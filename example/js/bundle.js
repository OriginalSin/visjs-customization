(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var vis = require('vis');
require('../../index.js');

console.log(vis);

var container = document.getElementById('vis');
console.log(container);

// Create a DataSet (allows two way data-binding)
var items = new vis.DataSet([
  {start: '2013-04'}
]);

// Configuration for the Timeline
var options = {
    // template: template,
    // align: 'right',                                                      // position
    autoResize: false,                                                       // better true, timeline center point stays at the same place
    multiselect: true,
    // configure: true,
    // dataAttributes: 'all',
    // editable: true,
    // groupEditable: true,
};

// Create a Timeline
var timeline = new vis.Timeline(container, items, options);

},{"../../index.js":2,"vis":3}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
/**
 * vis.js
 * https://github.com/almende/vis
 *
 * A dynamic, browser-based visualization library.
 *
 * @version 4.17.0
 * @date    2016-11-05
 *
 * @license
 * Copyright (C) 2011-2016 Almende B.V, http://almende.com
 *
 * Vis.js is dual licensed under both
 *
 * * The Apache 2.0 License
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * and
 *
 * * The MIT License
 *   http://opensource.org/licenses/MIT
 *
 * Vis.js may be distributed under either license.
 */

"use strict";

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["vis"] = factory();
	else
		root["vis"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);

  // Graph3d
  util.extend(exports, __webpack_require__(7));

  // Timeline & Graph2d
  util.extend(exports, __webpack_require__(26));

  // Network
  util.extend(exports, __webpack_require__(62));

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  // utility functions

  // first check if moment.js is already loaded in the browser window, if so,
  // use this instance. Else, load via commonjs.


  var moment = __webpack_require__(2);
  var uuid = __webpack_require__(6);

  /**
   * Test whether given object is a number
   * @param {*} object
   * @return {Boolean} isNumber
   */
  exports.isNumber = function (object) {
    return object instanceof Number || typeof object == 'number';
  };

  /**
   * Remove everything in the DOM object
   * @param DOMobject
   */
  exports.recursiveDOMDelete = function (DOMobject) {
    if (DOMobject) {
      while (DOMobject.hasChildNodes() === true) {
        exports.recursiveDOMDelete(DOMobject.firstChild);
        DOMobject.removeChild(DOMobject.firstChild);
      }
    }
  };

  /**
   * this function gives you a range between 0 and 1 based on the min and max values in the set, the total sum of all values and the current value.
   *
   * @param min
   * @param max
   * @param total
   * @param value
   * @returns {number}
   */
  exports.giveRange = function (min, max, total, value) {
    if (max == min) {
      return 0.5;
    } else {
      var scale = 1 / (max - min);
      return Math.max(0, (value - min) * scale);
    }
  };

  /**
   * Test whether given object is a string
   * @param {*} object
   * @return {Boolean} isString
   */
  exports.isString = function (object) {
    return object instanceof String || typeof object == 'string';
  };

  /**
   * Test whether given object is a Date, or a String containing a Date
   * @param {Date | String} object
   * @return {Boolean} isDate
   */
  exports.isDate = function (object) {
    if (object instanceof Date) {
      return true;
    } else if (exports.isString(object)) {
      // test whether this string contains a date
      var match = ASPDateRegex.exec(object);
      if (match) {
        return true;
      } else if (!isNaN(Date.parse(object))) {
        return true;
      }
    }

    return false;
  };

  /**
   * Create a semi UUID
   * source: http://stackoverflow.com/a/105074/1262753
   * @return {String} uuid
   */
  exports.randomUUID = function () {
    return uuid.v4();
  };

  /**
   * assign all keys of an object that are not nested objects to a certain value (used for color objects).
   * @param obj
   * @param value
   */
  exports.assignAllKeys = function (obj, value) {
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        if (_typeof(obj[prop]) !== 'object') {
          obj[prop] = value;
        }
      }
    }
  };

  /**
   * Fill an object with a possibly partially defined other object. Only copies values if the a object has an object requiring values.
   * That means an object is not created on a property if only the b object has it.
   * @param obj
   * @param value
   */
  exports.fillIfDefined = function (a, b) {
    var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    for (var prop in a) {
      if (b[prop] !== undefined) {
        if (_typeof(b[prop]) !== 'object') {
          if ((b[prop] === undefined || b[prop] === null) && a[prop] !== undefined && allowDeletion === true) {
            delete a[prop];
          } else {
            a[prop] = b[prop];
          }
        } else {
          if (_typeof(a[prop]) === 'object') {
            exports.fillIfDefined(a[prop], b[prop], allowDeletion);
          }
        }
      }
    }
  };

  /**
   * Extend object a with the properties of object b or a series of objects
   * Only properties with defined values are copied
   * @param {Object} a
   * @param {... Object} b
   * @return {Object} a
   */
  exports.protoExtend = function (a, b) {
    for (var i = 1; i < arguments.length; i++) {
      var other = arguments[i];
      for (var prop in other) {
        a[prop] = other[prop];
      }
    }
    return a;
  };

  /**
   * Extend object a with the properties of object b or a series of objects
   * Only properties with defined values are copied
   * @param {Object} a
   * @param {... Object} b
   * @return {Object} a
   */
  exports.extend = function (a, b) {
    for (var i = 1; i < arguments.length; i++) {
      var other = arguments[i];
      for (var prop in other) {
        if (other.hasOwnProperty(prop)) {
          a[prop] = other[prop];
        }
      }
    }
    return a;
  };

  /**
   * Extend object a with selected properties of object b or a series of objects
   * Only properties with defined values are copied
   * @param {Array.<String>} props
   * @param {Object} a
   * @param {Object} b
   * @return {Object} a
   */
  exports.selectiveExtend = function (props, a, b) {
    if (!Array.isArray(props)) {
      throw new Error('Array with property names expected as first argument');
    }

    for (var i = 2; i < arguments.length; i++) {
      var other = arguments[i];

      for (var p = 0; p < props.length; p++) {
        var prop = props[p];
        if (other.hasOwnProperty(prop)) {
          a[prop] = other[prop];
        }
      }
    }
    return a;
  };

  /**
   * Extend object a with selected properties of object b or a series of objects
   * Only properties with defined values are copied
   * @param {Array.<String>} props
   * @param {Object} a
   * @param {Object} b
   * @return {Object} a
   */
  exports.selectiveDeepExtend = function (props, a, b) {
    var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    // TODO: add support for Arrays to deepExtend
    if (Array.isArray(b)) {
      throw new TypeError('Arrays are not supported by deepExtend');
    }
    for (var i = 2; i < arguments.length; i++) {
      var other = arguments[i];
      for (var p = 0; p < props.length; p++) {
        var prop = props[p];
        if (other.hasOwnProperty(prop)) {
          if (b[prop] && b[prop].constructor === Object) {
            if (a[prop] === undefined) {
              a[prop] = {};
            }
            if (a[prop].constructor === Object) {
              exports.deepExtend(a[prop], b[prop], false, allowDeletion);
            } else {
              if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
                delete a[prop];
              } else {
                a[prop] = b[prop];
              }
            }
          } else if (Array.isArray(b[prop])) {
            throw new TypeError('Arrays are not supported by deepExtend');
          } else {
            if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
              delete a[prop];
            } else {
              a[prop] = b[prop];
            }
          }
        }
      }
    }
    return a;
  };

  /**
   * Extend object a with selected properties of object b or a series of objects
   * Only properties with defined values are copied
   * @param {Array.<String>} props
   * @param {Object} a
   * @param {Object} b
   * @return {Object} a
   */
  exports.selectiveNotDeepExtend = function (props, a, b) {
    var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    // TODO: add support for Arrays to deepExtend
    if (Array.isArray(b)) {
      throw new TypeError('Arrays are not supported by deepExtend');
    }
    for (var prop in b) {
      if (b.hasOwnProperty(prop)) {
        if (props.indexOf(prop) == -1) {
          if (b[prop] && b[prop].constructor === Object) {
            if (a[prop] === undefined) {
              a[prop] = {};
            }
            if (a[prop].constructor === Object) {
              exports.deepExtend(a[prop], b[prop]);
            } else {
              if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
                delete a[prop];
              } else {
                a[prop] = b[prop];
              }
            }
          } else if (Array.isArray(b[prop])) {
            a[prop] = [];
            for (var i = 0; i < b[prop].length; i++) {
              a[prop].push(b[prop][i]);
            }
          } else {
            if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
              delete a[prop];
            } else {
              a[prop] = b[prop];
            }
          }
        }
      }
    }
    return a;
  };

  /**
   * Deep extend an object a with the properties of object b
   * @param {Object} a
   * @param {Object} b
   * @param [Boolean] protoExtend --> optional parameter. If true, the prototype values will also be extended.
   *                                  (ie. the options objects that inherit from others will also get the inherited options)
   * @param [Boolean] global      --> optional parameter. If true, the values of fields that are null will not deleted
   * @returns {Object}
   */
  exports.deepExtend = function (a, b, protoExtend, allowDeletion) {
    for (var prop in b) {
      if (b.hasOwnProperty(prop) || protoExtend === true) {
        if (b[prop] && b[prop].constructor === Object) {
          if (a[prop] === undefined) {
            a[prop] = {};
          }
          if (a[prop].constructor === Object) {
            exports.deepExtend(a[prop], b[prop], protoExtend);
          } else {
            if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
              delete a[prop];
            } else {
              a[prop] = b[prop];
            }
          }
        } else if (Array.isArray(b[prop])) {
          a[prop] = [];
          for (var i = 0; i < b[prop].length; i++) {
            a[prop].push(b[prop][i]);
          }
        } else {
          if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
            delete a[prop];
          } else {
            a[prop] = b[prop];
          }
        }
      }
    }
    return a;
  };

  /**
   * Test whether all elements in two arrays are equal.
   * @param {Array} a
   * @param {Array} b
   * @return {boolean} Returns true if both arrays have the same length and same
   *                   elements.
   */
  exports.equalArray = function (a, b) {
    if (a.length != b.length) return false;

    for (var i = 0, len = a.length; i < len; i++) {
      if (a[i] != b[i]) return false;
    }

    return true;
  };

  /**
   * Convert an object to another type
   * @param {Boolean | Number | String | Date | Moment | Null | undefined} object
   * @param {String | undefined} type   Name of the type. Available types:
   *                                    'Boolean', 'Number', 'String',
   *                                    'Date', 'Moment', ISODate', 'ASPDate'.
   * @return {*} object
   * @throws Error
   */
  exports.convert = function (object, type) {
    var match;

    if (object === undefined) {
      return undefined;
    }
    if (object === null) {
      return null;
    }

    if (!type) {
      return object;
    }
    if (!(typeof type === 'string') && !(type instanceof String)) {
      throw new Error('Type must be a string');
    }

    //noinspection FallthroughInSwitchStatementJS
    switch (type) {
      case 'boolean':
      case 'Boolean':
        return Boolean(object);

      case 'number':
      case 'Number':
        if (!isNaN(Date.parse(object))) {
          return moment(object).valueOf();
        } else {
          return Number(object.valueOf());
        }
      case 'string':
      case 'String':
        return String(object);

      case 'Date':
        if (exports.isNumber(object)) {
          return new Date(object);
        }
        if (object instanceof Date) {
          return new Date(object.valueOf());
        } else if (moment.isMoment(object)) {
          return new Date(object.valueOf());
        }
        if (exports.isString(object)) {
          match = ASPDateRegex.exec(object);
          if (match) {
            // object is an ASP date
            return new Date(Number(match[1])); // parse number
          } else {
            return moment(new Date(object)).toDate(); // parse string
          }
        } else {
          throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type Date');
        }

      case 'Moment':
        if (exports.isNumber(object)) {
          return moment(object);
        }
        if (object instanceof Date) {
          return moment(object.valueOf());
        } else if (moment.isMoment(object)) {
          return moment(object);
        }
        if (exports.isString(object)) {
          match = ASPDateRegex.exec(object);
          if (match) {
            // object is an ASP date
            return moment(Number(match[1])); // parse number
          } else {
            return moment(object); // parse string
          }
        } else {
          throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type Date');
        }

      case 'ISODate':
        if (exports.isNumber(object)) {
          return new Date(object);
        } else if (object instanceof Date) {
          return object.toISOString();
        } else if (moment.isMoment(object)) {
          return object.toDate().toISOString();
        } else if (exports.isString(object)) {
          match = ASPDateRegex.exec(object);
          if (match) {
            // object is an ASP date
            return new Date(Number(match[1])).toISOString(); // parse number
          } else {
            return moment(object).format(); // ISO 8601
          }
        } else {
          throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type ISODate');
        }

      case 'ASPDate':
        if (exports.isNumber(object)) {
          return '/Date(' + object + ')/';
        } else if (object instanceof Date) {
          return '/Date(' + object.valueOf() + ')/';
        } else if (exports.isString(object)) {
          match = ASPDateRegex.exec(object);
          var value;
          if (match) {
            // object is an ASP date
            value = new Date(Number(match[1])).valueOf(); // parse number
          } else {
            value = new Date(object).valueOf(); // parse string
          }
          return '/Date(' + value + ')/';
        } else {
          throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type ASPDate');
        }

      default:
        throw new Error('Unknown type "' + type + '"');
    }
  };

  // parse ASP.Net Date pattern,
  // for example '/Date(1198908717056)/' or '/Date(1198908717056-0700)/'
  // code from http://momentjs.com/
  var ASPDateRegex = /^\/?Date\((\-?\d+)/i;

  /**
   * Get the type of an object, for example exports.getType([]) returns 'Array'
   * @param {*} object
   * @return {String} type
   */
  exports.getType = function (object) {
    var type = typeof object === 'undefined' ? 'undefined' : _typeof(object);

    if (type == 'object') {
      if (object === null) {
        return 'null';
      }
      if (object instanceof Boolean) {
        return 'Boolean';
      }
      if (object instanceof Number) {
        return 'Number';
      }
      if (object instanceof String) {
        return 'String';
      }
      if (Array.isArray(object)) {
        return 'Array';
      }
      if (object instanceof Date) {
        return 'Date';
      }
      return 'Object';
    } else if (type == 'number') {
      return 'Number';
    } else if (type == 'boolean') {
      return 'Boolean';
    } else if (type == 'string') {
      return 'String';
    } else if (type === undefined) {
      return 'undefined';
    }

    return type;
  };

  /**
   * Used to extend an array and copy it. This is used to propagate paths recursively.
   *
   * @param arr
   * @param newValue
   * @returns {Array}
   */
  exports.copyAndExtendArray = function (arr, newValue) {
    var newArr = [];
    for (var i = 0; i < arr.length; i++) {
      newArr.push(arr[i]);
    }
    newArr.push(newValue);
    return newArr;
  };

  /**
   * Used to extend an array and copy it. This is used to propagate paths recursively.
   *
   * @param arr
   * @param newValue
   * @returns {Array}
   */
  exports.copyArray = function (arr) {
    var newArr = [];
    for (var i = 0; i < arr.length; i++) {
      newArr.push(arr[i]);
    }
    return newArr;
  };

  /**
   * Retrieve the absolute left value of a DOM element
   * @param {Element} elem        A dom element, for example a div
   * @return {number} left        The absolute left position of this element
   *                              in the browser page.
   */
  exports.getAbsoluteLeft = function (elem) {
    return elem.getBoundingClientRect().left;
  };

  exports.getAbsoluteRight = function (elem) {
    return elem.getBoundingClientRect().right;
  };

  /**
   * Retrieve the absolute top value of a DOM element
   * @param {Element} elem        A dom element, for example a div
   * @return {number} top        The absolute top position of this element
   *                              in the browser page.
   */
  exports.getAbsoluteTop = function (elem) {
    return elem.getBoundingClientRect().top;
  };

  /**
   * add a className to the given elements style
   * @param {Element} elem
   * @param {String} className
   */
  exports.addClassName = function (elem, className) {
    var classes = elem.className.split(' ');
    if (classes.indexOf(className) == -1) {
      classes.push(className); // add the class to the array
      elem.className = classes.join(' ');
    }
  };

  /**
   * add a className to the given elements style
   * @param {Element} elem
   * @param {String} className
   */
  exports.removeClassName = function (elem, className) {
    var classes = elem.className.split(' ');
    var index = classes.indexOf(className);
    if (index != -1) {
      classes.splice(index, 1); // remove the class from the array
      elem.className = classes.join(' ');
    }
  };

  /**
   * For each method for both arrays and objects.
   * In case of an array, the built-in Array.forEach() is applied.
   * In case of an Object, the method loops over all properties of the object.
   * @param {Object | Array} object   An Object or Array
   * @param {function} callback       Callback method, called for each item in
   *                                  the object or array with three parameters:
   *                                  callback(value, index, object)
   */
  exports.forEach = function (object, callback) {
    var i, len;
    if (Array.isArray(object)) {
      // array
      for (i = 0, len = object.length; i < len; i++) {
        callback(object[i], i, object);
      }
    } else {
      // object
      for (i in object) {
        if (object.hasOwnProperty(i)) {
          callback(object[i], i, object);
        }
      }
    }
  };

  /**
   * Convert an object into an array: all objects properties are put into the
   * array. The resulting array is unordered.
   * @param {Object} object
   * @param {Array} array
   */
  exports.toArray = function (object) {
    var array = [];

    for (var prop in object) {
      if (object.hasOwnProperty(prop)) array.push(object[prop]);
    }

    return array;
  };

  /**
   * Update a property in an object
   * @param {Object} object
   * @param {String} key
   * @param {*} value
   * @return {Boolean} changed
   */
  exports.updateProperty = function (object, key, value) {
    if (object[key] !== value) {
      object[key] = value;
      return true;
    } else {
      return false;
    }
  };

  /**
   * Throttle the given function to be only executed once per animation frame
   * @param {function} fn
   * @returns {function} Returns the throttled function
   */
  exports.throttle = function (fn) {
    var scheduled = false;

    return function throttled() {
      if (!scheduled) {
        scheduled = true;
        requestAnimationFrame(function () {
          scheduled = false;
          fn();
        });
      }
    };
  };

  /**
   * Add and event listener. Works for all browsers
   * @param {Element}     element    An html element
   * @param {string}      action     The action, for example "click",
   *                                 without the prefix "on"
   * @param {function}    listener   The callback function to be executed
   * @param {boolean}     [useCapture]
   */
  exports.addEventListener = function (element, action, listener, useCapture) {
    if (element.addEventListener) {
      if (useCapture === undefined) useCapture = false;

      if (action === "mousewheel" && navigator.userAgent.indexOf("Firefox") >= 0) {
        action = "DOMMouseScroll"; // For Firefox
      }

      element.addEventListener(action, listener, useCapture);
    } else {
      element.attachEvent("on" + action, listener); // IE browsers
    }
  };

  /**
   * Remove an event listener from an element
   * @param {Element}     element         An html dom element
   * @param {string}      action          The name of the event, for example "mousedown"
   * @param {function}    listener        The listener function
   * @param {boolean}     [useCapture]
   */
  exports.removeEventListener = function (element, action, listener, useCapture) {
    if (element.removeEventListener) {
      // non-IE browsers
      if (useCapture === undefined) useCapture = false;

      if (action === "mousewheel" && navigator.userAgent.indexOf("Firefox") >= 0) {
        action = "DOMMouseScroll"; // For Firefox
      }

      element.removeEventListener(action, listener, useCapture);
    } else {
      // IE browsers
      element.detachEvent("on" + action, listener);
    }
  };

  /**
   * Cancels the event if it is cancelable, without stopping further propagation of the event.
   */
  exports.preventDefault = function (event) {
    if (!event) event = window.event;

    if (event.preventDefault) {
      event.preventDefault(); // non-IE browsers
    } else {
      event.returnValue = false; // IE browsers
    }
  };

  /**
   * Get HTML element which is the target of the event
   * @param {Event} event
   * @return {Element} target element
   */
  exports.getTarget = function (event) {
    // code from http://www.quirksmode.org/js/events_properties.html
    if (!event) {
      event = window.event;
    }

    var target;

    if (event.target) {
      target = event.target;
    } else if (event.srcElement) {
      target = event.srcElement;
    }

    if (target.nodeType != undefined && target.nodeType == 3) {
      // defeat Safari bug
      target = target.parentNode;
    }

    return target;
  };

  /**
   * Check if given element contains given parent somewhere in the DOM tree
   * @param {Element} element
   * @param {Element} parent
   */
  exports.hasParent = function (element, parent) {
    var e = element;

    while (e) {
      if (e === parent) {
        return true;
      }
      e = e.parentNode;
    }

    return false;
  };

  exports.option = {};

  /**
   * Convert a value into a boolean
   * @param {Boolean | function | undefined} value
   * @param {Boolean} [defaultValue]
   * @returns {Boolean} bool
   */
  exports.option.asBoolean = function (value, defaultValue) {
    if (typeof value == 'function') {
      value = value();
    }

    if (value != null) {
      return value != false;
    }

    return defaultValue || null;
  };

  /**
   * Convert a value into a number
   * @param {Boolean | function | undefined} value
   * @param {Number} [defaultValue]
   * @returns {Number} number
   */
  exports.option.asNumber = function (value, defaultValue) {
    if (typeof value == 'function') {
      value = value();
    }

    if (value != null) {
      return Number(value) || defaultValue || null;
    }

    return defaultValue || null;
  };

  /**
   * Convert a value into a string
   * @param {String | function | undefined} value
   * @param {String} [defaultValue]
   * @returns {String} str
   */
  exports.option.asString = function (value, defaultValue) {
    if (typeof value == 'function') {
      value = value();
    }

    if (value != null) {
      return String(value);
    }

    return defaultValue || null;
  };

  /**
   * Convert a size or location into a string with pixels or a percentage
   * @param {String | Number | function | undefined} value
   * @param {String} [defaultValue]
   * @returns {String} size
   */
  exports.option.asSize = function (value, defaultValue) {
    if (typeof value == 'function') {
      value = value();
    }

    if (exports.isString(value)) {
      return value;
    } else if (exports.isNumber(value)) {
      return value + 'px';
    } else {
      return defaultValue || null;
    }
  };

  /**
   * Convert a value into a DOM element
   * @param {HTMLElement | function | undefined} value
   * @param {HTMLElement} [defaultValue]
   * @returns {HTMLElement | null} dom
   */
  exports.option.asElement = function (value, defaultValue) {
    if (typeof value == 'function') {
      value = value();
    }

    return value || defaultValue || null;
  };

  /**
   * http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
   *
   * @param {String} hex
   * @returns {{r: *, g: *, b: *}} | 255 range
   */
  exports.hexToRGB = function (hex) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, function (m, r, g, b) {
      return r + r + g + g + b + b;
    });
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  };

  /**
   * This function takes color in hex format or rgb() or rgba() format and overrides the opacity. Returns rgba() string.
   * @param color
   * @param opacity
   * @returns {*}
   */
  exports.overrideOpacity = function (color, opacity) {
    if (color.indexOf("rgba") != -1) {
      return color;
    } else if (color.indexOf("rgb") != -1) {
      var rgb = color.substr(color.indexOf("(") + 1).replace(")", "").split(",");
      return "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + "," + opacity + ")";
    } else {
      var rgb = exports.hexToRGB(color);
      if (rgb == null) {
        return color;
      } else {
        return "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + opacity + ")";
      }
    }
  };

  /**
   *
   * @param red     0 -- 255
   * @param green   0 -- 255
   * @param blue    0 -- 255
   * @returns {string}
   * @constructor
   */
  exports.RGBToHex = function (red, green, blue) {
    return "#" + ((1 << 24) + (red << 16) + (green << 8) + blue).toString(16).slice(1);
  };

  /**
   * Parse a color property into an object with border, background, and
   * highlight colors
   * @param {Object | String} color
   * @return {Object} colorObject
   */
  exports.parseColor = function (color) {
    var c;
    if (exports.isString(color) === true) {
      if (exports.isValidRGB(color) === true) {
        var rgb = color.substr(4).substr(0, color.length - 5).split(',').map(function (value) {
          return parseInt(value);
        });
        color = exports.RGBToHex(rgb[0], rgb[1], rgb[2]);
      }
      if (exports.isValidHex(color) === true) {
        var hsv = exports.hexToHSV(color);
        var lighterColorHSV = { h: hsv.h, s: hsv.s * 0.8, v: Math.min(1, hsv.v * 1.02) };
        var darkerColorHSV = { h: hsv.h, s: Math.min(1, hsv.s * 1.25), v: hsv.v * 0.8 };
        var darkerColorHex = exports.HSVToHex(darkerColorHSV.h, darkerColorHSV.s, darkerColorHSV.v);
        var lighterColorHex = exports.HSVToHex(lighterColorHSV.h, lighterColorHSV.s, lighterColorHSV.v);
        c = {
          background: color,
          border: darkerColorHex,
          highlight: {
            background: lighterColorHex,
            border: darkerColorHex
          },
          hover: {
            background: lighterColorHex,
            border: darkerColorHex
          }
        };
      } else {
        c = {
          background: color,
          border: color,
          highlight: {
            background: color,
            border: color
          },
          hover: {
            background: color,
            border: color
          }
        };
      }
    } else {
      c = {};
      c.background = color.background || undefined;
      c.border = color.border || undefined;

      if (exports.isString(color.highlight)) {
        c.highlight = {
          border: color.highlight,
          background: color.highlight
        };
      } else {
        c.highlight = {};
        c.highlight.background = color.highlight && color.highlight.background || undefined;
        c.highlight.border = color.highlight && color.highlight.border || undefined;
      }

      if (exports.isString(color.hover)) {
        c.hover = {
          border: color.hover,
          background: color.hover
        };
      } else {
        c.hover = {};
        c.hover.background = color.hover && color.hover.background || undefined;
        c.hover.border = color.hover && color.hover.border || undefined;
      }
    }

    return c;
  };

  /**
   * http://www.javascripter.net/faq/rgb2hsv.htm
   *
   * @param red
   * @param green
   * @param blue
   * @returns {*}
   * @constructor
   */
  exports.RGBToHSV = function (red, green, blue) {
    red = red / 255;green = green / 255;blue = blue / 255;
    var minRGB = Math.min(red, Math.min(green, blue));
    var maxRGB = Math.max(red, Math.max(green, blue));

    // Black-gray-white
    if (minRGB == maxRGB) {
      return { h: 0, s: 0, v: minRGB };
    }

    // Colors other than black-gray-white:
    var d = red == minRGB ? green - blue : blue == minRGB ? red - green : blue - red;
    var h = red == minRGB ? 3 : blue == minRGB ? 1 : 5;
    var hue = 60 * (h - d / (maxRGB - minRGB)) / 360;
    var saturation = (maxRGB - minRGB) / maxRGB;
    var value = maxRGB;
    return { h: hue, s: saturation, v: value };
  };

  var cssUtil = {
    // split a string with css styles into an object with key/values
    split: function split(cssText) {
      var styles = {};

      cssText.split(';').forEach(function (style) {
        if (style.trim() != '') {
          var parts = style.split(':');
          var key = parts[0].trim();
          var value = parts[1].trim();
          styles[key] = value;
        }
      });

      return styles;
    },

    // build a css text string from an object with key/values
    join: function join(styles) {
      return Object.keys(styles).map(function (key) {
        return key + ': ' + styles[key];
      }).join('; ');
    }
  };

  /**
   * Append a string with css styles to an element
   * @param {Element} element
   * @param {String} cssText
   */
  exports.addCssText = function (element, cssText) {
    var currentStyles = cssUtil.split(element.style.cssText);
    var newStyles = cssUtil.split(cssText);
    var styles = exports.extend(currentStyles, newStyles);

    element.style.cssText = cssUtil.join(styles);
  };

  /**
   * Remove a string with css styles from an element
   * @param {Element} element
   * @param {String} cssText
   */
  exports.removeCssText = function (element, cssText) {
    var styles = cssUtil.split(element.style.cssText);
    var removeStyles = cssUtil.split(cssText);

    for (var key in removeStyles) {
      if (removeStyles.hasOwnProperty(key)) {
        delete styles[key];
      }
    }

    element.style.cssText = cssUtil.join(styles);
  };

  /**
   * https://gist.github.com/mjijackson/5311256
   * @param h
   * @param s
   * @param v
   * @returns {{r: number, g: number, b: number}}
   * @constructor
   */
  exports.HSVToRGB = function (h, s, v) {
    var r, g, b;

    var i = Math.floor(h * 6);
    var f = h * 6 - i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);

    switch (i % 6) {
      case 0:
        r = v, g = t, b = p;break;
      case 1:
        r = q, g = v, b = p;break;
      case 2:
        r = p, g = v, b = t;break;
      case 3:
        r = p, g = q, b = v;break;
      case 4:
        r = t, g = p, b = v;break;
      case 5:
        r = v, g = p, b = q;break;
    }

    return { r: Math.floor(r * 255), g: Math.floor(g * 255), b: Math.floor(b * 255) };
  };

  exports.HSVToHex = function (h, s, v) {
    var rgb = exports.HSVToRGB(h, s, v);
    return exports.RGBToHex(rgb.r, rgb.g, rgb.b);
  };

  exports.hexToHSV = function (hex) {
    var rgb = exports.hexToRGB(hex);
    return exports.RGBToHSV(rgb.r, rgb.g, rgb.b);
  };

  exports.isValidHex = function (hex) {
    var isOk = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);
    return isOk;
  };

  exports.isValidRGB = function (rgb) {
    rgb = rgb.replace(" ", "");
    var isOk = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/i.test(rgb);
    return isOk;
  };
  exports.isValidRGBA = function (rgba) {
    rgba = rgba.replace(" ", "");
    var isOk = /rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),(.{1,3})\)/i.test(rgba);
    return isOk;
  };

  /**
   * This recursively redirects the prototype of JSON objects to the referenceObject
   * This is used for default options.
   *
   * @param referenceObject
   * @returns {*}
   */
  exports.selectiveBridgeObject = function (fields, referenceObject) {
    if ((typeof referenceObject === 'undefined' ? 'undefined' : _typeof(referenceObject)) == "object") {
      var objectTo = Object.create(referenceObject);
      for (var i = 0; i < fields.length; i++) {
        if (referenceObject.hasOwnProperty(fields[i])) {
          if (_typeof(referenceObject[fields[i]]) == "object") {
            objectTo[fields[i]] = exports.bridgeObject(referenceObject[fields[i]]);
          }
        }
      }
      return objectTo;
    } else {
      return null;
    }
  };

  /**
   * This recursively redirects the prototype of JSON objects to the referenceObject
   * This is used for default options.
   *
   * @param referenceObject
   * @returns {*}
   */
  exports.bridgeObject = function (referenceObject) {
    if ((typeof referenceObject === 'undefined' ? 'undefined' : _typeof(referenceObject)) == "object") {
      var objectTo = Object.create(referenceObject);
      for (var i in referenceObject) {
        if (referenceObject.hasOwnProperty(i)) {
          if (_typeof(referenceObject[i]) == "object") {
            objectTo[i] = exports.bridgeObject(referenceObject[i]);
          }
        }
      }
      return objectTo;
    } else {
      return null;
    }
  };

  /**
   * This method provides a stable sort implementation, very fast for presorted data
   *
   * @param a the array
   * @param a order comparator
   * @returns {the array}
   */
  exports.insertSort = function (a, compare) {
    for (var i = 0; i < a.length; i++) {
      var k = a[i];
      for (var j = i; j > 0 && compare(k, a[j - 1]) < 0; j--) {
        a[j] = a[j - 1];
      }
      a[j] = k;
    }
    return a;
  };

  /**
   * this is used to set the options of subobjects in the options object. A requirement of these subobjects
   * is that they have an 'enabled' element which is optional for the user but mandatory for the program.
   *
   * @param [object] mergeTarget | this is either this.options or the options used for the groups.
   * @param [object] options     | options
   * @param [String] option      | this is the option key in the options argument
   */
  exports.mergeOptions = function (mergeTarget, options, option) {
    var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var globalOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

    if (options[option] === null) {
      mergeTarget[option] = Object.create(globalOptions[option]);
    } else {
      if (options[option] !== undefined) {
        if (typeof options[option] === 'boolean') {
          mergeTarget[option].enabled = options[option];
        } else {
          if (options[option].enabled === undefined) {
            mergeTarget[option].enabled = true;
          }
          for (var prop in options[option]) {
            if (options[option].hasOwnProperty(prop)) {
              mergeTarget[option][prop] = options[option][prop];
            }
          }
        }
      }
    }
  };

  /**
   * This function does a binary search for a visible item in a sorted list. If we find a visible item, the code that uses
   * this function will then iterate in both directions over this sorted list to find all visible items.
   *
   * @param {Item[]} orderedItems       | Items ordered by start
   * @param {function} comparator       | -1 is lower, 0 is equal, 1 is higher
   * @param {String} field
   * @param {String} field2
   * @returns {number}
   * @private
   */
  exports.binarySearchCustom = function (orderedItems, comparator, field, field2) {
    var maxIterations = 10000;
    var iteration = 0;
    var low = 0;
    var high = orderedItems.length - 1;

    while (low <= high && iteration < maxIterations) {
      var middle = Math.floor((low + high) / 2);

      var item = orderedItems[middle];
      var value = field2 === undefined ? item[field] : item[field][field2];

      var searchResult = comparator(value);
      if (searchResult == 0) {
        // jihaa, found a visible item!
        return middle;
      } else if (searchResult == -1) {
        // it is too small --> increase low
        low = middle + 1;
      } else {
        // it is too big --> decrease high
        high = middle - 1;
      }

      iteration++;
    }

    return -1;
  };

  /**
   * This function does a binary search for a specific value in a sorted array. If it does not exist but is in between of
   * two values, we return either the one before or the one after, depending on user input
   * If it is found, we return the index, else -1.
   *
   * @param {Array} orderedItems
   * @param {{start: number, end: number}} target
   * @param {String} field
   * @param {String} sidePreference   'before' or 'after'
   * @param {function} comparator an optional comparator, returning -1,0,1 for <,==,>.
   * @returns {number}
   * @private
   */
  exports.binarySearchValue = function (orderedItems, target, field, sidePreference, comparator) {
    var maxIterations = 10000;
    var iteration = 0;
    var low = 0;
    var high = orderedItems.length - 1;
    var prevValue, value, nextValue, middle;

    var comparator = comparator != undefined ? comparator : function (a, b) {
      return a == b ? 0 : a < b ? -1 : 1;
    };

    while (low <= high && iteration < maxIterations) {
      // get a new guess
      middle = Math.floor(0.5 * (high + low));
      prevValue = orderedItems[Math.max(0, middle - 1)][field];
      value = orderedItems[middle][field];
      nextValue = orderedItems[Math.min(orderedItems.length - 1, middle + 1)][field];

      if (comparator(value, target) == 0) {
        // we found the target
        return middle;
      } else if (comparator(prevValue, target) < 0 && comparator(value, target) > 0) {
        // target is in between of the previous and the current
        return sidePreference == 'before' ? Math.max(0, middle - 1) : middle;
      } else if (comparator(value, target) < 0 && comparator(nextValue, target) > 0) {
        // target is in between of the current and the next
        return sidePreference == 'before' ? middle : Math.min(orderedItems.length - 1, middle + 1);
      } else {
        // didnt find the target, we need to change our boundaries.
        if (comparator(value, target) < 0) {
          // it is too small --> increase low
          low = middle + 1;
        } else {
          // it is too big --> decrease high
          high = middle - 1;
        }
      }
      iteration++;
    }

    // didnt find anything. Return -1.
    return -1;
  };

  /*
   * Easing Functions - inspired from http://gizma.com/easing/
   * only considering the t value for the range [0, 1] => [0, 1]
   * https://gist.github.com/gre/1650294
   */
  exports.easingFunctions = {
    // no easing, no acceleration
    linear: function linear(t) {
      return t;
    },
    // accelerating from zero velocity
    easeInQuad: function easeInQuad(t) {
      return t * t;
    },
    // decelerating to zero velocity
    easeOutQuad: function easeOutQuad(t) {
      return t * (2 - t);
    },
    // acceleration until halfway, then deceleration
    easeInOutQuad: function easeInOutQuad(t) {
      return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    },
    // accelerating from zero velocity
    easeInCubic: function easeInCubic(t) {
      return t * t * t;
    },
    // decelerating to zero velocity
    easeOutCubic: function easeOutCubic(t) {
      return --t * t * t + 1;
    },
    // acceleration until halfway, then deceleration
    easeInOutCubic: function easeInOutCubic(t) {
      return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
    },
    // accelerating from zero velocity
    easeInQuart: function easeInQuart(t) {
      return t * t * t * t;
    },
    // decelerating to zero velocity
    easeOutQuart: function easeOutQuart(t) {
      return 1 - --t * t * t * t;
    },
    // acceleration until halfway, then deceleration
    easeInOutQuart: function easeInOutQuart(t) {
      return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
    },
    // accelerating from zero velocity
    easeInQuint: function easeInQuint(t) {
      return t * t * t * t * t;
    },
    // decelerating to zero velocity
    easeOutQuint: function easeOutQuint(t) {
      return 1 + --t * t * t * t * t;
    },
    // acceleration until halfway, then deceleration
    easeInOutQuint: function easeInOutQuint(t) {
      return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
    }
  };

  exports.getScrollBarWidth = function () {
    var inner = document.createElement('p');
    inner.style.width = "100%";
    inner.style.height = "200px";

    var outer = document.createElement('div');
    outer.style.position = "absolute";
    outer.style.top = "0px";
    outer.style.left = "0px";
    outer.style.visibility = "hidden";
    outer.style.width = "200px";
    outer.style.height = "150px";
    outer.style.overflow = "hidden";
    outer.appendChild(inner);

    document.body.appendChild(outer);
    var w1 = inner.offsetWidth;
    outer.style.overflow = 'scroll';
    var w2 = inner.offsetWidth;
    if (w1 == w2) w2 = outer.clientWidth;

    document.body.removeChild(outer);

    return w1 - w2;
  };

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  // first check if moment.js is already loaded in the browser window, if so,
  // use this instance. Else, load via commonjs.
  module.exports = typeof window !== 'undefined' && window['moment'] || __webpack_require__(3);

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

  /* WEBPACK VAR INJECTION */(function(module) {//! moment.js
  //! version : 2.15.2
  //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
  //! license : MIT
  //! momentjs.com

  ;(function (global, factory) {
       true ? module.exports = factory() :
      typeof define === 'function' && define.amd ? define(factory) :
      global.moment = factory()
  }(this, function () { 'use strict';

      var hookCallback;

      function utils_hooks__hooks () {
          return hookCallback.apply(null, arguments);
      }

      // This is done to register the method called with moment()
      // without creating circular dependencies.
      function setHookCallback (callback) {
          hookCallback = callback;
      }

      function isArray(input) {
          return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
      }

      function isObject(input) {
          // IE8 will treat undefined and null as object if it wasn't for
          // input != null
          return input != null && Object.prototype.toString.call(input) === '[object Object]';
      }

      function isObjectEmpty(obj) {
          var k;
          for (k in obj) {
              // even if its not own property I'd still call it non-empty
              return false;
          }
          return true;
      }

      function isDate(input) {
          return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
      }

      function map(arr, fn) {
          var res = [], i;
          for (i = 0; i < arr.length; ++i) {
              res.push(fn(arr[i], i));
          }
          return res;
      }

      function hasOwnProp(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
      }

      function extend(a, b) {
          for (var i in b) {
              if (hasOwnProp(b, i)) {
                  a[i] = b[i];
              }
          }

          if (hasOwnProp(b, 'toString')) {
              a.toString = b.toString;
          }

          if (hasOwnProp(b, 'valueOf')) {
              a.valueOf = b.valueOf;
          }

          return a;
      }

      function create_utc__createUTC (input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, true).utc();
      }

      function defaultParsingFlags() {
          // We need to deep clone this object.
          return {
              empty           : false,
              unusedTokens    : [],
              unusedInput     : [],
              overflow        : -2,
              charsLeftOver   : 0,
              nullInput       : false,
              invalidMonth    : null,
              invalidFormat   : false,
              userInvalidated : false,
              iso             : false,
              parsedDateParts : [],
              meridiem        : null
          };
      }

      function getParsingFlags(m) {
          if (m._pf == null) {
              m._pf = defaultParsingFlags();
          }
          return m._pf;
      }

      var some;
      if (Array.prototype.some) {
          some = Array.prototype.some;
      } else {
          some = function (fun) {
              var t = Object(this);
              var len = t.length >>> 0;

              for (var i = 0; i < len; i++) {
                  if (i in t && fun.call(this, t[i], i, t)) {
                      return true;
                  }
              }

              return false;
          };
      }

      function valid__isValid(m) {
          if (m._isValid == null) {
              var flags = getParsingFlags(m);
              var parsedParts = some.call(flags.parsedDateParts, function (i) {
                  return i != null;
              });
              var isNowValid = !isNaN(m._d.getTime()) &&
                  flags.overflow < 0 &&
                  !flags.empty &&
                  !flags.invalidMonth &&
                  !flags.invalidWeekday &&
                  !flags.nullInput &&
                  !flags.invalidFormat &&
                  !flags.userInvalidated &&
                  (!flags.meridiem || (flags.meridiem && parsedParts));

              if (m._strict) {
                  isNowValid = isNowValid &&
                      flags.charsLeftOver === 0 &&
                      flags.unusedTokens.length === 0 &&
                      flags.bigHour === undefined;
              }

              if (Object.isFrozen == null || !Object.isFrozen(m)) {
                  m._isValid = isNowValid;
              }
              else {
                  return isNowValid;
              }
          }
          return m._isValid;
      }

      function valid__createInvalid (flags) {
          var m = create_utc__createUTC(NaN);
          if (flags != null) {
              extend(getParsingFlags(m), flags);
          }
          else {
              getParsingFlags(m).userInvalidated = true;
          }

          return m;
      }

      function isUndefined(input) {
          return input === void 0;
      }

      // Plugins that add properties should also add the key here (null value),
      // so we can properly clone ourselves.
      var momentProperties = utils_hooks__hooks.momentProperties = [];

      function copyConfig(to, from) {
          var i, prop, val;

          if (!isUndefined(from._isAMomentObject)) {
              to._isAMomentObject = from._isAMomentObject;
          }
          if (!isUndefined(from._i)) {
              to._i = from._i;
          }
          if (!isUndefined(from._f)) {
              to._f = from._f;
          }
          if (!isUndefined(from._l)) {
              to._l = from._l;
          }
          if (!isUndefined(from._strict)) {
              to._strict = from._strict;
          }
          if (!isUndefined(from._tzm)) {
              to._tzm = from._tzm;
          }
          if (!isUndefined(from._isUTC)) {
              to._isUTC = from._isUTC;
          }
          if (!isUndefined(from._offset)) {
              to._offset = from._offset;
          }
          if (!isUndefined(from._pf)) {
              to._pf = getParsingFlags(from);
          }
          if (!isUndefined(from._locale)) {
              to._locale = from._locale;
          }

          if (momentProperties.length > 0) {
              for (i in momentProperties) {
                  prop = momentProperties[i];
                  val = from[prop];
                  if (!isUndefined(val)) {
                      to[prop] = val;
                  }
              }
          }

          return to;
      }

      var updateInProgress = false;

      // Moment prototype object
      function Moment(config) {
          copyConfig(this, config);
          this._d = new Date(config._d != null ? config._d.getTime() : NaN);
          // Prevent infinite loop in case updateOffset creates new moment
          // objects.
          if (updateInProgress === false) {
              updateInProgress = true;
              utils_hooks__hooks.updateOffset(this);
              updateInProgress = false;
          }
      }

      function isMoment (obj) {
          return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
      }

      function absFloor (number) {
          if (number < 0) {
              // -0 -> 0
              return Math.ceil(number) || 0;
          } else {
              return Math.floor(number);
          }
      }

      function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion,
              value = 0;

          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
              value = absFloor(coercedNumber);
          }

          return value;
      }

      // compare two arrays, return the number of differences
      function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length),
              lengthDiff = Math.abs(array1.length - array2.length),
              diffs = 0,
              i;
          for (i = 0; i < len; i++) {
              if ((dontConvert && array1[i] !== array2[i]) ||
                  (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                  diffs++;
              }
          }
          return diffs + lengthDiff;
      }

      function warn(msg) {
          if (utils_hooks__hooks.suppressDeprecationWarnings === false &&
                  (typeof console !==  'undefined') && console.warn) {
              console.warn('Deprecation warning: ' + msg);
          }
      }

      function deprecate(msg, fn) {
          var firstTime = true;

          return extend(function () {
              if (utils_hooks__hooks.deprecationHandler != null) {
                  utils_hooks__hooks.deprecationHandler(null, msg);
              }
              if (firstTime) {
                  var args = [];
                  var arg;
                  for (var i = 0; i < arguments.length; i++) {
                      arg = '';
                      if (typeof arguments[i] === 'object') {
                          arg += '\n[' + i + '] ';
                          for (var key in arguments[0]) {
                              arg += key + ': ' + arguments[0][key] + ', ';
                          }
                          arg = arg.slice(0, -2); // Remove trailing comma and space
                      } else {
                          arg = arguments[i];
                      }
                      args.push(arg);
                  }
                  warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                  firstTime = false;
              }
              return fn.apply(this, arguments);
          }, fn);
      }

      var deprecations = {};

      function deprecateSimple(name, msg) {
          if (utils_hooks__hooks.deprecationHandler != null) {
              utils_hooks__hooks.deprecationHandler(name, msg);
          }
          if (!deprecations[name]) {
              warn(msg);
              deprecations[name] = true;
          }
      }

      utils_hooks__hooks.suppressDeprecationWarnings = false;
      utils_hooks__hooks.deprecationHandler = null;

      function isFunction(input) {
          return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
      }

      function locale_set__set (config) {
          var prop, i;
          for (i in config) {
              prop = config[i];
              if (isFunction(prop)) {
                  this[i] = prop;
              } else {
                  this['_' + i] = prop;
              }
          }
          this._config = config;
          // Lenient ordinal parsing accepts just a number in addition to
          // number + (possibly) stuff coming from _ordinalParseLenient.
          this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
      }

      function mergeConfigs(parentConfig, childConfig) {
          var res = extend({}, parentConfig), prop;
          for (prop in childConfig) {
              if (hasOwnProp(childConfig, prop)) {
                  if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                      res[prop] = {};
                      extend(res[prop], parentConfig[prop]);
                      extend(res[prop], childConfig[prop]);
                  } else if (childConfig[prop] != null) {
                      res[prop] = childConfig[prop];
                  } else {
                      delete res[prop];
                  }
              }
          }
          for (prop in parentConfig) {
              if (hasOwnProp(parentConfig, prop) &&
                      !hasOwnProp(childConfig, prop) &&
                      isObject(parentConfig[prop])) {
                  // make sure changes to properties don't modify parent config
                  res[prop] = extend({}, res[prop]);
              }
          }
          return res;
      }

      function Locale(config) {
          if (config != null) {
              this.set(config);
          }
      }

      var keys;

      if (Object.keys) {
          keys = Object.keys;
      } else {
          keys = function (obj) {
              var i, res = [];
              for (i in obj) {
                  if (hasOwnProp(obj, i)) {
                      res.push(i);
                  }
              }
              return res;
          };
      }

      var defaultCalendar = {
          sameDay : '[Today at] LT',
          nextDay : '[Tomorrow at] LT',
          nextWeek : 'dddd [at] LT',
          lastDay : '[Yesterday at] LT',
          lastWeek : '[Last] dddd [at] LT',
          sameElse : 'L'
      };

      function locale_calendar__calendar (key, mom, now) {
          var output = this._calendar[key] || this._calendar['sameElse'];
          return isFunction(output) ? output.call(mom, now) : output;
      }

      var defaultLongDateFormat = {
          LTS  : 'h:mm:ss A',
          LT   : 'h:mm A',
          L    : 'MM/DD/YYYY',
          LL   : 'MMMM D, YYYY',
          LLL  : 'MMMM D, YYYY h:mm A',
          LLLL : 'dddd, MMMM D, YYYY h:mm A'
      };

      function longDateFormat (key) {
          var format = this._longDateFormat[key],
              formatUpper = this._longDateFormat[key.toUpperCase()];

          if (format || !formatUpper) {
              return format;
          }

          this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
              return val.slice(1);
          });

          return this._longDateFormat[key];
      }

      var defaultInvalidDate = 'Invalid date';

      function invalidDate () {
          return this._invalidDate;
      }

      var defaultOrdinal = '%d';
      var defaultOrdinalParse = /\d{1,2}/;

      function ordinal (number) {
          return this._ordinal.replace('%d', number);
      }

      var defaultRelativeTime = {
          future : 'in %s',
          past   : '%s ago',
          s  : 'a few seconds',
          m  : 'a minute',
          mm : '%d minutes',
          h  : 'an hour',
          hh : '%d hours',
          d  : 'a day',
          dd : '%d days',
          M  : 'a month',
          MM : '%d months',
          y  : 'a year',
          yy : '%d years'
      };

      function relative__relativeTime (number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return (isFunction(output)) ?
              output(number, withoutSuffix, string, isFuture) :
              output.replace(/%d/i, number);
      }

      function pastFuture (diff, output) {
          var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
          return isFunction(format) ? format(output) : format.replace(/%s/i, output);
      }

      var aliases = {};

      function addUnitAlias (unit, shorthand) {
          var lowerCase = unit.toLowerCase();
          aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
      }

      function normalizeUnits(units) {
          return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
      }

      function normalizeObjectUnits(inputObject) {
          var normalizedInput = {},
              normalizedProp,
              prop;

          for (prop in inputObject) {
              if (hasOwnProp(inputObject, prop)) {
                  normalizedProp = normalizeUnits(prop);
                  if (normalizedProp) {
                      normalizedInput[normalizedProp] = inputObject[prop];
                  }
              }
          }

          return normalizedInput;
      }

      var priorities = {};

      function addUnitPriority(unit, priority) {
          priorities[unit] = priority;
      }

      function getPrioritizedUnits(unitsObj) {
          var units = [];
          for (var u in unitsObj) {
              units.push({unit: u, priority: priorities[u]});
          }
          units.sort(function (a, b) {
              return a.priority - b.priority;
          });
          return units;
      }

      function makeGetSet (unit, keepTime) {
          return function (value) {
              if (value != null) {
                  get_set__set(this, unit, value);
                  utils_hooks__hooks.updateOffset(this, keepTime);
                  return this;
              } else {
                  return get_set__get(this, unit);
              }
          };
      }

      function get_set__get (mom, unit) {
          return mom.isValid() ?
              mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
      }

      function get_set__set (mom, unit, value) {
          if (mom.isValid()) {
              mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
          }
      }

      // MOMENTS

      function stringGet (units) {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
              return this[units]();
          }
          return this;
      }


      function stringSet (units, value) {
          if (typeof units === 'object') {
              units = normalizeObjectUnits(units);
              var prioritized = getPrioritizedUnits(units);
              for (var i = 0; i < prioritized.length; i++) {
                  this[prioritized[i].unit](units[prioritized[i].unit]);
              }
          } else {
              units = normalizeUnits(units);
              if (isFunction(this[units])) {
                  return this[units](value);
              }
          }
          return this;
      }

      function zeroFill(number, targetLength, forceSign) {
          var absNumber = '' + Math.abs(number),
              zerosToFill = targetLength - absNumber.length,
              sign = number >= 0;
          return (sign ? (forceSign ? '+' : '') : '-') +
              Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }

      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

      var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

      var formatFunctions = {};

      var formatTokenFunctions = {};

      // token:    'M'
      // padded:   ['MM', 2]
      // ordinal:  'Mo'
      // callback: function () { this.month() + 1 }
      function addFormatToken (token, padded, ordinal, callback) {
          var func = callback;
          if (typeof callback === 'string') {
              func = function () {
                  return this[callback]();
              };
          }
          if (token) {
              formatTokenFunctions[token] = func;
          }
          if (padded) {
              formatTokenFunctions[padded[0]] = function () {
                  return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
              };
          }
          if (ordinal) {
              formatTokenFunctions[ordinal] = function () {
                  return this.localeData().ordinal(func.apply(this, arguments), token);
              };
          }
      }

      function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
              return input.replace(/^\[|\]$/g, '');
          }
          return input.replace(/\\/g, '');
      }

      function makeFormatFunction(format) {
          var array = format.match(formattingTokens), i, length;

          for (i = 0, length = array.length; i < length; i++) {
              if (formatTokenFunctions[array[i]]) {
                  array[i] = formatTokenFunctions[array[i]];
              } else {
                  array[i] = removeFormattingTokens(array[i]);
              }
          }

          return function (mom) {
              var output = '', i;
              for (i = 0; i < length; i++) {
                  output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
              }
              return output;
          };
      }

      // format date using native date object
      function formatMoment(m, format) {
          if (!m.isValid()) {
              return m.localeData().invalidDate();
          }

          format = expandFormat(format, m.localeData());
          formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

          return formatFunctions[format](m);
      }

      function expandFormat(format, locale) {
          var i = 5;

          function replaceLongDateFormatTokens(input) {
              return locale.longDateFormat(input) || input;
          }

          localFormattingTokens.lastIndex = 0;
          while (i >= 0 && localFormattingTokens.test(format)) {
              format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
              localFormattingTokens.lastIndex = 0;
              i -= 1;
          }

          return format;
      }

      var match1         = /\d/;            //       0 - 9
      var match2         = /\d\d/;          //      00 - 99
      var match3         = /\d{3}/;         //     000 - 999
      var match4         = /\d{4}/;         //    0000 - 9999
      var match6         = /[+-]?\d{6}/;    // -999999 - 999999
      var match1to2      = /\d\d?/;         //       0 - 99
      var match3to4      = /\d\d\d\d?/;     //     999 - 9999
      var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
      var match1to3      = /\d{1,3}/;       //       0 - 999
      var match1to4      = /\d{1,4}/;       //       0 - 9999
      var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

      var matchUnsigned  = /\d+/;           //       0 - inf
      var matchSigned    = /[+-]?\d+/;      //    -inf - inf

      var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
      var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

      var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

      // any word (or two) characters or numbers including two/three word month in arabic.
      // includes scottish gaelic two word and hyphenated months
      var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


      var regexes = {};

      function addRegexToken (token, regex, strictRegex) {
          regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
              return (isStrict && strictRegex) ? strictRegex : regex;
          };
      }

      function getParseRegexForToken (token, config) {
          if (!hasOwnProp(regexes, token)) {
              return new RegExp(unescapeFormat(token));
          }

          return regexes[token](config._strict, config._locale);
      }

      // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
      function unescapeFormat(s) {
          return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
              return p1 || p2 || p3 || p4;
          }));
      }

      function regexEscape(s) {
          return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
      }

      var tokens = {};

      function addParseToken (token, callback) {
          var i, func = callback;
          if (typeof token === 'string') {
              token = [token];
          }
          if (typeof callback === 'number') {
              func = function (input, array) {
                  array[callback] = toInt(input);
              };
          }
          for (i = 0; i < token.length; i++) {
              tokens[token[i]] = func;
          }
      }

      function addWeekParseToken (token, callback) {
          addParseToken(token, function (input, array, config, token) {
              config._w = config._w || {};
              callback(input, config._w, config, token);
          });
      }

      function addTimeToArrayFromToken(token, input, config) {
          if (input != null && hasOwnProp(tokens, token)) {
              tokens[token](input, config._a, config, token);
          }
      }

      var YEAR = 0;
      var MONTH = 1;
      var DATE = 2;
      var HOUR = 3;
      var MINUTE = 4;
      var SECOND = 5;
      var MILLISECOND = 6;
      var WEEK = 7;
      var WEEKDAY = 8;

      var indexOf;

      if (Array.prototype.indexOf) {
          indexOf = Array.prototype.indexOf;
      } else {
          indexOf = function (o) {
              // I know
              var i;
              for (i = 0; i < this.length; ++i) {
                  if (this[i] === o) {
                      return i;
                  }
              }
              return -1;
          };
      }

      function daysInMonth(year, month) {
          return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
      }

      // FORMATTING

      addFormatToken('M', ['MM', 2], 'Mo', function () {
          return this.month() + 1;
      });

      addFormatToken('MMM', 0, 0, function (format) {
          return this.localeData().monthsShort(this, format);
      });

      addFormatToken('MMMM', 0, 0, function (format) {
          return this.localeData().months(this, format);
      });

      // ALIASES

      addUnitAlias('month', 'M');

      // PRIORITY

      addUnitPriority('month', 8);

      // PARSING

      addRegexToken('M',    match1to2);
      addRegexToken('MM',   match1to2, match2);
      addRegexToken('MMM',  function (isStrict, locale) {
          return locale.monthsShortRegex(isStrict);
      });
      addRegexToken('MMMM', function (isStrict, locale) {
          return locale.monthsRegex(isStrict);
      });

      addParseToken(['M', 'MM'], function (input, array) {
          array[MONTH] = toInt(input) - 1;
      });

      addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
          var month = config._locale.monthsParse(input, token, config._strict);
          // if we didn't find a month name, mark the date as invalid.
          if (month != null) {
              array[MONTH] = month;
          } else {
              getParsingFlags(config).invalidMonth = input;
          }
      });

      // LOCALES

      var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
      var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
      function localeMonths (m, format) {
          if (!m) {
              return this._months;
          }
          return isArray(this._months) ? this._months[m.month()] :
              this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
      }

      var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
      function localeMonthsShort (m, format) {
          if (!m) {
              return this._monthsShort;
          }
          return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
              this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
      }

      function units_month__handleStrictParse(monthName, format, strict) {
          var i, ii, mom, llc = monthName.toLocaleLowerCase();
          if (!this._monthsParse) {
              // this is not used
              this._monthsParse = [];
              this._longMonthsParse = [];
              this._shortMonthsParse = [];
              for (i = 0; i < 12; ++i) {
                  mom = create_utc__createUTC([2000, i]);
                  this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                  this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
              }
          }

          if (strict) {
              if (format === 'MMM') {
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._longMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              }
          } else {
              if (format === 'MMM') {
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._longMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._longMonthsParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              }
          }
      }

      function localeMonthsParse (monthName, format, strict) {
          var i, mom, regex;

          if (this._monthsParseExact) {
              return units_month__handleStrictParse.call(this, monthName, format, strict);
          }

          if (!this._monthsParse) {
              this._monthsParse = [];
              this._longMonthsParse = [];
              this._shortMonthsParse = [];
          }

          // TODO: add sorting
          // Sorting makes sure if one month (or abbr) is a prefix of another
          // see sorting in computeMonthsParse
          for (i = 0; i < 12; i++) {
              // make the regex if we don't have it already
              mom = create_utc__createUTC([2000, i]);
              if (strict && !this._longMonthsParse[i]) {
                  this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                  this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
              }
              if (!strict && !this._monthsParse[i]) {
                  regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                  this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
              }
              // test the regex
              if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                  return i;
              } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                  return i;
              } else if (!strict && this._monthsParse[i].test(monthName)) {
                  return i;
              }
          }
      }

      // MOMENTS

      function setMonth (mom, value) {
          var dayOfMonth;

          if (!mom.isValid()) {
              // No op
              return mom;
          }

          if (typeof value === 'string') {
              if (/^\d+$/.test(value)) {
                  value = toInt(value);
              } else {
                  value = mom.localeData().monthsParse(value);
                  // TODO: Another silent failure?
                  if (typeof value !== 'number') {
                      return mom;
                  }
              }
          }

          dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
          return mom;
      }

      function getSetMonth (value) {
          if (value != null) {
              setMonth(this, value);
              utils_hooks__hooks.updateOffset(this, true);
              return this;
          } else {
              return get_set__get(this, 'Month');
          }
      }

      function getDaysInMonth () {
          return daysInMonth(this.year(), this.month());
      }

      var defaultMonthsShortRegex = matchWord;
      function monthsShortRegex (isStrict) {
          if (this._monthsParseExact) {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  computeMonthsParse.call(this);
              }
              if (isStrict) {
                  return this._monthsShortStrictRegex;
              } else {
                  return this._monthsShortRegex;
              }
          } else {
              if (!hasOwnProp(this, '_monthsShortRegex')) {
                  this._monthsShortRegex = defaultMonthsShortRegex;
              }
              return this._monthsShortStrictRegex && isStrict ?
                  this._monthsShortStrictRegex : this._monthsShortRegex;
          }
      }

      var defaultMonthsRegex = matchWord;
      function monthsRegex (isStrict) {
          if (this._monthsParseExact) {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  computeMonthsParse.call(this);
              }
              if (isStrict) {
                  return this._monthsStrictRegex;
              } else {
                  return this._monthsRegex;
              }
          } else {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  this._monthsRegex = defaultMonthsRegex;
              }
              return this._monthsStrictRegex && isStrict ?
                  this._monthsStrictRegex : this._monthsRegex;
          }
      }

      function computeMonthsParse () {
          function cmpLenRev(a, b) {
              return b.length - a.length;
          }

          var shortPieces = [], longPieces = [], mixedPieces = [],
              i, mom;
          for (i = 0; i < 12; i++) {
              // make the regex if we don't have it already
              mom = create_utc__createUTC([2000, i]);
              shortPieces.push(this.monthsShort(mom, ''));
              longPieces.push(this.months(mom, ''));
              mixedPieces.push(this.months(mom, ''));
              mixedPieces.push(this.monthsShort(mom, ''));
          }
          // Sorting makes sure if one month (or abbr) is a prefix of another it
          // will match the longer piece.
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i = 0; i < 12; i++) {
              shortPieces[i] = regexEscape(shortPieces[i]);
              longPieces[i] = regexEscape(longPieces[i]);
          }
          for (i = 0; i < 24; i++) {
              mixedPieces[i] = regexEscape(mixedPieces[i]);
          }

          this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
          this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
      }

      // FORMATTING

      addFormatToken('Y', 0, 0, function () {
          var y = this.year();
          return y <= 9999 ? '' + y : '+' + y;
      });

      addFormatToken(0, ['YY', 2], 0, function () {
          return this.year() % 100;
      });

      addFormatToken(0, ['YYYY',   4],       0, 'year');
      addFormatToken(0, ['YYYYY',  5],       0, 'year');
      addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

      // ALIASES

      addUnitAlias('year', 'y');

      // PRIORITIES

      addUnitPriority('year', 1);

      // PARSING

      addRegexToken('Y',      matchSigned);
      addRegexToken('YY',     match1to2, match2);
      addRegexToken('YYYY',   match1to4, match4);
      addRegexToken('YYYYY',  match1to6, match6);
      addRegexToken('YYYYYY', match1to6, match6);

      addParseToken(['YYYYY', 'YYYYYY'], YEAR);
      addParseToken('YYYY', function (input, array) {
          array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken('YY', function (input, array) {
          array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
      });
      addParseToken('Y', function (input, array) {
          array[YEAR] = parseInt(input, 10);
      });

      // HELPERS

      function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
      }

      function isLeapYear(year) {
          return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
      }

      // HOOKS

      utils_hooks__hooks.parseTwoDigitYear = function (input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
      };

      // MOMENTS

      var getSetYear = makeGetSet('FullYear', true);

      function getIsLeapYear () {
          return isLeapYear(this.year());
      }

      function createDate (y, m, d, h, M, s, ms) {
          //can't just apply() to create a date:
          //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
          var date = new Date(y, m, d, h, M, s, ms);

          //the date constructor remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
              date.setFullYear(y);
          }
          return date;
      }

      function createUTCDate (y) {
          var date = new Date(Date.UTC.apply(null, arguments));

          //the Date.UTC function remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
              date.setUTCFullYear(y);
          }
          return date;
      }

      // start-of-first-week - start-of-year
      function firstWeekOffset(year, dow, doy) {
          var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
              fwd = 7 + dow - doy,
              // first-week day local weekday -- which local weekday is fwd
              fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

          return -fwdlw + fwd - 1;
      }

      //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7,
              weekOffset = firstWeekOffset(year, dow, doy),
              dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
              resYear, resDayOfYear;

          if (dayOfYear <= 0) {
              resYear = year - 1;
              resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
              resYear = year + 1;
              resDayOfYear = dayOfYear - daysInYear(year);
          } else {
              resYear = year;
              resDayOfYear = dayOfYear;
          }

          return {
              year: resYear,
              dayOfYear: resDayOfYear
          };
      }

      function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy),
              week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
              resWeek, resYear;

          if (week < 1) {
              resYear = mom.year() - 1;
              resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
              resWeek = week - weeksInYear(mom.year(), dow, doy);
              resYear = mom.year() + 1;
          } else {
              resYear = mom.year();
              resWeek = week;
          }

          return {
              week: resWeek,
              year: resYear
          };
      }

      function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy),
              weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }

      // FORMATTING

      addFormatToken('w', ['ww', 2], 'wo', 'week');
      addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

      // ALIASES

      addUnitAlias('week', 'w');
      addUnitAlias('isoWeek', 'W');

      // PRIORITIES

      addUnitPriority('week', 5);
      addUnitPriority('isoWeek', 5);

      // PARSING

      addRegexToken('w',  match1to2);
      addRegexToken('ww', match1to2, match2);
      addRegexToken('W',  match1to2);
      addRegexToken('WW', match1to2, match2);

      addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
          week[token.substr(0, 1)] = toInt(input);
      });

      // HELPERS

      // LOCALES

      function localeWeek (mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }

      var defaultLocaleWeek = {
          dow : 0, // Sunday is the first day of the week.
          doy : 6  // The week that contains Jan 1st is the first week of the year.
      };

      function localeFirstDayOfWeek () {
          return this._week.dow;
      }

      function localeFirstDayOfYear () {
          return this._week.doy;
      }

      // MOMENTS

      function getSetWeek (input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, 'd');
      }

      function getSetISOWeek (input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, 'd');
      }

      // FORMATTING

      addFormatToken('d', 0, 'do', 'day');

      addFormatToken('dd', 0, 0, function (format) {
          return this.localeData().weekdaysMin(this, format);
      });

      addFormatToken('ddd', 0, 0, function (format) {
          return this.localeData().weekdaysShort(this, format);
      });

      addFormatToken('dddd', 0, 0, function (format) {
          return this.localeData().weekdays(this, format);
      });

      addFormatToken('e', 0, 0, 'weekday');
      addFormatToken('E', 0, 0, 'isoWeekday');

      // ALIASES

      addUnitAlias('day', 'd');
      addUnitAlias('weekday', 'e');
      addUnitAlias('isoWeekday', 'E');

      // PRIORITY
      addUnitPriority('day', 11);
      addUnitPriority('weekday', 11);
      addUnitPriority('isoWeekday', 11);

      // PARSING

      addRegexToken('d',    match1to2);
      addRegexToken('e',    match1to2);
      addRegexToken('E',    match1to2);
      addRegexToken('dd',   function (isStrict, locale) {
          return locale.weekdaysMinRegex(isStrict);
      });
      addRegexToken('ddd',   function (isStrict, locale) {
          return locale.weekdaysShortRegex(isStrict);
      });
      addRegexToken('dddd',   function (isStrict, locale) {
          return locale.weekdaysRegex(isStrict);
      });

      addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
          var weekday = config._locale.weekdaysParse(input, token, config._strict);
          // if we didn't get a weekday name, mark the date as invalid
          if (weekday != null) {
              week.d = weekday;
          } else {
              getParsingFlags(config).invalidWeekday = input;
          }
      });

      addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
          week[token] = toInt(input);
      });

      // HELPERS

      function parseWeekday(input, locale) {
          if (typeof input !== 'string') {
              return input;
          }

          if (!isNaN(input)) {
              return parseInt(input, 10);
          }

          input = locale.weekdaysParse(input);
          if (typeof input === 'number') {
              return input;
          }

          return null;
      }

      function parseIsoWeekday(input, locale) {
          if (typeof input === 'string') {
              return locale.weekdaysParse(input) % 7 || 7;
          }
          return isNaN(input) ? null : input;
      }

      // LOCALES

      var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
      function localeWeekdays (m, format) {
          if (!m) {
              return this._weekdays;
          }
          return isArray(this._weekdays) ? this._weekdays[m.day()] :
              this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
      }

      var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
      function localeWeekdaysShort (m) {
          return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }

      var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
      function localeWeekdaysMin (m) {
          return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }

      function day_of_week__handleStrictParse(weekdayName, format, strict) {
          var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
          if (!this._weekdaysParse) {
              this._weekdaysParse = [];
              this._shortWeekdaysParse = [];
              this._minWeekdaysParse = [];

              for (i = 0; i < 7; ++i) {
                  mom = create_utc__createUTC([2000, 1]).day(i);
                  this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                  this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                  this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
              }
          }

          if (strict) {
              if (format === 'dddd') {
                  ii = indexOf.call(this._weekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else if (format === 'ddd') {
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              }
          } else {
              if (format === 'dddd') {
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else if (format === 'ddd') {
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              }
          }
      }

      function localeWeekdaysParse (weekdayName, format, strict) {
          var i, mom, regex;

          if (this._weekdaysParseExact) {
              return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
          }

          if (!this._weekdaysParse) {
              this._weekdaysParse = [];
              this._minWeekdaysParse = [];
              this._shortWeekdaysParse = [];
              this._fullWeekdaysParse = [];
          }

          for (i = 0; i < 7; i++) {
              // make the regex if we don't have it already

              mom = create_utc__createUTC([2000, 1]).day(i);
              if (strict && !this._fullWeekdaysParse[i]) {
                  this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
                  this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
                  this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
              }
              if (!this._weekdaysParse[i]) {
                  regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                  this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
              }
              // test the regex
              if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                  return i;
              } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                  return i;
              } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                  return i;
              } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                  return i;
              }
          }
      }

      // MOMENTS

      function getSetDayOfWeek (input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
          if (input != null) {
              input = parseWeekday(input, this.localeData());
              return this.add(input - day, 'd');
          } else {
              return day;
          }
      }

      function getSetLocaleDayOfWeek (input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, 'd');
      }

      function getSetISODayOfWeek (input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }

          // behaves the same as moment#day except
          // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
          // as a setter, sunday should belong to the previous week.

          if (input != null) {
              var weekday = parseIsoWeekday(input, this.localeData());
              return this.day(this.day() % 7 ? weekday : weekday - 7);
          } else {
              return this.day() || 7;
          }
      }

      var defaultWeekdaysRegex = matchWord;
      function weekdaysRegex (isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysStrictRegex;
              } else {
                  return this._weekdaysRegex;
              }
          } else {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  this._weekdaysRegex = defaultWeekdaysRegex;
              }
              return this._weekdaysStrictRegex && isStrict ?
                  this._weekdaysStrictRegex : this._weekdaysRegex;
          }
      }

      var defaultWeekdaysShortRegex = matchWord;
      function weekdaysShortRegex (isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysShortStrictRegex;
              } else {
                  return this._weekdaysShortRegex;
              }
          } else {
              if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                  this._weekdaysShortRegex = defaultWeekdaysShortRegex;
              }
              return this._weekdaysShortStrictRegex && isStrict ?
                  this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
          }
      }

      var defaultWeekdaysMinRegex = matchWord;
      function weekdaysMinRegex (isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysMinStrictRegex;
              } else {
                  return this._weekdaysMinRegex;
              }
          } else {
              if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                  this._weekdaysMinRegex = defaultWeekdaysMinRegex;
              }
              return this._weekdaysMinStrictRegex && isStrict ?
                  this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
          }
      }


      function computeWeekdaysParse () {
          function cmpLenRev(a, b) {
              return b.length - a.length;
          }

          var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
              i, mom, minp, shortp, longp;
          for (i = 0; i < 7; i++) {
              // make the regex if we don't have it already
              mom = create_utc__createUTC([2000, 1]).day(i);
              minp = this.weekdaysMin(mom, '');
              shortp = this.weekdaysShort(mom, '');
              longp = this.weekdays(mom, '');
              minPieces.push(minp);
              shortPieces.push(shortp);
              longPieces.push(longp);
              mixedPieces.push(minp);
              mixedPieces.push(shortp);
              mixedPieces.push(longp);
          }
          // Sorting makes sure if one weekday (or abbr) is a prefix of another it
          // will match the longer piece.
          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i = 0; i < 7; i++) {
              shortPieces[i] = regexEscape(shortPieces[i]);
              longPieces[i] = regexEscape(longPieces[i]);
              mixedPieces[i] = regexEscape(mixedPieces[i]);
          }

          this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;

          this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
          this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
          this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
      }

      // FORMATTING

      function hFormat() {
          return this.hours() % 12 || 12;
      }

      function kFormat() {
          return this.hours() || 24;
      }

      addFormatToken('H', ['HH', 2], 0, 'hour');
      addFormatToken('h', ['hh', 2], 0, hFormat);
      addFormatToken('k', ['kk', 2], 0, kFormat);

      addFormatToken('hmm', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });

      addFormatToken('hmmss', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
              zeroFill(this.seconds(), 2);
      });

      addFormatToken('Hmm', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2);
      });

      addFormatToken('Hmmss', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2) +
              zeroFill(this.seconds(), 2);
      });

      function meridiem (token, lowercase) {
          addFormatToken(token, 0, 0, function () {
              return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
          });
      }

      meridiem('a', true);
      meridiem('A', false);

      // ALIASES

      addUnitAlias('hour', 'h');

      // PRIORITY
      addUnitPriority('hour', 13);

      // PARSING

      function matchMeridiem (isStrict, locale) {
          return locale._meridiemParse;
      }

      addRegexToken('a',  matchMeridiem);
      addRegexToken('A',  matchMeridiem);
      addRegexToken('H',  match1to2);
      addRegexToken('h',  match1to2);
      addRegexToken('HH', match1to2, match2);
      addRegexToken('hh', match1to2, match2);

      addRegexToken('hmm', match3to4);
      addRegexToken('hmmss', match5to6);
      addRegexToken('Hmm', match3to4);
      addRegexToken('Hmmss', match5to6);

      addParseToken(['H', 'HH'], HOUR);
      addParseToken(['a', 'A'], function (input, array, config) {
          config._isPm = config._locale.isPM(input);
          config._meridiem = input;
      });
      addParseToken(['h', 'hh'], function (input, array, config) {
          array[HOUR] = toInt(input);
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmmss', function (input, array, config) {
          var pos1 = input.length - 4;
          var pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('Hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken('Hmmss', function (input, array, config) {
          var pos1 = input.length - 4;
          var pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
      });

      // LOCALES

      function localeIsPM (input) {
          // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
          // Using charAt should be more compatible.
          return ((input + '').toLowerCase().charAt(0) === 'p');
      }

      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
      function localeMeridiem (hours, minutes, isLower) {
          if (hours > 11) {
              return isLower ? 'pm' : 'PM';
          } else {
              return isLower ? 'am' : 'AM';
          }
      }


      // MOMENTS

      // Setting the hour should keep the time, because the user explicitly
      // specified which hour he wants. So trying to maintain the same hour (in
      // a new timezone) makes sense. Adding/subtracting hours does not follow
      // this rule.
      var getSetHour = makeGetSet('Hours', true);

      var baseConfig = {
          calendar: defaultCalendar,
          longDateFormat: defaultLongDateFormat,
          invalidDate: defaultInvalidDate,
          ordinal: defaultOrdinal,
          ordinalParse: defaultOrdinalParse,
          relativeTime: defaultRelativeTime,

          months: defaultLocaleMonths,
          monthsShort: defaultLocaleMonthsShort,

          week: defaultLocaleWeek,

          weekdays: defaultLocaleWeekdays,
          weekdaysMin: defaultLocaleWeekdaysMin,
          weekdaysShort: defaultLocaleWeekdaysShort,

          meridiemParse: defaultLocaleMeridiemParse
      };

      // internal storage for locale config files
      var locales = {};
      var globalLocale;

      function normalizeLocale(key) {
          return key ? key.toLowerCase().replace('_', '-') : key;
      }

      // pick the locale from the array
      // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
      // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
      function chooseLocale(names) {
          var i = 0, j, next, locale, split;

          while (i < names.length) {
              split = normalizeLocale(names[i]).split('-');
              j = split.length;
              next = normalizeLocale(names[i + 1]);
              next = next ? next.split('-') : null;
              while (j > 0) {
                  locale = loadLocale(split.slice(0, j).join('-'));
                  if (locale) {
                      return locale;
                  }
                  if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                      //the next array item is better than a shallower substring of this one
                      break;
                  }
                  j--;
              }
              i++;
          }
          return null;
      }

      function loadLocale(name) {
          var oldLocale = null;
          // TODO: Find a better way to register and load all the locales in Node
          if (!locales[name] && (typeof module !== 'undefined') &&
                  module && module.exports) {
              try {
                  oldLocale = globalLocale._abbr;
                  !(function webpackMissingModule() { var e = new Error("Cannot find module \"./locale\""); e.code = 'MODULE_NOT_FOUND'; throw e; }());
                  // because defineLocale currently also sets the global locale, we
                  // want to undo that for lazy loaded locales
                  locale_locales__getSetGlobalLocale(oldLocale);
              } catch (e) { }
          }
          return locales[name];
      }

      // This function will load locale and then set the global locale.  If
      // no arguments are passed in, it will simply return the current global
      // locale key.
      function locale_locales__getSetGlobalLocale (key, values) {
          var data;
          if (key) {
              if (isUndefined(values)) {
                  data = locale_locales__getLocale(key);
              }
              else {
                  data = defineLocale(key, values);
              }

              if (data) {
                  // moment.duration._locale = moment._locale = data;
                  globalLocale = data;
              }
          }

          return globalLocale._abbr;
      }

      function defineLocale (name, config) {
          if (config !== null) {
              var parentConfig = baseConfig;
              config.abbr = name;
              if (locales[name] != null) {
                  deprecateSimple('defineLocaleOverride',
                          'use moment.updateLocale(localeName, config) to change ' +
                          'an existing locale. moment.defineLocale(localeName, ' +
                          'config) should only be used for creating a new locale ' +
                          'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                  parentConfig = locales[name]._config;
              } else if (config.parentLocale != null) {
                  if (locales[config.parentLocale] != null) {
                      parentConfig = locales[config.parentLocale]._config;
                  } else {
                      // treat as if there is no base config
                      deprecateSimple('parentLocaleUndefined',
                              'specified parentLocale is not defined yet. See http://momentjs.com/guides/#/warnings/parent-locale/');
                  }
              }
              locales[name] = new Locale(mergeConfigs(parentConfig, config));

              // backwards compat for now: also set the locale
              locale_locales__getSetGlobalLocale(name);

              return locales[name];
          } else {
              // useful for testing
              delete locales[name];
              return null;
          }
      }

      function updateLocale(name, config) {
          if (config != null) {
              var locale, parentConfig = baseConfig;
              // MERGE
              if (locales[name] != null) {
                  parentConfig = locales[name]._config;
              }
              config = mergeConfigs(parentConfig, config);
              locale = new Locale(config);
              locale.parentLocale = locales[name];
              locales[name] = locale;

              // backwards compat for now: also set the locale
              locale_locales__getSetGlobalLocale(name);
          } else {
              // pass null for config to unupdate, useful for tests
              if (locales[name] != null) {
                  if (locales[name].parentLocale != null) {
                      locales[name] = locales[name].parentLocale;
                  } else if (locales[name] != null) {
                      delete locales[name];
                  }
              }
          }
          return locales[name];
      }

      // returns locale data
      function locale_locales__getLocale (key) {
          var locale;

          if (key && key._locale && key._locale._abbr) {
              key = key._locale._abbr;
          }

          if (!key) {
              return globalLocale;
          }

          if (!isArray(key)) {
              //short-circuit everything else
              locale = loadLocale(key);
              if (locale) {
                  return locale;
              }
              key = [key];
          }

          return chooseLocale(key);
      }

      function locale_locales__listLocales() {
          return keys(locales);
      }

      function checkOverflow (m) {
          var overflow;
          var a = m._a;

          if (a && getParsingFlags(m).overflow === -2) {
              overflow =
                  a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                  a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                  a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                  a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                  a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                  a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                  -1;

              if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                  overflow = DATE;
              }
              if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                  overflow = WEEK;
              }
              if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                  overflow = WEEKDAY;
              }

              getParsingFlags(m).overflow = overflow;
          }

          return m;
      }

      // iso 8601 regex
      // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
      var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;

      var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

      var isoDates = [
          ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
          ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
          ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
          ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
          ['YYYY-DDD', /\d{4}-\d{3}/],
          ['YYYY-MM', /\d{4}-\d\d/, false],
          ['YYYYYYMMDD', /[+-]\d{10}/],
          ['YYYYMMDD', /\d{8}/],
          // YYYYMM is NOT allowed by the standard
          ['GGGG[W]WWE', /\d{4}W\d{3}/],
          ['GGGG[W]WW', /\d{4}W\d{2}/, false],
          ['YYYYDDD', /\d{7}/]
      ];

      // iso time formats and regexes
      var isoTimes = [
          ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
          ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
          ['HH:mm:ss', /\d\d:\d\d:\d\d/],
          ['HH:mm', /\d\d:\d\d/],
          ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
          ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
          ['HHmmss', /\d\d\d\d\d\d/],
          ['HHmm', /\d\d\d\d/],
          ['HH', /\d\d/]
      ];

      var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

      // date from iso format
      function configFromISO(config) {
          var i, l,
              string = config._i,
              match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
              allowTime, dateFormat, timeFormat, tzFormat;

          if (match) {
              getParsingFlags(config).iso = true;

              for (i = 0, l = isoDates.length; i < l; i++) {
                  if (isoDates[i][1].exec(match[1])) {
                      dateFormat = isoDates[i][0];
                      allowTime = isoDates[i][2] !== false;
                      break;
                  }
              }
              if (dateFormat == null) {
                  config._isValid = false;
                  return;
              }
              if (match[3]) {
                  for (i = 0, l = isoTimes.length; i < l; i++) {
                      if (isoTimes[i][1].exec(match[3])) {
                          // match[2] should be 'T' or space
                          timeFormat = (match[2] || ' ') + isoTimes[i][0];
                          break;
                      }
                  }
                  if (timeFormat == null) {
                      config._isValid = false;
                      return;
                  }
              }
              if (!allowTime && timeFormat != null) {
                  config._isValid = false;
                  return;
              }
              if (match[4]) {
                  if (tzRegex.exec(match[4])) {
                      tzFormat = 'Z';
                  } else {
                      config._isValid = false;
                      return;
                  }
              }
              config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
              configFromStringAndFormat(config);
          } else {
              config._isValid = false;
          }
      }

      // date from iso format or fallback
      function configFromString(config) {
          var matched = aspNetJsonRegex.exec(config._i);

          if (matched !== null) {
              config._d = new Date(+matched[1]);
              return;
          }

          configFromISO(config);
          if (config._isValid === false) {
              delete config._isValid;
              utils_hooks__hooks.createFromInputFallback(config);
          }
      }

      utils_hooks__hooks.createFromInputFallback = deprecate(
          'value provided is not in a recognized ISO format. moment construction falls back to js Date(), ' +
          'which is not reliable across all browsers and versions. Non ISO date formats are ' +
          'discouraged and will be removed in an upcoming major release. Please refer to ' +
          'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
          function (config) {
              config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
          }
      );

      // Pick the first defined of two or three arguments.
      function defaults(a, b, c) {
          if (a != null) {
              return a;
          }
          if (b != null) {
              return b;
          }
          return c;
      }

      function currentDateArray(config) {
          // hooks is actually the exported moment object
          var nowValue = new Date(utils_hooks__hooks.now());
          if (config._useUTC) {
              return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
          }
          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }

      // convert an array to a date.
      // the array should mirror the parameters below
      // note: all values past the year are optional and will default to the lowest possible value.
      // [year, month, day , hour, minute, second, millisecond]
      function configFromArray (config) {
          var i, date, input = [], currentDate, yearToUse;

          if (config._d) {
              return;
          }

          currentDate = currentDateArray(config);

          //compute day of the year from weeks and weekdays
          if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
              dayOfYearFromWeekInfo(config);
          }

          //if the day of the year is set, figure out what it is
          if (config._dayOfYear) {
              yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

              if (config._dayOfYear > daysInYear(yearToUse)) {
                  getParsingFlags(config)._overflowDayOfYear = true;
              }

              date = createUTCDate(yearToUse, 0, config._dayOfYear);
              config._a[MONTH] = date.getUTCMonth();
              config._a[DATE] = date.getUTCDate();
          }

          // Default to current date.
          // * if no year, month, day of month are given, default to today
          // * if day of month is given, default month and year
          // * if month is given, default only year
          // * if year is given, don't default anything
          for (i = 0; i < 3 && config._a[i] == null; ++i) {
              config._a[i] = input[i] = currentDate[i];
          }

          // Zero out whatever was not defaulted, including time
          for (; i < 7; i++) {
              config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
          }

          // Check for 24:00:00.000
          if (config._a[HOUR] === 24 &&
                  config._a[MINUTE] === 0 &&
                  config._a[SECOND] === 0 &&
                  config._a[MILLISECOND] === 0) {
              config._nextDay = true;
              config._a[HOUR] = 0;
          }

          config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
          // Apply timezone offset from input. The actual utcOffset can be changed
          // with parseZone.
          if (config._tzm != null) {
              config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          }

          if (config._nextDay) {
              config._a[HOUR] = 24;
          }
      }

      function dayOfYearFromWeekInfo(config) {
          var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

          w = config._w;
          if (w.GG != null || w.W != null || w.E != null) {
              dow = 1;
              doy = 4;

              // TODO: We need to take the current isoWeekYear, but that depends on
              // how we interpret now (local, utc, fixed offset). So create
              // a now version of current config (take local/utc/offset flags, and
              // create now).
              weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
              week = defaults(w.W, 1);
              weekday = defaults(w.E, 1);
              if (weekday < 1 || weekday > 7) {
                  weekdayOverflow = true;
              }
          } else {
              dow = config._locale._week.dow;
              doy = config._locale._week.doy;

              weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
              week = defaults(w.w, 1);

              if (w.d != null) {
                  // weekday -- low day numbers are considered next week
                  weekday = w.d;
                  if (weekday < 0 || weekday > 6) {
                      weekdayOverflow = true;
                  }
              } else if (w.e != null) {
                  // local weekday -- counting starts from begining of week
                  weekday = w.e + dow;
                  if (w.e < 0 || w.e > 6) {
                      weekdayOverflow = true;
                  }
              } else {
                  // default to begining of week
                  weekday = dow;
              }
          }
          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
              getParsingFlags(config)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
              getParsingFlags(config)._overflowWeekday = true;
          } else {
              temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
              config._a[YEAR] = temp.year;
              config._dayOfYear = temp.dayOfYear;
          }
      }

      // constant that refers to the ISO standard
      utils_hooks__hooks.ISO_8601 = function () {};

      // date from string and format string
      function configFromStringAndFormat(config) {
          // TODO: Move this to another part of the creation flow to prevent circular deps
          if (config._f === utils_hooks__hooks.ISO_8601) {
              configFromISO(config);
              return;
          }

          config._a = [];
          getParsingFlags(config).empty = true;

          // This array is used to make a Date, either with `new Date` or `Date.UTC`
          var string = '' + config._i,
              i, parsedInput, tokens, token, skipped,
              stringLength = string.length,
              totalParsedInputLength = 0;

          tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

          for (i = 0; i < tokens.length; i++) {
              token = tokens[i];
              parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
              // console.log('token', token, 'parsedInput', parsedInput,
              //         'regex', getParseRegexForToken(token, config));
              if (parsedInput) {
                  skipped = string.substr(0, string.indexOf(parsedInput));
                  if (skipped.length > 0) {
                      getParsingFlags(config).unusedInput.push(skipped);
                  }
                  string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                  totalParsedInputLength += parsedInput.length;
              }
              // don't parse if it's not a known token
              if (formatTokenFunctions[token]) {
                  if (parsedInput) {
                      getParsingFlags(config).empty = false;
                  }
                  else {
                      getParsingFlags(config).unusedTokens.push(token);
                  }
                  addTimeToArrayFromToken(token, parsedInput, config);
              }
              else if (config._strict && !parsedInput) {
                  getParsingFlags(config).unusedTokens.push(token);
              }
          }

          // add remaining unparsed input length to the string
          getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
          if (string.length > 0) {
              getParsingFlags(config).unusedInput.push(string);
          }

          // clear _12h flag if hour is <= 12
          if (config._a[HOUR] <= 12 &&
              getParsingFlags(config).bigHour === true &&
              config._a[HOUR] > 0) {
              getParsingFlags(config).bigHour = undefined;
          }

          getParsingFlags(config).parsedDateParts = config._a.slice(0);
          getParsingFlags(config).meridiem = config._meridiem;
          // handle meridiem
          config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

          configFromArray(config);
          checkOverflow(config);
      }


      function meridiemFixWrap (locale, hour, meridiem) {
          var isPm;

          if (meridiem == null) {
              // nothing to do
              return hour;
          }
          if (locale.meridiemHour != null) {
              return locale.meridiemHour(hour, meridiem);
          } else if (locale.isPM != null) {
              // Fallback
              isPm = locale.isPM(meridiem);
              if (isPm && hour < 12) {
                  hour += 12;
              }
              if (!isPm && hour === 12) {
                  hour = 0;
              }
              return hour;
          } else {
              // this is not supposed to happen
              return hour;
          }
      }

      // date from string and array of format strings
      function configFromStringAndArray(config) {
          var tempConfig,
              bestMoment,

              scoreToBeat,
              i,
              currentScore;

          if (config._f.length === 0) {
              getParsingFlags(config).invalidFormat = true;
              config._d = new Date(NaN);
              return;
          }

          for (i = 0; i < config._f.length; i++) {
              currentScore = 0;
              tempConfig = copyConfig({}, config);
              if (config._useUTC != null) {
                  tempConfig._useUTC = config._useUTC;
              }
              tempConfig._f = config._f[i];
              configFromStringAndFormat(tempConfig);

              if (!valid__isValid(tempConfig)) {
                  continue;
              }

              // if there is any input that was not parsed add a penalty for that format
              currentScore += getParsingFlags(tempConfig).charsLeftOver;

              //or tokens
              currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

              getParsingFlags(tempConfig).score = currentScore;

              if (scoreToBeat == null || currentScore < scoreToBeat) {
                  scoreToBeat = currentScore;
                  bestMoment = tempConfig;
              }
          }

          extend(config, bestMoment || tempConfig);
      }

      function configFromObject(config) {
          if (config._d) {
              return;
          }

          var i = normalizeObjectUnits(config._i);
          config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
              return obj && parseInt(obj, 10);
          });

          configFromArray(config);
      }

      function createFromConfig (config) {
          var res = new Moment(checkOverflow(prepareConfig(config)));
          if (res._nextDay) {
              // Adding is smart enough around DST
              res.add(1, 'd');
              res._nextDay = undefined;
          }

          return res;
      }

      function prepareConfig (config) {
          var input = config._i,
              format = config._f;

          config._locale = config._locale || locale_locales__getLocale(config._l);

          if (input === null || (format === undefined && input === '')) {
              return valid__createInvalid({nullInput: true});
          }

          if (typeof input === 'string') {
              config._i = input = config._locale.preparse(input);
          }

          if (isMoment(input)) {
              return new Moment(checkOverflow(input));
          } else if (isArray(format)) {
              configFromStringAndArray(config);
          } else if (isDate(input)) {
              config._d = input;
          } else if (format) {
              configFromStringAndFormat(config);
          }  else {
              configFromInput(config);
          }

          if (!valid__isValid(config)) {
              config._d = null;
          }

          return config;
      }

      function configFromInput(config) {
          var input = config._i;
          if (input === undefined) {
              config._d = new Date(utils_hooks__hooks.now());
          } else if (isDate(input)) {
              config._d = new Date(input.valueOf());
          } else if (typeof input === 'string') {
              configFromString(config);
          } else if (isArray(input)) {
              config._a = map(input.slice(0), function (obj) {
                  return parseInt(obj, 10);
              });
              configFromArray(config);
          } else if (typeof(input) === 'object') {
              configFromObject(config);
          } else if (typeof(input) === 'number') {
              // from milliseconds
              config._d = new Date(input);
          } else {
              utils_hooks__hooks.createFromInputFallback(config);
          }
      }

      function createLocalOrUTC (input, format, locale, strict, isUTC) {
          var c = {};

          if (typeof(locale) === 'boolean') {
              strict = locale;
              locale = undefined;
          }

          if ((isObject(input) && isObjectEmpty(input)) ||
                  (isArray(input) && input.length === 0)) {
              input = undefined;
          }
          // object construction must be done this way.
          // https://github.com/moment/moment/issues/1423
          c._isAMomentObject = true;
          c._useUTC = c._isUTC = isUTC;
          c._l = locale;
          c._i = input;
          c._f = format;
          c._strict = strict;

          return createFromConfig(c);
      }

      function local__createLocal (input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, false);
      }

      var prototypeMin = deprecate(
          'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
          function () {
              var other = local__createLocal.apply(null, arguments);
              if (this.isValid() && other.isValid()) {
                  return other < this ? this : other;
              } else {
                  return valid__createInvalid();
              }
          }
      );

      var prototypeMax = deprecate(
          'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
          function () {
              var other = local__createLocal.apply(null, arguments);
              if (this.isValid() && other.isValid()) {
                  return other > this ? this : other;
              } else {
                  return valid__createInvalid();
              }
          }
      );

      // Pick a moment m from moments so that m[fn](other) is true for all
      // other. This relies on the function fn to be transitive.
      //
      // moments should either be an array of moment objects or an array, whose
      // first element is an array of moment objects.
      function pickBy(fn, moments) {
          var res, i;
          if (moments.length === 1 && isArray(moments[0])) {
              moments = moments[0];
          }
          if (!moments.length) {
              return local__createLocal();
          }
          res = moments[0];
          for (i = 1; i < moments.length; ++i) {
              if (!moments[i].isValid() || moments[i][fn](res)) {
                  res = moments[i];
              }
          }
          return res;
      }

      // TODO: Use [].sort instead?
      function min () {
          var args = [].slice.call(arguments, 0);

          return pickBy('isBefore', args);
      }

      function max () {
          var args = [].slice.call(arguments, 0);

          return pickBy('isAfter', args);
      }

      var now = function () {
          return Date.now ? Date.now() : +(new Date());
      };

      function Duration (duration) {
          var normalizedInput = normalizeObjectUnits(duration),
              years = normalizedInput.year || 0,
              quarters = normalizedInput.quarter || 0,
              months = normalizedInput.month || 0,
              weeks = normalizedInput.week || 0,
              days = normalizedInput.day || 0,
              hours = normalizedInput.hour || 0,
              minutes = normalizedInput.minute || 0,
              seconds = normalizedInput.second || 0,
              milliseconds = normalizedInput.millisecond || 0;

          // representation for dateAddRemove
          this._milliseconds = +milliseconds +
              seconds * 1e3 + // 1000
              minutes * 6e4 + // 1000 * 60
              hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
          // Because of dateAddRemove treats 24 hours as different from a
          // day when working around DST, we need to store them separately
          this._days = +days +
              weeks * 7;
          // It is impossible translate months into days without knowing
          // which months you are are talking about, so we have to store
          // it separately.
          this._months = +months +
              quarters * 3 +
              years * 12;

          this._data = {};

          this._locale = locale_locales__getLocale();

          this._bubble();
      }

      function isDuration (obj) {
          return obj instanceof Duration;
      }

      function absRound (number) {
          if (number < 0) {
              return Math.round(-1 * number) * -1;
          } else {
              return Math.round(number);
          }
      }

      // FORMATTING

      function offset (token, separator) {
          addFormatToken(token, 0, 0, function () {
              var offset = this.utcOffset();
              var sign = '+';
              if (offset < 0) {
                  offset = -offset;
                  sign = '-';
              }
              return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
          });
      }

      offset('Z', ':');
      offset('ZZ', '');

      // PARSING

      addRegexToken('Z',  matchShortOffset);
      addRegexToken('ZZ', matchShortOffset);
      addParseToken(['Z', 'ZZ'], function (input, array, config) {
          config._useUTC = true;
          config._tzm = offsetFromString(matchShortOffset, input);
      });

      // HELPERS

      // timezone chunker
      // '+10:00' > ['10',  '00']
      // '-1530'  > ['-15', '30']
      var chunkOffset = /([\+\-]|\d\d)/gi;

      function offsetFromString(matcher, string) {
          var matches = ((string || '').match(matcher) || []);
          var chunk   = matches[matches.length - 1] || [];
          var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
          var minutes = +(parts[1] * 60) + toInt(parts[2]);

          return parts[0] === '+' ? minutes : -minutes;
      }

      // Return a moment from input, that is local/utc/zone equivalent to model.
      function cloneWithOffset(input, model) {
          var res, diff;
          if (model._isUTC) {
              res = model.clone();
              diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
              // Use low-level api, because this fn is low-level api.
              res._d.setTime(res._d.valueOf() + diff);
              utils_hooks__hooks.updateOffset(res, false);
              return res;
          } else {
              return local__createLocal(input).local();
          }
      }

      function getDateOffset (m) {
          // On Firefox.24 Date#getTimezoneOffset returns a floating point.
          // https://github.com/moment/moment/pull/1871
          return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
      }

      // HOOKS

      // This function will be called whenever a moment is mutated.
      // It is intended to keep the offset in sync with the timezone.
      utils_hooks__hooks.updateOffset = function () {};

      // MOMENTS

      // keepLocalTime = true means only change the timezone, without
      // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
      // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
      // +0200, so we adjust the time as needed, to be valid.
      //
      // Keeping the time actually adds/subtracts (one hour)
      // from the actual represented time. That is why we call updateOffset
      // a second time. In case it wants us to change the offset again
      // _changeInProgress == true case, then we have to adjust, because
      // there is no such time in the given timezone.
      function getSetOffset (input, keepLocalTime) {
          var offset = this._offset || 0,
              localAdjust;
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          if (input != null) {
              if (typeof input === 'string') {
                  input = offsetFromString(matchShortOffset, input);
              } else if (Math.abs(input) < 16) {
                  input = input * 60;
              }
              if (!this._isUTC && keepLocalTime) {
                  localAdjust = getDateOffset(this);
              }
              this._offset = input;
              this._isUTC = true;
              if (localAdjust != null) {
                  this.add(localAdjust, 'm');
              }
              if (offset !== input) {
                  if (!keepLocalTime || this._changeInProgress) {
                      add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                  } else if (!this._changeInProgress) {
                      this._changeInProgress = true;
                      utils_hooks__hooks.updateOffset(this, true);
                      this._changeInProgress = null;
                  }
              }
              return this;
          } else {
              return this._isUTC ? offset : getDateOffset(this);
          }
      }

      function getSetZone (input, keepLocalTime) {
          if (input != null) {
              if (typeof input !== 'string') {
                  input = -input;
              }

              this.utcOffset(input, keepLocalTime);

              return this;
          } else {
              return -this.utcOffset();
          }
      }

      function setOffsetToUTC (keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
      }

      function setOffsetToLocal (keepLocalTime) {
          if (this._isUTC) {
              this.utcOffset(0, keepLocalTime);
              this._isUTC = false;

              if (keepLocalTime) {
                  this.subtract(getDateOffset(this), 'm');
              }
          }
          return this;
      }

      function setOffsetToParsedOffset () {
          if (this._tzm) {
              this.utcOffset(this._tzm);
          } else if (typeof this._i === 'string') {
              var tZone = offsetFromString(matchOffset, this._i);

              if (tZone === 0) {
                  this.utcOffset(0, true);
              } else {
                  this.utcOffset(offsetFromString(matchOffset, this._i));
              }
          }
          return this;
      }

      function hasAlignedHourOffset (input) {
          if (!this.isValid()) {
              return false;
          }
          input = input ? local__createLocal(input).utcOffset() : 0;

          return (this.utcOffset() - input) % 60 === 0;
      }

      function isDaylightSavingTime () {
          return (
              this.utcOffset() > this.clone().month(0).utcOffset() ||
              this.utcOffset() > this.clone().month(5).utcOffset()
          );
      }

      function isDaylightSavingTimeShifted () {
          if (!isUndefined(this._isDSTShifted)) {
              return this._isDSTShifted;
          }

          var c = {};

          copyConfig(c, this);
          c = prepareConfig(c);

          if (c._a) {
              var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
              this._isDSTShifted = this.isValid() &&
                  compareArrays(c._a, other.toArray()) > 0;
          } else {
              this._isDSTShifted = false;
          }

          return this._isDSTShifted;
      }

      function isLocal () {
          return this.isValid() ? !this._isUTC : false;
      }

      function isUtcOffset () {
          return this.isValid() ? this._isUTC : false;
      }

      function isUtc () {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }

      // ASP.NET json date format regex
      var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

      // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
      // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
      // and further modified to allow for strings containing both week and day
      var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

      function create__createDuration (input, key) {
          var duration = input,
              // matching against regexp is expensive, do it on demand
              match = null,
              sign,
              ret,
              diffRes;

          if (isDuration(input)) {
              duration = {
                  ms : input._milliseconds,
                  d  : input._days,
                  M  : input._months
              };
          } else if (typeof input === 'number') {
              duration = {};
              if (key) {
                  duration[key] = input;
              } else {
                  duration.milliseconds = input;
              }
          } else if (!!(match = aspNetRegex.exec(input))) {
              sign = (match[1] === '-') ? -1 : 1;
              duration = {
                  y  : 0,
                  d  : toInt(match[DATE])                         * sign,
                  h  : toInt(match[HOUR])                         * sign,
                  m  : toInt(match[MINUTE])                       * sign,
                  s  : toInt(match[SECOND])                       * sign,
                  ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
              };
          } else if (!!(match = isoRegex.exec(input))) {
              sign = (match[1] === '-') ? -1 : 1;
              duration = {
                  y : parseIso(match[2], sign),
                  M : parseIso(match[3], sign),
                  w : parseIso(match[4], sign),
                  d : parseIso(match[5], sign),
                  h : parseIso(match[6], sign),
                  m : parseIso(match[7], sign),
                  s : parseIso(match[8], sign)
              };
          } else if (duration == null) {// checks for null or undefined
              duration = {};
          } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
              diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

              duration = {};
              duration.ms = diffRes.milliseconds;
              duration.M = diffRes.months;
          }

          ret = new Duration(duration);

          if (isDuration(input) && hasOwnProp(input, '_locale')) {
              ret._locale = input._locale;
          }

          return ret;
      }

      create__createDuration.fn = Duration.prototype;

      function parseIso (inp, sign) {
          // We'd normally use ~~inp for this, but unfortunately it also
          // converts floats to ints.
          // inp may be undefined, so careful calling replace on it.
          var res = inp && parseFloat(inp.replace(',', '.'));
          // apply sign while we're at it
          return (isNaN(res) ? 0 : res) * sign;
      }

      function positiveMomentsDifference(base, other) {
          var res = {milliseconds: 0, months: 0};

          res.months = other.month() - base.month() +
              (other.year() - base.year()) * 12;
          if (base.clone().add(res.months, 'M').isAfter(other)) {
              --res.months;
          }

          res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

          return res;
      }

      function momentsDifference(base, other) {
          var res;
          if (!(base.isValid() && other.isValid())) {
              return {milliseconds: 0, months: 0};
          }

          other = cloneWithOffset(other, base);
          if (base.isBefore(other)) {
              res = positiveMomentsDifference(base, other);
          } else {
              res = positiveMomentsDifference(other, base);
              res.milliseconds = -res.milliseconds;
              res.months = -res.months;
          }

          return res;
      }

      // TODO: remove 'name' arg after deprecation is removed
      function createAdder(direction, name) {
          return function (val, period) {
              var dur, tmp;
              //invert the arguments, but complain about it
              if (period !== null && !isNaN(+period)) {
                  deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                  'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                  tmp = val; val = period; period = tmp;
              }

              val = typeof val === 'string' ? +val : val;
              dur = create__createDuration(val, period);
              add_subtract__addSubtract(this, dur, direction);
              return this;
          };
      }

      function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
          var milliseconds = duration._milliseconds,
              days = absRound(duration._days),
              months = absRound(duration._months);

          if (!mom.isValid()) {
              // No op
              return;
          }

          updateOffset = updateOffset == null ? true : updateOffset;

          if (milliseconds) {
              mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
          }
          if (days) {
              get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
          }
          if (months) {
              setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
          }
          if (updateOffset) {
              utils_hooks__hooks.updateOffset(mom, days || months);
          }
      }

      var add_subtract__add      = createAdder(1, 'add');
      var add_subtract__subtract = createAdder(-1, 'subtract');

      function getCalendarFormat(myMoment, now) {
          var diff = myMoment.diff(now, 'days', true);
          return diff < -6 ? 'sameElse' :
                  diff < -1 ? 'lastWeek' :
                  diff < 0 ? 'lastDay' :
                  diff < 1 ? 'sameDay' :
                  diff < 2 ? 'nextDay' :
                  diff < 7 ? 'nextWeek' : 'sameElse';
      }

      function moment_calendar__calendar (time, formats) {
          // We want to compare the start of today, vs this.
          // Getting start-of-today depends on whether we're local/utc/offset or not.
          var now = time || local__createLocal(),
              sod = cloneWithOffset(now, this).startOf('day'),
              format = utils_hooks__hooks.calendarFormat(this, sod) || 'sameElse';

          var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

          return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
      }

      function clone () {
          return new Moment(this);
      }

      function isAfter (input, units) {
          var localInput = isMoment(input) ? input : local__createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
          if (units === 'millisecond') {
              return this.valueOf() > localInput.valueOf();
          } else {
              return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
      }

      function isBefore (input, units) {
          var localInput = isMoment(input) ? input : local__createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
          if (units === 'millisecond') {
              return this.valueOf() < localInput.valueOf();
          } else {
              return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
      }

      function isBetween (from, to, units, inclusivity) {
          inclusivity = inclusivity || '()';
          return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
              (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
      }

      function isSame (input, units) {
          var localInput = isMoment(input) ? input : local__createLocal(input),
              inputMs;
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(units || 'millisecond');
          if (units === 'millisecond') {
              return this.valueOf() === localInput.valueOf();
          } else {
              inputMs = localInput.valueOf();
              return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
          }
      }

      function isSameOrAfter (input, units) {
          return this.isSame(input, units) || this.isAfter(input,units);
      }

      function isSameOrBefore (input, units) {
          return this.isSame(input, units) || this.isBefore(input,units);
      }

      function diff (input, units, asFloat) {
          var that,
              zoneDelta,
              delta, output;

          if (!this.isValid()) {
              return NaN;
          }

          that = cloneWithOffset(input, this);

          if (!that.isValid()) {
              return NaN;
          }

          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

          units = normalizeUnits(units);

          if (units === 'year' || units === 'month' || units === 'quarter') {
              output = monthDiff(this, that);
              if (units === 'quarter') {
                  output = output / 3;
              } else if (units === 'year') {
                  output = output / 12;
              }
          } else {
              delta = this - that;
              output = units === 'second' ? delta / 1e3 : // 1000
                  units === 'minute' ? delta / 6e4 : // 1000 * 60
                  units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                  units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                  units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                  delta;
          }
          return asFloat ? output : absFloor(output);
      }

      function monthDiff (a, b) {
          // difference in months
          var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
              // b is in (anchor - 1 month, anchor + 1 month)
              anchor = a.clone().add(wholeMonthDiff, 'months'),
              anchor2, adjust;

          if (b - anchor < 0) {
              anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
              // linear across the month
              adjust = (b - anchor) / (anchor - anchor2);
          } else {
              anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
              // linear across the month
              adjust = (b - anchor) / (anchor2 - anchor);
          }

          //check for negative zero, return zero if negative zero
          return -(wholeMonthDiff + adjust) || 0;
      }

      utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
      utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

      function toString () {
          return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
      }

      function moment_format__toISOString () {
          var m = this.clone().utc();
          if (0 < m.year() && m.year() <= 9999) {
              if (isFunction(Date.prototype.toISOString)) {
                  // native implementation is ~50x faster, use it when we can
                  return this.toDate().toISOString();
              } else {
                  return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
              }
          } else {
              return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
          }
      }

      function format (inputString) {
          if (!inputString) {
              inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
          }
          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
      }

      function from (time, withoutSuffix) {
          if (this.isValid() &&
                  ((isMoment(time) && time.isValid()) ||
                   local__createLocal(time).isValid())) {
              return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
          } else {
              return this.localeData().invalidDate();
          }
      }

      function fromNow (withoutSuffix) {
          return this.from(local__createLocal(), withoutSuffix);
      }

      function to (time, withoutSuffix) {
          if (this.isValid() &&
                  ((isMoment(time) && time.isValid()) ||
                   local__createLocal(time).isValid())) {
              return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
          } else {
              return this.localeData().invalidDate();
          }
      }

      function toNow (withoutSuffix) {
          return this.to(local__createLocal(), withoutSuffix);
      }

      // If passed a locale key, it will set the locale for this
      // instance.  Otherwise, it will return the locale configuration
      // variables for this instance.
      function locale (key) {
          var newLocaleData;

          if (key === undefined) {
              return this._locale._abbr;
          } else {
              newLocaleData = locale_locales__getLocale(key);
              if (newLocaleData != null) {
                  this._locale = newLocaleData;
              }
              return this;
          }
      }

      var lang = deprecate(
          'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
          function (key) {
              if (key === undefined) {
                  return this.localeData();
              } else {
                  return this.locale(key);
              }
          }
      );

      function localeData () {
          return this._locale;
      }

      function startOf (units) {
          units = normalizeUnits(units);
          // the following switch intentionally omits break keywords
          // to utilize falling through the cases.
          switch (units) {
              case 'year':
                  this.month(0);
                  /* falls through */
              case 'quarter':
              case 'month':
                  this.date(1);
                  /* falls through */
              case 'week':
              case 'isoWeek':
              case 'day':
              case 'date':
                  this.hours(0);
                  /* falls through */
              case 'hour':
                  this.minutes(0);
                  /* falls through */
              case 'minute':
                  this.seconds(0);
                  /* falls through */
              case 'second':
                  this.milliseconds(0);
          }

          // weeks are a special case
          if (units === 'week') {
              this.weekday(0);
          }
          if (units === 'isoWeek') {
              this.isoWeekday(1);
          }

          // quarters are also special
          if (units === 'quarter') {
              this.month(Math.floor(this.month() / 3) * 3);
          }

          return this;
      }

      function endOf (units) {
          units = normalizeUnits(units);
          if (units === undefined || units === 'millisecond') {
              return this;
          }

          // 'date' is an alias for 'day', so it should be considered as such.
          if (units === 'date') {
              units = 'day';
          }

          return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
      }

      function to_type__valueOf () {
          return this._d.valueOf() - ((this._offset || 0) * 60000);
      }

      function unix () {
          return Math.floor(this.valueOf() / 1000);
      }

      function toDate () {
          return new Date(this.valueOf());
      }

      function toArray () {
          var m = this;
          return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
      }

      function toObject () {
          var m = this;
          return {
              years: m.year(),
              months: m.month(),
              date: m.date(),
              hours: m.hours(),
              minutes: m.minutes(),
              seconds: m.seconds(),
              milliseconds: m.milliseconds()
          };
      }

      function toJSON () {
          // new Date(NaN).toJSON() === null
          return this.isValid() ? this.toISOString() : null;
      }

      function moment_valid__isValid () {
          return valid__isValid(this);
      }

      function parsingFlags () {
          return extend({}, getParsingFlags(this));
      }

      function invalidAt () {
          return getParsingFlags(this).overflow;
      }

      function creationData() {
          return {
              input: this._i,
              format: this._f,
              locale: this._locale,
              isUTC: this._isUTC,
              strict: this._strict
          };
      }

      // FORMATTING

      addFormatToken(0, ['gg', 2], 0, function () {
          return this.weekYear() % 100;
      });

      addFormatToken(0, ['GG', 2], 0, function () {
          return this.isoWeekYear() % 100;
      });

      function addWeekYearFormatToken (token, getter) {
          addFormatToken(0, [token, token.length], 0, getter);
      }

      addWeekYearFormatToken('gggg',     'weekYear');
      addWeekYearFormatToken('ggggg',    'weekYear');
      addWeekYearFormatToken('GGGG',  'isoWeekYear');
      addWeekYearFormatToken('GGGGG', 'isoWeekYear');

      // ALIASES

      addUnitAlias('weekYear', 'gg');
      addUnitAlias('isoWeekYear', 'GG');

      // PRIORITY

      addUnitPriority('weekYear', 1);
      addUnitPriority('isoWeekYear', 1);


      // PARSING

      addRegexToken('G',      matchSigned);
      addRegexToken('g',      matchSigned);
      addRegexToken('GG',     match1to2, match2);
      addRegexToken('gg',     match1to2, match2);
      addRegexToken('GGGG',   match1to4, match4);
      addRegexToken('gggg',   match1to4, match4);
      addRegexToken('GGGGG',  match1to6, match6);
      addRegexToken('ggggg',  match1to6, match6);

      addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
          week[token.substr(0, 2)] = toInt(input);
      });

      addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
          week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
      });

      // MOMENTS

      function getSetWeekYear (input) {
          return getSetWeekYearHelper.call(this,
                  input,
                  this.week(),
                  this.weekday(),
                  this.localeData()._week.dow,
                  this.localeData()._week.doy);
      }

      function getSetISOWeekYear (input) {
          return getSetWeekYearHelper.call(this,
                  input, this.isoWeek(), this.isoWeekday(), 1, 4);
      }

      function getISOWeeksInYear () {
          return weeksInYear(this.year(), 1, 4);
      }

      function getWeeksInYear () {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }

      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;
          if (input == null) {
              return weekOfYear(this, dow, doy).year;
          } else {
              weeksTarget = weeksInYear(input, dow, doy);
              if (week > weeksTarget) {
                  week = weeksTarget;
              }
              return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
      }

      function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
              date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
      }

      // FORMATTING

      addFormatToken('Q', 0, 'Qo', 'quarter');

      // ALIASES

      addUnitAlias('quarter', 'Q');

      // PRIORITY

      addUnitPriority('quarter', 7);

      // PARSING

      addRegexToken('Q', match1);
      addParseToken('Q', function (input, array) {
          array[MONTH] = (toInt(input) - 1) * 3;
      });

      // MOMENTS

      function getSetQuarter (input) {
          return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }

      // FORMATTING

      addFormatToken('D', ['DD', 2], 'Do', 'date');

      // ALIASES

      addUnitAlias('date', 'D');

      // PRIOROITY
      addUnitPriority('date', 9);

      // PARSING

      addRegexToken('D',  match1to2);
      addRegexToken('DD', match1to2, match2);
      addRegexToken('Do', function (isStrict, locale) {
          return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
      });

      addParseToken(['D', 'DD'], DATE);
      addParseToken('Do', function (input, array) {
          array[DATE] = toInt(input.match(match1to2)[0], 10);
      });

      // MOMENTS

      var getSetDayOfMonth = makeGetSet('Date', true);

      // FORMATTING

      addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

      // ALIASES

      addUnitAlias('dayOfYear', 'DDD');

      // PRIORITY
      addUnitPriority('dayOfYear', 4);

      // PARSING

      addRegexToken('DDD',  match1to3);
      addRegexToken('DDDD', match3);
      addParseToken(['DDD', 'DDDD'], function (input, array, config) {
          config._dayOfYear = toInt(input);
      });

      // HELPERS

      // MOMENTS

      function getSetDayOfYear (input) {
          var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
          return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
      }

      // FORMATTING

      addFormatToken('m', ['mm', 2], 0, 'minute');

      // ALIASES

      addUnitAlias('minute', 'm');

      // PRIORITY

      addUnitPriority('minute', 14);

      // PARSING

      addRegexToken('m',  match1to2);
      addRegexToken('mm', match1to2, match2);
      addParseToken(['m', 'mm'], MINUTE);

      // MOMENTS

      var getSetMinute = makeGetSet('Minutes', false);

      // FORMATTING

      addFormatToken('s', ['ss', 2], 0, 'second');

      // ALIASES

      addUnitAlias('second', 's');

      // PRIORITY

      addUnitPriority('second', 15);

      // PARSING

      addRegexToken('s',  match1to2);
      addRegexToken('ss', match1to2, match2);
      addParseToken(['s', 'ss'], SECOND);

      // MOMENTS

      var getSetSecond = makeGetSet('Seconds', false);

      // FORMATTING

      addFormatToken('S', 0, 0, function () {
          return ~~(this.millisecond() / 100);
      });

      addFormatToken(0, ['SS', 2], 0, function () {
          return ~~(this.millisecond() / 10);
      });

      addFormatToken(0, ['SSS', 3], 0, 'millisecond');
      addFormatToken(0, ['SSSS', 4], 0, function () {
          return this.millisecond() * 10;
      });
      addFormatToken(0, ['SSSSS', 5], 0, function () {
          return this.millisecond() * 100;
      });
      addFormatToken(0, ['SSSSSS', 6], 0, function () {
          return this.millisecond() * 1000;
      });
      addFormatToken(0, ['SSSSSSS', 7], 0, function () {
          return this.millisecond() * 10000;
      });
      addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
          return this.millisecond() * 100000;
      });
      addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
          return this.millisecond() * 1000000;
      });


      // ALIASES

      addUnitAlias('millisecond', 'ms');

      // PRIORITY

      addUnitPriority('millisecond', 16);

      // PARSING

      addRegexToken('S',    match1to3, match1);
      addRegexToken('SS',   match1to3, match2);
      addRegexToken('SSS',  match1to3, match3);

      var token;
      for (token = 'SSSS'; token.length <= 9; token += 'S') {
          addRegexToken(token, matchUnsigned);
      }

      function parseMs(input, array) {
          array[MILLISECOND] = toInt(('0.' + input) * 1000);
      }

      for (token = 'S'; token.length <= 9; token += 'S') {
          addParseToken(token, parseMs);
      }
      // MOMENTS

      var getSetMillisecond = makeGetSet('Milliseconds', false);

      // FORMATTING

      addFormatToken('z',  0, 0, 'zoneAbbr');
      addFormatToken('zz', 0, 0, 'zoneName');

      // MOMENTS

      function getZoneAbbr () {
          return this._isUTC ? 'UTC' : '';
      }

      function getZoneName () {
          return this._isUTC ? 'Coordinated Universal Time' : '';
      }

      var momentPrototype__proto = Moment.prototype;

      momentPrototype__proto.add               = add_subtract__add;
      momentPrototype__proto.calendar          = moment_calendar__calendar;
      momentPrototype__proto.clone             = clone;
      momentPrototype__proto.diff              = diff;
      momentPrototype__proto.endOf             = endOf;
      momentPrototype__proto.format            = format;
      momentPrototype__proto.from              = from;
      momentPrototype__proto.fromNow           = fromNow;
      momentPrototype__proto.to                = to;
      momentPrototype__proto.toNow             = toNow;
      momentPrototype__proto.get               = stringGet;
      momentPrototype__proto.invalidAt         = invalidAt;
      momentPrototype__proto.isAfter           = isAfter;
      momentPrototype__proto.isBefore          = isBefore;
      momentPrototype__proto.isBetween         = isBetween;
      momentPrototype__proto.isSame            = isSame;
      momentPrototype__proto.isSameOrAfter     = isSameOrAfter;
      momentPrototype__proto.isSameOrBefore    = isSameOrBefore;
      momentPrototype__proto.isValid           = moment_valid__isValid;
      momentPrototype__proto.lang              = lang;
      momentPrototype__proto.locale            = locale;
      momentPrototype__proto.localeData        = localeData;
      momentPrototype__proto.max               = prototypeMax;
      momentPrototype__proto.min               = prototypeMin;
      momentPrototype__proto.parsingFlags      = parsingFlags;
      momentPrototype__proto.set               = stringSet;
      momentPrototype__proto.startOf           = startOf;
      momentPrototype__proto.subtract          = add_subtract__subtract;
      momentPrototype__proto.toArray           = toArray;
      momentPrototype__proto.toObject          = toObject;
      momentPrototype__proto.toDate            = toDate;
      momentPrototype__proto.toISOString       = moment_format__toISOString;
      momentPrototype__proto.toJSON            = toJSON;
      momentPrototype__proto.toString          = toString;
      momentPrototype__proto.unix              = unix;
      momentPrototype__proto.valueOf           = to_type__valueOf;
      momentPrototype__proto.creationData      = creationData;

      // Year
      momentPrototype__proto.year       = getSetYear;
      momentPrototype__proto.isLeapYear = getIsLeapYear;

      // Week Year
      momentPrototype__proto.weekYear    = getSetWeekYear;
      momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

      // Quarter
      momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

      // Month
      momentPrototype__proto.month       = getSetMonth;
      momentPrototype__proto.daysInMonth = getDaysInMonth;

      // Week
      momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
      momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
      momentPrototype__proto.weeksInYear    = getWeeksInYear;
      momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

      // Day
      momentPrototype__proto.date       = getSetDayOfMonth;
      momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
      momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
      momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
      momentPrototype__proto.dayOfYear  = getSetDayOfYear;

      // Hour
      momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

      // Minute
      momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

      // Second
      momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

      // Millisecond
      momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

      // Offset
      momentPrototype__proto.utcOffset            = getSetOffset;
      momentPrototype__proto.utc                  = setOffsetToUTC;
      momentPrototype__proto.local                = setOffsetToLocal;
      momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
      momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
      momentPrototype__proto.isDST                = isDaylightSavingTime;
      momentPrototype__proto.isLocal              = isLocal;
      momentPrototype__proto.isUtcOffset          = isUtcOffset;
      momentPrototype__proto.isUtc                = isUtc;
      momentPrototype__proto.isUTC                = isUtc;

      // Timezone
      momentPrototype__proto.zoneAbbr = getZoneAbbr;
      momentPrototype__proto.zoneName = getZoneName;

      // Deprecations
      momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
      momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
      momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
      momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
      momentPrototype__proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

      var momentPrototype = momentPrototype__proto;

      function moment__createUnix (input) {
          return local__createLocal(input * 1000);
      }

      function moment__createInZone () {
          return local__createLocal.apply(null, arguments).parseZone();
      }

      function preParsePostFormat (string) {
          return string;
      }

      var prototype__proto = Locale.prototype;

      prototype__proto.calendar        = locale_calendar__calendar;
      prototype__proto.longDateFormat  = longDateFormat;
      prototype__proto.invalidDate     = invalidDate;
      prototype__proto.ordinal         = ordinal;
      prototype__proto.preparse        = preParsePostFormat;
      prototype__proto.postformat      = preParsePostFormat;
      prototype__proto.relativeTime    = relative__relativeTime;
      prototype__proto.pastFuture      = pastFuture;
      prototype__proto.set             = locale_set__set;

      // Month
      prototype__proto.months            =        localeMonths;
      prototype__proto.monthsShort       =        localeMonthsShort;
      prototype__proto.monthsParse       =        localeMonthsParse;
      prototype__proto.monthsRegex       = monthsRegex;
      prototype__proto.monthsShortRegex  = monthsShortRegex;

      // Week
      prototype__proto.week = localeWeek;
      prototype__proto.firstDayOfYear = localeFirstDayOfYear;
      prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

      // Day of Week
      prototype__proto.weekdays       =        localeWeekdays;
      prototype__proto.weekdaysMin    =        localeWeekdaysMin;
      prototype__proto.weekdaysShort  =        localeWeekdaysShort;
      prototype__proto.weekdaysParse  =        localeWeekdaysParse;

      prototype__proto.weekdaysRegex       =        weekdaysRegex;
      prototype__proto.weekdaysShortRegex  =        weekdaysShortRegex;
      prototype__proto.weekdaysMinRegex    =        weekdaysMinRegex;

      // Hours
      prototype__proto.isPM = localeIsPM;
      prototype__proto.meridiem = localeMeridiem;

      function lists__get (format, index, field, setter) {
          var locale = locale_locales__getLocale();
          var utc = create_utc__createUTC().set(setter, index);
          return locale[field](utc, format);
      }

      function listMonthsImpl (format, index, field) {
          if (typeof format === 'number') {
              index = format;
              format = undefined;
          }

          format = format || '';

          if (index != null) {
              return lists__get(format, index, field, 'month');
          }

          var i;
          var out = [];
          for (i = 0; i < 12; i++) {
              out[i] = lists__get(format, i, field, 'month');
          }
          return out;
      }

      // ()
      // (5)
      // (fmt, 5)
      // (fmt)
      // (true)
      // (true, 5)
      // (true, fmt, 5)
      // (true, fmt)
      function listWeekdaysImpl (localeSorted, format, index, field) {
          if (typeof localeSorted === 'boolean') {
              if (typeof format === 'number') {
                  index = format;
                  format = undefined;
              }

              format = format || '';
          } else {
              format = localeSorted;
              index = format;
              localeSorted = false;

              if (typeof format === 'number') {
                  index = format;
                  format = undefined;
              }

              format = format || '';
          }

          var locale = locale_locales__getLocale(),
              shift = localeSorted ? locale._week.dow : 0;

          if (index != null) {
              return lists__get(format, (index + shift) % 7, field, 'day');
          }

          var i;
          var out = [];
          for (i = 0; i < 7; i++) {
              out[i] = lists__get(format, (i + shift) % 7, field, 'day');
          }
          return out;
      }

      function lists__listMonths (format, index) {
          return listMonthsImpl(format, index, 'months');
      }

      function lists__listMonthsShort (format, index) {
          return listMonthsImpl(format, index, 'monthsShort');
      }

      function lists__listWeekdays (localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
      }

      function lists__listWeekdaysShort (localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
      }

      function lists__listWeekdaysMin (localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
      }

      locale_locales__getSetGlobalLocale('en', {
          ordinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal : function (number) {
              var b = number % 10,
                  output = (toInt(number % 100 / 10) === 1) ? 'th' :
                  (b === 1) ? 'st' :
                  (b === 2) ? 'nd' :
                  (b === 3) ? 'rd' : 'th';
              return number + output;
          }
      });

      // Side effect imports
      utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
      utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

      var mathAbs = Math.abs;

      function duration_abs__abs () {
          var data           = this._data;

          this._milliseconds = mathAbs(this._milliseconds);
          this._days         = mathAbs(this._days);
          this._months       = mathAbs(this._months);

          data.milliseconds  = mathAbs(data.milliseconds);
          data.seconds       = mathAbs(data.seconds);
          data.minutes       = mathAbs(data.minutes);
          data.hours         = mathAbs(data.hours);
          data.months        = mathAbs(data.months);
          data.years         = mathAbs(data.years);

          return this;
      }

      function duration_add_subtract__addSubtract (duration, input, value, direction) {
          var other = create__createDuration(input, value);

          duration._milliseconds += direction * other._milliseconds;
          duration._days         += direction * other._days;
          duration._months       += direction * other._months;

          return duration._bubble();
      }

      // supports only 2.0-style add(1, 's') or add(duration)
      function duration_add_subtract__add (input, value) {
          return duration_add_subtract__addSubtract(this, input, value, 1);
      }

      // supports only 2.0-style subtract(1, 's') or subtract(duration)
      function duration_add_subtract__subtract (input, value) {
          return duration_add_subtract__addSubtract(this, input, value, -1);
      }

      function absCeil (number) {
          if (number < 0) {
              return Math.floor(number);
          } else {
              return Math.ceil(number);
          }
      }

      function bubble () {
          var milliseconds = this._milliseconds;
          var days         = this._days;
          var months       = this._months;
          var data         = this._data;
          var seconds, minutes, hours, years, monthsFromDays;

          // if we have a mix of positive and negative values, bubble down first
          // check: https://github.com/moment/moment/issues/2166
          if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                  (milliseconds <= 0 && days <= 0 && months <= 0))) {
              milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
              days = 0;
              months = 0;
          }

          // The following code bubbles up values, see the tests for
          // examples of what that means.
          data.milliseconds = milliseconds % 1000;

          seconds           = absFloor(milliseconds / 1000);
          data.seconds      = seconds % 60;

          minutes           = absFloor(seconds / 60);
          data.minutes      = minutes % 60;

          hours             = absFloor(minutes / 60);
          data.hours        = hours % 24;

          days += absFloor(hours / 24);

          // convert days to months
          monthsFromDays = absFloor(daysToMonths(days));
          months += monthsFromDays;
          days -= absCeil(monthsToDays(monthsFromDays));

          // 12 months -> 1 year
          years = absFloor(months / 12);
          months %= 12;

          data.days   = days;
          data.months = months;
          data.years  = years;

          return this;
      }

      function daysToMonths (days) {
          // 400 years have 146097 days (taking into account leap year rules)
          // 400 years have 12 months === 4800
          return days * 4800 / 146097;
      }

      function monthsToDays (months) {
          // the reverse of daysToMonths
          return months * 146097 / 4800;
      }

      function as (units) {
          var days;
          var months;
          var milliseconds = this._milliseconds;

          units = normalizeUnits(units);

          if (units === 'month' || units === 'year') {
              days   = this._days   + milliseconds / 864e5;
              months = this._months + daysToMonths(days);
              return units === 'month' ? months : months / 12;
          } else {
              // handle milliseconds separately because of floating point math errors (issue #1867)
              days = this._days + Math.round(monthsToDays(this._months));
              switch (units) {
                  case 'week'   : return days / 7     + milliseconds / 6048e5;
                  case 'day'    : return days         + milliseconds / 864e5;
                  case 'hour'   : return days * 24    + milliseconds / 36e5;
                  case 'minute' : return days * 1440  + milliseconds / 6e4;
                  case 'second' : return days * 86400 + milliseconds / 1000;
                  // Math.floor prevents floating point math errors here
                  case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                  default: throw new Error('Unknown unit ' + units);
              }
          }
      }

      // TODO: Use this.as('ms')?
      function duration_as__valueOf () {
          return (
              this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6
          );
      }

      function makeAs (alias) {
          return function () {
              return this.as(alias);
          };
      }

      var asMilliseconds = makeAs('ms');
      var asSeconds      = makeAs('s');
      var asMinutes      = makeAs('m');
      var asHours        = makeAs('h');
      var asDays         = makeAs('d');
      var asWeeks        = makeAs('w');
      var asMonths       = makeAs('M');
      var asYears        = makeAs('y');

      function duration_get__get (units) {
          units = normalizeUnits(units);
          return this[units + 's']();
      }

      function makeGetter(name) {
          return function () {
              return this._data[name];
          };
      }

      var milliseconds = makeGetter('milliseconds');
      var seconds      = makeGetter('seconds');
      var minutes      = makeGetter('minutes');
      var hours        = makeGetter('hours');
      var days         = makeGetter('days');
      var months       = makeGetter('months');
      var years        = makeGetter('years');

      function weeks () {
          return absFloor(this.days() / 7);
      }

      var round = Math.round;
      var thresholds = {
          s: 45,  // seconds to minute
          m: 45,  // minutes to hour
          h: 22,  // hours to day
          d: 26,  // days to month
          M: 11   // months to year
      };

      // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
          return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }

      function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
          var duration = create__createDuration(posNegDuration).abs();
          var seconds  = round(duration.as('s'));
          var minutes  = round(duration.as('m'));
          var hours    = round(duration.as('h'));
          var days     = round(duration.as('d'));
          var months   = round(duration.as('M'));
          var years    = round(duration.as('y'));

          var a = seconds < thresholds.s && ['s', seconds]  ||
                  minutes <= 1           && ['m']           ||
                  minutes < thresholds.m && ['mm', minutes] ||
                  hours   <= 1           && ['h']           ||
                  hours   < thresholds.h && ['hh', hours]   ||
                  days    <= 1           && ['d']           ||
                  days    < thresholds.d && ['dd', days]    ||
                  months  <= 1           && ['M']           ||
                  months  < thresholds.M && ['MM', months]  ||
                  years   <= 1           && ['y']           || ['yy', years];

          a[2] = withoutSuffix;
          a[3] = +posNegDuration > 0;
          a[4] = locale;
          return substituteTimeAgo.apply(null, a);
      }

      // This function allows you to set the rounding function for relative time strings
      function duration_humanize__getSetRelativeTimeRounding (roundingFunction) {
          if (roundingFunction === undefined) {
              return round;
          }
          if (typeof(roundingFunction) === 'function') {
              round = roundingFunction;
              return true;
          }
          return false;
      }

      // This function allows you to set a threshold for relative time strings
      function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
          if (thresholds[threshold] === undefined) {
              return false;
          }
          if (limit === undefined) {
              return thresholds[threshold];
          }
          thresholds[threshold] = limit;
          return true;
      }

      function humanize (withSuffix) {
          var locale = this.localeData();
          var output = duration_humanize__relativeTime(this, !withSuffix, locale);

          if (withSuffix) {
              output = locale.pastFuture(+this, output);
          }

          return locale.postformat(output);
      }

      var iso_string__abs = Math.abs;

      function iso_string__toISOString() {
          // for ISO strings we do not use the normal bubbling rules:
          //  * milliseconds bubble up until they become hours
          //  * days do not bubble at all
          //  * months bubble up until they become years
          // This is because there is no context-free conversion between hours and days
          // (think of clock changes)
          // and also not between days and months (28-31 days per month)
          var seconds = iso_string__abs(this._milliseconds) / 1000;
          var days         = iso_string__abs(this._days);
          var months       = iso_string__abs(this._months);
          var minutes, hours, years;

          // 3600 seconds -> 60 minutes -> 1 hour
          minutes           = absFloor(seconds / 60);
          hours             = absFloor(minutes / 60);
          seconds %= 60;
          minutes %= 60;

          // 12 months -> 1 year
          years  = absFloor(months / 12);
          months %= 12;


          // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
          var Y = years;
          var M = months;
          var D = days;
          var h = hours;
          var m = minutes;
          var s = seconds;
          var total = this.asSeconds();

          if (!total) {
              // this is the same as C#'s (Noda) and python (isodate)...
              // but not other JS (goog.date)
              return 'P0D';
          }

          return (total < 0 ? '-' : '') +
              'P' +
              (Y ? Y + 'Y' : '') +
              (M ? M + 'M' : '') +
              (D ? D + 'D' : '') +
              ((h || m || s) ? 'T' : '') +
              (h ? h + 'H' : '') +
              (m ? m + 'M' : '') +
              (s ? s + 'S' : '');
      }

      var duration_prototype__proto = Duration.prototype;

      duration_prototype__proto.abs            = duration_abs__abs;
      duration_prototype__proto.add            = duration_add_subtract__add;
      duration_prototype__proto.subtract       = duration_add_subtract__subtract;
      duration_prototype__proto.as             = as;
      duration_prototype__proto.asMilliseconds = asMilliseconds;
      duration_prototype__proto.asSeconds      = asSeconds;
      duration_prototype__proto.asMinutes      = asMinutes;
      duration_prototype__proto.asHours        = asHours;
      duration_prototype__proto.asDays         = asDays;
      duration_prototype__proto.asWeeks        = asWeeks;
      duration_prototype__proto.asMonths       = asMonths;
      duration_prototype__proto.asYears        = asYears;
      duration_prototype__proto.valueOf        = duration_as__valueOf;
      duration_prototype__proto._bubble        = bubble;
      duration_prototype__proto.get            = duration_get__get;
      duration_prototype__proto.milliseconds   = milliseconds;
      duration_prototype__proto.seconds        = seconds;
      duration_prototype__proto.minutes        = minutes;
      duration_prototype__proto.hours          = hours;
      duration_prototype__proto.days           = days;
      duration_prototype__proto.weeks          = weeks;
      duration_prototype__proto.months         = months;
      duration_prototype__proto.years          = years;
      duration_prototype__proto.humanize       = humanize;
      duration_prototype__proto.toISOString    = iso_string__toISOString;
      duration_prototype__proto.toString       = iso_string__toISOString;
      duration_prototype__proto.toJSON         = iso_string__toISOString;
      duration_prototype__proto.locale         = locale;
      duration_prototype__proto.localeData     = localeData;

      // Deprecations
      duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
      duration_prototype__proto.lang = lang;

      // Side effect imports

      // FORMATTING

      addFormatToken('X', 0, 0, 'unix');
      addFormatToken('x', 0, 0, 'valueOf');

      // PARSING

      addRegexToken('x', matchSigned);
      addRegexToken('X', matchTimestamp);
      addParseToken('X', function (input, array, config) {
          config._d = new Date(parseFloat(input, 10) * 1000);
      });
      addParseToken('x', function (input, array, config) {
          config._d = new Date(toInt(input));
      });

      // Side effect imports


      utils_hooks__hooks.version = '2.15.2';

      setHookCallback(local__createLocal);

      utils_hooks__hooks.fn                    = momentPrototype;
      utils_hooks__hooks.min                   = min;
      utils_hooks__hooks.max                   = max;
      utils_hooks__hooks.now                   = now;
      utils_hooks__hooks.utc                   = create_utc__createUTC;
      utils_hooks__hooks.unix                  = moment__createUnix;
      utils_hooks__hooks.months                = lists__listMonths;
      utils_hooks__hooks.isDate                = isDate;
      utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
      utils_hooks__hooks.invalid               = valid__createInvalid;
      utils_hooks__hooks.duration              = create__createDuration;
      utils_hooks__hooks.isMoment              = isMoment;
      utils_hooks__hooks.weekdays              = lists__listWeekdays;
      utils_hooks__hooks.parseZone             = moment__createInZone;
      utils_hooks__hooks.localeData            = locale_locales__getLocale;
      utils_hooks__hooks.isDuration            = isDuration;
      utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
      utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
      utils_hooks__hooks.defineLocale          = defineLocale;
      utils_hooks__hooks.updateLocale          = updateLocale;
      utils_hooks__hooks.locales               = locale_locales__listLocales;
      utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
      utils_hooks__hooks.normalizeUnits        = normalizeUnits;
      utils_hooks__hooks.relativeTimeRounding = duration_humanize__getSetRelativeTimeRounding;
      utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
      utils_hooks__hooks.calendarFormat        = getCalendarFormat;
      utils_hooks__hooks.prototype             = momentPrototype;

      var _moment = utils_hooks__hooks;

      return _moment;

  }));
  /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)(module)))

/***/ },
/* 4 */
/***/ function(module, exports) {

  module.exports = function(module) {
  	if(!module.webpackPolyfill) {
  		module.deprecate = function() {};
  		module.paths = [];
  		// module.parent = undefined by default
  		module.children = [];
  		module.webpackPolyfill = 1;
  	}
  	return module;
  }


/***/ },
/* 5 */
/***/ function(module, exports) {

  function webpackContext(req) {
  	throw new Error("Cannot find module '" + req + "'.");
  }
  webpackContext.keys = function() { return []; };
  webpackContext.resolve = webpackContext;
  module.exports = webpackContext;
  webpackContext.id = 5;


/***/ },
/* 6 */
/***/ function(module, exports) {

  /* WEBPACK VAR INJECTION */(function(global) {'use strict';

  var _rng;

  var globalVar = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : null;

  if (globalVar && globalVar.crypto && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);
    _rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var _rnds = new Array(16);
    _rng = function _rng() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return _rnds;
    };
  }

  //     uuid.js
  //
  //     Copyright (c) 2010-2012 Robert Kieffer
  //     MIT License - http://opensource.org/licenses/mit-license.php

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required

  //var _rng = require('./rng');

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = buf && offset || 0,
        ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function (oct) {
      if (ii < 16) {
        // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0,
        bth = _byteToHex;
    return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [_seedBytes[0] | 0x01, _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0,
      _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof options == 'string') {
      buf = options == 'binary' ? new Array(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;

  module.exports = uuid;
  /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  // utils
  exports.util = __webpack_require__(1);
  exports.DOMutil = __webpack_require__(8);

  // data
  exports.DataSet = __webpack_require__(9);
  exports.DataView = __webpack_require__(11);
  exports.Queue = __webpack_require__(10);

  // Graph3d
  exports.Graph3d = __webpack_require__(12);
  exports.graph3d = {
    Camera: __webpack_require__(16),
    Filter: __webpack_require__(17),
    Point2d: __webpack_require__(15),
    Point3d: __webpack_require__(14),
    Slider: __webpack_require__(18),
    StepNumber: __webpack_require__(19)
  };

  // bundled external libraries
  exports.moment = __webpack_require__(2);
  exports.Hammer = __webpack_require__(22);
  exports.keycharm = __webpack_require__(25);

/***/ },
/* 8 */
/***/ function(module, exports) {

  'use strict';

  // DOM utility methods

  /**
   * this prepares the JSON container for allocating SVG elements
   * @param JSONcontainer
   * @private
   */
  exports.prepareElements = function (JSONcontainer) {
    // cleanup the redundant svgElements;
    for (var elementType in JSONcontainer) {
      if (JSONcontainer.hasOwnProperty(elementType)) {
        JSONcontainer[elementType].redundant = JSONcontainer[elementType].used;
        JSONcontainer[elementType].used = [];
      }
    }
  };

  /**
   * this cleans up all the unused SVG elements. By asking for the parentNode, we only need to supply the JSON container from
   * which to remove the redundant elements.
   *
   * @param JSONcontainer
   * @private
   */
  exports.cleanupElements = function (JSONcontainer) {
    // cleanup the redundant svgElements;
    for (var elementType in JSONcontainer) {
      if (JSONcontainer.hasOwnProperty(elementType)) {
        if (JSONcontainer[elementType].redundant) {
          for (var i = 0; i < JSONcontainer[elementType].redundant.length; i++) {
            JSONcontainer[elementType].redundant[i].parentNode.removeChild(JSONcontainer[elementType].redundant[i]);
          }
          JSONcontainer[elementType].redundant = [];
        }
      }
    }
  };

  /**
   * Ensures that all elements are removed first up so they can be recreated cleanly
   * @param JSONcontainer
   */
  exports.resetElements = function (JSONcontainer) {
    exports.prepareElements(JSONcontainer);
    exports.cleanupElements(JSONcontainer);
    exports.prepareElements(JSONcontainer);
  };

  /**
   * Allocate or generate an SVG element if needed. Store a reference to it in the JSON container and draw it in the svgContainer
   * the JSON container and the SVG container have to be supplied so other svg containers (like the legend) can use this.
   *
   * @param elementType
   * @param JSONcontainer
   * @param svgContainer
   * @returns {*}
   * @private
   */
  exports.getSVGElement = function (elementType, JSONcontainer, svgContainer) {
    var element;
    // allocate SVG element, if it doesnt yet exist, create one.
    if (JSONcontainer.hasOwnProperty(elementType)) {
      // this element has been created before
      // check if there is an redundant element
      if (JSONcontainer[elementType].redundant.length > 0) {
        element = JSONcontainer[elementType].redundant[0];
        JSONcontainer[elementType].redundant.shift();
      } else {
        // create a new element and add it to the SVG
        element = document.createElementNS('http://www.w3.org/2000/svg', elementType);
        svgContainer.appendChild(element);
      }
    } else {
      // create a new element and add it to the SVG, also create a new object in the svgElements to keep track of it.
      element = document.createElementNS('http://www.w3.org/2000/svg', elementType);
      JSONcontainer[elementType] = { used: [], redundant: [] };
      svgContainer.appendChild(element);
    }
    JSONcontainer[elementType].used.push(element);
    return element;
  };

  /**
   * Allocate or generate an SVG element if needed. Store a reference to it in the JSON container and draw it in the svgContainer
   * the JSON container and the SVG container have to be supplied so other svg containers (like the legend) can use this.
   *
   * @param elementType
   * @param JSONcontainer
   * @param DOMContainer
   * @returns {*}
   * @private
   */
  exports.getDOMElement = function (elementType, JSONcontainer, DOMContainer, insertBefore) {
    var element;
    // allocate DOM element, if it doesnt yet exist, create one.
    if (JSONcontainer.hasOwnProperty(elementType)) {
      // this element has been created before
      // check if there is an redundant element
      if (JSONcontainer[elementType].redundant.length > 0) {
        element = JSONcontainer[elementType].redundant[0];
        JSONcontainer[elementType].redundant.shift();
      } else {
        // create a new element and add it to the SVG
        element = document.createElement(elementType);
        if (insertBefore !== undefined) {
          DOMContainer.insertBefore(element, insertBefore);
        } else {
          DOMContainer.appendChild(element);
        }
      }
    } else {
      // create a new element and add it to the SVG, also create a new object in the svgElements to keep track of it.
      element = document.createElement(elementType);
      JSONcontainer[elementType] = { used: [], redundant: [] };
      if (insertBefore !== undefined) {
        DOMContainer.insertBefore(element, insertBefore);
      } else {
        DOMContainer.appendChild(element);
      }
    }
    JSONcontainer[elementType].used.push(element);
    return element;
  };

  /**
   * Draw a point object. This is a separate function because it can also be called by the legend.
   * The reason the JSONcontainer and the target SVG svgContainer have to be supplied is so the legend can use these functions
   * as well.
   *
   * @param x
   * @param y
   * @param groupTemplate: A template containing the necessary information to draw the datapoint e.g., {style: 'circle', size: 5, className: 'className' }
   * @param JSONcontainer
   * @param svgContainer
   * @param labelObj
   * @returns {*}
   */
  exports.drawPoint = function (x, y, groupTemplate, JSONcontainer, svgContainer, labelObj) {
    var point;
    if (groupTemplate.style == 'circle') {
      point = exports.getSVGElement('circle', JSONcontainer, svgContainer);
      point.setAttributeNS(null, "cx", x);
      point.setAttributeNS(null, "cy", y);
      point.setAttributeNS(null, "r", 0.5 * groupTemplate.size);
    } else {
      point = exports.getSVGElement('rect', JSONcontainer, svgContainer);
      point.setAttributeNS(null, "x", x - 0.5 * groupTemplate.size);
      point.setAttributeNS(null, "y", y - 0.5 * groupTemplate.size);
      point.setAttributeNS(null, "width", groupTemplate.size);
      point.setAttributeNS(null, "height", groupTemplate.size);
    }

    if (groupTemplate.styles !== undefined) {
      point.setAttributeNS(null, "style", groupTemplate.styles);
    }
    point.setAttributeNS(null, "class", groupTemplate.className + " vis-point");
    //handle label


    if (labelObj) {
      var label = exports.getSVGElement('text', JSONcontainer, svgContainer);
      if (labelObj.xOffset) {
        x = x + labelObj.xOffset;
      }

      if (labelObj.yOffset) {
        y = y + labelObj.yOffset;
      }
      if (labelObj.content) {
        label.textContent = labelObj.content;
      }

      if (labelObj.className) {
        label.setAttributeNS(null, "class", labelObj.className + " vis-label");
      }
      label.setAttributeNS(null, "x", x);
      label.setAttributeNS(null, "y", y);
    }

    return point;
  };

  /**
   * draw a bar SVG element centered on the X coordinate
   *
   * @param x
   * @param y
   * @param className
   */
  exports.drawBar = function (x, y, width, height, className, JSONcontainer, svgContainer, style) {
    if (height != 0) {
      if (height < 0) {
        height *= -1;
        y -= height;
      }
      var rect = exports.getSVGElement('rect', JSONcontainer, svgContainer);
      rect.setAttributeNS(null, "x", x - 0.5 * width);
      rect.setAttributeNS(null, "y", y);
      rect.setAttributeNS(null, "width", width);
      rect.setAttributeNS(null, "height", height);
      rect.setAttributeNS(null, "class", className);
      if (style) {
        rect.setAttributeNS(null, "style", style);
      }
    }
  };

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var util = __webpack_require__(1);
  var Queue = __webpack_require__(10);

  /**
   * DataSet
   *
   * Usage:
   *     var dataSet = new DataSet({
   *         fieldId: '_id',
   *         type: {
   *             // ...
   *         }
   *     });
   *
   *     dataSet.add(item);
   *     dataSet.add(data);
   *     dataSet.update(item);
   *     dataSet.update(data);
   *     dataSet.remove(id);
   *     dataSet.remove(ids);
   *     var data = dataSet.get();
   *     var data = dataSet.get(id);
   *     var data = dataSet.get(ids);
   *     var data = dataSet.get(ids, options, data);
   *     dataSet.clear();
   *
   * A data set can:
   * - add/remove/update data
   * - gives triggers upon changes in the data
   * - can  import/export data in various data formats
   *
   * @param {Array} [data]    Optional array with initial data
   * @param {Object} [options]   Available options:
   *                             {String} fieldId Field name of the id in the
   *                                              items, 'id' by default.
   *                             {Object.<String, String} type
   *                                              A map with field names as key,
   *                                              and the field type as value.
   *                             {Object} queue   Queue changes to the DataSet,
   *                                              flush them all at once.
   *                                              Queue options:
   *                                              - {number} delay  Delay in ms, null by default
   *                                              - {number} max    Maximum number of entries in the queue, Infinity by default
   * @constructor DataSet
   */
  // TODO: add a DataSet constructor DataSet(data, options)
  function DataSet(data, options) {
    // correctly read optional arguments
    if (data && !Array.isArray(data)) {
      options = data;
      data = null;
    }

    this._options = options || {};
    this._data = {}; // map with data indexed by id
    this.length = 0; // number of items in the DataSet
    this._fieldId = this._options.fieldId || 'id'; // name of the field containing id
    this._type = {}; // internal field types (NOTE: this can differ from this._options.type)

    // all variants of a Date are internally stored as Date, so we can convert
    // from everything to everything (also from ISODate to Number for example)
    if (this._options.type) {
      var fields = Object.keys(this._options.type);
      for (var i = 0, len = fields.length; i < len; i++) {
        var field = fields[i];
        var value = this._options.type[field];
        if (value == 'Date' || value == 'ISODate' || value == 'ASPDate') {
          this._type[field] = 'Date';
        } else {
          this._type[field] = value;
        }
      }
    }

    // TODO: deprecated since version 1.1.1 (or 2.0.0?)
    if (this._options.convert) {
      throw new Error('Option "convert" is deprecated. Use "type" instead.');
    }

    this._subscribers = {}; // event subscribers

    // add initial data when provided
    if (data) {
      this.add(data);
    }

    this.setOptions(options);
  }

  /**
   * @param {Object} [options]   Available options:
   *                             {Object} queue   Queue changes to the DataSet,
   *                                              flush them all at once.
   *                                              Queue options:
   *                                              - {number} delay  Delay in ms, null by default
   *                                              - {number} max    Maximum number of entries in the queue, Infinity by default
   * @param options
   */
  DataSet.prototype.setOptions = function (options) {
    if (options && options.queue !== undefined) {
      if (options.queue === false) {
        // delete queue if loaded
        if (this._queue) {
          this._queue.destroy();
          delete this._queue;
        }
      } else {
        // create queue and update its options
        if (!this._queue) {
          this._queue = Queue.extend(this, {
            replace: ['add', 'update', 'remove']
          });
        }

        if (_typeof(options.queue) === 'object') {
          this._queue.setOptions(options.queue);
        }
      }
    }
  };

  /**
   * Subscribe to an event, add an event listener
   * @param {String} event        Event name. Available events: 'put', 'update',
   *                              'remove'
   * @param {function} callback   Callback method. Called with three parameters:
   *                                  {String} event
   *                                  {Object | null} params
   *                                  {String | Number} senderId
   */
  DataSet.prototype.on = function (event, callback) {
    var subscribers = this._subscribers[event];
    if (!subscribers) {
      subscribers = [];
      this._subscribers[event] = subscribers;
    }

    subscribers.push({
      callback: callback
    });
  };

  // TODO: remove this deprecated function some day (replaced with `on` since version 0.5, deprecated since v4.0)
  DataSet.prototype.subscribe = function () {
    throw new Error('DataSet.subscribe is deprecated. Use DataSet.on instead.');
  };

  /**
   * Unsubscribe from an event, remove an event listener
   * @param {String} event
   * @param {function} callback
   */
  DataSet.prototype.off = function (event, callback) {
    var subscribers = this._subscribers[event];
    if (subscribers) {
      this._subscribers[event] = subscribers.filter(function (listener) {
        return listener.callback != callback;
      });
    }
  };

  // TODO: remove this deprecated function some day (replaced with `on` since version 0.5, deprecated since v4.0)
  DataSet.prototype.unsubscribe = function () {
    throw new Error('DataSet.unsubscribe is deprecated. Use DataSet.off instead.');
  };

  /**
   * Trigger an event
   * @param {String} event
   * @param {Object | null} params
   * @param {String} [senderId]       Optional id of the sender.
   * @private
   */
  DataSet.prototype._trigger = function (event, params, senderId) {
    if (event == '*') {
      throw new Error('Cannot trigger event *');
    }

    var subscribers = [];
    if (event in this._subscribers) {
      subscribers = subscribers.concat(this._subscribers[event]);
    }
    if ('*' in this._subscribers) {
      subscribers = subscribers.concat(this._subscribers['*']);
    }

    for (var i = 0, len = subscribers.length; i < len; i++) {
      var subscriber = subscribers[i];
      if (subscriber.callback) {
        subscriber.callback(event, params, senderId || null);
      }
    }
  };

  /**
   * Add data.
   * Adding an item will fail when there already is an item with the same id.
   * @param {Object | Array} data
   * @param {String} [senderId] Optional sender id
   * @return {Array} addedIds      Array with the ids of the added items
   */
  DataSet.prototype.add = function (data, senderId) {
    var addedIds = [],
        id,
        me = this;

    if (Array.isArray(data)) {
      // Array
      for (var i = 0, len = data.length; i < len; i++) {
        id = me._addItem(data[i]);
        addedIds.push(id);
      }
    } else if (data instanceof Object) {
      // Single item
      id = me._addItem(data);
      addedIds.push(id);
    } else {
      throw new Error('Unknown dataType');
    }

    if (addedIds.length) {
      this._trigger('add', { items: addedIds }, senderId);
    }

    return addedIds;
  };

  /**
   * Update existing items. When an item does not exist, it will be created
   * @param {Object | Array} data
   * @param {String} [senderId] Optional sender id
   * @return {Array} updatedIds     The ids of the added or updated items
   */
  DataSet.prototype.update = function (data, senderId) {
    var addedIds = [];
    var updatedIds = [];
    var oldData = [];
    var updatedData = [];
    var me = this;
    var fieldId = me._fieldId;

    var addOrUpdate = function addOrUpdate(item) {
      var id = item[fieldId];
      if (me._data[id]) {
        var oldItem = util.extend({}, me._data[id]);
        // update item
        id = me._updateItem(item);
        updatedIds.push(id);
        updatedData.push(item);
        oldData.push(oldItem);
      } else {
        // add new item
        id = me._addItem(item);
        addedIds.push(id);
      }
    };

    if (Array.isArray(data)) {
      // Array
      for (var i = 0, len = data.length; i < len; i++) {
        if (data[i] instanceof Object) {
          addOrUpdate(data[i]);
        } else {
          console.warn('Ignoring input item, which is not an object at index ' + i);
        }
      }
    } else if (data instanceof Object) {
      // Single item
      addOrUpdate(data);
    } else {
      throw new Error('Unknown dataType');
    }

    if (addedIds.length) {
      this._trigger('add', { items: addedIds }, senderId);
    }
    if (updatedIds.length) {
      var props = { items: updatedIds, oldData: oldData, data: updatedData };
      // TODO: remove deprecated property 'data' some day
      //Object.defineProperty(props, 'data', {
      //  'get': (function() {
      //    console.warn('Property data is deprecated. Use DataSet.get(ids) to retrieve the new data, use the oldData property on this object to get the old data');
      //    return updatedData;
      //  }).bind(this)
      //});
      this._trigger('update', props, senderId);
    }

    return addedIds.concat(updatedIds);
  };

  /**
   * Get a data item or multiple items.
   *
   * Usage:
   *
   *     get()
   *     get(options: Object)
   *
   *     get(id: Number | String)
   *     get(id: Number | String, options: Object)
   *
   *     get(ids: Number[] | String[])
   *     get(ids: Number[] | String[], options: Object)
   *
   * Where:
   *
   * {Number | String} id         The id of an item
   * {Number[] | String{}} ids    An array with ids of items
   * {Object} options             An Object with options. Available options:
   * {String} [returnType]        Type of data to be returned.
   *                              Can be 'Array' (default) or 'Object'.
   * {Object.<String, String>} [type]
   * {String[]} [fields]          field names to be returned
   * {function} [filter]          filter items
   * {String | function} [order]  Order the items by a field name or custom sort function.
   * @throws Error
   */
  DataSet.prototype.get = function (args) {
    var me = this;

    // parse the arguments
    var id, ids, options;
    var firstType = util.getType(arguments[0]);
    if (firstType == 'String' || firstType == 'Number') {
      // get(id [, options])
      id = arguments[0];
      options = arguments[1];
    } else if (firstType == 'Array') {
      // get(ids [, options])
      ids = arguments[0];
      options = arguments[1];
    } else {
      // get([, options])
      options = arguments[0];
    }

    // determine the return type
    var returnType;
    if (options && options.returnType) {
      var allowedValues = ['Array', 'Object'];
      returnType = allowedValues.indexOf(options.returnType) == -1 ? 'Array' : options.returnType;
    } else {
      returnType = 'Array';
    }

    // build options
    var type = options && options.type || this._options.type;
    var filter = options && options.filter;
    var items = [],
        item,
        itemIds,
        itemId,
        i,
        len;

    // convert items
    if (id != undefined) {
      // return a single item
      item = me._getItem(id, type);
      if (item && filter && !filter(item)) {
        item = null;
      }
    } else if (ids != undefined) {
      // return a subset of items
      for (i = 0, len = ids.length; i < len; i++) {
        item = me._getItem(ids[i], type);
        if (!filter || filter(item)) {
          items.push(item);
        }
      }
    } else {
      // return all items
      itemIds = Object.keys(this._data);
      for (i = 0, len = itemIds.length; i < len; i++) {
        itemId = itemIds[i];
        item = me._getItem(itemId, type);
        if (!filter || filter(item)) {
          items.push(item);
        }
      }
    }

    // order the results
    if (options && options.order && id == undefined) {
      this._sort(items, options.order);
    }

    // filter fields of the items
    if (options && options.fields) {
      var fields = options.fields;
      if (id != undefined) {
        item = this._filterFields(item, fields);
      } else {
        for (i = 0, len = items.length; i < len; i++) {
          items[i] = this._filterFields(items[i], fields);
        }
      }
    }

    // return the results
    if (returnType == 'Object') {
      var result = {},
          resultant;
      for (i = 0, len = items.length; i < len; i++) {
        resultant = items[i];
        result[resultant.id] = resultant;
      }
      return result;
    } else {
      if (id != undefined) {
        // a single item
        return item;
      } else {
        // just return our array
        return items;
      }
    }
  };

  /**
   * Get ids of all items or from a filtered set of items.
   * @param {Object} [options]    An Object with options. Available options:
   *                              {function} [filter] filter items
   *                              {String | function} [order] Order the items by
   *                                  a field name or custom sort function.
   * @return {Array} ids
   */
  DataSet.prototype.getIds = function (options) {
    var data = this._data,
        filter = options && options.filter,
        order = options && options.order,
        type = options && options.type || this._options.type,
        itemIds = Object.keys(data),
        i,
        len,
        id,
        item,
        items,
        ids = [];

    if (filter) {
      // get filtered items
      if (order) {
        // create ordered list
        items = [];
        for (i = 0, len = itemIds.length; i < len; i++) {
          id = itemIds[i];
          item = this._getItem(id, type);
          if (filter(item)) {
            items.push(item);
          }
        }

        this._sort(items, order);

        for (i = 0, len = items.length; i < len; i++) {
          ids.push(items[i][this._fieldId]);
        }
      } else {
        // create unordered list
        for (i = 0, len = itemIds.length; i < len; i++) {
          id = itemIds[i];
          item = this._getItem(id, type);
          if (filter(item)) {
            ids.push(item[this._fieldId]);
          }
        }
      }
    } else {
      // get all items
      if (order) {
        // create an ordered list
        items = [];
        for (i = 0, len = itemIds.length; i < len; i++) {
          id = itemIds[i];
          items.push(data[id]);
        }

        this._sort(items, order);

        for (i = 0, len = items.length; i < len; i++) {
          ids.push(items[i][this._fieldId]);
        }
      } else {
        // create unordered list
        for (i = 0, len = itemIds.length; i < len; i++) {
          id = itemIds[i];
          item = data[id];
          ids.push(item[this._fieldId]);
        }
      }
    }

    return ids;
  };

  /**
   * Returns the DataSet itself. Is overwritten for example by the DataView,
   * which returns the DataSet it is connected to instead.
   */
  DataSet.prototype.getDataSet = function () {
    return this;
  };

  /**
   * Execute a callback function for every item in the dataset.
   * @param {function} callback
   * @param {Object} [options]    Available options:
   *                              {Object.<String, String>} [type]
   *                              {String[]} [fields] filter fields
   *                              {function} [filter] filter items
   *                              {String | function} [order] Order the items by
   *                                  a field name or custom sort function.
   */
  DataSet.prototype.forEach = function (callback, options) {
    var filter = options && options.filter,
        type = options && options.type || this._options.type,
        data = this._data,
        itemIds = Object.keys(data),
        i,
        len,
        item,
        id;

    if (options && options.order) {
      // execute forEach on ordered list
      var items = this.get(options);

      for (i = 0, len = items.length; i < len; i++) {
        item = items[i];
        id = item[this._fieldId];
        callback(item, id);
      }
    } else {
      // unordered
      for (i = 0, len = itemIds.length; i < len; i++) {
        id = itemIds[i];
        item = this._getItem(id, type);
        if (!filter || filter(item)) {
          callback(item, id);
        }
      }
    }
  };

  /**
   * Map every item in the dataset.
   * @param {function} callback
   * @param {Object} [options]    Available options:
   *                              {Object.<String, String>} [type]
   *                              {String[]} [fields] filter fields
   *                              {function} [filter] filter items
   *                              {String | function} [order] Order the items by
   *                                  a field name or custom sort function.
   * @return {Object[]} mappedItems
   */
  DataSet.prototype.map = function (callback, options) {
    var filter = options && options.filter,
        type = options && options.type || this._options.type,
        mappedItems = [],
        data = this._data,
        itemIds = Object.keys(data),
        i,
        len,
        id,
        item;

    // convert and filter items
    for (i = 0, len = itemIds.length; i < len; i++) {
      id = itemIds[i];
      item = this._getItem(id, type);
      if (!filter || filter(item)) {
        mappedItems.push(callback(item, id));
      }
    }

    // order items
    if (options && options.order) {
      this._sort(mappedItems, options.order);
    }

    return mappedItems;
  };

  /**
   * Filter the fields of an item
   * @param {Object | null} item
   * @param {String[]} fields     Field names
   * @return {Object | null} filteredItem or null if no item is provided
   * @private
   */
  DataSet.prototype._filterFields = function (item, fields) {
    if (!item) {
      // item is null
      return item;
    }

    var filteredItem = {},
        itemFields = Object.keys(item),
        len = itemFields.length,
        i,
        field;

    if (Array.isArray(fields)) {
      for (i = 0; i < len; i++) {
        field = itemFields[i];
        if (fields.indexOf(field) != -1) {
          filteredItem[field] = item[field];
        }
      }
    } else {
      for (i = 0; i < len; i++) {
        field = itemFields[i];
        if (fields.hasOwnProperty(field)) {
          filteredItem[fields[field]] = item[field];
        }
      }
    }

    return filteredItem;
  };

  /**
   * Sort the provided array with items
   * @param {Object[]} items
   * @param {String | function} order      A field name or custom sort function.
   * @private
   */
  DataSet.prototype._sort = function (items, order) {
    if (util.isString(order)) {
      // order by provided field name
      var name = order; // field name
      items.sort(function (a, b) {
        var av = a[name];
        var bv = b[name];
        return av > bv ? 1 : av < bv ? -1 : 0;
      });
    } else if (typeof order === 'function') {
      // order by sort function
      items.sort(order);
    }
    // TODO: extend order by an Object {field:String, direction:String}
    //       where direction can be 'asc' or 'desc'
    else {
        throw new TypeError('Order must be a function or a string');
      }
  };

  /**
   * Remove an object by pointer or by id
   * @param {String | Number | Object | Array} id Object or id, or an array with
   *                                              objects or ids to be removed
   * @param {String} [senderId] Optional sender id
   * @return {Array} removedIds
   */
  DataSet.prototype.remove = function (id, senderId) {
    var removedIds = [],
        removedItems = [],
        ids = [],
        i,
        len,
        itemId,
        item;

    // force everything to be an array for simplicity
    ids = Array.isArray(id) ? id : [id];

    for (i = 0, len = ids.length; i < len; i++) {
      item = this._remove(ids[i]);
      if (item) {
        itemId = item[this._fieldId];
        if (itemId) {
          removedIds.push(itemId);
          removedItems.push(item);
        }
      }
    }

    if (removedIds.length) {
      this._trigger('remove', { items: removedIds, oldData: removedItems }, senderId);
    }

    return removedIds;
  };

  /**
   * Remove an item by its id
   * @param {Number | String | Object} id   id or item
   * @returns {Number | String | null} id
   * @private
   */
  DataSet.prototype._remove = function (id) {
    var item, ident;

    // confirm the id to use based on the args type
    if (util.isNumber(id) || util.isString(id)) {
      ident = id;
    } else if (id instanceof Object) {
      ident = id[this._fieldId]; // look for the identifier field using _fieldId
    }

    // do the remove if the item is found
    if (ident !== undefined && this._data[ident]) {
      item = this._data[ident];
      delete this._data[ident];
      this.length--;
      return item;
    }
    return null;
  };

  /**
   * Clear the data
   * @param {String} [senderId] Optional sender id
   * @return {Array} removedIds    The ids of all removed items
   */
  DataSet.prototype.clear = function (senderId) {
    var i, len;
    var ids = Object.keys(this._data);
    var items = [];

    for (i = 0, len = ids.length; i < len; i++) {
      items.push(this._data[ids[i]]);
    }

    this._data = {};
    this.length = 0;

    this._trigger('remove', { items: ids, oldData: items }, senderId);

    return ids;
  };

  /**
   * Find the item with maximum value of a specified field
   * @param {String} field
   * @return {Object | null} item  Item containing max value, or null if no items
   */
  DataSet.prototype.max = function (field) {
    var data = this._data,
        itemIds = Object.keys(data),
        max = null,
        maxField = null,
        i,
        len;

    for (i = 0, len = itemIds.length; i < len; i++) {
      var id = itemIds[i];
      var item = data[id];
      var itemField = item[field];
      if (itemField != null && (!max || itemField > maxField)) {
        max = item;
        maxField = itemField;
      }
    }

    return max;
  };

  /**
   * Find the item with minimum value of a specified field
   * @param {String} field
   * @return {Object | null} item  Item containing max value, or null if no items
   */
  DataSet.prototype.min = function (field) {
    var data = this._data,
        itemIds = Object.keys(data),
        min = null,
        minField = null,
        i,
        len;

    for (i = 0, len = itemIds.length; i < len; i++) {
      var id = itemIds[i];
      var item = data[id];
      var itemField = item[field];
      if (itemField != null && (!min || itemField < minField)) {
        min = item;
        minField = itemField;
      }
    }

    return min;
  };

  /**
   * Find all distinct values of a specified field
   * @param {String} field
   * @return {Array} values  Array containing all distinct values. If data items
   *                         do not contain the specified field are ignored.
   *                         The returned array is unordered.
   */
  DataSet.prototype.distinct = function (field) {
    var data = this._data;
    var itemIds = Object.keys(data);
    var values = [];
    var fieldType = this._options.type && this._options.type[field] || null;
    var count = 0;
    var i, j, len;

    for (i = 0, len = itemIds.length; i < len; i++) {
      var id = itemIds[i];
      var item = data[id];
      var value = item[field];
      var exists = false;
      for (j = 0; j < count; j++) {
        if (values[j] == value) {
          exists = true;
          break;
        }
      }
      if (!exists && value !== undefined) {
        values[count] = value;
        count++;
      }
    }

    if (fieldType) {
      for (i = 0, len = values.length; i < len; i++) {
        values[i] = util.convert(values[i], fieldType);
      }
    }

    return values;
  };

  /**
   * Add a single item. Will fail when an item with the same id already exists.
   * @param {Object} item
   * @return {String} id
   * @private
   */
  DataSet.prototype._addItem = function (item) {
    var id = item[this._fieldId];

    if (id != undefined) {
      // check whether this id is already taken
      if (this._data[id]) {
        // item already exists
        throw new Error('Cannot add item: item with id ' + id + ' already exists');
      }
    } else {
      // generate an id
      id = util.randomUUID();
      item[this._fieldId] = id;
    }

    var d = {},
        fields = Object.keys(item),
        i,
        len;
    for (i = 0, len = fields.length; i < len; i++) {
      var field = fields[i];
      var fieldType = this._type[field]; // type may be undefined
      d[field] = util.convert(item[field], fieldType);
    }
    this._data[id] = d;
    this.length++;

    return id;
  };

  /**
   * Get an item. Fields can be converted to a specific type
   * @param {String} id
   * @param {Object.<String, String>} [types]  field types to convert
   * @return {Object | null} item
   * @private
   */
  DataSet.prototype._getItem = function (id, types) {
    var field, value, i, len;

    // get the item from the dataset
    var raw = this._data[id];
    if (!raw) {
      return null;
    }

    // convert the items field types
    var converted = {},
        fields = Object.keys(raw);

    if (types) {
      for (i = 0, len = fields.length; i < len; i++) {
        field = fields[i];
        value = raw[field];
        converted[field] = util.convert(value, types[field]);
      }
    } else {
      // no field types specified, no converting needed
      for (i = 0, len = fields.length; i < len; i++) {
        field = fields[i];
        value = raw[field];
        converted[field] = value;
      }
    }
    return converted;
  };

  /**
   * Update a single item: merge with existing item.
   * Will fail when the item has no id, or when there does not exist an item
   * with the same id.
   * @param {Object} item
   * @return {String} id
   * @private
   */
  DataSet.prototype._updateItem = function (item) {
    var id = item[this._fieldId];
    if (id == undefined) {
      throw new Error('Cannot update item: item has no id (item: ' + JSON.stringify(item) + ')');
    }
    var d = this._data[id];
    if (!d) {
      // item doesn't exist
      throw new Error('Cannot update item: no item with id ' + id + ' found');
    }

    // merge with current item
    var fields = Object.keys(item);
    for (var i = 0, len = fields.length; i < len; i++) {
      var field = fields[i];
      var fieldType = this._type[field]; // type may be undefined
      d[field] = util.convert(item[field], fieldType);
    }

    return id;
  };

  module.exports = DataSet;

/***/ },
/* 10 */
/***/ function(module, exports) {

  'use strict';

  /**
   * A queue
   * @param {Object} options
   *            Available options:
   *            - delay: number    When provided, the queue will be flushed
   *                               automatically after an inactivity of this delay
   *                               in milliseconds.
   *                               Default value is null.
   *            - max: number      When the queue exceeds the given maximum number
   *                               of entries, the queue is flushed automatically.
   *                               Default value of max is Infinity.
   * @constructor
   */
  function Queue(options) {
    // options
    this.delay = null;
    this.max = Infinity;

    // properties
    this._queue = [];
    this._timeout = null;
    this._extended = null;

    this.setOptions(options);
  }

  /**
   * Update the configuration of the queue
   * @param {Object} options
   *            Available options:
   *            - delay: number    When provided, the queue will be flushed
   *                               automatically after an inactivity of this delay
   *                               in milliseconds.
   *                               Default value is null.
   *            - max: number      When the queue exceeds the given maximum number
   *                               of entries, the queue is flushed automatically.
   *                               Default value of max is Infinity.
   * @param options
   */
  Queue.prototype.setOptions = function (options) {
    if (options && typeof options.delay !== 'undefined') {
      this.delay = options.delay;
    }
    if (options && typeof options.max !== 'undefined') {
      this.max = options.max;
    }

    this._flushIfNeeded();
  };

  /**
   * Extend an object with queuing functionality.
   * The object will be extended with a function flush, and the methods provided
   * in options.replace will be replaced with queued ones.
   * @param {Object} object
   * @param {Object} options
   *            Available options:
   *            - replace: Array.<string>
   *                               A list with method names of the methods
   *                               on the object to be replaced with queued ones.
   *            - delay: number    When provided, the queue will be flushed
   *                               automatically after an inactivity of this delay
   *                               in milliseconds.
   *                               Default value is null.
   *            - max: number      When the queue exceeds the given maximum number
   *                               of entries, the queue is flushed automatically.
   *                               Default value of max is Infinity.
   * @return {Queue} Returns the created queue
   */
  Queue.extend = function (object, options) {
    var queue = new Queue(options);

    if (object.flush !== undefined) {
      throw new Error('Target object already has a property flush');
    }
    object.flush = function () {
      queue.flush();
    };

    var methods = [{
      name: 'flush',
      original: undefined
    }];

    if (options && options.replace) {
      for (var i = 0; i < options.replace.length; i++) {
        var name = options.replace[i];
        methods.push({
          name: name,
          original: object[name]
        });
        queue.replace(object, name);
      }
    }

    queue._extended = {
      object: object,
      methods: methods
    };

    return queue;
  };

  /**
   * Destroy the queue. The queue will first flush all queued actions, and in
   * case it has extended an object, will restore the original object.
   */
  Queue.prototype.destroy = function () {
    this.flush();

    if (this._extended) {
      var object = this._extended.object;
      var methods = this._extended.methods;
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        if (method.original) {
          object[method.name] = method.original;
        } else {
          delete object[method.name];
        }
      }
      this._extended = null;
    }
  };

  /**
   * Replace a method on an object with a queued version
   * @param {Object} object   Object having the method
   * @param {string} method   The method name
   */
  Queue.prototype.replace = function (object, method) {
    var me = this;
    var original = object[method];
    if (!original) {
      throw new Error('Method ' + method + ' undefined');
    }

    object[method] = function () {
      // create an Array with the arguments
      var args = [];
      for (var i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      // add this call to the queue
      me.queue({
        args: args,
        fn: original,
        context: this
      });
    };
  };

  /**
   * Queue a call
   * @param {function | {fn: function, args: Array} | {fn: function, args: Array, context: Object}} entry
   */
  Queue.prototype.queue = function (entry) {
    if (typeof entry === 'function') {
      this._queue.push({ fn: entry });
    } else {
      this._queue.push(entry);
    }

    this._flushIfNeeded();
  };

  /**
   * Check whether the queue needs to be flushed
   * @private
   */
  Queue.prototype._flushIfNeeded = function () {
    // flush when the maximum is exceeded.
    if (this._queue.length > this.max) {
      this.flush();
    }

    // flush after a period of inactivity when a delay is configured
    clearTimeout(this._timeout);
    if (this.queue.length > 0 && typeof this.delay === 'number') {
      var me = this;
      this._timeout = setTimeout(function () {
        me.flush();
      }, this.delay);
    }
  };

  /**
   * Flush all queued calls
   */
  Queue.prototype.flush = function () {
    while (this._queue.length > 0) {
      var entry = this._queue.shift();
      entry.fn.apply(entry.context || entry.fn, entry.args || []);
    }
  };

  module.exports = Queue;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);
  var DataSet = __webpack_require__(9);

  /**
   * DataView
   *
   * a dataview offers a filtered view on a dataset or an other dataview.
   *
   * @param {DataSet | DataView} data
   * @param {Object} [options]   Available options: see method get
   *
   * @constructor DataView
   */
  function DataView(data, options) {
    this._data = null;
    this._ids = {}; // ids of the items currently in memory (just contains a boolean true)
    this.length = 0; // number of items in the DataView
    this._options = options || {};
    this._fieldId = 'id'; // name of the field containing id
    this._subscribers = {}; // event subscribers

    var me = this;
    this.listener = function () {
      me._onEvent.apply(me, arguments);
    };

    this.setData(data);
  }

  // TODO: implement a function .config() to dynamically update things like configured filter
  // and trigger changes accordingly

  /**
   * Set a data source for the view
   * @param {DataSet | DataView} data
   */
  DataView.prototype.setData = function (data) {
    var ids, id, i, len, items;

    if (this._data) {
      // unsubscribe from current dataset
      if (this._data.off) {
        this._data.off('*', this.listener);
      }

      // trigger a remove of all items in memory
      ids = this._data.getIds({ filter: this._options && this._options.filter });
      items = [];

      for (i = 0, len = ids.length; i < len; i++) {
        items.push(this._data._data[ids[i]]);
      }

      this._ids = {};
      this.length = 0;
      this._trigger('remove', { items: ids, oldData: items });
    }

    this._data = data;

    if (this._data) {
      // update fieldId
      this._fieldId = this._options.fieldId || this._data && this._data.options && this._data.options.fieldId || 'id';

      // trigger an add of all added items
      ids = this._data.getIds({ filter: this._options && this._options.filter });
      for (i = 0, len = ids.length; i < len; i++) {
        id = ids[i];
        this._ids[id] = true;
      }
      this.length = ids.length;
      this._trigger('add', { items: ids });

      // subscribe to new dataset
      if (this._data.on) {
        this._data.on('*', this.listener);
      }
    }
  };

  /**
   * Refresh the DataView. Useful when the DataView has a filter function
   * containing a variable parameter.
   */
  DataView.prototype.refresh = function () {
    var id, i, len;
    var ids = this._data.getIds({ filter: this._options && this._options.filter }),
        oldIds = Object.keys(this._ids),
        newIds = {},
        addedIds = [],
        removedIds = [],
        removedItems = [];

    // check for additions
    for (i = 0, len = ids.length; i < len; i++) {
      id = ids[i];
      newIds[id] = true;
      if (!this._ids[id]) {
        addedIds.push(id);
        this._ids[id] = true;
      }
    }

    // check for removals
    for (i = 0, len = oldIds.length; i < len; i++) {
      id = oldIds[i];
      if (!newIds[id]) {
        removedIds.push(id);
        removedItems.push(this._data[id]);
        delete this._ids[id];
      }
    }

    this.length += addedIds.length - removedIds.length;

    // trigger events
    if (addedIds.length) {
      this._trigger('add', { items: addedIds });
    }
    if (removedIds.length) {
      this._trigger('remove', { items: removedIds, oldData: removedItems });
    }
  };

  /**
   * Get data from the data view
   *
   * Usage:
   *
   *     get()
   *     get(options: Object)
   *     get(options: Object, data: Array | DataTable)
   *
   *     get(id: Number)
   *     get(id: Number, options: Object)
   *     get(id: Number, options: Object, data: Array | DataTable)
   *
   *     get(ids: Number[])
   *     get(ids: Number[], options: Object)
   *     get(ids: Number[], options: Object, data: Array | DataTable)
   *
   * Where:
   *
   * {Number | String} id         The id of an item
   * {Number[] | String{}} ids    An array with ids of items
   * {Object} options             An Object with options. Available options:
   *                              {String} [type] Type of data to be returned. Can
   *                                              be 'DataTable' or 'Array' (default)
   *                              {Object.<String, String>} [convert]
   *                              {String[]} [fields] field names to be returned
   *                              {function} [filter] filter items
   *                              {String | function} [order] Order the items by
   *                                  a field name or custom sort function.
   * {Array | DataTable} [data]   If provided, items will be appended to this
   *                              array or table. Required in case of Google
   *                              DataTable.
   * @param args
   */
  DataView.prototype.get = function (args) {
    var me = this;

    // parse the arguments
    var ids, options, data;
    var firstType = util.getType(arguments[0]);
    if (firstType == 'String' || firstType == 'Number' || firstType == 'Array') {
      // get(id(s) [, options] [, data])
      ids = arguments[0]; // can be a single id or an array with ids
      options = arguments[1];
      data = arguments[2];
    } else {
      // get([, options] [, data])
      options = arguments[0];
      data = arguments[1];
    }

    // extend the options with the default options and provided options
    var viewOptions = util.extend({}, this._options, options);

    // create a combined filter method when needed
    if (this._options.filter && options && options.filter) {
      viewOptions.filter = function (item) {
        return me._options.filter(item) && options.filter(item);
      };
    }

    // build up the call to the linked data set
    var getArguments = [];
    if (ids != undefined) {
      getArguments.push(ids);
    }
    getArguments.push(viewOptions);
    getArguments.push(data);

    return this._data && this._data.get.apply(this._data, getArguments);
  };

  /**
   * Get ids of all items or from a filtered set of items.
   * @param {Object} [options]    An Object with options. Available options:
   *                              {function} [filter] filter items
   *                              {String | function} [order] Order the items by
   *                                  a field name or custom sort function.
   * @return {Array} ids
   */
  DataView.prototype.getIds = function (options) {
    var ids;

    if (this._data) {
      var defaultFilter = this._options.filter;
      var filter;

      if (options && options.filter) {
        if (defaultFilter) {
          filter = function filter(item) {
            return defaultFilter(item) && options.filter(item);
          };
        } else {
          filter = options.filter;
        }
      } else {
        filter = defaultFilter;
      }

      ids = this._data.getIds({
        filter: filter,
        order: options && options.order
      });
    } else {
      ids = [];
    }

    return ids;
  };

  /**
   * Map every item in the dataset.
   * @param {function} callback
   * @param {Object} [options]    Available options:
   *                              {Object.<String, String>} [type]
   *                              {String[]} [fields] filter fields
   *                              {function} [filter] filter items
   *                              {String | function} [order] Order the items by
   *                                  a field name or custom sort function.
   * @return {Object[]} mappedItems
   */
  DataView.prototype.map = function (callback, options) {
    var mappedItems = [];
    if (this._data) {
      var defaultFilter = this._options.filter;
      var filter;

      if (options && options.filter) {
        if (defaultFilter) {
          filter = function filter(item) {
            return defaultFilter(item) && options.filter(item);
          };
        } else {
          filter = options.filter;
        }
      } else {
        filter = defaultFilter;
      }

      mappedItems = this._data.map(callback, {
        filter: filter,
        order: options && options.order
      });
    } else {
      mappedItems = [];
    }

    return mappedItems;
  };

  /**
   * Get the DataSet to which this DataView is connected. In case there is a chain
   * of multiple DataViews, the root DataSet of this chain is returned.
   * @return {DataSet} dataSet
   */
  DataView.prototype.getDataSet = function () {
    var dataSet = this;
    while (dataSet instanceof DataView) {
      dataSet = dataSet._data;
    }
    return dataSet || null;
  };

  /**
   * Event listener. Will propagate all events from the connected data set to
   * the subscribers of the DataView, but will filter the items and only trigger
   * when there are changes in the filtered data set.
   * @param {String} event
   * @param {Object | null} params
   * @param {String} senderId
   * @private
   */
  DataView.prototype._onEvent = function (event, params, senderId) {
    var i, len, id, item;
    var ids = params && params.items;
    var addedIds = [],
        updatedIds = [],
        removedIds = [],
        oldItems = [],
        updatedItems = [],
        removedItems = [];

    if (ids && this._data) {
      switch (event) {
        case 'add':
          // filter the ids of the added items
          for (i = 0, len = ids.length; i < len; i++) {
            id = ids[i];
            item = this.get(id);
            if (item) {
              this._ids[id] = true;
              addedIds.push(id);
            }
          }

          break;

        case 'update':
          // determine the event from the views viewpoint: an updated
          // item can be added, updated, or removed from this view.
          for (i = 0, len = ids.length; i < len; i++) {
            id = ids[i];
            item = this.get(id);

            if (item) {
              if (this._ids[id]) {
                updatedIds.push(id);
                updatedItems.push(params.data[i]);
                oldItems.push(params.oldData[i]);
              } else {
                this._ids[id] = true;
                addedIds.push(id);
              }
            } else {
              if (this._ids[id]) {
                delete this._ids[id];
                removedIds.push(id);
                removedItems.push(params.oldData[i]);
              } else {
                // nothing interesting for me :-(
              }
            }
          }

          break;

        case 'remove':
          // filter the ids of the removed items
          for (i = 0, len = ids.length; i < len; i++) {
            id = ids[i];
            if (this._ids[id]) {
              delete this._ids[id];
              removedIds.push(id);
              removedItems.push(params.oldData[i]);
            }
          }

          break;
      }

      this.length += addedIds.length - removedIds.length;

      if (addedIds.length) {
        this._trigger('add', { items: addedIds }, senderId);
      }
      if (updatedIds.length) {
        this._trigger('update', { items: updatedIds, oldData: oldItems, data: updatedItems }, senderId);
      }
      if (removedIds.length) {
        this._trigger('remove', { items: removedIds, oldData: removedItems }, senderId);
      }
    }
  };

  // copy subscription functionality from DataSet
  DataView.prototype.on = DataSet.prototype.on;
  DataView.prototype.off = DataSet.prototype.off;
  DataView.prototype._trigger = DataSet.prototype._trigger;

  // TODO: make these functions deprecated (replaced with `on` and `off` since version 0.5)
  DataView.prototype.subscribe = DataView.prototype.on;
  DataView.prototype.unsubscribe = DataView.prototype.off;

  module.exports = DataView;

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Emitter = __webpack_require__(13);var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);
  var util = __webpack_require__(1);
  var Point3d = __webpack_require__(14);
  var Point2d = __webpack_require__(15);
  var Camera = __webpack_require__(16);
  var Filter = __webpack_require__(17);
  var Slider = __webpack_require__(18);
  var StepNumber = __webpack_require__(19);
  var Range = __webpack_require__(20);
  var Settings = __webpack_require__(21);

  /// enumerate the available styles
  Graph3d.STYLE = Settings.STYLE;

  /**
   * Following label is used in the settings to describe values which should be
   * determined by the code while running, from the current data and graph style.
   * 
   * Using 'undefined' directly achieves the same thing, but this is more
   * descriptive by describing the intent.
   */
  var autoByDefault = undefined;

  /**
   * Default values for option settings.
   *
   * These are the values used when a Graph3d instance is initialized without
   * custom settings.
   *
   * If a field is not in this list, a default value of 'autoByDefault' is assumed,
   * which is just an alias for 'undefined'.
   */
  var DEFAULTS = {
    width: '400px',
    height: '400px',
    filterLabel: 'time',
    legendLabel: 'value',
    xLabel: 'x',
    yLabel: 'y',
    zLabel: 'z',
    xValueLabel: function xValueLabel(v) {
      return v;
    },
    yValueLabel: function yValueLabel(v) {
      return v;
    },
    zValueLabel: function zValueLabel(v) {
      return v;
    },
    showGrid: true,
    showPerspective: true,
    showShadow: false,
    keepAspectRatio: true,
    verticalRatio: 0.5, // 0.1 to 1.0, where 1.0 results in a 'cube'
    dotSizeRatio: 0.02, // size of the dots as a fraction of the graph width

    showAnimationControls: autoByDefault,
    animationInterval: 1000, // milliseconds
    animationPreload: false,
    animationAutoStart: autoByDefault,

    axisColor: '#4D4D4D',
    gridColor: '#D3D3D3',
    xCenter: '55%',
    yCenter: '50%',

    style: Graph3d.STYLE.DOT,
    tooltip: false,
    showLegend: autoByDefault, // determined by graph style
    backgroundColor: autoByDefault,

    dataColor: {
      fill: '#7DC1FF',
      stroke: '#3267D2',
      strokeWidth: 1 // px
    },

    cameraPosition: {
      horizontal: 1.0,
      vertical: 0.5,
      distance: 1.7
    },

    xBarWidth: autoByDefault,
    yBarWidth: autoByDefault,
    valueMin: autoByDefault,
    valueMax: autoByDefault,
    xMin: autoByDefault,
    xMax: autoByDefault,
    xStep: autoByDefault,
    yMin: autoByDefault,
    yMax: autoByDefault,
    yStep: autoByDefault,
    zMin: autoByDefault,
    zMax: autoByDefault,
    zStep: autoByDefault
  };

  // -----------------------------------------------------------------------------
  // Class Graph3d
  // -----------------------------------------------------------------------------


  /**
   * @constructor Graph3d
   * Graph3d displays data in 3d.
   *
   * Graph3d is developed in javascript as a Google Visualization Chart.
   *
   * @param {Element} container   The DOM element in which the Graph3d will
   *                              be created. Normally a div element.
   * @param {DataSet | DataView | Array} [data]
   * @param {Object} [options]
   */
  function Graph3d(container, data, options) {
    if (!(this instanceof Graph3d)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // create variables and set default values
    this.containerElement = container;

    this.dataTable = null; // The original data table
    this.dataPoints = null; // The table with point objects

    // create a frame and canvas
    this.create();

    Settings.setDefaults(DEFAULTS, this);

    // the column indexes
    this.colX = undefined;
    this.colY = undefined;
    this.colZ = undefined;
    this.colValue = undefined;
    this.colFilter = undefined;

    // TODO: customize axis range

    // apply options (also when undefined)
    this.setOptions(options);

    // apply data
    if (data) {
      this.setData(data);
    }
  }

  // Extend Graph3d with an Emitter mixin
  Emitter(Graph3d.prototype);

  /**
   * Calculate the scaling values, dependent on the range in x, y, and z direction
   */
  Graph3d.prototype._setScale = function () {
    this.scale = new Point3d(1 / this.xRange.range(), 1 / this.yRange.range(), 1 / this.zRange.range());

    // keep aspect ration between x and y scale if desired
    if (this.keepAspectRatio) {
      if (this.scale.x < this.scale.y) {
        //noinspection JSSuspiciousNameCombination
        this.scale.y = this.scale.x;
      } else {
        //noinspection JSSuspiciousNameCombination
        this.scale.x = this.scale.y;
      }
    }

    // scale the vertical axis
    this.scale.z *= this.verticalRatio;
    // TODO: can this be automated? verticalRatio?

    // determine scale for (optional) value
    if (this.valueRange !== undefined) {
      this.scale.value = 1 / this.valueRange.range();
    }

    // position the camera arm
    var xCenter = this.xRange.center() * this.scale.x;
    var yCenter = this.yRange.center() * this.scale.y;
    var zCenter = this.zRange.center() * this.scale.z;
    this.camera.setArmLocation(xCenter, yCenter, zCenter);
  };

  /**
   * Convert a 3D location to a 2D location on screen
   * Source: ttp://en.wikipedia.org/wiki/3D_projection
   *
   * @param   {Point3d} point3d  A 3D point with parameters x, y, z
   * @returns {Point2d} point2d  A 2D point with parameters x, y
   */
  Graph3d.prototype._convert3Dto2D = function (point3d) {
    var translation = this._convertPointToTranslation(point3d);
    return this._convertTranslationToScreen(translation);
  };

  /**
   * Convert a 3D location its translation seen from the camera
   * Source: http://en.wikipedia.org/wiki/3D_projection
   *
   * @param   {Point3d} point3d     A 3D point with parameters x, y, z
   * @returns {Point3d} translation A 3D point with parameters x, y, z This is
   *                                the translation of the point, seen from the
   *                                camera.
   */
  Graph3d.prototype._convertPointToTranslation = function (point3d) {
    var cameraLocation = this.camera.getCameraLocation(),
        cameraRotation = this.camera.getCameraRotation(),
        ax = point3d.x * this.scale.x,
        ay = point3d.y * this.scale.y,
        az = point3d.z * this.scale.z,
        cx = cameraLocation.x,
        cy = cameraLocation.y,
        cz = cameraLocation.z,


    // calculate angles
    sinTx = Math.sin(cameraRotation.x),
        cosTx = Math.cos(cameraRotation.x),
        sinTy = Math.sin(cameraRotation.y),
        cosTy = Math.cos(cameraRotation.y),
        sinTz = Math.sin(cameraRotation.z),
        cosTz = Math.cos(cameraRotation.z),


    // calculate translation
    dx = cosTy * (sinTz * (ay - cy) + cosTz * (ax - cx)) - sinTy * (az - cz),
        dy = sinTx * (cosTy * (az - cz) + sinTy * (sinTz * (ay - cy) + cosTz * (ax - cx))) + cosTx * (cosTz * (ay - cy) - sinTz * (ax - cx)),
        dz = cosTx * (cosTy * (az - cz) + sinTy * (sinTz * (ay - cy) + cosTz * (ax - cx))) - sinTx * (cosTz * (ay - cy) - sinTz * (ax - cx));

    return new Point3d(dx, dy, dz);
  };

  /**
   * Convert a translation point to a point on the screen
   *
   * @param   {Point3d} translation A 3D point with parameters x, y, z This is
   *                                the translation of the point, seen from the
   *                                camera.
   * @returns {Point2d} point2d     A 2D point with parameters x, y
   */
  Graph3d.prototype._convertTranslationToScreen = function (translation) {
    var ex = this.eye.x,
        ey = this.eye.y,
        ez = this.eye.z,
        dx = translation.x,
        dy = translation.y,
        dz = translation.z;

    // calculate position on screen from translation
    var bx;
    var by;
    if (this.showPerspective) {
      bx = (dx - ex) * (ez / dz);
      by = (dy - ey) * (ez / dz);
    } else {
      bx = dx * -(ez / this.camera.getArmLength());
      by = dy * -(ez / this.camera.getArmLength());
    }

    // shift and scale the point to the center of the screen
    // use the width of the graph to scale both horizontally and vertically.
    return new Point2d(this.currentXCenter + bx * this.frame.canvas.clientWidth, this.currentYCenter - by * this.frame.canvas.clientWidth);
  };

  /**
   * Calculate the translations and screen positions of all points
   */
  Graph3d.prototype._calcTranslations = function (points, sort) {
    if (sort === undefined) {
      sort = true;
    }

    for (var i = 0; i < points.length; i++) {
      var point = points[i];
      point.trans = this._convertPointToTranslation(point.point);
      point.screen = this._convertTranslationToScreen(point.trans);

      // calculate the translation of the point at the bottom (needed for sorting)
      var transBottom = this._convertPointToTranslation(point.bottom);
      point.dist = this.showPerspective ? transBottom.length() : -transBottom.z;
    }

    if (!sort) {
      return;
    }

    // sort the points on depth of their (x,y) position (not on z)
    var sortDepth = function sortDepth(a, b) {
      return b.dist - a.dist;
    };
    points.sort(sortDepth);
  };

  Graph3d.prototype.getNumberOfRows = function (data) {
    return data.length;
  };

  Graph3d.prototype.getNumberOfColumns = function (data) {
    var counter = 0;
    for (var column in data[0]) {
      if (data[0].hasOwnProperty(column)) {
        counter++;
      }
    }
    return counter;
  };

  Graph3d.prototype.getDistinctValues = function (data, column) {
    var distinctValues = [];
    for (var i = 0; i < data.length; i++) {
      if (distinctValues.indexOf(data[i][column]) == -1) {
        distinctValues.push(data[i][column]);
      }
    }
    return distinctValues;
  };

  /**
   * Get the absolute min/max values for the passed data column.
   *
   * @returns {Range} A Range instance with min/max members properly set.
   */
  Graph3d.prototype.getColumnRange = function (data, column) {
    var range = new Range();

    // Adjust the range so that it covers all values in the passed data elements.
    for (var i = 0; i < data.length; i++) {
      var item = data[i][column];
      range.adjust(item);
    }

    return range;
  };

  /**
   * Check if the state is consistent for the use of the value field.
   *
   * Throws if a problem is detected.
   */
  Graph3d.prototype._checkValueField = function (data) {

    var hasValueField = this.style === Graph3d.STYLE.BARCOLOR || this.style === Graph3d.STYLE.BARSIZE || this.style === Graph3d.STYLE.DOTCOLOR || this.style === Graph3d.STYLE.DOTSIZE;

    if (!hasValueField) {
      return; // No need to check further
    }

    // Following field must be present for the current graph style
    if (this.colValue === undefined) {
      throw new Error('Expected data to have ' + ' field \'style\' ' + ' for graph style \'' + this.style + '\'');
    }

    // The data must also contain this field.
    // Note that only first data element is checked.
    if (data[0][this.colValue] === undefined) {
      throw new Error('Expected data to have ' + ' field \'' + this.colValue + '\' ' + ' for graph style \'' + this.style + '\'');
    }
  };

  /**
   * Set default values for range
   *
   * The default values override the range values, if defined.
   *
   * Because it's possible that only defaultMin or defaultMax is set, it's better
   * to pass in a range already set with the min/max set from the data. Otherwise,
   * it's quite hard to process the min/max properly.
   */
  Graph3d.prototype._setRangeDefaults = function (range, defaultMin, defaultMax) {
    if (defaultMin !== undefined) {
      range.min = defaultMin;
    }

    if (defaultMax !== undefined) {
      range.max = defaultMax;
    }

    // This is the original way that the default min/max values were adjusted.
    // TODO: Perhaps it's better if an error is thrown if the values do not agree.
    //       But this will change the behaviour.
    if (range.max <= range.min) range.max = range.min + 1;
  };

  /**
   * Initialize the data from the data table. Calculate minimum and maximum values
   * and column index values
   * @param {Array | DataSet | DataView} rawData The data containing the items for
   *                                             the Graph.
   * @param {Number}                     style   Style Number
   */
  Graph3d.prototype._dataInitialize = function (rawData, style) {
    var me = this;

    // unsubscribe from the dataTable
    if (this.dataSet) {
      this.dataSet.off('*', this._onChange);
    }

    if (rawData === undefined) return;

    if (Array.isArray(rawData)) {
      rawData = new DataSet(rawData);
    }

    var data;
    if (rawData instanceof DataSet || rawData instanceof DataView) {
      data = rawData.get();
    } else {
      throw new Error('Array, DataSet, or DataView expected');
    }

    if (data.length == 0) return;

    this.dataSet = rawData;
    this.dataTable = data;

    // subscribe to changes in the dataset
    this._onChange = function () {
      me.setData(me.dataSet);
    };
    this.dataSet.on('*', this._onChange);

    // determine the location of x,y,z,value,filter columns
    this.colX = 'x';
    this.colY = 'y';
    this.colZ = 'z';

    var withBars = this.style == Graph3d.STYLE.BAR || this.style == Graph3d.STYLE.BARCOLOR || this.style == Graph3d.STYLE.BARSIZE;

    // determine barWidth from data
    if (withBars) {
      if (this.defaultXBarWidth !== undefined) {
        this.xBarWidth = this.defaultXBarWidth;
      } else {
        var dataX = this.getDistinctValues(data, this.colX);
        this.xBarWidth = dataX[1] - dataX[0] || 1;
      }

      if (this.defaultYBarWidth !== undefined) {
        this.yBarWidth = this.defaultYBarWidth;
      } else {
        var dataY = this.getDistinctValues(data, this.colY);
        this.yBarWidth = dataY[1] - dataY[0] || 1;
      }
    }

    // calculate minimums and maximums
    var NUMSTEPS = 5;

    var xRange = this.getColumnRange(data, this.colX);
    if (withBars) {
      xRange.expand(this.xBarWidth / 2);
    }
    this._setRangeDefaults(xRange, this.defaultXMin, this.defaultXMax);
    this.xRange = xRange;
    this.xStep = this.defaultXStep !== undefined ? this.defaultXStep : xRange.range() / NUMSTEPS;

    var yRange = this.getColumnRange(data, this.colY);
    if (withBars) {
      yRange.expand(this.yBarWidth / 2);
    }
    this._setRangeDefaults(yRange, this.defaultYMin, this.defaultYMax);
    this.yRange = yRange;
    this.yStep = this.defaultYStep !== undefined ? this.defaultYStep : yRange.range() / NUMSTEPS;

    var zRange = this.getColumnRange(data, this.colZ);
    this._setRangeDefaults(zRange, this.defaultZMin, this.defaultZMax);
    this.zRange = zRange;
    this.zStep = this.defaultZStep !== undefined ? this.defaultZStep : zRange.range() / NUMSTEPS;

    if (data[0].hasOwnProperty('style')) {
      this.colValue = 'style';
      var valueRange = this.getColumnRange(data, this.colValue);
      this._setRangeDefaults(valueRange, this.defaultValueMin, this.defaultValueMax);
      this.valueRange = valueRange;
    }

    // check if a filter column is provided
    // Needs to be started after zRange is defined
    if (data[0].hasOwnProperty('filter')) {
      // Only set this field if it's actually present
      this.colFilter = 'filter';

      if (this.dataFilter === undefined) {
        this.dataFilter = new Filter(rawData, this.colFilter, this);
        this.dataFilter.setOnLoadCallback(function () {
          me.redraw();
        });
      }
    }

    // set the scale dependent on the ranges.
    this._setScale();
  };

  /**
   * Filter the data based on the current filter
   *
   * @param   {Array} data
   * @returns {Array} dataPoints Array with point objects which can be drawn on
   *                             screen
   */
  Graph3d.prototype._getDataPoints = function (data) {
    // TODO: store the created matrix dataPoints in the filters instead of
    //       reloading each time.
    var x, y, i, z, obj, point;

    var dataPoints = [];

    if (this.style === Graph3d.STYLE.GRID || this.style === Graph3d.STYLE.SURFACE) {
      // copy all values from the google data table to a matrix
      // the provided values are supposed to form a grid of (x,y) positions

      // create two lists with all present x and y values
      var dataX = [];
      var dataY = [];
      for (i = 0; i < this.getNumberOfRows(data); i++) {
        x = data[i][this.colX] || 0;
        y = data[i][this.colY] || 0;

        if (dataX.indexOf(x) === -1) {
          dataX.push(x);
        }
        if (dataY.indexOf(y) === -1) {
          dataY.push(y);
        }
      }

      var sortNumber = function sortNumber(a, b) {
        return a - b;
      };
      dataX.sort(sortNumber);
      dataY.sort(sortNumber);

      // create a grid, a 2d matrix, with all values.
      var dataMatrix = []; // temporary data matrix
      for (i = 0; i < data.length; i++) {
        x = data[i][this.colX] || 0;
        y = data[i][this.colY] || 0;
        z = data[i][this.colZ] || 0;

        // TODO: implement Array().indexOf() for Internet Explorer
        var xIndex = dataX.indexOf(x);
        var yIndex = dataY.indexOf(y);

        if (dataMatrix[xIndex] === undefined) {
          dataMatrix[xIndex] = [];
        }

        var point3d = new Point3d();
        point3d.x = x;
        point3d.y = y;
        point3d.z = z;
        point3d.data = data[i];

        obj = {};
        obj.point = point3d;
        obj.trans = undefined;
        obj.screen = undefined;
        obj.bottom = new Point3d(x, y, this.zRange.min);

        dataMatrix[xIndex][yIndex] = obj;

        dataPoints.push(obj);
      }

      // fill in the pointers to the neighbors.
      for (x = 0; x < dataMatrix.length; x++) {
        for (y = 0; y < dataMatrix[x].length; y++) {
          if (dataMatrix[x][y]) {
            dataMatrix[x][y].pointRight = x < dataMatrix.length - 1 ? dataMatrix[x + 1][y] : undefined;
            dataMatrix[x][y].pointTop = y < dataMatrix[x].length - 1 ? dataMatrix[x][y + 1] : undefined;
            dataMatrix[x][y].pointCross = x < dataMatrix.length - 1 && y < dataMatrix[x].length - 1 ? dataMatrix[x + 1][y + 1] : undefined;
          }
        }
      }
    } else {
      // 'dot', 'dot-line', etc.
      this._checkValueField(data);

      // copy all values from the google data table to a list with Point3d objects
      for (i = 0; i < data.length; i++) {
        point = new Point3d();
        point.x = data[i][this.colX] || 0;
        point.y = data[i][this.colY] || 0;
        point.z = data[i][this.colZ] || 0;
        point.data = data[i];

        if (this.colValue !== undefined) {
          point.value = data[i][this.colValue] || 0;
        }

        obj = {};
        obj.point = point;
        obj.bottom = new Point3d(point.x, point.y, this.zRange.min);
        obj.trans = undefined;
        obj.screen = undefined;

        if (this.style === Graph3d.STYLE.LINE) {
          if (i > 0) {
            // Add next point for line drawing
            dataPoints[i - 1].pointNext = obj;
          }
        }

        dataPoints.push(obj);
      }
    }

    return dataPoints;
  };

  /**
   * Create the main frame for the Graph3d.
   *
   * This function is executed once when a Graph3d object is created. The frame
   * contains a canvas, and this canvas contains all objects like the axis and
   * nodes.
   */
  Graph3d.prototype.create = function () {
    // remove all elements from the container element.
    while (this.containerElement.hasChildNodes()) {
      this.containerElement.removeChild(this.containerElement.firstChild);
    }

    this.frame = document.createElement('div');
    this.frame.style.position = 'relative';
    this.frame.style.overflow = 'hidden';

    // create the graph canvas (HTML canvas element)
    this.frame.canvas = document.createElement('canvas');
    this.frame.canvas.style.position = 'relative';
    this.frame.appendChild(this.frame.canvas);
    //if (!this.frame.canvas.getContext) {
    {
      var noCanvas = document.createElement('DIV');
      noCanvas.style.color = 'red';
      noCanvas.style.fontWeight = 'bold';
      noCanvas.style.padding = '10px';
      noCanvas.innerHTML = 'Error: your browser does not support HTML canvas';
      this.frame.canvas.appendChild(noCanvas);
    }

    this.frame.filter = document.createElement('div');
    this.frame.filter.style.position = 'absolute';
    this.frame.filter.style.bottom = '0px';
    this.frame.filter.style.left = '0px';
    this.frame.filter.style.width = '100%';
    this.frame.appendChild(this.frame.filter);

    // add event listeners to handle moving and zooming the contents
    var me = this;
    var onmousedown = function onmousedown(event) {
      me._onMouseDown(event);
    };
    var ontouchstart = function ontouchstart(event) {
      me._onTouchStart(event);
    };
    var onmousewheel = function onmousewheel(event) {
      me._onWheel(event);
    };
    var ontooltip = function ontooltip(event) {
      me._onTooltip(event);
    };
    // TODO: these events are never cleaned up... can give a 'memory leakage'

    util.addEventListener(this.frame.canvas, 'keydown', onkeydown);
    util.addEventListener(this.frame.canvas, 'mousedown', onmousedown);
    util.addEventListener(this.frame.canvas, 'touchstart', ontouchstart);
    util.addEventListener(this.frame.canvas, 'mousewheel', onmousewheel);
    util.addEventListener(this.frame.canvas, 'mousemove', ontooltip);

    // add the new graph to the container element
    this.containerElement.appendChild(this.frame);
  };

  /**
   * Set a new size for the graph
   *
   * @param {string} width  Width in pixels or percentage (for example '800px'
   *                        or '50%')
   * @param {string} height Height in pixels or percentage  (for example '400px'
   *                        or '30%')
   */
  Graph3d.prototype.setSize = function (width, height) {
    this.frame.style.width = width;
    this.frame.style.height = height;

    this._resizeCanvas();
  };

  /**
   * Resize the canvas to the current size of the frame
   */
  Graph3d.prototype._resizeCanvas = function () {
    this.frame.canvas.style.width = '100%';
    this.frame.canvas.style.height = '100%';

    this.frame.canvas.width = this.frame.canvas.clientWidth;
    this.frame.canvas.height = this.frame.canvas.clientHeight;

    // adjust with for margin
    this.frame.filter.style.width = this.frame.canvas.clientWidth - 2 * 10 + 'px';
  };

  /**
   * Start animation
   */
  Graph3d.prototype.animationStart = function () {
    if (!this.frame.filter || !this.frame.filter.slider) throw new Error('No animation available');

    this.frame.filter.slider.play();
  };

  /**
   * Stop animation
   */
  Graph3d.prototype.animationStop = function () {
    if (!this.frame.filter || !this.frame.filter.slider) return;

    this.frame.filter.slider.stop();
  };

  /**
   * Resize the center position based on the current values in this.xCenter
   * and this.yCenter (which are strings with a percentage or a value
   * in pixels). The center positions are the variables this.currentXCenter
   * and this.currentYCenter
   */
  Graph3d.prototype._resizeCenter = function () {
    // calculate the horizontal center position
    if (this.xCenter.charAt(this.xCenter.length - 1) === '%') {
      this.currentXCenter = parseFloat(this.xCenter) / 100 * this.frame.canvas.clientWidth;
    } else {
      this.currentXCenter = parseFloat(this.xCenter); // supposed to be in px
    }

    // calculate the vertical center position
    if (this.yCenter.charAt(this.yCenter.length - 1) === '%') {
      this.currentYCenter = parseFloat(this.yCenter) / 100 * (this.frame.canvas.clientHeight - this.frame.filter.clientHeight);
    } else {
      this.currentYCenter = parseFloat(this.yCenter); // supposed to be in px
    }
  };

  /**
   * Retrieve the current camera rotation
   *
   * @returns {object} An object with parameters horizontal, vertical, and
   *                   distance
   */
  Graph3d.prototype.getCameraPosition = function () {
    var pos = this.camera.getArmRotation();
    pos.distance = this.camera.getArmLength();
    return pos;
  };

  /**
   * Load data into the 3D Graph
   */
  Graph3d.prototype._readData = function (data) {
    // read the data
    this._dataInitialize(data, this.style);

    if (this.dataFilter) {
      // apply filtering
      this.dataPoints = this.dataFilter._getDataPoints();
    } else {
      // no filtering. load all data
      this.dataPoints = this._getDataPoints(this.dataTable);
    }

    // draw the filter
    this._redrawFilter();
  };

  /**
   * Replace the dataset of the Graph3d
   *
   * @param {Array | DataSet | DataView} data
   */
  Graph3d.prototype.setData = function (data) {
    this._readData(data);
    this.redraw();

    // start animation when option is true
    if (this.animationAutoStart && this.dataFilter) {
      this.animationStart();
    }
  };

  /**
   * Update the options. Options will be merged with current options
   *
   * @param {Object} options
   */
  Graph3d.prototype.setOptions = function (options) {
    var cameraPosition = undefined;

    this.animationStop();

    Settings.setOptions(options, this);

    this.setPointDrawingMethod();
    this.setSize(this.width, this.height);

    // re-load the data
    if (this.dataTable) {
      this.setData(this.dataTable);
    }

    // start animation when option is true
    if (this.animationAutoStart && this.dataFilter) {
      this.animationStart();
    }
  };

  /**
   * Determine which point drawing method to use for the current graph style.
   */
  Graph3d.prototype.setPointDrawingMethod = function () {
    var method = undefined;

    switch (this.style) {
      case Graph3d.STYLE.BAR:
        method = Graph3d.prototype._redrawBarGraphPoint;
        break;
      case Graph3d.STYLE.BARCOLOR:
        method = Graph3d.prototype._redrawBarColorGraphPoint;
        break;
      case Graph3d.STYLE.BARSIZE:
        method = Graph3d.prototype._redrawBarSizeGraphPoint;
        break;
      case Graph3d.STYLE.DOT:
        method = Graph3d.prototype._redrawDotGraphPoint;
        break;
      case Graph3d.STYLE.DOTLINE:
        method = Graph3d.prototype._redrawDotLineGraphPoint;
        break;
      case Graph3d.STYLE.DOTCOLOR:
        method = Graph3d.prototype._redrawDotColorGraphPoint;
        break;
      case Graph3d.STYLE.DOTSIZE:
        method = Graph3d.prototype._redrawDotSizeGraphPoint;
        break;
      case Graph3d.STYLE.SURFACE:
        method = Graph3d.prototype._redrawSurfaceGraphPoint;
        break;
      case Graph3d.STYLE.GRID:
        method = Graph3d.prototype._redrawGridGraphPoint;
        break;
      case Graph3d.STYLE.LINE:
        method = Graph3d.prototype._redrawLineGraphPoint;
        break;
      default:
        throw new Error('Can not determine point drawing method ' + 'for graph style \'' + this.style + '\'');
        break;
    }

    this._pointDrawingMethod = method;
  };

  /**
   * Redraw the Graph.
   */
  Graph3d.prototype.redraw = function () {
    if (this.dataPoints === undefined) {
      throw new Error('Graph data not initialized');
    }

    this._resizeCanvas();
    this._resizeCenter();
    this._redrawSlider();
    this._redrawClear();
    this._redrawAxis();

    this._redrawDataGraph();

    this._redrawInfo();
    this._redrawLegend();
  };

  /**
   * Get drawing context without exposing canvas
   */
  Graph3d.prototype._getContext = function () {
    var canvas = this.frame.canvas;
    var ctx = canvas.getContext('2d');

    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';

    return ctx;
  };

  /**
   * Clear the canvas before redrawing
   */
  Graph3d.prototype._redrawClear = function () {
    var canvas = this.frame.canvas;
    var ctx = canvas.getContext('2d');

    ctx.clearRect(0, 0, canvas.width, canvas.height);
  };

  Graph3d.prototype._dotSize = function () {
    return this.frame.clientWidth * this.dotSizeRatio;
  };

  /**
   * Get legend width 
   */
  Graph3d.prototype._getLegendWidth = function () {
    var width;

    if (this.style === Graph3d.STYLE.DOTSIZE) {
      var dotSize = this._dotSize();
      width = dotSize / 2 + dotSize * 2;
    } else if (this.style === Graph3d.STYLE.BARSIZE) {
      width = this.xBarWidth;
    } else {
      width = 20;
    }
    return width;
  };

  /**
   * Redraw the legend based on size, dot color, or surface height 
   */
  Graph3d.prototype._redrawLegend = function () {

    //Return without drawing anything, if no legend is specified 
    if (this.showLegend !== true) {
      return;
    }

    // Do not draw legend when graph style does not support
    if (this.style === Graph3d.STYLE.LINE || this.style === Graph3d.STYLE.BARSIZE //TODO add legend support for BARSIZE 
    ) {
        return;
      }

    // Legend types - size and color. Determine if size legend.  
    var isSizeLegend = this.style === Graph3d.STYLE.BARSIZE || this.style === Graph3d.STYLE.DOTSIZE;

    // Legend is either tracking z values or style values. This flag if false means use z values. 
    var isValueLegend = this.style === Graph3d.STYLE.DOTSIZE || this.style === Graph3d.STYLE.DOTCOLOR || this.style === Graph3d.STYLE.BARCOLOR;

    var height = Math.max(this.frame.clientHeight * 0.25, 100);
    var top = this.margin;
    var width = this._getLegendWidth(); // px - overwritten by size legend  
    var right = this.frame.clientWidth - this.margin;
    var left = right - width;
    var bottom = top + height;

    var ctx = this._getContext();
    ctx.lineWidth = 1;
    ctx.font = '14px arial'; // TODO: put in options

    if (isSizeLegend === false) {
      // draw the color bar
      var ymin = 0;
      var ymax = height; // Todo: make height customizable
      var y;

      for (y = ymin; y < ymax; y++) {
        var f = (y - ymin) / (ymax - ymin);
        var hue = f * 240;
        var color = this._hsv2rgb(hue, 1, 1);

        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(left, top + y);
        ctx.lineTo(right, top + y);
        ctx.stroke();
      }
      ctx.strokeStyle = this.axisColor;
      ctx.strokeRect(left, top, width, height);
    } else {

      // draw the size legend box 
      var widthMin;
      if (this.style === Graph3d.STYLE.DOTSIZE) {
        var dotSize = this._dotSize();
        widthMin = dotSize / 2; // px
      } else if (this.style === Graph3d.STYLE.BARSIZE) {
        //widthMin = this.xBarWidth * 0.2 this is wrong - barwidth measures in terms of xvalues 
      }
      ctx.strokeStyle = this.axisColor;
      ctx.fillStyle = this.dataColor.fill;
      ctx.beginPath();
      ctx.moveTo(left, top);
      ctx.lineTo(right, top);
      ctx.lineTo(right - width + widthMin, bottom);
      ctx.lineTo(left, bottom);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }

    // print value text along the legend edge 
    var gridLineLen = 5; // px

    var legendMin = isValueLegend ? this.valueRange.min : this.zRange.min;
    var legendMax = isValueLegend ? this.valueRange.max : this.zRange.max;
    var step = new StepNumber(legendMin, legendMax, (legendMax - legendMin) / 5, true);
    step.start(true);

    var y;
    var from;
    var to;
    while (!step.end()) {
      y = bottom - (step.getCurrent() - legendMin) / (legendMax - legendMin) * height;
      from = new Point2d(left - gridLineLen, y);
      to = new Point2d(left, y);
      this._line(ctx, from, to);

      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = this.axisColor;
      ctx.fillText(step.getCurrent(), left - 2 * gridLineLen, y);

      step.next();
    }

    ctx.textAlign = 'right';
    ctx.textBaseline = 'top';
    var label = this.legendLabel;
    ctx.fillText(label, right, bottom + this.margin);
  };

  /**
   * Redraw the filter
   */
  Graph3d.prototype._redrawFilter = function () {
    this.frame.filter.innerHTML = '';

    if (this.dataFilter) {
      var options = {
        'visible': this.showAnimationControls
      };
      var slider = new Slider(this.frame.filter, options);
      this.frame.filter.slider = slider;

      // TODO: css here is not nice here...
      this.frame.filter.style.padding = '10px';
      //this.frame.filter.style.backgroundColor = '#EFEFEF';

      slider.setValues(this.dataFilter.values);
      slider.setPlayInterval(this.animationInterval);

      // create an event handler
      var me = this;
      var onchange = function onchange() {
        var index = slider.getIndex();

        me.dataFilter.selectValue(index);
        me.dataPoints = me.dataFilter._getDataPoints();

        me.redraw();
      };
      slider.setOnChangeCallback(onchange);
    } else {
      this.frame.filter.slider = undefined;
    }
  };

  /**
   * Redraw the slider
   */
  Graph3d.prototype._redrawSlider = function () {
    if (this.frame.filter.slider !== undefined) {
      this.frame.filter.slider.redraw();
    }
  };

  /**
   * Redraw common information
   */
  Graph3d.prototype._redrawInfo = function () {
    if (this.dataFilter) {
      var ctx = this._getContext();

      ctx.font = '14px arial'; // TODO: put in options
      ctx.lineStyle = 'gray';
      ctx.fillStyle = 'gray';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';

      var x = this.margin;
      var y = this.margin;
      ctx.fillText(this.dataFilter.getLabel() + ': ' + this.dataFilter.getSelectedValue(), x, y);
    }
  };

  /**
   * Draw a line between 2d points 'from' and 'to'.
   *
   * If stroke style specified, set that as well.
   */
  Graph3d.prototype._line = function (ctx, from, to, strokeStyle) {
    if (strokeStyle !== undefined) {
      ctx.strokeStyle = strokeStyle;
    }

    ctx.beginPath();
    ctx.moveTo(from.x, from.y);
    ctx.lineTo(to.x, to.y);
    ctx.stroke();
  };

  Graph3d.prototype.drawAxisLabelX = function (ctx, point3d, text, armAngle, yMargin) {
    if (yMargin === undefined) {
      yMargin = 0;
    }

    var point2d = this._convert3Dto2D(point3d);

    if (Math.cos(armAngle * 2) > 0) {
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      point2d.y += yMargin;
    } else if (Math.sin(armAngle * 2) < 0) {
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
    } else {
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
    }

    ctx.fillStyle = this.axisColor;
    ctx.fillText(text, point2d.x, point2d.y);
  };

  Graph3d.prototype.drawAxisLabelY = function (ctx, point3d, text, armAngle, yMargin) {
    if (yMargin === undefined) {
      yMargin = 0;
    }

    var point2d = this._convert3Dto2D(point3d);

    if (Math.cos(armAngle * 2) < 0) {
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      point2d.y += yMargin;
    } else if (Math.sin(armAngle * 2) > 0) {
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
    } else {
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
    }

    ctx.fillStyle = this.axisColor;
    ctx.fillText(text, point2d.x, point2d.y);
  };

  Graph3d.prototype.drawAxisLabelZ = function (ctx, point3d, text, offset) {
    if (offset === undefined) {
      offset = 0;
    }

    var point2d = this._convert3Dto2D(point3d);
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = this.axisColor;
    ctx.fillText(text, point2d.x - offset, point2d.y);
  };

  /**


  /**
   * Draw a line between 2d points 'from' and 'to'.
   *
   * If stroke style specified, set that as well.
   */
  Graph3d.prototype._line3d = function (ctx, from, to, strokeStyle) {
    var from2d = this._convert3Dto2D(from);
    var to2d = this._convert3Dto2D(to);

    this._line(ctx, from2d, to2d, strokeStyle);
  };

  /**
   * Redraw the axis
   */
  Graph3d.prototype._redrawAxis = function () {
    var ctx = this._getContext(),
        from,
        to,
        step,
        prettyStep,
        text,
        xText,
        yText,
        zText,
        offset,
        xOffset,
        yOffset;

    // TODO: get the actual rendered style of the containerElement
    //ctx.font = this.containerElement.style.font;
    ctx.font = 24 / this.camera.getArmLength() + 'px arial';

    // calculate the length for the short grid lines
    var gridLenX = 0.025 / this.scale.x;
    var gridLenY = 0.025 / this.scale.y;
    var textMargin = 5 / this.camera.getArmLength(); // px
    var armAngle = this.camera.getArmRotation().horizontal;
    var armVector = new Point2d(Math.cos(armAngle), Math.sin(armAngle));

    var xRange = this.xRange;
    var yRange = this.yRange;
    var zRange = this.zRange;

    // draw x-grid lines
    ctx.lineWidth = 1;
    prettyStep = this.defaultXStep === undefined;
    step = new StepNumber(xRange.min, xRange.max, this.xStep, prettyStep);
    step.start(true);

    while (!step.end()) {
      var x = step.getCurrent();

      if (this.showGrid) {
        from = new Point3d(x, yRange.min, zRange.min);
        to = new Point3d(x, yRange.max, zRange.min);
        this._line3d(ctx, from, to, this.gridColor);
      } else {
        from = new Point3d(x, yRange.min, zRange.min);
        to = new Point3d(x, yRange.min + gridLenX, zRange.min);
        this._line3d(ctx, from, to, this.axisColor);

        from = new Point3d(x, yRange.max, zRange.min);
        to = new Point3d(x, yRange.max - gridLenX, zRange.min);
        this._line3d(ctx, from, to, this.axisColor);
      }

      yText = armVector.x > 0 ? yRange.min : yRange.max;
      var point3d = new Point3d(x, yText, zRange.min);
      var msg = '  ' + this.xValueLabel(x) + '  ';
      this.drawAxisLabelX(ctx, point3d, msg, armAngle, textMargin);

      step.next();
    }

    // draw y-grid lines
    ctx.lineWidth = 1;
    prettyStep = this.defaultYStep === undefined;
    step = new StepNumber(yRange.min, yRange.max, this.yStep, prettyStep);
    step.start(true);

    while (!step.end()) {
      var y = step.getCurrent();

      if (this.showGrid) {
        from = new Point3d(xRange.min, y, zRange.min);
        to = new Point3d(xRange.max, y, zRange.min);
        this._line3d(ctx, from, to, this.gridColor);
      } else {
        from = new Point3d(xRange.min, y, zRange.min);
        to = new Point3d(xRange.min + gridLenY, y, zRange.min);
        this._line3d(ctx, from, to, this.axisColor);

        from = new Point3d(xRange.max, y, zRange.min);
        to = new Point3d(xRange.max - gridLenY, y, zRange.min);
        this._line3d(ctx, from, to, this.axisColor);
      }

      xText = armVector.y > 0 ? xRange.min : xRange.max;
      point3d = new Point3d(xText, y, zRange.min);
      var msg = '  ' + this.yValueLabel(y) + '  ';
      this.drawAxisLabelY(ctx, point3d, msg, armAngle, textMargin);

      step.next();
    }

    // draw z-grid lines and axis
    ctx.lineWidth = 1;
    prettyStep = this.defaultZStep === undefined;
    step = new StepNumber(zRange.min, zRange.max, this.zStep, prettyStep);
    step.start(true);

    xText = armVector.x > 0 ? xRange.min : xRange.max;
    yText = armVector.y < 0 ? yRange.min : yRange.max;

    while (!step.end()) {
      var z = step.getCurrent();

      // TODO: make z-grid lines really 3d?
      var from3d = new Point3d(xText, yText, z);
      var from2d = this._convert3Dto2D(from3d);
      to = new Point2d(from2d.x - textMargin, from2d.y);
      this._line(ctx, from2d, to, this.axisColor);

      var msg = this.zValueLabel(z) + ' ';
      this.drawAxisLabelZ(ctx, from3d, msg, 5);

      step.next();
    }

    ctx.lineWidth = 1;
    from = new Point3d(xText, yText, zRange.min);
    to = new Point3d(xText, yText, zRange.max);
    this._line3d(ctx, from, to, this.axisColor);

    // draw x-axis
    var xMin2d;
    var xMax2d;
    ctx.lineWidth = 1;

    // line at yMin
    xMin2d = new Point3d(xRange.min, yRange.min, zRange.min);
    xMax2d = new Point3d(xRange.max, yRange.min, zRange.min);
    this._line3d(ctx, xMin2d, xMax2d, this.axisColor);
    // line at ymax
    xMin2d = new Point3d(xRange.min, yRange.max, zRange.min);
    xMax2d = new Point3d(xRange.max, yRange.max, zRange.min);
    this._line3d(ctx, xMin2d, xMax2d, this.axisColor);

    // draw y-axis
    ctx.lineWidth = 1;
    // line at xMin
    from = new Point3d(xRange.min, yRange.min, zRange.min);
    to = new Point3d(xRange.min, yRange.max, zRange.min);
    this._line3d(ctx, from, to, this.axisColor);
    // line at xMax
    from = new Point3d(xRange.max, yRange.min, zRange.min);
    to = new Point3d(xRange.max, yRange.max, zRange.min);
    this._line3d(ctx, from, to, this.axisColor);

    // draw x-label
    var xLabel = this.xLabel;
    if (xLabel.length > 0) {
      yOffset = 0.1 / this.scale.y;
      xText = xRange.center() / 2;
      yText = armVector.x > 0 ? yRange.min - yOffset : yRange.max + yOffset;
      text = new Point3d(xText, yText, zRange.min);
      this.drawAxisLabelX(ctx, text, xLabel, armAngle);
    }

    // draw y-label
    var yLabel = this.yLabel;
    if (yLabel.length > 0) {
      xOffset = 0.1 / this.scale.x;
      xText = armVector.y > 0 ? xRange.min - xOffset : xRange.max + xOffset;
      yText = yRange.center() / 2;
      text = new Point3d(xText, yText, zRange.min);

      this.drawAxisLabelY(ctx, text, yLabel, armAngle);
    }

    // draw z-label
    var zLabel = this.zLabel;
    if (zLabel.length > 0) {
      offset = 30; // pixels.  // TODO: relate to the max width of the values on the z axis?
      xText = armVector.x > 0 ? xRange.min : xRange.max;
      yText = armVector.y < 0 ? yRange.min : yRange.max;
      zText = zRange.center() / 2;
      text = new Point3d(xText, yText, zText);

      this.drawAxisLabelZ(ctx, text, zLabel, offset);
    }
  };

  /**
   * Calculate the color based on the given value.
   * @param {Number} H   Hue, a value be between 0 and 360
   * @param {Number} S   Saturation, a value between 0 and 1
   * @param {Number} V   Value, a value between 0 and 1
   */
  Graph3d.prototype._hsv2rgb = function (H, S, V) {
    var R, G, B, C, Hi, X;

    C = V * S;
    Hi = Math.floor(H / 60); // hi = 0,1,2,3,4,5
    X = C * (1 - Math.abs(H / 60 % 2 - 1));

    switch (Hi) {
      case 0:
        R = C;G = X;B = 0;break;
      case 1:
        R = X;G = C;B = 0;break;
      case 2:
        R = 0;G = C;B = X;break;
      case 3:
        R = 0;G = X;B = C;break;
      case 4:
        R = X;G = 0;B = C;break;
      case 5:
        R = C;G = 0;B = X;break;

      default:
        R = 0;G = 0;B = 0;break;
    }

    return 'RGB(' + parseInt(R * 255) + ',' + parseInt(G * 255) + ',' + parseInt(B * 255) + ')';
  };

  Graph3d.prototype._getStrokeWidth = function (point) {
    if (point !== undefined) {
      if (this.showPerspective) {
        return 1 / -point.trans.z * this.dataColor.strokeWidth;
      } else {
        return -(this.eye.z / this.camera.getArmLength()) * this.dataColor.strokeWidth;
      }
    }

    return this.dataColor.strokeWidth;
  };

  // -----------------------------------------------------------------------------
  // Drawing primitives for the graphs
  // -----------------------------------------------------------------------------


  /**
   * Draw a bar element in the view with the given properties.
   */
  Graph3d.prototype._redrawBar = function (ctx, point, xWidth, yWidth, color, borderColor) {
    var i, j, surface;

    // calculate all corner points
    var me = this;
    var point3d = point.point;
    var zMin = this.zRange.min;
    var top = [{ point: new Point3d(point3d.x - xWidth, point3d.y - yWidth, point3d.z) }, { point: new Point3d(point3d.x + xWidth, point3d.y - yWidth, point3d.z) }, { point: new Point3d(point3d.x + xWidth, point3d.y + yWidth, point3d.z) }, { point: new Point3d(point3d.x - xWidth, point3d.y + yWidth, point3d.z) }];
    var bottom = [{ point: new Point3d(point3d.x - xWidth, point3d.y - yWidth, zMin) }, { point: new Point3d(point3d.x + xWidth, point3d.y - yWidth, zMin) }, { point: new Point3d(point3d.x + xWidth, point3d.y + yWidth, zMin) }, { point: new Point3d(point3d.x - xWidth, point3d.y + yWidth, zMin) }];

    // calculate screen location of the points
    top.forEach(function (obj) {
      obj.screen = me._convert3Dto2D(obj.point);
    });
    bottom.forEach(function (obj) {
      obj.screen = me._convert3Dto2D(obj.point);
    });

    // create five sides, calculate both corner points and center points
    var surfaces = [{ corners: top, center: Point3d.avg(bottom[0].point, bottom[2].point) }, { corners: [top[0], top[1], bottom[1], bottom[0]], center: Point3d.avg(bottom[1].point, bottom[0].point) }, { corners: [top[1], top[2], bottom[2], bottom[1]], center: Point3d.avg(bottom[2].point, bottom[1].point) }, { corners: [top[2], top[3], bottom[3], bottom[2]], center: Point3d.avg(bottom[3].point, bottom[2].point) }, { corners: [top[3], top[0], bottom[0], bottom[3]], center: Point3d.avg(bottom[0].point, bottom[3].point) }];
    point.surfaces = surfaces;

    // calculate the distance of each of the surface centers to the camera
    for (j = 0; j < surfaces.length; j++) {
      surface = surfaces[j];
      var transCenter = this._convertPointToTranslation(surface.center);
      surface.dist = this.showPerspective ? transCenter.length() : -transCenter.z;
      // TODO: this dept calculation doesn't work 100% of the cases due to perspective,
      //     but the current solution is fast/simple and works in 99.9% of all cases
      //     the issue is visible in example 14, with graph.setCameraPosition({horizontal: 2.97, vertical: 0.5, distance: 0.9})
    }

    // order the surfaces by their (translated) depth
    surfaces.sort(function (a, b) {
      var diff = b.dist - a.dist;
      if (diff) return diff;

      // if equal depth, sort the top surface last
      if (a.corners === top) return 1;
      if (b.corners === top) return -1;

      // both are equal
      return 0;
    });

    // draw the ordered surfaces
    ctx.lineWidth = this._getStrokeWidth(point);
    ctx.strokeStyle = borderColor;
    ctx.fillStyle = color;
    // NOTE: we start at j=2 instead of j=0 as we don't need to draw the two surfaces at the backside
    for (j = 2; j < surfaces.length; j++) {
      surface = surfaces[j];
      this._polygon(ctx, surface.corners);
    }
  };

  /**
   * Draw a polygon using the passed points and fill it with the passed style and stroke.
   *
   * @param points      an array of points. 
   * @param fillStyle   optional; the fill style to set
   * @param strokeStyle optional; the stroke style to set
   */
  Graph3d.prototype._polygon = function (ctx, points, fillStyle, strokeStyle) {
    if (points.length < 2) {
      return;
    }

    if (fillStyle !== undefined) {
      ctx.fillStyle = fillStyle;
    }
    if (strokeStyle !== undefined) {
      ctx.strokeStyle = strokeStyle;
    }
    ctx.beginPath();
    ctx.moveTo(points[0].screen.x, points[0].screen.y);

    for (var i = 1; i < points.length; ++i) {
      var point = points[i];
      ctx.lineTo(point.screen.x, point.screen.y);
    }

    ctx.closePath();
    ctx.fill();
    ctx.stroke(); // TODO: only draw stroke when strokeWidth > 0
  };

  /**
   * @param size optional; if not specified use value from 'this._dotSize()`
   */
  Graph3d.prototype._drawCircle = function (ctx, point, color, borderColor, size) {
    var radius = this._calcRadius(point, size);

    ctx.lineWidth = this._getStrokeWidth(point);
    ctx.strokeStyle = borderColor;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(point.screen.x, point.screen.y, radius, 0, Math.PI * 2, true);
    ctx.fill();
    ctx.stroke();
  };

  /**
   * Determine the colors for the 'regular' graph styles.
   */
  Graph3d.prototype._getColorsRegular = function (point) {
    // calculate Hue from the current value. At zMin the hue is 240, at zMax the hue is 0
    var hue = (1 - (point.point.z - this.zRange.min) * this.scale.z / this.verticalRatio) * 240;
    var color = this._hsv2rgb(hue, 1, 1);
    var borderColor = this._hsv2rgb(hue, 1, 0.8);

    return {
      fill: color,
      border: borderColor
    };
  };

  /**
   * Get the colors for the 'color' graph styles.
   * These styles are currently: 'bar-color' and 'dot-color'
   */
  Graph3d.prototype._getColorsColor = function (point) {
    // calculate the color based on the value
    var hue = (1 - (point.point.value - this.valueRange.min) * this.scale.value) * 240;
    var color = this._hsv2rgb(hue, 1, 1);
    var borderColor = this._hsv2rgb(hue, 1, 0.8);

    return {
      fill: color,
      border: borderColor
    };
  };

  /**
   * Get the colors for the 'size' graph styles.
   * These styles are currently: 'bar-size' and 'dot-size'
   */
  Graph3d.prototype._getColorsSize = function () {
    return {
      fill: this.dataColor.fill,
      border: this.dataColor.stroke
    };
  };

  /**
   * Determine the size of a point on-screen, as determined by the
   * distance to the camera.
   *
   * @param size the size that needs to be translated to screen coordinates.
   *             optional; if not passed, use the default point size.
   */
  Graph3d.prototype._calcRadius = function (point, size) {
    if (size === undefined) {
      size = this._dotSize();
    }

    var radius;
    if (this.showPerspective) {
      radius = size / -point.trans.z;
    } else {
      radius = size * -(this.eye.z / this.camera.getArmLength());
    }
    if (radius < 0) {
      radius = 0;
    }

    return radius;
  };

  // -----------------------------------------------------------------------------
  // Methods for drawing points per graph style.
  // -----------------------------------------------------------------------------


  /**
   * Draw single datapoint for graph style 'bar'.
   */
  Graph3d.prototype._redrawBarGraphPoint = function (ctx, point) {
    var xWidth = this.xBarWidth / 2;
    var yWidth = this.yBarWidth / 2;
    var colors = this._getColorsRegular(point);

    this._redrawBar(ctx, point, xWidth, yWidth, colors.fill, colors.border);
  };

  /**
   * Draw single datapoint for graph style 'bar-color'.
   */
  Graph3d.prototype._redrawBarColorGraphPoint = function (ctx, point) {
    var xWidth = this.xBarWidth / 2;
    var yWidth = this.yBarWidth / 2;
    var colors = this._getColorsColor(point);

    this._redrawBar(ctx, point, xWidth, yWidth, colors.fill, colors.border);
  };

  /**
   * Draw single datapoint for graph style 'bar-size'.
   */
  Graph3d.prototype._redrawBarSizeGraphPoint = function (ctx, point) {
    // calculate size for the bar
    var fraction = (point.point.value - this.valueRange.min) / this.valueRange.range();
    var xWidth = this.xBarWidth / 2 * (fraction * 0.8 + 0.2);
    var yWidth = this.yBarWidth / 2 * (fraction * 0.8 + 0.2);

    var colors = this._getColorsSize();

    this._redrawBar(ctx, point, xWidth, yWidth, colors.fill, colors.border);
  };

  /**
   * Draw single datapoint for graph style 'dot'.
   */
  Graph3d.prototype._redrawDotGraphPoint = function (ctx, point) {
    var colors = this._getColorsRegular(point);

    this._drawCircle(ctx, point, colors.fill, colors.border);
  };

  /**
   * Draw single datapoint for graph style 'dot-line'.
   */
  Graph3d.prototype._redrawDotLineGraphPoint = function (ctx, point) {
    // draw a vertical line from the XY-plane to the graph value
    var from = this._convert3Dto2D(point.bottom);
    ctx.lineWidth = 1;
    this._line(ctx, from, point.screen, this.gridColor);

    this._redrawDotGraphPoint(ctx, point);
  };

  /**
   * Draw single datapoint for graph style 'dot-color'.
   */
  Graph3d.prototype._redrawDotColorGraphPoint = function (ctx, point) {
    var colors = this._getColorsColor(point);

    this._drawCircle(ctx, point, colors.fill, colors.border);
  };

  /**
   * Draw single datapoint for graph style 'dot-size'.
   */
  Graph3d.prototype._redrawDotSizeGraphPoint = function (ctx, point) {
    var dotSize = this._dotSize();
    var fraction = (point.point.value - this.valueRange.min) / this.valueRange.range();
    var size = dotSize / 2 + 2 * dotSize * fraction;
    var colors = this._getColorsSize();

    this._drawCircle(ctx, point, colors.fill, colors.border, size);
  };

  /**
   * Draw single datapoint for graph style 'surface'.
   */
  Graph3d.prototype._redrawSurfaceGraphPoint = function (ctx, point) {
    var right = point.pointRight;
    var top = point.pointTop;
    var cross = point.pointCross;

    if (point === undefined || right === undefined || top === undefined || cross === undefined) {
      return;
    }

    var topSideVisible = true;
    var fillStyle;
    var strokeStyle;
    var lineWidth;

    if (this.showGrayBottom || this.showShadow) {
      // calculate the cross product of the two vectors from center
      // to left and right, in order to know whether we are looking at the
      // bottom or at the top side. We can also use the cross product
      // for calculating light intensity
      var aDiff = Point3d.subtract(cross.trans, point.trans);
      var bDiff = Point3d.subtract(top.trans, right.trans);
      var crossproduct = Point3d.crossProduct(aDiff, bDiff);
      var len = crossproduct.length();
      // FIXME: there is a bug with determining the surface side (shadow or colored)

      topSideVisible = crossproduct.z > 0;
    }

    if (topSideVisible) {

      // calculate Hue from the current value. At zMin the hue is 240, at zMax the hue is 0
      var zAvg = (point.point.z + right.point.z + top.point.z + cross.point.z) / 4;
      var h = (1 - (zAvg - this.zRange.min) * this.scale.z / this.verticalRatio) * 240;
      var s = 1; // saturation
      var v;

      if (this.showShadow) {
        v = Math.min(1 + crossproduct.x / len / 2, 1); // value. TODO: scale
        fillStyle = this._hsv2rgb(h, s, v);
        strokeStyle = fillStyle;
      } else {
        v = 1;
        fillStyle = this._hsv2rgb(h, s, v);
        strokeStyle = this.axisColor; // TODO: should be customizable
      }
    } else {
      fillStyle = 'gray';
      strokeStyle = this.axisColor;
    }

    ctx.lineWidth = this._getStrokeWidth(point);
    // TODO: only draw stroke when strokeWidth > 0

    var points = [point, right, cross, top];
    this._polygon(ctx, points, fillStyle, strokeStyle);
  };

  /**
   * Helper method for _redrawGridGraphPoint()
   */
  Graph3d.prototype._drawGridLine = function (ctx, from, to) {
    if (from === undefined || to === undefined) {
      return;
    }

    // calculate Hue from the current value. At zMin the hue is 240, at zMax the hue is 0
    var zAvg = (from.point.z + to.point.z) / 2;
    var h = (1 - (zAvg - this.zRange.min) * this.scale.z / this.verticalRatio) * 240;

    ctx.lineWidth = this._getStrokeWidth(from) * 2;
    ctx.strokeStyle = this._hsv2rgb(h, 1, 1);
    this._line(ctx, from.screen, to.screen);
  };

  /**
   * Draw single datapoint for graph style 'Grid'.
   */
  Graph3d.prototype._redrawGridGraphPoint = function (ctx, point) {
    this._drawGridLine(ctx, point, point.pointRight);
    this._drawGridLine(ctx, point, point.pointTop);
  };

  /**
   * Draw single datapoint for graph style 'line'.
   */
  Graph3d.prototype._redrawLineGraphPoint = function (ctx, point) {
    if (point.pointNext === undefined) {
      return;
    }

    ctx.lineWidth = this._getStrokeWidth(point);
    ctx.strokeStyle = this.dataColor.stroke;

    this._line(ctx, point.screen, point.pointNext.screen);
  };

  /**
   * Draw all datapoints for currently selected graph style.
   *
   */
  Graph3d.prototype._redrawDataGraph = function () {
    var ctx = this._getContext();
    var i;

    if (this.dataPoints === undefined || this.dataPoints.length <= 0) return; // TODO: throw exception?

    this._calcTranslations(this.dataPoints);

    for (i = 0; i < this.dataPoints.length; i++) {
      var point = this.dataPoints[i];

      // Using call() ensures that the correct context is used
      this._pointDrawingMethod.call(this, ctx, point);
    }
  };

  // -----------------------------------------------------------------------------
  // End methods for drawing points per graph style.
  // -----------------------------------------------------------------------------


  /**
   * Start a moving operation inside the provided parent element
   * @param {Event}     event     The event that occurred (required for
   *                  retrieving the  mouse position)
   */
  Graph3d.prototype._onMouseDown = function (event) {
    event = event || window.event;

    // check if mouse is still down (may be up when focus is lost for example
    // in an iframe)
    if (this.leftButtonDown) {
      this._onMouseUp(event);
    }

    // only react on left mouse button down
    this.leftButtonDown = event.which ? event.which === 1 : event.button === 1;
    if (!this.leftButtonDown && !this.touchDown) return;

    // get mouse position (different code for IE and all other browsers)
    this.startMouseX = getMouseX(event);
    this.startMouseY = getMouseY(event);

    this.startStart = new Date(this.start);
    this.startEnd = new Date(this.end);
    this.startArmRotation = this.camera.getArmRotation();

    this.frame.style.cursor = 'move';

    // add event listeners to handle moving the contents
    // we store the function onmousemove and onmouseup in the graph, so we can
    // remove the eventlisteners lateron in the function mouseUp()
    var me = this;
    this.onmousemove = function (event) {
      me._onMouseMove(event);
    };
    this.onmouseup = function (event) {
      me._onMouseUp(event);
    };
    util.addEventListener(document, 'mousemove', me.onmousemove);
    util.addEventListener(document, 'mouseup', me.onmouseup);
    util.preventDefault(event);
  };

  /**
   * Perform moving operating.
   * This function activated from within the funcion Graph.mouseDown().
   * @param {Event}   event  Well, eehh, the event
   */
  Graph3d.prototype._onMouseMove = function (event) {
    event = event || window.event;

    // calculate change in mouse position
    var diffX = parseFloat(getMouseX(event)) - this.startMouseX;
    var diffY = parseFloat(getMouseY(event)) - this.startMouseY;

    var horizontalNew = this.startArmRotation.horizontal + diffX / 200;
    var verticalNew = this.startArmRotation.vertical + diffY / 200;

    var snapAngle = 4; // degrees
    var snapValue = Math.sin(snapAngle / 360 * 2 * Math.PI);

    // snap horizontally to nice angles at 0pi, 0.5pi, 1pi, 1.5pi, etc...
    // the -0.001 is to take care that the vertical axis is always drawn at the left front corner
    if (Math.abs(Math.sin(horizontalNew)) < snapValue) {
      horizontalNew = Math.round(horizontalNew / Math.PI) * Math.PI - 0.001;
    }
    if (Math.abs(Math.cos(horizontalNew)) < snapValue) {
      horizontalNew = (Math.round(horizontalNew / Math.PI - 0.5) + 0.5) * Math.PI - 0.001;
    }

    // snap vertically to nice angles
    if (Math.abs(Math.sin(verticalNew)) < snapValue) {
      verticalNew = Math.round(verticalNew / Math.PI) * Math.PI;
    }
    if (Math.abs(Math.cos(verticalNew)) < snapValue) {
      verticalNew = (Math.round(verticalNew / Math.PI - 0.5) + 0.5) * Math.PI;
    }

    this.camera.setArmRotation(horizontalNew, verticalNew);
    this.redraw();

    // fire a cameraPositionChange event
    var parameters = this.getCameraPosition();
    this.emit('cameraPositionChange', parameters);

    util.preventDefault(event);
  };

  /**
   * Stop moving operating.
   * This function activated from within the funcion Graph.mouseDown().
   * @param {event}  event   The event
   */
  Graph3d.prototype._onMouseUp = function (event) {
    this.frame.style.cursor = 'auto';
    this.leftButtonDown = false;

    // remove event listeners here
    util.removeEventListener(document, 'mousemove', this.onmousemove);
    util.removeEventListener(document, 'mouseup', this.onmouseup);
    util.preventDefault(event);
  };

  /**
   * After having moved the mouse, a tooltip should pop up when the mouse is resting on a data point
   * @param {Event}  event   A mouse move event
   */
  Graph3d.prototype._onTooltip = function (event) {
    var delay = 300; // ms
    var boundingRect = this.frame.getBoundingClientRect();
    var mouseX = getMouseX(event) - boundingRect.left;
    var mouseY = getMouseY(event) - boundingRect.top;

    if (!this.showTooltip) {
      return;
    }

    if (this.tooltipTimeout) {
      clearTimeout(this.tooltipTimeout);
    }

    // (delayed) display of a tooltip only if no mouse button is down
    if (this.leftButtonDown) {
      this._hideTooltip();
      return;
    }

    if (this.tooltip && this.tooltip.dataPoint) {
      // tooltip is currently visible
      var dataPoint = this._dataPointFromXY(mouseX, mouseY);
      if (dataPoint !== this.tooltip.dataPoint) {
        // datapoint changed
        if (dataPoint) {
          this._showTooltip(dataPoint);
        } else {
          this._hideTooltip();
        }
      }
    } else {
      // tooltip is currently not visible
      var me = this;
      this.tooltipTimeout = setTimeout(function () {
        me.tooltipTimeout = null;

        // show a tooltip if we have a data point
        var dataPoint = me._dataPointFromXY(mouseX, mouseY);
        if (dataPoint) {
          me._showTooltip(dataPoint);
        }
      }, delay);
    }
  };

  /**
   * Event handler for touchstart event on mobile devices
   */
  Graph3d.prototype._onTouchStart = function (event) {
    this.touchDown = true;

    var me = this;
    this.ontouchmove = function (event) {
      me._onTouchMove(event);
    };
    this.ontouchend = function (event) {
      me._onTouchEnd(event);
    };
    util.addEventListener(document, 'touchmove', me.ontouchmove);
    util.addEventListener(document, 'touchend', me.ontouchend);

    this._onMouseDown(event);
  };

  /**
   * Event handler for touchmove event on mobile devices
   */
  Graph3d.prototype._onTouchMove = function (event) {
    this._onMouseMove(event);
  };

  /**
   * Event handler for touchend event on mobile devices
   */
  Graph3d.prototype._onTouchEnd = function (event) {
    this.touchDown = false;

    util.removeEventListener(document, 'touchmove', this.ontouchmove);
    util.removeEventListener(document, 'touchend', this.ontouchend);

    this._onMouseUp(event);
  };

  /**
   * Event handler for mouse wheel event, used to zoom the graph
   * Code from http://adomas.org/javascript-mouse-wheel/
   * @param {event}  event   The event
   */
  Graph3d.prototype._onWheel = function (event) {
    if (!event) /* For IE. */
      event = window.event;

    // retrieve delta
    var delta = 0;
    if (event.wheelDelta) {
      /* IE/Opera. */
      delta = event.wheelDelta / 120;
    } else if (event.detail) {
      /* Mozilla case. */
      // In Mozilla, sign of delta is different than in IE.
      // Also, delta is multiple of 3.
      delta = -event.detail / 3;
    }

    // If delta is nonzero, handle it.
    // Basically, delta is now positive if wheel was scrolled up,
    // and negative, if wheel was scrolled down.
    if (delta) {
      var oldLength = this.camera.getArmLength();
      var newLength = oldLength * (1 - delta / 10);

      this.camera.setArmLength(newLength);
      this.redraw();

      this._hideTooltip();
    }

    // fire a cameraPositionChange event
    var parameters = this.getCameraPosition();
    this.emit('cameraPositionChange', parameters);

    // Prevent default actions caused by mouse wheel.
    // That might be ugly, but we handle scrolls somehow
    // anyway, so don't bother here..
    util.preventDefault(event);
  };

  /**
   * Test whether a point lies inside given 2D triangle
   *
   * @param   {Point2d}   point
   * @param   {Point2d[]} triangle
   * @returns {boolean}   true if given point lies inside or on the edge of the
   *                      triangle, false otherwise
   * @private
   */
  Graph3d.prototype._insideTriangle = function (point, triangle) {
    var a = triangle[0],
        b = triangle[1],
        c = triangle[2];

    function sign(x) {
      return x > 0 ? 1 : x < 0 ? -1 : 0;
    }

    var as = sign((b.x - a.x) * (point.y - a.y) - (b.y - a.y) * (point.x - a.x));
    var bs = sign((c.x - b.x) * (point.y - b.y) - (c.y - b.y) * (point.x - b.x));
    var cs = sign((a.x - c.x) * (point.y - c.y) - (a.y - c.y) * (point.x - c.x));

    // each of the three signs must be either equal to each other or zero
    return (as == 0 || bs == 0 || as == bs) && (bs == 0 || cs == 0 || bs == cs) && (as == 0 || cs == 0 || as == cs);
  };

  /**
   * Find a data point close to given screen position (x, y)
   *
   * @param   {Number} x
   * @param   {Number} y
   * @returns {Object | null} The closest data point or null if not close to any
   *                          data point
   * @private
   */
  Graph3d.prototype._dataPointFromXY = function (x, y) {
    var i,
        distMax = 100,
        // px
    dataPoint = null,
        closestDataPoint = null,
        closestDist = null,
        center = new Point2d(x, y);

    if (this.style === Graph3d.STYLE.BAR || this.style === Graph3d.STYLE.BARCOLOR || this.style === Graph3d.STYLE.BARSIZE) {
      // the data points are ordered from far away to closest
      for (i = this.dataPoints.length - 1; i >= 0; i--) {
        dataPoint = this.dataPoints[i];
        var surfaces = dataPoint.surfaces;
        if (surfaces) {
          for (var s = surfaces.length - 1; s >= 0; s--) {
            // split each surface in two triangles, and see if the center point is inside one of these
            var surface = surfaces[s];
            var corners = surface.corners;
            var triangle1 = [corners[0].screen, corners[1].screen, corners[2].screen];
            var triangle2 = [corners[2].screen, corners[3].screen, corners[0].screen];
            if (this._insideTriangle(center, triangle1) || this._insideTriangle(center, triangle2)) {
              // return immediately at the first hit
              return dataPoint;
            }
          }
        }
      }
    } else {
      // find the closest data point, using distance to the center of the point on 2d screen
      for (i = 0; i < this.dataPoints.length; i++) {
        dataPoint = this.dataPoints[i];
        var point = dataPoint.screen;
        if (point) {
          var distX = Math.abs(x - point.x);
          var distY = Math.abs(y - point.y);
          var dist = Math.sqrt(distX * distX + distY * distY);

          if ((closestDist === null || dist < closestDist) && dist < distMax) {
            closestDist = dist;
            closestDataPoint = dataPoint;
          }
        }
      }
    }

    return closestDataPoint;
  };

  /**
   * Display a tooltip for given data point
   * @param {Object} dataPoint
   * @private
   */
  Graph3d.prototype._showTooltip = function (dataPoint) {
    var content, line, dot;

    if (!this.tooltip) {
      content = document.createElement('div');
      content.style.position = 'absolute';
      content.style.padding = '10px';
      content.style.border = '1px solid #4d4d4d';
      content.style.color = '#1a1a1a';
      content.style.background = 'rgba(255,255,255,0.7)';
      content.style.borderRadius = '2px';
      content.style.boxShadow = '5px 5px 10px rgba(128,128,128,0.5)';

      line = document.createElement('div');
      line.style.position = 'absolute';
      line.style.height = '40px';
      line.style.width = '0';
      line.style.borderLeft = '1px solid #4d4d4d';

      dot = document.createElement('div');
      dot.style.position = 'absolute';
      dot.style.height = '0';
      dot.style.width = '0';
      dot.style.border = '5px solid #4d4d4d';
      dot.style.borderRadius = '5px';

      this.tooltip = {
        dataPoint: null,
        dom: {
          content: content,
          line: line,
          dot: dot
        }
      };
    } else {
      content = this.tooltip.dom.content;
      line = this.tooltip.dom.line;
      dot = this.tooltip.dom.dot;
    }

    this._hideTooltip();

    this.tooltip.dataPoint = dataPoint;
    if (typeof this.showTooltip === 'function') {
      content.innerHTML = this.showTooltip(dataPoint.point);
    } else {
      content.innerHTML = '<table>' + '<tr><td>' + this.xLabel + ':</td><td>' + dataPoint.point.x + '</td></tr>' + '<tr><td>' + this.yLabel + ':</td><td>' + dataPoint.point.y + '</td></tr>' + '<tr><td>' + this.zLabel + ':</td><td>' + dataPoint.point.z + '</td></tr>' + '</table>';
    }

    content.style.left = '0';
    content.style.top = '0';
    this.frame.appendChild(content);
    this.frame.appendChild(line);
    this.frame.appendChild(dot);

    // calculate sizes
    var contentWidth = content.offsetWidth;
    var contentHeight = content.offsetHeight;
    var lineHeight = line.offsetHeight;
    var dotWidth = dot.offsetWidth;
    var dotHeight = dot.offsetHeight;

    var left = dataPoint.screen.x - contentWidth / 2;
    left = Math.min(Math.max(left, 10), this.frame.clientWidth - 10 - contentWidth);

    line.style.left = dataPoint.screen.x + 'px';
    line.style.top = dataPoint.screen.y - lineHeight + 'px';
    content.style.left = left + 'px';
    content.style.top = dataPoint.screen.y - lineHeight - contentHeight + 'px';
    dot.style.left = dataPoint.screen.x - dotWidth / 2 + 'px';
    dot.style.top = dataPoint.screen.y - dotHeight / 2 + 'px';
  };

  /**
   * Hide the tooltip when displayed
   * @private
   */
  Graph3d.prototype._hideTooltip = function () {
    if (this.tooltip) {
      this.tooltip.dataPoint = null;

      for (var prop in this.tooltip.dom) {
        if (this.tooltip.dom.hasOwnProperty(prop)) {
          var elem = this.tooltip.dom[prop];
          if (elem && elem.parentNode) {
            elem.parentNode.removeChild(elem);
          }
        }
      }
    }
  };

  /**--------------------------------------------------------------------------**/

  /**
   * Get the horizontal mouse position from a mouse event
   *
   * @param   {Event}  event
   * @returns {Number} mouse x
   */
  function getMouseX(event) {
    if ('clientX' in event) return event.clientX;
    return event.targetTouches[0] && event.targetTouches[0].clientX || 0;
  }

  /**
   * Get the vertical mouse position from a mouse event
   *
   * @param   {Event}  event
   * @returns {Number} mouse y
   */
  function getMouseY(event) {
    if ('clientY' in event) return event.clientY;
    return event.targetTouches[0] && event.targetTouches[0].clientY || 0;
  }

  // -----------------------------------------------------------------------------
  //  Public methods for specific settings
  // -----------------------------------------------------------------------------

  /**
   * Set the rotation and distance of the camera
   *
   * @param {Object}  pos            An object with the camera position
   * @param {?Number} pos.horizontal The horizontal rotation, between 0 and 2*PI.
   *                                 Optional, can be left undefined.
   * @param {?Number} pos.vertical   The vertical rotation, between 0 and 0.5*PI.
   *                                 if vertical=0.5*PI, the graph is shown from
   *                                 the top. Optional, can be left undefined.
   * @param {?Number} pos.distance   The (normalized) distance of the camera to the
   *                                 center of the graph, a value between 0.71 and
   *                                 5.0. Optional, can be left undefined.
   */
  Graph3d.prototype.setCameraPosition = function (pos) {
    Settings.setCameraPosition(pos, this);
    this.redraw();
  };

  // -----------------------------------------------------------------------------
  //  End public methods for specific settings
  // -----------------------------------------------------------------------------


  module.exports = Graph3d;

/***/ },
/* 13 */
/***/ function(module, exports) {

  
  /**
   * Expose `Emitter`.
   */

  module.exports = Emitter;

  /**
   * Initialize a new `Emitter`.
   *
   * @api public
   */

  function Emitter(obj) {
    if (obj) return mixin(obj);
  };

  /**
   * Mixin the emitter properties.
   *
   * @param {Object} obj
   * @return {Object}
   * @api private
   */

  function mixin(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }
    return obj;
  }

  /**
   * Listen on the given `event` with `fn`.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.on =
  Emitter.prototype.addEventListener = function(event, fn){
    this._callbacks = this._callbacks || {};
    (this._callbacks[event] = this._callbacks[event] || [])
      .push(fn);
    return this;
  };

  /**
   * Adds an `event` listener that will be invoked a single
   * time then automatically removed.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.once = function(event, fn){
    var self = this;
    this._callbacks = this._callbacks || {};

    function on() {
      self.off(event, on);
      fn.apply(this, arguments);
    }

    on.fn = fn;
    this.on(event, on);
    return this;
  };

  /**
   * Remove the given callback for `event` or all
   * registered callbacks.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.off =
  Emitter.prototype.removeListener =
  Emitter.prototype.removeAllListeners =
  Emitter.prototype.removeEventListener = function(event, fn){
    this._callbacks = this._callbacks || {};

    // all
    if (0 == arguments.length) {
      this._callbacks = {};
      return this;
    }

    // specific event
    var callbacks = this._callbacks[event];
    if (!callbacks) return this;

    // remove all handlers
    if (1 == arguments.length) {
      delete this._callbacks[event];
      return this;
    }

    // remove specific handler
    var cb;
    for (var i = 0; i < callbacks.length; i++) {
      cb = callbacks[i];
      if (cb === fn || cb.fn === fn) {
        callbacks.splice(i, 1);
        break;
      }
    }
    return this;
  };

  /**
   * Emit `event` with the given args.
   *
   * @param {String} event
   * @param {Mixed} ...
   * @return {Emitter}
   */

  Emitter.prototype.emit = function(event){
    this._callbacks = this._callbacks || {};
    var args = [].slice.call(arguments, 1)
      , callbacks = this._callbacks[event];

    if (callbacks) {
      callbacks = callbacks.slice(0);
      for (var i = 0, len = callbacks.length; i < len; ++i) {
        callbacks[i].apply(this, args);
      }
    }

    return this;
  };

  /**
   * Return array of callbacks for `event`.
   *
   * @param {String} event
   * @return {Array}
   * @api public
   */

  Emitter.prototype.listeners = function(event){
    this._callbacks = this._callbacks || {};
    return this._callbacks[event] || [];
  };

  /**
   * Check if this emitter has `event` handlers.
   *
   * @param {String} event
   * @return {Boolean}
   * @api public
   */

  Emitter.prototype.hasListeners = function(event){
    return !! this.listeners(event).length;
  };


/***/ },
/* 14 */
/***/ function(module, exports) {

  "use strict";

  /**
   * @prototype Point3d
   * @param {Number} [x]
   * @param {Number} [y]
   * @param {Number} [z]
   */
  function Point3d(x, y, z) {
    this.x = x !== undefined ? x : 0;
    this.y = y !== undefined ? y : 0;
    this.z = z !== undefined ? z : 0;
  };

  /**
   * Subtract the two provided points, returns a-b
   * @param {Point3d} a
   * @param {Point3d} b
   * @return {Point3d} a-b
   */
  Point3d.subtract = function (a, b) {
    var sub = new Point3d();
    sub.x = a.x - b.x;
    sub.y = a.y - b.y;
    sub.z = a.z - b.z;
    return sub;
  };

  /**
   * Add the two provided points, returns a+b
   * @param {Point3d} a
   * @param {Point3d} b
   * @return {Point3d} a+b
   */
  Point3d.add = function (a, b) {
    var sum = new Point3d();
    sum.x = a.x + b.x;
    sum.y = a.y + b.y;
    sum.z = a.z + b.z;
    return sum;
  };

  /**
   * Calculate the average of two 3d points
   * @param {Point3d} a
   * @param {Point3d} b
   * @return {Point3d} The average, (a+b)/2
   */
  Point3d.avg = function (a, b) {
    return new Point3d((a.x + b.x) / 2, (a.y + b.y) / 2, (a.z + b.z) / 2);
  };

  /**
   * Calculate the cross product of the two provided points, returns axb
   * Documentation: http://en.wikipedia.org/wiki/Cross_product
   * @param {Point3d} a
   * @param {Point3d} b
   * @return {Point3d} cross product axb
   */
  Point3d.crossProduct = function (a, b) {
    var crossproduct = new Point3d();

    crossproduct.x = a.y * b.z - a.z * b.y;
    crossproduct.y = a.z * b.x - a.x * b.z;
    crossproduct.z = a.x * b.y - a.y * b.x;

    return crossproduct;
  };

  /**
   * Rtrieve the length of the vector (or the distance from this point to the origin
   * @return {Number}  length
   */
  Point3d.prototype.length = function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  };

  module.exports = Point3d;

/***/ },
/* 15 */
/***/ function(module, exports) {

  "use strict";

  /**
   * @prototype Point2d
   * @param {Number} [x]
   * @param {Number} [y]
   */
  function Point2d(x, y) {
    this.x = x !== undefined ? x : 0;
    this.y = y !== undefined ? y : 0;
  }

  module.exports = Point2d;

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Point3d = __webpack_require__(14);

  /**
   * @class Camera
   * The camera is mounted on a (virtual) camera arm. The camera arm can rotate
   * The camera is always looking in the direction of the origin of the arm.
   * This way, the camera always rotates around one fixed point, the location
   * of the camera arm.
   *
   * Documentation:
   *   http://en.wikipedia.org/wiki/3D_projection
   */
  function Camera() {
    this.armLocation = new Point3d();
    this.armRotation = {};
    this.armRotation.horizontal = 0;
    this.armRotation.vertical = 0;
    this.armLength = 1.7;

    this.cameraLocation = new Point3d();
    this.cameraRotation = new Point3d(0.5 * Math.PI, 0, 0);

    this.calculateCameraOrientation();
  }

  /**
   * Set the location (origin) of the arm
   * @param {Number} x  Normalized value of x
   * @param {Number} y  Normalized value of y
   * @param {Number} z  Normalized value of z
   */
  Camera.prototype.setArmLocation = function (x, y, z) {
    this.armLocation.x = x;
    this.armLocation.y = y;
    this.armLocation.z = z;

    this.calculateCameraOrientation();
  };

  /**
   * Set the rotation of the camera arm
   * @param {Number} horizontal   The horizontal rotation, between 0 and 2*PI.
   *                Optional, can be left undefined.
   * @param {Number} vertical   The vertical rotation, between 0 and 0.5*PI
   *                if vertical=0.5*PI, the graph is shown from the
   *                top. Optional, can be left undefined.
   */
  Camera.prototype.setArmRotation = function (horizontal, vertical) {
    if (horizontal !== undefined) {
      this.armRotation.horizontal = horizontal;
    }

    if (vertical !== undefined) {
      this.armRotation.vertical = vertical;
      if (this.armRotation.vertical < 0) this.armRotation.vertical = 0;
      if (this.armRotation.vertical > 0.5 * Math.PI) this.armRotation.vertical = 0.5 * Math.PI;
    }

    if (horizontal !== undefined || vertical !== undefined) {
      this.calculateCameraOrientation();
    }
  };

  /**
   * Retrieve the current arm rotation
   * @return {object}   An object with parameters horizontal and vertical
   */
  Camera.prototype.getArmRotation = function () {
    var rot = {};
    rot.horizontal = this.armRotation.horizontal;
    rot.vertical = this.armRotation.vertical;

    return rot;
  };

  /**
   * Set the (normalized) length of the camera arm.
   * @param {Number} length A length between 0.71 and 5.0
   */
  Camera.prototype.setArmLength = function (length) {
    if (length === undefined) return;

    this.armLength = length;

    // Radius must be larger than the corner of the graph,
    // which has a distance of sqrt(0.5^2+0.5^2) = 0.71 from the center of the
    // graph
    if (this.armLength < 0.71) this.armLength = 0.71;
    if (this.armLength > 5.0) this.armLength = 5.0;

    this.calculateCameraOrientation();
  };

  /**
   * Retrieve the arm length
   * @return {Number} length
   */
  Camera.prototype.getArmLength = function () {
    return this.armLength;
  };

  /**
   * Retrieve the camera location
   * @return {Point3d} cameraLocation
   */
  Camera.prototype.getCameraLocation = function () {
    return this.cameraLocation;
  };

  /**
   * Retrieve the camera rotation
   * @return {Point3d} cameraRotation
   */
  Camera.prototype.getCameraRotation = function () {
    return this.cameraRotation;
  };

  /**
   * Calculate the location and rotation of the camera based on the
   * position and orientation of the camera arm
   */
  Camera.prototype.calculateCameraOrientation = function () {
    // calculate location of the camera
    this.cameraLocation.x = this.armLocation.x - this.armLength * Math.sin(this.armRotation.horizontal) * Math.cos(this.armRotation.vertical);
    this.cameraLocation.y = this.armLocation.y - this.armLength * Math.cos(this.armRotation.horizontal) * Math.cos(this.armRotation.vertical);
    this.cameraLocation.z = this.armLocation.z + this.armLength * Math.sin(this.armRotation.vertical);

    // calculate rotation of the camera
    this.cameraRotation.x = Math.PI / 2 - this.armRotation.vertical;
    this.cameraRotation.y = 0;
    this.cameraRotation.z = -this.armRotation.horizontal;
  };

  module.exports = Camera;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var DataView = __webpack_require__(11);

  /**
   * @class Filter
   *
   * @param {DataSet} data The google data table
   * @param {Number}  column             The index of the column to be filtered
   * @param {Graph} graph           The graph
   */
  function Filter(data, column, graph) {
    this.data = data;
    this.column = column;
    this.graph = graph; // the parent graph

    this.index = undefined;
    this.value = undefined;

    // read all distinct values and select the first one
    this.values = graph.getDistinctValues(data.get(), this.column);

    // sort both numeric and string values correctly
    this.values.sort(function (a, b) {
      return a > b ? 1 : a < b ? -1 : 0;
    });

    if (this.values.length > 0) {
      this.selectValue(0);
    }

    // create an array with the filtered datapoints. this will be loaded afterwards
    this.dataPoints = [];

    this.loaded = false;
    this.onLoadCallback = undefined;

    if (graph.animationPreload) {
      this.loaded = false;
      this.loadInBackground();
    } else {
      this.loaded = true;
    }
  };

  /**
   * Return the label
   * @return {string} label
   */
  Filter.prototype.isLoaded = function () {
    return this.loaded;
  };

  /**
   * Return the loaded progress
   * @return {Number} percentage between 0 and 100
   */
  Filter.prototype.getLoadedProgress = function () {
    var len = this.values.length;

    var i = 0;
    while (this.dataPoints[i]) {
      i++;
    }

    return Math.round(i / len * 100);
  };

  /**
   * Return the label
   * @return {string} label
   */
  Filter.prototype.getLabel = function () {
    return this.graph.filterLabel;
  };

  /**
   * Return the columnIndex of the filter
   * @return {Number} columnIndex
   */
  Filter.prototype.getColumn = function () {
    return this.column;
  };

  /**
   * Return the currently selected value. Returns undefined if there is no selection
   * @return {*} value
   */
  Filter.prototype.getSelectedValue = function () {
    if (this.index === undefined) return undefined;

    return this.values[this.index];
  };

  /**
   * Retrieve all values of the filter
   * @return {Array} values
   */
  Filter.prototype.getValues = function () {
    return this.values;
  };

  /**
   * Retrieve one value of the filter
   * @param {Number}  index
   * @return {*} value
   */
  Filter.prototype.getValue = function (index) {
    if (index >= this.values.length) throw new Error('Index out of range');

    return this.values[index];
  };

  /**
   * Retrieve the (filtered) dataPoints for the currently selected filter index
   * @param {Number} [index] (optional)
   * @return {Array} dataPoints
   */
  Filter.prototype._getDataPoints = function (index) {
    if (index === undefined) index = this.index;

    if (index === undefined) return [];

    var dataPoints;
    if (this.dataPoints[index]) {
      dataPoints = this.dataPoints[index];
    } else {
      var f = {};
      f.column = this.column;
      f.value = this.values[index];

      var dataView = new DataView(this.data, { filter: function filter(item) {
          return item[f.column] == f.value;
        } }).get();
      dataPoints = this.graph._getDataPoints(dataView);

      this.dataPoints[index] = dataPoints;
    }

    return dataPoints;
  };

  /**
   * Set a callback function when the filter is fully loaded.
   */
  Filter.prototype.setOnLoadCallback = function (callback) {
    this.onLoadCallback = callback;
  };

  /**
   * Add a value to the list with available values for this filter
   * No double entries will be created.
   * @param {Number} index
   */
  Filter.prototype.selectValue = function (index) {
    if (index >= this.values.length) throw new Error('Index out of range');

    this.index = index;
    this.value = this.values[index];
  };

  /**
   * Load all filtered rows in the background one by one
   * Start this method without providing an index!
   */
  Filter.prototype.loadInBackground = function (index) {
    if (index === undefined) index = 0;

    var frame = this.graph.frame;

    if (index < this.values.length) {
      var dataPointsTemp = this._getDataPoints(index);
      //this.graph.redrawInfo(); // TODO: not neat

      // create a progress box
      if (frame.progress === undefined) {
        frame.progress = document.createElement('DIV');
        frame.progress.style.position = 'absolute';
        frame.progress.style.color = 'gray';
        frame.appendChild(frame.progress);
      }
      var progress = this.getLoadedProgress();
      frame.progress.innerHTML = 'Loading animation... ' + progress + '%';
      // TODO: this is no nice solution...
      frame.progress.style.bottom = 60 + 'px'; // TODO: use height of slider
      frame.progress.style.left = 10 + 'px';

      var me = this;
      setTimeout(function () {
        me.loadInBackground(index + 1);
      }, 10);
      this.loaded = false;
    } else {
      this.loaded = true;

      // remove the progress box
      if (frame.progress !== undefined) {
        frame.removeChild(frame.progress);
        frame.progress = undefined;
      }

      if (this.onLoadCallback) this.onLoadCallback();
    }
  };

  module.exports = Filter;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);

  /**
   * @constructor Slider
   *
   * An html slider control with start/stop/prev/next buttons
   * @param {Element} container  The element where the slider will be created
   * @param {Object} options   Available options:
   *                 {boolean} visible   If true (default) the
   *                           slider is visible.
   */
  function Slider(container, options) {
    if (container === undefined) {
      throw new Error('No container element defined');
    }
    this.container = container;
    this.visible = options && options.visible != undefined ? options.visible : true;

    if (this.visible) {
      this.frame = document.createElement('DIV');
      //this.frame.style.backgroundColor = '#E5E5E5';
      this.frame.style.width = '100%';
      this.frame.style.position = 'relative';
      this.container.appendChild(this.frame);

      this.frame.prev = document.createElement('INPUT');
      this.frame.prev.type = 'BUTTON';
      this.frame.prev.value = 'Prev';
      this.frame.appendChild(this.frame.prev);

      this.frame.play = document.createElement('INPUT');
      this.frame.play.type = 'BUTTON';
      this.frame.play.value = 'Play';
      this.frame.appendChild(this.frame.play);

      this.frame.next = document.createElement('INPUT');
      this.frame.next.type = 'BUTTON';
      this.frame.next.value = 'Next';
      this.frame.appendChild(this.frame.next);

      this.frame.bar = document.createElement('INPUT');
      this.frame.bar.type = 'BUTTON';
      this.frame.bar.style.position = 'absolute';
      this.frame.bar.style.border = '1px solid red';
      this.frame.bar.style.width = '100px';
      this.frame.bar.style.height = '6px';
      this.frame.bar.style.borderRadius = '2px';
      this.frame.bar.style.MozBorderRadius = '2px';
      this.frame.bar.style.border = '1px solid #7F7F7F';
      this.frame.bar.style.backgroundColor = '#E5E5E5';
      this.frame.appendChild(this.frame.bar);

      this.frame.slide = document.createElement('INPUT');
      this.frame.slide.type = 'BUTTON';
      this.frame.slide.style.margin = '0px';
      this.frame.slide.value = ' ';
      this.frame.slide.style.position = 'relative';
      this.frame.slide.style.left = '-100px';
      this.frame.appendChild(this.frame.slide);

      // create events
      var me = this;
      this.frame.slide.onmousedown = function (event) {
        me._onMouseDown(event);
      };
      this.frame.prev.onclick = function (event) {
        me.prev(event);
      };
      this.frame.play.onclick = function (event) {
        me.togglePlay(event);
      };
      this.frame.next.onclick = function (event) {
        me.next(event);
      };
    }

    this.onChangeCallback = undefined;

    this.values = [];
    this.index = undefined;

    this.playTimeout = undefined;
    this.playInterval = 1000; // milliseconds
    this.playLoop = true;
  }

  /**
   * Select the previous index
   */
  Slider.prototype.prev = function () {
    var index = this.getIndex();
    if (index > 0) {
      index--;
      this.setIndex(index);
    }
  };

  /**
   * Select the next index
   */
  Slider.prototype.next = function () {
    var index = this.getIndex();
    if (index < this.values.length - 1) {
      index++;
      this.setIndex(index);
    }
  };

  /**
   * Select the next index
   */
  Slider.prototype.playNext = function () {
    var start = new Date();

    var index = this.getIndex();
    if (index < this.values.length - 1) {
      index++;
      this.setIndex(index);
    } else if (this.playLoop) {
      // jump to the start
      index = 0;
      this.setIndex(index);
    }

    var end = new Date();
    var diff = end - start;

    // calculate how much time it to to set the index and to execute the callback
    // function.
    var interval = Math.max(this.playInterval - diff, 0);
    // document.title = diff // TODO: cleanup

    var me = this;
    this.playTimeout = setTimeout(function () {
      me.playNext();
    }, interval);
  };

  /**
   * Toggle start or stop playing
   */
  Slider.prototype.togglePlay = function () {
    if (this.playTimeout === undefined) {
      this.play();
    } else {
      this.stop();
    }
  };

  /**
   * Start playing
   */
  Slider.prototype.play = function () {
    // Test whether already playing
    if (this.playTimeout) return;

    this.playNext();

    if (this.frame) {
      this.frame.play.value = 'Stop';
    }
  };

  /**
   * Stop playing
   */
  Slider.prototype.stop = function () {
    clearInterval(this.playTimeout);
    this.playTimeout = undefined;

    if (this.frame) {
      this.frame.play.value = 'Play';
    }
  };

  /**
   * Set a callback function which will be triggered when the value of the
   * slider bar has changed.
   */
  Slider.prototype.setOnChangeCallback = function (callback) {
    this.onChangeCallback = callback;
  };

  /**
   * Set the interval for playing the list
   * @param {Number} interval   The interval in milliseconds
   */
  Slider.prototype.setPlayInterval = function (interval) {
    this.playInterval = interval;
  };

  /**
   * Retrieve the current play interval
   * @return {Number} interval   The interval in milliseconds
   */
  Slider.prototype.getPlayInterval = function (interval) {
    return this.playInterval;
  };

  /**
   * Set looping on or off
   * @pararm {boolean} doLoop  If true, the slider will jump to the start when
   *               the end is passed, and will jump to the end
   *               when the start is passed.
   */
  Slider.prototype.setPlayLoop = function (doLoop) {
    this.playLoop = doLoop;
  };

  /**
   * Execute the onchange callback function
   */
  Slider.prototype.onChange = function () {
    if (this.onChangeCallback !== undefined) {
      this.onChangeCallback();
    }
  };

  /**
   * redraw the slider on the correct place
   */
  Slider.prototype.redraw = function () {
    if (this.frame) {
      // resize the bar
      this.frame.bar.style.top = this.frame.clientHeight / 2 - this.frame.bar.offsetHeight / 2 + 'px';
      this.frame.bar.style.width = this.frame.clientWidth - this.frame.prev.clientWidth - this.frame.play.clientWidth - this.frame.next.clientWidth - 30 + 'px';

      // position the slider button
      var left = this.indexToLeft(this.index);
      this.frame.slide.style.left = left + 'px';
    }
  };

  /**
   * Set the list with values for the slider
   * @param {Array} values   A javascript array with values (any type)
   */
  Slider.prototype.setValues = function (values) {
    this.values = values;

    if (this.values.length > 0) this.setIndex(0);else this.index = undefined;
  };

  /**
   * Select a value by its index
   * @param {Number} index
   */
  Slider.prototype.setIndex = function (index) {
    if (index < this.values.length) {
      this.index = index;

      this.redraw();
      this.onChange();
    } else {
      throw new Error('Index out of range');
    }
  };

  /**
   * retrieve the index of the currently selected vaue
   * @return {Number} index
   */
  Slider.prototype.getIndex = function () {
    return this.index;
  };

  /**
   * retrieve the currently selected value
   * @return {*} value
   */
  Slider.prototype.get = function () {
    return this.values[this.index];
  };

  Slider.prototype._onMouseDown = function (event) {
    // only react on left mouse button down
    var leftButtonDown = event.which ? event.which === 1 : event.button === 1;
    if (!leftButtonDown) return;

    this.startClientX = event.clientX;
    this.startSlideX = parseFloat(this.frame.slide.style.left);

    this.frame.style.cursor = 'move';

    // add event listeners to handle moving the contents
    // we store the function onmousemove and onmouseup in the graph, so we can
    // remove the eventlisteners lateron in the function mouseUp()
    var me = this;
    this.onmousemove = function (event) {
      me._onMouseMove(event);
    };
    this.onmouseup = function (event) {
      me._onMouseUp(event);
    };
    util.addEventListener(document, 'mousemove', this.onmousemove);
    util.addEventListener(document, 'mouseup', this.onmouseup);
    util.preventDefault(event);
  };

  Slider.prototype.leftToIndex = function (left) {
    var width = parseFloat(this.frame.bar.style.width) - this.frame.slide.clientWidth - 10;
    var x = left - 3;

    var index = Math.round(x / width * (this.values.length - 1));
    if (index < 0) index = 0;
    if (index > this.values.length - 1) index = this.values.length - 1;

    return index;
  };

  Slider.prototype.indexToLeft = function (index) {
    var width = parseFloat(this.frame.bar.style.width) - this.frame.slide.clientWidth - 10;

    var x = index / (this.values.length - 1) * width;
    var left = x + 3;

    return left;
  };

  Slider.prototype._onMouseMove = function (event) {
    var diff = event.clientX - this.startClientX;
    var x = this.startSlideX + diff;

    var index = this.leftToIndex(x);

    this.setIndex(index);

    util.preventDefault();
  };

  Slider.prototype._onMouseUp = function (event) {
    this.frame.style.cursor = 'auto';

    // remove event listeners
    util.removeEventListener(document, 'mousemove', this.onmousemove);
    util.removeEventListener(document, 'mouseup', this.onmouseup);

    util.preventDefault();
  };

  module.exports = Slider;

/***/ },
/* 19 */
/***/ function(module, exports) {

  'use strict';

  /**
   * @prototype StepNumber
   * The class StepNumber is an iterator for Numbers. You provide a start and end
   * value, and a best step size. StepNumber itself rounds to fixed values and
   * a finds the step that best fits the provided step.
   *
   * If prettyStep is true, the step size is chosen as close as possible to the
   * provided step, but being a round value like 1, 2, 5, 10, 20, 50, ....
   *
   * Example usage:
   *   var step = new StepNumber(0, 10, 2.5, true);
   *   step.start();
   *   while (!step.end()) {
   *   alert(step.getCurrent());
   *   step.next();
   *   }
   *
   * Version: 1.0
   *
   * @param {Number} start     The start value
   * @param {Number} end     The end value
   * @param {Number} step    Optional. Step size. Must be a positive value.
   * @param {boolean} prettyStep Optional. If true, the step size is rounded
   *               To a pretty step size (like 1, 2, 5, 10, 20, 50, ...)
   */
  function StepNumber(start, end, step, prettyStep) {
    // set default values
    this._start = 0;
    this._end = 0;
    this._step = 1;
    this.prettyStep = true;
    this.precision = 5;

    this._current = 0;
    this.setRange(start, end, step, prettyStep);
  };

  /**
   * Check for input values, to prevent disasters from happening
   *
   * Source: http://stackoverflow.com/a/1830844
   */
  StepNumber.prototype.isNumeric = function (n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  };

  /**
   * Set a new range: start, end and step.
   *
   * @param {Number} start     The start value
   * @param {Number} end     The end value
   * @param {Number} step    Optional. Step size. Must be a positive value.
   * @param {boolean} prettyStep Optional. If true, the step size is rounded
   *               To a pretty step size (like 1, 2, 5, 10, 20, 50, ...)
   */
  StepNumber.prototype.setRange = function (start, end, step, prettyStep) {
    if (!this.isNumeric(start)) {
      throw new Error('Parameter \'start\' is not numeric; value: ' + start);
    }
    if (!this.isNumeric(end)) {
      throw new Error('Parameter \'end\' is not numeric; value: ' + start);
    }
    if (!this.isNumeric(step)) {
      throw new Error('Parameter \'step\' is not numeric; value: ' + start);
    }

    this._start = start ? start : 0;
    this._end = end ? end : 0;

    this.setStep(step, prettyStep);
  };

  /**
   * Set a new step size
   * @param {Number} step    New step size. Must be a positive value
   * @param {boolean} prettyStep Optional. If true, the provided step is rounded
   *               to a pretty step size (like 1, 2, 5, 10, 20, 50, ...)
   */
  StepNumber.prototype.setStep = function (step, prettyStep) {
    if (step === undefined || step <= 0) return;

    if (prettyStep !== undefined) this.prettyStep = prettyStep;

    if (this.prettyStep === true) this._step = StepNumber.calculatePrettyStep(step);else this._step = step;
  };

  /**
   * Calculate a nice step size, closest to the desired step size.
   * Returns a value in one of the ranges 1*10^n, 2*10^n, or 5*10^n, where n is an
   * integer Number. For example 1, 2, 5, 10, 20, 50, etc...
   * @param {Number}  step  Desired step size
   * @return {Number}     Nice step size
   */
  StepNumber.calculatePrettyStep = function (step) {
    var log10 = function log10(x) {
      return Math.log(x) / Math.LN10;
    };

    // try three steps (multiple of 1, 2, or 5
    var step1 = Math.pow(10, Math.round(log10(step))),
        step2 = 2 * Math.pow(10, Math.round(log10(step / 2))),
        step5 = 5 * Math.pow(10, Math.round(log10(step / 5)));

    // choose the best step (closest to minimum step)
    var prettyStep = step1;
    if (Math.abs(step2 - step) <= Math.abs(prettyStep - step)) prettyStep = step2;
    if (Math.abs(step5 - step) <= Math.abs(prettyStep - step)) prettyStep = step5;

    // for safety
    if (prettyStep <= 0) {
      prettyStep = 1;
    }

    return prettyStep;
  };

  /**
   * returns the current value of the step
   * @return {Number} current value
   */
  StepNumber.prototype.getCurrent = function () {
    return parseFloat(this._current.toPrecision(this.precision));
  };

  /**
   * returns the current step size
   * @return {Number} current step size
   */
  StepNumber.prototype.getStep = function () {
    return this._step;
  };

  /**
   * Set the current to its starting value.
   *
   * By default, this will be the largest value smaller than start, which
   * is a multiple of the step size.
   *
   * Parameters checkFirst is optional, default false.
   * If set to true, move the current value one step if smaller than start.
   */
  StepNumber.prototype.start = function (checkFirst) {
    if (checkFirst === undefined) {
      checkFirst = false;
    }

    this._current = this._start - this._start % this._step;

    if (checkFirst) {
      if (this.getCurrent() < this._start) {
        this.next();
      }
    }
  };

  /**
   * Do a step, add the step size to the current value
   */
  StepNumber.prototype.next = function () {
    this._current += this._step;
  };

  /**
   * Returns true whether the end is reached
   * @return {boolean}  True if the current value has passed the end value.
   */
  StepNumber.prototype.end = function () {
    return this._current > this._end;
  };

  module.exports = StepNumber;

/***/ },
/* 20 */
/***/ function(module, exports) {

  'use strict';

  /**
   * @prototype Range
   *
   * Helper class to make working with related min and max values easier.
   *
   * The range is inclusive; a given value is considered part of the range if:
   *
   *    this.min <= value <= this.max
   */
  function Range() {
    this.min = undefined;
    this.max = undefined;
  }

  /**
   * Adjust the range so that the passed value fits in it.
   *
   * If the value is outside of the current extremes, adjust
   * the min or max so that the value is within the range.
   *
   * @param {number} value Numeric value to fit in range
   */
  Range.prototype.adjust = function (value) {
    if (value === undefined) return;

    if (this.min === undefined || this.min > value) {
      this.min = value;
    }

    if (this.max === undefined || this.max < value) {
      this.max = value;
    }
  };

  /**
   * Adjust the current range so that the passed range fits in it.
   *
   * @param {Range} range Range instance to fit in current instance
   */
  Range.prototype.combine = function (range) {
    this.add(range.min);
    this.add(range.max);
  };

  /**
   * Expand the range by the given value
   *
   * min will be lowered by given value;
   * max will be raised by given value
   *
   * Shrinking by passing a negative value is allowed.
   *
   * @param {number} val Amount by which to expand or shrink current range with
   */
  Range.prototype.expand = function (val) {
    if (val === undefined) {
      return;
    }

    var newMin = this.min - val;
    var newMax = this.max + val;

    // Note that following allows newMin === newMax.
    // This should be OK, since method expand() allows this also.
    if (newMin > newMax) {
      throw new Error('Passed expansion value makes range invalid');
    }

    this.min = newMin;
    this.max = newMax;
  };

  /**
   * Determine the full range width of current instance.
   *
   * @returns {num} The calculated width of this range
   */
  Range.prototype.range = function () {
    return this.max - this.min;
  };

  /**
   * Determine the central point of current instance.
   *
   * @returns {number} the value in the middle of min and max
   */
  Range.prototype.center = function () {
    return (this.min + this.max) / 2;
  };

  module.exports = Range;

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  ////////////////////////////////////////////////////////////////////////////////
  // This modules handles the options for Graph3d.
  //
  ////////////////////////////////////////////////////////////////////////////////
  var Camera = __webpack_require__(16);
  var Point3d = __webpack_require__(14);

  // enumerate the available styles
  var STYLE = {
    BAR: 0,
    BARCOLOR: 1,
    BARSIZE: 2,
    DOT: 3,
    DOTLINE: 4,
    DOTCOLOR: 5,
    DOTSIZE: 6,
    GRID: 7,
    LINE: 8,
    SURFACE: 9
  };

  // The string representations of the styles
  var STYLENAME = {
    'dot': STYLE.DOT,
    'dot-line': STYLE.DOTLINE,
    'dot-color': STYLE.DOTCOLOR,
    'dot-size': STYLE.DOTSIZE,
    'line': STYLE.LINE,
    'grid': STYLE.GRID,
    'surface': STYLE.SURFACE,
    'bar': STYLE.BAR,
    'bar-color': STYLE.BARCOLOR,
    'bar-size': STYLE.BARSIZE
  };

  /**
   * Field names in the options hash which are of relevance to the user.
   *
   * Specifically, these are the fields which require no special handling,
   * and can be directly copied over.
   */
  var OPTIONKEYS = ['width', 'height', 'filterLabel', 'legendLabel', 'xLabel', 'yLabel', 'zLabel', 'xValueLabel', 'yValueLabel', 'zValueLabel', 'showGrid', 'showPerspective', 'showShadow', 'keepAspectRatio', 'verticalRatio', 'dotSizeRatio', 'showAnimationControls', 'animationInterval', 'animationPreload', 'animationAutoStart', 'axisColor', 'gridColor', 'xCenter', 'yCenter'];

  /**
   * Field names in the options hash which are of relevance to the user.
   *
   * Same as OPTIONKEYS, but internally these fields are stored with 
   * prefix 'default' in the name.
   */
  var PREFIXEDOPTIONKEYS = ['xBarWidth', 'yBarWidth', 'valueMin', 'valueMax', 'xMin', 'xMax', 'xStep', 'yMin', 'yMax', 'yStep', 'zMin', 'zMax', 'zStep'];

  // Placeholder for DEFAULTS reference
  var DEFAULTS = undefined;

  /**
   * Check if given hash is empty.
   *
   * Source: http://stackoverflow.com/a/679937
   */
  function isEmpty(obj) {
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) return false;
    }

    return true;
  }

  /**
   * Make first letter of parameter upper case.
   *
   * Source: http://stackoverflow.com/a/1026087
   */
  function capitalize(str) {
    if (str === undefined || str === "") {
      return str;
    }

    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  /**
   * Add a prefix to a field name, taking style guide into account
   */
  function prefixFieldName(prefix, fieldName) {
    if (prefix === undefined || prefix === "") {
      return fieldName;
    }

    return prefix + capitalize(fieldName);
  }

  /**
   * Forcibly copy fields from src to dst in a controlled manner.
   *
   * A given field in dst will always be overwitten. If this field
   * is undefined or not present in src, the field in dst will 
   * be explicitly set to undefined.
   * 
   * The intention here is to be able to reset all option fields.
   * 
   * Only the fields mentioned in array 'fields' will be handled.
   *
   * @param fields array with names of fields to copy
   * @param prefix optional; prefix to use for the target fields.
   */
  function forceCopy(src, dst, fields, prefix) {
    var srcKey;
    var dstKey;

    for (var i in fields) {
      srcKey = fields[i];
      dstKey = prefixFieldName(prefix, srcKey);

      dst[dstKey] = src[srcKey];
    }
  }

  /**
   * Copy fields from src to dst in a safe and controlled manner.
   *
   * Only the fields mentioned in array 'fields' will be copied over,
   * and only if these are actually defined.
   *
   * @param fields array with names of fields to copy
   * @param prefix optional; prefix to use for the target fields.
   */
  function safeCopy(src, dst, fields, prefix) {
    var srcKey;
    var dstKey;

    for (var i in fields) {
      srcKey = fields[i];
      if (src[srcKey] === undefined) continue;

      dstKey = prefixFieldName(prefix, srcKey);

      dst[dstKey] = src[srcKey];
    }
  }

  /**
   * Initialize dst with the values in src.
   *
   * src is the hash with the default values. 
   * A reference DEFAULTS to this hash is stored locally for 
   * further handling.
   *
   * For now, dst is assumed to be a Graph3d instance.
   */
  function setDefaults(src, dst) {
    if (src === undefined || isEmpty(src)) {
      throw new Error('No DEFAULTS passed');
    }
    if (dst === undefined) {
      throw new Error('No dst passed');
    }

    // Remember defaults for future reference
    DEFAULTS = src;

    // Handle the defaults which can be simply copied over
    forceCopy(src, dst, OPTIONKEYS);
    forceCopy(src, dst, PREFIXEDOPTIONKEYS, 'default');

    // Handle the more complex ('special') fields
    setSpecialSettings(src, dst);

    // Following are internal fields, not part of the user settings
    dst.margin = 10; // px
    dst.showGrayBottom = false; // TODO: this does not work correctly
    dst.showTooltip = false;
    dst.eye = new Point3d(0, 0, -1); // TODO: set eye.z about 3/4 of the width of the window?
  }

  function setOptions(options, dst) {
    if (options === undefined) {
      return;
    }
    if (dst === undefined) {
      throw new Error('No dst passed');
    }

    if (DEFAULTS === undefined || isEmpty(DEFAULTS)) {
      throw new Error('DEFAULTS not set for module Settings');
    }

    // Handle the parameters which can be simply copied over
    safeCopy(options, dst, OPTIONKEYS);
    safeCopy(options, dst, PREFIXEDOPTIONKEYS, 'default');

    // Handle the more complex ('special') fields
    setSpecialSettings(options, dst);
  }

  /**
   * Special handling for certain parameters
   *
   * 'Special' here means: setting requires more than a simple copy
   */
  function setSpecialSettings(src, dst) {
    if (src.backgroundColor !== undefined) {
      setBackgroundColor(src.backgroundColor, dst);
    }

    setDataColor(src.dataColor, dst);
    setStyle(src.style, dst);
    setShowLegend(src.showLegend, dst);
    setCameraPosition(src.cameraPosition, dst);

    // As special fields go, this is an easy one; just a translation of the name.
    // Can't use this.tooltip directly, because that field exists internally
    if (src.tooltip !== undefined) {
      dst.showTooltip = src.tooltip;
    }
  }

  /**
   * Set the value of setting 'showLegend'
   *
   * This depends on the value of the style fields, so it must be called
   * after the style field has been initialized.
   */
  function setShowLegend(showLegend, dst) {
    if (showLegend === undefined) {
      // If the default was auto, make a choice for this field
      var isAutoByDefault = DEFAULTS.showLegend === undefined;

      if (isAutoByDefault) {
        // these styles default to having legends
        var isLegendGraphStyle = dst.style === STYLE.DOTCOLOR || dst.style === STYLE.DOTSIZE;

        dst.showLegend = isLegendGraphStyle;
      } else {
        // Leave current value as is
      }
    } else {
      dst.showLegend = showLegend;
    }
  }

  /**
   * Retrieve the style index from given styleName
   * @param {string} styleName  Style name such as 'dot', 'grid', 'dot-line'
   * @return {Number} styleNumber Enumeration value representing the style, or -1
   *                when not found
   */
  function getStyleNumberByName(styleName) {
    var number = STYLENAME[styleName];

    if (number === undefined) {
      return -1;
    }

    return number;
  }

  /**
   * Check if given number is a valid style number.
   *
   * @return true if valid, false otherwise
   */
  function checkStyleNumber(style) {
    var valid = false;

    for (var n in STYLE) {
      if (STYLE[n] === style) {
        valid = true;
        break;
      }
    }

    return valid;
  }

  function setStyle(style, dst) {
    if (style === undefined) {
      return; // Nothing to do
    }

    var styleNumber;

    if (typeof style === 'string') {
      styleNumber = getStyleNumberByName(style);

      if (styleNumber === -1) {
        throw new Error('Style \'' + style + '\' is invalid');
      }
    } else {
      // Do a pedantic check on style number value
      if (!checkStyleNumber(style)) {
        throw new Error('Style \'' + style + '\' is invalid');
      }

      styleNumber = style;
    }

    dst.style = styleNumber;
  }

  /**
   * Set the background styling for the graph
   * @param {string | {fill: string, stroke: string, strokeWidth: string}} backgroundColor
   */
  function setBackgroundColor(backgroundColor, dst) {
    var fill = 'white';
    var stroke = 'gray';
    var strokeWidth = 1;

    if (typeof backgroundColor === 'string') {
      fill = backgroundColor;
      stroke = 'none';
      strokeWidth = 0;
    } else if ((typeof backgroundColor === 'undefined' ? 'undefined' : _typeof(backgroundColor)) === 'object') {
      if (backgroundColor.fill !== undefined) fill = backgroundColor.fill;
      if (backgroundColor.stroke !== undefined) stroke = backgroundColor.stroke;
      if (backgroundColor.strokeWidth !== undefined) strokeWidth = backgroundColor.strokeWidth;
    } else {
      throw new Error('Unsupported type of backgroundColor');
    }

    dst.frame.style.backgroundColor = fill;
    dst.frame.style.borderColor = stroke;
    dst.frame.style.borderWidth = strokeWidth + 'px';
    dst.frame.style.borderStyle = 'solid';
  }

  function setDataColor(dataColor, dst) {
    if (dataColor === undefined) {
      return; // Nothing to do
    }

    if (dst.dataColor === undefined) {
      dst.dataColor = {};
    }

    if (typeof dataColor === 'string') {
      dst.dataColor.fill = dataColor;
      dst.dataColor.stroke = dataColor;
    } else {
      if (dataColor.fill) {
        dst.dataColor.fill = dataColor.fill;
      }
      if (dataColor.stroke) {
        dst.dataColor.stroke = dataColor.stroke;
      }
      if (dataColor.strokeWidth !== undefined) {
        dst.dataColor.strokeWidth = dataColor.strokeWidth;
      }
    }
  }

  function setCameraPosition(cameraPosition, dst) {
    var camPos = cameraPosition;
    if (camPos === undefined) {
      return;
    }

    if (dst.camera === undefined) {
      dst.camera = new Camera();
    }

    dst.camera.setArmRotation(camPos.horizontal, camPos.vertical);
    dst.camera.setArmLength(camPos.distance);
  }

  module.exports.STYLE = STYLE;
  module.exports.setDefaults = setDefaults;
  module.exports.setOptions = setOptions;
  module.exports.setCameraPosition = setCameraPosition;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  // Only load hammer.js when in a browser environment
  // (loading hammer.js in a node.js environment gives errors)
  if (typeof window !== 'undefined') {
    var propagating = __webpack_require__(23);
    var Hammer = window['Hammer'] || __webpack_require__(24);
    module.exports = propagating(Hammer, {
      preventDefault: 'mouse'
    });
  } else {
    module.exports = function () {
      throw Error('hammer.js is only available in a browser, not in node.js.');
    };
  }

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

  (function (factory) {
    if (true) {
      // AMD. Register as an anonymous module.
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports === 'object') {
      // Node. Does not work with strict CommonJS, but
      // only CommonJS-like environments that support module.exports,
      // like Node.
      module.exports = factory();
    } else {
      // Browser globals (root is window)
      window.propagating = factory();
    }
  }(function () {
    var _firstTarget = null; // singleton, will contain the target element where the touch event started

    /**
     * Extend an Hammer.js instance with event propagation.
     *
     * Features:
     * - Events emitted by hammer will propagate in order from child to parent
     *   elements.
     * - Events are extended with a function `event.stopPropagation()` to stop
     *   propagation to parent elements.
     * - An option `preventDefault` to stop all default browser behavior.
     *
     * Usage:
     *   var hammer = propagatingHammer(new Hammer(element));
     *   var hammer = propagatingHammer(new Hammer(element), {preventDefault: true});
     *
     * @param {Hammer.Manager} hammer   An hammer instance.
     * @param {Object} [options]        Available options:
     *                                  - `preventDefault: true | false | 'mouse' | 'touch' | 'pen'`.
     *                                    Enforce preventing the default browser behavior.
     *                                    Cannot be set to `false`.
     * @return {Hammer.Manager} Returns the same hammer instance with extended
     *                          functionality
     */
    return function propagating(hammer, options) {
      var _options = options || {
        preventDefault: false
      };

      if (hammer.Manager) {
        // This looks like the Hammer constructor.
        // Overload the constructors with our own.
        var Hammer = hammer;

        var PropagatingHammer = function(element, options) {
          var o = Object.create(_options);
          if (options) Hammer.assign(o, options);
          return propagating(new Hammer(element, o), o);
        };
        Hammer.assign(PropagatingHammer, Hammer);

        PropagatingHammer.Manager = function (element, options) {
          var o = Object.create(_options);
          if (options) Hammer.assign(o, options);
          return propagating(new Hammer.Manager(element, o), o);
        };

        return PropagatingHammer;
      }

      // create a wrapper object which will override the functions
      // `on`, `off`, `destroy`, and `emit` of the hammer instance
      var wrapper = Object.create(hammer);

      // attach to DOM element
      var element = hammer.element;

      if(!element.hammer) element.hammer = [];
      element.hammer.push(wrapper);

      // register an event to catch the start of a gesture and store the
      // target in a singleton
      hammer.on('hammer.input', function (event) {
        if (_options.preventDefault === true || (_options.preventDefault === event.pointerType)) {
          event.preventDefault();
        }
        if (event.isFirst) {
          _firstTarget = event.target;
        }
      });

      /** @type {Object.<String, Array.<function>>} */
      wrapper._handlers = {};

      /**
       * Register a handler for one or multiple events
       * @param {String} events    A space separated string with events
       * @param {function} handler A callback function, called as handler(event)
       * @returns {Hammer.Manager} Returns the hammer instance
       */
      wrapper.on = function (events, handler) {
        // register the handler
        split(events).forEach(function (event) {
          var _handlers = wrapper._handlers[event];
          if (!_handlers) {
            wrapper._handlers[event] = _handlers = [];

            // register the static, propagated handler
            hammer.on(event, propagatedHandler);
          }
          _handlers.push(handler);
        });

        return wrapper;
      };

      /**
       * Unregister a handler for one or multiple events
       * @param {String} events      A space separated string with events
       * @param {function} [handler] Optional. The registered handler. If not
       *                             provided, all handlers for given events
       *                             are removed.
       * @returns {Hammer.Manager}   Returns the hammer instance
       */
      wrapper.off = function (events, handler) {
        // unregister the handler
        split(events).forEach(function (event) {
          var _handlers = wrapper._handlers[event];
          if (_handlers) {
            _handlers = handler ? _handlers.filter(function (h) {
              return h !== handler;
            }) : [];

            if (_handlers.length > 0) {
              wrapper._handlers[event] = _handlers;
            }
            else {
              // remove static, propagated handler
              hammer.off(event, propagatedHandler);
              delete wrapper._handlers[event];
            }
          }
        });

        return wrapper;
      };

      /**
       * Emit to the event listeners
       * @param {string} eventType
       * @param {Event} event
       */
      wrapper.emit = function(eventType, event) {
        _firstTarget = event.target;
        hammer.emit(eventType, event);
      };

      wrapper.destroy = function () {
        // Detach from DOM element
        var hammers = hammer.element.hammer;
        var idx = hammers.indexOf(wrapper);
        if(idx !== -1) hammers.splice(idx,1);
        if(!hammers.length) delete hammer.element.hammer;

        // clear all handlers
        wrapper._handlers = {};

        // call original hammer destroy
        hammer.destroy();
      };

      // split a string with space separated words
      function split(events) {
        return events.match(/[^ ]+/g);
      }

      /**
       * A static event handler, applying event propagation.
       * @param {Object} event
       */
      function propagatedHandler(event) {
        // let only a single hammer instance handle this event
        if (event.type !== 'hammer.input') {
          // it is possible that the same srcEvent is used with multiple hammer events,
          // we keep track on which events are handled in an object _handled
          if (!event.srcEvent._handled) {
            event.srcEvent._handled = {};
          }

          if (event.srcEvent._handled[event.type]) {
            return;
          }
          else {
            event.srcEvent._handled[event.type] = true;
          }
        }

        // attach a stopPropagation function to the event
        var stopped = false;
        event.stopPropagation = function () {
          stopped = true;
        };

        //wrap the srcEvent's stopPropagation to also stop hammer propagation:
        var srcStop = event.srcEvent.stopPropagation.bind(event.srcEvent);
        if(typeof srcStop == "function") {
          event.srcEvent.stopPropagation = function(){
            srcStop();
            event.stopPropagation();
          }
        }

        // attach firstTarget property to the event
        event.firstTarget = _firstTarget;

        // propagate over all elements (until stopped)
        var elem = _firstTarget;
        while (elem && !stopped) {
          var elemHammer = elem.hammer;
          if(elemHammer){
            var _handlers;
            for(var k = 0; k < elemHammer.length; k++){
              _handlers = elemHammer[k]._handlers[event.type];
              if(_handlers) for (var i = 0; i < _handlers.length && !stopped; i++) {
                _handlers[i](event);
              }
            }
          }
          elem = elem.parentNode;
        }
      }

      return wrapper;
    };
  }));


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

  var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22
   * http://hammerjs.github.io/
   *
   * Copyright (c) 2016 Jorik Tangelder;
   * Licensed under the MIT license */
  (function(window, document, exportName, undefined) {
    'use strict';

  var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
  var TEST_ELEMENT = document.createElement('div');

  var TYPE_FUNCTION = 'function';

  var round = Math.round;
  var abs = Math.abs;
  var now = Date.now;

  /**
   * set a timeout with a given scope
   * @param {Function} fn
   * @param {Number} timeout
   * @param {Object} context
   * @returns {number}
   */
  function setTimeoutContext(fn, timeout, context) {
      return setTimeout(bindFn(fn, context), timeout);
  }

  /**
   * if the argument is an array, we want to execute the fn on each entry
   * if it aint an array we don't want to do a thing.
   * this is used by all the methods that accept a single and array argument.
   * @param {*|Array} arg
   * @param {String} fn
   * @param {Object} [context]
   * @returns {Boolean}
   */
  function invokeArrayArg(arg, fn, context) {
      if (Array.isArray(arg)) {
          each(arg, context[fn], context);
          return true;
      }
      return false;
  }

  /**
   * walk objects and arrays
   * @param {Object} obj
   * @param {Function} iterator
   * @param {Object} context
   */
  function each(obj, iterator, context) {
      var i;

      if (!obj) {
          return;
      }

      if (obj.forEach) {
          obj.forEach(iterator, context);
      } else if (obj.length !== undefined) {
          i = 0;
          while (i < obj.length) {
              iterator.call(context, obj[i], i, obj);
              i++;
          }
      } else {
          for (i in obj) {
              obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
          }
      }
  }

  /**
   * wrap a method with a deprecation warning and stack trace
   * @param {Function} method
   * @param {String} name
   * @param {String} message
   * @returns {Function} A new function wrapping the supplied method.
   */
  function deprecate(method, name, message) {
      var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
      return function() {
          var e = new Error('get-stack-trace');
          var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
              .replace(/^\s+at\s+/gm, '')
              .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

          var log = window.console && (window.console.warn || window.console.log);
          if (log) {
              log.call(window.console, deprecationMessage, stack);
          }
          return method.apply(this, arguments);
      };
  }

  /**
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} target
   * @param {...Object} objects_to_assign
   * @returns {Object} target
   */
  var assign;
  if (typeof Object.assign !== 'function') {
      assign = function assign(target) {
          if (target === undefined || target === null) {
              throw new TypeError('Cannot convert undefined or null to object');
          }

          var output = Object(target);
          for (var index = 1; index < arguments.length; index++) {
              var source = arguments[index];
              if (source !== undefined && source !== null) {
                  for (var nextKey in source) {
                      if (source.hasOwnProperty(nextKey)) {
                          output[nextKey] = source[nextKey];
                      }
                  }
              }
          }
          return output;
      };
  } else {
      assign = Object.assign;
  }

  /**
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} dest
   * @param {Object} src
   * @param {Boolean} [merge=false]
   * @returns {Object} dest
   */
  var extend = deprecate(function extend(dest, src, merge) {
      var keys = Object.keys(src);
      var i = 0;
      while (i < keys.length) {
          if (!merge || (merge && dest[keys[i]] === undefined)) {
              dest[keys[i]] = src[keys[i]];
          }
          i++;
      }
      return dest;
  }, 'extend', 'Use `assign`.');

  /**
   * merge the values from src in the dest.
   * means that properties that exist in dest will not be overwritten by src
   * @param {Object} dest
   * @param {Object} src
   * @returns {Object} dest
   */
  var merge = deprecate(function merge(dest, src) {
      return extend(dest, src, true);
  }, 'merge', 'Use `assign`.');

  /**
   * simple class inheritance
   * @param {Function} child
   * @param {Function} base
   * @param {Object} [properties]
   */
  function inherit(child, base, properties) {
      var baseP = base.prototype,
          childP;

      childP = child.prototype = Object.create(baseP);
      childP.constructor = child;
      childP._super = baseP;

      if (properties) {
          assign(childP, properties);
      }
  }

  /**
   * simple function bind
   * @param {Function} fn
   * @param {Object} context
   * @returns {Function}
   */
  function bindFn(fn, context) {
      return function boundFn() {
          return fn.apply(context, arguments);
      };
  }

  /**
   * let a boolean value also be a function that must return a boolean
   * this first item in args will be used as the context
   * @param {Boolean|Function} val
   * @param {Array} [args]
   * @returns {Boolean}
   */
  function boolOrFn(val, args) {
      if (typeof val == TYPE_FUNCTION) {
          return val.apply(args ? args[0] || undefined : undefined, args);
      }
      return val;
  }

  /**
   * use the val2 when val1 is undefined
   * @param {*} val1
   * @param {*} val2
   * @returns {*}
   */
  function ifUndefined(val1, val2) {
      return (val1 === undefined) ? val2 : val1;
  }

  /**
   * addEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */
  function addEventListeners(target, types, handler) {
      each(splitStr(types), function(type) {
          target.addEventListener(type, handler, false);
      });
  }

  /**
   * removeEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */
  function removeEventListeners(target, types, handler) {
      each(splitStr(types), function(type) {
          target.removeEventListener(type, handler, false);
      });
  }

  /**
   * find if a node is in the given parent
   * @method hasParent
   * @param {HTMLElement} node
   * @param {HTMLElement} parent
   * @return {Boolean} found
   */
  function hasParent(node, parent) {
      while (node) {
          if (node == parent) {
              return true;
          }
          node = node.parentNode;
      }
      return false;
  }

  /**
   * small indexOf wrapper
   * @param {String} str
   * @param {String} find
   * @returns {Boolean} found
   */
  function inStr(str, find) {
      return str.indexOf(find) > -1;
  }

  /**
   * split string on whitespace
   * @param {String} str
   * @returns {Array} words
   */
  function splitStr(str) {
      return str.trim().split(/\s+/g);
  }

  /**
   * find if a array contains the object using indexOf or a simple polyFill
   * @param {Array} src
   * @param {String} find
   * @param {String} [findByKey]
   * @return {Boolean|Number} false when not found, or the index
   */
  function inArray(src, find, findByKey) {
      if (src.indexOf && !findByKey) {
          return src.indexOf(find);
      } else {
          var i = 0;
          while (i < src.length) {
              if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                  return i;
              }
              i++;
          }
          return -1;
      }
  }

  /**
   * convert array-like objects to real arrays
   * @param {Object} obj
   * @returns {Array}
   */
  function toArray(obj) {
      return Array.prototype.slice.call(obj, 0);
  }

  /**
   * unique array with objects based on a key (like 'id') or just by the array's value
   * @param {Array} src [{id:1},{id:2},{id:1}]
   * @param {String} [key]
   * @param {Boolean} [sort=False]
   * @returns {Array} [{id:1},{id:2}]
   */
  function uniqueArray(src, key, sort) {
      var results = [];
      var values = [];
      var i = 0;

      while (i < src.length) {
          var val = key ? src[i][key] : src[i];
          if (inArray(values, val) < 0) {
              results.push(src[i]);
          }
          values[i] = val;
          i++;
      }

      if (sort) {
          if (!key) {
              results = results.sort();
          } else {
              results = results.sort(function sortUniqueArray(a, b) {
                  return a[key] > b[key];
              });
          }
      }

      return results;
  }

  /**
   * get the prefixed property
   * @param {Object} obj
   * @param {String} property
   * @returns {String|Undefined} prefixed
   */
  function prefixed(obj, property) {
      var prefix, prop;
      var camelProp = property[0].toUpperCase() + property.slice(1);

      var i = 0;
      while (i < VENDOR_PREFIXES.length) {
          prefix = VENDOR_PREFIXES[i];
          prop = (prefix) ? prefix + camelProp : property;

          if (prop in obj) {
              return prop;
          }
          i++;
      }
      return undefined;
  }

  /**
   * get a unique id
   * @returns {number} uniqueId
   */
  var _uniqueId = 1;
  function uniqueId() {
      return _uniqueId++;
  }

  /**
   * get the window object of an element
   * @param {HTMLElement} element
   * @returns {DocumentView|Window}
   */
  function getWindowForElement(element) {
      var doc = element.ownerDocument || element;
      return (doc.defaultView || doc.parentWindow || window);
  }

  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

  var SUPPORT_TOUCH = ('ontouchstart' in window);
  var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

  var INPUT_TYPE_TOUCH = 'touch';
  var INPUT_TYPE_PEN = 'pen';
  var INPUT_TYPE_MOUSE = 'mouse';
  var INPUT_TYPE_KINECT = 'kinect';

  var COMPUTE_INTERVAL = 25;

  var INPUT_START = 1;
  var INPUT_MOVE = 2;
  var INPUT_END = 4;
  var INPUT_CANCEL = 8;

  var DIRECTION_NONE = 1;
  var DIRECTION_LEFT = 2;
  var DIRECTION_RIGHT = 4;
  var DIRECTION_UP = 8;
  var DIRECTION_DOWN = 16;

  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

  var PROPS_XY = ['x', 'y'];
  var PROPS_CLIENT_XY = ['clientX', 'clientY'];

  /**
   * create new input type manager
   * @param {Manager} manager
   * @param {Function} callback
   * @returns {Input}
   * @constructor
   */
  function Input(manager, callback) {
      var self = this;
      this.manager = manager;
      this.callback = callback;
      this.element = manager.element;
      this.target = manager.options.inputTarget;

      // smaller wrapper around the handler, for the scope and the enabled state of the manager,
      // so when disabled the input events are completely bypassed.
      this.domHandler = function(ev) {
          if (boolOrFn(manager.options.enable, [manager])) {
              self.handler(ev);
          }
      };

      this.init();

  }

  Input.prototype = {
      /**
       * should handle the inputEvent data and trigger the callback
       * @virtual
       */
      handler: function() { },

      /**
       * bind the events
       */
      init: function() {
          this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
      },

      /**
       * unbind the events
       */
      destroy: function() {
          this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
      }
  };

  /**
   * create new input type manager
   * called by the Manager constructor
   * @param {Hammer} manager
   * @returns {Input}
   */
  function createInputInstance(manager) {
      var Type;
      var inputClass = manager.options.inputClass;

      if (inputClass) {
          Type = inputClass;
      } else if (SUPPORT_POINTER_EVENTS) {
          Type = PointerEventInput;
      } else if (SUPPORT_ONLY_TOUCH) {
          Type = TouchInput;
      } else if (!SUPPORT_TOUCH) {
          Type = MouseInput;
      } else {
          Type = TouchMouseInput;
      }
      return new (Type)(manager, inputHandler);
  }

  /**
   * handle input events
   * @param {Manager} manager
   * @param {String} eventType
   * @param {Object} input
   */
  function inputHandler(manager, eventType, input) {
      var pointersLen = input.pointers.length;
      var changedPointersLen = input.changedPointers.length;
      var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
      var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

      input.isFirst = !!isFirst;
      input.isFinal = !!isFinal;

      if (isFirst) {
          manager.session = {};
      }

      // source event is the normalized value of the domEvents
      // like 'touchstart, mouseup, pointerdown'
      input.eventType = eventType;

      // compute scale, rotation etc
      computeInputData(manager, input);

      // emit secret event
      manager.emit('hammer.input', input);

      manager.recognize(input);
      manager.session.prevInput = input;
  }

  /**
   * extend the data with some usable properties like scale, rotate, velocity etc
   * @param {Object} manager
   * @param {Object} input
   */
  function computeInputData(manager, input) {
      var session = manager.session;
      var pointers = input.pointers;
      var pointersLength = pointers.length;

      // store the first input to calculate the distance and direction
      if (!session.firstInput) {
          session.firstInput = simpleCloneInputData(input);
      }

      // to compute scale and rotation we need to store the multiple touches
      if (pointersLength > 1 && !session.firstMultiple) {
          session.firstMultiple = simpleCloneInputData(input);
      } else if (pointersLength === 1) {
          session.firstMultiple = false;
      }

      var firstInput = session.firstInput;
      var firstMultiple = session.firstMultiple;
      var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

      var center = input.center = getCenter(pointers);
      input.timeStamp = now();
      input.deltaTime = input.timeStamp - firstInput.timeStamp;

      input.angle = getAngle(offsetCenter, center);
      input.distance = getDistance(offsetCenter, center);

      computeDeltaXY(session, input);
      input.offsetDirection = getDirection(input.deltaX, input.deltaY);

      var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
      input.overallVelocityX = overallVelocity.x;
      input.overallVelocityY = overallVelocity.y;
      input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

      input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
      input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

      input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
          session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

      computeIntervalInputData(session, input);

      // find the correct target
      var target = manager.element;
      if (hasParent(input.srcEvent.target, target)) {
          target = input.srcEvent.target;
      }
      input.target = target;
  }

  function computeDeltaXY(session, input) {
      var center = input.center;
      var offset = session.offsetDelta || {};
      var prevDelta = session.prevDelta || {};
      var prevInput = session.prevInput || {};

      if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
          prevDelta = session.prevDelta = {
              x: prevInput.deltaX || 0,
              y: prevInput.deltaY || 0
          };

          offset = session.offsetDelta = {
              x: center.x,
              y: center.y
          };
      }

      input.deltaX = prevDelta.x + (center.x - offset.x);
      input.deltaY = prevDelta.y + (center.y - offset.y);
  }

  /**
   * velocity is calculated every x ms
   * @param {Object} session
   * @param {Object} input
   */
  function computeIntervalInputData(session, input) {
      var last = session.lastInterval || input,
          deltaTime = input.timeStamp - last.timeStamp,
          velocity, velocityX, velocityY, direction;

      if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
          var deltaX = input.deltaX - last.deltaX;
          var deltaY = input.deltaY - last.deltaY;

          var v = getVelocity(deltaTime, deltaX, deltaY);
          velocityX = v.x;
          velocityY = v.y;
          velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
          direction = getDirection(deltaX, deltaY);

          session.lastInterval = input;
      } else {
          // use latest velocity info if it doesn't overtake a minimum period
          velocity = last.velocity;
          velocityX = last.velocityX;
          velocityY = last.velocityY;
          direction = last.direction;
      }

      input.velocity = velocity;
      input.velocityX = velocityX;
      input.velocityY = velocityY;
      input.direction = direction;
  }

  /**
   * create a simple clone from the input used for storage of firstInput and firstMultiple
   * @param {Object} input
   * @returns {Object} clonedInputData
   */
  function simpleCloneInputData(input) {
      // make a simple copy of the pointers because we will get a reference if we don't
      // we only need clientXY for the calculations
      var pointers = [];
      var i = 0;
      while (i < input.pointers.length) {
          pointers[i] = {
              clientX: round(input.pointers[i].clientX),
              clientY: round(input.pointers[i].clientY)
          };
          i++;
      }

      return {
          timeStamp: now(),
          pointers: pointers,
          center: getCenter(pointers),
          deltaX: input.deltaX,
          deltaY: input.deltaY
      };
  }

  /**
   * get the center of all the pointers
   * @param {Array} pointers
   * @return {Object} center contains `x` and `y` properties
   */
  function getCenter(pointers) {
      var pointersLength = pointers.length;

      // no need to loop when only one touch
      if (pointersLength === 1) {
          return {
              x: round(pointers[0].clientX),
              y: round(pointers[0].clientY)
          };
      }

      var x = 0, y = 0, i = 0;
      while (i < pointersLength) {
          x += pointers[i].clientX;
          y += pointers[i].clientY;
          i++;
      }

      return {
          x: round(x / pointersLength),
          y: round(y / pointersLength)
      };
  }

  /**
   * calculate the velocity between two points. unit is in px per ms.
   * @param {Number} deltaTime
   * @param {Number} x
   * @param {Number} y
   * @return {Object} velocity `x` and `y`
   */
  function getVelocity(deltaTime, x, y) {
      return {
          x: x / deltaTime || 0,
          y: y / deltaTime || 0
      };
  }

  /**
   * get the direction between two points
   * @param {Number} x
   * @param {Number} y
   * @return {Number} direction
   */
  function getDirection(x, y) {
      if (x === y) {
          return DIRECTION_NONE;
      }

      if (abs(x) >= abs(y)) {
          return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
      }
      return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
  }

  /**
   * calculate the absolute distance between two points
   * @param {Object} p1 {x, y}
   * @param {Object} p2 {x, y}
   * @param {Array} [props] containing x and y keys
   * @return {Number} distance
   */
  function getDistance(p1, p2, props) {
      if (!props) {
          props = PROPS_XY;
      }
      var x = p2[props[0]] - p1[props[0]],
          y = p2[props[1]] - p1[props[1]];

      return Math.sqrt((x * x) + (y * y));
  }

  /**
   * calculate the angle between two coordinates
   * @param {Object} p1
   * @param {Object} p2
   * @param {Array} [props] containing x and y keys
   * @return {Number} angle
   */
  function getAngle(p1, p2, props) {
      if (!props) {
          props = PROPS_XY;
      }
      var x = p2[props[0]] - p1[props[0]],
          y = p2[props[1]] - p1[props[1]];
      return Math.atan2(y, x) * 180 / Math.PI;
  }

  /**
   * calculate the rotation degrees between two pointersets
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} rotation
   */
  function getRotation(start, end) {
      return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
  }

  /**
   * calculate the scale factor between two pointersets
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} scale
   */
  function getScale(start, end) {
      return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
  }

  var MOUSE_INPUT_MAP = {
      mousedown: INPUT_START,
      mousemove: INPUT_MOVE,
      mouseup: INPUT_END
  };

  var MOUSE_ELEMENT_EVENTS = 'mousedown';
  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

  /**
   * Mouse events input
   * @constructor
   * @extends Input
   */
  function MouseInput() {
      this.evEl = MOUSE_ELEMENT_EVENTS;
      this.evWin = MOUSE_WINDOW_EVENTS;

      this.pressed = false; // mousedown state

      Input.apply(this, arguments);
  }

  inherit(MouseInput, Input, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function MEhandler(ev) {
          var eventType = MOUSE_INPUT_MAP[ev.type];

          // on start we want to have the left mouse button down
          if (eventType & INPUT_START && ev.button === 0) {
              this.pressed = true;
          }

          if (eventType & INPUT_MOVE && ev.which !== 1) {
              eventType = INPUT_END;
          }

          // mouse must be down
          if (!this.pressed) {
              return;
          }

          if (eventType & INPUT_END) {
              this.pressed = false;
          }

          this.callback(this.manager, eventType, {
              pointers: [ev],
              changedPointers: [ev],
              pointerType: INPUT_TYPE_MOUSE,
              srcEvent: ev
          });
      }
  });

  var POINTER_INPUT_MAP = {
      pointerdown: INPUT_START,
      pointermove: INPUT_MOVE,
      pointerup: INPUT_END,
      pointercancel: INPUT_CANCEL,
      pointerout: INPUT_CANCEL
  };

  // in IE10 the pointer types is defined as an enum
  var IE10_POINTER_TYPE_ENUM = {
      2: INPUT_TYPE_TOUCH,
      3: INPUT_TYPE_PEN,
      4: INPUT_TYPE_MOUSE,
      5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
  };

  var POINTER_ELEMENT_EVENTS = 'pointerdown';
  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

  // IE10 has prefixed support, and case-sensitive
  if (window.MSPointerEvent && !window.PointerEvent) {
      POINTER_ELEMENT_EVENTS = 'MSPointerDown';
      POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
  }

  /**
   * Pointer events input
   * @constructor
   * @extends Input
   */
  function PointerEventInput() {
      this.evEl = POINTER_ELEMENT_EVENTS;
      this.evWin = POINTER_WINDOW_EVENTS;

      Input.apply(this, arguments);

      this.store = (this.manager.session.pointerEvents = []);
  }

  inherit(PointerEventInput, Input, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function PEhandler(ev) {
          var store = this.store;
          var removePointer = false;

          var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
          var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
          var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

          var isTouch = (pointerType == INPUT_TYPE_TOUCH);

          // get index of the event in the store
          var storeIndex = inArray(store, ev.pointerId, 'pointerId');

          // start and mouse must be down
          if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
              if (storeIndex < 0) {
                  store.push(ev);
                  storeIndex = store.length - 1;
              }
          } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
              removePointer = true;
          }

          // it not found, so the pointer hasn't been down (so it's probably a hover)
          if (storeIndex < 0) {
              return;
          }

          // update the event in the store
          store[storeIndex] = ev;

          this.callback(this.manager, eventType, {
              pointers: store,
              changedPointers: [ev],
              pointerType: pointerType,
              srcEvent: ev
          });

          if (removePointer) {
              // remove from the store
              store.splice(storeIndex, 1);
          }
      }
  });

  var SINGLE_TOUCH_INPUT_MAP = {
      touchstart: INPUT_START,
      touchmove: INPUT_MOVE,
      touchend: INPUT_END,
      touchcancel: INPUT_CANCEL
  };

  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

  /**
   * Touch events input
   * @constructor
   * @extends Input
   */
  function SingleTouchInput() {
      this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
      this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
      this.started = false;

      Input.apply(this, arguments);
  }

  inherit(SingleTouchInput, Input, {
      handler: function TEhandler(ev) {
          var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

          // should we handle the touch events?
          if (type === INPUT_START) {
              this.started = true;
          }

          if (!this.started) {
              return;
          }

          var touches = normalizeSingleTouches.call(this, ev, type);

          // when done, reset the started state
          if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
              this.started = false;
          }

          this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
          });
      }
  });

  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */
  function normalizeSingleTouches(ev, type) {
      var all = toArray(ev.touches);
      var changed = toArray(ev.changedTouches);

      if (type & (INPUT_END | INPUT_CANCEL)) {
          all = uniqueArray(all.concat(changed), 'identifier', true);
      }

      return [all, changed];
  }

  var TOUCH_INPUT_MAP = {
      touchstart: INPUT_START,
      touchmove: INPUT_MOVE,
      touchend: INPUT_END,
      touchcancel: INPUT_CANCEL
  };

  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

  /**
   * Multi-user touch events input
   * @constructor
   * @extends Input
   */
  function TouchInput() {
      this.evTarget = TOUCH_TARGET_EVENTS;
      this.targetIds = {};

      Input.apply(this, arguments);
  }

  inherit(TouchInput, Input, {
      handler: function MTEhandler(ev) {
          var type = TOUCH_INPUT_MAP[ev.type];
          var touches = getTouches.call(this, ev, type);
          if (!touches) {
              return;
          }

          this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
          });
      }
  });

  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */
  function getTouches(ev, type) {
      var allTouches = toArray(ev.touches);
      var targetIds = this.targetIds;

      // when there is only one touch, the process can be simplified
      if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
          targetIds[allTouches[0].identifier] = true;
          return [allTouches, allTouches];
      }

      var i,
          targetTouches,
          changedTouches = toArray(ev.changedTouches),
          changedTargetTouches = [],
          target = this.target;

      // get target touches from touches
      targetTouches = allTouches.filter(function(touch) {
          return hasParent(touch.target, target);
      });

      // collect touches
      if (type === INPUT_START) {
          i = 0;
          while (i < targetTouches.length) {
              targetIds[targetTouches[i].identifier] = true;
              i++;
          }
      }

      // filter changed touches to only contain touches that exist in the collected target ids
      i = 0;
      while (i < changedTouches.length) {
          if (targetIds[changedTouches[i].identifier]) {
              changedTargetTouches.push(changedTouches[i]);
          }

          // cleanup removed touches
          if (type & (INPUT_END | INPUT_CANCEL)) {
              delete targetIds[changedTouches[i].identifier];
          }
          i++;
      }

      if (!changedTargetTouches.length) {
          return;
      }

      return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
          changedTargetTouches
      ];
  }

  /**
   * Combined touch and mouse input
   *
   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
   * This because touch devices also emit mouse events while doing a touch.
   *
   * @constructor
   * @extends Input
   */

  var DEDUP_TIMEOUT = 2500;
  var DEDUP_DISTANCE = 25;

  function TouchMouseInput() {
      Input.apply(this, arguments);

      var handler = bindFn(this.handler, this);
      this.touch = new TouchInput(this.manager, handler);
      this.mouse = new MouseInput(this.manager, handler);

      this.primaryTouch = null;
      this.lastTouches = [];
  }

  inherit(TouchMouseInput, Input, {
      /**
       * handle mouse and touch events
       * @param {Hammer} manager
       * @param {String} inputEvent
       * @param {Object} inputData
       */
      handler: function TMEhandler(manager, inputEvent, inputData) {
          var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
              isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

          if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
              return;
          }

          // when we're in a touch event, record touches to  de-dupe synthetic mouse event
          if (isTouch) {
              recordTouches.call(this, inputEvent, inputData);
          } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
              return;
          }

          this.callback(manager, inputEvent, inputData);
      },

      /**
       * remove the event listeners
       */
      destroy: function destroy() {
          this.touch.destroy();
          this.mouse.destroy();
      }
  });

  function recordTouches(eventType, eventData) {
      if (eventType & INPUT_START) {
          this.primaryTouch = eventData.changedPointers[0].identifier;
          setLastTouch.call(this, eventData);
      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
          setLastTouch.call(this, eventData);
      }
  }

  function setLastTouch(eventData) {
      var touch = eventData.changedPointers[0];

      if (touch.identifier === this.primaryTouch) {
          var lastTouch = {x: touch.clientX, y: touch.clientY};
          this.lastTouches.push(lastTouch);
          var lts = this.lastTouches;
          var removeLastTouch = function() {
              var i = lts.indexOf(lastTouch);
              if (i > -1) {
                  lts.splice(i, 1);
              }
          };
          setTimeout(removeLastTouch, DEDUP_TIMEOUT);
      }
  }

  function isSyntheticEvent(eventData) {
      var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
      for (var i = 0; i < this.lastTouches.length; i++) {
          var t = this.lastTouches[i];
          var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
          if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
              return true;
          }
      }
      return false;
  }

  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

  // magical touchAction value
  var TOUCH_ACTION_COMPUTE = 'compute';
  var TOUCH_ACTION_AUTO = 'auto';
  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
  var TOUCH_ACTION_NONE = 'none';
  var TOUCH_ACTION_PAN_X = 'pan-x';
  var TOUCH_ACTION_PAN_Y = 'pan-y';
  var TOUCH_ACTION_MAP = getTouchActionProps();

  /**
   * Touch Action
   * sets the touchAction property or uses the js alternative
   * @param {Manager} manager
   * @param {String} value
   * @constructor
   */
  function TouchAction(manager, value) {
      this.manager = manager;
      this.set(value);
  }

  TouchAction.prototype = {
      /**
       * set the touchAction value on the element or enable the polyfill
       * @param {String} value
       */
      set: function(value) {
          // find out the touch-action by the event handlers
          if (value == TOUCH_ACTION_COMPUTE) {
              value = this.compute();
          }

          if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
              this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
          }
          this.actions = value.toLowerCase().trim();
      },

      /**
       * just re-set the touchAction value
       */
      update: function() {
          this.set(this.manager.options.touchAction);
      },

      /**
       * compute the value for the touchAction property based on the recognizer's settings
       * @returns {String} value
       */
      compute: function() {
          var actions = [];
          each(this.manager.recognizers, function(recognizer) {
              if (boolOrFn(recognizer.options.enable, [recognizer])) {
                  actions = actions.concat(recognizer.getTouchAction());
              }
          });
          return cleanTouchActions(actions.join(' '));
      },

      /**
       * this method is called on each input cycle and provides the preventing of the browser behavior
       * @param {Object} input
       */
      preventDefaults: function(input) {
          var srcEvent = input.srcEvent;
          var direction = input.offsetDirection;

          // if the touch action did prevented once this session
          if (this.manager.session.prevented) {
              srcEvent.preventDefault();
              return;
          }

          var actions = this.actions;
          var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

          if (hasNone) {
              //do not prevent defaults if this is a tap gesture

              var isTapPointer = input.pointers.length === 1;
              var isTapMovement = input.distance < 2;
              var isTapTouchTime = input.deltaTime < 250;

              if (isTapPointer && isTapMovement && isTapTouchTime) {
                  return;
              }
          }

          if (hasPanX && hasPanY) {
              // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
              return;
          }

          if (hasNone ||
              (hasPanY && direction & DIRECTION_HORIZONTAL) ||
              (hasPanX && direction & DIRECTION_VERTICAL)) {
              return this.preventSrc(srcEvent);
          }
      },

      /**
       * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
       * @param {Object} srcEvent
       */
      preventSrc: function(srcEvent) {
          this.manager.session.prevented = true;
          srcEvent.preventDefault();
      }
  };

  /**
   * when the touchActions are collected they are not a valid value, so we need to clean things up. *
   * @param {String} actions
   * @returns {*}
   */
  function cleanTouchActions(actions) {
      // none
      if (inStr(actions, TOUCH_ACTION_NONE)) {
          return TOUCH_ACTION_NONE;
      }

      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

      // if both pan-x and pan-y are set (different recognizers
      // for different directions, e.g. horizontal pan but vertical swipe?)
      // we need none (as otherwise with pan-x pan-y combined none of these
      // recognizers will work, since the browser would handle all panning
      if (hasPanX && hasPanY) {
          return TOUCH_ACTION_NONE;
      }

      // pan-x OR pan-y
      if (hasPanX || hasPanY) {
          return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
      }

      // manipulation
      if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
          return TOUCH_ACTION_MANIPULATION;
      }

      return TOUCH_ACTION_AUTO;
  }

  function getTouchActionProps() {
      if (!NATIVE_TOUCH_ACTION) {
          return false;
      }
      var touchMap = {};
      var cssSupports = window.CSS && window.CSS.supports;
      ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

          // If css.supports is not supported but there is native touch-action assume it supports
          // all values. This is the case for IE 10 and 11.
          touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
      });
      return touchMap;
  }

  /**
   * Recognizer flow explained; *
   * All recognizers have the initial state of POSSIBLE when a input session starts.
   * The definition of a input session is from the first input until the last input, with all it's movement in it. *
   * Example session for mouse-input: mousedown -> mousemove -> mouseup
   *
   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
   * which determines with state it should be.
   *
   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
   * POSSIBLE to give it another change on the next cycle.
   *
   *               Possible
   *                  |
   *            +-----+---------------+
   *            |                     |
   *      +-----+-----+               |
   *      |           |               |
   *   Failed      Cancelled          |
   *                          +-------+------+
   *                          |              |
   *                      Recognized       Began
   *                                         |
   *                                      Changed
   *                                         |
   *                                  Ended/Recognized
   */
  var STATE_POSSIBLE = 1;
  var STATE_BEGAN = 2;
  var STATE_CHANGED = 4;
  var STATE_ENDED = 8;
  var STATE_RECOGNIZED = STATE_ENDED;
  var STATE_CANCELLED = 16;
  var STATE_FAILED = 32;

  /**
   * Recognizer
   * Every recognizer needs to extend from this class.
   * @constructor
   * @param {Object} options
   */
  function Recognizer(options) {
      this.options = assign({}, this.defaults, options || {});

      this.id = uniqueId();

      this.manager = null;

      // default is enable true
      this.options.enable = ifUndefined(this.options.enable, true);

      this.state = STATE_POSSIBLE;

      this.simultaneous = {};
      this.requireFail = [];
  }

  Recognizer.prototype = {
      /**
       * @virtual
       * @type {Object}
       */
      defaults: {},

      /**
       * set options
       * @param {Object} options
       * @return {Recognizer}
       */
      set: function(options) {
          assign(this.options, options);

          // also update the touchAction, in case something changed about the directions/enabled state
          this.manager && this.manager.touchAction.update();
          return this;
      },

      /**
       * recognize simultaneous with an other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      recognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
              return this;
          }

          var simultaneous = this.simultaneous;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (!simultaneous[otherRecognizer.id]) {
              simultaneous[otherRecognizer.id] = otherRecognizer;
              otherRecognizer.recognizeWith(this);
          }
          return this;
      },

      /**
       * drop the simultaneous link. it doesnt remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRecognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
              return this;
          }

          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          delete this.simultaneous[otherRecognizer.id];
          return this;
      },

      /**
       * recognizer can only run when an other is failing
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      requireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
              return this;
          }

          var requireFail = this.requireFail;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (inArray(requireFail, otherRecognizer) === -1) {
              requireFail.push(otherRecognizer);
              otherRecognizer.requireFailure(this);
          }
          return this;
      },

      /**
       * drop the requireFailure link. it does not remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRequireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
              return this;
          }

          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          var index = inArray(this.requireFail, otherRecognizer);
          if (index > -1) {
              this.requireFail.splice(index, 1);
          }
          return this;
      },

      /**
       * has require failures boolean
       * @returns {boolean}
       */
      hasRequireFailures: function() {
          return this.requireFail.length > 0;
      },

      /**
       * if the recognizer can recognize simultaneous with an other recognizer
       * @param {Recognizer} otherRecognizer
       * @returns {Boolean}
       */
      canRecognizeWith: function(otherRecognizer) {
          return !!this.simultaneous[otherRecognizer.id];
      },

      /**
       * You should use `tryEmit` instead of `emit` directly to check
       * that all the needed recognizers has failed before emitting.
       * @param {Object} input
       */
      emit: function(input) {
          var self = this;
          var state = this.state;

          function emit(event) {
              self.manager.emit(event, input);
          }

          // 'panstart' and 'panmove'
          if (state < STATE_ENDED) {
              emit(self.options.event + stateStr(state));
          }

          emit(self.options.event); // simple 'eventName' events

          if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
              emit(input.additionalEvent);
          }

          // panend and pancancel
          if (state >= STATE_ENDED) {
              emit(self.options.event + stateStr(state));
          }
      },

      /**
       * Check that all the require failure recognizers has failed,
       * if true, it emits a gesture event,
       * otherwise, setup the state to FAILED.
       * @param {Object} input
       */
      tryEmit: function(input) {
          if (this.canEmit()) {
              return this.emit(input);
          }
          // it's failing anyway
          this.state = STATE_FAILED;
      },

      /**
       * can we emit?
       * @returns {boolean}
       */
      canEmit: function() {
          var i = 0;
          while (i < this.requireFail.length) {
              if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                  return false;
              }
              i++;
          }
          return true;
      },

      /**
       * update the recognizer
       * @param {Object} inputData
       */
      recognize: function(inputData) {
          // make a new copy of the inputData
          // so we can change the inputData without messing up the other recognizers
          var inputDataClone = assign({}, inputData);

          // is is enabled and allow recognizing?
          if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
              this.reset();
              this.state = STATE_FAILED;
              return;
          }

          // reset when we've reached the end
          if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
              this.state = STATE_POSSIBLE;
          }

          this.state = this.process(inputDataClone);

          // the recognizer has recognized a gesture
          // so trigger an event
          if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
              this.tryEmit(inputDataClone);
          }
      },

      /**
       * return the state of the recognizer
       * the actual recognizing happens in this method
       * @virtual
       * @param {Object} inputData
       * @returns {Const} STATE
       */
      process: function(inputData) { }, // jshint ignore:line

      /**
       * return the preferred touch-action
       * @virtual
       * @returns {Array}
       */
      getTouchAction: function() { },

      /**
       * called when the gesture isn't allowed to recognize
       * like when another is being recognized or it is disabled
       * @virtual
       */
      reset: function() { }
  };

  /**
   * get a usable string, used as event postfix
   * @param {Const} state
   * @returns {String} state
   */
  function stateStr(state) {
      if (state & STATE_CANCELLED) {
          return 'cancel';
      } else if (state & STATE_ENDED) {
          return 'end';
      } else if (state & STATE_CHANGED) {
          return 'move';
      } else if (state & STATE_BEGAN) {
          return 'start';
      }
      return '';
  }

  /**
   * direction cons to string
   * @param {Const} direction
   * @returns {String}
   */
  function directionStr(direction) {
      if (direction == DIRECTION_DOWN) {
          return 'down';
      } else if (direction == DIRECTION_UP) {
          return 'up';
      } else if (direction == DIRECTION_LEFT) {
          return 'left';
      } else if (direction == DIRECTION_RIGHT) {
          return 'right';
      }
      return '';
  }

  /**
   * get a recognizer by name if it is bound to a manager
   * @param {Recognizer|String} otherRecognizer
   * @param {Recognizer} recognizer
   * @returns {Recognizer}
   */
  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
      var manager = recognizer.manager;
      if (manager) {
          return manager.get(otherRecognizer);
      }
      return otherRecognizer;
  }

  /**
   * This recognizer is just used as a base for the simple attribute recognizers.
   * @constructor
   * @extends Recognizer
   */
  function AttrRecognizer() {
      Recognizer.apply(this, arguments);
  }

  inherit(AttrRecognizer, Recognizer, {
      /**
       * @namespace
       * @memberof AttrRecognizer
       */
      defaults: {
          /**
           * @type {Number}
           * @default 1
           */
          pointers: 1
      },

      /**
       * Used to check if it the recognizer receives valid input, like input.distance > 10.
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {Boolean} recognized
       */
      attrTest: function(input) {
          var optionPointers = this.options.pointers;
          return optionPointers === 0 || input.pointers.length === optionPointers;
      },

      /**
       * Process the input and return the state for the recognizer
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {*} State
       */
      process: function(input) {
          var state = this.state;
          var eventType = input.eventType;

          var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
          var isValid = this.attrTest(input);

          // on cancel input and we've recognized before, return STATE_CANCELLED
          if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
              return state | STATE_CANCELLED;
          } else if (isRecognized || isValid) {
              if (eventType & INPUT_END) {
                  return state | STATE_ENDED;
              } else if (!(state & STATE_BEGAN)) {
                  return STATE_BEGAN;
              }
              return state | STATE_CHANGED;
          }
          return STATE_FAILED;
      }
  });

  /**
   * Pan
   * Recognized when the pointer is down and moved in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */
  function PanRecognizer() {
      AttrRecognizer.apply(this, arguments);

      this.pX = null;
      this.pY = null;
  }

  inherit(PanRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof PanRecognizer
       */
      defaults: {
          event: 'pan',
          threshold: 10,
          pointers: 1,
          direction: DIRECTION_ALL
      },

      getTouchAction: function() {
          var direction = this.options.direction;
          var actions = [];
          if (direction & DIRECTION_HORIZONTAL) {
              actions.push(TOUCH_ACTION_PAN_Y);
          }
          if (direction & DIRECTION_VERTICAL) {
              actions.push(TOUCH_ACTION_PAN_X);
          }
          return actions;
      },

      directionTest: function(input) {
          var options = this.options;
          var hasMoved = true;
          var distance = input.distance;
          var direction = input.direction;
          var x = input.deltaX;
          var y = input.deltaY;

          // lock to axis?
          if (!(direction & options.direction)) {
              if (options.direction & DIRECTION_HORIZONTAL) {
                  direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                  hasMoved = x != this.pX;
                  distance = Math.abs(input.deltaX);
              } else {
                  direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                  hasMoved = y != this.pY;
                  distance = Math.abs(input.deltaY);
              }
          }
          input.direction = direction;
          return hasMoved && distance > options.threshold && direction & options.direction;
      },

      attrTest: function(input) {
          return AttrRecognizer.prototype.attrTest.call(this, input) &&
              (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
      },

      emit: function(input) {

          this.pX = input.deltaX;
          this.pY = input.deltaY;

          var direction = directionStr(input.direction);

          if (direction) {
              input.additionalEvent = this.options.event + direction;
          }
          this._super.emit.call(this, input);
      }
  });

  /**
   * Pinch
   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
   * @constructor
   * @extends AttrRecognizer
   */
  function PinchRecognizer() {
      AttrRecognizer.apply(this, arguments);
  }

  inherit(PinchRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
          event: 'pinch',
          threshold: 0,
          pointers: 2
      },

      getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
      },

      attrTest: function(input) {
          return this._super.attrTest.call(this, input) &&
              (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
      },

      emit: function(input) {
          if (input.scale !== 1) {
              var inOut = input.scale < 1 ? 'in' : 'out';
              input.additionalEvent = this.options.event + inOut;
          }
          this._super.emit.call(this, input);
      }
  });

  /**
   * Press
   * Recognized when the pointer is down for x ms without any movement.
   * @constructor
   * @extends Recognizer
   */
  function PressRecognizer() {
      Recognizer.apply(this, arguments);

      this._timer = null;
      this._input = null;
  }

  inherit(PressRecognizer, Recognizer, {
      /**
       * @namespace
       * @memberof PressRecognizer
       */
      defaults: {
          event: 'press',
          pointers: 1,
          time: 251, // minimal time of the pointer to be pressed
          threshold: 9 // a minimal movement is ok, but keep it low
      },

      getTouchAction: function() {
          return [TOUCH_ACTION_AUTO];
      },

      process: function(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTime = input.deltaTime > options.time;

          this._input = input;

          // we only allow little movement
          // and we've reached an end event, so a tap is possible
          if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
              this.reset();
          } else if (input.eventType & INPUT_START) {
              this.reset();
              this._timer = setTimeoutContext(function() {
                  this.state = STATE_RECOGNIZED;
                  this.tryEmit();
              }, options.time, this);
          } else if (input.eventType & INPUT_END) {
              return STATE_RECOGNIZED;
          }
          return STATE_FAILED;
      },

      reset: function() {
          clearTimeout(this._timer);
      },

      emit: function(input) {
          if (this.state !== STATE_RECOGNIZED) {
              return;
          }

          if (input && (input.eventType & INPUT_END)) {
              this.manager.emit(this.options.event + 'up', input);
          } else {
              this._input.timeStamp = now();
              this.manager.emit(this.options.event, this._input);
          }
      }
  });

  /**
   * Rotate
   * Recognized when two or more pointer are moving in a circular motion.
   * @constructor
   * @extends AttrRecognizer
   */
  function RotateRecognizer() {
      AttrRecognizer.apply(this, arguments);
  }

  inherit(RotateRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof RotateRecognizer
       */
      defaults: {
          event: 'rotate',
          threshold: 0,
          pointers: 2
      },

      getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
      },

      attrTest: function(input) {
          return this._super.attrTest.call(this, input) &&
              (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
      }
  });

  /**
   * Swipe
   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */
  function SwipeRecognizer() {
      AttrRecognizer.apply(this, arguments);
  }

  inherit(SwipeRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof SwipeRecognizer
       */
      defaults: {
          event: 'swipe',
          threshold: 10,
          velocity: 0.3,
          direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
          pointers: 1
      },

      getTouchAction: function() {
          return PanRecognizer.prototype.getTouchAction.call(this);
      },

      attrTest: function(input) {
          var direction = this.options.direction;
          var velocity;

          if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
              velocity = input.overallVelocity;
          } else if (direction & DIRECTION_HORIZONTAL) {
              velocity = input.overallVelocityX;
          } else if (direction & DIRECTION_VERTICAL) {
              velocity = input.overallVelocityY;
          }

          return this._super.attrTest.call(this, input) &&
              direction & input.offsetDirection &&
              input.distance > this.options.threshold &&
              input.maxPointers == this.options.pointers &&
              abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
      },

      emit: function(input) {
          var direction = directionStr(input.offsetDirection);
          if (direction) {
              this.manager.emit(this.options.event + direction, input);
          }

          this.manager.emit(this.options.event, input);
      }
  });

  /**
   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
   * between the given interval and position. The delay option can be used to recognize multi-taps without firing
   * a single tap.
   *
   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
   * multi-taps being recognized.
   * @constructor
   * @extends Recognizer
   */
  function TapRecognizer() {
      Recognizer.apply(this, arguments);

      // previous time and center,
      // used for tap counting
      this.pTime = false;
      this.pCenter = false;

      this._timer = null;
      this._input = null;
      this.count = 0;
  }

  inherit(TapRecognizer, Recognizer, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
          event: 'tap',
          pointers: 1,
          taps: 1,
          interval: 300, // max time between the multi-tap taps
          time: 250, // max time of the pointer to be down (like finger on the screen)
          threshold: 9, // a minimal movement is ok, but keep it low
          posThreshold: 10 // a multi-tap can be a bit off the initial position
      },

      getTouchAction: function() {
          return [TOUCH_ACTION_MANIPULATION];
      },

      process: function(input) {
          var options = this.options;

          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTouchTime = input.deltaTime < options.time;

          this.reset();

          if ((input.eventType & INPUT_START) && (this.count === 0)) {
              return this.failTimeout();
          }

          // we only allow little movement
          // and we've reached an end event, so a tap is possible
          if (validMovement && validTouchTime && validPointers) {
              if (input.eventType != INPUT_END) {
                  return this.failTimeout();
              }

              var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
              var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

              this.pTime = input.timeStamp;
              this.pCenter = input.center;

              if (!validMultiTap || !validInterval) {
                  this.count = 1;
              } else {
                  this.count += 1;
              }

              this._input = input;

              // if tap count matches we have recognized it,
              // else it has began recognizing...
              var tapCount = this.count % options.taps;
              if (tapCount === 0) {
                  // no failing requirements, immediately trigger the tap event
                  // or wait as long as the multitap interval to trigger
                  if (!this.hasRequireFailures()) {
                      return STATE_RECOGNIZED;
                  } else {
                      this._timer = setTimeoutContext(function() {
                          this.state = STATE_RECOGNIZED;
                          this.tryEmit();
                      }, options.interval, this);
                      return STATE_BEGAN;
                  }
              }
          }
          return STATE_FAILED;
      },

      failTimeout: function() {
          this._timer = setTimeoutContext(function() {
              this.state = STATE_FAILED;
          }, this.options.interval, this);
          return STATE_FAILED;
      },

      reset: function() {
          clearTimeout(this._timer);
      },

      emit: function() {
          if (this.state == STATE_RECOGNIZED) {
              this._input.tapCount = this.count;
              this.manager.emit(this.options.event, this._input);
          }
      }
  });

  /**
   * Simple way to create a manager with a default set of recognizers.
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */
  function Hammer(element, options) {
      options = options || {};
      options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
      return new Manager(element, options);
  }

  /**
   * @const {string}
   */
  Hammer.VERSION = '2.0.7';

  /**
   * default settings
   * @namespace
   */
  Hammer.defaults = {
      /**
       * set if DOM events are being triggered.
       * But this is slower and unused by simple implementations, so disabled by default.
       * @type {Boolean}
       * @default false
       */
      domEvents: false,

      /**
       * The value for the touchAction property/fallback.
       * When set to `compute` it will magically set the correct value based on the added recognizers.
       * @type {String}
       * @default compute
       */
      touchAction: TOUCH_ACTION_COMPUTE,

      /**
       * @type {Boolean}
       * @default true
       */
      enable: true,

      /**
       * EXPERIMENTAL FEATURE -- can be removed/changed
       * Change the parent input target element.
       * If Null, then it is being set the to main element.
       * @type {Null|EventTarget}
       * @default null
       */
      inputTarget: null,

      /**
       * force an input class
       * @type {Null|Function}
       * @default null
       */
      inputClass: null,

      /**
       * Default recognizer setup when calling `Hammer()`
       * When creating a new Manager these will be skipped.
       * @type {Array}
       */
      preset: [
          // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
          [RotateRecognizer, {enable: false}],
          [PinchRecognizer, {enable: false}, ['rotate']],
          [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
          [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
          [TapRecognizer],
          [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
          [PressRecognizer]
      ],

      /**
       * Some CSS properties can be used to improve the working of Hammer.
       * Add them to this method and they will be set when creating a new Manager.
       * @namespace
       */
      cssProps: {
          /**
           * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userSelect: 'none',

          /**
           * Disable the Windows Phone grippers when pressing an element.
           * @type {String}
           * @default 'none'
           */
          touchSelect: 'none',

          /**
           * Disables the default callout shown when you touch and hold a touch target.
           * On iOS, when you touch and hold a touch target such as a link, Safari displays
           * a callout containing information about the link. This property allows you to disable that callout.
           * @type {String}
           * @default 'none'
           */
          touchCallout: 'none',

          /**
           * Specifies whether zooming is enabled. Used by IE10>
           * @type {String}
           * @default 'none'
           */
          contentZooming: 'none',

          /**
           * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userDrag: 'none',

          /**
           * Overrides the highlight color shown when the user taps a link or a JavaScript
           * clickable element in iOS. This property obeys the alpha value, if specified.
           * @type {String}
           * @default 'rgba(0,0,0,0)'
           */
          tapHighlightColor: 'rgba(0,0,0,0)'
      }
  };

  var STOP = 1;
  var FORCED_STOP = 2;

  /**
   * Manager
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */
  function Manager(element, options) {
      this.options = assign({}, Hammer.defaults, options || {});

      this.options.inputTarget = this.options.inputTarget || element;

      this.handlers = {};
      this.session = {};
      this.recognizers = [];
      this.oldCssProps = {};

      this.element = element;
      this.input = createInputInstance(this);
      this.touchAction = new TouchAction(this, this.options.touchAction);

      toggleCssProps(this, true);

      each(this.options.recognizers, function(item) {
          var recognizer = this.add(new (item[0])(item[1]));
          item[2] && recognizer.recognizeWith(item[2]);
          item[3] && recognizer.requireFailure(item[3]);
      }, this);
  }

  Manager.prototype = {
      /**
       * set options
       * @param {Object} options
       * @returns {Manager}
       */
      set: function(options) {
          assign(this.options, options);

          // Options that need a little more setup
          if (options.touchAction) {
              this.touchAction.update();
          }
          if (options.inputTarget) {
              // Clean up existing event listeners and reinitialize
              this.input.destroy();
              this.input.target = options.inputTarget;
              this.input.init();
          }
          return this;
      },

      /**
       * stop recognizing for this session.
       * This session will be discarded, when a new [input]start event is fired.
       * When forced, the recognizer cycle is stopped immediately.
       * @param {Boolean} [force]
       */
      stop: function(force) {
          this.session.stopped = force ? FORCED_STOP : STOP;
      },

      /**
       * run the recognizers!
       * called by the inputHandler function on every movement of the pointers (touches)
       * it walks through all the recognizers and tries to detect the gesture that is being made
       * @param {Object} inputData
       */
      recognize: function(inputData) {
          var session = this.session;
          if (session.stopped) {
              return;
          }

          // run the touch-action polyfill
          this.touchAction.preventDefaults(inputData);

          var recognizer;
          var recognizers = this.recognizers;

          // this holds the recognizer that is being recognized.
          // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
          // if no recognizer is detecting a thing, it is set to `null`
          var curRecognizer = session.curRecognizer;

          // reset when the last recognizer is recognized
          // or when we're in a new session
          if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
              curRecognizer = session.curRecognizer = null;
          }

          var i = 0;
          while (i < recognizers.length) {
              recognizer = recognizers[i];

              // find out if we are allowed try to recognize the input for this one.
              // 1.   allow if the session is NOT forced stopped (see the .stop() method)
              // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
              //      that is being recognized.
              // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
              //      this can be setup with the `recognizeWith()` method on the recognizer.
              if (session.stopped !== FORCED_STOP && ( // 1
                      !curRecognizer || recognizer == curRecognizer || // 2
                      recognizer.canRecognizeWith(curRecognizer))) { // 3
                  recognizer.recognize(inputData);
              } else {
                  recognizer.reset();
              }

              // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
              // current active recognizer. but only if we don't already have an active recognizer
              if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                  curRecognizer = session.curRecognizer = recognizer;
              }
              i++;
          }
      },

      /**
       * get a recognizer by its event name.
       * @param {Recognizer|String} recognizer
       * @returns {Recognizer|Null}
       */
      get: function(recognizer) {
          if (recognizer instanceof Recognizer) {
              return recognizer;
          }

          var recognizers = this.recognizers;
          for (var i = 0; i < recognizers.length; i++) {
              if (recognizers[i].options.event == recognizer) {
                  return recognizers[i];
              }
          }
          return null;
      },

      /**
       * add a recognizer to the manager
       * existing recognizers with the same event name will be removed
       * @param {Recognizer} recognizer
       * @returns {Recognizer|Manager}
       */
      add: function(recognizer) {
          if (invokeArrayArg(recognizer, 'add', this)) {
              return this;
          }

          // remove existing
          var existing = this.get(recognizer.options.event);
          if (existing) {
              this.remove(existing);
          }

          this.recognizers.push(recognizer);
          recognizer.manager = this;

          this.touchAction.update();
          return recognizer;
      },

      /**
       * remove a recognizer by name or instance
       * @param {Recognizer|String} recognizer
       * @returns {Manager}
       */
      remove: function(recognizer) {
          if (invokeArrayArg(recognizer, 'remove', this)) {
              return this;
          }

          recognizer = this.get(recognizer);

          // let's make sure this recognizer exists
          if (recognizer) {
              var recognizers = this.recognizers;
              var index = inArray(recognizers, recognizer);

              if (index !== -1) {
                  recognizers.splice(index, 1);
                  this.touchAction.update();
              }
          }

          return this;
      },

      /**
       * bind event
       * @param {String} events
       * @param {Function} handler
       * @returns {EventEmitter} this
       */
      on: function(events, handler) {
          if (events === undefined) {
              return;
          }
          if (handler === undefined) {
              return;
          }

          var handlers = this.handlers;
          each(splitStr(events), function(event) {
              handlers[event] = handlers[event] || [];
              handlers[event].push(handler);
          });
          return this;
      },

      /**
       * unbind event, leave emit blank to remove all handlers
       * @param {String} events
       * @param {Function} [handler]
       * @returns {EventEmitter} this
       */
      off: function(events, handler) {
          if (events === undefined) {
              return;
          }

          var handlers = this.handlers;
          each(splitStr(events), function(event) {
              if (!handler) {
                  delete handlers[event];
              } else {
                  handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
              }
          });
          return this;
      },

      /**
       * emit event to the listeners
       * @param {String} event
       * @param {Object} data
       */
      emit: function(event, data) {
          // we also want to trigger dom events
          if (this.options.domEvents) {
              triggerDomEvent(event, data);
          }

          // no handlers, so skip it all
          var handlers = this.handlers[event] && this.handlers[event].slice();
          if (!handlers || !handlers.length) {
              return;
          }

          data.type = event;
          data.preventDefault = function() {
              data.srcEvent.preventDefault();
          };

          var i = 0;
          while (i < handlers.length) {
              handlers[i](data);
              i++;
          }
      },

      /**
       * destroy the manager and unbinds all events
       * it doesn't unbind dom events, that is the user own responsibility
       */
      destroy: function() {
          this.element && toggleCssProps(this, false);

          this.handlers = {};
          this.session = {};
          this.input.destroy();
          this.element = null;
      }
  };

  /**
   * add/remove the css properties as defined in manager.options.cssProps
   * @param {Manager} manager
   * @param {Boolean} add
   */
  function toggleCssProps(manager, add) {
      var element = manager.element;
      if (!element.style) {
          return;
      }
      var prop;
      each(manager.options.cssProps, function(value, name) {
          prop = prefixed(element.style, name);
          if (add) {
              manager.oldCssProps[prop] = element.style[prop];
              element.style[prop] = value;
          } else {
              element.style[prop] = manager.oldCssProps[prop] || '';
          }
      });
      if (!add) {
          manager.oldCssProps = {};
      }
  }

  /**
   * trigger dom event
   * @param {String} event
   * @param {Object} data
   */
  function triggerDomEvent(event, data) {
      var gestureEvent = document.createEvent('Event');
      gestureEvent.initEvent(event, true, true);
      gestureEvent.gesture = data;
      data.target.dispatchEvent(gestureEvent);
  }

  assign(Hammer, {
      INPUT_START: INPUT_START,
      INPUT_MOVE: INPUT_MOVE,
      INPUT_END: INPUT_END,
      INPUT_CANCEL: INPUT_CANCEL,

      STATE_POSSIBLE: STATE_POSSIBLE,
      STATE_BEGAN: STATE_BEGAN,
      STATE_CHANGED: STATE_CHANGED,
      STATE_ENDED: STATE_ENDED,
      STATE_RECOGNIZED: STATE_RECOGNIZED,
      STATE_CANCELLED: STATE_CANCELLED,
      STATE_FAILED: STATE_FAILED,

      DIRECTION_NONE: DIRECTION_NONE,
      DIRECTION_LEFT: DIRECTION_LEFT,
      DIRECTION_RIGHT: DIRECTION_RIGHT,
      DIRECTION_UP: DIRECTION_UP,
      DIRECTION_DOWN: DIRECTION_DOWN,
      DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
      DIRECTION_VERTICAL: DIRECTION_VERTICAL,
      DIRECTION_ALL: DIRECTION_ALL,

      Manager: Manager,
      Input: Input,
      TouchAction: TouchAction,

      TouchInput: TouchInput,
      MouseInput: MouseInput,
      PointerEventInput: PointerEventInput,
      TouchMouseInput: TouchMouseInput,
      SingleTouchInput: SingleTouchInput,

      Recognizer: Recognizer,
      AttrRecognizer: AttrRecognizer,
      Tap: TapRecognizer,
      Pan: PanRecognizer,
      Swipe: SwipeRecognizer,
      Pinch: PinchRecognizer,
      Rotate: RotateRecognizer,
      Press: PressRecognizer,

      on: addEventListeners,
      off: removeEventListeners,
      each: each,
      merge: merge,
      extend: extend,
      assign: assign,
      inherit: inherit,
      bindFn: bindFn,
      prefixed: prefixed
  });

  // this prevents errors when Hammer is loaded in the presence of an AMD
  //  style loader but by script tag, not by the loader.
  var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
  freeGlobal.Hammer = Hammer;

  if (true) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
          return Hammer;
      }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof module != 'undefined' && module.exports) {
      module.exports = Hammer;
  } else {
      window[exportName] = Hammer;
  }

  })(window, document, 'Hammer');


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
  /**
   * Created by Alex on 11/6/2014.
   */

  // https://github.com/umdjs/umd/blob/master/returnExports.js#L40-L60
  // if the module has no dependencies, the above pattern can be simplified to
  (function (root, factory) {
    if (true) {
      // AMD. Register as an anonymous module.
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports === 'object') {
      // Node. Does not work with strict CommonJS, but
      // only CommonJS-like environments that support module.exports,
      // like Node.
      module.exports = factory();
    } else {
      // Browser globals (root is window)
      root.keycharm = factory();
    }
  }(this, function () {

    function keycharm(options) {
      var preventDefault = options && options.preventDefault || false;

      var container = options && options.container || window;

      var _exportFunctions = {};
      var _bound = {keydown:{}, keyup:{}};
      var _keys = {};
      var i;

      // a - z
      for (i = 97; i <= 122; i++) {_keys[String.fromCharCode(i)] = {code:65 + (i - 97), shift: false};}
      // A - Z
      for (i = 65; i <= 90; i++) {_keys[String.fromCharCode(i)] = {code:i, shift: true};}
      // 0 - 9
      for (i = 0;  i <= 9;   i++) {_keys['' + i] = {code:48 + i, shift: false};}
      // F1 - F12
      for (i = 1;  i <= 12;   i++) {_keys['F' + i] = {code:111 + i, shift: false};}
      // num0 - num9
      for (i = 0;  i <= 9;   i++) {_keys['num' + i] = {code:96 + i, shift: false};}

      // numpad misc
      _keys['num*'] = {code:106, shift: false};
      _keys['num+'] = {code:107, shift: false};
      _keys['num-'] = {code:109, shift: false};
      _keys['num/'] = {code:111, shift: false};
      _keys['num.'] = {code:110, shift: false};
      // arrows
      _keys['left']  = {code:37, shift: false};
      _keys['up']    = {code:38, shift: false};
      _keys['right'] = {code:39, shift: false};
      _keys['down']  = {code:40, shift: false};
      // extra keys
      _keys['space'] = {code:32, shift: false};
      _keys['enter'] = {code:13, shift: false};
      _keys['shift'] = {code:16, shift: undefined};
      _keys['esc']   = {code:27, shift: false};
      _keys['backspace'] = {code:8, shift: false};
      _keys['tab']       = {code:9, shift: false};
      _keys['ctrl']      = {code:17, shift: false};
      _keys['alt']       = {code:18, shift: false};
      _keys['delete']    = {code:46, shift: false};
      _keys['pageup']    = {code:33, shift: false};
      _keys['pagedown']  = {code:34, shift: false};
      // symbols
      _keys['=']     = {code:187, shift: false};
      _keys['-']     = {code:189, shift: false};
      _keys[']']     = {code:221, shift: false};
      _keys['[']     = {code:219, shift: false};



      var down = function(event) {handleEvent(event,'keydown');};
      var up = function(event) {handleEvent(event,'keyup');};

      // handle the actualy bound key with the event
      var handleEvent = function(event,type) {
        if (_bound[type][event.keyCode] !== undefined) {
          var bound = _bound[type][event.keyCode];
          for (var i = 0; i < bound.length; i++) {
            if (bound[i].shift === undefined) {
              bound[i].fn(event);
            }
            else if (bound[i].shift == true && event.shiftKey == true) {
              bound[i].fn(event);
            }
            else if (bound[i].shift == false && event.shiftKey == false) {
              bound[i].fn(event);
            }
          }

          if (preventDefault == true) {
            event.preventDefault();
          }
        }
      };

      // bind a key to a callback
      _exportFunctions.bind = function(key, callback, type) {
        if (type === undefined) {
          type = 'keydown';
        }
        if (_keys[key] === undefined) {
          throw new Error("unsupported key: " + key);
        }
        if (_bound[type][_keys[key].code] === undefined) {
          _bound[type][_keys[key].code] = [];
        }
        _bound[type][_keys[key].code].push({fn:callback, shift:_keys[key].shift});
      };


      // bind all keys to a call back (demo purposes)
      _exportFunctions.bindAll = function(callback, type) {
        if (type === undefined) {
          type = 'keydown';
        }
        for (var key in _keys) {
          if (_keys.hasOwnProperty(key)) {
            _exportFunctions.bind(key,callback,type);
          }
        }
      };

      // get the key label from an event
      _exportFunctions.getKey = function(event) {
        for (var key in _keys) {
          if (_keys.hasOwnProperty(key)) {
            if (event.shiftKey == true && _keys[key].shift == true && event.keyCode == _keys[key].code) {
              return key;
            }
            else if (event.shiftKey == false && _keys[key].shift == false && event.keyCode == _keys[key].code) {
              return key;
            }
            else if (event.keyCode == _keys[key].code && key == 'shift') {
              return key;
            }
          }
        }
        return "unknown key, currently not supported";
      };

      // unbind either a specific callback from a key or all of them (by leaving callback undefined)
      _exportFunctions.unbind = function(key, callback, type) {
        if (type === undefined) {
          type = 'keydown';
        }
        if (_keys[key] === undefined) {
          throw new Error("unsupported key: " + key);
        }
        if (callback !== undefined) {
          var newBindings = [];
          var bound = _bound[type][_keys[key].code];
          if (bound !== undefined) {
            for (var i = 0; i < bound.length; i++) {
              if (!(bound[i].fn == callback && bound[i].shift == _keys[key].shift)) {
                newBindings.push(_bound[type][_keys[key].code][i]);
              }
            }
          }
          _bound[type][_keys[key].code] = newBindings;
        }
        else {
          _bound[type][_keys[key].code] = [];
        }
      };

      // reset all bound variables.
      _exportFunctions.reset = function() {
        _bound = {keydown:{}, keyup:{}};
      };

      // unbind all listeners and reset all variables.
      _exportFunctions.destroy = function() {
        _bound = {keydown:{}, keyup:{}};
        container.removeEventListener('keydown', down, true);
        container.removeEventListener('keyup', up, true);
      };

      // create listeners.
      container.addEventListener('keydown',down,true);
      container.addEventListener('keyup',up,true);

      // return the public functions.
      return _exportFunctions;
    }

    return keycharm;
  }));




/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  // utils
  exports.util = __webpack_require__(1);
  exports.DOMutil = __webpack_require__(8);

  // data
  exports.DataSet = __webpack_require__(9);
  exports.DataView = __webpack_require__(11);
  exports.Queue = __webpack_require__(10);

  // Timeline
  exports.Timeline = __webpack_require__(27);
  exports.Graph2d = __webpack_require__(52);
  exports.timeline = {
    Core: __webpack_require__(35),
    DateUtil: __webpack_require__(34),
    Range: __webpack_require__(32),
    stack: __webpack_require__(39),
    TimeStep: __webpack_require__(37),

    components: {
      items: {
        Item: __webpack_require__(41),
        BackgroundItem: __webpack_require__(45),
        BoxItem: __webpack_require__(43),
        PointItem: __webpack_require__(44),
        RangeItem: __webpack_require__(40)
      },

      BackgroundGroup: __webpack_require__(42),
      Component: __webpack_require__(33),
      CurrentTime: __webpack_require__(50),
      CustomTime: __webpack_require__(48),
      DataAxis: __webpack_require__(54),
      DataScale: __webpack_require__(55),
      GraphGroup: __webpack_require__(56),
      Group: __webpack_require__(38),
      ItemSet: __webpack_require__(36),
      Legend: __webpack_require__(60),
      LineGraph: __webpack_require__(53),
      TimeAxis: __webpack_require__(46)
    }
  };

  // bundled external libraries
  exports.moment = __webpack_require__(2);
  exports.Hammer = __webpack_require__(22);
  exports.keycharm = __webpack_require__(25);

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _Configurator = __webpack_require__(28);

  var _Configurator2 = _interopRequireDefault(_Configurator);

  var _Validator = __webpack_require__(31);

  var _Validator2 = _interopRequireDefault(_Validator);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var Emitter = __webpack_require__(13);
  var Hammer = __webpack_require__(22);
  var moment = __webpack_require__(2);
  var util = __webpack_require__(1);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);
  var Range = __webpack_require__(32);
  var Core = __webpack_require__(35);
  var TimeAxis = __webpack_require__(46);
  var CurrentTime = __webpack_require__(50);
  var CustomTime = __webpack_require__(48);
  var ItemSet = __webpack_require__(36);

  var printStyle = __webpack_require__(31).printStyle;
  var allOptions = __webpack_require__(51).allOptions;
  var configureOptions = __webpack_require__(51).configureOptions;

  /**
   * Create a timeline visualization
   * @param {HTMLElement} container
   * @param {vis.DataSet | vis.DataView | Array} [items]
   * @param {vis.DataSet | vis.DataView | Array} [groups]
   * @param {Object} [options]  See Timeline.setOptions for the available options.
   * @constructor
   * @extends Core
   */
  function Timeline(container, items, groups, options) {

    if (!(this instanceof Timeline)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // if the third element is options, the forth is groups (optionally);
    if (!(Array.isArray(groups) || groups instanceof DataSet || groups instanceof DataView) && groups instanceof Object) {
      var forthArgument = options;
      options = groups;
      groups = forthArgument;
    }

    var me = this;
    this.defaultOptions = {
      start: null,
      end: null,
      autoResize: true,
      orientation: {
        axis: 'bottom', // axis orientation: 'bottom', 'top', or 'both'
        item: 'bottom' // not relevant
      },
      moment: moment,
      width: null,
      height: null,
      maxHeight: null,
      minHeight: null
    };
    this.options = util.deepExtend({}, this.defaultOptions);

    // Create the DOM, props, and emitter
    this._create(container);

    if (!options || options && typeof options.rtl == "undefined") {
      var directionFromDom,
          domNode = this.dom.root;
      while (!directionFromDom && domNode) {
        directionFromDom = window.getComputedStyle(domNode, null).direction;
        domNode = domNode.parentElement;
      }
      this.options.rtl = directionFromDom && directionFromDom.toLowerCase() == "rtl";
    } else {
      this.options.rtl = options.rtl;
    }

    // all components listed here will be repainted automatically
    this.components = [];

    this.body = {
      dom: this.dom,
      domProps: this.props,
      emitter: {
        on: this.on.bind(this),
        off: this.off.bind(this),
        emit: this.emit.bind(this)
      },
      hiddenDates: [],
      util: {
        getScale: function getScale() {
          return me.timeAxis.step.scale;
        },
        getStep: function getStep() {
          return me.timeAxis.step.step;
        },

        toScreen: me._toScreen.bind(me),
        toGlobalScreen: me._toGlobalScreen.bind(me), // this refers to the root.width
        toTime: me._toTime.bind(me),
        toGlobalTime: me._toGlobalTime.bind(me)
      }
    };

    // range
    this.range = new Range(this.body, this.options);
    this.components.push(this.range);
    this.body.range = this.range;

    // time axis
    this.timeAxis = new TimeAxis(this.body, this.options);
    this.timeAxis2 = null; // used in case of orientation option 'both'
    this.components.push(this.timeAxis);

    // current time bar
    this.currentTime = new CurrentTime(this.body, this.options);
    this.components.push(this.currentTime);

    // item set
    this.itemSet = new ItemSet(this.body, this.options);
    this.components.push(this.itemSet);

    this.itemsData = null; // DataSet
    this.groupsData = null; // DataSet

    this.on('tap', function (event) {
      me.emit('click', me.getEventProperties(event));
    });
    this.on('doubletap', function (event) {
      me.emit('doubleClick', me.getEventProperties(event));
    });
    this.dom.root.oncontextmenu = function (event) {
      me.emit('contextmenu', me.getEventProperties(event));
    };

    //Single time autoscale/fit
    this.fitDone = false;
    this.on('changed', function () {
      if (this.itemsData == null) return;
      if (!me.fitDone) {
        me.fitDone = true;
        if (me.options.start != undefined || me.options.end != undefined) {
          if (me.options.start == undefined || me.options.end == undefined) {
            var range = me.getItemRange();
          }

          var start = me.options.start != undefined ? me.options.start : range.min;
          var end = me.options.end != undefined ? me.options.end : range.max;

          me.setWindow(start, end, { animation: false });
        } else {
          me.fit({ animation: false });
        }
      }
    });

    // apply options
    if (options) {
      this.setOptions(options);
    }

    // IMPORTANT: THIS HAPPENS BEFORE SET ITEMS!
    if (groups) {
      this.setGroups(groups);
    }

    // create itemset
    if (items) {
      this.setItems(items);
    }

    // draw for the first time
    this._redraw();
  }

  // Extend the functionality from Core
  Timeline.prototype = new Core();

  /**
   * Load a configurator
   * @return {Object}
   * @private
   */
  Timeline.prototype._createConfigurator = function () {
    return new _Configurator2.default(this, this.dom.container, configureOptions);
  };

  /**
   * Force a redraw. The size of all items will be recalculated.
   * Can be useful to manually redraw when option autoResize=false and the window
   * has been resized, or when the items CSS has been changed.
   *
   * Note: this function will be overridden on construction with a trottled version
   */
  Timeline.prototype.redraw = function () {
    this.itemSet && this.itemSet.markDirty({ refreshItems: true });
    this._redraw();
  };

  Timeline.prototype.setOptions = function (options) {
    // validate options
    var errorFound = _Validator2.default.validate(options, allOptions);

    if (errorFound === true) {
      console.log('%cErrors have been found in the supplied options object.', printStyle);
    }
    Core.prototype.setOptions.call(this, options);

    if ('type' in options) {
      if (options.type !== this.options.type) {
        this.options.type = options.type;

        // force recreation of all items
        var itemsData = this.itemsData;
        if (itemsData) {
          var selection = this.getSelection();
          this.setItems(null); // remove all
          this.setItems(itemsData); // add all
          this.setSelection(selection); // restore selection
        }
      }
    }
  };

  /**
   * Set items
   * @param {vis.DataSet | Array | null} items
   */
  Timeline.prototype.setItems = function (items) {
    // convert to type DataSet when needed
    var newDataSet;
    if (!items) {
      newDataSet = null;
    } else if (items instanceof DataSet || items instanceof DataView) {
      newDataSet = items;
    } else {
      // turn an array into a dataset
      newDataSet = new DataSet(items, {
        type: {
          start: 'Date',
          end: 'Date'
        }
      });
    }

    // set items
    this.itemsData = newDataSet;
    this.itemSet && this.itemSet.setItems(newDataSet);
  };

  /**
   * Set groups
   * @param {vis.DataSet | Array} groups
   */
  Timeline.prototype.setGroups = function (groups) {
    // convert to type DataSet when needed
    var newDataSet;
    if (!groups) {
      newDataSet = null;
    } else if (groups instanceof DataSet || groups instanceof DataView) {
      newDataSet = groups;
    } else {
      // turn an array into a dataset
      newDataSet = new DataSet(groups);
    }

    this.groupsData = newDataSet;
    this.itemSet.setGroups(newDataSet);
  };

  /**
   * Set both items and groups in one go
   * @param {{items: Array | vis.DataSet, groups: Array | vis.DataSet}} data
   */
  Timeline.prototype.setData = function (data) {
    if (data && data.groups) {
      this.setGroups(data.groups);
    }

    if (data && data.items) {
      this.setItems(data.items);
    }
  };

  /**
   * Set selected items by their id. Replaces the current selection
   * Unknown id's are silently ignored.
   * @param {string[] | string} [ids]  An array with zero or more id's of the items to be
   *                                selected. If ids is an empty array, all items will be
   *                                unselected.
   * @param {Object} [options]      Available options:
   *                                `focus: boolean`
   *                                    If true, focus will be set to the selected item(s)
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   *                                    Only applicable when option focus is true.
   */
  Timeline.prototype.setSelection = function (ids, options) {
    this.itemSet && this.itemSet.setSelection(ids);

    if (options && options.focus) {
      this.focus(ids, options);
    }
  };

  /**
   * Get the selected items by their id
   * @return {Array} ids  The ids of the selected items
   */
  Timeline.prototype.getSelection = function () {
    return this.itemSet && this.itemSet.getSelection() || [];
  };

  /**
   * Adjust the visible window such that the selected item (or multiple items)
   * are centered on screen.
   * @param {String | String[]} id     An item id or array with item ids
   * @param {Object} [options]      Available options:
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   */
  Timeline.prototype.focus = function (id, options) {
    if (!this.itemsData || id == undefined) return;

    var ids = Array.isArray(id) ? id : [id];

    // get the specified item(s)
    var itemsData = this.itemsData.getDataSet().get(ids, {
      type: {
        start: 'Date',
        end: 'Date'
      }
    });

    // calculate minimum start and maximum end of specified items
    var start = null;
    var end = null;
    itemsData.forEach(function (itemData) {
      var s = itemData.start.valueOf();
      var e = 'end' in itemData ? itemData.end.valueOf() : itemData.start.valueOf();

      if (start === null || s < start) {
        start = s;
      }

      if (end === null || e > end) {
        end = e;
      }
    });

    if (start !== null && end !== null) {
      // calculate the new middle and interval for the window
      var middle = (start + end) / 2;
      var interval = Math.max(this.range.end - this.range.start, (end - start) * 1.1);

      var animation = options && options.animation !== undefined ? options.animation : true;
      this.range.setRange(middle - interval / 2, middle + interval / 2, animation);
    }
  };

  /**
   * Set Timeline window such that it fits all items
   * @param {Object} [options]  Available options:
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   */
  Timeline.prototype.fit = function (options) {
    var animation = options && options.animation !== undefined ? options.animation : true;
    var range;

    var dataset = this.itemsData && this.itemsData.getDataSet();
    if (dataset.length === 1 && dataset.get()[0].end === undefined) {
      // a single item -> don't fit, just show a range around the item from -4 to +3 days
      range = this.getDataRange();
      this.moveTo(range.min.valueOf(), { animation: animation });
    } else {
      // exactly fit the items (plus a small margin)
      range = this.getItemRange();
      this.range.setRange(range.min, range.max, animation);
    }
  };

  /**
   * Determine the range of the items, taking into account their actual width
   * and a margin of 10 pixels on both sides.
   * @return {{min: Date | null, max: Date | null}}
   */
  Timeline.prototype.getItemRange = function () {
    var _this = this;

    // get a rough approximation for the range based on the items start and end dates
    var range = this.getDataRange();
    var min = range.min !== null ? range.min.valueOf() : null;
    var max = range.max !== null ? range.max.valueOf() : null;
    var minItem = null;
    var maxItem = null;

    if (min != null && max != null) {
      var interval;
      var factor;
      var lhs;
      var rhs;
      var delta;

      (function () {
        var getStart = function getStart(item) {
          return util.convert(item.data.start, 'Date').valueOf();
        };

        var getEnd = function getEnd(item) {
          var end = item.data.end != undefined ? item.data.end : item.data.start;
          return util.convert(end, 'Date').valueOf();
        };

        // calculate the date of the left side and right side of the items given


        interval = max - min; // ms

        if (interval <= 0) {
          interval = 10;
        }
        factor = interval / _this.props.center.width;
        util.forEach(_this.itemSet.items, function (item) {
          item.show();
          item.repositionX();

          var start = getStart(item);
          var end = getEnd(item);

          if (this.options.rtl) {
            var startSide = start - (item.getWidthRight() + 10) * factor;
            var endSide = end + (item.getWidthLeft() + 10) * factor;
          } else {
            var startSide = start - (item.getWidthLeft() + 10) * factor;
            var endSide = end + (item.getWidthRight() + 10) * factor;
          }

          if (startSide < min) {
            min = startSide;
            minItem = item;
          }
          if (endSide > max) {
            max = endSide;
            maxItem = item;
          }
        }.bind(_this));

        if (minItem && maxItem) {
          lhs = minItem.getWidthLeft() + 10;
          rhs = maxItem.getWidthRight() + 10;
          delta = _this.props.center.width - lhs - rhs; // px

          if (delta > 0) {
            if (_this.options.rtl) {
              min = getStart(minItem) - rhs * interval / delta; // ms
              max = getEnd(maxItem) + lhs * interval / delta; // ms
            } else {
              min = getStart(minItem) - lhs * interval / delta; // ms
              max = getEnd(maxItem) + rhs * interval / delta; // ms
            }
          }
        }
      })();
    }

    return {
      min: min != null ? new Date(min) : null,
      max: max != null ? new Date(max) : null
    };
  };

  /**
   * Calculate the data range of the items start and end dates
   * @returns {{min: Date | null, max: Date | null}}
   */
  Timeline.prototype.getDataRange = function () {
    var min = null;
    var max = null;

    var dataset = this.itemsData && this.itemsData.getDataSet();
    if (dataset) {
      dataset.forEach(function (item) {
        var start = util.convert(item.start, 'Date').valueOf();
        var end = util.convert(item.end != undefined ? item.end : item.start, 'Date').valueOf();
        if (min === null || start < min) {
          min = start;
        }
        if (max === null || end > max) {
          max = end;
        }
      });
    }

    return {
      min: min != null ? new Date(min) : null,
      max: max != null ? new Date(max) : null
    };
  };

  /**
   * Generate Timeline related information from an event
   * @param {Event} event
   * @return {Object} An object with related information, like on which area
   *                  The event happened, whether clicked on an item, etc.
   */
  Timeline.prototype.getEventProperties = function (event) {
    var clientX = event.center ? event.center.x : event.clientX;
    var clientY = event.center ? event.center.y : event.clientY;
    if (this.options.rtl) {
      var x = util.getAbsoluteRight(this.dom.centerContainer) - clientX;
    } else {
      var x = clientX - util.getAbsoluteLeft(this.dom.centerContainer);
    }
    var y = clientY - util.getAbsoluteTop(this.dom.centerContainer);

    var item = this.itemSet.itemFromTarget(event);
    var group = this.itemSet.groupFromTarget(event);
    var customTime = CustomTime.customTimeFromTarget(event);

    var snap = this.itemSet.options.snap || null;
    var scale = this.body.util.getScale();
    var step = this.body.util.getStep();
    var time = this._toTime(x);
    var snappedTime = snap ? snap(time, scale, step) : time;

    var element = util.getTarget(event);
    var what = null;
    if (item != null) {
      what = 'item';
    } else if (customTime != null) {
      what = 'custom-time';
    } else if (util.hasParent(element, this.timeAxis.dom.foreground)) {
      what = 'axis';
    } else if (this.timeAxis2 && util.hasParent(element, this.timeAxis2.dom.foreground)) {
      what = 'axis';
    } else if (util.hasParent(element, this.itemSet.dom.labelSet)) {
      what = 'group-label';
    } else if (util.hasParent(element, this.currentTime.bar)) {
      what = 'current-time';
    } else if (util.hasParent(element, this.dom.center)) {
      what = 'background';
    }

    return {
      event: event,
      item: item ? item.id : null,
      group: group ? group.groupId : null,
      what: what,
      pageX: event.srcEvent ? event.srcEvent.pageX : event.pageX,
      pageY: event.srcEvent ? event.srcEvent.pageY : event.pageY,
      x: x,
      y: y,
      time: time,
      snappedTime: snappedTime
    };
  };

  module.exports = Timeline;

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _ColorPicker = __webpack_require__(29);

  var _ColorPicker2 = _interopRequireDefault(_ColorPicker);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  /**
   * The way this works is for all properties of this.possible options, you can supply the property name in any form to list the options.
   * Boolean options are recognised as Boolean
   * Number options should be written as array: [default value, min value, max value, stepsize]
   * Colors should be written as array: ['color', '#ffffff']
   * Strings with should be written as array: [option1, option2, option3, ..]
   *
   * The options are matched with their counterparts in each of the modules and the values used in the configuration are
   *
   * @param parentModule        | the location where parentModule.setOptions() can be called
   * @param defaultContainer    | the default container of the module
   * @param configureOptions    | the fully configured and predefined options set found in allOptions.js
   * @param pixelRatio          | canvas pixel ratio
   */
  var Configurator = function () {
    function Configurator(parentModule, defaultContainer, configureOptions) {
      var pixelRatio = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

      _classCallCheck(this, Configurator);

      this.parent = parentModule;
      this.changedOptions = [];
      this.container = defaultContainer;
      this.allowCreation = false;

      this.options = {};
      this.initialized = false;
      this.popupCounter = 0;
      this.defaultOptions = {
        enabled: false,
        filter: true,
        container: undefined,
        showButton: true
      };
      util.extend(this.options, this.defaultOptions);

      this.configureOptions = configureOptions;
      this.moduleOptions = {};
      this.domElements = [];
      this.popupDiv = {};
      this.popupLimit = 5;
      this.popupHistory = {};
      this.colorPicker = new _ColorPicker2.default(pixelRatio);
      this.wrapper = undefined;
    }

    /**
     * refresh all options.
     * Because all modules parse their options by themselves, we just use their options. We copy them here.
     *
     * @param options
     */


    _createClass(Configurator, [{
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {
          // reset the popup history because the indices may have been changed.
          this.popupHistory = {};
          this._removePopup();

          var enabled = true;
          if (typeof options === 'string') {
            this.options.filter = options;
          } else if (options instanceof Array) {
            this.options.filter = options.join();
          } else if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
            if (options.container !== undefined) {
              this.options.container = options.container;
            }
            if (options.filter !== undefined) {
              this.options.filter = options.filter;
            }
            if (options.showButton !== undefined) {
              this.options.showButton = options.showButton;
            }
            if (options.enabled !== undefined) {
              enabled = options.enabled;
            }
          } else if (typeof options === 'boolean') {
            this.options.filter = true;
            enabled = options;
          } else if (typeof options === 'function') {
            this.options.filter = options;
            enabled = true;
          }
          if (this.options.filter === false) {
            enabled = false;
          }

          this.options.enabled = enabled;
        }
        this._clean();
      }
    }, {
      key: 'setModuleOptions',
      value: function setModuleOptions(moduleOptions) {
        this.moduleOptions = moduleOptions;
        if (this.options.enabled === true) {
          this._clean();
          if (this.options.container !== undefined) {
            this.container = this.options.container;
          }
          this._create();
        }
      }

      /**
       * Create all DOM elements
       * @private
       */

    }, {
      key: '_create',
      value: function _create() {
        var _this = this;

        this._clean();
        this.changedOptions = [];

        var filter = this.options.filter;
        var counter = 0;
        var show = false;
        for (var option in this.configureOptions) {
          if (this.configureOptions.hasOwnProperty(option)) {
            this.allowCreation = false;
            show = false;
            if (typeof filter === 'function') {
              show = filter(option, []);
              show = show || this._handleObject(this.configureOptions[option], [option], true);
            } else if (filter === true || filter.indexOf(option) !== -1) {
              show = true;
            }

            if (show !== false) {
              this.allowCreation = true;

              // linebreak between categories
              if (counter > 0) {
                this._makeItem([]);
              }
              // a header for the category
              this._makeHeader(option);

              // get the sub options
              this._handleObject(this.configureOptions[option], [option]);
            }
            counter++;
          }
        }

        if (this.options.showButton === true) {
          (function () {
            var generateButton = document.createElement('div');
            generateButton.className = 'vis-configuration vis-config-button';
            generateButton.innerHTML = 'generate options';
            generateButton.onclick = function () {
              _this._printOptions();
            };
            generateButton.onmouseover = function () {
              generateButton.className = 'vis-configuration vis-config-button hover';
            };
            generateButton.onmouseout = function () {
              generateButton.className = 'vis-configuration vis-config-button';
            };

            _this.optionsContainer = document.createElement('div');
            _this.optionsContainer.className = 'vis-configuration vis-config-option-container';

            _this.domElements.push(_this.optionsContainer);
            _this.domElements.push(generateButton);
          })();
        }

        this._push();
        //~ this.colorPicker.insertTo(this.container);
      }

      /**
       * draw all DOM elements on the screen
       * @private
       */

    }, {
      key: '_push',
      value: function _push() {
        this.wrapper = document.createElement('div');
        this.wrapper.className = 'vis-configuration-wrapper';
        this.container.appendChild(this.wrapper);
        for (var i = 0; i < this.domElements.length; i++) {
          this.wrapper.appendChild(this.domElements[i]);
        }

        this._showPopupIfNeeded();
      }

      /**
       * delete all DOM elements
       * @private
       */

    }, {
      key: '_clean',
      value: function _clean() {
        for (var i = 0; i < this.domElements.length; i++) {
          this.wrapper.removeChild(this.domElements[i]);
        }

        if (this.wrapper !== undefined) {
          this.container.removeChild(this.wrapper);
          this.wrapper = undefined;
        }
        this.domElements = [];

        this._removePopup();
      }

      /**
       * get the value from the actualOptions if it exists
       * @param {array} path    | where to look for the actual option
       * @returns {*}
       * @private
       */

    }, {
      key: '_getValue',
      value: function _getValue(path) {
        var base = this.moduleOptions;
        for (var i = 0; i < path.length; i++) {
          if (base[path[i]] !== undefined) {
            base = base[path[i]];
          } else {
            base = undefined;
            break;
          }
        }
        return base;
      }

      /**
       * all option elements are wrapped in an item
       * @param path
       * @param domElements
       * @private
       */

    }, {
      key: '_makeItem',
      value: function _makeItem(path) {
        var _arguments = arguments,
            _this2 = this;

        if (this.allowCreation === true) {
          var _len, domElements, _key;

          var _ret2 = function () {
            var item = document.createElement('div');
            item.className = 'vis-configuration vis-config-item vis-config-s' + path.length;

            for (_len = _arguments.length, domElements = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              domElements[_key - 1] = _arguments[_key];
            }

            domElements.forEach(function (element) {
              item.appendChild(element);
            });
            _this2.domElements.push(item);
            return {
              v: _this2.domElements.length
            };
          }();

          if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
        }
        return 0;
      }

      /**
       * header for major subjects
       * @param name
       * @private
       */

    }, {
      key: '_makeHeader',
      value: function _makeHeader(name) {
        var div = document.createElement('div');
        div.className = 'vis-configuration vis-config-header';
        div.innerHTML = name;
        this._makeItem([], div);
      }

      /**
       * make a label, if it is an object label, it gets different styling.
       * @param name
       * @param path
       * @param objectLabel
       * @returns {HTMLElement}
       * @private
       */

    }, {
      key: '_makeLabel',
      value: function _makeLabel(name, path) {
        var objectLabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        var div = document.createElement('div');
        div.className = 'vis-configuration vis-config-label vis-config-s' + path.length;
        if (objectLabel === true) {
          div.innerHTML = '<i><b>' + name + ':</b></i>';
        } else {
          div.innerHTML = name + ':';
        }
        return div;
      }

      /**
       * make a dropdown list for multiple possible string optoins
       * @param arr
       * @param value
       * @param path
       * @private
       */

    }, {
      key: '_makeDropdown',
      value: function _makeDropdown(arr, value, path) {
        var select = document.createElement('select');
        select.className = 'vis-configuration vis-config-select';
        var selectedValue = 0;
        if (value !== undefined) {
          if (arr.indexOf(value) !== -1) {
            selectedValue = arr.indexOf(value);
          }
        }

        for (var i = 0; i < arr.length; i++) {
          var option = document.createElement('option');
          option.value = arr[i];
          if (i === selectedValue) {
            option.selected = 'selected';
          }
          option.innerHTML = arr[i];
          select.appendChild(option);
        }

        var me = this;
        select.onchange = function () {
          me._update(this.value, path);
        };

        var label = this._makeLabel(path[path.length - 1], path);
        this._makeItem(path, label, select);
      }

      /**
       * make a range object for numeric options
       * @param arr
       * @param value
       * @param path
       * @private
       */

    }, {
      key: '_makeRange',
      value: function _makeRange(arr, value, path) {
        var defaultValue = arr[0];
        var min = arr[1];
        var max = arr[2];
        var step = arr[3];
        var range = document.createElement('input');
        range.className = 'vis-configuration vis-config-range';
        try {
          range.type = 'range'; // not supported on IE9
          range.min = min;
          range.max = max;
        } catch (err) {}
        range.step = step;

        // set up the popup settings in case they are needed.
        var popupString = '';
        var popupValue = 0;

        if (value !== undefined) {
          var factor = 1.20;
          if (value < 0 && value * factor < min) {
            range.min = Math.ceil(value * factor);
            popupValue = range.min;
            popupString = 'range increased';
          } else if (value / factor < min) {
            range.min = Math.ceil(value / factor);
            popupValue = range.min;
            popupString = 'range increased';
          }
          if (value * factor > max && max !== 1) {
            range.max = Math.ceil(value * factor);
            popupValue = range.max;
            popupString = 'range increased';
          }
          range.value = value;
        } else {
          range.value = defaultValue;
        }

        var input = document.createElement('input');
        input.className = 'vis-configuration vis-config-rangeinput';
        input.value = range.value;

        var me = this;
        range.onchange = function () {
          input.value = this.value;me._update(Number(this.value), path);
        };
        range.oninput = function () {
          input.value = this.value;
        };

        var label = this._makeLabel(path[path.length - 1], path);
        var itemIndex = this._makeItem(path, label, range, input);

        // if a popup is needed AND it has not been shown for this value, show it.
        if (popupString !== '' && this.popupHistory[itemIndex] !== popupValue) {
          this.popupHistory[itemIndex] = popupValue;
          this._setupPopup(popupString, itemIndex);
        }
      }

      /**
       * prepare the popup
       * @param string
       * @param index
       * @private
       */

    }, {
      key: '_setupPopup',
      value: function _setupPopup(string, index) {
        var _this3 = this;

        if (this.initialized === true && this.allowCreation === true && this.popupCounter < this.popupLimit) {
          var div = document.createElement("div");
          div.id = "vis-configuration-popup";
          div.className = "vis-configuration-popup";
          div.innerHTML = string;
          div.onclick = function () {
            _this3._removePopup();
          };
          this.popupCounter += 1;
          this.popupDiv = { html: div, index: index };
        }
      }

      /**
       * remove the popup from the dom
       * @private
       */

    }, {
      key: '_removePopup',
      value: function _removePopup() {
        if (this.popupDiv.html !== undefined) {
          this.popupDiv.html.parentNode.removeChild(this.popupDiv.html);
          clearTimeout(this.popupDiv.hideTimeout);
          clearTimeout(this.popupDiv.deleteTimeout);
          this.popupDiv = {};
        }
      }

      /**
       * Show the popup if it is needed.
       * @private
       */

    }, {
      key: '_showPopupIfNeeded',
      value: function _showPopupIfNeeded() {
        var _this4 = this;

        if (this.popupDiv.html !== undefined) {
          var correspondingElement = this.domElements[this.popupDiv.index];
          var rect = correspondingElement.getBoundingClientRect();
          this.popupDiv.html.style.left = rect.left + "px";
          this.popupDiv.html.style.top = rect.top - 30 + "px"; // 30 is the height;
          document.body.appendChild(this.popupDiv.html);
          this.popupDiv.hideTimeout = setTimeout(function () {
            _this4.popupDiv.html.style.opacity = 0;
          }, 1500);
          this.popupDiv.deleteTimeout = setTimeout(function () {
            _this4._removePopup();
          }, 1800);
        }
      }

      /**
       * make a checkbox for boolean options.
       * @param defaultValue
       * @param value
       * @param path
       * @private
       */

    }, {
      key: '_makeCheckbox',
      value: function _makeCheckbox(defaultValue, value, path) {
        var checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'vis-configuration vis-config-checkbox';
        checkbox.checked = defaultValue;
        if (value !== undefined) {
          checkbox.checked = value;
          if (value !== defaultValue) {
            if ((typeof defaultValue === 'undefined' ? 'undefined' : _typeof(defaultValue)) === 'object') {
              if (value !== defaultValue.enabled) {
                this.changedOptions.push({ path: path, value: value });
              }
            } else {
              this.changedOptions.push({ path: path, value: value });
            }
          }
        }

        var me = this;
        checkbox.onchange = function () {
          me._update(this.checked, path);
        };

        var label = this._makeLabel(path[path.length - 1], path);
        this._makeItem(path, label, checkbox);
      }

      /**
       * make a text input field for string options.
       * @param defaultValue
       * @param value
       * @param path
       * @private
       */

    }, {
      key: '_makeTextInput',
      value: function _makeTextInput(defaultValue, value, path) {
        var checkbox = document.createElement('input');
        checkbox.type = 'text';
        checkbox.className = 'vis-configuration vis-config-text';
        checkbox.value = value;
        if (value !== defaultValue) {
          this.changedOptions.push({ path: path, value: value });
        }

        var me = this;
        checkbox.onchange = function () {
          me._update(this.value, path);
        };

        var label = this._makeLabel(path[path.length - 1], path);
        this._makeItem(path, label, checkbox);
      }

      /**
       * make a color field with a color picker for color fields
       * @param arr
       * @param value
       * @param path
       * @private
       */

    }, {
      key: '_makeColorField',
      value: function _makeColorField(arr, value, path) {
        var _this5 = this;

        var defaultColor = arr[1];
        var div = document.createElement('div');
        value = value === undefined ? defaultColor : value;

        if (value !== 'none') {
          div.className = 'vis-configuration vis-config-colorBlock';
          div.style.backgroundColor = value;
        } else {
          div.className = 'vis-configuration vis-config-colorBlock none';
        }

        value = value === undefined ? defaultColor : value;
        div.onclick = function () {
          _this5._showColorPicker(value, div, path);
        };

        var label = this._makeLabel(path[path.length - 1], path);
        this._makeItem(path, label, div);
      }

      /**
       * used by the color buttons to call the color picker.
       * @param event
       * @param value
       * @param div
       * @param path
       * @private
       */

    }, {
      key: '_showColorPicker',
      value: function _showColorPicker(value, div, path) {
        var _this6 = this;

        // clear the callback from this div
        div.onclick = function () {};

        this.colorPicker.insertTo(div);
        this.colorPicker.show();

        this.colorPicker.setColor(value);
        this.colorPicker.setUpdateCallback(function (color) {
          var colorString = 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',' + color.a + ')';
          div.style.backgroundColor = colorString;
          _this6._update(colorString, path);
        });

        // on close of the colorpicker, restore the callback.
        this.colorPicker.setCloseCallback(function () {
          div.onclick = function () {
            _this6._showColorPicker(value, div, path);
          };
        });
      }

      /**
       * parse an object and draw the correct items
       * @param obj
       * @param path
       * @private
       */

    }, {
      key: '_handleObject',
      value: function _handleObject(obj) {
        var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        var checkOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        var show = false;
        var filter = this.options.filter;
        var visibleInSet = false;
        for (var subObj in obj) {
          if (obj.hasOwnProperty(subObj)) {
            show = true;
            var item = obj[subObj];
            var newPath = util.copyAndExtendArray(path, subObj);
            if (typeof filter === 'function') {
              show = filter(subObj, path);

              // if needed we must go deeper into the object.
              if (show === false) {
                if (!(item instanceof Array) && typeof item !== 'string' && typeof item !== 'boolean' && item instanceof Object) {
                  this.allowCreation = false;
                  show = this._handleObject(item, newPath, true);
                  this.allowCreation = checkOnly === false;
                }
              }
            }

            if (show !== false) {
              visibleInSet = true;
              var value = this._getValue(newPath);

              if (item instanceof Array) {
                this._handleArray(item, value, newPath);
              } else if (typeof item === 'string') {
                this._makeTextInput(item, value, newPath);
              } else if (typeof item === 'boolean') {
                this._makeCheckbox(item, value, newPath);
              } else if (item instanceof Object) {
                // collapse the physics options that are not enabled
                var draw = true;
                if (path.indexOf('physics') !== -1) {
                  if (this.moduleOptions.physics.solver !== subObj) {
                    draw = false;
                  }
                }

                if (draw === true) {
                  // initially collapse options with an disabled enabled option.
                  if (item.enabled !== undefined) {
                    var enabledPath = util.copyAndExtendArray(newPath, 'enabled');
                    var enabledValue = this._getValue(enabledPath);
                    if (enabledValue === true) {
                      var label = this._makeLabel(subObj, newPath, true);
                      this._makeItem(newPath, label);
                      visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                    } else {
                      this._makeCheckbox(item, enabledValue, newPath);
                    }
                  } else {
                    var _label = this._makeLabel(subObj, newPath, true);
                    this._makeItem(newPath, _label);
                    visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                  }
                }
              } else {
                console.error('dont know how to handle', item, subObj, newPath);
              }
            }
          }
        }
        return visibleInSet;
      }

      /**
       * handle the array type of option
       * @param optionName
       * @param arr
       * @param value
       * @param path
       * @private
       */

    }, {
      key: '_handleArray',
      value: function _handleArray(arr, value, path) {
        if (typeof arr[0] === 'string' && arr[0] === 'color') {
          this._makeColorField(arr, value, path);
          if (arr[1] !== value) {
            this.changedOptions.push({ path: path, value: value });
          }
        } else if (typeof arr[0] === 'string') {
          this._makeDropdown(arr, value, path);
          if (arr[0] !== value) {
            this.changedOptions.push({ path: path, value: value });
          }
        } else if (typeof arr[0] === 'number') {
          this._makeRange(arr, value, path);
          if (arr[0] !== value) {
            this.changedOptions.push({ path: path, value: Number(value) });
          }
        }
      }

      /**
       * called to update the network with the new settings.
       * @param value
       * @param path
       * @private
       */

    }, {
      key: '_update',
      value: function _update(value, path) {
        var options = this._constructOptions(value, path);

        if (this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit) {
          this.parent.body.emitter.emit("configChange", options);
        }
        this.initialized = true;
        this.parent.setOptions(options);
      }
    }, {
      key: '_constructOptions',
      value: function _constructOptions(value, path) {
        var optionsObj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        var pointer = optionsObj;

        // when dropdown boxes can be string or boolean, we typecast it into correct types
        value = value === 'true' ? true : value;
        value = value === 'false' ? false : value;

        for (var i = 0; i < path.length; i++) {
          if (path[i] !== 'global') {
            if (pointer[path[i]] === undefined) {
              pointer[path[i]] = {};
            }
            if (i !== path.length - 1) {
              pointer = pointer[path[i]];
            } else {
              pointer[path[i]] = value;
            }
          }
        }
        return optionsObj;
      }
    }, {
      key: '_printOptions',
      value: function _printOptions() {
        var options = this.getOptions();
        this.optionsContainer.innerHTML = '<pre>var options = ' + JSON.stringify(options, null, 2) + '</pre>';
      }
    }, {
      key: 'getOptions',
      value: function getOptions() {
        var options = {};
        for (var i = 0; i < this.changedOptions.length; i++) {
          this._constructOptions(this.changedOptions[i].value, this.changedOptions[i].path, options);
        }
        return options;
      }
    }]);

    return Configurator;
  }();

  exports.default = Configurator;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var Hammer = __webpack_require__(22);
  var hammerUtil = __webpack_require__(30);
  var util = __webpack_require__(1);

  var ColorPicker = function () {
    function ColorPicker() {
      var pixelRatio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      _classCallCheck(this, ColorPicker);

      this.pixelRatio = pixelRatio;
      this.generated = false;
      this.centerCoordinates = { x: 289 / 2, y: 289 / 2 };
      this.r = 289 * 0.49;
      this.color = { r: 255, g: 255, b: 255, a: 1.0 };
      this.hueCircle = undefined;
      this.initialColor = { r: 255, g: 255, b: 255, a: 1.0 };
      this.previousColor = undefined;
      this.applied = false;

      // bound by
      this.updateCallback = function () {};
      this.closeCallback = function () {};

      // create all DOM elements
      this._create();
    }

    /**
     * this inserts the colorPicker into a div from the DOM
     * @param container
     */


    _createClass(ColorPicker, [{
      key: 'insertTo',
      value: function insertTo(container) {
        if (this.hammer !== undefined) {
          this.hammer.destroy();
          this.hammer = undefined;
        }
        this.container = container;
        this.container.appendChild(this.frame);
        this._bindHammer();

        this._setSize();
      }

      /**
       * the callback is executed on apply and save. Bind it to the application
       * @param callback
       */

    }, {
      key: 'setUpdateCallback',
      value: function setUpdateCallback(callback) {
        if (typeof callback === 'function') {
          this.updateCallback = callback;
        } else {
          throw new Error("Function attempted to set as colorPicker update callback is not a function.");
        }
      }

      /**
       * the callback is executed on apply and save. Bind it to the application
       * @param callback
       */

    }, {
      key: 'setCloseCallback',
      value: function setCloseCallback(callback) {
        if (typeof callback === 'function') {
          this.closeCallback = callback;
        } else {
          throw new Error("Function attempted to set as colorPicker closing callback is not a function.");
        }
      }
    }, {
      key: '_isColorString',
      value: function _isColorString(color) {
        var htmlColors = { black: '#000000', navy: '#000080', darkblue: '#00008B', mediumblue: '#0000CD', blue: '#0000FF', darkgreen: '#006400', green: '#008000', teal: '#008080', darkcyan: '#008B8B', deepskyblue: '#00BFFF', darkturquoise: '#00CED1', mediumspringgreen: '#00FA9A', lime: '#00FF00', springgreen: '#00FF7F', aqua: '#00FFFF', cyan: '#00FFFF', midnightblue: '#191970', dodgerblue: '#1E90FF', lightseagreen: '#20B2AA', forestgreen: '#228B22', seagreen: '#2E8B57', darkslategray: '#2F4F4F', limegreen: '#32CD32', mediumseagreen: '#3CB371', turquoise: '#40E0D0', royalblue: '#4169E1', steelblue: '#4682B4', darkslateblue: '#483D8B', mediumturquoise: '#48D1CC', indigo: '#4B0082', darkolivegreen: '#556B2F', cadetblue: '#5F9EA0', cornflowerblue: '#6495ED', mediumaquamarine: '#66CDAA', dimgray: '#696969', slateblue: '#6A5ACD', olivedrab: '#6B8E23', slategray: '#708090', lightslategray: '#778899', mediumslateblue: '#7B68EE', lawngreen: '#7CFC00', chartreuse: '#7FFF00', aquamarine: '#7FFFD4', maroon: '#800000', purple: '#800080', olive: '#808000', gray: '#808080', skyblue: '#87CEEB', lightskyblue: '#87CEFA', blueviolet: '#8A2BE2', darkred: '#8B0000', darkmagenta: '#8B008B', saddlebrown: '#8B4513', darkseagreen: '#8FBC8F', lightgreen: '#90EE90', mediumpurple: '#9370D8', darkviolet: '#9400D3', palegreen: '#98FB98', darkorchid: '#9932CC', yellowgreen: '#9ACD32', sienna: '#A0522D', brown: '#A52A2A', darkgray: '#A9A9A9', lightblue: '#ADD8E6', greenyellow: '#ADFF2F', paleturquoise: '#AFEEEE', lightsteelblue: '#B0C4DE', powderblue: '#B0E0E6', firebrick: '#B22222', darkgoldenrod: '#B8860B', mediumorchid: '#BA55D3', rosybrown: '#BC8F8F', darkkhaki: '#BDB76B', silver: '#C0C0C0', mediumvioletred: '#C71585', indianred: '#CD5C5C', peru: '#CD853F', chocolate: '#D2691E', tan: '#D2B48C', lightgrey: '#D3D3D3', palevioletred: '#D87093', thistle: '#D8BFD8', orchid: '#DA70D6', goldenrod: '#DAA520', crimson: '#DC143C', gainsboro: '#DCDCDC', plum: '#DDA0DD', burlywood: '#DEB887', lightcyan: '#E0FFFF', lavender: '#E6E6FA', darksalmon: '#E9967A', violet: '#EE82EE', palegoldenrod: '#EEE8AA', lightcoral: '#F08080', khaki: '#F0E68C', aliceblue: '#F0F8FF', honeydew: '#F0FFF0', azure: '#F0FFFF', sandybrown: '#F4A460', wheat: '#F5DEB3', beige: '#F5F5DC', whitesmoke: '#F5F5F5', mintcream: '#F5FFFA', ghostwhite: '#F8F8FF', salmon: '#FA8072', antiquewhite: '#FAEBD7', linen: '#FAF0E6', lightgoldenrodyellow: '#FAFAD2', oldlace: '#FDF5E6', red: '#FF0000', fuchsia: '#FF00FF', magenta: '#FF00FF', deeppink: '#FF1493', orangered: '#FF4500', tomato: '#FF6347', hotpink: '#FF69B4', coral: '#FF7F50', darkorange: '#FF8C00', lightsalmon: '#FFA07A', orange: '#FFA500', lightpink: '#FFB6C1', pink: '#FFC0CB', gold: '#FFD700', peachpuff: '#FFDAB9', navajowhite: '#FFDEAD', moccasin: '#FFE4B5', bisque: '#FFE4C4', mistyrose: '#FFE4E1', blanchedalmond: '#FFEBCD', papayawhip: '#FFEFD5', lavenderblush: '#FFF0F5', seashell: '#FFF5EE', cornsilk: '#FFF8DC', lemonchiffon: '#FFFACD', floralwhite: '#FFFAF0', snow: '#FFFAFA', yellow: '#FFFF00', lightyellow: '#FFFFE0', ivory: '#FFFFF0', white: '#FFFFFF' };
        if (typeof color === 'string') {
          return htmlColors[color];
        }
      }

      /**
       * Set the color of the colorPicker
       * Supported formats:
       * 'red'                   --> HTML color string
       * '#ffffff'               --> hex string
       * 'rbg(255,255,255)'      --> rgb string
       * 'rgba(255,255,255,1.0)' --> rgba string
       * {r:255,g:255,b:255}     --> rgb object
       * {r:255,g:255,b:255,a:1.0} --> rgba object
       * @param color
       * @param setInitial
       */

    }, {
      key: 'setColor',
      value: function setColor(color) {
        var setInitial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        if (color === 'none') {
          return;
        }

        var rgba = void 0;

        // if a html color shorthand is used, convert to hex
        var htmlColor = this._isColorString(color);
        if (htmlColor !== undefined) {
          color = htmlColor;
        }

        // check format
        if (util.isString(color) === true) {
          if (util.isValidRGB(color) === true) {
            var rgbaArray = color.substr(4).substr(0, color.length - 5).split(',');
            rgba = { r: rgbaArray[0], g: rgbaArray[1], b: rgbaArray[2], a: 1.0 };
          } else if (util.isValidRGBA(color) === true) {
            var _rgbaArray = color.substr(5).substr(0, color.length - 6).split(',');
            rgba = { r: _rgbaArray[0], g: _rgbaArray[1], b: _rgbaArray[2], a: _rgbaArray[3] };
          } else if (util.isValidHex(color) === true) {
            var rgbObj = util.hexToRGB(color);
            rgba = { r: rgbObj.r, g: rgbObj.g, b: rgbObj.b, a: 1.0 };
          }
        } else {
          if (color instanceof Object) {
            if (color.r !== undefined && color.g !== undefined && color.b !== undefined) {
              var alpha = color.a !== undefined ? color.a : '1.0';
              rgba = { r: color.r, g: color.g, b: color.b, a: alpha };
            }
          }
        }

        // set color
        if (rgba === undefined) {
          throw new Error("Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: " + JSON.stringify(color));
        } else {
          this._setColor(rgba, setInitial);
        }
      }

      /**
       * this shows the color picker.
       * The hue circle is constructed once and stored.
       */

    }, {
      key: 'show',
      value: function show() {
        if (this.closeCallback !== undefined) {
          this.closeCallback();
          this.closeCallback = undefined;
        }

        this.applied = false;
        this.frame.style.display = 'block';
        this._generateHueCircle();
      }

      // ------------------------------------------ PRIVATE ----------------------------- //

      /**
       * Hide the picker. Is called by the cancel button.
       * Optional boolean to store the previous color for easy access later on.
       * @param storePrevious
       * @private
       */

    }, {
      key: '_hide',
      value: function _hide() {
        var _this = this;

        var storePrevious = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        // store the previous color for next time;
        if (storePrevious === true) {
          this.previousColor = util.extend({}, this.color);
        }

        if (this.applied === true) {
          this.updateCallback(this.initialColor);
        }

        this.frame.style.display = 'none';

        // call the closing callback, restoring the onclick method.
        // this is in a setTimeout because it will trigger the show again before the click is done.
        setTimeout(function () {
          if (_this.closeCallback !== undefined) {
            _this.closeCallback();
            _this.closeCallback = undefined;
          }
        }, 0);
      }

      /**
       * bound to the save button. Saves and hides.
       * @private
       */

    }, {
      key: '_save',
      value: function _save() {
        this.updateCallback(this.color);
        this.applied = false;
        this._hide();
      }

      /**
       * Bound to apply button. Saves but does not close. Is undone by the cancel button.
       * @private
       */

    }, {
      key: '_apply',
      value: function _apply() {
        this.applied = true;
        this.updateCallback(this.color);
        this._updatePicker(this.color);
      }

      /**
       * load the color from the previous session.
       * @private
       */

    }, {
      key: '_loadLast',
      value: function _loadLast() {
        if (this.previousColor !== undefined) {
          this.setColor(this.previousColor, false);
        } else {
          alert("There is no last color to load...");
        }
      }

      /**
       * set the color, place the picker
       * @param rgba
       * @param setInitial
       * @private
       */

    }, {
      key: '_setColor',
      value: function _setColor(rgba) {
        var setInitial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        // store the initial color
        if (setInitial === true) {
          this.initialColor = util.extend({}, rgba);
        }

        this.color = rgba;
        var hsv = util.RGBToHSV(rgba.r, rgba.g, rgba.b);

        var angleConvert = 2 * Math.PI;
        var radius = this.r * hsv.s;
        var x = this.centerCoordinates.x + radius * Math.sin(angleConvert * hsv.h);
        var y = this.centerCoordinates.y + radius * Math.cos(angleConvert * hsv.h);

        this.colorPickerSelector.style.left = x - 0.5 * this.colorPickerSelector.clientWidth + 'px';
        this.colorPickerSelector.style.top = y - 0.5 * this.colorPickerSelector.clientHeight + 'px';

        this._updatePicker(rgba);
      }

      /**
       * bound to opacity control
       * @param value
       * @private
       */

    }, {
      key: '_setOpacity',
      value: function _setOpacity(value) {
        this.color.a = value / 100;
        this._updatePicker(this.color);
      }

      /**
       * bound to brightness control
       * @param value
       * @private
       */

    }, {
      key: '_setBrightness',
      value: function _setBrightness(value) {
        var hsv = util.RGBToHSV(this.color.r, this.color.g, this.color.b);
        hsv.v = value / 100;
        var rgba = util.HSVToRGB(hsv.h, hsv.s, hsv.v);
        rgba['a'] = this.color.a;
        this.color = rgba;
        this._updatePicker();
      }

      /**
       * update the color picker. A black circle overlays the hue circle to mimic the brightness decreasing.
       * @param rgba
       * @private
       */

    }, {
      key: '_updatePicker',
      value: function _updatePicker() {
        var rgba = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.color;

        var hsv = util.RGBToHSV(rgba.r, rgba.g, rgba.b);
        var ctx = this.colorPickerCanvas.getContext('2d');
        if (this.pixelRation === undefined) {
          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
        }
        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);

        // clear the canvas
        var w = this.colorPickerCanvas.clientWidth;
        var h = this.colorPickerCanvas.clientHeight;
        ctx.clearRect(0, 0, w, h);

        ctx.putImageData(this.hueCircle, 0, 0);
        ctx.fillStyle = 'rgba(0,0,0,' + (1 - hsv.v) + ')';
        ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
        ctx.fill();

        this.brightnessRange.value = 100 * hsv.v;
        this.opacityRange.value = 100 * rgba.a;

        this.initialColorDiv.style.backgroundColor = 'rgba(' + this.initialColor.r + ',' + this.initialColor.g + ',' + this.initialColor.b + ',' + this.initialColor.a + ')';
        this.newColorDiv.style.backgroundColor = 'rgba(' + this.color.r + ',' + this.color.g + ',' + this.color.b + ',' + this.color.a + ')';
      }

      /**
       * used by create to set the size of the canvas.
       * @private
       */

    }, {
      key: '_setSize',
      value: function _setSize() {
        this.colorPickerCanvas.style.width = '100%';
        this.colorPickerCanvas.style.height = '100%';

        this.colorPickerCanvas.width = 289 * this.pixelRatio;
        this.colorPickerCanvas.height = 289 * this.pixelRatio;
      }

      /**
       * create all dom elements
       * TODO: cleanup, lots of similar dom elements
       * @private
       */

    }, {
      key: '_create',
      value: function _create() {
        this.frame = document.createElement('div');
        this.frame.className = 'vis-color-picker';

        this.colorPickerDiv = document.createElement('div');
        this.colorPickerSelector = document.createElement('div');
        this.colorPickerSelector.className = 'vis-selector';
        this.colorPickerDiv.appendChild(this.colorPickerSelector);

        this.colorPickerCanvas = document.createElement('canvas');
        this.colorPickerDiv.appendChild(this.colorPickerCanvas);

        if (!this.colorPickerCanvas.getContext) {
          var noCanvas = document.createElement('DIV');
          noCanvas.style.color = 'red';
          noCanvas.style.fontWeight = 'bold';
          noCanvas.style.padding = '10px';
          noCanvas.innerHTML = 'Error: your browser does not support HTML canvas';
          this.colorPickerCanvas.appendChild(noCanvas);
        } else {
          var ctx = this.colorPickerCanvas.getContext("2d");
          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);

          this.colorPickerCanvas.getContext("2d").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
        }

        this.colorPickerDiv.className = 'vis-color';

        this.opacityDiv = document.createElement('div');
        this.opacityDiv.className = 'vis-opacity';

        this.brightnessDiv = document.createElement('div');
        this.brightnessDiv.className = 'vis-brightness';

        this.arrowDiv = document.createElement('div');
        this.arrowDiv.className = 'vis-arrow';

        this.opacityRange = document.createElement('input');
        try {
          this.opacityRange.type = 'range'; // Not supported on IE9
          this.opacityRange.min = '0';
          this.opacityRange.max = '100';
        } catch (err) {}
        this.opacityRange.value = '100';
        this.opacityRange.className = 'vis-range';

        this.brightnessRange = document.createElement('input');
        try {
          this.brightnessRange.type = 'range'; // Not supported on IE9
          this.brightnessRange.min = '0';
          this.brightnessRange.max = '100';
        } catch (err) {}
        this.brightnessRange.value = '100';
        this.brightnessRange.className = 'vis-range';

        this.opacityDiv.appendChild(this.opacityRange);
        this.brightnessDiv.appendChild(this.brightnessRange);

        var me = this;
        this.opacityRange.onchange = function () {
          me._setOpacity(this.value);
        };
        this.opacityRange.oninput = function () {
          me._setOpacity(this.value);
        };
        this.brightnessRange.onchange = function () {
          me._setBrightness(this.value);
        };
        this.brightnessRange.oninput = function () {
          me._setBrightness(this.value);
        };

        this.brightnessLabel = document.createElement("div");
        this.brightnessLabel.className = "vis-label vis-brightness";
        this.brightnessLabel.innerHTML = 'brightness:';

        this.opacityLabel = document.createElement("div");
        this.opacityLabel.className = "vis-label vis-opacity";
        this.opacityLabel.innerHTML = 'opacity:';

        this.newColorDiv = document.createElement("div");
        this.newColorDiv.className = "vis-new-color";
        this.newColorDiv.innerHTML = 'new';

        this.initialColorDiv = document.createElement("div");
        this.initialColorDiv.className = "vis-initial-color";
        this.initialColorDiv.innerHTML = 'initial';

        this.cancelButton = document.createElement("div");
        this.cancelButton.className = "vis-button vis-cancel";
        this.cancelButton.innerHTML = 'cancel';
        this.cancelButton.onclick = this._hide.bind(this, false);

        this.applyButton = document.createElement("div");
        this.applyButton.className = "vis-button vis-apply";
        this.applyButton.innerHTML = 'apply';
        this.applyButton.onclick = this._apply.bind(this);

        this.saveButton = document.createElement("div");
        this.saveButton.className = "vis-button vis-save";
        this.saveButton.innerHTML = 'save';
        this.saveButton.onclick = this._save.bind(this);

        this.loadButton = document.createElement("div");
        this.loadButton.className = "vis-button vis-load";
        this.loadButton.innerHTML = 'load last';
        this.loadButton.onclick = this._loadLast.bind(this);

        this.frame.appendChild(this.colorPickerDiv);
        this.frame.appendChild(this.arrowDiv);
        this.frame.appendChild(this.brightnessLabel);
        this.frame.appendChild(this.brightnessDiv);
        this.frame.appendChild(this.opacityLabel);
        this.frame.appendChild(this.opacityDiv);
        this.frame.appendChild(this.newColorDiv);
        this.frame.appendChild(this.initialColorDiv);

        this.frame.appendChild(this.cancelButton);
        this.frame.appendChild(this.applyButton);
        this.frame.appendChild(this.saveButton);
        this.frame.appendChild(this.loadButton);
      }

      /**
       * bind hammer to the color picker
       * @private
       */

    }, {
      key: '_bindHammer',
      value: function _bindHammer() {
        var _this2 = this;

        this.drag = {};
        this.pinch = {};
        this.hammer = new Hammer(this.colorPickerCanvas);
        this.hammer.get('pinch').set({ enable: true });

        hammerUtil.onTouch(this.hammer, function (event) {
          _this2._moveSelector(event);
        });
        this.hammer.on('tap', function (event) {
          _this2._moveSelector(event);
        });
        this.hammer.on('panstart', function (event) {
          _this2._moveSelector(event);
        });
        this.hammer.on('panmove', function (event) {
          _this2._moveSelector(event);
        });
        this.hammer.on('panend', function (event) {
          _this2._moveSelector(event);
        });
      }

      /**
       * generate the hue circle. This is relatively heavy (200ms) and is done only once on the first time it is shown.
       * @private
       */

    }, {
      key: '_generateHueCircle',
      value: function _generateHueCircle() {
        if (this.generated === false) {
          var ctx = this.colorPickerCanvas.getContext('2d');
          if (this.pixelRation === undefined) {
            this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
          }
          ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);

          // clear the canvas
          var w = this.colorPickerCanvas.clientWidth;
          var h = this.colorPickerCanvas.clientHeight;
          ctx.clearRect(0, 0, w, h);

          // draw hue circle
          var x = void 0,
              y = void 0,
              hue = void 0,
              sat = void 0;
          this.centerCoordinates = { x: w * 0.5, y: h * 0.5 };
          this.r = 0.49 * w;
          var angleConvert = 2 * Math.PI / 360;
          var hfac = 1 / 360;
          var sfac = 1 / this.r;
          var rgb = void 0;
          for (hue = 0; hue < 360; hue++) {
            for (sat = 0; sat < this.r; sat++) {
              x = this.centerCoordinates.x + sat * Math.sin(angleConvert * hue);
              y = this.centerCoordinates.y + sat * Math.cos(angleConvert * hue);
              rgb = util.HSVToRGB(hue * hfac, sat * sfac, 1);
              ctx.fillStyle = 'rgb(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ')';
              ctx.fillRect(x - 0.5, y - 0.5, 2, 2);
            }
          }
          ctx.strokeStyle = 'rgba(0,0,0,1)';
          ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
          ctx.stroke();

          this.hueCircle = ctx.getImageData(0, 0, w, h);
        }
        this.generated = true;
      }

      /**
       * move the selector. This is called by hammer functions.
       *
       * @param event
       * @private
       */

    }, {
      key: '_moveSelector',
      value: function _moveSelector(event) {
        var rect = this.colorPickerDiv.getBoundingClientRect();
        var left = event.center.x - rect.left;
        var top = event.center.y - rect.top;

        var centerY = 0.5 * this.colorPickerDiv.clientHeight;
        var centerX = 0.5 * this.colorPickerDiv.clientWidth;

        var x = left - centerX;
        var y = top - centerY;

        var angle = Math.atan2(x, y);
        var radius = 0.98 * Math.min(Math.sqrt(x * x + y * y), centerX);

        var newTop = Math.cos(angle) * radius + centerY;
        var newLeft = Math.sin(angle) * radius + centerX;

        this.colorPickerSelector.style.top = newTop - 0.5 * this.colorPickerSelector.clientHeight + 'px';
        this.colorPickerSelector.style.left = newLeft - 0.5 * this.colorPickerSelector.clientWidth + 'px';

        // set color
        var h = angle / (2 * Math.PI);
        h = h < 0 ? h + 1 : h;
        var s = radius / this.r;
        var hsv = util.RGBToHSV(this.color.r, this.color.g, this.color.b);
        hsv.h = h;
        hsv.s = s;
        var rgba = util.HSVToRGB(hsv.h, hsv.s, hsv.v);
        rgba['a'] = this.color.a;
        this.color = rgba;

        // update previews
        this.initialColorDiv.style.backgroundColor = 'rgba(' + this.initialColor.r + ',' + this.initialColor.g + ',' + this.initialColor.b + ',' + this.initialColor.a + ')';
        this.newColorDiv.style.backgroundColor = 'rgba(' + this.color.r + ',' + this.color.g + ',' + this.color.b + ',' + this.color.a + ')';
      }
    }]);

    return ColorPicker;
  }();

  exports.default = ColorPicker;

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Hammer = __webpack_require__(22);

  /**
   * Register a touch event, taking place before a gesture
   * @param {Hammer} hammer       A hammer instance
   * @param {function} callback   Callback, called as callback(event)
   */
  exports.onTouch = function (hammer, callback) {
    callback.inputHandler = function (event) {
      if (event.isFirst) {
        callback(event);
      }
    };

    hammer.on('hammer.input', callback.inputHandler);
  };

  /**
   * Register a release event, taking place after a gesture
   * @param {Hammer} hammer       A hammer instance
   * @param {function} callback   Callback, called as callback(event)
   */
  exports.onRelease = function (hammer, callback) {
    callback.inputHandler = function (event) {
      if (event.isFinal) {
        callback(event);
      }
    };

    return hammer.on('hammer.input', callback.inputHandler);
  };

  /**
   * Unregister a touch event, taking place before a gesture
   * @param {Hammer} hammer       A hammer instance
   * @param {function} callback   Callback, called as callback(event)
   */
  exports.offTouch = function (hammer, callback) {
    hammer.off('hammer.input', callback.inputHandler);
  };

  /**
   * Unregister a release event, taking place before a gesture
   * @param {Hammer} hammer       A hammer instance
   * @param {function} callback   Callback, called as callback(event)
   */
  exports.offRelease = exports.offTouch;

  /**
   * Hack the PinchRecognizer such that it doesn't prevent default behavior
   * for vertical panning.
   *
   * Yeah ... this is quite a hack ... see https://github.com/hammerjs/hammer.js/issues/932
   *
   * @param {Hammer.Pinch} pinchRecognizer
   * @return {Hammer.Pinch} returns the pinchRecognizer
   */
  exports.disablePreventDefaultVertically = function (pinchRecognizer) {
    var TOUCH_ACTION_PAN_Y = 'pan-y';

    pinchRecognizer.getTouchAction = function () {
      // default method returns [TOUCH_ACTION_NONE]
      return [TOUCH_ACTION_PAN_Y];
    };

    return pinchRecognizer;
  };

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var errorFound = false;
  var allOptions = void 0;
  var printStyle = 'background: #FFeeee; color: #dd0000';
  /**
   *  Used to validate options.
   */

  var Validator = function () {
    function Validator() {
      _classCallCheck(this, Validator);
    }

    /**
     * Main function to be called
     * @param options
     * @param subObject
     * @returns {boolean}
     */


    _createClass(Validator, null, [{
      key: 'validate',
      value: function validate(options, referenceOptions, subObject) {
        errorFound = false;
        allOptions = referenceOptions;
        var usedOptions = referenceOptions;
        if (subObject !== undefined) {
          usedOptions = referenceOptions[subObject];
        }
        Validator.parse(options, usedOptions, []);
        return errorFound;
      }

      /**
       * Will traverse an object recursively and check every value
       * @param options
       * @param referenceOptions
       * @param path
       */

    }, {
      key: 'parse',
      value: function parse(options, referenceOptions, path) {
        for (var option in options) {
          if (options.hasOwnProperty(option)) {
            Validator.check(option, options, referenceOptions, path);
          }
        }
      }

      /**
       * Check every value. If the value is an object, call the parse function on that object.
       * @param option
       * @param options
       * @param referenceOptions
       * @param path
       */

    }, {
      key: 'check',
      value: function check(option, options, referenceOptions, path) {
        if (referenceOptions[option] === undefined && referenceOptions.__any__ === undefined) {
          Validator.getSuggestion(option, referenceOptions, path);
        } else if (referenceOptions[option] === undefined && referenceOptions.__any__ !== undefined) {
          // __any__ is a wildcard. Any value is accepted and will be further analysed by reference.
          if (Validator.getType(options[option]) === 'object' && referenceOptions['__any__'].__type__ !== undefined) {
            // if the any subgroup is not a predefined object int he configurator we do not look deeper into the object.
            Validator.checkFields(option, options, referenceOptions, '__any__', referenceOptions['__any__'].__type__, path);
          } else {
            Validator.checkFields(option, options, referenceOptions, '__any__', referenceOptions['__any__'], path);
          }
        } else {
          // Since all options in the reference are objects, we can check whether they are supposed to be object to look for the __type__ field.
          if (referenceOptions[option].__type__ !== undefined) {
            // if this should be an object, we check if the correct type has been supplied to account for shorthand options.
            Validator.checkFields(option, options, referenceOptions, option, referenceOptions[option].__type__, path);
          } else {
            Validator.checkFields(option, options, referenceOptions, option, referenceOptions[option], path);
          }
        }
      }

      /**
       *
       * @param {String}  option     | the option property
       * @param {Object}  options    | The supplied options object
       * @param {Object}  referenceOptions    | The reference options containing all options and their allowed formats
       * @param {String}  referenceOption     | Usually this is the same as option, except when handling an __any__ tag.
       * @param {String}  refOptionType       | This is the type object from the reference options
       * @param {Array}   path      | where in the object is the option
       */

    }, {
      key: 'checkFields',
      value: function checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path) {
        var optionType = Validator.getType(options[option]);
        var refOptionType = refOptionObj[optionType];
        if (refOptionType !== undefined) {
          // if the type is correct, we check if it is supposed to be one of a few select values
          if (Validator.getType(refOptionType) === 'array') {
            if (refOptionType.indexOf(options[option]) === -1) {
              console.log('%cInvalid option detected in "' + option + '".' + ' Allowed values are:' + Validator.print(refOptionType) + ' not "' + options[option] + '". ' + Validator.printLocation(path, option), printStyle);
              errorFound = true;
            } else if (optionType === 'object' && referenceOption !== "__any__") {
              path = util.copyAndExtendArray(path, option);
              Validator.parse(options[option], referenceOptions[referenceOption], path);
            }
          } else if (optionType === 'object' && referenceOption !== "__any__") {
            path = util.copyAndExtendArray(path, option);
            Validator.parse(options[option], referenceOptions[referenceOption], path);
          }
        } else if (refOptionObj['any'] === undefined) {
          // type of the field is incorrect and the field cannot be any
          console.log('%cInvalid type received for "' + option + '". Expected: ' + Validator.print(Object.keys(refOptionObj)) + '. Received [' + optionType + '] "' + options[option] + '"' + Validator.printLocation(path, option), printStyle);
          errorFound = true;
        }
      }
    }, {
      key: 'getType',
      value: function getType(object) {
        var type = typeof object === 'undefined' ? 'undefined' : _typeof(object);

        if (type === 'object') {
          if (object === null) {
            return 'null';
          }
          if (object instanceof Boolean) {
            return 'boolean';
          }
          if (object instanceof Number) {
            return 'number';
          }
          if (object instanceof String) {
            return 'string';
          }
          if (Array.isArray(object)) {
            return 'array';
          }
          if (object instanceof Date) {
            return 'date';
          }
          if (object.nodeType !== undefined) {
            return 'dom';
          }
          if (object._isAMomentObject === true) {
            return 'moment';
          }
          return 'object';
        } else if (type === 'number') {
          return 'number';
        } else if (type === 'boolean') {
          return 'boolean';
        } else if (type === 'string') {
          return 'string';
        } else if (type === undefined) {
          return 'undefined';
        }
        return type;
      }
    }, {
      key: 'getSuggestion',
      value: function getSuggestion(option, options, path) {
        var localSearch = Validator.findInOptions(option, options, path, false);
        var globalSearch = Validator.findInOptions(option, allOptions, [], true);

        var localSearchThreshold = 8;
        var globalSearchThreshold = 4;

        if (localSearch.indexMatch !== undefined) {
          console.log('%cUnknown option detected: "' + option + '" in ' + Validator.printLocation(localSearch.path, option, '') + 'Perhaps it was incomplete? Did you mean: "' + localSearch.indexMatch + '"?\n\n', printStyle);
        } else if (globalSearch.distance <= globalSearchThreshold && localSearch.distance > globalSearch.distance) {
          console.log('%cUnknown option detected: "' + option + '" in ' + Validator.printLocation(localSearch.path, option, '') + 'Perhaps it was misplaced? Matching option found at: ' + Validator.printLocation(globalSearch.path, globalSearch.closestMatch, ''), printStyle);
        } else if (localSearch.distance <= localSearchThreshold) {
          console.log('%cUnknown option detected: "' + option + '". Did you mean "' + localSearch.closestMatch + '"?' + Validator.printLocation(localSearch.path, option), printStyle);
        } else {
          console.log('%cUnknown option detected: "' + option + '". Did you mean one of these: ' + Validator.print(Object.keys(options)) + Validator.printLocation(path, option), printStyle);
        }

        errorFound = true;
      }

      /**
       * traverse the options in search for a match.
       * @param option
       * @param options
       * @param path
       * @param recursive
       * @returns {{closestMatch: string, path: Array, distance: number}}
       */

    }, {
      key: 'findInOptions',
      value: function findInOptions(option, options, path) {
        var recursive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

        var min = 1e9;
        var closestMatch = '';
        var closestMatchPath = [];
        var lowerCaseOption = option.toLowerCase();
        var indexMatch = undefined;
        for (var op in options) {
          var distance = void 0;
          if (options[op].__type__ !== undefined && recursive === true) {
            var result = Validator.findInOptions(option, options[op], util.copyAndExtendArray(path, op));
            if (min > result.distance) {
              closestMatch = result.closestMatch;
              closestMatchPath = result.path;
              min = result.distance;
              indexMatch = result.indexMatch;
            }
          } else {
            if (op.toLowerCase().indexOf(lowerCaseOption) !== -1) {
              indexMatch = op;
            }
            distance = Validator.levenshteinDistance(option, op);
            if (min > distance) {
              closestMatch = op;
              closestMatchPath = util.copyArray(path);
              min = distance;
            }
          }
        }
        return { closestMatch: closestMatch, path: closestMatchPath, distance: min, indexMatch: indexMatch };
      }
    }, {
      key: 'printLocation',
      value: function printLocation(path, option) {
        var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'Problem value found at: \n';

        var str = '\n\n' + prefix + 'options = {\n';
        for (var i = 0; i < path.length; i++) {
          for (var j = 0; j < i + 1; j++) {
            str += '  ';
          }
          str += path[i] + ': {\n';
        }
        for (var _j = 0; _j < path.length + 1; _j++) {
          str += '  ';
        }
        str += option + '\n';
        for (var _i = 0; _i < path.length + 1; _i++) {
          for (var _j2 = 0; _j2 < path.length - _i; _j2++) {
            str += '  ';
          }
          str += '}\n';
        }
        return str + '\n\n';
      }
    }, {
      key: 'print',
      value: function print(options) {
        return JSON.stringify(options).replace(/(\")|(\[)|(\])|(,"__type__")/g, "").replace(/(\,)/g, ', ');
      }

      // Compute the edit distance between the two given strings
      // http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript
      /*
       Copyright (c) 2011 Andrei Mackenzie
        Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
        The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
       */

    }, {
      key: 'levenshteinDistance',
      value: function levenshteinDistance(a, b) {
        if (a.length === 0) return b.length;
        if (b.length === 0) return a.length;

        var matrix = [];

        // increment along the first column of each row
        var i;
        for (i = 0; i <= b.length; i++) {
          matrix[i] = [i];
        }

        // increment each column in the first row
        var j;
        for (j = 0; j <= a.length; j++) {
          matrix[0][j] = j;
        }

        // Fill in the rest of the matrix
        for (i = 1; i <= b.length; i++) {
          for (j = 1; j <= a.length; j++) {
            if (b.charAt(i - 1) == a.charAt(j - 1)) {
              matrix[i][j] = matrix[i - 1][j - 1];
            } else {
              matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution
              Math.min(matrix[i][j - 1] + 1, // insertion
              matrix[i - 1][j] + 1)); // deletion
            }
          }
        }

        return matrix[b.length][a.length];
      }
    }]);

    return Validator;
  }();

  exports.default = Validator;
  exports.printStyle = printStyle;

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var util = __webpack_require__(1);
  var hammerUtil = __webpack_require__(30);
  var moment = __webpack_require__(2);
  var Component = __webpack_require__(33);
  var DateUtil = __webpack_require__(34);

  /**
   * @constructor Range
   * A Range controls a numeric range with a start and end value.
   * The Range adjusts the range based on mouse events or programmatic changes,
   * and triggers events when the range is changing or has been changed.
   * @param {{dom: Object, domProps: Object, emitter: Emitter}} body
   * @param {Object} [options]    See description at Range.setOptions
   */
  function Range(body, options) {
    var now = moment().hours(0).minutes(0).seconds(0).milliseconds(0);
    this.start = now.clone().add(-3, 'days').valueOf(); // Number
    this.end = now.clone().add(4, 'days').valueOf(); // Number

    this.body = body;
    this.deltaDifference = 0;
    this.scaleOffset = 0;
    this.startToFront = false;
    this.endToFront = true;

    // default options
    this.defaultOptions = {
      rtl: false,
      start: null,
      end: null,
      moment: moment,
      direction: 'horizontal', // 'horizontal' or 'vertical'
      moveable: true,
      zoomable: true,
      min: null,
      max: null,
      zoomMin: 10, // milliseconds
      zoomMax: 1000 * 60 * 60 * 24 * 365 * 10000 // milliseconds
    };
    this.options = util.extend({}, this.defaultOptions);
    this.props = {
      touch: {}
    };
    this.animationTimer = null;

    // drag listeners for dragging
    this.body.emitter.on('panstart', this._onDragStart.bind(this));
    this.body.emitter.on('panmove', this._onDrag.bind(this));
    this.body.emitter.on('panend', this._onDragEnd.bind(this));

    // mouse wheel for zooming
    this.body.emitter.on('mousewheel', this._onMouseWheel.bind(this));

    // pinch to zoom
    this.body.emitter.on('touch', this._onTouch.bind(this));
    this.body.emitter.on('pinch', this._onPinch.bind(this));

    this.setOptions(options);
  }

  Range.prototype = new Component();

  /**
   * Set options for the range controller
   * @param {Object} options      Available options:
   *                              {Number | Date | String} start  Start date for the range
   *                              {Number | Date | String} end    End date for the range
   *                              {Number} min    Minimum value for start
   *                              {Number} max    Maximum value for end
   *                              {Number} zoomMin    Set a minimum value for
   *                                                  (end - start).
   *                              {Number} zoomMax    Set a maximum value for
   *                                                  (end - start).
   *                              {Boolean} moveable Enable moving of the range
   *                                                 by dragging. True by default
   *                              {Boolean} zoomable Enable zooming of the range
   *                                                 by pinching/scrolling. True by default
   */
  Range.prototype.setOptions = function (options) {
    if (options) {
      // copy the options that we know
      var fields = ['direction', 'min', 'max', 'zoomMin', 'zoomMax', 'moveable', 'zoomable', 'moment', 'activate', 'hiddenDates', 'zoomKey', 'rtl', 'horizontalScroll'];
      util.selectiveExtend(fields, this.options, options);

      if ('start' in options || 'end' in options) {
        // apply a new range. both start and end are optional
        this.setRange(options.start, options.end);
      }
    }
  };

  /**
   * Test whether direction has a valid value
   * @param {String} direction    'horizontal' or 'vertical'
   */
  function validateDirection(direction) {
    if (direction != 'horizontal' && direction != 'vertical') {
      throw new TypeError('Unknown direction "' + direction + '". ' + 'Choose "horizontal" or "vertical".');
    }
  }

  /**
   * Set a new start and end range
   * @param {Date | Number | String} [start]
   * @param {Date | Number | String} [end]
   * @param {boolean | {duration: number, easingFunction: string}} [animation=false]
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   * @param {Boolean} [byUser=false]
   *
   */
  Range.prototype.setRange = function (start, end, animation, byUser) {
    if (byUser !== true) {
      byUser = false;
    }
    var finalStart = start != undefined ? util.convert(start, 'Date').valueOf() : null;
    var finalEnd = end != undefined ? util.convert(end, 'Date').valueOf() : null;
    this._cancelAnimation();

    if (animation) {
      // true or an Object
      var me = this;
      var initStart = this.start;
      var initEnd = this.end;
      var duration = (typeof animation === 'undefined' ? 'undefined' : _typeof(animation)) === 'object' && 'duration' in animation ? animation.duration : 500;
      var easingName = (typeof animation === 'undefined' ? 'undefined' : _typeof(animation)) === 'object' && 'easingFunction' in animation ? animation.easingFunction : 'easeInOutQuad';
      var easingFunction = util.easingFunctions[easingName];
      if (!easingFunction) {
        throw new Error('Unknown easing function ' + JSON.stringify(easingName) + '. ' + 'Choose from: ' + Object.keys(util.easingFunctions).join(', '));
      }

      var initTime = new Date().valueOf();
      var anyChanged = false;

      var next = function next() {
        if (!me.props.touch.dragging) {
          var now = new Date().valueOf();
          var time = now - initTime;
          var ease = easingFunction(time / duration);
          var done = time > duration;
          var s = done || finalStart === null ? finalStart : initStart + (finalStart - initStart) * ease;
          var e = done || finalEnd === null ? finalEnd : initEnd + (finalEnd - initEnd) * ease;

          changed = me._applyRange(s, e);
          DateUtil.updateHiddenDates(me.options.moment, me.body, me.options.hiddenDates);
          anyChanged = anyChanged || changed;
          if (changed) {
            me.body.emitter.emit('rangechange', { start: new Date(me.start), end: new Date(me.end), byUser: byUser });
          }

          if (done) {
            if (anyChanged) {
              me.body.emitter.emit('rangechanged', { start: new Date(me.start), end: new Date(me.end), byUser: byUser });
            }
          } else {
            // animate with as high as possible frame rate, leave 20 ms in between
            // each to prevent the browser from blocking
            me.animationTimer = setTimeout(next, 20);
          }
        }
      };

      return next();
    } else {
      var changed = this._applyRange(finalStart, finalEnd);
      DateUtil.updateHiddenDates(this.options.moment, this.body, this.options.hiddenDates);
      if (changed) {
        var params = { start: new Date(this.start), end: new Date(this.end), byUser: byUser };
        this.body.emitter.emit('rangechange', params);
        this.body.emitter.emit('rangechanged', params);
      }
    }
  };

  /**
   * Stop an animation
   * @private
   */
  Range.prototype._cancelAnimation = function () {
    if (this.animationTimer) {
      clearTimeout(this.animationTimer);
      this.animationTimer = null;
    }
  };

  /**
   * Set a new start and end range. This method is the same as setRange, but
   * does not trigger a range change and range changed event, and it returns
   * true when the range is changed
   * @param {Number} [start]
   * @param {Number} [end]
   * @return {Boolean} changed
   * @private
   */
  Range.prototype._applyRange = function (start, end) {
    var newStart = start != null ? util.convert(start, 'Date').valueOf() : this.start,
        newEnd = end != null ? util.convert(end, 'Date').valueOf() : this.end,
        max = this.options.max != null ? util.convert(this.options.max, 'Date').valueOf() : null,
        min = this.options.min != null ? util.convert(this.options.min, 'Date').valueOf() : null,
        diff;

    // check for valid number
    if (isNaN(newStart) || newStart === null) {
      throw new Error('Invalid start "' + start + '"');
    }
    if (isNaN(newEnd) || newEnd === null) {
      throw new Error('Invalid end "' + end + '"');
    }

    // prevent start < end
    if (newEnd < newStart) {
      newEnd = newStart;
    }

    // prevent start < min
    if (min !== null) {
      if (newStart < min) {
        diff = min - newStart;
        newStart += diff;
        newEnd += diff;

        // prevent end > max
        if (max != null) {
          if (newEnd > max) {
            newEnd = max;
          }
        }
      }
    }

    // prevent end > max
    if (max !== null) {
      if (newEnd > max) {
        diff = newEnd - max;
        newStart -= diff;
        newEnd -= diff;

        // prevent start < min
        if (min != null) {
          if (newStart < min) {
            newStart = min;
          }
        }
      }
    }

    // prevent (end-start) < zoomMin
    if (this.options.zoomMin !== null) {
      var zoomMin = parseFloat(this.options.zoomMin);
      if (zoomMin < 0) {
        zoomMin = 0;
      }
      if (newEnd - newStart < zoomMin) {
        if (this.end - this.start === zoomMin && newStart > this.start && newEnd < this.end) {
          // ignore this action, we are already zoomed to the minimum
          newStart = this.start;
          newEnd = this.end;
        } else {
          // zoom to the minimum
          diff = zoomMin - (newEnd - newStart);
          newStart -= diff / 2;
          newEnd += diff / 2;
        }
      }
    }

    // prevent (end-start) > zoomMax
    if (this.options.zoomMax !== null) {
      var zoomMax = parseFloat(this.options.zoomMax);
      if (zoomMax < 0) {
        zoomMax = 0;
      }

      if (newEnd - newStart > zoomMax) {
        if (this.end - this.start === zoomMax && newStart < this.start && newEnd > this.end) {
          // ignore this action, we are already zoomed to the maximum
          newStart = this.start;
          newEnd = this.end;
        } else {
          // zoom to the maximum
          diff = newEnd - newStart - zoomMax;
          newStart += diff / 2;
          newEnd -= diff / 2;
        }
      }
    }

    var changed = this.start != newStart || this.end != newEnd;

    // if the new range does NOT overlap with the old range, emit checkRangedItems to avoid not showing ranged items (ranged meaning has end time, not necessarily of type Range)
    if (!(newStart >= this.start && newStart <= this.end || newEnd >= this.start && newEnd <= this.end) && !(this.start >= newStart && this.start <= newEnd || this.end >= newStart && this.end <= newEnd)) {
      this.body.emitter.emit('checkRangedItems');
    }

    this.start = newStart;
    this.end = newEnd;
    return changed;
  };

  /**
   * Retrieve the current range.
   * @return {Object} An object with start and end properties
   */
  Range.prototype.getRange = function () {
    return {
      start: this.start,
      end: this.end
    };
  };

  /**
   * Calculate the conversion offset and scale for current range, based on
   * the provided width
   * @param {Number} width
   * @returns {{offset: number, scale: number}} conversion
   */
  Range.prototype.conversion = function (width, totalHidden) {
    return Range.conversion(this.start, this.end, width, totalHidden);
  };

  /**
   * Static method to calculate the conversion offset and scale for a range,
   * based on the provided start, end, and width
   * @param {Number} start
   * @param {Number} end
   * @param {Number} width
   * @returns {{offset: number, scale: number}} conversion
   */
  Range.conversion = function (start, end, width, totalHidden) {
    if (totalHidden === undefined) {
      totalHidden = 0;
    }
    if (width != 0 && end - start != 0) {
      return {
        offset: start,
        scale: width / (end - start - totalHidden)
      };
    } else {
      return {
        offset: 0,
        scale: 1
      };
    }
  };

  /**
   * Start dragging horizontally or vertically
   * @param {Event} event
   * @private
   */
  Range.prototype._onDragStart = function (event) {
    this.deltaDifference = 0;
    this.previousDelta = 0;

    // only allow dragging when configured as movable
    if (!this.options.moveable) return;

    // only start dragging when the mouse is inside the current range
    if (!this._isInsideRange(event)) return;

    // refuse to drag when we where pinching to prevent the timeline make a jump
    // when releasing the fingers in opposite order from the touch screen
    if (!this.props.touch.allowDragging) return;

    this.props.touch.start = this.start;
    this.props.touch.end = this.end;
    this.props.touch.dragging = true;

    if (this.body.dom.root) {
      this.body.dom.root.style.cursor = 'move';
    }
  };

  /**
   * Perform dragging operation
   * @param {Event} event
   * @private
   */
  Range.prototype._onDrag = function (event) {
    if (!event) return;

    if (!this.props.touch.dragging) return;

    // only allow dragging when configured as movable
    if (!this.options.moveable) return;

    // TODO: this may be redundant in hammerjs2
    // refuse to drag when we where pinching to prevent the timeline make a jump
    // when releasing the fingers in opposite order from the touch screen
    if (!this.props.touch.allowDragging) return;

    var direction = this.options.direction;
    validateDirection(direction);
    var delta = direction == 'horizontal' ? event.deltaX : event.deltaY;
    delta -= this.deltaDifference;
    var interval = this.props.touch.end - this.props.touch.start;

    // normalize dragging speed if cutout is in between.
    var duration = DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
    interval -= duration;

    var width = direction == 'horizontal' ? this.body.domProps.center.width : this.body.domProps.center.height;

    if (this.options.rtl) {
      var diffRange = delta / width * interval;
    } else {
      var diffRange = -delta / width * interval;
    }

    var newStart = this.props.touch.start + diffRange;
    var newEnd = this.props.touch.end + diffRange;

    // snapping times away from hidden zones
    var safeStart = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newStart, this.previousDelta - delta, true);
    var safeEnd = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newEnd, this.previousDelta - delta, true);
    if (safeStart != newStart || safeEnd != newEnd) {
      this.deltaDifference += delta;
      this.props.touch.start = safeStart;
      this.props.touch.end = safeEnd;
      this._onDrag(event);
      return;
    }

    this.previousDelta = delta;
    this._applyRange(newStart, newEnd);

    var startDate = new Date(this.start);
    var endDate = new Date(this.end);

    // fire a rangechange event
    this.body.emitter.emit('rangechange', {
      start: startDate,
      end: endDate,
      byUser: true
    });

    // fire a panmove event
    this.body.emitter.emit('panmove');
  };

  /**
   * Stop dragging operation
   * @param {event} event
   * @private
   */
  Range.prototype._onDragEnd = function (event) {
    if (!this.props.touch.dragging) return;

    // only allow dragging when configured as movable
    if (!this.options.moveable) return;

    // TODO: this may be redundant in hammerjs2
    // refuse to drag when we where pinching to prevent the timeline make a jump
    // when releasing the fingers in opposite order from the touch screen
    if (!this.props.touch.allowDragging) return;

    this.props.touch.dragging = false;
    if (this.body.dom.root) {
      this.body.dom.root.style.cursor = 'auto';
    }

    // fire a rangechanged event
    this.body.emitter.emit('rangechanged', {
      start: new Date(this.start),
      end: new Date(this.end),
      byUser: true
    });
  };

  /**
   * Event handler for mouse wheel event, used to zoom
   * Code from http://adomas.org/javascript-mouse-wheel/
   * @param {Event} event
   * @private
   */
  Range.prototype._onMouseWheel = function (event) {
    // Prevent default actions caused by mouse wheel
    // (else the page and timeline both zoom and scroll)
    event.preventDefault();

    // retrieve delta
    var delta = 0;
    if (event.wheelDelta) {
      /* IE/Opera. */
      delta = event.wheelDelta / 120;
    } else if (event.detail) {
      /* Mozilla case. */
      // In Mozilla, sign of delta is different than in IE.
      // Also, delta is multiple of 3.
      delta = -event.detail / 3;
    }

    // don't allow zoom when the according key is pressed and the zoomKey option or not zoomable but movable
    if (this.options.zoomKey && !event[this.options.zoomKey] && this.options.zoomable || !this.options.zoomable && this.options.moveable) {
      if (this.options.horizontalScroll) {
        // calculate a single scroll jump relative to the range scale
        var diff = delta * (this.end - this.start) / 20;
        // calculate new start and end
        var newStart = this.start - diff;
        var newEnd = this.end - diff;

        this.setRange(newStart, newEnd);
      }
      return;
    }

    // only allow zooming when configured as zoomable and moveable
    if (!(this.options.zoomable && this.options.moveable)) return;

    // only zoom when the mouse is inside the current range
    if (!this._isInsideRange(event)) return;

    // If delta is nonzero, handle it.
    // Basically, delta is now positive if wheel was scrolled up,
    // and negative, if wheel was scrolled down.
    if (delta) {
      // perform the zoom action. Delta is normally 1 or -1

      // adjust a negative delta such that zooming in with delta 0.1
      // equals zooming out with a delta -0.1
      var scale;
      if (delta < 0) {
        scale = 1 - delta / 5;
      } else {
        scale = 1 / (1 + delta / 5);
      }

      // calculate center, the date to zoom around
      var pointer = this.getPointer({ x: event.clientX, y: event.clientY }, this.body.dom.center);
      var pointerDate = this._pointerToDate(pointer);

      this.zoom(scale, pointerDate, delta);
    }
  };

  /**
   * Start of a touch gesture
   * @private
   */
  Range.prototype._onTouch = function (event) {
    this.props.touch.start = this.start;
    this.props.touch.end = this.end;
    this.props.touch.allowDragging = true;
    this.props.touch.center = null;
    this.scaleOffset = 0;
    this.deltaDifference = 0;
  };

  /**
   * Handle pinch event
   * @param {Event} event
   * @private
   */
  Range.prototype._onPinch = function (event) {
    // only allow zooming when configured as zoomable and moveable
    if (!(this.options.zoomable && this.options.moveable)) return;

    this.props.touch.allowDragging = false;

    if (!this.props.touch.center) {
      this.props.touch.center = this.getPointer(event.center, this.body.dom.center);
    }

    var scale = 1 / (event.scale + this.scaleOffset);
    var centerDate = this._pointerToDate(this.props.touch.center);

    var hiddenDuration = DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
    var hiddenDurationBefore = DateUtil.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this, centerDate);
    var hiddenDurationAfter = hiddenDuration - hiddenDurationBefore;

    // calculate new start and end
    var newStart = centerDate - hiddenDurationBefore + (this.props.touch.start - (centerDate - hiddenDurationBefore)) * scale;
    var newEnd = centerDate + hiddenDurationAfter + (this.props.touch.end - (centerDate + hiddenDurationAfter)) * scale;

    // snapping times away from hidden zones
    this.startToFront = 1 - scale <= 0; // used to do the right auto correction with periodic hidden times
    this.endToFront = scale - 1 <= 0; // used to do the right auto correction with periodic hidden times

    var safeStart = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newStart, 1 - scale, true);
    var safeEnd = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newEnd, scale - 1, true);
    if (safeStart != newStart || safeEnd != newEnd) {
      this.props.touch.start = safeStart;
      this.props.touch.end = safeEnd;
      this.scaleOffset = 1 - event.scale;
      newStart = safeStart;
      newEnd = safeEnd;
    }

    this.setRange(newStart, newEnd, false, true);

    this.startToFront = false; // revert to default
    this.endToFront = true; // revert to default
  };

  /**
   * Test whether the mouse from a mouse event is inside the visible window,
   * between the current start and end date
   * @param {Object} event
   * @return {boolean} Returns true when inside the visible window
   * @private
   */
  Range.prototype._isInsideRange = function (event) {
    // calculate the time where the mouse is, check whether inside
    // and no scroll action should happen.
    var clientX = event.center ? event.center.x : event.clientX;
    if (this.options.rtl) {
      var x = clientX - util.getAbsoluteLeft(this.body.dom.centerContainer);
    } else {
      var x = util.getAbsoluteRight(this.body.dom.centerContainer) - clientX;
    }
    var time = this.body.util.toTime(x);

    return time >= this.start && time <= this.end;
  };

  /**
   * Helper function to calculate the center date for zooming
   * @param {{x: Number, y: Number}} pointer
   * @return {number} date
   * @private
   */
  Range.prototype._pointerToDate = function (pointer) {
    var conversion;
    var direction = this.options.direction;

    validateDirection(direction);

    if (direction == 'horizontal') {
      return this.body.util.toTime(pointer.x).valueOf();
    } else {
      var height = this.body.domProps.center.height;
      conversion = this.conversion(height);
      return pointer.y / conversion.scale + conversion.offset;
    }
  };

  /**
   * Get the pointer location relative to the location of the dom element
   * @param {{x: Number, y: Number}} touch
   * @param {Element} element   HTML DOM element
   * @return {{x: Number, y: Number}} pointer
   * @private
   */
  Range.prototype.getPointer = function (touch, element) {
    if (this.options.rtl) {
      return {
        x: util.getAbsoluteRight(element) - touch.x,
        y: touch.y - util.getAbsoluteTop(element)
      };
    } else {
      return {
        x: touch.x - util.getAbsoluteLeft(element),
        y: touch.y - util.getAbsoluteTop(element)
      };
    }
  };

  /**
   * Zoom the range the given scale in or out. Start and end date will
   * be adjusted, and the timeline will be redrawn. You can optionally give a
   * date around which to zoom.
   * For example, try scale = 0.9 or 1.1
   * @param {Number} scale      Scaling factor. Values above 1 will zoom out,
   *                            values below 1 will zoom in.
   * @param {Number} [center]   Value representing a date around which will
   *                            be zoomed.
   */
  Range.prototype.zoom = function (scale, center, delta) {
    // if centerDate is not provided, take it half between start Date and end Date
    if (center == null) {
      center = (this.start + this.end) / 2;
    }

    var hiddenDuration = DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
    var hiddenDurationBefore = DateUtil.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this, center);
    var hiddenDurationAfter = hiddenDuration - hiddenDurationBefore;

    // calculate new start and end
    var newStart = center - hiddenDurationBefore + (this.start - (center - hiddenDurationBefore)) * scale;
    var newEnd = center + hiddenDurationAfter + (this.end - (center + hiddenDurationAfter)) * scale;

    // snapping times away from hidden zones
    this.startToFront = delta > 0 ? false : true; // used to do the right autocorrection with periodic hidden times
    this.endToFront = -delta > 0 ? false : true; // used to do the right autocorrection with periodic hidden times
    var safeStart = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newStart, delta, true);
    var safeEnd = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newEnd, -delta, true);
    if (safeStart != newStart || safeEnd != newEnd) {
      newStart = safeStart;
      newEnd = safeEnd;
    }

    this.setRange(newStart, newEnd, false, true);

    this.startToFront = false; // revert to default
    this.endToFront = true; // revert to default
  };

  /**
   * Move the range with a given delta to the left or right. Start and end
   * value will be adjusted. For example, try delta = 0.1 or -0.1
   * @param {Number}  delta     Moving amount. Positive value will move right,
   *                            negative value will move left
   */
  Range.prototype.move = function (delta) {
    // zoom start Date and end Date relative to the centerDate
    var diff = this.end - this.start;

    // apply new values
    var newStart = this.start + diff * delta;
    var newEnd = this.end + diff * delta;

    // TODO: reckon with min and max range

    this.start = newStart;
    this.end = newEnd;
  };

  /**
   * Move the range to a new center point
   * @param {Number} moveTo      New center point of the range
   */
  Range.prototype.moveTo = function (moveTo) {
    var center = (this.start + this.end) / 2;

    var diff = center - moveTo;

    // calculate new start and end
    var newStart = this.start - diff;
    var newEnd = this.end - diff;

    this.setRange(newStart, newEnd);
  };

  module.exports = Range;

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);

  /**
   * Prototype for visual components
   * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} [body]
   * @param {Object} [options]
   */
  function Component(body, options) {
    this.options = null;
    this.props = null;
  }

  /**
   * Set options for the component. The new options will be merged into the
   * current options.
   * @param {Object} options
   */
  Component.prototype.setOptions = function (options) {
    if (options) {
      util.extend(this.options, options);
    }
  };

  /**
   * Repaint the component
   * @return {boolean} Returns true if the component is resized
   */
  Component.prototype.redraw = function () {
    // should be implemented by the component
    return false;
  };

  /**
   * Destroy the component. Cleanup DOM and event listeners
   */
  Component.prototype.destroy = function () {
    // should be implemented by the component
  };

  /**
   * Test whether the component is resized since the last time _isResized() was
   * called.
   * @return {Boolean} Returns true if the component is resized
   * @protected
   */
  Component.prototype._isResized = function () {
    var resized = this.props._previousWidth !== this.props.width || this.props._previousHeight !== this.props.height;

    this.props._previousWidth = this.props.width;
    this.props._previousHeight = this.props.height;

    return resized;
  };

  module.exports = Component;

/***/ },
/* 34 */
/***/ function(module, exports) {

  "use strict";

  /**
   * used in Core to convert the options into a volatile variable
   * 
   * @param {function} moment
   * @param {Object} body
   * @param {Array | Object} hiddenDates
   */
  exports.convertHiddenOptions = function (moment, body, hiddenDates) {
    if (hiddenDates && !Array.isArray(hiddenDates)) {
      return exports.convertHiddenOptions(moment, body, [hiddenDates]);
    }

    body.hiddenDates = [];
    if (hiddenDates) {
      if (Array.isArray(hiddenDates) == true) {
        for (var i = 0; i < hiddenDates.length; i++) {
          if (hiddenDates[i].repeat === undefined) {
            var dateItem = {};
            dateItem.start = moment(hiddenDates[i].start).toDate().valueOf();
            dateItem.end = moment(hiddenDates[i].end).toDate().valueOf();
            body.hiddenDates.push(dateItem);
          }
        }
        body.hiddenDates.sort(function (a, b) {
          return a.start - b.start;
        }); // sort by start time
      }
    }
  };

  /**
   * create new entrees for the repeating hidden dates
   * @param {function} moment
   * @param {Object} body
   * @param {Array | Object} hiddenDates
   */
  exports.updateHiddenDates = function (moment, body, hiddenDates) {
    if (hiddenDates && !Array.isArray(hiddenDates)) {
      return exports.updateHiddenDates(moment, body, [hiddenDates]);
    }

    if (hiddenDates && body.domProps.centerContainer.width !== undefined) {
      exports.convertHiddenOptions(moment, body, hiddenDates);

      var start = moment(body.range.start);
      var end = moment(body.range.end);

      var totalRange = body.range.end - body.range.start;
      var pixelTime = totalRange / body.domProps.centerContainer.width;

      for (var i = 0; i < hiddenDates.length; i++) {
        if (hiddenDates[i].repeat !== undefined) {
          var startDate = moment(hiddenDates[i].start);
          var endDate = moment(hiddenDates[i].end);

          if (startDate._d == "Invalid Date") {
            throw new Error("Supplied start date is not valid: " + hiddenDates[i].start);
          }
          if (endDate._d == "Invalid Date") {
            throw new Error("Supplied end date is not valid: " + hiddenDates[i].end);
          }

          var duration = endDate - startDate;
          if (duration >= 4 * pixelTime) {

            var offset = 0;
            var runUntil = end.clone();
            switch (hiddenDates[i].repeat) {
              case "daily":
                // case of time
                if (startDate.day() != endDate.day()) {
                  offset = 1;
                }
                startDate.dayOfYear(start.dayOfYear());
                startDate.year(start.year());
                startDate.subtract(7, 'days');

                endDate.dayOfYear(start.dayOfYear());
                endDate.year(start.year());
                endDate.subtract(7 - offset, 'days');

                runUntil.add(1, 'weeks');
                break;
              case "weekly":
                var dayOffset = endDate.diff(startDate, 'days');
                var day = startDate.day();

                // set the start date to the range.start
                startDate.date(start.date());
                startDate.month(start.month());
                startDate.year(start.year());
                endDate = startDate.clone();

                // force
                startDate.day(day);
                endDate.day(day);
                endDate.add(dayOffset, 'days');

                startDate.subtract(1, 'weeks');
                endDate.subtract(1, 'weeks');

                runUntil.add(1, 'weeks');
                break;
              case "monthly":
                if (startDate.month() != endDate.month()) {
                  offset = 1;
                }
                startDate.month(start.month());
                startDate.year(start.year());
                startDate.subtract(1, 'months');

                endDate.month(start.month());
                endDate.year(start.year());
                endDate.subtract(1, 'months');
                endDate.add(offset, 'months');

                runUntil.add(1, 'months');
                break;
              case "yearly":
                if (startDate.year() != endDate.year()) {
                  offset = 1;
                }
                startDate.year(start.year());
                startDate.subtract(1, 'years');
                endDate.year(start.year());
                endDate.subtract(1, 'years');
                endDate.add(offset, 'years');

                runUntil.add(1, 'years');
                break;
              default:
                console.log("Wrong repeat format, allowed are: daily, weekly, monthly, yearly. Given:", hiddenDates[i].repeat);
                return;
            }
            while (startDate < runUntil) {
              body.hiddenDates.push({ start: startDate.valueOf(), end: endDate.valueOf() });
              switch (hiddenDates[i].repeat) {
                case "daily":
                  startDate.add(1, 'days');
                  endDate.add(1, 'days');
                  break;
                case "weekly":
                  startDate.add(1, 'weeks');
                  endDate.add(1, 'weeks');
                  break;
                case "monthly":
                  startDate.add(1, 'months');
                  endDate.add(1, 'months');
                  break;
                case "yearly":
                  startDate.add(1, 'y');
                  endDate.add(1, 'y');
                  break;
                default:
                  console.log("Wrong repeat format, allowed are: daily, weekly, monthly, yearly. Given:", hiddenDates[i].repeat);
                  return;
              }
            }
            body.hiddenDates.push({ start: startDate.valueOf(), end: endDate.valueOf() });
          }
        }
      }
      // remove duplicates, merge where possible
      exports.removeDuplicates(body);
      // ensure the new positions are not on hidden dates
      var startHidden = exports.isHidden(body.range.start, body.hiddenDates);
      var endHidden = exports.isHidden(body.range.end, body.hiddenDates);
      var rangeStart = body.range.start;
      var rangeEnd = body.range.end;
      if (startHidden.hidden == true) {
        rangeStart = body.range.startToFront == true ? startHidden.startDate - 1 : startHidden.endDate + 1;
      }
      if (endHidden.hidden == true) {
        rangeEnd = body.range.endToFront == true ? endHidden.startDate - 1 : endHidden.endDate + 1;
      }
      if (startHidden.hidden == true || endHidden.hidden == true) {
        body.range._applyRange(rangeStart, rangeEnd);
      }
    }
  };

  /**
   * remove duplicates from the hidden dates list. Duplicates are evil. They mess everything up.
   * Scales with N^2
   * @param body
   */
  exports.removeDuplicates = function (body) {
    var hiddenDates = body.hiddenDates;
    var safeDates = [];
    for (var i = 0; i < hiddenDates.length; i++) {
      for (var j = 0; j < hiddenDates.length; j++) {
        if (i != j && hiddenDates[j].remove != true && hiddenDates[i].remove != true) {
          // j inside i
          if (hiddenDates[j].start >= hiddenDates[i].start && hiddenDates[j].end <= hiddenDates[i].end) {
            hiddenDates[j].remove = true;
          }
          // j start inside i
          else if (hiddenDates[j].start >= hiddenDates[i].start && hiddenDates[j].start <= hiddenDates[i].end) {
              hiddenDates[i].end = hiddenDates[j].end;
              hiddenDates[j].remove = true;
            }
            // j end inside i
            else if (hiddenDates[j].end >= hiddenDates[i].start && hiddenDates[j].end <= hiddenDates[i].end) {
                hiddenDates[i].start = hiddenDates[j].start;
                hiddenDates[j].remove = true;
              }
        }
      }
    }

    for (var i = 0; i < hiddenDates.length; i++) {
      if (hiddenDates[i].remove !== true) {
        safeDates.push(hiddenDates[i]);
      }
    }

    body.hiddenDates = safeDates;
    body.hiddenDates.sort(function (a, b) {
      return a.start - b.start;
    }); // sort by start time
  };

  exports.printDates = function (dates) {
    for (var i = 0; i < dates.length; i++) {
      console.log(i, new Date(dates[i].start), new Date(dates[i].end), dates[i].start, dates[i].end, dates[i].remove);
    }
  };

  /**
   * Used in TimeStep to avoid the hidden times.
   * @param {function} moment
   * @param {TimeStep} timeStep
   * @param previousTime
   */
  exports.stepOverHiddenDates = function (moment, timeStep, previousTime) {
    var stepInHidden = false;
    var currentValue = timeStep.current.valueOf();
    for (var i = 0; i < timeStep.hiddenDates.length; i++) {
      var startDate = timeStep.hiddenDates[i].start;
      var endDate = timeStep.hiddenDates[i].end;
      if (currentValue >= startDate && currentValue < endDate) {
        stepInHidden = true;
        break;
      }
    }

    if (stepInHidden == true && currentValue < timeStep._end.valueOf() && currentValue != previousTime) {
      var prevValue = moment(previousTime);
      var newValue = moment(endDate);
      //check if the next step should be major
      if (prevValue.year() != newValue.year()) {
        timeStep.switchedYear = true;
      } else if (prevValue.month() != newValue.month()) {
        timeStep.switchedMonth = true;
      } else if (prevValue.dayOfYear() != newValue.dayOfYear()) {
        timeStep.switchedDay = true;
      }

      timeStep.current = newValue;
    }
  };

  ///**
  // * Used in TimeStep to avoid the hidden times.
  // * @param timeStep
  // * @param previousTime
  // */
  //exports.checkFirstStep = function(timeStep) {
  //  var stepInHidden = false;
  //  var currentValue = timeStep.current.valueOf();
  //  for (var i = 0; i < timeStep.hiddenDates.length; i++) {
  //    var startDate = timeStep.hiddenDates[i].start;
  //    var endDate = timeStep.hiddenDates[i].end;
  //    if (currentValue >= startDate && currentValue < endDate) {
  //      stepInHidden = true;
  //      break;
  //    }
  //  }
  //
  //  if (stepInHidden == true && currentValue <= timeStep._end.valueOf()) {
  //    var newValue = moment(endDate);
  //    timeStep.current = newValue.toDate();
  //  }
  //};

  /**
   * replaces the Core toScreen methods
   * @param Core
   * @param time
   * @param width
   * @returns {number}
   */
  exports.toScreen = function (Core, time, width) {
    if (Core.body.hiddenDates.length == 0) {
      var conversion = Core.range.conversion(width);
      return (time.valueOf() - conversion.offset) * conversion.scale;
    } else {
      var hidden = exports.isHidden(time, Core.body.hiddenDates);
      if (hidden.hidden == true) {
        time = hidden.startDate;
      }

      var duration = exports.getHiddenDurationBetween(Core.body.hiddenDates, Core.range.start, Core.range.end);
      if (time < Core.range.start) {
        var conversion = Core.range.conversion(width, duration);
        var hiddenBeforeStart = exports.getHiddenDurationBeforeStart(Core.body.hiddenDates, time, conversion.offset);
        time = Core.options.moment(time).toDate().valueOf();
        time = time + hiddenBeforeStart;
        return -(conversion.offset - time.valueOf()) * conversion.scale;
      } else if (time > Core.range.end) {
        var rangeAfterEnd = { start: Core.range.start, end: time };
        time = exports.correctTimeForHidden(Core.options.moment, Core.body.hiddenDates, rangeAfterEnd, time);
        var conversion = Core.range.conversion(width, duration);
        return (time.valueOf() - conversion.offset) * conversion.scale;
      } else {
        time = exports.correctTimeForHidden(Core.options.moment, Core.body.hiddenDates, Core.range, time);
        var conversion = Core.range.conversion(width, duration);
        return (time.valueOf() - conversion.offset) * conversion.scale;
      }
    }
  };

  /**
   * Replaces the core toTime methods
   * @param body
   * @param range
   * @param x
   * @param width
   * @returns {Date}
   */
  exports.toTime = function (Core, x, width) {
    if (Core.body.hiddenDates.length == 0) {
      var conversion = Core.range.conversion(width);
      return new Date(x / conversion.scale + conversion.offset);
    } else {
      var hiddenDuration = exports.getHiddenDurationBetween(Core.body.hiddenDates, Core.range.start, Core.range.end);
      var totalDuration = Core.range.end - Core.range.start - hiddenDuration;
      var partialDuration = totalDuration * x / width;
      var accumulatedHiddenDuration = exports.getAccumulatedHiddenDuration(Core.body.hiddenDates, Core.range, partialDuration);

      var newTime = new Date(accumulatedHiddenDuration + partialDuration + Core.range.start);
      return newTime;
    }
  };

  /**
   * Support function
   *
   * @param hiddenDates
   * @param range
   * @returns {number}
   */
  exports.getHiddenDurationBetween = function (hiddenDates, start, end) {
    var duration = 0;
    for (var i = 0; i < hiddenDates.length; i++) {
      var startDate = hiddenDates[i].start;
      var endDate = hiddenDates[i].end;
      // if time after the cutout, and the
      if (startDate >= start && endDate < end) {
        duration += endDate - startDate;
      }
    }
    return duration;
  };

  /**
     * Support function
     *
     * @param hiddenDates
     * @param start
     * @param end
     * @returns {number}
     */
  exports.getHiddenDurationBeforeStart = function (hiddenDates, start, end) {
    var duration = 0;
    for (var i = 0; i < hiddenDates.length; i++) {
      var startDate = hiddenDates[i].start;
      var endDate = hiddenDates[i].end;

      if (startDate >= start && endDate <= end) {
        duration += endDate - startDate;
      }
    }
    return duration;
  };

  /**
   * Support function
   * @param moment
   * @param hiddenDates
   * @param range
   * @param time
   * @returns {{duration: number, time: *, offset: number}}
   */
  exports.correctTimeForHidden = function (moment, hiddenDates, range, time) {
    time = moment(time).toDate().valueOf();
    time -= exports.getHiddenDurationBefore(moment, hiddenDates, range, time);
    return time;
  };

  exports.getHiddenDurationBefore = function (moment, hiddenDates, range, time) {
    var timeOffset = 0;
    time = moment(time).toDate().valueOf();

    for (var i = 0; i < hiddenDates.length; i++) {
      var startDate = hiddenDates[i].start;
      var endDate = hiddenDates[i].end;
      // if time after the cutout, and the
      if (startDate >= range.start && endDate < range.end) {
        if (time >= endDate) {
          timeOffset += endDate - startDate;
        }
      }
    }
    return timeOffset;
  };

  /**
   * sum the duration from start to finish, including the hidden duration,
   * until the required amount has been reached, return the accumulated hidden duration
   * @param hiddenDates
   * @param range
   * @param time
   * @returns {{duration: number, time: *, offset: number}}
   */
  exports.getAccumulatedHiddenDuration = function (hiddenDates, range, requiredDuration) {
    var hiddenDuration = 0;
    var duration = 0;
    var previousPoint = range.start;
    //exports.printDates(hiddenDates)
    for (var i = 0; i < hiddenDates.length; i++) {
      var startDate = hiddenDates[i].start;
      var endDate = hiddenDates[i].end;
      // if time after the cutout, and the
      if (startDate >= range.start && endDate < range.end) {
        duration += startDate - previousPoint;
        previousPoint = endDate;
        if (duration >= requiredDuration) {
          break;
        } else {
          hiddenDuration += endDate - startDate;
        }
      }
    }

    return hiddenDuration;
  };

  /**
   * used to step over to either side of a hidden block. Correction is disabled on tablets, might be set to true
   * @param hiddenDates
   * @param time
   * @param direction
   * @param correctionEnabled
   * @returns {*}
   */
  exports.snapAwayFromHidden = function (hiddenDates, time, direction, correctionEnabled) {
    var isHidden = exports.isHidden(time, hiddenDates);
    if (isHidden.hidden == true) {
      if (direction < 0) {
        if (correctionEnabled == true) {
          return isHidden.startDate - (isHidden.endDate - time) - 1;
        } else {
          return isHidden.startDate - 1;
        }
      } else {
        if (correctionEnabled == true) {
          return isHidden.endDate + (time - isHidden.startDate) + 1;
        } else {
          return isHidden.endDate + 1;
        }
      }
    } else {
      return time;
    }
  };

  /**
   * Check if a time is hidden
   *
   * @param time
   * @param hiddenDates
   * @returns {{hidden: boolean, startDate: Window.start, endDate: *}}
   */
  exports.isHidden = function (time, hiddenDates) {
    for (var i = 0; i < hiddenDates.length; i++) {
      var startDate = hiddenDates[i].start;
      var endDate = hiddenDates[i].end;

      if (time >= startDate && time < endDate) {
        // if the start is entering a hidden zone
        return { hidden: true, startDate: startDate, endDate: endDate };
        break;
      }
    }
    return { hidden: false, startDate: startDate, endDate: endDate };
  };

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var Emitter = __webpack_require__(13);
  var Hammer = __webpack_require__(22);
  var hammerUtil = __webpack_require__(30);
  var util = __webpack_require__(1);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);
  var Range = __webpack_require__(32);
  var ItemSet = __webpack_require__(36);
  var TimeAxis = __webpack_require__(46);
  var Activator = __webpack_require__(47);
  var DateUtil = __webpack_require__(34);
  var CustomTime = __webpack_require__(48);

  /**
   * Create a timeline visualization
   * @constructor
   */
  function Core() {}

  // turn Core into an event emitter
  Emitter(Core.prototype);

  /**
   * Create the main DOM for the Core: a root panel containing left, right,
   * top, bottom, content, and background panel.
   * @param {Element} container  The container element where the Core will
   *                             be attached.
   * @protected
   */
  Core.prototype._create = function (container) {
    this.dom = {};

    this.dom.container = container;

    this.dom.root = document.createElement('div');
    this.dom.background = document.createElement('div');
    this.dom.backgroundVertical = document.createElement('div');
    this.dom.backgroundHorizontal = document.createElement('div');
    this.dom.centerContainer = document.createElement('div');
    this.dom.leftContainer = document.createElement('div');
    this.dom.rightContainer = document.createElement('div');
    this.dom.center = document.createElement('div');
    this.dom.left = document.createElement('div');
    this.dom.right = document.createElement('div');
    this.dom.top = document.createElement('div');
    this.dom.bottom = document.createElement('div');
    this.dom.shadowTop = document.createElement('div');
    this.dom.shadowBottom = document.createElement('div');
    this.dom.shadowTopLeft = document.createElement('div');
    this.dom.shadowBottomLeft = document.createElement('div');
    this.dom.shadowTopRight = document.createElement('div');
    this.dom.shadowBottomRight = document.createElement('div');

    this.dom.root.className = 'vis-timeline';
    this.dom.background.className = 'vis-panel vis-background';
    this.dom.backgroundVertical.className = 'vis-panel vis-background vis-vertical';
    this.dom.backgroundHorizontal.className = 'vis-panel vis-background vis-horizontal';
    this.dom.centerContainer.className = 'vis-panel vis-center';
    this.dom.leftContainer.className = 'vis-panel vis-left';
    this.dom.rightContainer.className = 'vis-panel vis-right';
    this.dom.top.className = 'vis-panel vis-top';
    this.dom.bottom.className = 'vis-panel vis-bottom';
    this.dom.left.className = 'vis-content';
    this.dom.center.className = 'vis-content';
    this.dom.right.className = 'vis-content';
    this.dom.shadowTop.className = 'vis-shadow vis-top';
    this.dom.shadowBottom.className = 'vis-shadow vis-bottom';
    this.dom.shadowTopLeft.className = 'vis-shadow vis-top';
    this.dom.shadowBottomLeft.className = 'vis-shadow vis-bottom';
    this.dom.shadowTopRight.className = 'vis-shadow vis-top';
    this.dom.shadowBottomRight.className = 'vis-shadow vis-bottom';

    this.dom.root.appendChild(this.dom.background);
    this.dom.root.appendChild(this.dom.backgroundVertical);
    this.dom.root.appendChild(this.dom.backgroundHorizontal);
    this.dom.root.appendChild(this.dom.centerContainer);
    this.dom.root.appendChild(this.dom.leftContainer);
    this.dom.root.appendChild(this.dom.rightContainer);
    this.dom.root.appendChild(this.dom.top);
    this.dom.root.appendChild(this.dom.bottom);

    this.dom.centerContainer.appendChild(this.dom.center);
    this.dom.leftContainer.appendChild(this.dom.left);
    this.dom.rightContainer.appendChild(this.dom.right);
    this.dom.centerContainer.appendChild(this.dom.shadowTop);
    this.dom.centerContainer.appendChild(this.dom.shadowBottom);
    this.dom.leftContainer.appendChild(this.dom.shadowTopLeft);
    this.dom.leftContainer.appendChild(this.dom.shadowBottomLeft);
    this.dom.rightContainer.appendChild(this.dom.shadowTopRight);
    this.dom.rightContainer.appendChild(this.dom.shadowBottomRight);

    // size properties of each of the panels
    this.props = {
      root: {},
      background: {},
      centerContainer: {},
      leftContainer: {},
      rightContainer: {},
      center: {},
      left: {},
      right: {},
      top: {},
      bottom: {},
      border: {},
      scrollTop: 0,
      scrollTopMin: 0
    };

    this.on('rangechange', function () {
      if (this.initialDrawDone === true) {
        this._redraw();
      }
    }.bind(this));
    this.on('touch', this._onTouch.bind(this));
    this.on('panmove', this._onDrag.bind(this));

    var me = this;
    this.on('_change', function (properties) {
      if (properties && properties.queue == true) {
        // redraw once on next tick
        if (!me._redrawTimer) {
          me._redrawTimer = setTimeout(function () {
            me._redrawTimer = null;
            me._redraw();
          }, 0);
        }
      } else {
        // redraw immediately
        me._redraw();
      }
    });

    // create event listeners for all interesting events, these events will be
    // emitted via emitter
    this.hammer = new Hammer(this.dom.root);
    var pinchRecognizer = this.hammer.get('pinch').set({ enable: true });
    hammerUtil.disablePreventDefaultVertically(pinchRecognizer);
    this.hammer.get('pan').set({ threshold: 5, direction: Hammer.DIRECTION_HORIZONTAL });
    this.listeners = {};

    var events = ['tap', 'doubletap', 'press', 'pinch', 'pan', 'panstart', 'panmove', 'panend'
    // TODO: cleanup
    //'touch', 'pinch',
    //'tap', 'doubletap', 'hold',
    //'dragstart', 'drag', 'dragend',
    //'mousewheel', 'DOMMouseScroll' // DOMMouseScroll is needed for Firefox
    ];
    events.forEach(function (type) {
      var listener = function listener(event) {
        if (me.isActive()) {
          me.emit(type, event);
        }
      };
      me.hammer.on(type, listener);
      me.listeners[type] = listener;
    });

    // emulate a touch event (emitted before the start of a pan, pinch, tap, or press)
    hammerUtil.onTouch(this.hammer, function (event) {
      me.emit('touch', event);
    }.bind(this));

    // emulate a release event (emitted after a pan, pinch, tap, or press)
    hammerUtil.onRelease(this.hammer, function (event) {
      me.emit('release', event);
    }.bind(this));

    function onMouseWheel(event) {
      if (this.isActive()) {
        this.emit('mousewheel', event);
      }

      // prevent scrolling when zoomKey defined or activated
      if (!this.options.zoomKey || event[this.options.zoomKey]) return;

      // prevent scrolling vertically when horizontalScroll is true
      if (this.options.horizontalScroll) return;

      var delta = 0;
      if (event.wheelDelta) {
        /* IE/Opera. */
        delta = event.wheelDelta / 120;
      } else if (event.detail) {
        /* Mozilla case. */
        // In Mozilla, sign of delta is different than in IE.
        // Also, delta is multiple of 3.
        delta = -event.detail / 3;
      }

      var current = this.props.scrollTop;
      var adjusted = current + delta * 120;

      if (this.isActive()) {
        this._setScrollTop(adjusted);
        if (this.options.verticalScroll) {
          this.dom.left.parentNode.scrollTop = -adjusted;
          this.dom.right.parentNode.scrollTop = -adjusted;
        }
        this._redraw();
        this.emit('scroll', event);
      }

      // Prevent default actions caused by mouse wheel
      // (else the page and timeline both scroll)
      event.preventDefault();
    }

    if (this.dom.centerContainer.addEventListener) {
      // IE9, Chrome, Safari, Opera
      this.dom.centerContainer.addEventListener("mousewheel", onMouseWheel.bind(this), false);
      // Firefox
      this.dom.centerContainer.addEventListener("DOMMouseScroll", onMouseWheel.bind(this), false);
    } else {
      // IE 6/7/8
      this.dom.centerContainer.attachEvent("onmousewheel", onMouseWheel.bind(this));
    }

    function onMouseScrollSide(event) {
      if (!me.options.verticalScroll) return;
      event.preventDefault();
      if (me.isActive()) {
        var adjusted = -event.target.scrollTop;
        me._setScrollTop(adjusted);
        me._redraw();
        me.emit('scrollSide', event);
      }
    }

    this.dom.left.parentNode.addEventListener('scroll', onMouseScrollSide.bind(this));
    this.dom.right.parentNode.addEventListener('scroll', onMouseScrollSide.bind(this));

    var itemAddedToTimeline = false;

    function handleDragOver(event) {
      if (event.preventDefault) {
        event.preventDefault(); // Necessary. Allows us to drop.
      }

      // make sure your target is a vis element
      if (!event.target.className.includes('vis')) return;

      // make sure only one item is added every time you're over the timeline
      if (itemAddedToTimeline) return;

      event.dataTransfer.dropEffect = 'move';
      itemAddedToTimeline = true;
      return false;
    }

    function handleDrop(event) {
      // return when dropping non-vis items 
      try {
        var itemData = JSON.parse(event.dataTransfer.getData("text/plain"));
        if (!itemData.content) return;
      } catch (err) {
        return false;
      }

      itemAddedToTimeline = false;
      event.center = {
        x: event.x,
        y: event.y
      };
      me.itemSet._onAddItem(event);

      return false;
    }

    this.dom.center.addEventListener('dragover', handleDragOver.bind(this), false);
    this.dom.center.addEventListener('drop', handleDrop.bind(this), false);

    this.customTimes = [];

    // store state information needed for touch events
    this.touch = {};

    this.redrawCount = 0;
    this.initialDrawDone = false;

    // attach the root panel to the provided container
    if (!container) throw new Error('No container provided');
    container.appendChild(this.dom.root);
  };

  /**
   * Set options. Options will be passed to all components loaded in the Timeline.
   * @param {Object} [options]
   *                           {String} orientation
   *                              Vertical orientation for the Timeline,
   *                              can be 'bottom' (default) or 'top'.
   *                           {String | Number} width
   *                              Width for the timeline, a number in pixels or
   *                              a css string like '1000px' or '75%'. '100%' by default.
   *                           {String | Number} height
   *                              Fixed height for the Timeline, a number in pixels or
   *                              a css string like '400px' or '75%'. If undefined,
   *                              The Timeline will automatically size such that
   *                              its contents fit.
   *                           {String | Number} minHeight
   *                              Minimum height for the Timeline, a number in pixels or
   *                              a css string like '400px' or '75%'.
   *                           {String | Number} maxHeight
   *                              Maximum height for the Timeline, a number in pixels or
   *                              a css string like '400px' or '75%'.
   *                           {Number | Date | String} start
   *                              Start date for the visible window
   *                           {Number | Date | String} end
   *                              End date for the visible window
   */
  Core.prototype.setOptions = function (options) {
    if (options) {
      // copy the known options
      var fields = ['width', 'height', 'minHeight', 'maxHeight', 'autoResize', 'start', 'end', 'clickToUse', 'dataAttributes', 'hiddenDates', 'locale', 'locales', 'moment', 'rtl', 'zoomKey', 'horizontalScroll', 'verticalScroll'];
      util.selectiveExtend(fields, this.options, options);

      if (this.options.rtl) {
        this.dom.container.style.direction = "rtl";
        this.dom.backgroundVertical.className = 'vis-panel vis-background vis-vertical-rtl';
      }

      if (this.options.verticalScroll) {
        if (this.options.rtl) {
          this.dom.rightContainer.className = 'vis-panel vis-right vis-vertical-scroll';
        } else {
          this.dom.leftContainer.className = 'vis-panel vis-left vis-vertical-scroll';
        }
      }

      this.options.orientation = { item: undefined, axis: undefined };
      if ('orientation' in options) {
        if (typeof options.orientation === 'string') {
          this.options.orientation = {
            item: options.orientation,
            axis: options.orientation
          };
        } else if (_typeof(options.orientation) === 'object') {
          if ('item' in options.orientation) {
            this.options.orientation.item = options.orientation.item;
          }
          if ('axis' in options.orientation) {
            this.options.orientation.axis = options.orientation.axis;
          }
        }
      }

      if (this.options.orientation.axis === 'both') {
        if (!this.timeAxis2) {
          var timeAxis2 = this.timeAxis2 = new TimeAxis(this.body);
          timeAxis2.setOptions = function (options) {
            var _options = options ? util.extend({}, options) : {};
            _options.orientation = 'top'; // override the orientation option, always top
            TimeAxis.prototype.setOptions.call(timeAxis2, _options);
          };
          this.components.push(timeAxis2);
        }
      } else {
        if (this.timeAxis2) {
          var index = this.components.indexOf(this.timeAxis2);
          if (index !== -1) {
            this.components.splice(index, 1);
          }
          this.timeAxis2.destroy();
          this.timeAxis2 = null;
        }
      }

      // if the graph2d's drawPoints is a function delegate the callback to the onRender property
      if (typeof options.drawPoints == 'function') {
        options.drawPoints = {
          onRender: options.drawPoints
        };
      }

      if ('hiddenDates' in this.options) {
        DateUtil.convertHiddenOptions(this.options.moment, this.body, this.options.hiddenDates);
      }

      if ('clickToUse' in options) {
        if (options.clickToUse) {
          if (!this.activator) {
            this.activator = new Activator(this.dom.root);
          }
        } else {
          if (this.activator) {
            this.activator.destroy();
            delete this.activator;
          }
        }
      }

      if ('showCustomTime' in options) {
        throw new Error('Option `showCustomTime` is deprecated. Create a custom time bar via timeline.addCustomTime(time [, id])');
      }

      // enable/disable autoResize
      this._initAutoResize();
    }

    // propagate options to all components
    this.components.forEach(function (component) {
      return component.setOptions(options);
    });

    // enable/disable configure
    if ('configure' in options) {
      if (!this.configurator) {
        this.configurator = this._createConfigurator();
      }

      this.configurator.setOptions(options.configure);

      // collect the settings of all components, and pass them to the configuration system
      var appliedOptions = util.deepExtend({}, this.options);
      this.components.forEach(function (component) {
        util.deepExtend(appliedOptions, component.options);
      });
      this.configurator.setModuleOptions({ global: appliedOptions });
    }

    // override redraw with a throttled version
    if (!this._origRedraw) {
      this._origRedraw = this._redraw.bind(this);
      this._redraw = util.throttle(this._origRedraw);
    } else {
      // Not the initial run: redraw everything
      this._redraw();
    }
  };

  /**
   * Returns true when the Timeline is active.
   * @returns {boolean}
   */
  Core.prototype.isActive = function () {
    return !this.activator || this.activator.active;
  };

  /**
   * Destroy the Core, clean up all DOM elements and event listeners.
   */
  Core.prototype.destroy = function () {
    // unbind datasets
    this.setItems(null);
    this.setGroups(null);

    // remove all event listeners
    this.off();

    // stop checking for changed size
    this._stopAutoResize();

    // remove from DOM
    if (this.dom.root.parentNode) {
      this.dom.root.parentNode.removeChild(this.dom.root);
    }
    this.dom = null;

    // remove Activator
    if (this.activator) {
      this.activator.destroy();
      delete this.activator;
    }

    // cleanup hammer touch events
    for (var event in this.listeners) {
      if (this.listeners.hasOwnProperty(event)) {
        delete this.listeners[event];
      }
    }
    this.listeners = null;
    this.hammer = null;

    // give all components the opportunity to cleanup
    this.components.forEach(function (component) {
      return component.destroy();
    });

    this.body = null;
  };

  /**
   * Set a custom time bar
   * @param {Date} time
   * @param {number} [id=undefined] Optional id of the custom time bar to be adjusted.
   */
  Core.prototype.setCustomTime = function (time, id) {
    var customTimes = this.customTimes.filter(function (component) {
      return id === component.options.id;
    });

    if (customTimes.length === 0) {
      throw new Error('No custom time bar found with id ' + JSON.stringify(id));
    }

    if (customTimes.length > 0) {
      customTimes[0].setCustomTime(time);
    }
  };

  /**
   * Retrieve the current custom time.
   * @param {number} [id=undefined]    Id of the custom time bar.
   * @return {Date | undefined} customTime
   */
  Core.prototype.getCustomTime = function (id) {
    var customTimes = this.customTimes.filter(function (component) {
      return component.options.id === id;
    });

    if (customTimes.length === 0) {
      throw new Error('No custom time bar found with id ' + JSON.stringify(id));
    }
    return customTimes[0].getCustomTime();
  };

  /**
   * Set a custom title for the custom time bar.
   * @param {String} [title] Custom title
   * @param {number} [id=undefined]    Id of the custom time bar.
   */
  Core.prototype.setCustomTimeTitle = function (title, id) {
    var customTimes = this.customTimes.filter(function (component) {
      return component.options.id === id;
    });

    if (customTimes.length === 0) {
      throw new Error('No custom time bar found with id ' + JSON.stringify(id));
    }
    if (customTimes.length > 0) {
      return customTimes[0].setCustomTitle(title);
    }
  };

  /**
   * Retrieve meta information from an event.
   * Should be overridden by classes extending Core
   * @param {Event} event
   * @return {Object} An object with related information.
   */
  Core.prototype.getEventProperties = function (event) {
    return { event: event };
  };

  /**
   * Add custom vertical bar
   * @param {Date | String | Number} [time]  A Date, unix timestamp, or
   *                                         ISO date string. Time point where
   *                                         the new bar should be placed.
   *                                         If not provided, `new Date()` will
   *                                         be used.
   * @param {Number | String} [id=undefined] Id of the new bar. Optional
   * @return {Number | String}               Returns the id of the new bar
   */
  Core.prototype.addCustomTime = function (time, id) {
    var timestamp = time !== undefined ? util.convert(time, 'Date').valueOf() : new Date();

    var exists = this.customTimes.some(function (customTime) {
      return customTime.options.id === id;
    });
    if (exists) {
      throw new Error('A custom time with id ' + JSON.stringify(id) + ' already exists');
    }

    var customTime = new CustomTime(this.body, util.extend({}, this.options, {
      time: timestamp,
      id: id
    }));

    this.customTimes.push(customTime);
    this.components.push(customTime);
    this._redraw();

    return id;
  };

  /**
   * Remove previously added custom bar
   * @param {int} id ID of the custom bar to be removed
   * @return {boolean} True if the bar exists and is removed, false otherwise
   */
  Core.prototype.removeCustomTime = function (id) {
    var customTimes = this.customTimes.filter(function (bar) {
      return bar.options.id === id;
    });

    if (customTimes.length === 0) {
      throw new Error('No custom time bar found with id ' + JSON.stringify(id));
    }

    customTimes.forEach(function (customTime) {
      this.customTimes.splice(this.customTimes.indexOf(customTime), 1);
      this.components.splice(this.components.indexOf(customTime), 1);
      customTime.destroy();
    }.bind(this));
  };

  /**
   * Get the id's of the currently visible items.
   * @returns {Array} The ids of the visible items
   */
  Core.prototype.getVisibleItems = function () {
    return this.itemSet && this.itemSet.getVisibleItems() || [];
  };

  /**
   * Set Core window such that it fits all items
   * @param {Object} [options]  Available options:
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   */
  Core.prototype.fit = function (options) {
    var range = this.getDataRange();

    // skip range set if there is no min and max date
    if (range.min === null && range.max === null) {
      return;
    }

    // apply a margin of 1% left and right of the data
    var interval = range.max - range.min;
    var min = new Date(range.min.valueOf() - interval * 0.01);
    var max = new Date(range.max.valueOf() + interval * 0.01);
    var animation = options && options.animation !== undefined ? options.animation : true;
    this.range.setRange(min, max, animation);
  };

  /**
   * Calculate the data range of the items start and end dates
   * @returns {{min: Date | null, max: Date | null}}
   * @protected
   */
  Core.prototype.getDataRange = function () {
    // must be implemented by Timeline and Graph2d
    throw new Error('Cannot invoke abstract method getDataRange');
  };

  /**
   * Set the visible window. Both parameters are optional, you can change only
   * start or only end. Syntax:
   *
   *     TimeLine.setWindow(start, end)
   *     TimeLine.setWindow(start, end, options)
   *     TimeLine.setWindow(range)
   *
   * Where start and end can be a Date, number, or string, and range is an
   * object with properties start and end.
   *
   * @param {Date | Number | String | Object} [start] Start date of visible window
   * @param {Date | Number | String} [end]            End date of visible window
   * @param {Object} [options]  Available options:
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   */
  Core.prototype.setWindow = function (start, end, options) {
    var animation;
    if (arguments.length == 1) {
      var range = arguments[0];
      animation = range.animation !== undefined ? range.animation : true;
      this.range.setRange(range.start, range.end, animation);
    } else {
      animation = options && options.animation !== undefined ? options.animation : true;
      this.range.setRange(start, end, animation);
    }
  };

  /**
   * Move the window such that given time is centered on screen.
   * @param {Date | Number | String} time
   * @param {Object} [options]  Available options:
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   */
  Core.prototype.moveTo = function (time, options) {
    var interval = this.range.end - this.range.start;
    var t = util.convert(time, 'Date').valueOf();

    var start = t - interval / 2;
    var end = t + interval / 2;
    var animation = options && options.animation !== undefined ? options.animation : true;

    this.range.setRange(start, end, animation);
  };

  /**
   * Get the visible window
   * @return {{start: Date, end: Date}}   Visible range
   */
  Core.prototype.getWindow = function () {
    var range = this.range.getRange();
    return {
      start: new Date(range.start),
      end: new Date(range.end)
    };
  };

  /**
   * Zoom in the window such that given time is centered on screen.
   * @param {Number} percentage - must be between [0..1]
   */
  Core.prototype.zoomIn = function (percentage) {
    if (!percentage || percentage < 0 || percentage > 1) return;
    var range = this.getWindow();
    var start = range.start.valueOf();
    var end = range.end.valueOf();
    var interval = end - start;
    var newInterval = interval / (1 + percentage);
    var distance = (interval - newInterval) / 2;
    var newStart = start + distance;
    var newEnd = end - distance;

    this.setWindow({
      start: newStart,
      end: newEnd
    });
  };

  /**
   * Zoom out the window such that given time is centered on screen.
   * @param {Number} percentage - must be between [0..1]
   */
  Core.prototype.zoomOut = function (percentage) {
    if (!percentage || percentage < 0 || percentage > 1) return;
    var range = this.getWindow();
    var start = range.start.valueOf();
    var end = range.end.valueOf();
    var interval = end - start;
    var newStart = start - interval * percentage / 2;
    var newEnd = end + interval * percentage / 2;

    this.setWindow({
      start: newStart,
      end: newEnd
    });
  };

  /**
   * Force a redraw. Can be overridden by implementations of Core
   *
   * Note: this function will be overridden on construction with a trottled version
   */
  Core.prototype.redraw = function () {
    this._redraw();
  };

  /**
   * Redraw for internal use. Redraws all components. See also the public
   * method redraw.
   * @protected
   */
  Core.prototype._redraw = function () {
    this.redrawCount++;
    var resized = false;
    var options = this.options;
    var props = this.props;
    var dom = this.dom;

    if (!dom || !dom.container || dom.root.offsetWidth == 0) return; // when destroyed, or invisible

    DateUtil.updateHiddenDates(this.options.moment, this.body, this.options.hiddenDates);

    // update class names
    if (options.orientation == 'top') {
      util.addClassName(dom.root, 'vis-top');
      util.removeClassName(dom.root, 'vis-bottom');
    } else {
      util.removeClassName(dom.root, 'vis-top');
      util.addClassName(dom.root, 'vis-bottom');
    }

    // update root width and height options
    dom.root.style.maxHeight = util.option.asSize(options.maxHeight, '');
    dom.root.style.minHeight = util.option.asSize(options.minHeight, '');
    dom.root.style.width = util.option.asSize(options.width, '');

    // calculate border widths
    props.border.left = (dom.centerContainer.offsetWidth - dom.centerContainer.clientWidth) / 2;
    props.border.right = props.border.left;
    props.border.top = (dom.centerContainer.offsetHeight - dom.centerContainer.clientHeight) / 2;
    props.border.bottom = props.border.top;
    var borderRootHeight = dom.root.offsetHeight - dom.root.clientHeight;
    var borderRootWidth = dom.root.offsetWidth - dom.root.clientWidth;

    // workaround for a bug in IE: the clientWidth of an element with
    // a height:0px and overflow:hidden is not calculated and always has value 0
    if (dom.centerContainer.clientHeight === 0) {
      props.border.left = props.border.top;
      props.border.right = props.border.left;
    }
    if (dom.root.clientHeight === 0) {
      borderRootWidth = borderRootHeight;
    }

    // calculate the heights. If any of the side panels is empty, we set the height to
    // minus the border width, such that the border will be invisible
    props.center.height = dom.center.offsetHeight;
    props.left.height = dom.left.offsetHeight;
    props.right.height = dom.right.offsetHeight;
    props.top.height = dom.top.clientHeight || -props.border.top;
    props.bottom.height = dom.bottom.clientHeight || -props.border.bottom;

    // TODO: compensate borders when any of the panels is empty.

    // apply auto height
    // TODO: only calculate autoHeight when needed (else we cause an extra reflow/repaint of the DOM)
    var contentHeight = Math.max(props.left.height, props.center.height, props.right.height);
    var autoHeight = props.top.height + contentHeight + props.bottom.height + borderRootHeight + props.border.top + props.border.bottom;
    dom.root.style.height = util.option.asSize(options.height, autoHeight + 'px');

    // calculate heights of the content panels
    props.root.height = dom.root.offsetHeight;
    props.background.height = props.root.height - borderRootHeight;
    var containerHeight = props.root.height - props.top.height - props.bottom.height - borderRootHeight;
    props.centerContainer.height = containerHeight;
    props.leftContainer.height = containerHeight;
    props.rightContainer.height = props.leftContainer.height;

    // calculate the widths of the panels
    props.root.width = dom.root.offsetWidth;
    props.background.width = props.root.width - borderRootWidth;

    if (!this.initialDrawDone) {
      props.scrollbarWidth = util.getScrollBarWidth();
    }

    if (this.options.verticalScroll) {
      if (this.options.rtl) {
        props.left.width = dom.leftContainer.clientWidth || -props.border.left;
        props.right.width = dom.rightContainer.clientWidth + props.scrollbarWidth || -props.border.right;
      } else {
        props.left.width = dom.leftContainer.clientWidth + props.scrollbarWidth || -props.border.left;
        props.right.width = dom.rightContainer.clientWidth || -props.border.right;
      }
    } else {
      props.left.width = dom.leftContainer.clientWidth || -props.border.left;
      props.right.width = dom.rightContainer.clientWidth || -props.border.right;
    }

    props.leftContainer.width = props.left.width;
    props.rightContainer.width = props.right.width;
    var centerWidth = props.root.width - props.left.width - props.right.width - borderRootWidth;
    props.center.width = centerWidth;
    props.centerContainer.width = centerWidth;
    props.top.width = centerWidth;
    props.bottom.width = centerWidth;

    // resize the panels
    dom.background.style.height = props.background.height + 'px';
    dom.backgroundVertical.style.height = props.background.height + 'px';
    dom.backgroundHorizontal.style.height = props.centerContainer.height + 'px';
    dom.centerContainer.style.height = props.centerContainer.height + 'px';
    dom.leftContainer.style.height = props.leftContainer.height + 'px';
    dom.rightContainer.style.height = props.rightContainer.height + 'px';

    dom.background.style.width = props.background.width + 'px';
    dom.backgroundVertical.style.width = props.centerContainer.width + 'px';
    dom.backgroundHorizontal.style.width = props.background.width + 'px';
    dom.centerContainer.style.width = props.center.width + 'px';
    dom.top.style.width = props.top.width + 'px';
    dom.bottom.style.width = props.bottom.width + 'px';

    // reposition the panels
    dom.background.style.left = '0';
    dom.background.style.top = '0';
    dom.backgroundVertical.style.left = props.left.width + props.border.left + 'px';
    dom.backgroundVertical.style.top = '0';
    dom.backgroundHorizontal.style.left = '0';
    dom.backgroundHorizontal.style.top = props.top.height + 'px';
    dom.centerContainer.style.left = props.left.width + 'px';
    dom.centerContainer.style.top = props.top.height + 'px';
    dom.leftContainer.style.left = '0';
    dom.leftContainer.style.top = props.top.height + 'px';
    dom.rightContainer.style.left = props.left.width + props.center.width + 'px';
    dom.rightContainer.style.top = props.top.height + 'px';
    dom.top.style.left = props.left.width + 'px';
    dom.top.style.top = '0';
    dom.bottom.style.left = props.left.width + 'px';
    dom.bottom.style.top = props.top.height + props.centerContainer.height + 'px';

    // update the scrollTop, feasible range for the offset can be changed
    // when the height of the Core or of the contents of the center changed
    var offset = this._updateScrollTop();

    // reposition the scrollable contents
    if (options.orientation.item != 'top') {
      offset += Math.max(this.props.centerContainer.height - this.props.center.height - this.props.border.top - this.props.border.bottom, 0);
    }
    dom.center.style.left = '0';
    dom.center.style.top = offset + 'px';
    dom.left.style.left = '0';
    dom.right.style.left = '0';

    // show shadows when vertical scrolling is available
    var visibilityTop = this.props.scrollTop == 0 ? 'hidden' : '';
    var visibilityBottom = this.props.scrollTop == this.props.scrollTopMin ? 'hidden' : '';
    dom.shadowTop.style.visibility = visibilityTop;
    dom.shadowBottom.style.visibility = visibilityBottom;
    dom.shadowTopLeft.style.visibility = visibilityTop;
    dom.shadowBottomLeft.style.visibility = visibilityBottom;
    dom.shadowTopRight.style.visibility = visibilityTop;
    dom.shadowBottomRight.style.visibility = visibilityBottom;

    if (this.options.verticalScroll) {
      dom.shadowTopRight.style.visibility = "hidden";
      dom.shadowBottomRight.style.visibility = "hidden";
      dom.shadowTopLeft.style.visibility = "hidden";
      dom.shadowBottomLeft.style.visibility = "hidden";
    } else {
      dom.left.style.top = offset + 'px';
      dom.right.style.top = offset + 'px';
    }

    // enable/disable vertical panning
    var contentsOverflow = this.props.center.height > this.props.centerContainer.height;
    this.hammer.get('pan').set({
      direction: contentsOverflow ? Hammer.DIRECTION_ALL : Hammer.DIRECTION_HORIZONTAL
    });

    // redraw all components
    this.components.forEach(function (component) {
      resized = component.redraw() || resized;
    });
    var MAX_REDRAW = 5;
    if (resized) {
      if (this.redrawCount < MAX_REDRAW) {
        this.body.emitter.emit('_change');
        return;
      } else {
        console.log('WARNING: infinite loop in redraw?');
      }
    } else {
      this.redrawCount = 0;
    }

    this.initialDrawDone = true;

    //Emit public 'changed' event for UI updates, see issue #1592
    this.body.emitter.emit("changed");
  };

  // TODO: deprecated since version 1.1.0, remove some day
  Core.prototype.repaint = function () {
    throw new Error('Function repaint is deprecated. Use redraw instead.');
  };

  /**
   * Set a current time. This can be used for example to ensure that a client's
   * time is synchronized with a shared server time.
   * Only applicable when option `showCurrentTime` is true.
   * @param {Date | String | Number} time     A Date, unix timestamp, or
   *                                          ISO date string.
   */
  Core.prototype.setCurrentTime = function (time) {
    if (!this.currentTime) {
      throw new Error('Option showCurrentTime must be true');
    }

    this.currentTime.setCurrentTime(time);
  };

  /**
   * Get the current time.
   * Only applicable when option `showCurrentTime` is true.
   * @return {Date} Returns the current time.
   */
  Core.prototype.getCurrentTime = function () {
    if (!this.currentTime) {
      throw new Error('Option showCurrentTime must be true');
    }

    return this.currentTime.getCurrentTime();
  };

  /**
   * Convert a position on screen (pixels) to a datetime
   * @param {int}     x    Position on the screen in pixels
   * @return {Date}   time The datetime the corresponds with given position x
   * @protected
   */
  // TODO: move this function to Range
  Core.prototype._toTime = function (x) {
    return DateUtil.toTime(this, x, this.props.center.width);
  };

  /**
   * Convert a position on the global screen (pixels) to a datetime
   * @param {int}     x    Position on the screen in pixels
   * @return {Date}   time The datetime the corresponds with given position x
   * @protected
   */
  // TODO: move this function to Range
  Core.prototype._toGlobalTime = function (x) {
    return DateUtil.toTime(this, x, this.props.root.width);
    //var conversion = this.range.conversion(this.props.root.width);
    //return new Date(x / conversion.scale + conversion.offset);
  };

  /**
   * Convert a datetime (Date object) into a position on the screen
   * @param {Date}   time A date
   * @return {int}   x    The position on the screen in pixels which corresponds
   *                      with the given date.
   * @protected
   */
  // TODO: move this function to Range
  Core.prototype._toScreen = function (time) {
    return DateUtil.toScreen(this, time, this.props.center.width);
  };

  /**
   * Convert a datetime (Date object) into a position on the root
   * This is used to get the pixel density estimate for the screen, not the center panel
   * @param {Date}   time A date
   * @return {int}   x    The position on root in pixels which corresponds
   *                      with the given date.
   * @protected
   */
  // TODO: move this function to Range
  Core.prototype._toGlobalScreen = function (time) {
    return DateUtil.toScreen(this, time, this.props.root.width);
    //var conversion = this.range.conversion(this.props.root.width);
    //return (time.valueOf() - conversion.offset) * conversion.scale;
  };

  /**
   * Initialize watching when option autoResize is true
   * @private
   */
  Core.prototype._initAutoResize = function () {
    if (this.options.autoResize == true) {
      this._startAutoResize();
    } else {
      this._stopAutoResize();
    }
  };

  /**
   * Watch for changes in the size of the container. On resize, the Panel will
   * automatically redraw itself.
   * @private
   */
  Core.prototype._startAutoResize = function () {
    var me = this;

    this._stopAutoResize();

    this._onResize = function () {
      if (me.options.autoResize != true) {
        // stop watching when the option autoResize is changed to false
        me._stopAutoResize();
        return;
      }

      if (me.dom.root) {
        // check whether the frame is resized
        // Note: we compare offsetWidth here, not clientWidth. For some reason,
        // IE does not restore the clientWidth from 0 to the actual width after
        // changing the timeline's container display style from none to visible
        if (me.dom.root.offsetWidth != me.props.lastWidth || me.dom.root.offsetHeight != me.props.lastHeight) {
          me.props.lastWidth = me.dom.root.offsetWidth;
          me.props.lastHeight = me.dom.root.offsetHeight;

          me.body.emitter.emit('_change');
        }
      }
    };

    // add event listener to window resize
    util.addEventListener(window, 'resize', this._onResize);

    //Prevent initial unnecessary redraw
    if (me.dom.root) {
      me.props.lastWidth = me.dom.root.offsetWidth;
      me.props.lastHeight = me.dom.root.offsetHeight;
    }

    this.watchTimer = setInterval(this._onResize, 1000);
  };

  /**
   * Stop watching for a resize of the frame.
   * @private
   */
  Core.prototype._stopAutoResize = function () {
    if (this.watchTimer) {
      clearInterval(this.watchTimer);
      this.watchTimer = undefined;
    }

    // remove event listener on window.resize
    if (this._onResize) {
      util.removeEventListener(window, 'resize', this._onResize);
      this._onResize = null;
    }
  };

  /**
   * Start moving the timeline vertically
   * @param {Event} event
   * @private
   */
  Core.prototype._onTouch = function (event) {
    this.touch.allowDragging = true;
    this.touch.initialScrollTop = this.props.scrollTop;
  };

  /**
   * Start moving the timeline vertically
   * @param {Event} event
   * @private
   */
  Core.prototype._onPinch = function (event) {
    this.touch.allowDragging = false;
  };

  /**
   * Move the timeline vertically
   * @param {Event} event
   * @private
   */
  Core.prototype._onDrag = function (event) {
    if (!event) return;
    // refuse to drag when we where pinching to prevent the timeline make a jump
    // when releasing the fingers in opposite order from the touch screen
    if (!this.touch.allowDragging) return;

    var delta = event.deltaY;

    var oldScrollTop = this._getScrollTop();
    var newScrollTop = this._setScrollTop(this.touch.initialScrollTop + delta);

    if (this.options.verticalScroll) {
      this.dom.left.parentNode.scrollTop = -this.props.scrollTop;
      this.dom.right.parentNode.scrollTop = -this.props.scrollTop;
    }

    if (newScrollTop != oldScrollTop) {
      this.emit("verticalDrag");
    }
  };

  /**
   * Apply a scrollTop
   * @param {Number} scrollTop
   * @returns {Number} scrollTop  Returns the applied scrollTop
   * @private
   */
  Core.prototype._setScrollTop = function (scrollTop) {
    this.props.scrollTop = scrollTop;
    this._updateScrollTop();
    return this.props.scrollTop;
  };

  /**
   * Update the current scrollTop when the height of  the containers has been changed
   * @returns {Number} scrollTop  Returns the applied scrollTop
   * @private
   */
  Core.prototype._updateScrollTop = function () {
    // recalculate the scrollTopMin
    var scrollTopMin = Math.min(this.props.centerContainer.height - this.props.center.height, 0); // is negative or zero
    if (scrollTopMin != this.props.scrollTopMin) {
      // in case of bottom orientation, change the scrollTop such that the contents
      // do not move relative to the time axis at the bottom
      if (this.options.orientation.item != 'top') {
        this.props.scrollTop += scrollTopMin - this.props.scrollTopMin;
      }
      this.props.scrollTopMin = scrollTopMin;
    }

    // limit the scrollTop to the feasible scroll range
    if (this.props.scrollTop > 0) this.props.scrollTop = 0;
    if (this.props.scrollTop < scrollTopMin) this.props.scrollTop = scrollTopMin;

    return this.props.scrollTop;
  };

  /**
   * Get the current scrollTop
   * @returns {number} scrollTop
   * @private
   */
  Core.prototype._getScrollTop = function () {
    return this.props.scrollTop;
  };

  /**
   * Load a configurator
   * @return {Object}
   * @private
   */
  Core.prototype._createConfigurator = function () {
    throw new Error('Cannot invoke abstract method _createConfigurator');
  };

  module.exports = Core;

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var Hammer = __webpack_require__(22);
  var util = __webpack_require__(1);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);
  var TimeStep = __webpack_require__(37);
  var Component = __webpack_require__(33);
  var Group = __webpack_require__(38);
  var BackgroundGroup = __webpack_require__(42);
  var BoxItem = __webpack_require__(43);
  var PointItem = __webpack_require__(44);
  var RangeItem = __webpack_require__(40);
  var BackgroundItem = __webpack_require__(45);

  var UNGROUPED = '__ungrouped__'; // reserved group id for ungrouped items
  var BACKGROUND = '__background__'; // reserved group id for background items without group

  /**
   * An ItemSet holds a set of items and ranges which can be displayed in a
   * range. The width is determined by the parent of the ItemSet, and the height
   * is determined by the size of the items.
   * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} body
   * @param {Object} [options]      See ItemSet.setOptions for the available options.
   * @constructor ItemSet
   * @extends Component
   */
  function ItemSet(body, options) {
    this.body = body;
    this.defaultOptions = {
      type: null, // 'box', 'point', 'range', 'background'
      orientation: {
        item: 'bottom' // item orientation: 'top' or 'bottom'
      },
      align: 'auto', // alignment of box items
      stack: true,
      groupOrderSwap: function groupOrderSwap(fromGroup, toGroup, groups) {
        var targetOrder = toGroup.order;
        toGroup.order = fromGroup.order;
        fromGroup.order = targetOrder;
      },
      groupOrder: 'order',

      selectable: true,
      multiselect: false,
      itemsAlwaysDraggable: false,

      editable: {
        updateTime: false,
        updateGroup: false,
        add: false,
        remove: false
      },

      groupEditable: {
        order: false,
        add: false,
        remove: false
      },

      snap: TimeStep.snap,

      onAdd: function onAdd(item, callback) {
        callback(item);
      },
      onUpdate: function onUpdate(item, callback) {
        callback(item);
      },
      onMove: function onMove(item, callback) {
        callback(item);
      },
      onRemove: function onRemove(item, callback) {
        callback(item);
      },
      onMoving: function onMoving(item, callback) {
        callback(item);
      },
      onAddGroup: function onAddGroup(item, callback) {
        callback(item);
      },
      onMoveGroup: function onMoveGroup(item, callback) {
        callback(item);
      },
      onRemoveGroup: function onRemoveGroup(item, callback) {
        callback(item);
      },

      margin: {
        item: {
          horizontal: 10,
          vertical: 10
        },
        axis: 20
      },

      tooltipOnItemUpdateTime: false
    };

    // options is shared by this ItemSet and all its items
    this.options = util.extend({}, this.defaultOptions);
    this.options.rtl = options.rtl;

    // options for getting items from the DataSet with the correct type
    this.itemOptions = {
      type: { start: 'Date', end: 'Date' }
    };

    this.conversion = {
      toScreen: body.util.toScreen,
      toTime: body.util.toTime
    };
    this.dom = {};
    this.props = {};
    this.hammer = null;

    var me = this;
    this.itemsData = null; // DataSet
    this.groupsData = null; // DataSet

    // listeners for the DataSet of the items
    this.itemListeners = {
      'add': function add(event, params, senderId) {
        me._onAdd(params.items);
      },
      'update': function update(event, params, senderId) {
        me._onUpdate(params.items);
      },
      'remove': function remove(event, params, senderId) {
        me._onRemove(params.items);
      }
    };

    // listeners for the DataSet of the groups
    this.groupListeners = {
      'add': function add(event, params, senderId) {
        me._onAddGroups(params.items);
      },
      'update': function update(event, params, senderId) {
        me._onUpdateGroups(params.items);
      },
      'remove': function remove(event, params, senderId) {
        me._onRemoveGroups(params.items);
      }
    };

    this.items = {}; // object with an Item for every data item
    this.groups = {}; // Group object for every group
    this.groupIds = [];

    this.selection = []; // list with the ids of all selected nodes
    this.stackDirty = true; // if true, all items will be restacked on next redraw

    this.touchParams = {}; // stores properties while dragging
    this.groupTouchParams = {};
    // create the HTML DOM

    this._create();

    this.setOptions(options);
  }

  ItemSet.prototype = new Component();

  // available item types will be registered here
  ItemSet.types = {
    background: BackgroundItem,
    box: BoxItem,
    range: RangeItem,
    point: PointItem
  };

  /**
   * Create the HTML DOM for the ItemSet
   */
  ItemSet.prototype._create = function () {
    var frame = document.createElement('div');
    frame.className = 'vis-itemset';
    frame['timeline-itemset'] = this;
    this.dom.frame = frame;

    // create background panel
    var background = document.createElement('div');
    background.className = 'vis-background';
    frame.appendChild(background);
    this.dom.background = background;

    // create foreground panel
    var foreground = document.createElement('div');
    foreground.className = 'vis-foreground';
    frame.appendChild(foreground);
    this.dom.foreground = foreground;

    // create axis panel
    var axis = document.createElement('div');
    axis.className = 'vis-axis';
    this.dom.axis = axis;

    // create labelset
    var labelSet = document.createElement('div');
    labelSet.className = 'vis-labelset';
    this.dom.labelSet = labelSet;

    // create ungrouped Group
    this._updateUngrouped();

    // create background Group
    var backgroundGroup = new BackgroundGroup(BACKGROUND, null, this);
    backgroundGroup.show();
    this.groups[BACKGROUND] = backgroundGroup;

    // attach event listeners
    // Note: we bind to the centerContainer for the case where the height
    //       of the center container is larger than of the ItemSet, so we
    //       can click in the empty area to create a new item or deselect an item.
    this.hammer = new Hammer(this.body.dom.centerContainer);

    // drag items when selected
    this.hammer.on('hammer.input', function (event) {
      if (event.isFirst) {
        this._onTouch(event);
      }
    }.bind(this));
    this.hammer.on('panstart', this._onDragStart.bind(this));
    this.hammer.on('panmove', this._onDrag.bind(this));
    this.hammer.on('panend', this._onDragEnd.bind(this));
    this.hammer.get('pan').set({ threshold: 5, direction: Hammer.DIRECTION_HORIZONTAL });

    // single select (or unselect) when tapping an item
    this.hammer.on('tap', this._onSelectItem.bind(this));

    // multi select when holding mouse/touch, or on ctrl+click
    this.hammer.on('press', this._onMultiSelectItem.bind(this));

    // add item on doubletap
    this.hammer.on('doubletap', this._onAddItem.bind(this));

    if (this.options.rtl) {
      this.groupHammer = new Hammer(this.body.dom.rightContainer);
    } else {
      this.groupHammer = new Hammer(this.body.dom.leftContainer);
    }

    this.groupHammer.on('panstart', this._onGroupDragStart.bind(this));
    this.groupHammer.on('panmove', this._onGroupDrag.bind(this));
    this.groupHammer.on('panend', this._onGroupDragEnd.bind(this));
    this.groupHammer.get('pan').set({ threshold: 5, direction: Hammer.DIRECTION_HORIZONTAL });

    this.body.dom.centerContainer.addEventListener('mouseover', this._onMouseOver.bind(this));
    this.body.dom.centerContainer.addEventListener('mouseout', this._onMouseOut.bind(this));

    // attach to the DOM
    this.show();
  };

  /**
   * Set options for the ItemSet. Existing options will be extended/overwritten.
   * @param {Object} [options] The following options are available:
   *                           {String} type
   *                              Default type for the items. Choose from 'box'
   *                              (default), 'point', 'range', or 'background'.
   *                              The default style can be overwritten by
   *                              individual items.
   *                           {String} align
   *                              Alignment for the items, only applicable for
   *                              BoxItem. Choose 'center' (default), 'left', or
   *                              'right'.
   *                           {String} orientation.item
   *                              Orientation of the item set. Choose 'top' or
   *                              'bottom' (default).
   *                           {Function} groupOrder
   *                              A sorting function for ordering groups
   *                           {Boolean} stack
   *                              If true (default), items will be stacked on
   *                              top of each other.
   *                           {Number} margin.axis
   *                              Margin between the axis and the items in pixels.
   *                              Default is 20.
   *                           {Number} margin.item.horizontal
   *                              Horizontal margin between items in pixels.
   *                              Default is 10.
   *                           {Number} margin.item.vertical
   *                              Vertical Margin between items in pixels.
   *                              Default is 10.
   *                           {Number} margin.item
   *                              Margin between items in pixels in both horizontal
   *                              and vertical direction. Default is 10.
   *                           {Number} margin
   *                              Set margin for both axis and items in pixels.
   *                           {Boolean} selectable
   *                              If true (default), items can be selected.
   *                           {Boolean} multiselect
   *                              If true, multiple items can be selected.
   *                              False by default.
   *                           {Boolean} editable
   *                              Set all editable options to true or false
   *                           {Boolean} editable.updateTime
   *                              Allow dragging an item to an other moment in time
   *                           {Boolean} editable.updateGroup
   *                              Allow dragging an item to an other group
   *                           {Boolean} editable.add
   *                              Allow creating new items on double tap
   *                           {Boolean} editable.remove
   *                              Allow removing items by clicking the delete button
   *                              top right of a selected item.
   *                           {Function(item: Item, callback: Function)} onAdd
   *                              Callback function triggered when an item is about to be added:
   *                              when the user double taps an empty space in the Timeline.
   *                           {Function(item: Item, callback: Function)} onUpdate
   *                              Callback function fired when an item is about to be updated.
   *                              This function typically has to show a dialog where the user
   *                              change the item. If not implemented, nothing happens.
   *                           {Function(item: Item, callback: Function)} onMove
   *                              Fired when an item has been moved. If not implemented,
   *                              the move action will be accepted.
   *                           {Function(item: Item, callback: Function)} onRemove
   *                              Fired when an item is about to be deleted.
   *                              If not implemented, the item will be always removed.
   */
  ItemSet.prototype.setOptions = function (options) {
    if (options) {
      // copy all options that we know
      var fields = ['type', 'rtl', 'align', 'order', 'stack', 'selectable', 'multiselect', 'itemsAlwaysDraggable', 'multiselectPerGroup', 'groupOrder', 'dataAttributes', 'template', 'groupTemplate', 'hide', 'snap', 'groupOrderSwap', 'tooltipOnItemUpdateTime'];
      util.selectiveExtend(fields, this.options, options);

      if ('orientation' in options) {
        if (typeof options.orientation === 'string') {
          this.options.orientation.item = options.orientation === 'top' ? 'top' : 'bottom';
        } else if (_typeof(options.orientation) === 'object' && 'item' in options.orientation) {
          this.options.orientation.item = options.orientation.item;
        }
      }

      if ('margin' in options) {
        if (typeof options.margin === 'number') {
          this.options.margin.axis = options.margin;
          this.options.margin.item.horizontal = options.margin;
          this.options.margin.item.vertical = options.margin;
        } else if (_typeof(options.margin) === 'object') {
          util.selectiveExtend(['axis'], this.options.margin, options.margin);
          if ('item' in options.margin) {
            if (typeof options.margin.item === 'number') {
              this.options.margin.item.horizontal = options.margin.item;
              this.options.margin.item.vertical = options.margin.item;
            } else if (_typeof(options.margin.item) === 'object') {
              util.selectiveExtend(['horizontal', 'vertical'], this.options.margin.item, options.margin.item);
            }
          }
        }
      }

      if ('editable' in options) {
        if (typeof options.editable === 'boolean') {
          this.options.editable.updateTime = options.editable;
          this.options.editable.updateGroup = options.editable;
          this.options.editable.add = options.editable;
          this.options.editable.remove = options.editable;
        } else if (_typeof(options.editable) === 'object') {
          util.selectiveExtend(['updateTime', 'updateGroup', 'add', 'remove'], this.options.editable, options.editable);
        }
      }

      if ('groupEditable' in options) {
        if (typeof options.groupEditable === 'boolean') {
          this.options.groupEditable.order = options.groupEditable;
          this.options.groupEditable.add = options.groupEditable;
          this.options.groupEditable.remove = options.groupEditable;
        } else if (_typeof(options.groupEditable) === 'object') {
          util.selectiveExtend(['order', 'add', 'remove'], this.options.groupEditable, options.groupEditable);
        }
      }

      // callback functions
      var addCallback = function (name) {
        var fn = options[name];
        if (fn) {
          if (!(fn instanceof Function)) {
            throw new Error('option ' + name + ' must be a function ' + name + '(item, callback)');
          }
          this.options[name] = fn;
        }
      }.bind(this);
      ['onAdd', 'onUpdate', 'onRemove', 'onMove', 'onMoving', 'onAddGroup', 'onMoveGroup', 'onRemoveGroup'].forEach(addCallback);

      // force the itemSet to refresh: options like orientation and margins may be changed
      this.markDirty();
    }
  };

  /**
   * Mark the ItemSet dirty so it will refresh everything with next redraw.
   * Optionally, all items can be marked as dirty and be refreshed.
   * @param {{refreshItems: boolean}} [options]
   */
  ItemSet.prototype.markDirty = function (options) {
    this.groupIds = [];
    this.stackDirty = true;

    if (options && options.refreshItems) {
      util.forEach(this.items, function (item) {
        item.dirty = true;
        if (item.displayed) item.redraw();
      });
    }
  };

  /**
   * Destroy the ItemSet
   */
  ItemSet.prototype.destroy = function () {
    this.hide();
    this.setItems(null);
    this.setGroups(null);

    this.hammer = null;

    this.body = null;
    this.conversion = null;
  };

  /**
   * Hide the component from the DOM
   */
  ItemSet.prototype.hide = function () {
    // remove the frame containing the items
    if (this.dom.frame.parentNode) {
      this.dom.frame.parentNode.removeChild(this.dom.frame);
    }

    // remove the axis with dots
    if (this.dom.axis.parentNode) {
      this.dom.axis.parentNode.removeChild(this.dom.axis);
    }

    // remove the labelset containing all group labels
    if (this.dom.labelSet.parentNode) {
      this.dom.labelSet.parentNode.removeChild(this.dom.labelSet);
    }
  };

  /**
   * Show the component in the DOM (when not already visible).
   * @return {Boolean} changed
   */
  ItemSet.prototype.show = function () {
    // show frame containing the items
    if (!this.dom.frame.parentNode) {
      this.body.dom.center.appendChild(this.dom.frame);
    }

    // show axis with dots
    if (!this.dom.axis.parentNode) {
      this.body.dom.backgroundVertical.appendChild(this.dom.axis);
    }

    // show labelset containing labels
    if (!this.dom.labelSet.parentNode) {
      if (this.options.rtl) {
        this.body.dom.right.appendChild(this.dom.labelSet);
      } else {
        this.body.dom.left.appendChild(this.dom.labelSet);
      }
    }
  };

  /**
   * Set selected items by their id. Replaces the current selection
   * Unknown id's are silently ignored.
   * @param {string[] | string} [ids] An array with zero or more id's of the items to be
   *                                  selected, or a single item id. If ids is undefined
   *                                  or an empty array, all items will be unselected.
   */
  ItemSet.prototype.setSelection = function (ids) {
    var i, ii, id, item;

    if (ids == undefined) ids = [];
    if (!Array.isArray(ids)) ids = [ids];

    // unselect currently selected items
    for (i = 0, ii = this.selection.length; i < ii; i++) {
      id = this.selection[i];
      item = this.items[id];
      if (item) item.unselect();
    }

    // select items
    this.selection = [];
    for (i = 0, ii = ids.length; i < ii; i++) {
      id = ids[i];
      item = this.items[id];
      if (item) {
        this.selection.push(id);
        item.select();
      }
    }
  };

  /**
   * Get the selected items by their id
   * @return {Array} ids  The ids of the selected items
   */
  ItemSet.prototype.getSelection = function () {
    return this.selection.concat([]);
  };

  /**
   * Get the id's of the currently visible items.
   * @returns {Array} The ids of the visible items
   */
  ItemSet.prototype.getVisibleItems = function () {
    var range = this.body.range.getRange();

    if (this.options.rtl) {
      var right = this.body.util.toScreen(range.start);
      var left = this.body.util.toScreen(range.end);
    } else {
      var left = this.body.util.toScreen(range.start);
      var right = this.body.util.toScreen(range.end);
    }

    var ids = [];
    for (var groupId in this.groups) {
      if (this.groups.hasOwnProperty(groupId)) {
        var group = this.groups[groupId];
        var rawVisibleItems = group.visibleItems;

        // filter the "raw" set with visibleItems into a set which is really
        // visible by pixels
        for (var i = 0; i < rawVisibleItems.length; i++) {
          var item = rawVisibleItems[i];
          // TODO: also check whether visible vertically
          if (this.options.rtl) {
            if (item.right < left && item.right + item.width > right) {
              ids.push(item.id);
            }
          } else {
            if (item.left < right && item.left + item.width > left) {
              ids.push(item.id);
            }
          }
        }
      }
    }

    return ids;
  };

  /**
   * Deselect a selected item
   * @param {String | Number} id
   * @private
   */
  ItemSet.prototype._deselect = function (id) {
    var selection = this.selection;
    for (var i = 0, ii = selection.length; i < ii; i++) {
      if (selection[i] == id) {
        // non-strict comparison!
        selection.splice(i, 1);
        break;
      }
    }
  };

  /**
   * Repaint the component
   * @return {boolean} Returns true if the component is resized
   */
  ItemSet.prototype.redraw = function () {
    var margin = this.options.margin,
        range = this.body.range,
        asSize = util.option.asSize,
        options = this.options,
        orientation = options.orientation.item,
        resized = false,
        frame = this.dom.frame;

    // recalculate absolute position (before redrawing groups)
    this.props.top = this.body.domProps.top.height + this.body.domProps.border.top;

    if (this.options.rtl) {
      this.props.right = this.body.domProps.right.width + this.body.domProps.border.right;
    } else {
      this.props.left = this.body.domProps.left.width + this.body.domProps.border.left;
    }

    // update class name
    frame.className = 'vis-itemset';

    // reorder the groups (if needed)
    resized = this._orderGroups() || resized;

    // check whether zoomed (in that case we need to re-stack everything)
    // TODO: would be nicer to get this as a trigger from Range
    var visibleInterval = range.end - range.start;
    var zoomed = visibleInterval != this.lastVisibleInterval || this.props.width != this.props.lastWidth;
    if (zoomed) this.stackDirty = true;
    this.lastVisibleInterval = visibleInterval;
    this.props.lastWidth = this.props.width;

    var restack = this.stackDirty;
    var firstGroup = this._firstGroup();
    var firstMargin = {
      item: margin.item,
      axis: margin.axis
    };
    var nonFirstMargin = {
      item: margin.item,
      axis: margin.item.vertical / 2
    };
    var height = 0;
    var minHeight = margin.axis + margin.item.vertical;

    // redraw the background group
    this.groups[BACKGROUND].redraw(range, nonFirstMargin, restack);

    // redraw all regular groups
    util.forEach(this.groups, function (group) {
      var groupMargin = group == firstGroup ? firstMargin : nonFirstMargin;
      var groupResized = group.redraw(range, groupMargin, restack);
      resized = groupResized || resized;
      height += group.height;
    });
    height = Math.max(height, minHeight);
    this.stackDirty = false;

    // update frame height
    frame.style.height = asSize(height);

    // calculate actual size
    this.props.width = frame.offsetWidth;
    this.props.height = height;

    // reposition axis
    this.dom.axis.style.top = asSize(orientation == 'top' ? this.body.domProps.top.height + this.body.domProps.border.top : this.body.domProps.top.height + this.body.domProps.centerContainer.height);
    if (this.options.rtl) {
      this.dom.axis.style.right = '0';
    } else {
      this.dom.axis.style.left = '0';
    }

    // check if this component is resized
    resized = this._isResized() || resized;

    return resized;
  };

  /**
   * Get the first group, aligned with the axis
   * @return {Group | null} firstGroup
   * @private
   */
  ItemSet.prototype._firstGroup = function () {
    var firstGroupIndex = this.options.orientation.item == 'top' ? 0 : this.groupIds.length - 1;
    var firstGroupId = this.groupIds[firstGroupIndex];
    var firstGroup = this.groups[firstGroupId] || this.groups[UNGROUPED];

    return firstGroup || null;
  };

  /**
   * Create or delete the group holding all ungrouped items. This group is used when
   * there are no groups specified.
   * @protected
   */
  ItemSet.prototype._updateUngrouped = function () {
    var ungrouped = this.groups[UNGROUPED];
    var background = this.groups[BACKGROUND];
    var item, itemId;

    if (this.groupsData) {
      // remove the group holding all ungrouped items
      if (ungrouped) {
        ungrouped.hide();
        delete this.groups[UNGROUPED];

        for (itemId in this.items) {
          if (this.items.hasOwnProperty(itemId)) {
            item = this.items[itemId];
            item.parent && item.parent.remove(item);
            var groupId = this._getGroupId(item.data);
            var group = this.groups[groupId];
            group && group.add(item) || item.hide();
          }
        }
      }
    } else {
      // create a group holding all (unfiltered) items
      if (!ungrouped) {
        var id = null;
        var data = null;
        ungrouped = new Group(id, data, this);
        this.groups[UNGROUPED] = ungrouped;

        for (itemId in this.items) {
          if (this.items.hasOwnProperty(itemId)) {
            item = this.items[itemId];
            ungrouped.add(item);
          }
        }

        ungrouped.show();
      }
    }
  };

  /**
   * Get the element for the labelset
   * @return {HTMLElement} labelSet
   */
  ItemSet.prototype.getLabelSet = function () {
    return this.dom.labelSet;
  };

  /**
   * Set items
   * @param {vis.DataSet | null} items
   */
  ItemSet.prototype.setItems = function (items) {
    var me = this,
        ids,
        oldItemsData = this.itemsData;

    // replace the dataset
    if (!items) {
      this.itemsData = null;
    } else if (items instanceof DataSet || items instanceof DataView) {
      this.itemsData = items;
    } else {
      throw new TypeError('Data must be an instance of DataSet or DataView');
    }

    if (oldItemsData) {
      // unsubscribe from old dataset
      util.forEach(this.itemListeners, function (callback, event) {
        oldItemsData.off(event, callback);
      });

      // remove all drawn items
      ids = oldItemsData.getIds();
      this._onRemove(ids);
    }

    if (this.itemsData) {
      // subscribe to new dataset
      var id = this.id;
      util.forEach(this.itemListeners, function (callback, event) {
        me.itemsData.on(event, callback, id);
      });

      // add all new items
      ids = this.itemsData.getIds();
      this._onAdd(ids);

      // update the group holding all ungrouped items
      this._updateUngrouped();
    }

    this.body.emitter.emit('_change', { queue: true });
  };

  /**
   * Get the current items
   * @returns {vis.DataSet | null}
   */
  ItemSet.prototype.getItems = function () {
    return this.itemsData;
  };

  /**
   * Set groups
   * @param {vis.DataSet} groups
   */
  ItemSet.prototype.setGroups = function (groups) {
    var me = this,
        ids;

    // unsubscribe from current dataset
    if (this.groupsData) {
      util.forEach(this.groupListeners, function (callback, event) {
        me.groupsData.off(event, callback);
      });

      // remove all drawn groups
      ids = this.groupsData.getIds();
      this.groupsData = null;
      this._onRemoveGroups(ids); // note: this will cause a redraw
    }

    // replace the dataset
    if (!groups) {
      this.groupsData = null;
    } else if (groups instanceof DataSet || groups instanceof DataView) {
      this.groupsData = groups;
    } else {
      throw new TypeError('Data must be an instance of DataSet or DataView');
    }

    if (this.groupsData) {
      // subscribe to new dataset
      var id = this.id;
      util.forEach(this.groupListeners, function (callback, event) {
        me.groupsData.on(event, callback, id);
      });

      // draw all ms
      ids = this.groupsData.getIds();
      this._onAddGroups(ids);
    }

    // update the group holding all ungrouped items
    this._updateUngrouped();

    // update the order of all items in each group
    this._order();

    this.body.emitter.emit('_change', { queue: true });
  };

  /**
   * Get the current groups
   * @returns {vis.DataSet | null} groups
   */
  ItemSet.prototype.getGroups = function () {
    return this.groupsData;
  };

  /**
   * Remove an item by its id
   * @param {String | Number} id
   */
  ItemSet.prototype.removeItem = function (id) {
    var item = this.itemsData.get(id),
        dataset = this.itemsData.getDataSet();

    if (item) {
      // confirm deletion
      this.options.onRemove(item, function (item) {
        if (item) {
          // remove by id here, it is possible that an item has no id defined
          // itself, so better not delete by the item itself
          dataset.remove(id);
        }
      });
    }
  };

  /**
   * Get the time of an item based on it's data and options.type
   * @param {Object} itemData
   * @returns {string} Returns the type
   * @private
   */
  ItemSet.prototype._getType = function (itemData) {
    return itemData.type || this.options.type || (itemData.end ? 'range' : 'box');
  };

  /**
   * Get the group id for an item
   * @param {Object} itemData
   * @returns {string} Returns the groupId
   * @private
   */
  ItemSet.prototype._getGroupId = function (itemData) {
    var type = this._getType(itemData);
    if (type == 'background' && itemData.group == undefined) {
      return BACKGROUND;
    } else {
      return this.groupsData ? itemData.group : UNGROUPED;
    }
  };

  /**
   * Handle updated items
   * @param {Number[]} ids
   * @protected
   */
  ItemSet.prototype._onUpdate = function (ids) {
    var me = this;

    ids.forEach(function (id) {
      var itemData = me.itemsData.get(id, me.itemOptions);
      var item = me.items[id];
      var type = itemData ? me._getType(itemData) : null;

      var constructor = ItemSet.types[type];
      var selected;

      if (item) {
        // update item
        if (!constructor || !(item instanceof constructor)) {
          // item type has changed, delete the item and recreate it
          selected = item.selected; // preserve selection of this item
          me._removeItem(item);
          item = null;
        } else {
          me._updateItem(item, itemData);
        }
      }

      if (!item && itemData) {
        // create item
        if (constructor) {
          item = new constructor(itemData, me.conversion, me.options);
          item.id = id; // TODO: not so nice setting id afterwards
          me._addItem(item);
          if (selected) {
            this.selection.push(id);
            item.select();
          }
        } else if (type == 'rangeoverflow') {
          // TODO: deprecated since version 2.1.0 (or 3.0.0?). cleanup some day
          throw new TypeError('Item type "rangeoverflow" is deprecated. Use css styling instead: ' + '.vis-item.vis-range .vis-item-content {overflow: visible;}');
        } else {
          throw new TypeError('Unknown item type "' + type + '"');
        }
      }
    }.bind(this));

    this._order();
    this.stackDirty = true; // force re-stacking of all items next redraw
    this.body.emitter.emit('_change', { queue: true });
  };

  /**
   * Handle added items
   * @param {Number[]} ids
   * @protected
   */
  ItemSet.prototype._onAdd = ItemSet.prototype._onUpdate;

  /**
   * Handle removed items
   * @param {Number[]} ids
   * @protected
   */
  ItemSet.prototype._onRemove = function (ids) {
    var count = 0;
    var me = this;
    ids.forEach(function (id) {
      var item = me.items[id];
      if (item) {
        count++;
        me._removeItem(item);
      }
    });

    if (count) {
      // update order
      this._order();
      this.stackDirty = true; // force re-stacking of all items next redraw
      this.body.emitter.emit('_change', { queue: true });
    }
  };

  /**
   * Update the order of item in all groups
   * @private
   */
  ItemSet.prototype._order = function () {
    // reorder the items in all groups
    // TODO: optimization: only reorder groups affected by the changed items
    util.forEach(this.groups, function (group) {
      group.order();
    });
  };

  /**
   * Handle updated groups
   * @param {Number[]} ids
   * @private
   */
  ItemSet.prototype._onUpdateGroups = function (ids) {
    this._onAddGroups(ids);
  };

  /**
   * Handle changed groups (added or updated)
   * @param {Number[]} ids
   * @private
   */
  ItemSet.prototype._onAddGroups = function (ids) {
    var me = this;

    ids.forEach(function (id) {
      var groupData = me.groupsData.get(id);
      var group = me.groups[id];

      if (!group) {
        // check for reserved ids
        if (id == UNGROUPED || id == BACKGROUND) {
          throw new Error('Illegal group id. ' + id + ' is a reserved id.');
        }

        var groupOptions = Object.create(me.options);
        util.extend(groupOptions, {
          height: null
        });

        group = new Group(id, groupData, me);
        me.groups[id] = group;

        // add items with this groupId to the new group
        for (var itemId in me.items) {
          if (me.items.hasOwnProperty(itemId)) {
            var item = me.items[itemId];
            if (item.data.group == id) {
              group.add(item);
            }
          }
        }

        group.order();
        group.show();
      } else {
        // update group
        group.setData(groupData);
      }
    });

    this.body.emitter.emit('_change', { queue: true });
  };

  /**
   * Handle removed groups
   * @param {Number[]} ids
   * @private
   */
  ItemSet.prototype._onRemoveGroups = function (ids) {
    var groups = this.groups;
    ids.forEach(function (id) {
      var group = groups[id];

      if (group) {
        group.hide();
        delete groups[id];
      }
    });

    this.markDirty();

    this.body.emitter.emit('_change', { queue: true });
  };

  /**
   * Reorder the groups if needed
   * @return {boolean} changed
   * @private
   */
  ItemSet.prototype._orderGroups = function () {
    if (this.groupsData) {
      // reorder the groups
      var groupIds = this.groupsData.getIds({
        order: this.options.groupOrder
      });

      var changed = !util.equalArray(groupIds, this.groupIds);
      if (changed) {
        // hide all groups, removes them from the DOM
        var groups = this.groups;
        groupIds.forEach(function (groupId) {
          groups[groupId].hide();
        });

        // show the groups again, attach them to the DOM in correct order
        groupIds.forEach(function (groupId) {
          groups[groupId].show();
        });

        this.groupIds = groupIds;
      }

      return changed;
    } else {
      return false;
    }
  };

  /**
   * Add a new item
   * @param {Item} item
   * @private
   */
  ItemSet.prototype._addItem = function (item) {
    this.items[item.id] = item;

    // add to group
    var groupId = this._getGroupId(item.data);
    var group = this.groups[groupId];
    if (group) group.add(item);
  };

  /**
   * Update an existing item
   * @param {Item} item
   * @param {Object} itemData
   * @private
   */
  ItemSet.prototype._updateItem = function (item, itemData) {
    var oldGroupId = item.data.group;
    var oldSubGroupId = item.data.subgroup;

    // update the items data (will redraw the item when displayed)
    item.setData(itemData);

    // update group
    if (oldGroupId != item.data.group || oldSubGroupId != item.data.subgroup) {
      var oldGroup = this.groups[oldGroupId];
      if (oldGroup) oldGroup.remove(item);

      var groupId = this._getGroupId(item.data);
      var group = this.groups[groupId];
      if (group) group.add(item);
    }
  };

  /**
   * Delete an item from the ItemSet: remove it from the DOM, from the map
   * with items, and from the map with visible items, and from the selection
   * @param {Item} item
   * @private
   */
  ItemSet.prototype._removeItem = function (item) {
    // remove from DOM
    item.hide();

    // remove from items
    delete this.items[item.id];

    // remove from selection
    var index = this.selection.indexOf(item.id);
    if (index != -1) this.selection.splice(index, 1);

    // remove from group
    item.parent && item.parent.remove(item);
  };

  /**
   * Create an array containing all items being a range (having an end date)
   * @param array
   * @returns {Array}
   * @private
   */
  ItemSet.prototype._constructByEndArray = function (array) {
    var endArray = [];

    for (var i = 0; i < array.length; i++) {
      if (array[i] instanceof RangeItem) {
        endArray.push(array[i]);
      }
    }
    return endArray;
  };

  /**
   * Register the clicked item on touch, before dragStart is initiated.
   *
   * dragStart is initiated from a mousemove event, AFTER the mouse/touch is
   * already moving. Therefore, the mouse/touch can sometimes be above an other
   * DOM element than the item itself.
   *
   * @param {Event} event
   * @private
   */
  ItemSet.prototype._onTouch = function (event) {
    // store the touched item, used in _onDragStart
    this.touchParams.item = this.itemFromTarget(event);
    this.touchParams.dragLeftItem = event.target.dragLeftItem || false;
    this.touchParams.dragRightItem = event.target.dragRightItem || false;
    this.touchParams.itemProps = null;
  };

  /**
   * Given an group id, returns the index it has.
   *
   * @param {Number} groupID
   * @private
   */
  ItemSet.prototype._getGroupIndex = function (groupId) {
    for (var i = 0; i < this.groupIds.length; i++) {
      if (groupId == this.groupIds[i]) return i;
    }
  };

  /**
   * Start dragging the selected events
   * @param {Event} event
   * @private
   */
  ItemSet.prototype._onDragStart = function (event) {
    var item = this.touchParams.item || null;
    var me = this;
    var props;

    if (item && (item.selected || this.options.itemsAlwaysDraggable)) {

      if (!this.options.editable.updateTime && !this.options.editable.updateGroup && !item.editable) {
        return;
      }

      // override options.editable
      if (item.editable === false) {
        return;
      }

      var dragLeftItem = this.touchParams.dragLeftItem;
      var dragRightItem = this.touchParams.dragRightItem;
      this.touchParams.itemIsDragging = true;

      if (dragLeftItem) {
        props = {
          item: dragLeftItem,
          initialX: event.center.x,
          dragLeft: true,
          data: this._cloneItemData(item.data)
        };

        this.touchParams.itemProps = [props];
      } else if (dragRightItem) {
        props = {
          item: dragRightItem,
          initialX: event.center.x,
          dragRight: true,
          data: this._cloneItemData(item.data)
        };

        this.touchParams.itemProps = [props];
      } else {
        this.touchParams.selectedItem = item;

        var baseGroupIndex = this._getGroupIndex(item.data.group);

        var itemsToDrag = this.options.itemsAlwaysDraggable && !item.selected ? [item.id] : this.getSelection();

        this.touchParams.itemProps = itemsToDrag.map(function (id) {
          var item = me.items[id];
          var groupIndex = me._getGroupIndex(item.data.group);
          return {
            item: item,
            initialX: event.center.x,
            groupOffset: baseGroupIndex - groupIndex,
            data: this._cloneItemData(item.data)
          };
        }.bind(this));
      }

      event.stopPropagation();
    } else if (this.options.editable.add && (event.srcEvent.ctrlKey || event.srcEvent.metaKey)) {
      // create a new range item when dragging with ctrl key down
      this._onDragStartAddItem(event);
    }
  };

  /**
   * Start creating a new range item by dragging.
   * @param {Event} event
   * @private
   */
  ItemSet.prototype._onDragStartAddItem = function (event) {
    var snap = this.options.snap || null;

    if (this.options.rtl) {
      var xAbs = util.getAbsoluteRight(this.dom.frame);
      var x = xAbs - event.center.x + 10; // plus 10 to compensate for the drag starting as soon as you've moved 10px
    } else {
      var xAbs = util.getAbsoluteLeft(this.dom.frame);
      var x = event.center.x - xAbs - 10; // minus 10 to compensate for the drag starting as soon as you've moved 10px
    }

    var time = this.body.util.toTime(x);
    var scale = this.body.util.getScale();
    var step = this.body.util.getStep();
    var start = snap ? snap(time, scale, step) : time;
    var end = start;

    var itemData = {
      type: 'range',
      start: start,
      end: end,
      content: 'new item'
    };

    var id = util.randomUUID();
    itemData[this.itemsData._fieldId] = id;

    var group = this.groupFromTarget(event);
    if (group) {
      itemData.group = group.groupId;
    }
    var newItem = new RangeItem(itemData, this.conversion, this.options);
    newItem.id = id; // TODO: not so nice setting id afterwards
    newItem.data = this._cloneItemData(itemData);
    this._addItem(newItem);

    var props = {
      item: newItem,
      initialX: event.center.x,
      data: newItem.data
    };

    if (this.options.rtl) {
      props.dragLeft = true;
    } else {
      props.dragRight = true;
    }
    this.touchParams.itemProps = [props];

    event.stopPropagation();
  };

  /**
   * Drag selected items
   * @param {Event} event
   * @private
   */
  ItemSet.prototype._onDrag = function (event) {
    if (this.touchParams.itemProps) {
      event.stopPropagation();

      var me = this;
      var snap = this.options.snap || null;

      if (this.options.rtl) {
        var xOffset = this.body.dom.root.offsetLeft + this.body.domProps.right.width;
      } else {
        var xOffset = this.body.dom.root.offsetLeft + this.body.domProps.left.width;
      }

      var scale = this.body.util.getScale();
      var step = this.body.util.getStep();

      //only calculate the new group for the item that's actually dragged
      var selectedItem = this.touchParams.selectedItem;
      var updateGroupAllowed = me.options.editable.updateGroup;
      var newGroupBase = null;
      if (updateGroupAllowed && selectedItem) {
        if (selectedItem.data.group != undefined) {
          // drag from one group to another
          var group = me.groupFromTarget(event);
          if (group) {
            //we know the offset for all items, so the new group for all items
            //will be relative to this one.
            newGroupBase = this._getGroupIndex(group.groupId);
          }
        }
      }

      // move
      this.touchParams.itemProps.forEach(function (props) {
        var current = me.body.util.toTime(event.center.x - xOffset);
        var initial = me.body.util.toTime(props.initialX - xOffset);

        if (this.options.rtl) {
          var offset = -(current - initial); // ms
        } else {
          var offset = current - initial; // ms
        }

        var itemData = this._cloneItemData(props.item.data); // clone the data
        if (props.item.editable === false) {
          return;
        }

        var updateTimeAllowed = me.options.editable.updateTime || props.item.editable === true;
        if (updateTimeAllowed) {
          if (props.dragLeft) {
            // drag left side of a range item
            if (this.options.rtl) {
              if (itemData.end != undefined) {
                var initialEnd = util.convert(props.data.end, 'Date');
                var end = new Date(initialEnd.valueOf() + offset);
                // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
                itemData.end = snap ? snap(end, scale, step) : end;
              }
            } else {
              if (itemData.start != undefined) {
                var initialStart = util.convert(props.data.start, 'Date');
                var start = new Date(initialStart.valueOf() + offset);
                // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
                itemData.start = snap ? snap(start, scale, step) : start;
              }
            }
          } else if (props.dragRight) {
            // drag right side of a range item
            if (this.options.rtl) {
              if (itemData.start != undefined) {
                var initialStart = util.convert(props.data.start, 'Date');
                var start = new Date(initialStart.valueOf() + offset);
                // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
                itemData.start = snap ? snap(start, scale, step) : start;
              }
            } else {
              if (itemData.end != undefined) {
                var initialEnd = util.convert(props.data.end, 'Date');
                var end = new Date(initialEnd.valueOf() + offset);
                // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
                itemData.end = snap ? snap(end, scale, step) : end;
              }
            }
          } else {
            // drag both start and end
            if (itemData.start != undefined) {

              var initialStart = util.convert(props.data.start, 'Date').valueOf();
              var start = new Date(initialStart + offset);

              if (itemData.end != undefined) {
                var initialEnd = util.convert(props.data.end, 'Date');
                var duration = initialEnd.valueOf() - initialStart.valueOf();

                // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
                itemData.start = snap ? snap(start, scale, step) : start;
                itemData.end = new Date(itemData.start.valueOf() + duration);
              } else {
                // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
                itemData.start = snap ? snap(start, scale, step) : start;
              }
            }
          }
        }

        var updateGroupAllowed = me.options.editable.updateGroup || props.item.editable === true;

        if (updateGroupAllowed && !props.dragLeft && !props.dragRight && newGroupBase != null) {
          if (itemData.group != undefined) {
            var newOffset = newGroupBase - props.groupOffset;

            //make sure we stay in bounds
            newOffset = Math.max(0, newOffset);
            newOffset = Math.min(me.groupIds.length - 1, newOffset);

            itemData.group = me.groupIds[newOffset];
          }
        }

        // confirm moving the item
        itemData = this._cloneItemData(itemData); // convert start and end to the correct type
        me.options.onMoving(itemData, function (itemData) {
          if (itemData) {
            props.item.setData(this._cloneItemData(itemData, 'Date'));
          }
        }.bind(this));
      }.bind(this));

      this.stackDirty = true; // force re-stacking of all items next redraw
      this.body.emitter.emit('_change');
    }
  };

  /**
   * Move an item to another group
   * @param {Item} item
   * @param {String | Number} groupId
   * @private
   */
  ItemSet.prototype._moveToGroup = function (item, groupId) {
    var group = this.groups[groupId];
    if (group && group.groupId != item.data.group) {
      var oldGroup = item.parent;
      oldGroup.remove(item);
      oldGroup.order();
      group.add(item);
      group.order();

      item.data.group = group.groupId;
    }
  };

  /**
   * End of dragging selected items
   * @param {Event} event
   * @private
   */
  ItemSet.prototype._onDragEnd = function (event) {
    if (this.touchParams.itemProps) {
      event.stopPropagation();

      var me = this;
      var dataset = this.itemsData.getDataSet();
      var itemProps = this.touchParams.itemProps;
      this.touchParams.itemProps = null;
      this.touchParams.itemIsDragging = false;

      itemProps.forEach(function (props) {
        var id = props.item.id;
        var exists = me.itemsData.get(id, me.itemOptions) != null;

        if (!exists) {
          // add a new item
          me.options.onAdd(props.item.data, function (itemData) {
            me._removeItem(props.item); // remove temporary item
            if (itemData) {
              me.itemsData.getDataSet().add(itemData);
            }

            // force re-stacking of all items next redraw
            me.stackDirty = true;
            me.body.emitter.emit('_change');
          });
        } else {
          // update existing item
          var itemData = this._cloneItemData(props.item.data); // convert start and end to the correct type
          me.options.onMove(itemData, function (itemData) {
            if (itemData) {
              // apply changes
              itemData[dataset._fieldId] = id; // ensure the item contains its id (can be undefined)
              dataset.update(itemData);
            } else {
              // restore original values
              props.item.setData(props.data);

              me.stackDirty = true; // force re-stacking of all items next redraw
              me.body.emitter.emit('_change');
            }
          });
        }
      }.bind(this));
    }
  };

  ItemSet.prototype._onGroupDragStart = function (event) {
    if (this.options.groupEditable.order) {
      this.groupTouchParams.group = this.groupFromTarget(event);

      if (this.groupTouchParams.group) {
        event.stopPropagation();

        this.groupTouchParams.originalOrder = this.groupsData.getIds({
          order: this.options.groupOrder
        });
      }
    }
  };

  ItemSet.prototype._onGroupDrag = function (event) {
    if (this.options.groupEditable.order && this.groupTouchParams.group) {
      event.stopPropagation();

      // drag from one group to another
      var group = this.groupFromTarget(event);

      // try to avoid toggling when groups differ in height
      if (group && group.height != this.groupTouchParams.group.height) {
        var movingUp = group.top < this.groupTouchParams.group.top;
        var clientY = event.center ? event.center.y : event.clientY;
        var targetGroupTop = util.getAbsoluteTop(group.dom.foreground);
        var draggedGroupHeight = this.groupTouchParams.group.height;
        if (movingUp) {
          // skip swapping the groups when the dragged group is not below clientY afterwards
          if (targetGroupTop + draggedGroupHeight < clientY) {
            return;
          }
        } else {
          var targetGroupHeight = group.height;
          // skip swapping the groups when the dragged group is not below clientY afterwards
          if (targetGroupTop + targetGroupHeight - draggedGroupHeight > clientY) {
            return;
          }
        }
      }

      if (group && group != this.groupTouchParams.group) {
        var groupsData = this.groupsData;
        var targetGroup = groupsData.get(group.groupId);
        var draggedGroup = groupsData.get(this.groupTouchParams.group.groupId);

        // switch groups
        if (draggedGroup && targetGroup) {
          this.options.groupOrderSwap(draggedGroup, targetGroup, this.groupsData);
          this.groupsData.update(draggedGroup);
          this.groupsData.update(targetGroup);
        }

        // fetch current order of groups
        var newOrder = this.groupsData.getIds({
          order: this.options.groupOrder
        });

        // in case of changes since _onGroupDragStart
        if (!util.equalArray(newOrder, this.groupTouchParams.originalOrder)) {
          var groupsData = this.groupsData;
          var origOrder = this.groupTouchParams.originalOrder;
          var draggedId = this.groupTouchParams.group.groupId;
          var numGroups = Math.min(origOrder.length, newOrder.length);
          var curPos = 0;
          var newOffset = 0;
          var orgOffset = 0;
          while (curPos < numGroups) {
            // as long as the groups are where they should be step down along the groups order
            while (curPos + newOffset < numGroups && curPos + orgOffset < numGroups && newOrder[curPos + newOffset] == origOrder[curPos + orgOffset]) {
              curPos++;
            }

            // all ok
            if (curPos + newOffset >= numGroups) {
              break;
            }

            // not all ok
            // if dragged group was move upwards everything below should have an offset
            if (newOrder[curPos + newOffset] == draggedId) {
              newOffset = 1;
              continue;
            }
            // if dragged group was move downwards everything above should have an offset
            else if (origOrder[curPos + orgOffset] == draggedId) {
                orgOffset = 1;
                continue;
              }
              // found a group (apart from dragged group) that has the wrong position -> switch with the 
              // group at the position where other one should be, fix index arrays and continue
              else {
                  var slippedPosition = newOrder.indexOf(origOrder[curPos + orgOffset]);
                  var switchGroup = groupsData.get(newOrder[curPos + newOffset]);
                  var shouldBeGroup = groupsData.get(origOrder[curPos + orgOffset]);
                  this.options.groupOrderSwap(switchGroup, shouldBeGroup, groupsData);
                  groupsData.update(switchGroup);
                  groupsData.update(shouldBeGroup);

                  var switchGroupId = newOrder[curPos + newOffset];
                  newOrder[curPos + newOffset] = origOrder[curPos + orgOffset];
                  newOrder[slippedPosition] = switchGroupId;

                  curPos++;
                }
          }
        }
      }
    }
  };

  ItemSet.prototype._onGroupDragEnd = function (event) {
    if (this.options.groupEditable.order && this.groupTouchParams.group) {
      event.stopPropagation();

      // update existing group
      var me = this;
      var id = me.groupTouchParams.group.groupId;
      var dataset = me.groupsData.getDataSet();
      var groupData = util.extend({}, dataset.get(id)); // clone the data
      me.options.onMoveGroup(groupData, function (groupData) {
        if (groupData) {
          // apply changes
          groupData[dataset._fieldId] = id; // ensure the group contains its id (can be undefined)
          dataset.update(groupData);
        } else {

          // fetch current order of groups
          var newOrder = dataset.getIds({
            order: me.options.groupOrder
          });

          // restore original order
          if (!util.equalArray(newOrder, me.groupTouchParams.originalOrder)) {
            var origOrder = me.groupTouchParams.originalOrder;
            var numGroups = Math.min(origOrder.length, newOrder.length);
            var curPos = 0;
            while (curPos < numGroups) {
              // as long as the groups are where they should be step down along the groups order
              while (curPos < numGroups && newOrder[curPos] == origOrder[curPos]) {
                curPos++;
              }

              // all ok
              if (curPos >= numGroups) {
                break;
              }

              // found a group that has the wrong position -> switch with the 
              // group at the position where other one should be, fix index arrays and continue
              var slippedPosition = newOrder.indexOf(origOrder[curPos]);
              var switchGroup = dataset.get(newOrder[curPos]);
              var shouldBeGroup = dataset.get(origOrder[curPos]);
              me.options.groupOrderSwap(switchGroup, shouldBeGroup, dataset);
              groupsData.update(switchGroup);
              groupsData.update(shouldBeGroup);

              var switchGroupId = newOrder[curPos];
              newOrder[curPos] = origOrder[curPos];
              newOrder[slippedPosition] = switchGroupId;

              curPos++;
            }
          }
        }
      });

      me.body.emitter.emit('groupDragged', { groupId: id });
    }
  };

  /**
   * Handle selecting/deselecting an item when tapping it
   * @param {Event} event
   * @private
   */
  ItemSet.prototype._onSelectItem = function (event) {
    if (!this.options.selectable) return;

    var ctrlKey = event.srcEvent && (event.srcEvent.ctrlKey || event.srcEvent.metaKey);
    var shiftKey = event.srcEvent && event.srcEvent.shiftKey;
    if (ctrlKey || shiftKey) {
      this._onMultiSelectItem(event);
      return;
    }

    var oldSelection = this.getSelection();

    var item = this.itemFromTarget(event);
    var selection = item ? [item.id] : [];
    this.setSelection(selection);

    var newSelection = this.getSelection();

    // emit a select event,
    // except when old selection is empty and new selection is still empty
    if (newSelection.length > 0 || oldSelection.length > 0) {
      this.body.emitter.emit('select', {
        items: newSelection,
        event: event
      });
    }
  };

  /**
   * Handle hovering an item
   * @param {Event} event
   * @private
   */
  ItemSet.prototype._onMouseOver = function (event) {
    var item = this.itemFromTarget(event);
    if (!item) return;
    this.body.emitter.emit('itemover', {
      item: item.id,
      event: event
    });
  };
  ItemSet.prototype._onMouseOut = function (event) {
    var item = this.itemFromTarget(event);
    if (!item) return;
    this.body.emitter.emit('itemout', {
      item: item.id,
      event: event
    });
  };

  /**
   * Handle creation and updates of an item on double tap
   * @param event
   * @private
   */
  ItemSet.prototype._onAddItem = function (event) {
    if (!this.options.selectable) return;
    if (!this.options.editable.add) return;

    var me = this;
    var snap = this.options.snap || null;
    var item = this.itemFromTarget(event);

    if (item) {
      // update item

      // execute async handler to update the item (or cancel it)
      var itemData = me.itemsData.get(item.id); // get a clone of the data from the dataset
      this.options.onUpdate(itemData, function (itemData) {
        if (itemData) {
          me.itemsData.getDataSet().update(itemData);
        }
      });
    } else {
      // add item
      if (this.options.rtl) {
        var xAbs = util.getAbsoluteRight(this.dom.frame);
        var x = xAbs - event.center.x;
      } else {
        var xAbs = util.getAbsoluteLeft(this.dom.frame);
        var x = event.center.x - xAbs;
      }
      // var xAbs = util.getAbsoluteLeft(this.dom.frame);
      // var x = event.center.x - xAbs;
      var start = this.body.util.toTime(x);
      var scale = this.body.util.getScale();
      var step = this.body.util.getStep();

      var newItemData = {
        start: snap ? snap(start, scale, step) : start,
        content: 'new item'
      };

      if (event.type == 'drop') {
        var itemData = JSON.parse(event.dataTransfer.getData("text/plain"));
        newItemData.content = itemData.content; // content is required 
        newItemData.type = itemData.type || 'box';
        newItemData[this.itemsData._fieldId] = itemData.id || util.randomUUID();

        if (itemData.type == 'range' || itemData.end && itemData.start) {

          if (!itemData.end) {
            var end = this.body.util.toTime(x + this.props.width / 5);
            newItemData.end = snap ? snap(end, scale, step) : end;
          } else {
            newItemData.end = new Date(newItemData.start._i).getTime() + new Date(itemData.end).getTime() - new Date(itemData.start).getTime();
          }
        }
      } else {
        newItemData[this.itemsData._fieldId] = util.randomUUID();

        // when default type is a range, add a default end date to the new item
        if (this.options.type === 'range') {
          var end = this.body.util.toTime(x + this.props.width / 5);
          newItemData.end = snap ? snap(end, scale, step) : end;
        }
      }

      var group = this.groupFromTarget(event);
      if (group) {
        newItemData.group = group.groupId;
      }

      // execute async handler to customize (or cancel) adding an item
      newItemData = this._cloneItemData(newItemData); // convert start and end to the correct type
      this.options.onAdd(newItemData, function (item) {
        if (item) {
          me.itemsData.getDataSet().add(item);
          if (event.type == 'drop') {
            me.setSelection([item.id]);
          }
          // TODO: need to trigger a redraw?
        }
      });
    }
  };

  /**
   * Handle selecting/deselecting multiple items when holding an item
   * @param {Event} event
   * @private
   */
  ItemSet.prototype._onMultiSelectItem = function (event) {
    if (!this.options.selectable) return;

    var item = this.itemFromTarget(event);

    if (item) {
      // multi select items (if allowed)

      var selection = this.options.multiselect ? this.getSelection() // take current selection
      : []; // deselect current selection

      var shiftKey = event.srcEvent && event.srcEvent.shiftKey || false;

      if (shiftKey && this.options.multiselect) {
        // select all items between the old selection and the tapped item
        var itemGroup = this.itemsData.get(item.id).group;

        // when filtering get the group of the last selected item
        var lastSelectedGroup = undefined;
        if (this.options.multiselectPerGroup) {
          if (selection.length > 0) {
            lastSelectedGroup = this.itemsData.get(selection[0]).group;
          }
        }

        // determine the selection range
        if (!this.options.multiselectPerGroup || lastSelectedGroup == undefined || lastSelectedGroup == itemGroup) {
          selection.push(item.id);
        }
        var range = ItemSet._getItemRange(this.itemsData.get(selection, this.itemOptions));

        if (!this.options.multiselectPerGroup || lastSelectedGroup == itemGroup) {
          // select all items within the selection range
          selection = [];
          for (var id in this.items) {
            if (this.items.hasOwnProperty(id)) {
              var _item = this.items[id];
              var start = _item.data.start;
              var end = _item.data.end !== undefined ? _item.data.end : start;

              if (start >= range.min && end <= range.max && (!this.options.multiselectPerGroup || lastSelectedGroup == this.itemsData.get(_item.id).group) && !(_item instanceof BackgroundItem)) {
                selection.push(_item.id); // do not use id but item.id, id itself is stringified
              }
            }
          }
        }
      } else {
        // add/remove this item from the current selection
        var index = selection.indexOf(item.id);
        if (index == -1) {
          // item is not yet selected -> select it
          selection.push(item.id);
        } else {
          // item is already selected -> deselect it
          selection.splice(index, 1);
        }
      }

      this.setSelection(selection);

      this.body.emitter.emit('select', {
        items: this.getSelection(),
        event: event
      });
    }
  };

  /**
   * Calculate the time range of a list of items
   * @param {Array.<Object>} itemsData
   * @return {{min: Date, max: Date}} Returns the range of the provided items
   * @private
   */
  ItemSet._getItemRange = function (itemsData) {
    var max = null;
    var min = null;

    itemsData.forEach(function (data) {
      if (min == null || data.start < min) {
        min = data.start;
      }

      if (data.end != undefined) {
        if (max == null || data.end > max) {
          max = data.end;
        }
      } else {
        if (max == null || data.start > max) {
          max = data.start;
        }
      }
    });

    return {
      min: min,
      max: max
    };
  };

  /**
   * Find an item from an event target:
   * searches for the attribute 'timeline-item' in the event target's element tree
   * @param {Event} event
   * @return {Item | null} item
   */
  ItemSet.prototype.itemFromTarget = function (event) {
    var target = event.target;
    while (target) {
      if (target.hasOwnProperty('timeline-item')) {
        return target['timeline-item'];
      }
      target = target.parentNode;
    }

    return null;
  };

  /**
   * Find the Group from an event target:
   * searches for the attribute 'timeline-group' in the event target's element tree
   * @param {Event} event
   * @return {Group | null} group
   */
  ItemSet.prototype.groupFromTarget = function (event) {
    var clientY = event.center ? event.center.y : event.clientY;
    for (var i = 0; i < this.groupIds.length; i++) {
      var groupId = this.groupIds[i];
      var group = this.groups[groupId];
      var foreground = group.dom.foreground;
      var top = util.getAbsoluteTop(foreground);
      if (clientY > top && clientY < top + foreground.offsetHeight) {
        return group;
      }

      if (this.options.orientation.item === 'top') {
        if (i === this.groupIds.length - 1 && clientY > top) {
          return group;
        }
      } else {
        if (i === 0 && clientY < top + foreground.offset) {
          return group;
        }
      }
    }

    return null;
  };

  /**
   * Find the ItemSet from an event target:
   * searches for the attribute 'timeline-itemset' in the event target's element tree
   * @param {Event} event
   * @return {ItemSet | null} item
   */
  ItemSet.itemSetFromTarget = function (event) {
    var target = event.target;
    while (target) {
      if (target.hasOwnProperty('timeline-itemset')) {
        return target['timeline-itemset'];
      }
      target = target.parentNode;
    }

    return null;
  };

  /**
   * Clone the data of an item, and "normalize" it: convert the start and end date
   * to the type (Date, Moment, ...) configured in the DataSet. If not configured,
   * start and end are converted to Date.
   * @param {Object} itemData, typically `item.data`
   * @param {string} [type]  Optional Date type. If not provided, the type from the DataSet is taken
   * @return {Object} The cloned object
   * @private
   */
  ItemSet.prototype._cloneItemData = function (itemData, type) {
    var clone = util.extend({}, itemData);

    if (!type) {
      // convert start and end date to the type (Date, Moment, ...) configured in the DataSet
      type = this.itemsData.getDataSet()._options.type;
    }

    if (clone.start != undefined) {
      clone.start = util.convert(clone.start, type && type.start || 'Date');
    }
    if (clone.end != undefined) {
      clone.end = util.convert(clone.end, type && type.end || 'Date');
    }

    return clone;
  };

  module.exports = ItemSet;

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var moment = __webpack_require__(2);
  var DateUtil = __webpack_require__(34);
  var util = __webpack_require__(1);

  /**
   * @constructor  TimeStep
   * The class TimeStep is an iterator for dates. You provide a start date and an
   * end date. The class itself determines the best scale (step size) based on the
   * provided start Date, end Date, and minimumStep.
   *
   * If minimumStep is provided, the step size is chosen as close as possible
   * to the minimumStep but larger than minimumStep. If minimumStep is not
   * provided, the scale is set to 1 DAY.
   * The minimumStep should correspond with the onscreen size of about 6 characters
   *
   * Alternatively, you can set a scale by hand.
   * After creation, you can initialize the class by executing first(). Then you
   * can iterate from the start date to the end date via next(). You can check if
   * the end date is reached with the function hasNext(). After each step, you can
   * retrieve the current date via getCurrent().
   * The TimeStep has scales ranging from milliseconds, seconds, minutes, hours,
   * days, to years.
   *
   * Version: 1.2
   *
   * @param {Date} [start]         The start date, for example new Date(2010, 9, 21)
   *                               or new Date(2010, 9, 21, 23, 45, 00)
   * @param {Date} [end]           The end date
   * @param {Number} [minimumStep] Optional. Minimum step size in milliseconds
   */
  function TimeStep(start, end, minimumStep, hiddenDates) {
    this.moment = moment;

    // variables
    this.current = this.moment();
    this._start = this.moment();
    this._end = this.moment();

    this.autoScale = true;
    this.scale = 'day';
    this.step = 1;

    // initialize the range
    this.setRange(start, end, minimumStep);

    // hidden Dates options
    this.switchedDay = false;
    this.switchedMonth = false;
    this.switchedYear = false;
    if (Array.isArray(hiddenDates)) {
      this.hiddenDates = hiddenDates;
    } else if (hiddenDates != undefined) {
      this.hiddenDates = [hiddenDates];
    } else {
      this.hiddenDates = [];
    }

    this.format = TimeStep.FORMAT; // default formatting
  }

  // Time formatting
  TimeStep.FORMAT = {
    minorLabels: {
      millisecond: 'SSS',
      second: 's',
      minute: 'HH:mm',
      hour: 'HH:mm',
      weekday: 'ddd D',
      day: 'D',
      month: 'MMM',
      year: 'YYYY'
    },
    majorLabels: {
      millisecond: 'HH:mm:ss',
      second: 'D MMMM HH:mm',
      minute: 'ddd D MMMM',
      hour: 'ddd D MMMM',
      weekday: 'MMMM YYYY',
      day: 'MMMM YYYY',
      month: 'YYYY',
      year: ''
    }
  };

  /**
   * Set custom constructor function for moment. Can be used to set dates
   * to UTC or to set a utcOffset.
   * @param {function} moment
   */
  TimeStep.prototype.setMoment = function (moment) {
    this.moment = moment;

    // update the date properties, can have a new utcOffset
    this.current = this.moment(this.current.valueOf());
    this._start = this.moment(this._start.valueOf());
    this._end = this.moment(this._end.valueOf());
  };

  /**
   * Set custom formatting for the minor an major labels of the TimeStep.
   * Both `minorLabels` and `majorLabels` are an Object with properties:
   * 'millisecond', 'second', 'minute', 'hour', 'weekday', 'day', 'month', 'year'.
   * @param {{minorLabels: Object, majorLabels: Object}} format
   */
  TimeStep.prototype.setFormat = function (format) {
    var defaultFormat = util.deepExtend({}, TimeStep.FORMAT);
    this.format = util.deepExtend(defaultFormat, format);
  };

  /**
   * Set a new range
   * If minimumStep is provided, the step size is chosen as close as possible
   * to the minimumStep but larger than minimumStep. If minimumStep is not
   * provided, the scale is set to 1 DAY.
   * The minimumStep should correspond with the onscreen size of about 6 characters
   * @param {Date} [start]      The start date and time.
   * @param {Date} [end]        The end date and time.
   * @param {int} [minimumStep] Optional. Minimum step size in milliseconds
   */
  TimeStep.prototype.setRange = function (start, end, minimumStep) {
    if (!(start instanceof Date) || !(end instanceof Date)) {
      throw "No legal start or end date in method setRange";
    }

    this._start = start != undefined ? this.moment(start.valueOf()) : new Date();
    this._end = end != undefined ? this.moment(end.valueOf()) : new Date();

    if (this.autoScale) {
      this.setMinimumStep(minimumStep);
    }
  };

  /**
   * Set the range iterator to the start date.
   */
  TimeStep.prototype.start = function () {
    this.current = this._start.clone();
    this.roundToMinor();
  };

  /**
   * Round the current date to the first minor date value
   * This must be executed once when the current date is set to start Date
   */
  TimeStep.prototype.roundToMinor = function () {
    // round to floor
    // IMPORTANT: we have no breaks in this switch! (this is no bug)
    // noinspection FallThroughInSwitchStatementJS
    switch (this.scale) {
      case 'year':
        this.current.year(this.step * Math.floor(this.current.year() / this.step));
        this.current.month(0);
      case 'month':
        this.current.date(1);
      case 'day': // intentional fall through
      case 'weekday':
        this.current.hours(0);
      case 'hour':
        this.current.minutes(0);
      case 'minute':
        this.current.seconds(0);
      case 'second':
        this.current.milliseconds(0);
      //case 'millisecond': // nothing to do for milliseconds
    }

    if (this.step != 1) {
      // round down to the first minor value that is a multiple of the current step size
      switch (this.scale) {
        case 'millisecond':
          this.current.subtract(this.current.milliseconds() % this.step, 'milliseconds');break;
        case 'second':
          this.current.subtract(this.current.seconds() % this.step, 'seconds');break;
        case 'minute':
          this.current.subtract(this.current.minutes() % this.step, 'minutes');break;
        case 'hour':
          this.current.subtract(this.current.hours() % this.step, 'hours');break;
        case 'weekday': // intentional fall through
        case 'day':
          this.current.subtract((this.current.date() - 1) % this.step, 'day');break;
        case 'month':
          this.current.subtract(this.current.month() % this.step, 'month');break;
        case 'year':
          this.current.subtract(this.current.year() % this.step, 'year');break;
        default:
          break;
      }
    }
  };

  /**
   * Check if the there is a next step
   * @return {boolean}  true if the current date has not passed the end date
   */
  TimeStep.prototype.hasNext = function () {
    return this.current.valueOf() <= this._end.valueOf();
  };

  /**
   * Do the next step
   */
  TimeStep.prototype.next = function () {
    var prev = this.current.valueOf();

    // Two cases, needed to prevent issues with switching daylight savings
    // (end of March and end of October)
    if (this.current.month() < 6) {
      switch (this.scale) {
        case 'millisecond':
          this.current.add(this.step, 'millisecond');break;
        case 'second':
          this.current.add(this.step, 'second');break;
        case 'minute':
          this.current.add(this.step, 'minute');break;
        case 'hour':
          this.current.add(this.step, 'hour');
          // in case of skipping an hour for daylight savings, adjust the hour again (else you get: 0h 5h 9h ... instead of 0h 4h 8h ...)
          // TODO: is this still needed now we use the function of moment.js?
          this.current.subtract(this.current.hours() % this.step, 'hour');
          break;
        case 'weekday': // intentional fall through
        case 'day':
          this.current.add(this.step, 'day');break;
        case 'month':
          this.current.add(this.step, 'month');break;
        case 'year':
          this.current.add(this.step, 'year');break;
        default:
          break;
      }
    } else {
      switch (this.scale) {
        case 'millisecond':
          this.current.add(this.step, 'millisecond');break;
        case 'second':
          this.current.add(this.step, 'second');break;
        case 'minute':
          this.current.add(this.step, 'minute');break;
        case 'hour':
          this.current.add(this.step, 'hour');break;
        case 'weekday': // intentional fall through
        case 'day':
          this.current.add(this.step, 'day');break;
        case 'month':
          this.current.add(this.step, 'month');break;
        case 'year':
          this.current.add(this.step, 'year');break;
        default:
          break;
      }
    }

    if (this.step != 1) {
      // round down to the correct major value
      switch (this.scale) {
        case 'millisecond':
          if (this.current.milliseconds() < this.step) this.current.milliseconds(0);break;
        case 'second':
          if (this.current.seconds() < this.step) this.current.seconds(0);break;
        case 'minute':
          if (this.current.minutes() < this.step) this.current.minutes(0);break;
        case 'hour':
          if (this.current.hours() < this.step) this.current.hours(0);break;
        case 'weekday': // intentional fall through
        case 'day':
          if (this.current.date() < this.step + 1) this.current.date(1);break;
        case 'month':
          if (this.current.month() < this.step) this.current.month(0);break;
        case 'year':
          break; // nothing to do for year
        default:
          break;
      }
    }

    // safety mechanism: if current time is still unchanged, move to the end
    if (this.current.valueOf() == prev) {
      this.current = this._end.clone();
    }

    // Reset switches for year, month and day. Will get set to true where appropriate in DateUtil.stepOverHiddenDates
    this.switchedDay = false;
    this.switchedMonth = false;
    this.switchedYear = false;

    DateUtil.stepOverHiddenDates(this.moment, this, prev);
  };

  /**
   * Get the current datetime
   * @return {Moment}  current The current date
   */
  TimeStep.prototype.getCurrent = function () {
    return this.current;
  };

  /**
   * Set a custom scale. Autoscaling will be disabled.
   * For example setScale('minute', 5) will result
   * in minor steps of 5 minutes, and major steps of an hour.
   *
   * @param {{scale: string, step: number}} params
   *                               An object containing two properties:
   *                               - A string 'scale'. Choose from 'millisecond', 'second',
   *                                 'minute', 'hour', 'weekday', 'day', 'month', 'year'.
   *                               - A number 'step'. A step size, by default 1.
   *                                 Choose for example 1, 2, 5, or 10.
   */
  TimeStep.prototype.setScale = function (params) {
    if (params && typeof params.scale == 'string') {
      this.scale = params.scale;
      this.step = params.step > 0 ? params.step : 1;
      this.autoScale = false;
    }
  };

  /**
   * Enable or disable autoscaling
   * @param {boolean} enable  If true, autoascaling is set true
   */
  TimeStep.prototype.setAutoScale = function (enable) {
    this.autoScale = enable;
  };

  /**
   * Automatically determine the scale that bests fits the provided minimum step
   * @param {Number} [minimumStep]  The minimum step size in milliseconds
   */
  TimeStep.prototype.setMinimumStep = function (minimumStep) {
    if (minimumStep == undefined) {
      return;
    }

    //var b = asc + ds;

    var stepYear = 1000 * 60 * 60 * 24 * 30 * 12;
    var stepMonth = 1000 * 60 * 60 * 24 * 30;
    var stepDay = 1000 * 60 * 60 * 24;
    var stepHour = 1000 * 60 * 60;
    var stepMinute = 1000 * 60;
    var stepSecond = 1000;
    var stepMillisecond = 1;

    // find the smallest step that is larger than the provided minimumStep
    if (stepYear * 1000 > minimumStep) {
      this.scale = 'year';this.step = 1000;
    }
    if (stepYear * 500 > minimumStep) {
      this.scale = 'year';this.step = 500;
    }
    if (stepYear * 100 > minimumStep) {
      this.scale = 'year';this.step = 100;
    }
    if (stepYear * 50 > minimumStep) {
      this.scale = 'year';this.step = 50;
    }
    if (stepYear * 10 > minimumStep) {
      this.scale = 'year';this.step = 10;
    }
    if (stepYear * 5 > minimumStep) {
      this.scale = 'year';this.step = 5;
    }
    if (stepYear > minimumStep) {
      this.scale = 'year';this.step = 1;
    }
    if (stepMonth * 3 > minimumStep) {
      this.scale = 'month';this.step = 3;
    }
    if (stepMonth > minimumStep) {
      this.scale = 'month';this.step = 1;
    }
    if (stepDay * 5 > minimumStep) {
      this.scale = 'day';this.step = 5;
    }
    if (stepDay * 2 > minimumStep) {
      this.scale = 'day';this.step = 2;
    }
    if (stepDay > minimumStep) {
      this.scale = 'day';this.step = 1;
    }
    if (stepDay / 2 > minimumStep) {
      this.scale = 'weekday';this.step = 1;
    }
    if (stepHour * 4 > minimumStep) {
      this.scale = 'hour';this.step = 4;
    }
    if (stepHour > minimumStep) {
      this.scale = 'hour';this.step = 1;
    }
    if (stepMinute * 15 > minimumStep) {
      this.scale = 'minute';this.step = 15;
    }
    if (stepMinute * 10 > minimumStep) {
      this.scale = 'minute';this.step = 10;
    }
    if (stepMinute * 5 > minimumStep) {
      this.scale = 'minute';this.step = 5;
    }
    if (stepMinute > minimumStep) {
      this.scale = 'minute';this.step = 1;
    }
    if (stepSecond * 15 > minimumStep) {
      this.scale = 'second';this.step = 15;
    }
    if (stepSecond * 10 > minimumStep) {
      this.scale = 'second';this.step = 10;
    }
    if (stepSecond * 5 > minimumStep) {
      this.scale = 'second';this.step = 5;
    }
    if (stepSecond > minimumStep) {
      this.scale = 'second';this.step = 1;
    }
    if (stepMillisecond * 200 > minimumStep) {
      this.scale = 'millisecond';this.step = 200;
    }
    if (stepMillisecond * 100 > minimumStep) {
      this.scale = 'millisecond';this.step = 100;
    }
    if (stepMillisecond * 50 > minimumStep) {
      this.scale = 'millisecond';this.step = 50;
    }
    if (stepMillisecond * 10 > minimumStep) {
      this.scale = 'millisecond';this.step = 10;
    }
    if (stepMillisecond * 5 > minimumStep) {
      this.scale = 'millisecond';this.step = 5;
    }
    if (stepMillisecond > minimumStep) {
      this.scale = 'millisecond';this.step = 1;
    }
  };

  /**
   * Snap a date to a rounded value.
   * The snap intervals are dependent on the current scale and step.
   * Static function
   * @param {Date} date    the date to be snapped.
   * @param {string} scale Current scale, can be 'millisecond', 'second',
   *                       'minute', 'hour', 'weekday, 'day', 'month', 'year'.
   * @param {number} step  Current step (1, 2, 4, 5, ...
   * @return {Date} snappedDate
   */
  TimeStep.snap = function (date, scale, step) {
    var clone = moment(date);

    if (scale == 'year') {
      var year = clone.year() + Math.round(clone.month() / 12);
      clone.year(Math.round(year / step) * step);
      clone.month(0);
      clone.date(0);
      clone.hours(0);
      clone.minutes(0);
      clone.seconds(0);
      clone.milliseconds(0);
    } else if (scale == 'month') {
      if (clone.date() > 15) {
        clone.date(1);
        clone.add(1, 'month');
        // important: first set Date to 1, after that change the month.
      } else {
        clone.date(1);
      }

      clone.hours(0);
      clone.minutes(0);
      clone.seconds(0);
      clone.milliseconds(0);
    } else if (scale == 'day') {
      //noinspection FallthroughInSwitchStatementJS
      switch (step) {
        case 5:
        case 2:
          clone.hours(Math.round(clone.hours() / 24) * 24);break;
        default:
          clone.hours(Math.round(clone.hours() / 12) * 12);break;
      }
      clone.minutes(0);
      clone.seconds(0);
      clone.milliseconds(0);
    } else if (scale == 'weekday') {
      //noinspection FallthroughInSwitchStatementJS
      switch (step) {
        case 5:
        case 2:
          clone.hours(Math.round(clone.hours() / 12) * 12);break;
        default:
          clone.hours(Math.round(clone.hours() / 6) * 6);break;
      }
      clone.minutes(0);
      clone.seconds(0);
      clone.milliseconds(0);
    } else if (scale == 'hour') {
      switch (step) {
        case 4:
          clone.minutes(Math.round(clone.minutes() / 60) * 60);break;
        default:
          clone.minutes(Math.round(clone.minutes() / 30) * 30);break;
      }
      clone.seconds(0);
      clone.milliseconds(0);
    } else if (scale == 'minute') {
      //noinspection FallthroughInSwitchStatementJS
      switch (step) {
        case 15:
        case 10:
          clone.minutes(Math.round(clone.minutes() / 5) * 5);
          clone.seconds(0);
          break;
        case 5:
          clone.seconds(Math.round(clone.seconds() / 60) * 60);break;
        default:
          clone.seconds(Math.round(clone.seconds() / 30) * 30);break;
      }
      clone.milliseconds(0);
    } else if (scale == 'second') {
      //noinspection FallthroughInSwitchStatementJS
      switch (step) {
        case 15:
        case 10:
          clone.seconds(Math.round(clone.seconds() / 5) * 5);
          clone.milliseconds(0);
          break;
        case 5:
          clone.milliseconds(Math.round(clone.milliseconds() / 1000) * 1000);break;
        default:
          clone.milliseconds(Math.round(clone.milliseconds() / 500) * 500);break;
      }
    } else if (scale == 'millisecond') {
      var _step = step > 5 ? step / 2 : 1;
      clone.milliseconds(Math.round(clone.milliseconds() / _step) * _step);
    }

    return clone;
  };

  /**
   * Check if the current value is a major value (for example when the step
   * is DAY, a major value is each first day of the MONTH)
   * @return {boolean} true if current date is major, else false.
   */
  TimeStep.prototype.isMajor = function () {
    if (this.switchedYear == true) {
      switch (this.scale) {
        case 'year':
        case 'month':
        case 'weekday':
        case 'day':
        case 'hour':
        case 'minute':
        case 'second':
        case 'millisecond':
          return true;
        default:
          return false;
      }
    } else if (this.switchedMonth == true) {
      switch (this.scale) {
        case 'weekday':
        case 'day':
        case 'hour':
        case 'minute':
        case 'second':
        case 'millisecond':
          return true;
        default:
          return false;
      }
    } else if (this.switchedDay == true) {
      switch (this.scale) {
        case 'millisecond':
        case 'second':
        case 'minute':
        case 'hour':
          return true;
        default:
          return false;
      }
    }

    var date = this.moment(this.current);
    switch (this.scale) {
      case 'millisecond':
        return date.milliseconds() == 0;
      case 'second':
        return date.seconds() == 0;
      case 'minute':
        return date.hours() == 0 && date.minutes() == 0;
      case 'hour':
        return date.hours() == 0;
      case 'weekday': // intentional fall through
      case 'day':
        return date.date() == 1;
      case 'month':
        return date.month() == 0;
      case 'year':
        return false;
      default:
        return false;
    }
  };

  /**
   * Returns formatted text for the minor axislabel, depending on the current
   * date and the scale. For example when scale is MINUTE, the current time is
   * formatted as "hh:mm".
   * @param {Date} [date] custom date. if not provided, current date is taken
   */
  TimeStep.prototype.getLabelMinor = function (date) {
    if (date == undefined) {
      date = this.current;
    }

    if (typeof this.format.minorLabels === "function") {
      return this.format.minorLabels(date, this.scale, this.step);
    }

    var format = this.format.minorLabels[this.scale];
    return format && format.length > 0 ? this.moment(date).format(format) : '';
  };

  /**
   * Returns formatted text for the major axis label, depending on the current
   * date and the scale. For example when scale is MINUTE, the major scale is
   * hours, and the hour will be formatted as "hh".
   * @param {Date} [date] custom date. if not provided, current date is taken
   */
  TimeStep.prototype.getLabelMajor = function (date) {
    if (date == undefined) {
      date = this.current;
    }

    if (typeof this.format.majorLabels === "function") {
      return this.format.majorLabels(date, this.scale, this.step);
    }

    var format = this.format.majorLabels[this.scale];
    return format && format.length > 0 ? this.moment(date).format(format) : '';
  };

  TimeStep.prototype.getClassName = function () {
    var _moment = this.moment;
    var m = this.moment(this.current);
    var current = m.locale ? m.locale('en') : m.lang('en'); // old versions of moment have .lang() function
    var step = this.step;

    function even(value) {
      return value / step % 2 == 0 ? ' vis-even' : ' vis-odd';
    }

    function today(date) {
      if (date.isSame(new Date(), 'day')) {
        return ' vis-today';
      }
      if (date.isSame(_moment().add(1, 'day'), 'day')) {
        return ' vis-tomorrow';
      }
      if (date.isSame(_moment().add(-1, 'day'), 'day')) {
        return ' vis-yesterday';
      }
      return '';
    }

    function currentWeek(date) {
      return date.isSame(new Date(), 'week') ? ' vis-current-week' : '';
    }

    function currentMonth(date) {
      return date.isSame(new Date(), 'month') ? ' vis-current-month' : '';
    }

    function currentYear(date) {
      return date.isSame(new Date(), 'year') ? ' vis-current-year' : '';
    }

    switch (this.scale) {
      case 'millisecond':
        return today(current) + even(current.milliseconds()).trim();

      case 'second':
        return today(current) + even(current.seconds()).trim();

      case 'minute':
        return today(current) + even(current.minutes()).trim();

      case 'hour':
        return 'vis-h' + current.hours() + (this.step == 4 ? '-h' + (current.hours() + 4) : '') + today(current) + even(current.hours());

      case 'weekday':
        return 'vis-' + current.format('dddd').toLowerCase() + today(current) + currentWeek(current) + even(current.date());

      case 'day':
        return 'vis-day' + current.date() + ' vis-' + current.format('MMMM').toLowerCase() + today(current) + currentMonth(current) + this.step <= 2 ? today(current) : '' + this.step <= 2 ? ' vis-' + current.format('dddd').toLowerCase() : '' + even(current.date() - 1);

      case 'month':
        return 'vis-' + current.format('MMMM').toLowerCase() + currentMonth(current) + even(current.month());

      case 'year':
        var year = current.year();
        return 'vis-year' + year + currentYear(current) + even(year);

      default:
        return '';
    }
  };

  module.exports = TimeStep;

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);
  var stack = __webpack_require__(39);
  var RangeItem = __webpack_require__(40);

  /**
   * @constructor Group
   * @param {Number | String} groupId
   * @param {Object} data
   * @param {ItemSet} itemSet
   */
  function Group(groupId, data, itemSet) {
    this.groupId = groupId;
    this.subgroups = {};
    this.subgroupIndex = 0;
    this.subgroupOrderer = data && data.subgroupOrder;
    this.itemSet = itemSet;
    this.isVisible = null;

    this.dom = {};
    this.props = {
      label: {
        width: 0,
        height: 0
      }
    };
    this.className = null;

    this.items = {}; // items filtered by groupId of this group
    this.visibleItems = []; // items currently visible in window
    this.orderedItems = {
      byStart: [],
      byEnd: []
    };
    this.checkRangedItems = false; // needed to refresh the ranged items if the window is programatically changed with NO overlap.
    var me = this;
    this.itemSet.body.emitter.on("checkRangedItems", function () {
      me.checkRangedItems = true;
    });

    this._create();

    this.setData(data);
  }

  /**
   * Create DOM elements for the group
   * @private
   */
  Group.prototype._create = function () {
    var label = document.createElement('div');
    if (this.itemSet.options.groupEditable.order) {
      label.className = 'vis-label draggable';
    } else {
      label.className = 'vis-label';
    }
    this.dom.label = label;

    var inner = document.createElement('div');
    inner.className = 'vis-inner';
    label.appendChild(inner);
    this.dom.inner = inner;

    var foreground = document.createElement('div');
    foreground.className = 'vis-group';
    foreground['timeline-group'] = this;
    this.dom.foreground = foreground;

    this.dom.background = document.createElement('div');
    this.dom.background.className = 'vis-group';

    this.dom.axis = document.createElement('div');
    this.dom.axis.className = 'vis-group';

    // create a hidden marker to detect when the Timelines container is attached
    // to the DOM, or the style of a parent of the Timeline is changed from
    // display:none is changed to visible.
    this.dom.marker = document.createElement('div');
    this.dom.marker.style.visibility = 'hidden';
    this.dom.marker.innerHTML = '?';
    this.dom.background.appendChild(this.dom.marker);
  };

  /**
   * Set the group data for this group
   * @param {Object} data   Group data, can contain properties content and className
   */
  Group.prototype.setData = function (data) {
    // update contents
    var content;
    var templateFunction;

    if (this.itemSet.options && this.itemSet.options.groupTemplate) {
      templateFunction = this.itemSet.options.groupTemplate.bind(this);
      content = templateFunction(data, this.dom.inner);
    } else {
      content = data && data.content;
    }

    if (content instanceof Element) {
      this.dom.inner.appendChild(content);
      while (this.dom.inner.firstChild) {
        this.dom.inner.removeChild(this.dom.inner.firstChild);
      }
      this.dom.inner.appendChild(content);
    } else if (content instanceof Object) {
      templateFunction(data, this.dom.inner);
    } else if (content !== undefined && content !== null) {
      this.dom.inner.innerHTML = content;
    } else {
      this.dom.inner.innerHTML = this.groupId || ''; // groupId can be null
    }

    // update title
    this.dom.label.title = data && data.title || '';

    if (!this.dom.inner.firstChild) {
      util.addClassName(this.dom.inner, 'vis-hidden');
    } else {
      util.removeClassName(this.dom.inner, 'vis-hidden');
    }

    // update className
    var className = data && data.className || null;
    if (className != this.className) {
      if (this.className) {
        util.removeClassName(this.dom.label, this.className);
        util.removeClassName(this.dom.foreground, this.className);
        util.removeClassName(this.dom.background, this.className);
        util.removeClassName(this.dom.axis, this.className);
      }
      util.addClassName(this.dom.label, className);
      util.addClassName(this.dom.foreground, className);
      util.addClassName(this.dom.background, className);
      util.addClassName(this.dom.axis, className);
      this.className = className;
    }

    // update style
    if (this.style) {
      util.removeCssText(this.dom.label, this.style);
      this.style = null;
    }
    if (data && data.style) {
      util.addCssText(this.dom.label, data.style);
      this.style = data.style;
    }
  };

  /**
   * Get the width of the group label
   * @return {number} width
   */
  Group.prototype.getLabelWidth = function () {
    return this.props.label.width;
  };

  /**
   * Repaint this group
   * @param {{start: number, end: number}} range
   * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
   * @param {boolean} [restack=false]  Force restacking of all items
   * @return {boolean} Returns true if the group is resized
   */
  Group.prototype.redraw = function (range, margin, restack) {
    var resized = false;

    // force recalculation of the height of the items when the marker height changed
    // (due to the Timeline being attached to the DOM or changed from display:none to visible)
    var markerHeight = this.dom.marker.clientHeight;
    if (markerHeight != this.lastMarkerHeight) {
      this.lastMarkerHeight = markerHeight;

      util.forEach(this.items, function (item) {
        item.dirty = true;
        if (item.displayed) item.redraw();
      });

      restack = true;
    }

    // recalculate the height of the subgroups
    this._calculateSubGroupHeights();

    this.isVisible = this._isGroupVisible(range, margin);

    // calculate actual size and position
    var foreground = this.dom.foreground;
    this.top = foreground.offsetTop;
    this.right = foreground.offsetLeft;
    this.width = foreground.offsetWidth;

    this.isVisible = this._isGroupVisible(range, margin);
    // reposition visible items vertically
    if (typeof this.itemSet.options.order === 'function') {
      // a custom order function

      if (restack) {
        // brute force restack of all items

        // show all items
        var me = this;
        var limitSize = false;
        util.forEach(this.items, function (item) {
          if (!item.displayed) {
            item.redraw();
            me.visibleItems.push(item);
          }
          item.repositionX(limitSize);
        });

        // order all items and force a restacking
        var customOrderedItems = this.orderedItems.byStart.slice().sort(function (a, b) {
          return me.itemSet.options.order(a.data, b.data);
        });
        stack.stack(customOrderedItems, margin, true /* restack=true */);
      }

      this.visibleItems = this._updateVisibleItems(this.orderedItems, this.visibleItems, range);
    } else {
      // no custom order function, lazy stacking

      this.visibleItems = this._updateVisibleItems(this.orderedItems, this.visibleItems, range);
      if (this.itemSet.options.stack) {
        // TODO: ugly way to access options...
        stack.stack(this.visibleItems, margin, restack);
      } else {
        // no stacking
        stack.nostack(this.visibleItems, margin, this.subgroups);
      }
    }

    if (!this.isVisible && this.height) {
      return resized = false;
    }

    // recalculate the height of the group
    var height = this._calculateHeight(margin);

    // calculate actual size and position
    var foreground = this.dom.foreground;
    this.top = foreground.offsetTop;
    this.right = foreground.offsetLeft;
    this.width = foreground.offsetWidth;
    resized = util.updateProperty(this, 'height', height) || resized;
    // recalculate size of label
    resized = util.updateProperty(this.props.label, 'width', this.dom.inner.clientWidth) || resized;
    resized = util.updateProperty(this.props.label, 'height', this.dom.inner.clientHeight) || resized;

    // apply new height
    this.dom.background.style.height = height + 'px';
    this.dom.foreground.style.height = height + 'px';
    this.dom.label.style.height = height + 'px';

    // update vertical position of items after they are re-stacked and the height of the group is calculated
    for (var i = 0, ii = this.visibleItems.length; i < ii; i++) {
      var item = this.visibleItems[i];
      item.repositionY(margin);
    }

    return resized;
  };

  /**
   * recalculate the height of the subgroups
   * @private
   */
  Group.prototype._calculateSubGroupHeights = function () {
    if (Object.keys(this.subgroups).length > 0) {
      var me = this;

      this.resetSubgroups();

      util.forEach(this.visibleItems, function (item) {
        if (item.data.subgroup !== undefined) {
          me.subgroups[item.data.subgroup].height = Math.max(me.subgroups[item.data.subgroup].height, item.height);
          me.subgroups[item.data.subgroup].visible = true;
        }
      });
    }
  };

  /**
   * check if group is visible
   * @private
    */
  Group.prototype._isGroupVisible = function (range, margin) {
    var isVisible = this.top <= range.body.domProps.centerContainer.height - range.body.domProps.scrollTop + margin.axis && this.top + this.height + margin.axis >= -range.body.domProps.scrollTop;
    return isVisible;
  };

  /**
   * recalculate the height of the group
   * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
   * @returns {number} Returns the height
   * @private
   */
  Group.prototype._calculateHeight = function (margin) {
    // recalculate the height of the group
    var height;
    var visibleItems = this.visibleItems;
    if (visibleItems.length > 0) {
      var min = visibleItems[0].top;
      var max = visibleItems[0].top + visibleItems[0].height;
      util.forEach(visibleItems, function (item) {
        min = Math.min(min, item.top);
        max = Math.max(max, item.top + item.height);
      });
      if (min > margin.axis) {
        // there is an empty gap between the lowest item and the axis
        var offset = min - margin.axis;
        max -= offset;
        util.forEach(visibleItems, function (item) {
          item.top -= offset;
        });
      }
      height = max + margin.item.vertical / 2;
    } else {
      height = 0;
    }
    height = Math.max(height, this.props.label.height);

    return height;
  };

  /**
   * Show this group: attach to the DOM
   */
  Group.prototype.show = function () {
    if (!this.dom.label.parentNode) {
      this.itemSet.dom.labelSet.appendChild(this.dom.label);
    }

    if (!this.dom.foreground.parentNode) {
      this.itemSet.dom.foreground.appendChild(this.dom.foreground);
    }

    if (!this.dom.background.parentNode) {
      this.itemSet.dom.background.appendChild(this.dom.background);
    }

    if (!this.dom.axis.parentNode) {
      this.itemSet.dom.axis.appendChild(this.dom.axis);
    }
  };

  /**
   * Hide this group: remove from the DOM
   */
  Group.prototype.hide = function () {
    var label = this.dom.label;
    if (label.parentNode) {
      label.parentNode.removeChild(label);
    }

    var foreground = this.dom.foreground;
    if (foreground.parentNode) {
      foreground.parentNode.removeChild(foreground);
    }

    var background = this.dom.background;
    if (background.parentNode) {
      background.parentNode.removeChild(background);
    }

    var axis = this.dom.axis;
    if (axis.parentNode) {
      axis.parentNode.removeChild(axis);
    }
  };

  /**
   * Add an item to the group
   * @param {Item} item
   */
  Group.prototype.add = function (item) {
    this.items[item.id] = item;
    item.setParent(this);

    // add to
    if (item.data.subgroup !== undefined) {
      if (this.subgroups[item.data.subgroup] === undefined) {
        this.subgroups[item.data.subgroup] = { height: 0, visible: false, index: this.subgroupIndex, items: [] };
        this.subgroupIndex++;
      }
      this.subgroups[item.data.subgroup].items.push(item);
    }
    this.orderSubgroups();

    if (this.visibleItems.indexOf(item) == -1) {
      var range = this.itemSet.body.range; // TODO: not nice accessing the range like this
      this._checkIfVisible(item, this.visibleItems, range);
    }
  };

  Group.prototype.orderSubgroups = function () {
    if (this.subgroupOrderer !== undefined) {
      var sortArray = [];
      if (typeof this.subgroupOrderer == 'string') {
        for (var subgroup in this.subgroups) {
          sortArray.push({ subgroup: subgroup, sortField: this.subgroups[subgroup].items[0].data[this.subgroupOrderer] });
        }
        sortArray.sort(function (a, b) {
          return a.sortField - b.sortField;
        });
      } else if (typeof this.subgroupOrderer == 'function') {
        for (var subgroup in this.subgroups) {
          sortArray.push(this.subgroups[subgroup].items[0].data);
        }
        sortArray.sort(this.subgroupOrderer);
      }

      if (sortArray.length > 0) {
        for (var i = 0; i < sortArray.length; i++) {
          this.subgroups[sortArray[i].subgroup].index = i;
        }
      }
    }
  };

  Group.prototype.resetSubgroups = function () {
    for (var subgroup in this.subgroups) {
      if (this.subgroups.hasOwnProperty(subgroup)) {
        this.subgroups[subgroup].visible = false;
      }
    }
  };

  /**
   * Remove an item from the group
   * @param {Item} item
   */
  Group.prototype.remove = function (item) {
    delete this.items[item.id];
    item.setParent(null);

    // remove from visible items
    var index = this.visibleItems.indexOf(item);
    if (index != -1) this.visibleItems.splice(index, 1);

    if (item.data.subgroup !== undefined) {
      var subgroup = this.subgroups[item.data.subgroup];
      if (subgroup) {
        var itemIndex = subgroup.items.indexOf(item);
        subgroup.items.splice(itemIndex, 1);
        if (!subgroup.items.length) {
          delete this.subgroups[item.data.subgroup];
          this.subgroupIndex--;
        }
        this.orderSubgroups();
      }
    }
  };

  /**
   * Remove an item from the corresponding DataSet
   * @param {Item} item
   */
  Group.prototype.removeFromDataSet = function (item) {
    this.itemSet.removeItem(item.id);
  };

  /**
   * Reorder the items
   */
  Group.prototype.order = function () {
    var array = util.toArray(this.items);
    var startArray = [];
    var endArray = [];

    for (var i = 0; i < array.length; i++) {
      if (array[i].data.end !== undefined) {
        endArray.push(array[i]);
      }
      startArray.push(array[i]);
    }
    this.orderedItems = {
      byStart: startArray,
      byEnd: endArray
    };

    stack.orderByStart(this.orderedItems.byStart);
    stack.orderByEnd(this.orderedItems.byEnd);
  };

  /**
   * Update the visible items
   * @param {{byStart: Item[], byEnd: Item[]}} orderedItems   All items ordered by start date and by end date
   * @param {Item[]} visibleItems                             The previously visible items.
   * @param {{start: number, end: number}} range              Visible range
   * @return {Item[]} visibleItems                            The new visible items.
   * @private
   */
  Group.prototype._updateVisibleItems = function (orderedItems, oldVisibleItems, range) {
    var visibleItems = [];
    var visibleItemsLookup = {}; // we keep this to quickly look up if an item already exists in the list without using indexOf on visibleItems
    if (!this.isVisible && this.groupId != "__background__") {
      for (var i = 0; i < oldVisibleItems.length; i++) {
        var item = oldVisibleItems[i];
        if (item.displayed) item.hide();
      }
      return visibleItems;
    }

    var interval = (range.end - range.start) / 4;
    var lowerBound = range.start - interval;
    var upperBound = range.end + interval;

    // this function is used to do the binary search.
    var searchFunction = function searchFunction(value) {
      if (value < lowerBound) {
        return -1;
      } else if (value <= upperBound) {
        return 0;
      } else {
        return 1;
      }
    };

    // first check if the items that were in view previously are still in view.
    // IMPORTANT: this handles the case for the items with startdate before the window and enddate after the window!
    // also cleans up invisible items.
    if (oldVisibleItems.length > 0) {
      for (var i = 0; i < oldVisibleItems.length; i++) {
        this._checkIfVisibleWithReference(oldVisibleItems[i], visibleItems, visibleItemsLookup, range);
      }
    }

    // we do a binary search for the items that have only start values.
    var initialPosByStart = util.binarySearchCustom(orderedItems.byStart, searchFunction, 'data', 'start');

    // trace the visible items from the inital start pos both ways until an invisible item is found, we only look at the start values.
    this._traceVisible(initialPosByStart, orderedItems.byStart, visibleItems, visibleItemsLookup, function (item) {
      return item.data.start < lowerBound || item.data.start > upperBound;
    });

    // if the window has changed programmatically without overlapping the old window, the ranged items with start < lowerBound and end > upperbound are not shown.
    // We therefore have to brute force check all items in the byEnd list
    if (this.checkRangedItems == true) {
      this.checkRangedItems = false;
      for (i = 0; i < orderedItems.byEnd.length; i++) {
        this._checkIfVisibleWithReference(orderedItems.byEnd[i], visibleItems, visibleItemsLookup, range);
      }
    } else {
      // we do a binary search for the items that have defined end times.
      var initialPosByEnd = util.binarySearchCustom(orderedItems.byEnd, searchFunction, 'data', 'end');

      // trace the visible items from the inital start pos both ways until an invisible item is found, we only look at the end values.
      this._traceVisible(initialPosByEnd, orderedItems.byEnd, visibleItems, visibleItemsLookup, function (item) {
        return item.data.end < lowerBound || item.data.end > upperBound;
      });
    }

    // finally, we reposition all the visible items.
    for (var i = 0; i < visibleItems.length; i++) {
      var item = visibleItems[i];
      if (!item.displayed) item.show();
      // reposition item horizontally
      item.repositionX();
    }

    return visibleItems;
  };

  Group.prototype._traceVisible = function (initialPos, items, visibleItems, visibleItemsLookup, breakCondition) {
    if (initialPos != -1) {
      for (var i = initialPos; i >= 0; i--) {
        var item = items[i];
        if (breakCondition(item)) {
          break;
        } else {
          if (visibleItemsLookup[item.id] === undefined) {
            visibleItemsLookup[item.id] = true;
            visibleItems.push(item);
          }
        }
      }

      for (var i = initialPos + 1; i < items.length; i++) {
        var item = items[i];
        if (breakCondition(item)) {
          break;
        } else {
          if (visibleItemsLookup[item.id] === undefined) {
            visibleItemsLookup[item.id] = true;
            visibleItems.push(item);
          }
        }
      }
    }
  };

  /**
   * this function is very similar to the _checkIfInvisible() but it does not
   * return booleans, hides the item if it should not be seen and always adds to
   * the visibleItems.
   * this one is for brute forcing and hiding.
   *
   * @param {Item} item
   * @param {Array} visibleItems
   * @param {{start:number, end:number}} range
   * @private
   */
  Group.prototype._checkIfVisible = function (item, visibleItems, range) {
    if (item.isVisible(range)) {
      if (!item.displayed) item.show();
      // reposition item horizontally
      item.repositionX();
      visibleItems.push(item);
    } else {
      if (item.displayed) item.hide();
    }
  };

  /**
   * this function is very similar to the _checkIfInvisible() but it does not
   * return booleans, hides the item if it should not be seen and always adds to
   * the visibleItems.
   * this one is for brute forcing and hiding.
   *
   * @param {Item} item
   * @param {Array} visibleItems
   * @param {{start:number, end:number}} range
   * @private
   */
  Group.prototype._checkIfVisibleWithReference = function (item, visibleItems, visibleItemsLookup, range) {
    if (item.isVisible(range)) {
      if (visibleItemsLookup[item.id] === undefined) {
        visibleItemsLookup[item.id] = true;
        visibleItems.push(item);
      }
    } else {
      if (item.displayed) item.hide();
    }
  };

  module.exports = Group;

/***/ },
/* 39 */
/***/ function(module, exports) {

  'use strict';

  // Utility functions for ordering and stacking of items
  var EPSILON = 0.001; // used when checking collisions, to prevent round-off errors

  /**
   * Order items by their start data
   * @param {Item[]} items
   */
  exports.orderByStart = function (items) {
    items.sort(function (a, b) {
      return a.data.start - b.data.start;
    });
  };

  /**
   * Order items by their end date. If they have no end date, their start date
   * is used.
   * @param {Item[]} items
   */
  exports.orderByEnd = function (items) {
    items.sort(function (a, b) {
      var aTime = 'end' in a.data ? a.data.end : a.data.start,
          bTime = 'end' in b.data ? b.data.end : b.data.start;

      return aTime - bTime;
    });
  };

  /**
   * Adjust vertical positions of the items such that they don't overlap each
   * other.
   * @param {Item[]} items
   *            All visible items
   * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
   *            Margins between items and between items and the axis.
   * @param {boolean} [force=false]
   *            If true, all items will be repositioned. If false (default), only
   *            items having a top===null will be re-stacked
   */
  exports.stack = function (items, margin, force) {
    var i, iMax;
    if (force) {
      // reset top position of all items
      for (i = 0, iMax = items.length; i < iMax; i++) {
        items[i].top = null;
      }
    }

    // calculate new, non-overlapping positions
    for (i = 0, iMax = items.length; i < iMax; i++) {
      var item = items[i];
      if (item.stack && item.top === null) {
        // initialize top position
        item.top = margin.axis;

        do {
          // TODO: optimize checking for overlap. when there is a gap without items,
          //       you only need to check for items from the next item on, not from zero
          var collidingItem = null;
          for (var j = 0, jj = items.length; j < jj; j++) {
            var other = items[j];
            if (other.top !== null && other !== item && other.stack && exports.collision(item, other, margin.item, other.options.rtl)) {
              collidingItem = other;
              break;
            }
          }

          if (collidingItem != null) {
            // There is a collision. Reposition the items above the colliding element
            item.top = collidingItem.top + collidingItem.height + margin.item.vertical;
          }
        } while (collidingItem);
      }
    }
  };

  /**
   * Adjust vertical positions of the items without stacking them
   * @param {Item[]} items
   *            All visible items
   * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
   *            Margins between items and between items and the axis.
   */
  exports.nostack = function (items, margin, subgroups) {
    var i, iMax, newTop;

    // reset top position of all items
    for (i = 0, iMax = items.length; i < iMax; i++) {
      if (items[i].data.subgroup !== undefined) {
        newTop = margin.axis;
        for (var subgroup in subgroups) {
          if (subgroups.hasOwnProperty(subgroup)) {
            if (subgroups[subgroup].visible == true && subgroups[subgroup].index < subgroups[items[i].data.subgroup].index) {
              newTop += subgroups[subgroup].height + margin.item.vertical;
            }
          }
        }
        items[i].top = newTop;
      } else {
        items[i].top = margin.axis;
      }
    }
  };

  /**
   * Test if the two provided items collide
   * The items must have parameters left, width, top, and height.
   * @param {Item} a          The first item
   * @param {Item} b          The second item
   * @param {{horizontal: number, vertical: number}} margin
   *                          An object containing a horizontal and vertical
   *                          minimum required margin.
   * @param {boolean} rtl
   * @return {boolean}        true if a and b collide, else false
   */
  exports.collision = function (a, b, margin, rtl) {
    if (rtl) {
      return a.right - margin.horizontal + EPSILON < b.right + b.width && a.right + a.width + margin.horizontal - EPSILON > b.right && a.top - margin.vertical + EPSILON < b.top + b.height && a.top + a.height + margin.vertical - EPSILON > b.top;
    } else {
      return a.left - margin.horizontal + EPSILON < b.left + b.width && a.left + a.width + margin.horizontal - EPSILON > b.left && a.top - margin.vertical + EPSILON < b.top + b.height && a.top + a.height + margin.vertical - EPSILON > b.top;
    }
  };

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Hammer = __webpack_require__(22);
  var Item = __webpack_require__(41);

  /**
   * @constructor RangeItem
   * @extends Item
   * @param {Object} data             Object containing parameters start, end
   *                                  content, className.
   * @param {{toScreen: function, toTime: function}} conversion
   *                                  Conversion functions from time to screen and vice versa
   * @param {Object} [options]        Configuration options
   *                                  // TODO: describe options
   */
  function RangeItem(data, conversion, options) {
    this.props = {
      content: {
        width: 0
      }
    };
    this.overflow = false; // if contents can overflow (css styling), this flag is set to true
    this.options = options;
    // validate data
    if (data) {
      if (data.start == undefined) {
        throw new Error('Property "start" missing in item ' + data.id);
      }
      if (data.end == undefined) {
        throw new Error('Property "end" missing in item ' + data.id);
      }
    }

    Item.call(this, data, conversion, options);
  }

  RangeItem.prototype = new Item(null, null, null);

  RangeItem.prototype.baseClassName = 'vis-item vis-range';

  /**
   * Check whether this item is visible inside given range
   * @returns {{start: Number, end: Number}} range with a timestamp for start and end
   * @returns {boolean} True if visible
   */
  RangeItem.prototype.isVisible = function (range) {
    // determine visibility
    return this.data.start < range.end && this.data.end > range.start;
  };

  /**
   * Repaint the item
   */
  RangeItem.prototype.redraw = function () {
    var dom = this.dom;
    if (!dom) {
      // create DOM
      this.dom = {};
      dom = this.dom;

      // background box
      dom.box = document.createElement('div');
      // className is updated in redraw()

      // frame box (to prevent the item contents from overflowing
      dom.frame = document.createElement('div');
      dom.frame.className = 'vis-item-overflow';
      dom.box.appendChild(dom.frame);

      // contents box
      dom.content = document.createElement('div');
      dom.content.className = 'vis-item-content';
      dom.frame.appendChild(dom.content);

      // attach this item as attribute
      dom.box['timeline-item'] = this;

      this.dirty = true;
    }

    // append DOM to parent DOM
    if (!this.parent) {
      throw new Error('Cannot redraw item: no parent attached');
    }
    if (!dom.box.parentNode) {
      var foreground = this.parent.dom.foreground;
      if (!foreground) {
        throw new Error('Cannot redraw item: parent has no foreground container element');
      }
      foreground.appendChild(dom.box);
    }
    this.displayed = true;

    // Update DOM when item is marked dirty. An item is marked dirty when:
    // - the item is not yet rendered
    // - the item's data is changed
    // - the item is selected/deselected
    if (this.dirty) {
      this._updateContents(this.dom.content);
      this._updateTitle(this.dom.box);
      this._updateDataAttributes(this.dom.box);
      this._updateStyle(this.dom.box);

      var editable = (this.options.editable.updateTime || this.options.editable.updateGroup || this.editable === true) && this.editable !== false;

      // update class
      var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + (editable ? ' vis-editable' : ' vis-readonly');
      dom.box.className = this.baseClassName + className;

      // determine from css whether this box has overflow
      this.overflow = window.getComputedStyle(dom.frame).overflow !== 'hidden';

      // recalculate size
      // turn off max-width to be able to calculate the real width
      // this causes an extra browser repaint/reflow, but so be it
      this.dom.content.style.maxWidth = 'none';
      this.props.content.width = this.dom.content.offsetWidth;
      this.height = this.dom.box.offsetHeight;
      this.dom.content.style.maxWidth = '';

      this.dirty = false;
    }

    this._repaintOnItemUpdateTimeTooltip(dom.box);
    this._repaintDeleteButton(dom.box);
    this._repaintDragCenter();
    this._repaintDragLeft();
    this._repaintDragRight();
  };

  /**
   * Show the item in the DOM (when not already visible). The items DOM will
   * be created when needed.
   */
  RangeItem.prototype.show = function () {
    if (!this.displayed) {
      this.redraw();
    }
  };

  /**
   * Hide the item from the DOM (when visible)
   * @return {Boolean} changed
   */
  RangeItem.prototype.hide = function () {
    if (this.displayed) {
      var box = this.dom.box;

      if (box.parentNode) {
        box.parentNode.removeChild(box);
      }

      this.displayed = false;
    }
  };

  /**
   * Reposition the item horizontally
   * @param {boolean} [limitSize=true] If true (default), the width of the range
   *                                   item will be limited, as the browser cannot
   *                                   display very wide divs. This means though
   *                                   that the applied left and width may
   *                                   not correspond to the ranges start and end
   * @Override
   */
  RangeItem.prototype.repositionX = function (limitSize) {
    var parentWidth = this.parent.width;
    var start = this.conversion.toScreen(this.data.start);
    var end = this.conversion.toScreen(this.data.end);
    var contentStartPosition;
    var contentWidth;

    // limit the width of the range, as browsers cannot draw very wide divs
    if (limitSize === undefined || limitSize === true) {
      if (start < -parentWidth) {
        start = -parentWidth;
      }
      if (end > 2 * parentWidth) {
        end = 2 * parentWidth;
      }
    }

    // add 0.5 to compensate floating-point values rounding
    var boxWidth = Math.max(end - start + 0.5, 1);

    if (this.overflow) {
      if (this.options.rtl) {
        this.right = start;
      } else {
        this.left = start;
      }
      this.width = boxWidth + this.props.content.width;
      contentWidth = this.props.content.width;

      // Note: The calculation of width is an optimistic calculation, giving
      //       a width which will not change when moving the Timeline
      //       So no re-stacking needed, which is nicer for the eye;
    } else {
      if (this.options.rtl) {
        this.right = start;
      } else {
        this.left = start;
      }
      this.width = boxWidth;
      contentWidth = Math.min(end - start, this.props.content.width);
    }

    if (this.options.rtl) {
      this.dom.box.style.right = this.right + 'px';
    } else {
      this.dom.box.style.left = this.left + 'px';
    }
    this.dom.box.style.width = boxWidth + 'px';

    switch (this.options.align) {
      case 'left':
        if (this.options.rtl) {
          this.dom.content.style.right = '0';
        } else {
          this.dom.content.style.left = '0';
        }
        break;

      case 'right':
        if (this.options.rtl) {
          this.dom.content.style.right = Math.max(boxWidth - contentWidth, 0) + 'px';
        } else {
          this.dom.content.style.left = Math.max(boxWidth - contentWidth, 0) + 'px';
        }
        break;

      case 'center':
        if (this.options.rtl) {
          this.dom.content.style.right = Math.max((boxWidth - contentWidth) / 2, 0) + 'px';
        } else {
          this.dom.content.style.left = Math.max((boxWidth - contentWidth) / 2, 0) + 'px';
        }

        break;

      default:
        // 'auto'
        // when range exceeds left of the window, position the contents at the left of the visible area
        if (this.overflow) {
          if (end > 0) {
            contentStartPosition = Math.max(-start, 0);
          } else {
            contentStartPosition = -contentWidth; // ensure it's not visible anymore
          }
        } else {
          if (start < 0) {
            contentStartPosition = -start;
          } else {
            contentStartPosition = 0;
          }
        }
        if (this.options.rtl) {
          this.dom.content.style.right = contentStartPosition + 'px';
        } else {
          this.dom.content.style.left = contentStartPosition + 'px';
          this.dom.content.style.width = 'calc(100% - ' + contentStartPosition + 'px)';
        }
    }
  };

  /**
   * Reposition the item vertically
   * @Override
   */
  RangeItem.prototype.repositionY = function () {
    var orientation = this.options.orientation.item;
    var box = this.dom.box;

    if (orientation == 'top') {
      box.style.top = this.top + 'px';
    } else {
      box.style.top = this.parent.height - this.top - this.height + 'px';
    }
  };

  /**
   * Repaint a drag area on the left side of the range when the range is selected
   * @protected
   */
  RangeItem.prototype._repaintDragLeft = function () {
    if (this.selected && this.options.editable.updateTime && !this.dom.dragLeft) {
      // create and show drag area
      var dragLeft = document.createElement('div');
      dragLeft.className = 'vis-drag-left';
      dragLeft.dragLeftItem = this;

      this.dom.box.appendChild(dragLeft);
      this.dom.dragLeft = dragLeft;
    } else if (!this.selected && this.dom.dragLeft) {
      // delete drag area
      if (this.dom.dragLeft.parentNode) {
        this.dom.dragLeft.parentNode.removeChild(this.dom.dragLeft);
      }
      this.dom.dragLeft = null;
    }
  };

  /**
   * Repaint a drag area on the right side of the range when the range is selected
   * @protected
   */
  RangeItem.prototype._repaintDragRight = function () {
    if (this.selected && this.options.editable.updateTime && !this.dom.dragRight) {
      // create and show drag area
      var dragRight = document.createElement('div');
      dragRight.className = 'vis-drag-right';
      dragRight.dragRightItem = this;

      this.dom.box.appendChild(dragRight);
      this.dom.dragRight = dragRight;
    } else if (!this.selected && this.dom.dragRight) {
      // delete drag area
      if (this.dom.dragRight.parentNode) {
        this.dom.dragRight.parentNode.removeChild(this.dom.dragRight);
      }
      this.dom.dragRight = null;
    }
  };

  module.exports = RangeItem;

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Hammer = __webpack_require__(22);
  var util = __webpack_require__(1);
  var moment = __webpack_require__(2);

  /**
   * @constructor Item
   * @param {Object} data             Object containing (optional) parameters type,
   *                                  start, end, content, group, className.
   * @param {{toScreen: function, toTime: function}} conversion
   *                                  Conversion functions from time to screen and vice versa
   * @param {Object} options          Configuration options
   *                                  // TODO: describe available options
   */
  function Item(data, conversion, options) {
    this.id = null;
    this.parent = null;
    this.data = data;
    this.dom = null;
    this.conversion = conversion || {};
    this.options = options || {};
    this.selected = false;
    this.displayed = false;
    this.dirty = true;

    this.top = null;
    this.right = null;
    this.left = null;
    this.width = null;
    this.height = null;

    this.editable = null;
    if (this.data && this.data.hasOwnProperty('editable') && typeof this.data.editable === 'boolean') {
      this.editable = data.editable;
    }
  }

  Item.prototype.stack = true;

  /**
   * Select current item
   */
  Item.prototype.select = function () {
    this.selected = true;
    this.dirty = true;
    if (this.displayed) this.redraw();
  };

  /**
   * Unselect current item
   */
  Item.prototype.unselect = function () {
    this.selected = false;
    this.dirty = true;
    if (this.displayed) this.redraw();
  };

  /**
   * Set data for the item. Existing data will be updated. The id should not
   * be changed. When the item is displayed, it will be redrawn immediately.
   * @param {Object} data
   */
  Item.prototype.setData = function (data) {
    var groupChanged = data.group != undefined && this.data.group != data.group;
    if (groupChanged) {
      this.parent.itemSet._moveToGroup(this, data.group);
    }

    if (data.hasOwnProperty('editable') && typeof data.editable === 'boolean') {
      this.editable = data.editable;
    }

    this.data = data;
    this.dirty = true;
    if (this.displayed) this.redraw();
  };

  /**
   * Set a parent for the item
   * @param {ItemSet | Group} parent
   */
  Item.prototype.setParent = function (parent) {
    if (this.displayed) {
      this.hide();
      this.parent = parent;
      if (this.parent) {
        this.show();
      }
    } else {
      this.parent = parent;
    }
  };

  /**
   * Check whether this item is visible inside given range
   * @returns {{start: Number, end: Number}} range with a timestamp for start and end
   * @returns {boolean} True if visible
   */
  Item.prototype.isVisible = function (range) {
    return false;
  };

  /**
   * Show the Item in the DOM (when not already visible)
   * @return {Boolean} changed
   */
  Item.prototype.show = function () {
    return false;
  };

  /**
   * Hide the Item from the DOM (when visible)
   * @return {Boolean} changed
   */
  Item.prototype.hide = function () {
    return false;
  };

  /**
   * Repaint the item
   */
  Item.prototype.redraw = function () {
    // should be implemented by the item
  };

  /**
   * Reposition the Item horizontally
   */
  Item.prototype.repositionX = function () {
    // should be implemented by the item
  };

  /**
   * Reposition the Item vertically
   */
  Item.prototype.repositionY = function () {
    // should be implemented by the item
  };

  /**
   * Repaint a delete button on the top right of the item when the item is selected
   * @param {HTMLElement} anchor
   * @protected
   */
  Item.prototype._repaintDeleteButton = function (anchor) {
    var editable = (this.options.editable.remove || this.data.editable === true) && this.data.editable !== false;

    if (this.selected && editable && !this.dom.deleteButton) {
      // create and show button
      var me = this;

      var deleteButton = document.createElement('div');

      if (this.options.rtl) {
        deleteButton.className = 'vis-delete-rtl';
      } else {
        deleteButton.className = 'vis-delete';
      }
      deleteButton.title = 'Delete this item';

      // TODO: be able to destroy the delete button
      new Hammer(deleteButton).on('tap', function (event) {
        event.stopPropagation();
        me.parent.removeFromDataSet(me);
      });

      anchor.appendChild(deleteButton);
      this.dom.deleteButton = deleteButton;
    } else if (!this.selected && this.dom.deleteButton) {
      // remove button
      if (this.dom.deleteButton.parentNode) {
        this.dom.deleteButton.parentNode.removeChild(this.dom.deleteButton);
      }
      this.dom.deleteButton = null;
    }
  };

  /**
   * Repaint a onChange tooltip on the top right of the item when the item is selected
   * @param {HTMLElement} anchor
   * @protected
   */
  Item.prototype._repaintOnItemUpdateTimeTooltip = function (anchor) {
    if (!this.options.tooltipOnItemUpdateTime) return;

    var editable = (this.options.editable.updateTime || this.data.editable === true) && this.data.editable !== false;

    if (this.selected && editable && !this.dom.onItemUpdateTimeTooltip) {
      // create and show tooltip
      var me = this;

      var onItemUpdateTimeTooltip = document.createElement('div');

      onItemUpdateTimeTooltip.className = 'vis-onUpdateTime-tooltip';
      anchor.appendChild(onItemUpdateTimeTooltip);
      this.dom.onItemUpdateTimeTooltip = onItemUpdateTimeTooltip;
    } else if (!this.selected && this.dom.onItemUpdateTimeTooltip) {
      // remove button
      if (this.dom.onItemUpdateTimeTooltip.parentNode) {
        this.dom.onItemUpdateTimeTooltip.parentNode.removeChild(this.dom.onItemUpdateTimeTooltip);
      }
      this.dom.onItemUpdateTimeTooltip = null;
    }

    // position onChange tooltip
    if (this.dom.onItemUpdateTimeTooltip) {

      // only show when editing
      this.dom.onItemUpdateTimeTooltip.style.visibility = this.parent.itemSet.touchParams.itemIsDragging ? 'visible' : 'hidden';

      // position relative to item's content
      if (this.options.rtl) {
        this.dom.onItemUpdateTimeTooltip.style.right = this.dom.content.style.right;
      } else {
        this.dom.onItemUpdateTimeTooltip.style.left = this.dom.content.style.left;
      }

      // position above or below the item depending on the item's position in the window
      var tooltipOffset = 50; // TODO: should be tooltip height (depends on template)
      var scrollTop = this.parent.itemSet.body.domProps.scrollTop;

      // TODO: this.top for orientation:true is actually the items distance from the bottom... 
      // (should be this.bottom)
      var itemDistanceFromTop;
      if (this.options.orientation.item == 'top') {
        itemDistanceFromTop = this.top;
      } else {
        itemDistanceFromTop = this.parent.height - this.top - this.height;
      }
      var isCloseToTop = itemDistanceFromTop + this.parent.top - tooltipOffset < -scrollTop;

      if (isCloseToTop) {
        this.dom.onItemUpdateTimeTooltip.style.bottom = "";
        this.dom.onItemUpdateTimeTooltip.style.top = this.height + 2 + "px";
      } else {
        this.dom.onItemUpdateTimeTooltip.style.top = "";
        this.dom.onItemUpdateTimeTooltip.style.bottom = this.height + 2 + "px";
      }

      // handle tooltip content
      var content;
      var templateFunction;

      if (this.options.tooltipOnItemUpdateTime && this.options.tooltipOnItemUpdateTime.template) {
        templateFunction = this.options.tooltipOnItemUpdateTime.template.bind(this);
        content = templateFunction(this.data);
      } else {
        content = 'start: ' + moment(this.data.start).format('MM/DD/YYYY hh:mm');
        if (this.data.end) {
          content += '<br> end: ' + moment(this.data.end).format('MM/DD/YYYY hh:mm');
        }
      }
      this.dom.onItemUpdateTimeTooltip.innerHTML = content;
    }
  };

  /**
   * Set HTML contents for the item
   * @param {Element} element   HTML element to fill with the contents
   * @private
   */
  Item.prototype._updateContents = function (element) {
    var content;
    var templateFunction;

    if (this.options.template) {
      var itemData = this.parent.itemSet.itemsData.get(this.id); // get a clone of the data from the dataset
      templateFunction = this.options.template.bind(this);
      content = templateFunction(itemData, element);
    } else {
      content = this.data.content;
    }

    if (content instanceof Object && !(content instanceof Element)) {
      templateFunction(itemData, element);
    } else {
      var changed = this._contentToString(this.content) !== this._contentToString(content);
      if (changed) {
        // only replace the content when changed
        if (content instanceof Element) {
          element.innerHTML = '';
          element.appendChild(content);
        } else if (content != undefined) {
          element.innerHTML = content;
        } else {
          if (!(this.data.type == 'background' && this.data.content === undefined)) {
            throw new Error('Property "content" missing in item ' + this.id);
          }
        }

        this.content = content;
      }
    }
  };

  /**
   * Set HTML contents for the item
   * @param {Element} element   HTML element to fill with the contents
   * @private
   */
  Item.prototype._updateTitle = function (element) {
    if (this.data.title != null) {
      element.title = this.data.title || '';
    } else {
      element.removeAttribute('vis-title');
    }
  };

  /**
   * Process dataAttributes timeline option and set as data- attributes on dom.content
   * @param {Element} element   HTML element to which the attributes will be attached
   * @private
   */
  Item.prototype._updateDataAttributes = function (element) {
    if (this.options.dataAttributes && this.options.dataAttributes.length > 0) {
      var attributes = [];

      if (Array.isArray(this.options.dataAttributes)) {
        attributes = this.options.dataAttributes;
      } else if (this.options.dataAttributes == 'all') {
        attributes = Object.keys(this.data);
      } else {
        return;
      }

      for (var i = 0; i < attributes.length; i++) {
        var name = attributes[i];
        var value = this.data[name];

        if (value != null) {
          element.setAttribute('data-' + name, value);
        } else {
          element.removeAttribute('data-' + name);
        }
      }
    }
  };

  /**
   * Update custom styles of the element
   * @param element
   * @private
   */
  Item.prototype._updateStyle = function (element) {
    // remove old styles
    if (this.style) {
      util.removeCssText(element, this.style);
      this.style = null;
    }

    // append new styles
    if (this.data.style) {
      util.addCssText(element, this.data.style);
      this.style = this.data.style;
    }
  };

  /**
   * Stringify the items contents
   * @param {string | Element | undefined} content
   * @returns {string | undefined}
   * @private
   */
  Item.prototype._contentToString = function (content) {
    if (typeof content === 'string') return content;
    if (content && 'outerHTML' in content) return content.outerHTML;
    return content;
  };

  /**
   * Return the width of the item left from its start date
   * @return {number}
   */
  Item.prototype.getWidthLeft = function () {
    return 0;
  };

  /**
   * Return the width of the item right from the max of its start and end date
   * @return {number}
   */
  Item.prototype.getWidthRight = function () {
    return 0;
  };

  /**
   * Repaint a drag area on the center of the item when the item is selected
   * @protected
   */
  Item.prototype._repaintDragCenter = function () {
    if (this.selected && this.options.editable.updateTime && !this.dom.dragCenter) {
      // create and show drag area
      var dragCenter = document.createElement('div');
      dragCenter.className = 'vis-drag-center';
      dragCenter.dragCenterItem = this;

      if (this.dom.box) {
        this.dom.box.appendChild(dragCenter);
      } else if (this.dom.point) {
        this.dom.point.appendChild(dragCenter);
      }

      this.dom.dragCenter = dragCenter;
    } else if (!this.selected && this.dom.dragCenter) {
      // delete drag area
      if (this.dom.dragCenter.parentNode) {
        this.dom.dragCenter.parentNode.removeChild(this.dom.dragCenter);
      }
      this.dom.dragCenter = null;
    }
  };

  module.exports = Item;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);
  var Group = __webpack_require__(38);

  /**
   * @constructor BackgroundGroup
   * @param {Number | String} groupId
   * @param {Object} data
   * @param {ItemSet} itemSet
   */
  function BackgroundGroup(groupId, data, itemSet) {
    Group.call(this, groupId, data, itemSet);

    this.width = 0;
    this.height = 0;
    this.top = 0;
    this.left = 0;
  }

  BackgroundGroup.prototype = Object.create(Group.prototype);

  /**
   * Repaint this group
   * @param {{start: number, end: number}} range
   * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
   * @param {boolean} [restack=false]  Force restacking of all items
   * @return {boolean} Returns true if the group is resized
   */
  BackgroundGroup.prototype.redraw = function (range, margin, restack) {
    var resized = false;

    this.visibleItems = this._updateVisibleItems(this.orderedItems, this.visibleItems, range);

    // calculate actual size
    this.width = this.dom.background.offsetWidth;

    // apply new height (just always zero for BackgroundGroup
    this.dom.background.style.height = '0';

    // update vertical position of items after they are re-stacked and the height of the group is calculated
    for (var i = 0, ii = this.visibleItems.length; i < ii; i++) {
      var item = this.visibleItems[i];
      item.repositionY(margin);
    }

    return resized;
  };

  /**
   * Show this group: attach to the DOM
   */
  BackgroundGroup.prototype.show = function () {
    if (!this.dom.background.parentNode) {
      this.itemSet.dom.background.appendChild(this.dom.background);
    }
  };

  module.exports = BackgroundGroup;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Item = __webpack_require__(41);
  var util = __webpack_require__(1);

  /**
   * @constructor BoxItem
   * @extends Item
   * @param {Object} data             Object containing parameters start
   *                                  content, className.
   * @param {{toScreen: function, toTime: function}} conversion
   *                                  Conversion functions from time to screen and vice versa
   * @param {Object} [options]        Configuration options
   *                                  // TODO: describe available options
   */
  function BoxItem(data, conversion, options) {
    this.props = {
      dot: {
        width: 0,
        height: 0
      },
      line: {
        width: 0,
        height: 0
      }
    };
    this.options = options;
    // validate data
    if (data) {
      if (data.start == undefined) {
        throw new Error('Property "start" missing in item ' + data);
      }
    }

    Item.call(this, data, conversion, options);
  }

  BoxItem.prototype = new Item(null, null, null);

  /**
   * Check whether this item is visible inside given range
   * @returns {{start: Number, end: Number}} range with a timestamp for start and end
   * @returns {boolean} True if visible
   */
  BoxItem.prototype.isVisible = function (range) {
    // determine visibility
    var isVisible;
    var align = this.options.align;
    var msPerPixel = (range.end - range.start) / range.body.dom.center.clientWidth;
    var widthInMs = this.width * msPerPixel;

    if (align == 'right') {
      isVisible = this.data.start.getTime() > range.start && this.data.start.getTime() - widthInMs < range.end;
    } else if (align == 'left') {
      isVisible = this.data.start.getTime() + widthInMs > range.start && this.data.start.getTime() < range.end;
    } else {
      // default or 'center'
      isVisible = this.data.start.getTime() + widthInMs / 2 > range.start && this.data.start.getTime() - widthInMs / 2 < range.end;
    }
    return isVisible;
  };

  /**
   * Repaint the item
   */
  BoxItem.prototype.redraw = function () {
    var dom = this.dom;
    if (!dom) {
      // create DOM
      this.dom = {};
      dom = this.dom;

      // create main box
      dom.box = document.createElement('DIV');

      // contents box (inside the background box). used for making margins
      dom.content = document.createElement('DIV');
      dom.content.className = 'vis-item-content';
      dom.box.appendChild(dom.content);

      // line to axis
      dom.line = document.createElement('DIV');
      dom.line.className = 'vis-line';

      // dot on axis
      dom.dot = document.createElement('DIV');
      dom.dot.className = 'vis-dot';

      // attach this item as attribute
      dom.box['timeline-item'] = this;

      this.dirty = true;
    }

    // append DOM to parent DOM
    if (!this.parent) {
      throw new Error('Cannot redraw item: no parent attached');
    }
    if (!dom.box.parentNode) {
      var foreground = this.parent.dom.foreground;
      if (!foreground) throw new Error('Cannot redraw item: parent has no foreground container element');
      foreground.appendChild(dom.box);
    }
    if (!dom.line.parentNode) {
      var background = this.parent.dom.background;
      if (!background) throw new Error('Cannot redraw item: parent has no background container element');
      background.appendChild(dom.line);
    }
    if (!dom.dot.parentNode) {
      var axis = this.parent.dom.axis;
      if (!background) throw new Error('Cannot redraw item: parent has no axis container element');
      axis.appendChild(dom.dot);
    }
    this.displayed = true;

    // Update DOM when item is marked dirty. An item is marked dirty when:
    // - the item is not yet rendered
    // - the item's data is changed
    // - the item is selected/deselected
    if (this.dirty) {
      this._updateContents(this.dom.content);
      this._updateTitle(this.dom.box);
      this._updateDataAttributes(this.dom.box);
      this._updateStyle(this.dom.box);

      var editable = (this.options.editable.updateTime || this.options.editable.updateGroup || this.editable === true) && this.editable !== false;

      // update class
      var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + (editable ? ' vis-editable' : ' vis-readonly');
      dom.box.className = 'vis-item vis-box' + className;
      dom.line.className = 'vis-item vis-line' + className;
      dom.dot.className = 'vis-item vis-dot' + className;

      // set initial position in the visible range of the grid so that the
      // rendered box size can be determinated correctly, even the content
      // has a dynamic width (fixes #2032).
      var previousRight = dom.box.style.right;
      var previousLeft = dom.box.style.left;
      if (this.options.rtl) {
        dom.box.style.right = "0px";
      } else {
        dom.box.style.left = "0px";
      }

      // recalculate size
      this.props.dot.height = dom.dot.offsetHeight;
      this.props.dot.width = dom.dot.offsetWidth;
      this.props.line.width = dom.line.offsetWidth;
      this.width = dom.box.offsetWidth;
      this.height = dom.box.offsetHeight;

      // restore previous position
      if (this.options.rtl) {
        dom.box.style.right = previousRight;
      } else {
        dom.box.style.left = previousLeft;
      }

      this.dirty = false;
    }

    this._repaintOnItemUpdateTimeTooltip(dom.box);
    this._repaintDragCenter();
    this._repaintDeleteButton(dom.box);
  };

  /**
   * Show the item in the DOM (when not already displayed). The items DOM will
   * be created when needed.
   */
  BoxItem.prototype.show = function () {
    if (!this.displayed) {
      this.redraw();
    }
  };

  /**
   * Hide the item from the DOM (when visible)
   */
  BoxItem.prototype.hide = function () {
    if (this.displayed) {
      var dom = this.dom;

      if (dom.box.parentNode) dom.box.parentNode.removeChild(dom.box);
      if (dom.line.parentNode) dom.line.parentNode.removeChild(dom.line);
      if (dom.dot.parentNode) dom.dot.parentNode.removeChild(dom.dot);

      this.displayed = false;
    }
  };

  /**
   * Reposition the item horizontally
   * @Override
   */
  BoxItem.prototype.repositionX = function () {
    var start = this.conversion.toScreen(this.data.start);
    var align = this.options.align;

    // calculate left position of the box
    if (align == 'right') {
      if (this.options.rtl) {
        this.right = start - this.width;

        // reposition box, line, and dot
        this.dom.box.style.right = this.right + 'px';
        this.dom.line.style.right = start - this.props.line.width + 'px';
        this.dom.dot.style.right = start - this.props.line.width / 2 - this.props.dot.width / 2 + 'px';
      } else {
        this.left = start - this.width;

        // reposition box, line, and dot
        this.dom.box.style.left = this.left + 'px';
        this.dom.line.style.left = start - this.props.line.width + 'px';
        this.dom.dot.style.left = start - this.props.line.width / 2 - this.props.dot.width / 2 + 'px';
      }
    } else if (align == 'left') {
      if (this.options.rtl) {
        this.right = start;

        // reposition box, line, and dot
        this.dom.box.style.right = this.right + 'px';
        this.dom.line.style.right = start + 'px';
        this.dom.dot.style.right = start + this.props.line.width / 2 - this.props.dot.width / 2 + 'px';
      } else {
        this.left = start;

        // reposition box, line, and dot
        this.dom.box.style.left = this.left + 'px';
        this.dom.line.style.left = start + 'px';
        this.dom.dot.style.left = start + this.props.line.width / 2 - this.props.dot.width / 2 + 'px';
      }
    } else {
      // default or 'center'
      if (this.options.rtl) {
        this.right = start - this.width / 2;

        // reposition box, line, and dot
        this.dom.box.style.right = this.right + 'px';
        this.dom.line.style.right = start - this.props.line.width + 'px';
        this.dom.dot.style.right = start - this.props.dot.width / 2 + 'px';
      } else {
        this.left = start - this.width / 2;

        // reposition box, line, and dot
        this.dom.box.style.left = this.left + 'px';
        this.dom.line.style.left = start - this.props.line.width / 2 + 'px';
        this.dom.dot.style.left = start - this.props.dot.width / 2 + 'px';
      }
    }
  };

  /**
   * Reposition the item vertically
   * @Override
   */
  BoxItem.prototype.repositionY = function () {
    var orientation = this.options.orientation.item;
    var box = this.dom.box;
    var line = this.dom.line;
    var dot = this.dom.dot;

    if (orientation == 'top') {
      box.style.top = (this.top || 0) + 'px';

      line.style.top = '0';
      line.style.height = this.parent.top + this.top + 1 + 'px';
      line.style.bottom = '';
    } else {
      // orientation 'bottom'
      var itemSetHeight = this.parent.itemSet.props.height; // TODO: this is nasty
      var lineHeight = itemSetHeight - this.parent.top - this.parent.height + this.top;

      box.style.top = (this.parent.height - this.top - this.height || 0) + 'px';
      line.style.top = itemSetHeight - lineHeight + 'px';
      line.style.bottom = '0';
    }

    dot.style.top = -this.props.dot.height / 2 + 'px';
  };

  /**
   * Return the width of the item left from its start date
   * @return {number}
   */
  BoxItem.prototype.getWidthLeft = function () {
    return this.width / 2;
  };

  /**
   * Return the width of the item right from its start date
   * @return {number}
   */
  BoxItem.prototype.getWidthRight = function () {
    return this.width / 2;
  };

  module.exports = BoxItem;

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Item = __webpack_require__(41);

  /**
   * @constructor PointItem
   * @extends Item
   * @param {Object} data             Object containing parameters start
   *                                  content, className.
   * @param {{toScreen: function, toTime: function}} conversion
   *                                  Conversion functions from time to screen and vice versa
   * @param {Object} [options]        Configuration options
   *                                  // TODO: describe available options
   */
  function PointItem(data, conversion, options) {
    this.props = {
      dot: {
        top: 0,
        width: 0,
        height: 0
      },
      content: {
        height: 0,
        marginLeft: 0,
        marginRight: 0
      }
    };
    this.options = options;
    // validate data
    if (data) {
      if (data.start == undefined) {
        throw new Error('Property "start" missing in item ' + data);
      }
    }

    Item.call(this, data, conversion, options);
  }

  PointItem.prototype = new Item(null, null, null);

  /**
   * Check whether this item is visible inside given range
   * @returns {{start: Number, end: Number}} range with a timestamp for start and end
   * @returns {boolean} True if visible
   */
  PointItem.prototype.isVisible = function (range) {
    // determine visibility
    var msPerPixel = (range.end - range.start) / range.body.dom.center.clientWidth;
    var widthInMs = this.width * msPerPixel;

    return this.data.start.getTime() + widthInMs > range.start && this.data.start < range.end;
  };

  /**
   * Repaint the item
   */
  PointItem.prototype.redraw = function () {
    var dom = this.dom;
    if (!dom) {
      // create DOM
      this.dom = {};
      dom = this.dom;

      // background box
      dom.point = document.createElement('div');
      // className is updated in redraw()

      // contents box, right from the dot
      dom.content = document.createElement('div');
      dom.content.className = 'vis-item-content';
      dom.point.appendChild(dom.content);

      // dot at start
      dom.dot = document.createElement('div');
      dom.point.appendChild(dom.dot);

      // attach this item as attribute
      dom.point['timeline-item'] = this;

      this.dirty = true;
    }

    // append DOM to parent DOM
    if (!this.parent) {
      throw new Error('Cannot redraw item: no parent attached');
    }
    if (!dom.point.parentNode) {
      var foreground = this.parent.dom.foreground;
      if (!foreground) {
        throw new Error('Cannot redraw item: parent has no foreground container element');
      }
      foreground.appendChild(dom.point);
    }
    this.displayed = true;

    // Update DOM when item is marked dirty. An item is marked dirty when:
    // - the item is not yet rendered
    // - the item's data is changed
    // - the item is selected/deselected
    if (this.dirty) {
      this._updateContents(this.dom.content);
      this._updateTitle(this.dom.point);
      this._updateDataAttributes(this.dom.point);
      this._updateStyle(this.dom.point);

      var editable = (this.options.editable.updateTime || this.options.editable.updateGroup || this.editable === true) && this.editable !== false;

      // update class
      var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + (editable ? ' vis-editable' : ' vis-readonly');
      dom.point.className = 'vis-item vis-point' + className;
      dom.dot.className = 'vis-item vis-dot' + className;

      // recalculate size of dot and contents
      this.props.dot.width = dom.dot.offsetWidth;
      this.props.dot.height = dom.dot.offsetHeight;
      this.props.content.height = dom.content.offsetHeight;

      // resize contents
      if (this.options.rtl) {
        dom.content.style.marginRight = 2 * this.props.dot.width + 'px';
      } else {
        dom.content.style.marginLeft = 2 * this.props.dot.width + 'px';
      }
      //dom.content.style.marginRight = ... + 'px'; // TODO: margin right

      // recalculate size
      this.width = dom.point.offsetWidth;
      this.height = dom.point.offsetHeight;

      // reposition the dot
      dom.dot.style.top = (this.height - this.props.dot.height) / 2 + 'px';
      if (this.options.rtl) {
        dom.dot.style.right = this.props.dot.width / 2 + 'px';
      } else {
        dom.dot.style.left = this.props.dot.width / 2 + 'px';
      }

      this.dirty = false;
    }

    this._repaintOnItemUpdateTimeTooltip(dom.point);
    this._repaintDragCenter();
    this._repaintDeleteButton(dom.point);
  };

  /**
   * Show the item in the DOM (when not already visible). The items DOM will
   * be created when needed.
   */
  PointItem.prototype.show = function () {
    if (!this.displayed) {
      this.redraw();
    }
  };

  /**
   * Hide the item from the DOM (when visible)
   */
  PointItem.prototype.hide = function () {
    if (this.displayed) {
      if (this.dom.point.parentNode) {
        this.dom.point.parentNode.removeChild(this.dom.point);
      }

      this.displayed = false;
    }
  };

  /**
   * Reposition the item horizontally
   * @Override
   */
  PointItem.prototype.repositionX = function () {
    var start = this.conversion.toScreen(this.data.start);

    if (this.options.rtl) {
      this.right = start - this.props.dot.width;

      // reposition point
      this.dom.point.style.right = this.right + 'px';
    } else {
      this.left = start - this.props.dot.width;

      // reposition point
      this.dom.point.style.left = this.left + 'px';
    }
  };

  /**
   * Reposition the item vertically
   * @Override
   */
  PointItem.prototype.repositionY = function () {
    var orientation = this.options.orientation.item;
    var point = this.dom.point;
    if (orientation == 'top') {
      point.style.top = this.top + 'px';
    } else {
      point.style.top = this.parent.height - this.top - this.height + 'px';
    }
  };

  /**
   * Return the width of the item left from its start date
   * @return {number}
   */
  PointItem.prototype.getWidthLeft = function () {
    return this.props.dot.width;
  };

  /**
   * Return the width of the item right from  its start date
   * @return {number}
   */
  PointItem.prototype.getWidthRight = function () {
    return this.props.dot.width;
  };

  module.exports = PointItem;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Hammer = __webpack_require__(22);
  var Item = __webpack_require__(41);
  var BackgroundGroup = __webpack_require__(42);
  var RangeItem = __webpack_require__(40);

  /**
   * @constructor BackgroundItem
   * @extends Item
   * @param {Object} data             Object containing parameters start, end
   *                                  content, className.
   * @param {{toScreen: function, toTime: function}} conversion
   *                                  Conversion functions from time to screen and vice versa
   * @param {Object} [options]        Configuration options
   *                                  // TODO: describe options
   */
  // TODO: implement support for the BackgroundItem just having a start, then being displayed as a sort of an annotation
  function BackgroundItem(data, conversion, options) {
    this.props = {
      content: {
        width: 0
      }
    };
    this.overflow = false; // if contents can overflow (css styling), this flag is set to true

    // validate data
    if (data) {
      if (data.start == undefined) {
        throw new Error('Property "start" missing in item ' + data.id);
      }
      if (data.end == undefined) {
        throw new Error('Property "end" missing in item ' + data.id);
      }
    }

    Item.call(this, data, conversion, options);
  }

  BackgroundItem.prototype = new Item(null, null, null);

  BackgroundItem.prototype.baseClassName = 'vis-item vis-background';
  BackgroundItem.prototype.stack = false;

  /**
   * Check whether this item is visible inside given range
   * @returns {{start: Number, end: Number}} range with a timestamp for start and end
   * @returns {boolean} True if visible
   */
  BackgroundItem.prototype.isVisible = function (range) {
    // determine visibility
    return this.data.start < range.end && this.data.end > range.start;
  };

  /**
   * Repaint the item
   */
  BackgroundItem.prototype.redraw = function () {
    var dom = this.dom;
    if (!dom) {
      // create DOM
      this.dom = {};
      dom = this.dom;

      // background box
      dom.box = document.createElement('div');
      // className is updated in redraw()

      // frame box (to prevent the item contents from overflowing
      dom.frame = document.createElement('div');
      dom.frame.className = 'vis-item-overflow';
      dom.box.appendChild(dom.frame);

      // contents box
      dom.content = document.createElement('div');
      dom.content.className = 'vis-item-content';
      dom.frame.appendChild(dom.content);

      // Note: we do NOT attach this item as attribute to the DOM,
      //       such that background items cannot be selected
      //dom.box['timeline-item'] = this;

      this.dirty = true;
    }

    // append DOM to parent DOM
    if (!this.parent) {
      throw new Error('Cannot redraw item: no parent attached');
    }
    if (!dom.box.parentNode) {
      var background = this.parent.dom.background;
      if (!background) {
        throw new Error('Cannot redraw item: parent has no background container element');
      }
      background.appendChild(dom.box);
    }
    this.displayed = true;

    // Update DOM when item is marked dirty. An item is marked dirty when:
    // - the item is not yet rendered
    // - the item's data is changed
    // - the item is selected/deselected
    if (this.dirty) {
      this._updateContents(this.dom.content);
      this._updateTitle(this.dom.content);
      this._updateDataAttributes(this.dom.content);
      this._updateStyle(this.dom.box);

      // update class
      var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '');
      dom.box.className = this.baseClassName + className;

      // determine from css whether this box has overflow
      this.overflow = window.getComputedStyle(dom.content).overflow !== 'hidden';

      // recalculate size
      this.props.content.width = this.dom.content.offsetWidth;
      this.height = 0; // set height zero, so this item will be ignored when stacking items

      this.dirty = false;
    }
  };

  /**
   * Show the item in the DOM (when not already visible). The items DOM will
   * be created when needed.
   */
  BackgroundItem.prototype.show = RangeItem.prototype.show;

  /**
   * Hide the item from the DOM (when visible)
   * @return {Boolean} changed
   */
  BackgroundItem.prototype.hide = RangeItem.prototype.hide;

  /**
   * Reposition the item horizontally
   * @Override
   */
  BackgroundItem.prototype.repositionX = RangeItem.prototype.repositionX;

  /**
   * Reposition the item vertically
   * @Override
   */
  BackgroundItem.prototype.repositionY = function (margin) {
    var onTop = this.options.orientation.item === 'top';
    this.dom.content.style.top = onTop ? '' : '0';
    this.dom.content.style.bottom = onTop ? '0' : '';
    var height;

    // special positioning for subgroups
    if (this.data.subgroup !== undefined) {
      // TODO: instead of calculating the top position of the subgroups here for every BackgroundItem, calculate the top of the subgroup once in Itemset

      var itemSubgroup = this.data.subgroup;
      var subgroups = this.parent.subgroups;
      var subgroupIndex = subgroups[itemSubgroup].index;
      // if the orientation is top, we need to take the difference in height into account.
      if (onTop == true) {
        // the first subgroup will have to account for the distance from the top to the first item.
        height = this.parent.subgroups[itemSubgroup].height + margin.item.vertical;
        height += subgroupIndex == 0 ? margin.axis - 0.5 * margin.item.vertical : 0;
        var newTop = this.parent.top;
        for (var subgroup in subgroups) {
          if (subgroups.hasOwnProperty(subgroup)) {
            if (subgroups[subgroup].visible == true && subgroups[subgroup].index < subgroupIndex) {
              newTop += subgroups[subgroup].height + margin.item.vertical;
            }
          }
        }

        // the others will have to be offset downwards with this same distance.
        newTop += subgroupIndex != 0 ? margin.axis - 0.5 * margin.item.vertical : 0;
        this.dom.box.style.top = newTop + 'px';
        this.dom.box.style.bottom = '';
      }
      // and when the orientation is bottom:
      else {
          var newTop = this.parent.top;
          var totalHeight = 0;
          for (var subgroup in subgroups) {
            if (subgroups.hasOwnProperty(subgroup)) {
              if (subgroups[subgroup].visible == true) {
                var newHeight = subgroups[subgroup].height + margin.item.vertical;
                totalHeight += newHeight;
                if (subgroups[subgroup].index > subgroupIndex) {
                  newTop += newHeight;
                }
              }
            }
          }
          height = this.parent.subgroups[itemSubgroup].height + margin.item.vertical;
          this.dom.box.style.top = this.parent.height - totalHeight + newTop + 'px';
          this.dom.box.style.bottom = '';
        }
    }
    // and in the case of no subgroups:
    else {
        // we want backgrounds with groups to only show in groups.
        if (this.parent instanceof BackgroundGroup) {
          // if the item is not in a group:
          height = Math.max(this.parent.height, this.parent.itemSet.body.domProps.center.height, this.parent.itemSet.body.domProps.centerContainer.height);
          this.dom.box.style.top = onTop ? '0' : '';
          this.dom.box.style.bottom = onTop ? '' : '0';
        } else {
          height = this.parent.height;
          // same alignment for items when orientation is top or bottom
          this.dom.box.style.top = this.parent.top + 'px';
          this.dom.box.style.bottom = '';
        }
      }
    this.dom.box.style.height = height + 'px';
  };

  module.exports = BackgroundItem;

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var util = __webpack_require__(1);
  var Component = __webpack_require__(33);
  var TimeStep = __webpack_require__(37);
  var DateUtil = __webpack_require__(34);
  var moment = __webpack_require__(2);

  /**
   * A horizontal time axis
   * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} body
   * @param {Object} [options]        See TimeAxis.setOptions for the available
   *                                  options.
   * @constructor TimeAxis
   * @extends Component
   */
  function TimeAxis(body, options) {
    this.dom = {
      foreground: null,
      lines: [],
      majorTexts: [],
      minorTexts: [],
      redundant: {
        lines: [],
        majorTexts: [],
        minorTexts: []
      }
    };
    this.props = {
      range: {
        start: 0,
        end: 0,
        minimumStep: 0
      },
      lineTop: 0
    };

    this.defaultOptions = {
      orientation: {
        axis: 'bottom'
      }, // axis orientation: 'top' or 'bottom'
      showMinorLabels: true,
      showMajorLabels: true,
      maxMinorChars: 7,
      format: TimeStep.FORMAT,
      moment: moment,
      timeAxis: null
    };
    this.options = util.extend({}, this.defaultOptions);

    this.body = body;

    // create the HTML DOM
    this._create();

    this.setOptions(options);
  }

  TimeAxis.prototype = new Component();

  /**
   * Set options for the TimeAxis.
   * Parameters will be merged in current options.
   * @param {Object} options  Available options:
   *                          {string} [orientation.axis]
   *                          {boolean} [showMinorLabels]
   *                          {boolean} [showMajorLabels]
   */
  TimeAxis.prototype.setOptions = function (options) {
    if (options) {
      // copy all options that we know
      util.selectiveExtend(['showMinorLabels', 'showMajorLabels', 'maxMinorChars', 'hiddenDates', 'timeAxis', 'moment', 'rtl'], this.options, options);

      // deep copy the format options
      util.selectiveDeepExtend(['format'], this.options, options);

      if ('orientation' in options) {
        if (typeof options.orientation === 'string') {
          this.options.orientation.axis = options.orientation;
        } else if (_typeof(options.orientation) === 'object' && 'axis' in options.orientation) {
          this.options.orientation.axis = options.orientation.axis;
        }
      }

      // apply locale to moment.js
      // TODO: not so nice, this is applied globally to moment.js
      if ('locale' in options) {
        if (typeof moment.locale === 'function') {
          // moment.js 2.8.1+
          moment.locale(options.locale);
        } else {
          moment.lang(options.locale);
        }
      }
    }
  };

  /**
   * Create the HTML DOM for the TimeAxis
   */
  TimeAxis.prototype._create = function () {
    this.dom.foreground = document.createElement('div');
    this.dom.background = document.createElement('div');

    this.dom.foreground.className = 'vis-time-axis vis-foreground';
    this.dom.background.className = 'vis-time-axis vis-background';
  };

  /**
   * Destroy the TimeAxis
   */
  TimeAxis.prototype.destroy = function () {
    // remove from DOM
    if (this.dom.foreground.parentNode) {
      this.dom.foreground.parentNode.removeChild(this.dom.foreground);
    }
    if (this.dom.background.parentNode) {
      this.dom.background.parentNode.removeChild(this.dom.background);
    }

    this.body = null;
  };

  /**
   * Repaint the component
   * @return {boolean} Returns true if the component is resized
   */
  TimeAxis.prototype.redraw = function () {
    var props = this.props;
    var foreground = this.dom.foreground;
    var background = this.dom.background;

    // determine the correct parent DOM element (depending on option orientation)
    var parent = this.options.orientation.axis == 'top' ? this.body.dom.top : this.body.dom.bottom;
    var parentChanged = foreground.parentNode !== parent;

    // calculate character width and height
    this._calculateCharSize();

    // TODO: recalculate sizes only needed when parent is resized or options is changed
    var showMinorLabels = this.options.showMinorLabels && this.options.orientation.axis !== 'none';
    var showMajorLabels = this.options.showMajorLabels && this.options.orientation.axis !== 'none';

    // determine the width and height of the elemens for the axis
    props.minorLabelHeight = showMinorLabels ? props.minorCharHeight : 0;
    props.majorLabelHeight = showMajorLabels ? props.majorCharHeight : 0;
    props.height = props.minorLabelHeight + props.majorLabelHeight;
    props.width = foreground.offsetWidth;

    props.minorLineHeight = this.body.domProps.root.height - props.majorLabelHeight - (this.options.orientation.axis == 'top' ? this.body.domProps.bottom.height : this.body.domProps.top.height);
    props.minorLineWidth = 1; // TODO: really calculate width
    props.majorLineHeight = props.minorLineHeight + props.majorLabelHeight;
    props.majorLineWidth = 1; // TODO: really calculate width

    //  take foreground and background offline while updating (is almost twice as fast)
    var foregroundNextSibling = foreground.nextSibling;
    var backgroundNextSibling = background.nextSibling;
    foreground.parentNode && foreground.parentNode.removeChild(foreground);
    background.parentNode && background.parentNode.removeChild(background);

    foreground.style.height = this.props.height + 'px';

    this._repaintLabels();

    // put DOM online again (at the same place)
    if (foregroundNextSibling) {
      parent.insertBefore(foreground, foregroundNextSibling);
    } else {
      parent.appendChild(foreground);
    }
    if (backgroundNextSibling) {
      this.body.dom.backgroundVertical.insertBefore(background, backgroundNextSibling);
    } else {
      this.body.dom.backgroundVertical.appendChild(background);
    }
    return this._isResized() || parentChanged;
  };

  /**
   * Repaint major and minor text labels and vertical grid lines
   * @private
   */
  TimeAxis.prototype._repaintLabels = function () {
    var orientation = this.options.orientation.axis;

    // calculate range and step (step such that we have space for 7 characters per label)
    var start = util.convert(this.body.range.start, 'Number');
    var end = util.convert(this.body.range.end, 'Number');
    var timeLabelsize = this.body.util.toTime((this.props.minorCharWidth || 10) * this.options.maxMinorChars).valueOf();
    var minimumStep = timeLabelsize - DateUtil.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this.body.range, timeLabelsize);
    minimumStep -= this.body.util.toTime(0).valueOf();

    var step = new TimeStep(new Date(start), new Date(end), minimumStep, this.body.hiddenDates);
    step.setMoment(this.options.moment);
    if (this.options.format) {
      step.setFormat(this.options.format);
    }
    if (this.options.timeAxis) {
      step.setScale(this.options.timeAxis);
    }
    this.step = step;

    // Move all DOM elements to a "redundant" list, where they
    // can be picked for re-use, and clear the lists with lines and texts.
    // At the end of the function _repaintLabels, left over elements will be cleaned up
    var dom = this.dom;
    dom.redundant.lines = dom.lines;
    dom.redundant.majorTexts = dom.majorTexts;
    dom.redundant.minorTexts = dom.minorTexts;
    dom.lines = [];
    dom.majorTexts = [];
    dom.minorTexts = [];

    var current;
    var next;
    var x;
    var xNext;
    var isMajor, nextIsMajor;
    var width = 0,
        prevWidth;
    var line;
    var labelMinor;
    var xFirstMajorLabel = undefined;
    var count = 0;
    var MAX = 1000;
    var className;

    step.start();
    next = step.getCurrent();
    xNext = this.body.util.toScreen(next);
    while (step.hasNext() && count < MAX) {
      count++;

      isMajor = step.isMajor();
      className = step.getClassName();
      labelMinor = step.getLabelMinor();

      current = next;
      x = xNext;

      step.next();
      next = step.getCurrent();
      nextIsMajor = step.isMajor();
      xNext = this.body.util.toScreen(next);

      prevWidth = width;
      width = xNext - x;
      var showMinorGrid = width >= prevWidth * 0.4; // prevent displaying of the 31th of the month on a scale of 5 days

      if (this.options.showMinorLabels && showMinorGrid) {
        var label = this._repaintMinorText(x, labelMinor, orientation, className);
        label.style.width = width + 'px'; // set width to prevent overflow
      }

      if (isMajor && this.options.showMajorLabels) {
        if (x > 0) {
          if (xFirstMajorLabel == undefined) {
            xFirstMajorLabel = x;
          }
          label = this._repaintMajorText(x, step.getLabelMajor(), orientation, className);
        }
        line = this._repaintMajorLine(x, width, orientation, className);
      } else {
        // minor line
        if (showMinorGrid) {
          line = this._repaintMinorLine(x, width, orientation, className);
        } else {
          if (line) {
            // adjust the width of the previous grid
            line.style.width = parseInt(line.style.width) + width + 'px';
          }
        }
      }
    }

    if (count === MAX && !warnedForOverflow) {
      console.warn('Something is wrong with the Timeline scale. Limited drawing of grid lines to ' + MAX + ' lines.');
      warnedForOverflow = true;
    }

    // create a major label on the left when needed
    if (this.options.showMajorLabels) {
      var leftTime = this.body.util.toTime(0),
          leftText = step.getLabelMajor(leftTime),
          widthText = leftText.length * (this.props.majorCharWidth || 10) + 10; // upper bound estimation

      if (xFirstMajorLabel == undefined || widthText < xFirstMajorLabel) {
        this._repaintMajorText(0, leftText, orientation, className);
      }
    }

    // Cleanup leftover DOM elements from the redundant list
    util.forEach(this.dom.redundant, function (arr) {
      while (arr.length) {
        var elem = arr.pop();
        if (elem && elem.parentNode) {
          elem.parentNode.removeChild(elem);
        }
      }
    });
  };

  /**
   * Create a minor label for the axis at position x
   * @param {Number} x
   * @param {String} text
   * @param {String} orientation   "top" or "bottom" (default)
   * @param {String} className
   * @return {Element} Returns the HTML element of the created label
   * @private
   */
  TimeAxis.prototype._repaintMinorText = function (x, text, orientation, className) {
    // reuse redundant label
    var label = this.dom.redundant.minorTexts.shift();

    if (!label) {
      // create new label
      var content = document.createTextNode('');
      label = document.createElement('div');
      label.appendChild(content);
      this.dom.foreground.appendChild(label);
    }
    this.dom.minorTexts.push(label);

    label.childNodes[0].nodeValue = text;

    label.style.top = orientation == 'top' ? this.props.majorLabelHeight + 'px' : '0';

    if (this.options.rtl) {
      label.style.left = "";
      label.style.right = x + 'px';
    } else {
      label.style.left = x + 'px';
    };
    label.className = 'vis-text vis-minor ' + className;
    //label.title = title;  // TODO: this is a heavy operation

    return label;
  };

  /**
   * Create a Major label for the axis at position x
   * @param {Number} x
   * @param {String} text
   * @param {String} orientation   "top" or "bottom" (default)
   * @param {String} className
   * @return {Element} Returns the HTML element of the created label
   * @private
   */
  TimeAxis.prototype._repaintMajorText = function (x, text, orientation, className) {
    // reuse redundant label
    var label = this.dom.redundant.majorTexts.shift();

    if (!label) {
      // create label
      var content = document.createTextNode(text);
      label = document.createElement('div');
      label.appendChild(content);
      this.dom.foreground.appendChild(label);
    }
    this.dom.majorTexts.push(label);

    label.childNodes[0].nodeValue = text;
    label.className = 'vis-text vis-major ' + className;
    //label.title = title; // TODO: this is a heavy operation

    label.style.top = orientation == 'top' ? '0' : this.props.minorLabelHeight + 'px';
    if (this.options.rtl) {
      label.style.left = "";
      label.style.right = x + 'px';
    } else {
      label.style.left = x + 'px';
    };

    return label;
  };

  /**
   * Create a minor line for the axis at position x
   * @param {Number} x
   * @param {Number} width
   * @param {String} orientation   "top" or "bottom" (default)
   * @param {String} className
   * @return {Element} Returns the created line
   * @private
   */
  TimeAxis.prototype._repaintMinorLine = function (x, width, orientation, className) {
    // reuse redundant line
    var line = this.dom.redundant.lines.shift();
    if (!line) {
      // create vertical line
      line = document.createElement('div');
      this.dom.background.appendChild(line);
    }
    this.dom.lines.push(line);

    var props = this.props;
    if (orientation == 'top') {
      line.style.top = props.majorLabelHeight + 'px';
    } else {
      line.style.top = this.body.domProps.top.height + 'px';
    }
    line.style.height = props.minorLineHeight + 'px';
    if (this.options.rtl) {
      line.style.left = "";
      line.style.right = x - props.minorLineWidth / 2 + 'px';
      line.className = 'vis-grid vis-vertical-rtl vis-minor ' + className;
    } else {
      line.style.left = x - props.minorLineWidth / 2 + 'px';
      line.className = 'vis-grid vis-vertical vis-minor ' + className;
    };
    line.style.width = width + 'px';

    return line;
  };

  /**
   * Create a Major line for the axis at position x
   * @param {Number} x
   * @param {Number} width
   * @param {String} orientation   "top" or "bottom" (default)
   * @param {String} className
   * @return {Element} Returns the created line
   * @private
   */
  TimeAxis.prototype._repaintMajorLine = function (x, width, orientation, className) {
    // reuse redundant line
    var line = this.dom.redundant.lines.shift();
    if (!line) {
      // create vertical line
      line = document.createElement('div');
      this.dom.background.appendChild(line);
    }
    this.dom.lines.push(line);

    var props = this.props;
    if (orientation == 'top') {
      line.style.top = '0';
    } else {
      line.style.top = this.body.domProps.top.height + 'px';
    }

    if (this.options.rtl) {
      line.style.left = "";
      line.style.right = x - props.majorLineWidth / 2 + 'px';
      line.className = 'vis-grid vis-vertical-rtl vis-major ' + className;
    } else {
      line.style.left = x - props.majorLineWidth / 2 + 'px';
      line.className = 'vis-grid vis-vertical vis-major ' + className;
    }

    line.style.height = props.majorLineHeight + 'px';
    line.style.width = width + 'px';

    return line;
  };

  /**
   * Determine the size of text on the axis (both major and minor axis).
   * The size is calculated only once and then cached in this.props.
   * @private
   */
  TimeAxis.prototype._calculateCharSize = function () {
    // Note: We calculate char size with every redraw. Size may change, for
    // example when any of the timelines parents had display:none for example.

    // determine the char width and height on the minor axis
    if (!this.dom.measureCharMinor) {
      this.dom.measureCharMinor = document.createElement('DIV');
      this.dom.measureCharMinor.className = 'vis-text vis-minor vis-measure';
      this.dom.measureCharMinor.style.position = 'absolute';

      this.dom.measureCharMinor.appendChild(document.createTextNode('0'));
      this.dom.foreground.appendChild(this.dom.measureCharMinor);
    }
    this.props.minorCharHeight = this.dom.measureCharMinor.clientHeight;
    this.props.minorCharWidth = this.dom.measureCharMinor.clientWidth;

    // determine the char width and height on the major axis
    if (!this.dom.measureCharMajor) {
      this.dom.measureCharMajor = document.createElement('DIV');
      this.dom.measureCharMajor.className = 'vis-text vis-major vis-measure';
      this.dom.measureCharMajor.style.position = 'absolute';

      this.dom.measureCharMajor.appendChild(document.createTextNode('0'));
      this.dom.foreground.appendChild(this.dom.measureCharMajor);
    }
    this.props.majorCharHeight = this.dom.measureCharMajor.clientHeight;
    this.props.majorCharWidth = this.dom.measureCharMajor.clientWidth;
  };

  var warnedForOverflow = false;

  module.exports = TimeAxis;

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var keycharm = __webpack_require__(25);
  var Emitter = __webpack_require__(13);
  var Hammer = __webpack_require__(22);
  var util = __webpack_require__(1);

  /**
   * Turn an element into an clickToUse element.
   * When not active, the element has a transparent overlay. When the overlay is
   * clicked, the mode is changed to active.
   * When active, the element is displayed with a blue border around it, and
   * the interactive contents of the element can be used. When clicked outside
   * the element, the elements mode is changed to inactive.
   * @param {Element} container
   * @constructor
   */
  function Activator(container) {
    this.active = false;

    this.dom = {
      container: container
    };

    this.dom.overlay = document.createElement('div');
    this.dom.overlay.className = 'vis-overlay';

    this.dom.container.appendChild(this.dom.overlay);

    this.hammer = Hammer(this.dom.overlay);
    this.hammer.on('tap', this._onTapOverlay.bind(this));

    // block all touch events (except tap)
    var me = this;
    var events = ['tap', 'doubletap', 'press', 'pinch', 'pan', 'panstart', 'panmove', 'panend'];
    events.forEach(function (event) {
      me.hammer.on(event, function (event) {
        event.stopPropagation();
      });
    });

    // attach a click event to the window, in order to deactivate when clicking outside the timeline
    if (document && document.body) {
      this.onClick = function (event) {
        if (!_hasParent(event.target, container)) {
          me.deactivate();
        }
      };
      document.body.addEventListener('click', this.onClick);
    }

    if (this.keycharm !== undefined) {
      this.keycharm.destroy();
    }
    this.keycharm = keycharm();

    // keycharm listener only bounded when active)
    this.escListener = this.deactivate.bind(this);
  }

  // turn into an event emitter
  Emitter(Activator.prototype);

  // The currently active activator
  Activator.current = null;

  /**
   * Destroy the activator. Cleans up all created DOM and event listeners
   */
  Activator.prototype.destroy = function () {
    this.deactivate();

    // remove dom
    this.dom.overlay.parentNode.removeChild(this.dom.overlay);

    // remove global event listener
    if (this.onClick) {
      document.body.removeEventListener('click', this.onClick);
    }

    // cleanup hammer instances
    this.hammer.destroy();
    this.hammer = null;
    // FIXME: cleaning up hammer instances doesn't work (Timeline not removed from memory)
  };

  /**
   * Activate the element
   * Overlay is hidden, element is decorated with a blue shadow border
   */
  Activator.prototype.activate = function () {
    // we allow only one active activator at a time
    if (Activator.current) {
      Activator.current.deactivate();
    }
    Activator.current = this;

    this.active = true;
    this.dom.overlay.style.display = 'none';
    util.addClassName(this.dom.container, 'vis-active');

    this.emit('change');
    this.emit('activate');

    // ugly hack: bind ESC after emitting the events, as the Network rebinds all
    // keyboard events on a 'change' event
    this.keycharm.bind('esc', this.escListener);
  };

  /**
   * Deactivate the element
   * Overlay is displayed on top of the element
   */
  Activator.prototype.deactivate = function () {
    this.active = false;
    this.dom.overlay.style.display = '';
    util.removeClassName(this.dom.container, 'vis-active');
    this.keycharm.unbind('esc', this.escListener);

    this.emit('change');
    this.emit('deactivate');
  };

  /**
   * Handle a tap event: activate the container
   * @param event
   * @private
   */
  Activator.prototype._onTapOverlay = function (event) {
    // activate the container
    this.activate();
    event.stopPropagation();
  };

  /**
   * Test whether the element has the requested parent element somewhere in
   * its chain of parent nodes.
   * @param {HTMLElement} element
   * @param {HTMLElement} parent
   * @returns {boolean} Returns true when the parent is found somewhere in the
   *                    chain of parent nodes.
   * @private
   */
  function _hasParent(element, parent) {
    while (element) {
      if (element === parent) {
        return true;
      }
      element = element.parentNode;
    }
    return false;
  }

  module.exports = Activator;

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Hammer = __webpack_require__(22);
  var util = __webpack_require__(1);
  var Component = __webpack_require__(33);
  var moment = __webpack_require__(2);
  var locales = __webpack_require__(49);

  /**
   * A custom time bar
   * @param {{range: Range, dom: Object}} body
   * @param {Object} [options]        Available parameters:
   *                                  {number | string} id
   *                                  {string} locales
   *                                  {string} locale
   * @constructor CustomTime
   * @extends Component
   */

  function CustomTime(body, options) {
    this.body = body;

    // default options
    this.defaultOptions = {
      moment: moment,
      locales: locales,
      locale: 'en',
      id: undefined,
      title: undefined
    };
    this.options = util.extend({}, this.defaultOptions);

    if (options && options.time) {
      this.customTime = options.time;
    } else {
      this.customTime = new Date();
    }

    this.eventParams = {}; // stores state parameters while dragging the bar

    this.setOptions(options);

    // create the DOM
    this._create();
  }

  CustomTime.prototype = new Component();

  /**
   * Set options for the component. Options will be merged in current options.
   * @param {Object} options  Available parameters:
   *                                  {number | string} id
   *                                  {string} locales
   *                                  {string} locale
   */
  CustomTime.prototype.setOptions = function (options) {
    if (options) {
      // copy all options that we know
      util.selectiveExtend(['moment', 'locale', 'locales', 'id'], this.options, options);
    }
  };

  /**
   * Create the DOM for the custom time
   * @private
   */
  CustomTime.prototype._create = function () {
    var bar = document.createElement('div');
    bar['custom-time'] = this;
    bar.className = 'vis-custom-time ' + (this.options.id || '');
    bar.style.position = 'absolute';
    bar.style.top = '0px';
    bar.style.height = '100%';
    this.bar = bar;

    var drag = document.createElement('div');
    drag.style.position = 'relative';
    drag.style.top = '0px';
    drag.style.left = '-10px';
    drag.style.height = '100%';
    drag.style.width = '20px';
    bar.appendChild(drag);

    // attach event listeners
    this.hammer = new Hammer(drag);
    this.hammer.on('panstart', this._onDragStart.bind(this));
    this.hammer.on('panmove', this._onDrag.bind(this));
    this.hammer.on('panend', this._onDragEnd.bind(this));
    this.hammer.get('pan').set({ threshold: 5, direction: Hammer.DIRECTION_HORIZONTAL });
  };

  /**
   * Destroy the CustomTime bar
   */
  CustomTime.prototype.destroy = function () {
    this.hide();

    this.hammer.destroy();
    this.hammer = null;

    this.body = null;
  };

  /**
   * Repaint the component
   * @return {boolean} Returns true if the component is resized
   */
  CustomTime.prototype.redraw = function () {
    var parent = this.body.dom.backgroundVertical;
    if (this.bar.parentNode != parent) {
      // attach to the dom
      if (this.bar.parentNode) {
        this.bar.parentNode.removeChild(this.bar);
      }
      parent.appendChild(this.bar);
    }

    var x = this.body.util.toScreen(this.customTime);

    var locale = this.options.locales[this.options.locale];
    if (!locale) {
      if (!this.warned) {
        console.log('WARNING: options.locales[\'' + this.options.locale + '\'] not found. See http://visjs.org/docs/timeline/#Localization');
        this.warned = true;
      }
      locale = this.options.locales['en']; // fall back on english when not available
    }

    var title = this.options.title;
    // To hide the title completely use empty string ''.
    if (title === undefined) {
      title = locale.time + ': ' + this.options.moment(this.customTime).format('dddd, MMMM Do YYYY, H:mm:ss');
      title = title.charAt(0).toUpperCase() + title.substring(1);
    }

    this.bar.style.left = x + 'px';
    this.bar.title = title;

    return false;
  };

  /**
   * Remove the CustomTime from the DOM
   */
  CustomTime.prototype.hide = function () {
    // remove the line from the DOM
    if (this.bar.parentNode) {
      this.bar.parentNode.removeChild(this.bar);
    }
  };

  /**
   * Set custom time.
   * @param {Date | number | string} time
   */
  CustomTime.prototype.setCustomTime = function (time) {
    this.customTime = util.convert(time, 'Date');
    this.redraw();
  };

  /**
   * Retrieve the current custom time.
   * @return {Date} customTime
   */
  CustomTime.prototype.getCustomTime = function () {
    return new Date(this.customTime.valueOf());
  };

  /**
    * Set custom title.
    * @param {Date | number | string} title
    */
  CustomTime.prototype.setCustomTitle = function (title) {
    this.options.title = title;
  };

  /**
   * Start moving horizontally
   * @param {Event} event
   * @private
   */
  CustomTime.prototype._onDragStart = function (event) {
    this.eventParams.dragging = true;
    this.eventParams.customTime = this.customTime;

    event.stopPropagation();
  };

  /**
   * Perform moving operating.
   * @param {Event} event
   * @private
   */
  CustomTime.prototype._onDrag = function (event) {
    if (!this.eventParams.dragging) return;

    var x = this.body.util.toScreen(this.eventParams.customTime) + event.deltaX;
    var time = this.body.util.toTime(x);

    this.setCustomTime(time);

    // fire a timechange event
    this.body.emitter.emit('timechange', {
      id: this.options.id,
      time: new Date(this.customTime.valueOf())
    });

    event.stopPropagation();
  };

  /**
   * Stop moving operating.
   * @param {Event} event
   * @private
   */
  CustomTime.prototype._onDragEnd = function (event) {
    if (!this.eventParams.dragging) return;

    // fire a timechanged event
    this.body.emitter.emit('timechanged', {
      id: this.options.id,
      time: new Date(this.customTime.valueOf())
    });

    event.stopPropagation();
  };

  /**
   * Find a custom time from an event target:
   * searches for the attribute 'custom-time' in the event target's element tree
   * @param {Event} event
   * @return {CustomTime | null} customTime
   */
  CustomTime.customTimeFromTarget = function (event) {
    var target = event.target;
    while (target) {
      if (target.hasOwnProperty('custom-time')) {
        return target['custom-time'];
      }
      target = target.parentNode;
    }

    return null;
  };

  module.exports = CustomTime;

/***/ },
/* 49 */
/***/ function(module, exports) {

  'use strict';

  // English
  exports['en'] = {
    current: 'current',
    time: 'time'
  };
  exports['en_EN'] = exports['en'];
  exports['en_US'] = exports['en'];

  // Italiano
  exports['it'] = {
    current: 'attuale',
    time: 'tempo'
  };
  exports['it_IT'] = exports['it'];
  exports['it_CH'] = exports['it'];

  // Dutch
  exports['nl'] = {
    current: 'huidige',
    time: 'tijd'
  };
  exports['nl_NL'] = exports['nl'];
  exports['nl_BE'] = exports['nl'];

  // German
  exports['de'] = {
    current: 'Aktuelle',
    time: 'Zeit'
  };
  exports['de_DE'] = exports['de'];

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);
  var Component = __webpack_require__(33);
  var moment = __webpack_require__(2);
  var locales = __webpack_require__(49);

  /**
   * A current time bar
   * @param {{range: Range, dom: Object, domProps: Object}} body
   * @param {Object} [options]        Available parameters:
   *                                  {Boolean} [showCurrentTime]
   * @constructor CurrentTime
   * @extends Component
   */
  function CurrentTime(body, options) {
    this.body = body;

    // default options
    this.defaultOptions = {
      rtl: false,
      showCurrentTime: true,

      moment: moment,
      locales: locales,
      locale: 'en'
    };
    this.options = util.extend({}, this.defaultOptions);
    this.offset = 0;

    this._create();

    this.setOptions(options);
  }

  CurrentTime.prototype = new Component();

  /**
   * Create the HTML DOM for the current time bar
   * @private
   */
  CurrentTime.prototype._create = function () {
    var bar = document.createElement('div');
    bar.className = 'vis-current-time';
    bar.style.position = 'absolute';
    bar.style.top = '0px';
    bar.style.height = '100%';

    this.bar = bar;
  };

  /**
   * Destroy the CurrentTime bar
   */
  CurrentTime.prototype.destroy = function () {
    this.options.showCurrentTime = false;
    this.redraw(); // will remove the bar from the DOM and stop refreshing

    this.body = null;
  };

  /**
   * Set options for the component. Options will be merged in current options.
   * @param {Object} options  Available parameters:
   *                          {boolean} [showCurrentTime]
   */
  CurrentTime.prototype.setOptions = function (options) {
    if (options) {
      // copy all options that we know
      util.selectiveExtend(['rtl', 'showCurrentTime', 'moment', 'locale', 'locales'], this.options, options);
    }
  };

  /**
   * Repaint the component
   * @return {boolean} Returns true if the component is resized
   */
  CurrentTime.prototype.redraw = function () {
    if (this.options.showCurrentTime) {
      var parent = this.body.dom.backgroundVertical;
      if (this.bar.parentNode != parent) {
        // attach to the dom
        if (this.bar.parentNode) {
          this.bar.parentNode.removeChild(this.bar);
        }
        parent.appendChild(this.bar);

        this.start();
      }

      var now = this.options.moment(new Date().valueOf() + this.offset);
      var x = this.body.util.toScreen(now);

      var locale = this.options.locales[this.options.locale];
      if (!locale) {
        if (!this.warned) {
          console.log('WARNING: options.locales[\'' + this.options.locale + '\'] not found. See http://visjs.org/docs/timeline/#Localization');
          this.warned = true;
        }
        locale = this.options.locales['en']; // fall back on english when not available
      }
      var title = locale.current + ' ' + locale.time + ': ' + now.format('dddd, MMMM Do YYYY, H:mm:ss');
      title = title.charAt(0).toUpperCase() + title.substring(1);

      if (this.options.rtl) {
        this.bar.style.right = x + 'px';
      } else {
        this.bar.style.left = x + 'px';
      }
      this.bar.title = title;
    } else {
      // remove the line from the DOM
      if (this.bar.parentNode) {
        this.bar.parentNode.removeChild(this.bar);
      }
      this.stop();
    }

    return false;
  };

  /**
   * Start auto refreshing the current time bar
   */
  CurrentTime.prototype.start = function () {
    var me = this;

    function update() {
      me.stop();

      // determine interval to refresh
      var scale = me.body.range.conversion(me.body.domProps.center.width).scale;
      var interval = 1 / scale / 10;
      if (interval < 30) interval = 30;
      if (interval > 1000) interval = 1000;

      me.redraw();
      me.body.emitter.emit('currentTimeTick');

      // start a renderTimer to adjust for the new time
      me.currentTimeTimer = setTimeout(update, interval);
    }

    update();
  };

  /**
   * Stop auto refreshing the current time bar
   */
  CurrentTime.prototype.stop = function () {
    if (this.currentTimeTimer !== undefined) {
      clearTimeout(this.currentTimeTimer);
      delete this.currentTimeTimer;
    }
  };

  /**
   * Set a current time. This can be used for example to ensure that a client's
   * time is synchronized with a shared server time.
   * @param {Date | String | Number} time     A Date, unix timestamp, or
   *                                          ISO date string.
   */
  CurrentTime.prototype.setCurrentTime = function (time) {
    var t = util.convert(time, 'Date').valueOf();
    var now = new Date().valueOf();
    this.offset = t - now;
    this.redraw();
  };

  /**
   * Get the current time.
   * @return {Date} Returns the current time.
   */
  CurrentTime.prototype.getCurrentTime = function () {
    return new Date(new Date().valueOf() + this.offset);
  };

  module.exports = CurrentTime;

/***/ },
/* 51 */
/***/ function(module, exports) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /**
   * This object contains all possible options. It will check if the types are correct, if required if the option is one
   * of the allowed values.
   *
   * __any__ means that the name of the property does not matter.
   * __type__ is a required field for all objects and contains the allowed types of all objects
   */
  var string = 'string';
  var boolean = 'boolean';
  var number = 'number';
  var array = 'array';
  var date = 'date';
  var object = 'object'; // should only be in a __type__ property
  var dom = 'dom';
  var moment = 'moment';
  var any = 'any';

  var allOptions = {
    configure: {
      enabled: { boolean: boolean },
      filter: { boolean: boolean, 'function': 'function' },
      container: { dom: dom },
      __type__: { object: object, boolean: boolean, 'function': 'function' }
    },

    //globals :
    align: { string: string },
    rtl: { boolean: boolean, 'undefined': 'undefined' },
    verticalScroll: { boolean: boolean, 'undefined': 'undefined' },
    horizontalScroll: { boolean: boolean, 'undefined': 'undefined' },
    autoResize: { boolean: boolean },
    clickToUse: { boolean: boolean },
    dataAttributes: { string: string, array: array },
    editable: {
      add: { boolean: boolean, 'undefined': 'undefined' },
      remove: { boolean: boolean, 'undefined': 'undefined' },
      updateGroup: { boolean: boolean, 'undefined': 'undefined' },
      updateTime: { boolean: boolean, 'undefined': 'undefined' },
      __type__: { boolean: boolean, object: object }
    },
    end: { number: number, date: date, string: string, moment: moment },
    format: {
      minorLabels: {
        millisecond: { string: string, 'undefined': 'undefined' },
        second: { string: string, 'undefined': 'undefined' },
        minute: { string: string, 'undefined': 'undefined' },
        hour: { string: string, 'undefined': 'undefined' },
        weekday: { string: string, 'undefined': 'undefined' },
        day: { string: string, 'undefined': 'undefined' },
        month: { string: string, 'undefined': 'undefined' },
        year: { string: string, 'undefined': 'undefined' },
        __type__: { object: object, 'function': 'function' }
      },
      majorLabels: {
        millisecond: { string: string, 'undefined': 'undefined' },
        second: { string: string, 'undefined': 'undefined' },
        minute: { string: string, 'undefined': 'undefined' },
        hour: { string: string, 'undefined': 'undefined' },
        weekday: { string: string, 'undefined': 'undefined' },
        day: { string: string, 'undefined': 'undefined' },
        month: { string: string, 'undefined': 'undefined' },
        year: { string: string, 'undefined': 'undefined' },
        __type__: { object: object, 'function': 'function' }
      },
      __type__: { object: object }
    },
    moment: { 'function': 'function' },
    groupOrder: { string: string, 'function': 'function' },
    groupEditable: {
      add: { boolean: boolean, 'undefined': 'undefined' },
      remove: { boolean: boolean, 'undefined': 'undefined' },
      order: { boolean: boolean, 'undefined': 'undefined' },
      __type__: { boolean: boolean, object: object }
    },
    groupOrderSwap: { 'function': 'function' },
    height: { string: string, number: number },
    hiddenDates: {
      start: { date: date, number: number, string: string, moment: moment },
      end: { date: date, number: number, string: string, moment: moment },
      repeat: { string: string },
      __type__: { object: object, array: array }
    },
    itemsAlwaysDraggable: { boolean: boolean },
    locale: { string: string },
    locales: {
      __any__: { any: any },
      __type__: { object: object }
    },
    margin: {
      axis: { number: number },
      item: {
        horizontal: { number: number, 'undefined': 'undefined' },
        vertical: { number: number, 'undefined': 'undefined' },
        __type__: { object: object, number: number }
      },
      __type__: { object: object, number: number }
    },
    max: { date: date, number: number, string: string, moment: moment },
    maxHeight: { number: number, string: string },
    maxMinorChars: { number: number },
    min: { date: date, number: number, string: string, moment: moment },
    minHeight: { number: number, string: string },
    moveable: { boolean: boolean },
    multiselect: { boolean: boolean },
    multiselectPerGroup: { boolean: boolean },
    onAdd: { 'function': 'function' },
    onUpdate: { 'function': 'function' },
    onMove: { 'function': 'function' },
    onMoving: { 'function': 'function' },
    onRemove: { 'function': 'function' },
    onAddGroup: { 'function': 'function' },
    onMoveGroup: { 'function': 'function' },
    onRemoveGroup: { 'function': 'function' },
    order: { 'function': 'function' },
    orientation: {
      axis: { string: string, 'undefined': 'undefined' },
      item: { string: string, 'undefined': 'undefined' },
      __type__: { string: string, object: object }
    },
    selectable: { boolean: boolean },
    showCurrentTime: { boolean: boolean },
    showMajorLabels: { boolean: boolean },
    showMinorLabels: { boolean: boolean },
    stack: { boolean: boolean },
    snap: { 'function': 'function', 'null': 'null' },
    start: { date: date, number: number, string: string, moment: moment },
    template: { 'function': 'function' },
    groupTemplate: { 'function': 'function' },
    tooltipOnItemUpdateTime: {
      template: { 'function': 'function' },
      __type__: { boolean: boolean, object: object }
    },
    timeAxis: {
      scale: { string: string, 'undefined': 'undefined' },
      step: { number: number, 'undefined': 'undefined' },
      __type__: { object: object }
    },
    type: { string: string },
    width: { string: string, number: number },
    zoomable: { boolean: boolean },
    zoomKey: { string: ['ctrlKey', 'altKey', 'metaKey', ''] },
    zoomMax: { number: number },
    zoomMin: { number: number },

    __type__: { object: object }
  };

  var configureOptions = {
    global: {
      align: ['center', 'left', 'right'],
      direction: false,
      autoResize: true,
      clickToUse: false,
      // dataAttributes: ['all'], // FIXME: can be 'all' or string[]
      editable: {
        add: false,
        remove: false,
        updateGroup: false,
        updateTime: false
      },
      end: '',
      format: {
        minorLabels: {
          millisecond: 'SSS',
          second: 's',
          minute: 'HH:mm',
          hour: 'HH:mm',
          weekday: 'ddd D',
          day: 'D',
          month: 'MMM',
          year: 'YYYY'
        },
        majorLabels: {
          millisecond: 'HH:mm:ss',
          second: 'D MMMM HH:mm',
          minute: 'ddd D MMMM',
          hour: 'ddd D MMMM',
          weekday: 'MMMM YYYY',
          day: 'MMMM YYYY',
          month: 'YYYY',
          year: ''
        }
      },

      //groupOrder: {string, 'function': 'function'},
      groupsDraggable: false,
      height: '',
      //hiddenDates: {object, array},
      locale: '',
      margin: {
        axis: [20, 0, 100, 1],
        item: {
          horizontal: [10, 0, 100, 1],
          vertical: [10, 0, 100, 1]
        }
      },
      max: '',
      maxHeight: '',
      maxMinorChars: [7, 0, 20, 1],
      min: '',
      minHeight: '',
      moveable: false,
      multiselect: false,
      multiselectPerGroup: false,
      //onAdd: {'function': 'function'},
      //onUpdate: {'function': 'function'},
      //onMove: {'function': 'function'},
      //onMoving: {'function': 'function'},
      //onRename: {'function': 'function'},
      //order: {'function': 'function'},
      orientation: {
        axis: ['both', 'bottom', 'top'],
        item: ['bottom', 'top']
      },
      selectable: true,
      showCurrentTime: false,
      showMajorLabels: true,
      showMinorLabels: true,
      stack: true,
      //snap: {'function': 'function', nada},
      start: '',
      //template: {'function': 'function'},
      //timeAxis: {
      //  scale: ['millisecond', 'second', 'minute', 'hour', 'weekday', 'day', 'month', 'year'],
      //  step: [1, 1, 10, 1]
      //},
      tooltipOnItemUpdateTime: false,
      type: ['box', 'point', 'range', 'background'],
      width: '100%',
      zoomable: true,
      zoomKey: ['ctrlKey', 'altKey', 'metaKey', ''],
      zoomMax: [315360000000000, 10, 315360000000000, 1],
      zoomMin: [10, 10, 315360000000000, 1]
    }
  };

  exports.allOptions = allOptions;
  exports.configureOptions = configureOptions;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _Configurator = __webpack_require__(28);

  var _Configurator2 = _interopRequireDefault(_Configurator);

  var _Validator = __webpack_require__(31);

  var _Validator2 = _interopRequireDefault(_Validator);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var Emitter = __webpack_require__(13);
  var Hammer = __webpack_require__(22);
  var moment = __webpack_require__(2);
  var util = __webpack_require__(1);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);
  var Range = __webpack_require__(32);
  var Core = __webpack_require__(35);
  var TimeAxis = __webpack_require__(46);
  var CurrentTime = __webpack_require__(50);
  var CustomTime = __webpack_require__(48);
  var LineGraph = __webpack_require__(53);

  var printStyle = __webpack_require__(31).printStyle;
  var allOptions = __webpack_require__(61).allOptions;
  var configureOptions = __webpack_require__(61).configureOptions;

  /**
   * Create a timeline visualization
   * @param {HTMLElement} container
   * @param {vis.DataSet | Array} [items]
   * @param {Object} [options]  See Graph2d.setOptions for the available options.
   * @constructor
   * @extends Core
   */
  function Graph2d(container, items, groups, options) {
    // if the third element is options, the forth is groups (optionally);
    if (!(Array.isArray(groups) || groups instanceof DataSet || groups instanceof DataView) && groups instanceof Object) {
      var forthArgument = options;
      options = groups;
      groups = forthArgument;
    }

    var me = this;
    this.defaultOptions = {
      start: null,
      end: null,

      autoResize: true,

      orientation: {
        axis: 'bottom', // axis orientation: 'bottom', 'top', or 'both'
        item: 'bottom' // not relevant for Graph2d
      },

      moment: moment,

      width: null,
      height: null,
      maxHeight: null,
      minHeight: null
    };
    this.options = util.deepExtend({}, this.defaultOptions);

    // Create the DOM, props, and emitter
    this._create(container);

    // all components listed here will be repainted automatically
    this.components = [];

    this.body = {
      dom: this.dom,
      domProps: this.props,
      emitter: {
        on: this.on.bind(this),
        off: this.off.bind(this),
        emit: this.emit.bind(this)
      },
      hiddenDates: [],
      util: {
        toScreen: me._toScreen.bind(me),
        toGlobalScreen: me._toGlobalScreen.bind(me), // this refers to the root.width
        toTime: me._toTime.bind(me),
        toGlobalTime: me._toGlobalTime.bind(me)
      }
    };

    // range
    this.range = new Range(this.body);
    this.components.push(this.range);
    this.body.range = this.range;

    // time axis
    this.timeAxis = new TimeAxis(this.body);
    this.components.push(this.timeAxis);
    //this.body.util.snap = this.timeAxis.snap.bind(this.timeAxis);

    // current time bar
    this.currentTime = new CurrentTime(this.body);
    this.components.push(this.currentTime);

    // item set
    this.linegraph = new LineGraph(this.body);

    this.components.push(this.linegraph);

    this.itemsData = null; // DataSet
    this.groupsData = null; // DataSet


    this.on('tap', function (event) {
      me.emit('click', me.getEventProperties(event));
    });
    this.on('doubletap', function (event) {
      me.emit('doubleClick', me.getEventProperties(event));
    });
    this.dom.root.oncontextmenu = function (event) {
      me.emit('contextmenu', me.getEventProperties(event));
    };

    // apply options
    if (options) {
      this.setOptions(options);
    }

    // IMPORTANT: THIS HAPPENS BEFORE SET ITEMS!
    if (groups) {
      this.setGroups(groups);
    }

    // create itemset
    if (items) {
      this.setItems(items);
    }

    // draw for the first time
    this._redraw();
  }

  // Extend the functionality from Core
  Graph2d.prototype = new Core();

  Graph2d.prototype.setOptions = function (options) {
    // validate options
    var errorFound = _Validator2.default.validate(options, allOptions);
    if (errorFound === true) {
      console.log('%cErrors have been found in the supplied options object.', printStyle);
    }

    Core.prototype.setOptions.call(this, options);
  };

  /**
   * Set items
   * @param {vis.DataSet | Array | null} items
   */
  Graph2d.prototype.setItems = function (items) {
    var initialLoad = this.itemsData == null;

    // convert to type DataSet when needed
    var newDataSet;
    if (!items) {
      newDataSet = null;
    } else if (items instanceof DataSet || items instanceof DataView) {
      newDataSet = items;
    } else {
      // turn an array into a dataset
      newDataSet = new DataSet(items, {
        type: {
          start: 'Date',
          end: 'Date'
        }
      });
    }

    // set items
    this.itemsData = newDataSet;
    this.linegraph && this.linegraph.setItems(newDataSet);

    if (initialLoad) {
      if (this.options.start != undefined || this.options.end != undefined) {
        var start = this.options.start != undefined ? this.options.start : null;
        var end = this.options.end != undefined ? this.options.end : null;
        this.setWindow(start, end, { animation: false });
      } else {
        this.fit({ animation: false });
      }
    }
  };

  /**
   * Set groups
   * @param {vis.DataSet | Array} groups
   */
  Graph2d.prototype.setGroups = function (groups) {
    // convert to type DataSet when needed
    var newDataSet;
    if (!groups) {
      newDataSet = null;
    } else if (groups instanceof DataSet || groups instanceof DataView) {
      newDataSet = groups;
    } else {
      // turn an array into a dataset
      newDataSet = new DataSet(groups);
    }

    this.groupsData = newDataSet;
    this.linegraph.setGroups(newDataSet);
  };

  /**
   * Returns an object containing an SVG element with the icon of the group (size determined by iconWidth and iconHeight), the label of the group (content) and the yAxisOrientation of the group (left or right).
   * @param groupId
   * @param width
   * @param height
   */
  Graph2d.prototype.getLegend = function (groupId, width, height) {
    if (width === undefined) {
      width = 15;
    }
    if (height === undefined) {
      height = 15;
    }
    if (this.linegraph.groups[groupId] !== undefined) {
      return this.linegraph.groups[groupId].getLegend(width, height);
    } else {
      return "cannot find group:'" + groupId + "'";
    }
  };

  /**
   * This checks if the visible option of the supplied group (by ID) is true or false.
   * @param groupId
   * @returns {*}
   */
  Graph2d.prototype.isGroupVisible = function (groupId) {
    if (this.linegraph.groups[groupId] !== undefined) {
      return this.linegraph.groups[groupId].visible && (this.linegraph.options.groups.visibility[groupId] === undefined || this.linegraph.options.groups.visibility[groupId] == true);
    } else {
      return false;
    }
  };

  /**
   * Get the data range of the item set.
   * @returns {{min: Date, max: Date}} range  A range with a start and end Date.
   *                                          When no minimum is found, min==null
   *                                          When no maximum is found, max==null
   */
  Graph2d.prototype.getDataRange = function () {
    var min = null;
    var max = null;

    // calculate min from start filed
    for (var groupId in this.linegraph.groups) {
      if (this.linegraph.groups.hasOwnProperty(groupId)) {
        if (this.linegraph.groups[groupId].visible == true) {
          for (var i = 0; i < this.linegraph.groups[groupId].itemsData.length; i++) {
            var item = this.linegraph.groups[groupId].itemsData[i];
            var value = util.convert(item.x, 'Date').valueOf();
            min = min == null ? value : min > value ? value : min;
            max = max == null ? value : max < value ? value : max;
          }
        }
      }
    }

    return {
      min: min != null ? new Date(min) : null,
      max: max != null ? new Date(max) : null
    };
  };

  /**
   * Generate Timeline related information from an event
   * @param {Event} event
   * @return {Object} An object with related information, like on which area
   *                  The event happened, whether clicked on an item, etc.
   */
  Graph2d.prototype.getEventProperties = function (event) {
    var clientX = event.center ? event.center.x : event.clientX;
    var clientY = event.center ? event.center.y : event.clientY;
    var x = clientX - util.getAbsoluteLeft(this.dom.centerContainer);
    var y = clientY - util.getAbsoluteTop(this.dom.centerContainer);
    var time = this._toTime(x);

    var customTime = CustomTime.customTimeFromTarget(event);

    var element = util.getTarget(event);
    var what = null;
    if (util.hasParent(element, this.timeAxis.dom.foreground)) {
      what = 'axis';
    } else if (this.timeAxis2 && util.hasParent(element, this.timeAxis2.dom.foreground)) {
      what = 'axis';
    } else if (util.hasParent(element, this.linegraph.yAxisLeft.dom.frame)) {
      what = 'data-axis';
    } else if (util.hasParent(element, this.linegraph.yAxisRight.dom.frame)) {
      what = 'data-axis';
    } else if (util.hasParent(element, this.linegraph.legendLeft.dom.frame)) {
      what = 'legend';
    } else if (util.hasParent(element, this.linegraph.legendRight.dom.frame)) {
      what = 'legend';
    } else if (customTime != null) {
      what = 'custom-time';
    } else if (util.hasParent(element, this.currentTime.bar)) {
      what = 'current-time';
    } else if (util.hasParent(element, this.dom.center)) {
      what = 'background';
    }

    var value = [];
    var yAxisLeft = this.linegraph.yAxisLeft;
    var yAxisRight = this.linegraph.yAxisRight;
    if (!yAxisLeft.hidden) {
      value.push(yAxisLeft.screenToValue(y));
    }
    if (!yAxisRight.hidden) {
      value.push(yAxisRight.screenToValue(y));
    }

    return {
      event: event,
      what: what,
      pageX: event.srcEvent ? event.srcEvent.pageX : event.pageX,
      pageY: event.srcEvent ? event.srcEvent.pageY : event.pageY,
      x: x,
      y: y,
      time: time,
      value: value
    };
  };

  /**
   * Load a configurator
   * @return {Object}
   * @private
   */
  Graph2d.prototype._createConfigurator = function () {
    return new _Configurator2.default(this, this.dom.container, configureOptions);
  };

  module.exports = Graph2d;

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var util = __webpack_require__(1);
  var DOMutil = __webpack_require__(8);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);
  var Component = __webpack_require__(33);
  var DataAxis = __webpack_require__(54);
  var GraphGroup = __webpack_require__(56);
  var Legend = __webpack_require__(60);
  var Bars = __webpack_require__(57);
  var Lines = __webpack_require__(59);
  var Points = __webpack_require__(58);

  var UNGROUPED = '__ungrouped__'; // reserved group id for ungrouped items

  /**
   * This is the constructor of the LineGraph. It requires a Timeline body and options.
   *
   * @param body
   * @param options
   * @constructor
   */
  function LineGraph(body, options) {
    this.id = util.randomUUID();
    this.body = body;

    this.defaultOptions = {
      yAxisOrientation: 'left',
      defaultGroup: 'default',
      sort: true,
      sampling: true,
      stack: false,
      graphHeight: '400px',
      shaded: {
        enabled: false,
        orientation: 'bottom' // top, bottom, zero
      },
      style: 'line', // line, bar
      barChart: {
        width: 50,
        sideBySide: false,
        align: 'center' // left, center, right
      },
      interpolation: {
        enabled: true,
        parametrization: 'centripetal', // uniform (alpha = 0.0), chordal (alpha = 1.0), centripetal (alpha = 0.5)
        alpha: 0.5
      },
      drawPoints: {
        enabled: true,
        size: 6,
        style: 'square' // square, circle
      },
      dataAxis: {}, //Defaults are done on DataAxis level
      legend: {}, //Defaults are done on Legend level
      groups: {
        visibility: {}
      }
    };

    // options is shared by this lineGraph and all its items
    this.options = util.extend({}, this.defaultOptions);
    this.dom = {};
    this.props = {};
    this.hammer = null;
    this.groups = {};
    this.abortedGraphUpdate = false;
    this.updateSVGheight = false;
    this.updateSVGheightOnResize = false;
    this.forceGraphUpdate = true;

    var me = this;
    this.itemsData = null; // DataSet
    this.groupsData = null; // DataSet

    // listeners for the DataSet of the items
    this.itemListeners = {
      'add': function add(event, params, senderId) {
        me._onAdd(params.items);
      },
      'update': function update(event, params, senderId) {
        me._onUpdate(params.items);
      },
      'remove': function remove(event, params, senderId) {
        me._onRemove(params.items);
      }
    };

    // listeners for the DataSet of the groups
    this.groupListeners = {
      'add': function add(event, params, senderId) {
        me._onAddGroups(params.items);
      },
      'update': function update(event, params, senderId) {
        me._onUpdateGroups(params.items);
      },
      'remove': function remove(event, params, senderId) {
        me._onRemoveGroups(params.items);
      }
    };

    this.items = {}; // object with an Item for every data item
    this.selection = []; // list with the ids of all selected nodes
    this.lastStart = this.body.range.start;
    this.touchParams = {}; // stores properties while dragging

    this.svgElements = {};
    this.setOptions(options);
    this.groupsUsingDefaultStyles = [0];
    this.body.emitter.on('rangechanged', function () {
      me.lastStart = me.body.range.start;
      me.svg.style.left = util.option.asSize(-me.props.width);

      me.forceGraphUpdate = true;
      //Is this local redraw necessary? (Core also does a change event!)
      me.redraw.call(me);
    });

    // create the HTML DOM
    this._create();
    this.framework = { svg: this.svg, svgElements: this.svgElements, options: this.options, groups: this.groups };
  }

  LineGraph.prototype = new Component();

  /**
   * Create the HTML DOM for the ItemSet
   */
  LineGraph.prototype._create = function () {
    var frame = document.createElement('div');
    frame.className = 'vis-line-graph';
    this.dom.frame = frame;

    // create svg element for graph drawing.
    this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    this.svg.style.position = 'relative';
    this.svg.style.height = ('' + this.options.graphHeight).replace('px', '') + 'px';
    this.svg.style.display = 'block';
    frame.appendChild(this.svg);

    // data axis
    this.options.dataAxis.orientation = 'left';
    this.yAxisLeft = new DataAxis(this.body, this.options.dataAxis, this.svg, this.options.groups);

    this.options.dataAxis.orientation = 'right';
    this.yAxisRight = new DataAxis(this.body, this.options.dataAxis, this.svg, this.options.groups);
    delete this.options.dataAxis.orientation;

    // legends
    this.legendLeft = new Legend(this.body, this.options.legend, 'left', this.options.groups);
    this.legendRight = new Legend(this.body, this.options.legend, 'right', this.options.groups);

    this.show();
  };

  /**
   * set the options of the LineGraph. the mergeOptions is used for subObjects that have an enabled element.
   * @param {object} options
   */
  LineGraph.prototype.setOptions = function (options) {
    if (options) {
      var fields = ['sampling', 'defaultGroup', 'stack', 'height', 'graphHeight', 'yAxisOrientation', 'style', 'barChart', 'dataAxis', 'sort', 'groups'];
      if (options.graphHeight === undefined && options.height !== undefined) {
        this.updateSVGheight = true;
        this.updateSVGheightOnResize = true;
      } else if (this.body.domProps.centerContainer.height !== undefined && options.graphHeight !== undefined) {
        if (parseInt((options.graphHeight + '').replace("px", '')) < this.body.domProps.centerContainer.height) {
          this.updateSVGheight = true;
        }
      }
      util.selectiveDeepExtend(fields, this.options, options);
      util.mergeOptions(this.options, options, 'interpolation');
      util.mergeOptions(this.options, options, 'drawPoints');
      util.mergeOptions(this.options, options, 'shaded');
      util.mergeOptions(this.options, options, 'legend');

      if (options.interpolation) {
        if (_typeof(options.interpolation) == 'object') {
          if (options.interpolation.parametrization) {
            if (options.interpolation.parametrization == 'uniform') {
              this.options.interpolation.alpha = 0;
            } else if (options.interpolation.parametrization == 'chordal') {
              this.options.interpolation.alpha = 1.0;
            } else {
              this.options.interpolation.parametrization = 'centripetal';
              this.options.interpolation.alpha = 0.5;
            }
          }
        }
      }

      if (this.yAxisLeft) {
        if (options.dataAxis !== undefined) {
          this.yAxisLeft.setOptions(this.options.dataAxis);
          this.yAxisRight.setOptions(this.options.dataAxis);
        }
      }

      if (this.legendLeft) {
        if (options.legend !== undefined) {
          this.legendLeft.setOptions(this.options.legend);
          this.legendRight.setOptions(this.options.legend);
        }
      }

      if (this.groups.hasOwnProperty(UNGROUPED)) {
        this.groups[UNGROUPED].setOptions(options);
      }
    }

    // this is used to redraw the graph if the visibility of the groups is changed.
    if (this.dom.frame) {
      //not on initial run?
      this.forceGraphUpdate = true;
      this.body.emitter.emit("_change", { queue: true });
    }
  };

  /**
   * Hide the component from the DOM
   */
  LineGraph.prototype.hide = function () {
    // remove the frame containing the items
    if (this.dom.frame.parentNode) {
      this.dom.frame.parentNode.removeChild(this.dom.frame);
    }
  };

  /**
   * Show the component in the DOM (when not already visible).
   * @return {Boolean} changed
   */
  LineGraph.prototype.show = function () {
    // show frame containing the items
    if (!this.dom.frame.parentNode) {
      this.body.dom.center.appendChild(this.dom.frame);
    }
  };

  /**
   * Set items
   * @param {vis.DataSet | null} items
   */
  LineGraph.prototype.setItems = function (items) {
    var me = this,
        ids,
        oldItemsData = this.itemsData;

    // replace the dataset
    if (!items) {
      this.itemsData = null;
    } else if (items instanceof DataSet || items instanceof DataView) {
      this.itemsData = items;
    } else {
      throw new TypeError('Data must be an instance of DataSet or DataView');
    }

    if (oldItemsData) {
      // unsubscribe from old dataset
      util.forEach(this.itemListeners, function (callback, event) {
        oldItemsData.off(event, callback);
      });

      // remove all drawn items
      ids = oldItemsData.getIds();
      this._onRemove(ids);
    }

    if (this.itemsData) {
      // subscribe to new dataset
      var id = this.id;
      util.forEach(this.itemListeners, function (callback, event) {
        me.itemsData.on(event, callback, id);
      });

      // add all new items
      ids = this.itemsData.getIds();
      this._onAdd(ids);
    }
  };

  /**
   * Set groups
   * @param {vis.DataSet} groups
   */
  LineGraph.prototype.setGroups = function (groups) {
    var me = this;
    var ids;

    // unsubscribe from current dataset
    if (this.groupsData) {
      util.forEach(this.groupListeners, function (callback, event) {
        me.groupsData.off(event, callback);
      });

      // remove all drawn groups
      ids = this.groupsData.getIds();
      this.groupsData = null;
      for (var i = 0; i < ids.length; i++) {
        this._removeGroup(ids[i]);
      }
    }

    // replace the dataset
    if (!groups) {
      this.groupsData = null;
    } else if (groups instanceof DataSet || groups instanceof DataView) {
      this.groupsData = groups;
    } else {
      throw new TypeError('Data must be an instance of DataSet or DataView');
    }

    if (this.groupsData) {
      // subscribe to new dataset
      var id = this.id;
      util.forEach(this.groupListeners, function (callback, event) {
        me.groupsData.on(event, callback, id);
      });

      // draw all ms
      ids = this.groupsData.getIds();
      this._onAddGroups(ids);
    }
  };

  LineGraph.prototype._onUpdate = function (ids) {
    this._updateAllGroupData();
  };
  LineGraph.prototype._onAdd = function (ids) {
    this._onUpdate(ids);
  };
  LineGraph.prototype._onRemove = function (ids) {
    this._onUpdate(ids);
  };
  LineGraph.prototype._onUpdateGroups = function (groupIds) {
    this._updateAllGroupData();
  };
  LineGraph.prototype._onAddGroups = function (groupIds) {
    this._onUpdateGroups(groupIds);
  };

  /**
   * this cleans the group out off the legends and the dataaxis, updates the ungrouped and updates the graph
   * @param {Array} groupIds
   * @private
   */
  LineGraph.prototype._onRemoveGroups = function (groupIds) {
    for (var i = 0; i < groupIds.length; i++) {
      this._removeGroup(groupIds[i]);
    }
    this.forceGraphUpdate = true;
    this.body.emitter.emit("_change", { queue: true });
  };

  /**
   * this cleans the group out off the legends and the dataaxis
   * @param groupId
   * @private
   */
  LineGraph.prototype._removeGroup = function (groupId) {
    if (this.groups.hasOwnProperty(groupId)) {
      if (this.groups[groupId].options.yAxisOrientation == 'right') {
        this.yAxisRight.removeGroup(groupId);
        this.legendRight.removeGroup(groupId);
        this.legendRight.redraw();
      } else {
        this.yAxisLeft.removeGroup(groupId);
        this.legendLeft.removeGroup(groupId);
        this.legendLeft.redraw();
      }
      delete this.groups[groupId];
    }
  };

  /**
   * update a group object with the group dataset entree
   *
   * @param group
   * @param groupId
   * @private
   */
  LineGraph.prototype._updateGroup = function (group, groupId) {
    if (!this.groups.hasOwnProperty(groupId)) {
      this.groups[groupId] = new GraphGroup(group, groupId, this.options, this.groupsUsingDefaultStyles);
      if (this.groups[groupId].options.yAxisOrientation == 'right') {
        this.yAxisRight.addGroup(groupId, this.groups[groupId]);
        this.legendRight.addGroup(groupId, this.groups[groupId]);
      } else {
        this.yAxisLeft.addGroup(groupId, this.groups[groupId]);
        this.legendLeft.addGroup(groupId, this.groups[groupId]);
      }
    } else {
      this.groups[groupId].update(group);
      if (this.groups[groupId].options.yAxisOrientation == 'right') {
        this.yAxisRight.updateGroup(groupId, this.groups[groupId]);
        this.legendRight.updateGroup(groupId, this.groups[groupId]);
        //If yAxisOrientation changed, clean out the group from the other axis.
        this.yAxisLeft.removeGroup(groupId);
        this.legendLeft.removeGroup(groupId);
      } else {
        this.yAxisLeft.updateGroup(groupId, this.groups[groupId]);
        this.legendLeft.updateGroup(groupId, this.groups[groupId]);
        //If yAxisOrientation changed, clean out the group from the other axis.
        this.yAxisRight.removeGroup(groupId);
        this.legendRight.removeGroup(groupId);
      }
    }
    this.legendLeft.redraw();
    this.legendRight.redraw();
  };

  /**
   * this updates all groups, it is used when there is an update the the itemset.
   *
   * @private
   */
  LineGraph.prototype._updateAllGroupData = function () {
    if (this.itemsData != null) {
      var groupsContent = {};
      var items = this.itemsData.get();
      //pre-Determine array sizes, for more efficient memory claim
      var groupCounts = {};
      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        var groupId = item.group;
        if (groupId === null || groupId === undefined) {
          groupId = UNGROUPED;
        }
        groupCounts.hasOwnProperty(groupId) ? groupCounts[groupId]++ : groupCounts[groupId] = 1;
      }
      //Now insert data into the arrays.
      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        var groupId = item.group;
        if (groupId === null || groupId === undefined) {
          groupId = UNGROUPED;
        }
        if (!groupsContent.hasOwnProperty(groupId)) {
          groupsContent[groupId] = new Array(groupCounts[groupId]);
        }
        //Copy data (because of unmodifiable DataView input.
        var extended = util.bridgeObject(item);
        extended.x = util.convert(item.x, 'Date');
        extended.orginalY = item.y; //real Y
        extended.y = Number(item.y);

        var index = groupsContent[groupId].length - groupCounts[groupId]--;
        groupsContent[groupId][index] = extended;
      }

      //Make sure all groups are present, to allow removal of old groups
      for (var groupId in this.groups) {
        if (this.groups.hasOwnProperty(groupId)) {
          if (!groupsContent.hasOwnProperty(groupId)) {
            groupsContent[groupId] = new Array(0);
          }
        }
      }

      //Update legendas, style and axis
      for (var groupId in groupsContent) {
        if (groupsContent.hasOwnProperty(groupId)) {
          if (groupsContent[groupId].length == 0) {
            if (this.groups.hasOwnProperty(groupId)) {
              this._removeGroup(groupId);
            }
          } else {
            var group = undefined;
            if (this.groupsData != undefined) {
              group = this.groupsData.get(groupId);
            }
            if (group == undefined) {
              group = { id: groupId, content: this.options.defaultGroup + groupId };
            }
            this._updateGroup(group, groupId);
            this.groups[groupId].setItems(groupsContent[groupId]);
          }
        }
      }
      this.forceGraphUpdate = true;
      this.body.emitter.emit("_change", { queue: true });
    }
  };

  /**
   * Redraw the component, mandatory function
   * @return {boolean} Returns true if the component is resized
   */
  LineGraph.prototype.redraw = function () {
    var resized = false;

    // calculate actual size and position
    this.props.width = this.dom.frame.offsetWidth;
    this.props.height = this.body.domProps.centerContainer.height - this.body.domProps.border.top - this.body.domProps.border.bottom;

    // check if this component is resized
    resized = this._isResized() || resized;

    // check whether zoomed (in that case we need to re-stack everything)
    var visibleInterval = this.body.range.end - this.body.range.start;
    var zoomed = visibleInterval != this.lastVisibleInterval;
    this.lastVisibleInterval = visibleInterval;

    // the svg element is three times as big as the width, this allows for fully dragging left and right
    // without reloading the graph. the controls for this are bound to events in the constructor
    if (resized == true) {
      this.svg.style.width = util.option.asSize(3 * this.props.width);
      this.svg.style.left = util.option.asSize(-this.props.width);

      // if the height of the graph is set as proportional, change the height of the svg
      if ((this.options.height + '').indexOf("%") != -1 || this.updateSVGheightOnResize == true) {
        this.updateSVGheight = true;
      }
    }

    // update the height of the graph on each redraw of the graph.
    if (this.updateSVGheight == true) {
      if (this.options.graphHeight != this.props.height + 'px') {
        this.options.graphHeight = this.props.height + 'px';
        this.svg.style.height = this.props.height + 'px';
      }
      this.updateSVGheight = false;
    } else {
      this.svg.style.height = ('' + this.options.graphHeight).replace('px', '') + 'px';
    }

    // zoomed is here to ensure that animations are shown correctly.
    if (resized == true || zoomed == true || this.abortedGraphUpdate == true || this.forceGraphUpdate == true) {
      resized = this._updateGraph() || resized;
      this.forceGraphUpdate = false;
    } else {
      // move the whole svg while dragging
      if (this.lastStart != 0) {
        var offset = this.body.range.start - this.lastStart;
        var range = this.body.range.end - this.body.range.start;
        if (this.props.width != 0) {
          var rangePerPixelInv = this.props.width / range;
          var xOffset = offset * rangePerPixelInv;
          this.svg.style.left = -this.props.width - xOffset + 'px';
        }
      }
    }
    this.legendLeft.redraw();
    this.legendRight.redraw();
    return resized;
  };

  LineGraph.prototype._getSortedGroupIds = function () {
    // getting group Ids
    var grouplist = [];
    for (var groupId in this.groups) {
      if (this.groups.hasOwnProperty(groupId)) {
        var group = this.groups[groupId];
        if (group.visible == true && (this.options.groups.visibility[groupId] === undefined || this.options.groups.visibility[groupId] == true)) {
          grouplist.push({ id: groupId, zIndex: group.options.zIndex });
        }
      }
    }
    util.insertSort(grouplist, function (a, b) {
      var az = a.zIndex;
      var bz = b.zIndex;
      if (az === undefined) az = 0;
      if (bz === undefined) bz = 0;
      return az == bz ? 0 : az < bz ? -1 : 1;
    });
    var groupIds = new Array(grouplist.length);
    for (var i = 0; i < grouplist.length; i++) {
      groupIds[i] = grouplist[i].id;
    }
    return groupIds;
  };

  /**
   * Update and redraw the graph.
   *
   */
  LineGraph.prototype._updateGraph = function () {
    // reset the svg elements
    DOMutil.prepareElements(this.svgElements);
    if (this.props.width != 0 && this.itemsData != null) {
      var group, i;
      var groupRanges = {};
      var changeCalled = false;
      // this is the range of the SVG canvas
      var minDate = this.body.util.toGlobalTime(-this.body.domProps.root.width);
      var maxDate = this.body.util.toGlobalTime(2 * this.body.domProps.root.width);

      // getting group Ids
      var groupIds = this._getSortedGroupIds();
      if (groupIds.length > 0) {
        var groupsData = {};

        // fill groups data, this only loads the data we require based on the timewindow
        this._getRelevantData(groupIds, groupsData, minDate, maxDate);

        // apply sampling, if disabled, it will pass through this function.
        this._applySampling(groupIds, groupsData);

        // we transform the X coordinates to detect collisions
        for (i = 0; i < groupIds.length; i++) {
          this._convertXcoordinates(groupsData[groupIds[i]]);
        }

        // now all needed data has been collected we start the processing.
        this._getYRanges(groupIds, groupsData, groupRanges);

        // update the Y axis first, we use this data to draw at the correct Y points
        changeCalled = this._updateYAxis(groupIds, groupRanges);

        //  at changeCalled, abort this update cycle as the graph needs another update with new Width input from the Redraw container.
        //  Cleanup SVG elements on abort.
        if (changeCalled == true) {
          DOMutil.cleanupElements(this.svgElements);
          this.abortedGraphUpdate = true;
          return true;
        }
        this.abortedGraphUpdate = false;

        // With the yAxis scaled correctly, use this to get the Y values of the points.
        var below = undefined;
        for (i = 0; i < groupIds.length; i++) {
          group = this.groups[groupIds[i]];
          if (this.options.stack === true && this.options.style === 'line') {
            if (group.options.excludeFromStacking == undefined || !group.options.excludeFromStacking) {
              if (below != undefined) {
                this._stack(groupsData[group.id], groupsData[below.id]);
                if (group.options.shaded.enabled == true && group.options.shaded.orientation !== "group") {
                  if (group.options.shaded.orientation == "top" && below.options.shaded.orientation !== "group") {
                    below.options.shaded.orientation = "group";
                    below.options.shaded.groupId = group.id;
                  } else {
                    group.options.shaded.orientation = "group";
                    group.options.shaded.groupId = below.id;
                  }
                }
              }
              below = group;
            }
          }
          this._convertYcoordinates(groupsData[groupIds[i]], group);
        }

        //Precalculate paths and draw shading if appropriate. This will make sure the shading is always behind any lines.
        var paths = {};
        for (i = 0; i < groupIds.length; i++) {
          group = this.groups[groupIds[i]];
          if (group.options.style === 'line' && group.options.shaded.enabled == true) {
            var dataset = groupsData[groupIds[i]];
            if (dataset == null || dataset.length == 0) {
              continue;
            }
            if (!paths.hasOwnProperty(groupIds[i])) {
              paths[groupIds[i]] = Lines.calcPath(dataset, group);
            }
            if (group.options.shaded.orientation === "group") {
              var subGroupId = group.options.shaded.groupId;
              if (groupIds.indexOf(subGroupId) === -1) {
                console.log(group.id + ": Unknown shading group target given:" + subGroupId);
                continue;
              }
              if (!paths.hasOwnProperty(subGroupId)) {
                paths[subGroupId] = Lines.calcPath(groupsData[subGroupId], this.groups[subGroupId]);
              }
              Lines.drawShading(paths[groupIds[i]], group, paths[subGroupId], this.framework);
            } else {
              Lines.drawShading(paths[groupIds[i]], group, undefined, this.framework);
            }
          }
        }

        // draw the groups, calculating paths if still necessary.
        Bars.draw(groupIds, groupsData, this.framework);
        for (i = 0; i < groupIds.length; i++) {
          group = this.groups[groupIds[i]];
          if (groupsData[groupIds[i]].length > 0) {
            switch (group.options.style) {
              case "line":
                if (!paths.hasOwnProperty(groupIds[i])) {
                  paths[groupIds[i]] = Lines.calcPath(groupsData[groupIds[i]], group);
                }
                Lines.draw(paths[groupIds[i]], group, this.framework);
              //explicit no break;
              case "point":
              //explicit no break;
              case "points":
                if (group.options.style == "point" || group.options.style == "points" || group.options.drawPoints.enabled == true) {
                  Points.draw(groupsData[groupIds[i]], group, this.framework);
                }
                break;
              case "bar":
              // bar needs to be drawn enmasse
              //explicit no break
              default:
              //do nothing...
            }
          }
        }
      }
    }

    // cleanup unused svg elements
    DOMutil.cleanupElements(this.svgElements);
    return false;
  };

  LineGraph.prototype._stack = function (data, subData) {
    var index, dx, dy, subPrevPoint, subNextPoint;
    index = 0;
    // for each data point we look for a matching on in the set below
    for (var j = 0; j < data.length; j++) {
      subPrevPoint = undefined;
      subNextPoint = undefined;
      // we look for time matches or a before-after point
      for (var k = index; k < subData.length; k++) {
        // if times match exactly
        if (subData[k].x === data[j].x) {
          subPrevPoint = subData[k];
          subNextPoint = subData[k];
          index = k;
          break;
        } else if (subData[k].x > data[j].x) {
          // overshoot
          subNextPoint = subData[k];
          if (k == 0) {
            subPrevPoint = subNextPoint;
          } else {
            subPrevPoint = subData[k - 1];
          }
          index = k;
          break;
        }
      }
      // in case the last data point has been used, we assume it stays like this.
      if (subNextPoint === undefined) {
        subPrevPoint = subData[subData.length - 1];
        subNextPoint = subData[subData.length - 1];
      }
      // linear interpolation
      dx = subNextPoint.x - subPrevPoint.x;
      dy = subNextPoint.y - subPrevPoint.y;
      if (dx == 0) {
        data[j].y = data[j].orginalY + subNextPoint.y;
      } else {
        data[j].y = data[j].orginalY + dy / dx * (data[j].x - subPrevPoint.x) + subPrevPoint.y; // ax + b where b is data[j].y
      }
    }
  };

  /**
   * first select and preprocess the data from the datasets.
   * the groups have their preselection of data, we now loop over this data to see
   * what data we need to draw. Sorted data is much faster.
   * more optimization is possible by doing the sampling before and using the binary search
   * to find the end date to determine the increment.
   *
   * @param {array}  groupIds
   * @param {object} groupsData
   * @param {date}   minDate
   * @param {date}   maxDate
   * @private
   */
  LineGraph.prototype._getRelevantData = function (groupIds, groupsData, minDate, maxDate) {
    var group, i, j, item;
    if (groupIds.length > 0) {
      for (i = 0; i < groupIds.length; i++) {
        group = this.groups[groupIds[i]];
        var itemsData = group.getItems();
        // optimization for sorted data
        if (group.options.sort == true) {
          var dateComparator = function dateComparator(a, b) {
            return a.getTime() == b.getTime() ? 0 : a < b ? -1 : 1;
          };
          var first = Math.max(0, util.binarySearchValue(itemsData, minDate, 'x', 'before', dateComparator));
          var last = Math.min(itemsData.length, util.binarySearchValue(itemsData, maxDate, 'x', 'after', dateComparator) + 1);
          if (last <= 0) {
            last = itemsData.length;
          }
          var dataContainer = new Array(last - first);
          for (j = first; j < last; j++) {
            item = group.itemsData[j];
            dataContainer[j - first] = item;
          }
          groupsData[groupIds[i]] = dataContainer;
        } else {
          // If unsorted data, all data is relevant, just returning entire structure
          groupsData[groupIds[i]] = group.itemsData;
        }
      }
    }
  };

  /**
   *
   * @param groupIds
   * @param groupsData
   * @private
   */
  LineGraph.prototype._applySampling = function (groupIds, groupsData) {
    var group;
    if (groupIds.length > 0) {
      for (var i = 0; i < groupIds.length; i++) {
        group = this.groups[groupIds[i]];
        if (group.options.sampling == true) {
          var dataContainer = groupsData[groupIds[i]];
          if (dataContainer.length > 0) {
            var increment = 1;
            var amountOfPoints = dataContainer.length;

            // the global screen is used because changing the width of the yAxis may affect the increment, resulting in an endless loop
            // of width changing of the yAxis.
            var xDistance = this.body.util.toGlobalScreen(dataContainer[dataContainer.length - 1].x) - this.body.util.toGlobalScreen(dataContainer[0].x);
            var pointsPerPixel = amountOfPoints / xDistance;
            increment = Math.min(Math.ceil(0.2 * amountOfPoints), Math.max(1, Math.round(pointsPerPixel)));

            var sampledData = new Array(amountOfPoints);
            for (var j = 0; j < amountOfPoints; j += increment) {
              var idx = Math.round(j / increment);
              sampledData[idx] = dataContainer[j];
            }
            groupsData[groupIds[i]] = sampledData.splice(0, Math.round(amountOfPoints / increment));
          }
        }
      }
    }
  };

  /**
   *
   *
   * @param {array}  groupIds
   * @param {object} groupsData
   * @param {object} groupRanges  | this is being filled here
   * @private
   */
  LineGraph.prototype._getYRanges = function (groupIds, groupsData, groupRanges) {
    var groupData, group, i;
    var combinedDataLeft = [];
    var combinedDataRight = [];
    var options;
    if (groupIds.length > 0) {
      for (i = 0; i < groupIds.length; i++) {
        groupData = groupsData[groupIds[i]];
        options = this.groups[groupIds[i]].options;
        if (groupData.length > 0) {
          group = this.groups[groupIds[i]];
          // if bar graphs are stacked, their range need to be handled differently and accumulated over all groups.
          if (options.stack === true && options.style === 'bar') {
            if (options.yAxisOrientation === 'left') {
              combinedDataLeft = combinedDataLeft.concat(group.getItems());
            } else {
              combinedDataRight = combinedDataRight.concat(group.getItems());
            }
          } else {
            groupRanges[groupIds[i]] = group.getYRange(groupData, groupIds[i]);
          }
        }
      }

      // if bar graphs are stacked, their range need to be handled differently and accumulated over all groups.
      Bars.getStackedYRange(combinedDataLeft, groupRanges, groupIds, '__barStackLeft', 'left');
      Bars.getStackedYRange(combinedDataRight, groupRanges, groupIds, '__barStackRight', 'right');
    }
  };

  /**
   * this sets the Y ranges for the Y axis. It also determines which of the axis should be shown or hidden.
   * @param {Array} groupIds
   * @param {Object} groupRanges
   * @private
   */
  LineGraph.prototype._updateYAxis = function (groupIds, groupRanges) {
    var resized = false;
    var yAxisLeftUsed = false;
    var yAxisRightUsed = false;
    var minLeft = 1e9,
        minRight = 1e9,
        maxLeft = -1e9,
        maxRight = -1e9,
        minVal,
        maxVal;
    // if groups are present
    if (groupIds.length > 0) {
      // this is here to make sure that if there are no items in the axis but there are groups, that there is no infinite draw/redraw loop.
      for (var i = 0; i < groupIds.length; i++) {
        var group = this.groups[groupIds[i]];
        if (group && group.options.yAxisOrientation != 'right') {
          yAxisLeftUsed = true;
          minLeft = 1e9;
          maxLeft = -1e9;
        } else if (group && group.options.yAxisOrientation) {
          yAxisRightUsed = true;
          minRight = 1e9;
          maxRight = -1e9;
        }
      }

      // if there are items:
      for (var i = 0; i < groupIds.length; i++) {
        if (groupRanges.hasOwnProperty(groupIds[i])) {
          if (groupRanges[groupIds[i]].ignore !== true) {
            minVal = groupRanges[groupIds[i]].min;
            maxVal = groupRanges[groupIds[i]].max;

            if (groupRanges[groupIds[i]].yAxisOrientation != 'right') {
              yAxisLeftUsed = true;
              minLeft = minLeft > minVal ? minVal : minLeft;
              maxLeft = maxLeft < maxVal ? maxVal : maxLeft;
            } else {
              yAxisRightUsed = true;
              minRight = minRight > minVal ? minVal : minRight;
              maxRight = maxRight < maxVal ? maxVal : maxRight;
            }
          }
        }
      }

      if (yAxisLeftUsed == true) {
        this.yAxisLeft.setRange(minLeft, maxLeft);
      }
      if (yAxisRightUsed == true) {
        this.yAxisRight.setRange(minRight, maxRight);
      }
    }
    resized = this._toggleAxisVisiblity(yAxisLeftUsed, this.yAxisLeft) || resized;
    resized = this._toggleAxisVisiblity(yAxisRightUsed, this.yAxisRight) || resized;

    if (yAxisRightUsed == true && yAxisLeftUsed == true) {
      this.yAxisLeft.drawIcons = true;
      this.yAxisRight.drawIcons = true;
    } else {
      this.yAxisLeft.drawIcons = false;
      this.yAxisRight.drawIcons = false;
    }
    this.yAxisRight.master = !yAxisLeftUsed;
    this.yAxisRight.masterAxis = this.yAxisLeft;

    if (this.yAxisRight.master == false) {
      if (yAxisRightUsed == true) {
        this.yAxisLeft.lineOffset = this.yAxisRight.width;
      } else {
        this.yAxisLeft.lineOffset = 0;
      }

      resized = this.yAxisLeft.redraw() || resized;
      resized = this.yAxisRight.redraw() || resized;
    } else {
      resized = this.yAxisRight.redraw() || resized;
    }

    // clean the accumulated lists
    var tempGroups = ['__barStackLeft', '__barStackRight', '__lineStackLeft', '__lineStackRight'];
    for (var i = 0; i < tempGroups.length; i++) {
      if (groupIds.indexOf(tempGroups[i]) != -1) {
        groupIds.splice(groupIds.indexOf(tempGroups[i]), 1);
      }
    }

    return resized;
  };

  /**
   * This shows or hides the Y axis if needed. If there is a change, the changed event is emitted by the updateYAxis function
   *
   * @param {boolean} axisUsed
   * @returns {boolean}
   * @private
   * @param axis
   */
  LineGraph.prototype._toggleAxisVisiblity = function (axisUsed, axis) {
    var changed = false;
    if (axisUsed == false) {
      if (axis.dom.frame.parentNode && axis.hidden == false) {
        axis.hide();
        changed = true;
      }
    } else {
      if (!axis.dom.frame.parentNode && axis.hidden == true) {
        axis.show();
        changed = true;
      }
    }
    return changed;
  };

  /**
   * This uses the DataAxis object to generate the correct X coordinate on the SVG window. It uses the
   * util function toScreen to get the x coordinate from the timestamp. It also pre-filters the data and get the minMax ranges for
   * the yAxis.
   *
   * @param datapoints
   * @returns {Array}
   * @private
   */
  LineGraph.prototype._convertXcoordinates = function (datapoints) {
    var toScreen = this.body.util.toScreen;
    for (var i = 0; i < datapoints.length; i++) {
      datapoints[i].screen_x = toScreen(datapoints[i].x) + this.props.width;
      datapoints[i].screen_y = datapoints[i].y; //starting point for range calculations
    }
  };

  /**
   * This uses the DataAxis object to generate the correct X coordinate on the SVG window. It uses the
   * util function toScreen to get the x coordinate from the timestamp. It also pre-filters the data and get the minMax ranges for
   * the yAxis.
   *
   * @param datapoints
   * @param group
   * @returns {Array}
   * @private
   */
  LineGraph.prototype._convertYcoordinates = function (datapoints, group) {
    var axis = this.yAxisLeft;
    var svgHeight = Number(this.svg.style.height.replace('px', ''));
    if (group.options.yAxisOrientation == 'right') {
      axis = this.yAxisRight;
    }
    for (var i = 0; i < datapoints.length; i++) {
      datapoints[i].screen_y = Math.round(axis.convertValue(datapoints[i].y));
    }
    group.setZeroPosition(Math.min(svgHeight, axis.convertValue(0)));
  };

  module.exports = LineGraph;

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);
  var DOMutil = __webpack_require__(8);
  var Component = __webpack_require__(33);
  var DataScale = __webpack_require__(55);
  /**
   * A horizontal time axis
   * @param {Object} [options]        See DataAxis.setOptions for the available
   *                                  options.
   * @constructor DataAxis
   * @extends Component
   * @param body
   */
  function DataAxis(body, options, svg, linegraphOptions) {
    this.id = util.randomUUID();
    this.body = body;

    this.defaultOptions = {
      orientation: 'left', // supported: 'left', 'right'
      showMinorLabels: true,
      showMajorLabels: true,
      icons: false,
      majorLinesOffset: 7,
      minorLinesOffset: 4,
      labelOffsetX: 10,
      labelOffsetY: 2,
      iconWidth: 20,
      width: '40px',
      visible: true,
      alignZeros: true,
      left: {
        range: { min: undefined, max: undefined },
        format: function format(value) {
          return '' + parseFloat(value.toPrecision(3));
        },
        title: { text: undefined, style: undefined }
      },
      right: {
        range: { min: undefined, max: undefined },
        format: function format(value) {
          return '' + parseFloat(value.toPrecision(3));
        },
        title: { text: undefined, style: undefined }
      }
    };

    this.linegraphOptions = linegraphOptions;
    this.linegraphSVG = svg;
    this.props = {};
    this.DOMelements = { // dynamic elements
      lines: {},
      labels: {},
      title: {}
    };

    this.dom = {};
    this.scale = undefined;
    this.range = { start: 0, end: 0 };

    this.options = util.extend({}, this.defaultOptions);
    this.conversionFactor = 1;

    this.setOptions(options);
    this.width = Number(('' + this.options.width).replace("px", ""));
    this.minWidth = this.width;
    this.height = this.linegraphSVG.getBoundingClientRect().height;
    this.hidden = false;

    this.stepPixels = 25;
    this.zeroCrossing = -1;
    this.amountOfSteps = -1;

    this.lineOffset = 0;
    this.master = true;
    this.masterAxis = null;
    this.svgElements = {};
    this.iconsRemoved = false;

    this.groups = {};
    this.amountOfGroups = 0;

    // create the HTML DOM
    this._create();
    this.framework = { svg: this.svg, svgElements: this.svgElements, options: this.options, groups: this.groups };

    var me = this;
    this.body.emitter.on("verticalDrag", function () {
      me.dom.lineContainer.style.top = me.body.domProps.scrollTop + 'px';
    });
  }

  DataAxis.prototype = new Component();

  DataAxis.prototype.addGroup = function (label, graphOptions) {
    if (!this.groups.hasOwnProperty(label)) {
      this.groups[label] = graphOptions;
    }
    this.amountOfGroups += 1;
  };

  DataAxis.prototype.updateGroup = function (label, graphOptions) {
    if (!this.groups.hasOwnProperty(label)) {
      this.amountOfGroups += 1;
    }
    this.groups[label] = graphOptions;
  };

  DataAxis.prototype.removeGroup = function (label) {
    if (this.groups.hasOwnProperty(label)) {
      delete this.groups[label];
      this.amountOfGroups -= 1;
    }
  };

  DataAxis.prototype.setOptions = function (options) {
    if (options) {
      var redraw = false;
      if (this.options.orientation != options.orientation && options.orientation !== undefined) {
        redraw = true;
      }
      var fields = ['orientation', 'showMinorLabels', 'showMajorLabels', 'icons', 'majorLinesOffset', 'minorLinesOffset', 'labelOffsetX', 'labelOffsetY', 'iconWidth', 'width', 'visible', 'left', 'right', 'alignZeros'];
      util.selectiveDeepExtend(fields, this.options, options);

      this.minWidth = Number(('' + this.options.width).replace("px", ""));
      if (redraw === true && this.dom.frame) {
        this.hide();
        this.show();
      }
    }
  };

  /**
   * Create the HTML DOM for the DataAxis
   */
  DataAxis.prototype._create = function () {
    this.dom.frame = document.createElement('div');
    this.dom.frame.style.width = this.options.width;
    this.dom.frame.style.height = this.height;

    this.dom.lineContainer = document.createElement('div');
    this.dom.lineContainer.style.width = '100%';
    this.dom.lineContainer.style.height = this.height;
    this.dom.lineContainer.style.position = 'relative';

    // create svg element for graph drawing.
    this.svg = document.createElementNS('http://www.w3.org/2000/svg', "svg");
    this.svg.style.position = "absolute";
    this.svg.style.top = '0px';
    this.svg.style.height = '100%';
    this.svg.style.width = '100%';
    this.svg.style.display = "block";
    this.dom.frame.appendChild(this.svg);
  };

  DataAxis.prototype._redrawGroupIcons = function () {
    DOMutil.prepareElements(this.svgElements);

    var x;
    var iconWidth = this.options.iconWidth;
    var iconHeight = 15;
    var iconOffset = 4;
    var y = iconOffset + 0.5 * iconHeight;

    if (this.options.orientation === 'left') {
      x = iconOffset;
    } else {
      x = this.width - iconWidth - iconOffset;
    }

    var groupArray = Object.keys(this.groups);
    groupArray.sort(function (a, b) {
      return a < b ? -1 : 1;
    });

    for (var i = 0; i < groupArray.length; i++) {
      var groupId = groupArray[i];
      if (this.groups[groupId].visible === true && (this.linegraphOptions.visibility[groupId] === undefined || this.linegraphOptions.visibility[groupId] === true)) {
        this.groups[groupId].getLegend(iconWidth, iconHeight, this.framework, x, y);
        y += iconHeight + iconOffset;
      }
    }

    DOMutil.cleanupElements(this.svgElements);
    this.iconsRemoved = false;
  };

  DataAxis.prototype._cleanupIcons = function () {
    if (this.iconsRemoved === false) {
      DOMutil.prepareElements(this.svgElements);
      DOMutil.cleanupElements(this.svgElements);
      this.iconsRemoved = true;
    }
  };

  /**
   * Create the HTML DOM for the DataAxis
   */
  DataAxis.prototype.show = function () {
    this.hidden = false;
    if (!this.dom.frame.parentNode) {
      if (this.options.orientation === 'left') {
        this.body.dom.left.appendChild(this.dom.frame);
      } else {
        this.body.dom.right.appendChild(this.dom.frame);
      }
    }

    if (!this.dom.lineContainer.parentNode) {
      this.body.dom.backgroundHorizontal.appendChild(this.dom.lineContainer);
    }
  };

  /**
   * Create the HTML DOM for the DataAxis
   */
  DataAxis.prototype.hide = function () {
    this.hidden = true;
    if (this.dom.frame.parentNode) {
      this.dom.frame.parentNode.removeChild(this.dom.frame);
    }

    if (this.dom.lineContainer.parentNode) {
      this.dom.lineContainer.parentNode.removeChild(this.dom.lineContainer);
    }
  };

  /**
   * Set a range (start and end)
   * @param end
   * @param start
   * @param end
   */
  DataAxis.prototype.setRange = function (start, end) {
    this.range.start = start;
    this.range.end = end;
  };

  /**
   * Repaint the component
   * @return {boolean} Returns true if the component is resized
   */
  DataAxis.prototype.redraw = function () {
    var resized = false;
    var activeGroups = 0;

    // Make sure the line container adheres to the vertical scrolling.
    this.dom.lineContainer.style.top = this.body.domProps.scrollTop + 'px';

    for (var groupId in this.groups) {
      if (this.groups.hasOwnProperty(groupId)) {
        if (this.groups[groupId].visible === true && (this.linegraphOptions.visibility[groupId] === undefined || this.linegraphOptions.visibility[groupId] === true)) {
          activeGroups++;
        }
      }
    }
    if (this.amountOfGroups === 0 || activeGroups === 0) {
      this.hide();
    } else {
      this.show();
      this.height = Number(this.linegraphSVG.style.height.replace("px", ""));

      // svg offsetheight did not work in firefox and explorer...
      this.dom.lineContainer.style.height = this.height + 'px';
      this.width = this.options.visible === true ? Number(('' + this.options.width).replace("px", "")) : 0;

      var props = this.props;
      var frame = this.dom.frame;

      // update classname
      frame.className = 'vis-data-axis';

      // calculate character width and height
      this._calculateCharSize();

      var orientation = this.options.orientation;
      var showMinorLabels = this.options.showMinorLabels;
      var showMajorLabels = this.options.showMajorLabels;

      // determine the width and height of the elements for the axis
      props.minorLabelHeight = showMinorLabels ? props.minorCharHeight : 0;
      props.majorLabelHeight = showMajorLabels ? props.majorCharHeight : 0;

      props.minorLineWidth = this.body.dom.backgroundHorizontal.offsetWidth - this.lineOffset - this.width + 2 * this.options.minorLinesOffset;
      props.minorLineHeight = 1;
      props.majorLineWidth = this.body.dom.backgroundHorizontal.offsetWidth - this.lineOffset - this.width + 2 * this.options.majorLinesOffset;
      props.majorLineHeight = 1;

      //  take frame offline while updating (is almost twice as fast)
      if (orientation === 'left') {
        frame.style.top = '0';
        frame.style.left = '0';
        frame.style.bottom = '';
        frame.style.width = this.width + 'px';
        frame.style.height = this.height + "px";
        this.props.width = this.body.domProps.left.width;
        this.props.height = this.body.domProps.left.height;
      } else {
        // right
        frame.style.top = '';
        frame.style.bottom = '0';
        frame.style.left = '0';
        frame.style.width = this.width + 'px';
        frame.style.height = this.height + "px";
        this.props.width = this.body.domProps.right.width;
        this.props.height = this.body.domProps.right.height;
      }

      resized = this._redrawLabels();
      resized = this._isResized() || resized;

      if (this.options.icons === true) {
        this._redrawGroupIcons();
      } else {
        this._cleanupIcons();
      }

      this._redrawTitle(orientation);
    }
    return resized;
  };

  /**
   * Repaint major and minor text labels and vertical grid lines
   * @private
   */
  DataAxis.prototype._redrawLabels = function () {
    var _this = this;

    var resized = false;
    DOMutil.prepareElements(this.DOMelements.lines);
    DOMutil.prepareElements(this.DOMelements.labels);
    var orientation = this.options['orientation'];
    var customRange = this.options[orientation].range != undefined ? this.options[orientation].range : {};

    //Override range with manual options:
    var autoScaleEnd = true;
    if (customRange.max != undefined) {
      this.range.end = customRange.max;
      autoScaleEnd = false;
    }
    var autoScaleStart = true;
    if (customRange.min != undefined) {
      this.range.start = customRange.min;
      autoScaleStart = false;
    }

    this.scale = new DataScale(this.range.start, this.range.end, autoScaleStart, autoScaleEnd, this.dom.frame.offsetHeight, this.props.majorCharHeight, this.options.alignZeros, this.options[orientation].format);

    if (this.master === false && this.masterAxis != undefined) {
      this.scale.followScale(this.masterAxis.scale);
    }

    //Is updated in side-effect of _redrawLabel():
    this.maxLabelSize = 0;

    var lines = this.scale.getLines();
    lines.forEach(function (line) {
      var y = line.y;
      var isMajor = line.major;
      if (_this.options['showMinorLabels'] && isMajor === false) {
        _this._redrawLabel(y - 2, line.val, orientation, 'vis-y-axis vis-minor', _this.props.minorCharHeight);
      }
      if (isMajor) {
        if (y >= 0) {
          _this._redrawLabel(y - 2, line.val, orientation, 'vis-y-axis vis-major', _this.props.majorCharHeight);
        }
      }
      if (_this.master === true) {
        if (isMajor) {
          _this._redrawLine(y, orientation, 'vis-grid vis-horizontal vis-major', _this.options.majorLinesOffset, _this.props.majorLineWidth);
        } else {
          _this._redrawLine(y, orientation, 'vis-grid vis-horizontal vis-minor', _this.options.minorLinesOffset, _this.props.minorLineWidth);
        }
      }
    });

    // Note that title is rotated, so we're using the height, not width!
    var titleWidth = 0;
    if (this.options[orientation].title !== undefined && this.options[orientation].title.text !== undefined) {
      titleWidth = this.props.titleCharHeight;
    }
    var offset = this.options.icons === true ? Math.max(this.options.iconWidth, titleWidth) + this.options.labelOffsetX + 15 : titleWidth + this.options.labelOffsetX + 15;

    // this will resize the yAxis to accommodate the labels.
    if (this.maxLabelSize > this.width - offset && this.options.visible === true) {
      this.width = this.maxLabelSize + offset;
      this.options.width = this.width + "px";
      DOMutil.cleanupElements(this.DOMelements.lines);
      DOMutil.cleanupElements(this.DOMelements.labels);
      this.redraw();
      resized = true;
    }
    // this will resize the yAxis if it is too big for the labels.
    else if (this.maxLabelSize < this.width - offset && this.options.visible === true && this.width > this.minWidth) {
        this.width = Math.max(this.minWidth, this.maxLabelSize + offset);
        this.options.width = this.width + "px";
        DOMutil.cleanupElements(this.DOMelements.lines);
        DOMutil.cleanupElements(this.DOMelements.labels);
        this.redraw();
        resized = true;
      } else {
        DOMutil.cleanupElements(this.DOMelements.lines);
        DOMutil.cleanupElements(this.DOMelements.labels);
        resized = false;
      }

    return resized;
  };

  DataAxis.prototype.convertValue = function (value) {
    return this.scale.convertValue(value);
  };

  DataAxis.prototype.screenToValue = function (x) {
    return this.scale.screenToValue(x);
  };

  /**
   * Create a label for the axis at position x
   * @private
   * @param y
   * @param text
   * @param orientation
   * @param className
   * @param characterHeight
   */
  DataAxis.prototype._redrawLabel = function (y, text, orientation, className, characterHeight) {
    // reuse redundant label
    var label = DOMutil.getDOMElement('div', this.DOMelements.labels, this.dom.frame); //this.dom.redundant.labels.shift();
    label.className = className;
    label.innerHTML = text;
    if (orientation === 'left') {
      label.style.left = '-' + this.options.labelOffsetX + 'px';
      label.style.textAlign = "right";
    } else {
      label.style.right = '-' + this.options.labelOffsetX + 'px';
      label.style.textAlign = "left";
    }

    label.style.top = y - 0.5 * characterHeight + this.options.labelOffsetY + 'px';

    text += '';

    var largestWidth = Math.max(this.props.majorCharWidth, this.props.minorCharWidth);
    if (this.maxLabelSize < text.length * largestWidth) {
      this.maxLabelSize = text.length * largestWidth;
    }
  };

  /**
   * Create a minor line for the axis at position y
   * @param y
   * @param orientation
   * @param className
   * @param offset
   * @param width
   */
  DataAxis.prototype._redrawLine = function (y, orientation, className, offset, width) {
    if (this.master === true) {
      var line = DOMutil.getDOMElement('div', this.DOMelements.lines, this.dom.lineContainer); //this.dom.redundant.lines.shift();
      line.className = className;
      line.innerHTML = '';

      if (orientation === 'left') {
        line.style.left = this.width - offset + 'px';
      } else {
        line.style.right = this.width - offset + 'px';
      }

      line.style.width = width + 'px';
      line.style.top = y + 'px';
    }
  };

  /**
   * Create a title for the axis
   * @private
   * @param orientation
   */
  DataAxis.prototype._redrawTitle = function (orientation) {
    DOMutil.prepareElements(this.DOMelements.title);

    // Check if the title is defined for this axes
    if (this.options[orientation].title !== undefined && this.options[orientation].title.text !== undefined) {
      var title = DOMutil.getDOMElement('div', this.DOMelements.title, this.dom.frame);
      title.className = 'vis-y-axis vis-title vis-' + orientation;
      title.innerHTML = this.options[orientation].title.text;

      // Add style - if provided
      if (this.options[orientation].title.style !== undefined) {
        util.addCssText(title, this.options[orientation].title.style);
      }

      if (orientation === 'left') {
        title.style.left = this.props.titleCharHeight + 'px';
      } else {
        title.style.right = this.props.titleCharHeight + 'px';
      }

      title.style.width = this.height + 'px';
    }

    // we need to clean up in case we did not use all elements.
    DOMutil.cleanupElements(this.DOMelements.title);
  };

  /**
   * Determine the size of text on the axis (both major and minor axis).
   * The size is calculated only once and then cached in this.props.
   * @private
   */
  DataAxis.prototype._calculateCharSize = function () {
    // determine the char width and height on the minor axis
    if (!('minorCharHeight' in this.props)) {
      var textMinor = document.createTextNode('0');
      var measureCharMinor = document.createElement('div');
      measureCharMinor.className = 'vis-y-axis vis-minor vis-measure';
      measureCharMinor.appendChild(textMinor);
      this.dom.frame.appendChild(measureCharMinor);

      this.props.minorCharHeight = measureCharMinor.clientHeight;
      this.props.minorCharWidth = measureCharMinor.clientWidth;

      this.dom.frame.removeChild(measureCharMinor);
    }

    if (!('majorCharHeight' in this.props)) {
      var textMajor = document.createTextNode('0');
      var measureCharMajor = document.createElement('div');
      measureCharMajor.className = 'vis-y-axis vis-major vis-measure';
      measureCharMajor.appendChild(textMajor);
      this.dom.frame.appendChild(measureCharMajor);

      this.props.majorCharHeight = measureCharMajor.clientHeight;
      this.props.majorCharWidth = measureCharMajor.clientWidth;

      this.dom.frame.removeChild(measureCharMajor);
    }

    if (!('titleCharHeight' in this.props)) {
      var textTitle = document.createTextNode('0');
      var measureCharTitle = document.createElement('div');
      measureCharTitle.className = 'vis-y-axis vis-title vis-measure';
      measureCharTitle.appendChild(textTitle);
      this.dom.frame.appendChild(measureCharTitle);

      this.props.titleCharHeight = measureCharTitle.clientHeight;
      this.props.titleCharWidth = measureCharTitle.clientWidth;

      this.dom.frame.removeChild(measureCharTitle);
    }
  };

  module.exports = DataAxis;

/***/ },
/* 55 */
/***/ function(module, exports) {

  'use strict';

  /**
   * Created by ludo on 25-1-16.
   */

  function DataScale(start, end, autoScaleStart, autoScaleEnd, containerHeight, majorCharHeight) {
    var zeroAlign = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
    var formattingFunction = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;

    this.majorSteps = [1, 2, 5, 10];
    this.minorSteps = [0.25, 0.5, 1, 2];
    this.customLines = null;

    this.containerHeight = containerHeight;
    this.majorCharHeight = majorCharHeight;
    this._start = start;
    this._end = end;

    this.scale = 1;
    this.minorStepIdx = -1;
    this.magnitudefactor = 1;
    this.determineScale();

    this.zeroAlign = zeroAlign;
    this.autoScaleStart = autoScaleStart;
    this.autoScaleEnd = autoScaleEnd;

    this.formattingFunction = formattingFunction;

    if (autoScaleStart || autoScaleEnd) {
      var me = this;
      var roundToMinor = function roundToMinor(value) {
        var rounded = value - value % (me.magnitudefactor * me.minorSteps[me.minorStepIdx]);
        if (value % (me.magnitudefactor * me.minorSteps[me.minorStepIdx]) > 0.5 * (me.magnitudefactor * me.minorSteps[me.minorStepIdx])) {
          return rounded + me.magnitudefactor * me.minorSteps[me.minorStepIdx];
        } else {
          return rounded;
        }
      };
      if (autoScaleStart) {
        this._start -= this.magnitudefactor * 2 * this.minorSteps[this.minorStepIdx];
        this._start = roundToMinor(this._start);
      }

      if (autoScaleEnd) {
        this._end += this.magnitudefactor * this.minorSteps[this.minorStepIdx];
        this._end = roundToMinor(this._end);
      }
      this.determineScale();
    }
  }

  DataScale.prototype.setCharHeight = function (majorCharHeight) {
    this.majorCharHeight = majorCharHeight;
  };

  DataScale.prototype.setHeight = function (containerHeight) {
    this.containerHeight = containerHeight;
  };

  DataScale.prototype.determineScale = function () {
    var range = this._end - this._start;
    this.scale = this.containerHeight / range;
    var minimumStepValue = this.majorCharHeight / this.scale;
    var orderOfMagnitude = range > 0 ? Math.round(Math.log(range) / Math.LN10) : 0;

    this.minorStepIdx = -1;
    this.magnitudefactor = Math.pow(10, orderOfMagnitude);

    var start = 0;
    if (orderOfMagnitude < 0) {
      start = orderOfMagnitude;
    }

    var solutionFound = false;
    for (var l = start; Math.abs(l) <= Math.abs(orderOfMagnitude); l++) {
      this.magnitudefactor = Math.pow(10, l);
      for (var j = 0; j < this.minorSteps.length; j++) {
        var stepSize = this.magnitudefactor * this.minorSteps[j];
        if (stepSize >= minimumStepValue) {
          solutionFound = true;
          this.minorStepIdx = j;
          break;
        }
      }
      if (solutionFound === true) {
        break;
      }
    }
  };

  DataScale.prototype.is_major = function (value) {
    return value % (this.magnitudefactor * this.majorSteps[this.minorStepIdx]) === 0;
  };

  DataScale.prototype.getStep = function () {
    return this.magnitudefactor * this.minorSteps[this.minorStepIdx];
  };

  DataScale.prototype.getFirstMajor = function () {
    var majorStep = this.magnitudefactor * this.majorSteps[this.minorStepIdx];
    return this.convertValue(this._start + (majorStep - this._start % majorStep) % majorStep);
  };

  DataScale.prototype.formatValue = function (current) {
    var returnValue = current.toPrecision(5);
    if (typeof this.formattingFunction === 'function') {
      returnValue = this.formattingFunction(current);
    }

    if (typeof returnValue === 'number') {
      return '' + returnValue;
    } else if (typeof returnValue === 'string') {
      return returnValue;
    } else {
      return current.toPrecision(5);
    }
  };

  DataScale.prototype.getLines = function () {
    var lines = [];
    var step = this.getStep();
    var bottomOffset = (step - this._start % step) % step;
    for (var i = this._start + bottomOffset; this._end - i > 0.00001; i += step) {
      if (i != this._start) {
        //Skip the bottom line
        lines.push({ major: this.is_major(i), y: this.convertValue(i), val: this.formatValue(i) });
      }
    }
    return lines;
  };

  DataScale.prototype.followScale = function (other) {
    var oldStepIdx = this.minorStepIdx;
    var oldStart = this._start;
    var oldEnd = this._end;

    var me = this;
    var increaseMagnitude = function increaseMagnitude() {
      me.magnitudefactor *= 2;
    };
    var decreaseMagnitude = function decreaseMagnitude() {
      me.magnitudefactor /= 2;
    };

    if (other.minorStepIdx <= 1 && this.minorStepIdx <= 1 || other.minorStepIdx > 1 && this.minorStepIdx > 1) {
      //easy, no need to change stepIdx nor multiplication factor
    } else if (other.minorStepIdx < this.minorStepIdx) {
      //I'm 5, they are 4 per major.
      this.minorStepIdx = 1;
      if (oldStepIdx == 2) {
        increaseMagnitude();
      } else {
        increaseMagnitude();
        increaseMagnitude();
      }
    } else {
      //I'm 4, they are 5 per major
      this.minorStepIdx = 2;
      if (oldStepIdx == 1) {
        decreaseMagnitude();
      } else {
        decreaseMagnitude();
        decreaseMagnitude();
      }
    }

    //Get masters stats:
    var lines = other.getLines();
    var otherZero = other.convertValue(0);
    var otherStep = other.getStep() * other.scale;

    var done = false;
    var count = 0;
    //Loop until magnitude is correct for given constrains.
    while (!done && count++ < 5) {

      //Get my stats:
      this.scale = otherStep / (this.minorSteps[this.minorStepIdx] * this.magnitudefactor);
      var newRange = this.containerHeight / this.scale;

      //For the case the magnitudefactor has changed:
      this._start = oldStart;
      this._end = this._start + newRange;

      var myOriginalZero = this._end * this.scale;
      var majorStep = this.magnitudefactor * this.majorSteps[this.minorStepIdx];
      var majorOffset = this.getFirstMajor() - other.getFirstMajor();

      if (this.zeroAlign) {
        var zeroOffset = otherZero - myOriginalZero;
        this._end += zeroOffset / this.scale;
        this._start = this._end - newRange;
      } else {
        if (!this.autoScaleStart) {
          this._start += majorStep - majorOffset / this.scale;
          this._end = this._start + newRange;
        } else {
          this._start -= majorOffset / this.scale;
          this._end = this._start + newRange;
        }
      }
      if (!this.autoScaleEnd && this._end > oldEnd + 0.00001) {
        //Need to decrease magnitude to prevent scale overshoot! (end)
        decreaseMagnitude();
        done = false;
        continue;
      }
      if (!this.autoScaleStart && this._start < oldStart - 0.00001) {
        if (this.zeroAlign && oldStart >= 0) {
          console.warn("Can't adhere to given 'min' range, due to zeroalign");
        } else {
          //Need to decrease magnitude to prevent scale overshoot! (start)
          decreaseMagnitude();
          done = false;
          continue;
        }
      }
      if (this.autoScaleStart && this.autoScaleEnd && newRange < oldEnd - oldStart) {
        increaseMagnitude();
        done = false;
        continue;
      }
      done = true;
    }
  };

  DataScale.prototype.convertValue = function (value) {
    return this.containerHeight - (value - this._start) * this.scale;
  };

  DataScale.prototype.screenToValue = function (pixels) {
    return (this.containerHeight - pixels) / this.scale + this._start;
  };

  module.exports = DataScale;

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var util = __webpack_require__(1);
  var DOMutil = __webpack_require__(8);
  var Bars = __webpack_require__(57);
  var Lines = __webpack_require__(59);
  var Points = __webpack_require__(58);

  /**
   * /**
   * @param {object} group            | the object of the group from the dataset
   * @param {string} groupId          | ID of the group
   * @param {object} options          | the default options
   * @param {array} groupsUsingDefaultStyles  | this array has one entree.
   *                                            It is passed as an array so it is passed by reference.
   *                                            It enumerates through the default styles
   * @constructor
   */
  function GraphGroup(group, groupId, options, groupsUsingDefaultStyles) {
    this.id = groupId;
    var fields = ['sampling', 'style', 'sort', 'yAxisOrientation', 'barChart', 'drawPoints', 'shaded', 'interpolation', 'zIndex', 'excludeFromStacking', 'excludeFromLegend'];
    this.options = util.selectiveBridgeObject(fields, options);
    this.usingDefaultStyle = group.className === undefined;
    this.groupsUsingDefaultStyles = groupsUsingDefaultStyles;
    this.zeroPosition = 0;
    this.update(group);
    if (this.usingDefaultStyle == true) {
      this.groupsUsingDefaultStyles[0] += 1;
    }
    this.itemsData = [];
    this.visible = group.visible === undefined ? true : group.visible;
  }

  /**
   * this loads a reference to all items in this group into this group.
   * @param {array} items
   */
  GraphGroup.prototype.setItems = function (items) {
    if (items != null) {
      this.itemsData = items;
      if (this.options.sort == true) {
        util.insertSort(this.itemsData, function (a, b) {
          return a.x > b.x ? 1 : -1;
        });
      }
    } else {
      this.itemsData = [];
    }
  };

  GraphGroup.prototype.getItems = function () {
    return this.itemsData;
  };

  /**
   * this is used for barcharts and shading, this way, we only have to calculate it once.
   * @param pos
   */
  GraphGroup.prototype.setZeroPosition = function (pos) {
    this.zeroPosition = pos;
  };

  /**
   * set the options of the graph group over the default options.
   * @param options
   */
  GraphGroup.prototype.setOptions = function (options) {
    if (options !== undefined) {
      var fields = ['sampling', 'style', 'sort', 'yAxisOrientation', 'barChart', 'zIndex', 'excludeFromStacking', 'excludeFromLegend'];
      util.selectiveDeepExtend(fields, this.options, options);

      // if the group's drawPoints is a function delegate the callback to the onRender property
      if (typeof options.drawPoints == 'function') {
        options.drawPoints = {
          onRender: options.drawPoints
        };
      }

      util.mergeOptions(this.options, options, 'interpolation');
      util.mergeOptions(this.options, options, 'drawPoints');
      util.mergeOptions(this.options, options, 'shaded');

      if (options.interpolation) {
        if (_typeof(options.interpolation) == 'object') {
          if (options.interpolation.parametrization) {
            if (options.interpolation.parametrization == 'uniform') {
              this.options.interpolation.alpha = 0;
            } else if (options.interpolation.parametrization == 'chordal') {
              this.options.interpolation.alpha = 1.0;
            } else {
              this.options.interpolation.parametrization = 'centripetal';
              this.options.interpolation.alpha = 0.5;
            }
          }
        }
      }
    }
  };

  /**
   * this updates the current group class with the latest group dataset entree, used in _updateGroup in linegraph
   * @param group
   */
  GraphGroup.prototype.update = function (group) {
    this.group = group;
    this.content = group.content || 'graph';
    this.className = group.className || this.className || 'vis-graph-group' + this.groupsUsingDefaultStyles[0] % 10;
    this.visible = group.visible === undefined ? true : group.visible;
    this.style = group.style;
    this.setOptions(group.options);
  };

  /**
   * return the legend entree for this group.
   *
   * @param iconWidth
   * @param iconHeight
   * @returns {{icon: HTMLElement, label: (group.content|*|string), orientation: (.options.yAxisOrientation|*)}}
   */
  GraphGroup.prototype.getLegend = function (iconWidth, iconHeight, framework, x, y) {
    if (framework == undefined || framework == null) {
      var svg = document.createElementNS('http://www.w3.org/2000/svg', "svg");
      framework = { svg: svg, svgElements: {}, options: this.options, groups: [this] };
    }
    if (x == undefined || x == null) {
      x = 0;
    }
    if (y == undefined || y == null) {
      y = 0.5 * iconHeight;
    }
    switch (this.options.style) {
      case "line":
        Lines.drawIcon(this, x, y, iconWidth, iconHeight, framework);
        break;
      case "points": //explicit no break
      case "point":
        Points.drawIcon(this, x, y, iconWidth, iconHeight, framework);
        break;
      case "bar":
        Bars.drawIcon(this, x, y, iconWidth, iconHeight, framework);
        break;
    }
    return { icon: framework.svg, label: this.content, orientation: this.options.yAxisOrientation };
  };

  GraphGroup.prototype.getYRange = function (groupData) {
    var yMin = groupData[0].y;
    var yMax = groupData[0].y;
    for (var j = 0; j < groupData.length; j++) {
      yMin = yMin > groupData[j].y ? groupData[j].y : yMin;
      yMax = yMax < groupData[j].y ? groupData[j].y : yMax;
    }
    return { min: yMin, max: yMax, yAxisOrientation: this.options.yAxisOrientation };
  };

  module.exports = GraphGroup;

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var DOMutil = __webpack_require__(8);
  var Points = __webpack_require__(58);

  function Bargraph(groupId, options) {}

  Bargraph.drawIcon = function (group, x, y, iconWidth, iconHeight, framework) {
    var fillHeight = iconHeight * 0.5;
    var path, fillPath;

    var outline = DOMutil.getSVGElement("rect", framework.svgElements, framework.svg);
    outline.setAttributeNS(null, "x", x);
    outline.setAttributeNS(null, "y", y - fillHeight);
    outline.setAttributeNS(null, "width", iconWidth);
    outline.setAttributeNS(null, "height", 2 * fillHeight);
    outline.setAttributeNS(null, "class", "vis-outline");

    var barWidth = Math.round(0.3 * iconWidth);
    var originalWidth = group.options.barChart.width;
    var scale = originalWidth / barWidth;
    var bar1Height = Math.round(0.4 * iconHeight);
    var bar2Height = Math.round(0.75 * iconHeight);

    var offset = Math.round((iconWidth - 2 * barWidth) / 3);

    DOMutil.drawBar(x + 0.5 * barWidth + offset, y + fillHeight - bar1Height - 1, barWidth, bar1Height, group.className + ' vis-bar', framework.svgElements, framework.svg, group.style);
    DOMutil.drawBar(x + 1.5 * barWidth + offset + 2, y + fillHeight - bar2Height - 1, barWidth, bar2Height, group.className + ' vis-bar', framework.svgElements, framework.svg, group.style);

    if (group.options.drawPoints.enabled == true) {
      var groupTemplate = {
        style: group.options.drawPoints.style,
        styles: group.options.drawPoints.styles,
        size: group.options.drawPoints.size / scale,
        className: group.className
      };
      DOMutil.drawPoint(x + 0.5 * barWidth + offset, y + fillHeight - bar1Height - 1, groupTemplate, framework.svgElements, framework.svg);
      DOMutil.drawPoint(x + 1.5 * barWidth + offset + 2, y + fillHeight - bar2Height - 1, groupTemplate, framework.svgElements, framework.svg);
    }
  };

  /**
   * draw a bar graph
   *
   * @param groupIds
   * @param processedGroupData
   */
  Bargraph.draw = function (groupIds, processedGroupData, framework) {
    var combinedData = [];
    var intersections = {};
    var coreDistance;
    var key, drawData;
    var group;
    var i, j;
    var barPoints = 0;

    // combine all barchart data
    for (i = 0; i < groupIds.length; i++) {
      group = framework.groups[groupIds[i]];
      if (group.options.style === 'bar') {
        if (group.visible === true && (framework.options.groups.visibility[groupIds[i]] === undefined || framework.options.groups.visibility[groupIds[i]] === true)) {
          for (j = 0; j < processedGroupData[groupIds[i]].length; j++) {
            combinedData.push({
              screen_x: processedGroupData[groupIds[i]][j].screen_x,
              screen_y: processedGroupData[groupIds[i]][j].screen_y,
              x: processedGroupData[groupIds[i]][j].x,
              y: processedGroupData[groupIds[i]][j].y,
              groupId: groupIds[i],
              label: processedGroupData[groupIds[i]][j].label
            });
            barPoints += 1;
          }
        }
      }
    }

    if (barPoints === 0) {
      return;
    }

    // sort by time and by group
    combinedData.sort(function (a, b) {
      if (a.screen_x === b.screen_x) {
        return a.groupId < b.groupId ? -1 : 1;
      } else {
        return a.screen_x - b.screen_x;
      }
    });

    // get intersections
    Bargraph._getDataIntersections(intersections, combinedData);

    // plot barchart
    for (i = 0; i < combinedData.length; i++) {
      group = framework.groups[combinedData[i].groupId];
      var minWidth = group.options.barChart.minWidth != undefined ? group.options.barChart.minWidth : 0.1 * group.options.barChart.width;

      key = combinedData[i].screen_x;
      var heightOffset = 0;
      if (intersections[key] === undefined) {
        if (i + 1 < combinedData.length) {
          coreDistance = Math.abs(combinedData[i + 1].screen_x - key);
        }
        drawData = Bargraph._getSafeDrawData(coreDistance, group, minWidth);
      } else {
        var nextKey = i + (intersections[key].amount - intersections[key].resolved);
        var prevKey = i - (intersections[key].resolved + 1);
        if (nextKey < combinedData.length) {
          coreDistance = Math.abs(combinedData[nextKey].screen_x - key);
        }
        drawData = Bargraph._getSafeDrawData(coreDistance, group, minWidth);
        intersections[key].resolved += 1;

        if (group.options.stack === true && group.options.excludeFromStacking !== true) {
          if (combinedData[i].screen_y < group.zeroPosition) {
            heightOffset = intersections[key].accumulatedNegative;
            intersections[key].accumulatedNegative += group.zeroPosition - combinedData[i].screen_y;
          } else {
            heightOffset = intersections[key].accumulatedPositive;
            intersections[key].accumulatedPositive += group.zeroPosition - combinedData[i].screen_y;
          }
        } else if (group.options.barChart.sideBySide === true) {
          drawData.width = drawData.width / intersections[key].amount;
          drawData.offset += intersections[key].resolved * drawData.width - 0.5 * drawData.width * (intersections[key].amount + 1);
        }
      }
      DOMutil.drawBar(combinedData[i].screen_x + drawData.offset, combinedData[i].screen_y - heightOffset, drawData.width, group.zeroPosition - combinedData[i].screen_y, group.className + ' vis-bar', framework.svgElements, framework.svg, group.style);
      // draw points
      if (group.options.drawPoints.enabled === true) {
        var pointData = {
          screen_x: combinedData[i].screen_x,
          screen_y: combinedData[i].screen_y - heightOffset,
          x: combinedData[i].x,
          y: combinedData[i].y,
          groupId: combinedData[i].groupId,
          label: combinedData[i].label
        };
        Points.draw([pointData], group, framework, drawData.offset);
        //DOMutil.drawPoint(combinedData[i].x + drawData.offset, combinedData[i].y, group, framework.svgElements, framework.svg);
      }
    }
  };

  /**
   * Fill the intersections object with counters of how many datapoints share the same x coordinates
   * @param intersections
   * @param combinedData
   * @private
   */
  Bargraph._getDataIntersections = function (intersections, combinedData) {
    // get intersections
    var coreDistance;
    for (var i = 0; i < combinedData.length; i++) {
      if (i + 1 < combinedData.length) {
        coreDistance = Math.abs(combinedData[i + 1].screen_x - combinedData[i].screen_x);
      }
      if (i > 0) {
        coreDistance = Math.min(coreDistance, Math.abs(combinedData[i - 1].screen_x - combinedData[i].screen_x));
      }
      if (coreDistance === 0) {
        if (intersections[combinedData[i].screen_x] === undefined) {
          intersections[combinedData[i].screen_x] = {
            amount: 0,
            resolved: 0,
            accumulatedPositive: 0,
            accumulatedNegative: 0
          };
        }
        intersections[combinedData[i].screen_x].amount += 1;
      }
    }
  };

  /**
   * Get the width and offset for bargraphs based on the coredistance between datapoints
   *
   * @param coreDistance
   * @param group
   * @param minWidth
   * @returns {{width: Number, offset: Number}}
   * @private
   */
  Bargraph._getSafeDrawData = function (coreDistance, group, minWidth) {
    var width, offset;
    if (coreDistance < group.options.barChart.width && coreDistance > 0) {
      width = coreDistance < minWidth ? minWidth : coreDistance;

      offset = 0; // recalculate offset with the new width;
      if (group.options.barChart.align === 'left') {
        offset -= 0.5 * coreDistance;
      } else if (group.options.barChart.align === 'right') {
        offset += 0.5 * coreDistance;
      }
    } else {
      // default settings
      width = group.options.barChart.width;
      offset = 0;
      if (group.options.barChart.align === 'left') {
        offset -= 0.5 * group.options.barChart.width;
      } else if (group.options.barChart.align === 'right') {
        offset += 0.5 * group.options.barChart.width;
      }
    }

    return { width: width, offset: offset };
  };

  Bargraph.getStackedYRange = function (combinedData, groupRanges, groupIds, groupLabel, orientation) {
    if (combinedData.length > 0) {
      // sort by time and by group
      combinedData.sort(function (a, b) {
        if (a.screen_x === b.screen_x) {
          return a.groupId < b.groupId ? -1 : 1;
        } else {
          return a.screen_x - b.screen_x;
        }
      });
      var intersections = {};

      Bargraph._getDataIntersections(intersections, combinedData);
      groupRanges[groupLabel] = Bargraph._getStackedYRange(intersections, combinedData);
      groupRanges[groupLabel].yAxisOrientation = orientation;
      groupIds.push(groupLabel);
    }
  };

  Bargraph._getStackedYRange = function (intersections, combinedData) {
    var key;
    var yMin = combinedData[0].screen_y;
    var yMax = combinedData[0].screen_y;
    for (var i = 0; i < combinedData.length; i++) {
      key = combinedData[i].screen_x;
      if (intersections[key] === undefined) {
        yMin = yMin > combinedData[i].screen_y ? combinedData[i].screen_y : yMin;
        yMax = yMax < combinedData[i].screen_y ? combinedData[i].screen_y : yMax;
      } else {
        if (combinedData[i].screen_y < 0) {
          intersections[key].accumulatedNegative += combinedData[i].screen_y;
        } else {
          intersections[key].accumulatedPositive += combinedData[i].screen_y;
        }
      }
    }
    for (var xpos in intersections) {
      if (intersections.hasOwnProperty(xpos)) {
        yMin = yMin > intersections[xpos].accumulatedNegative ? intersections[xpos].accumulatedNegative : yMin;
        yMin = yMin > intersections[xpos].accumulatedPositive ? intersections[xpos].accumulatedPositive : yMin;
        yMax = yMax < intersections[xpos].accumulatedNegative ? intersections[xpos].accumulatedNegative : yMax;
        yMax = yMax < intersections[xpos].accumulatedPositive ? intersections[xpos].accumulatedPositive : yMax;
      }
    }

    return { min: yMin, max: yMax };
  };

  module.exports = Bargraph;

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var DOMutil = __webpack_require__(8);

  function Points(groupId, options) {}

  /**
   * draw the data points
   *
   * @param {Array} dataset
   * @param {Object} JSONcontainer
   * @param {Object} svg            | SVG DOM element
   * @param {GraphGroup} group
   * @param {Number} [offset]
   */
  Points.draw = function (dataset, group, framework, offset) {
    offset = offset || 0;
    var callback = getCallback(framework, group);

    for (var i = 0; i < dataset.length; i++) {
      if (!callback) {
        // draw the point the simple way.
        DOMutil.drawPoint(dataset[i].screen_x + offset, dataset[i].screen_y, getGroupTemplate(group), framework.svgElements, framework.svg, dataset[i].label);
      } else {
        var callbackResult = callback(dataset[i], group); // result might be true, false or an object
        if (callbackResult === true || (typeof callbackResult === 'undefined' ? 'undefined' : _typeof(callbackResult)) === 'object') {
          DOMutil.drawPoint(dataset[i].screen_x + offset, dataset[i].screen_y, getGroupTemplate(group, callbackResult), framework.svgElements, framework.svg, dataset[i].label);
        }
      }
    }
  };

  Points.drawIcon = function (group, x, y, iconWidth, iconHeight, framework) {
    var fillHeight = iconHeight * 0.5;
    var path, fillPath;

    var outline = DOMutil.getSVGElement("rect", framework.svgElements, framework.svg);
    outline.setAttributeNS(null, "x", x);
    outline.setAttributeNS(null, "y", y - fillHeight);
    outline.setAttributeNS(null, "width", iconWidth);
    outline.setAttributeNS(null, "height", 2 * fillHeight);
    outline.setAttributeNS(null, "class", "vis-outline");

    //Don't call callback on icon
    DOMutil.drawPoint(x + 0.5 * iconWidth, y, getGroupTemplate(group), framework.svgElements, framework.svg);
  };

  function getGroupTemplate(group, callbackResult) {
    callbackResult = typeof callbackResult === 'undefined' ? {} : callbackResult;
    return {
      style: callbackResult.style || group.options.drawPoints.style,
      styles: callbackResult.styles || group.options.drawPoints.styles,
      size: callbackResult.size || group.options.drawPoints.size,
      className: callbackResult.className || group.className
    };
  }

  function getCallback(framework, group) {
    var callback = undefined;
    // check for the graph2d onRender
    if (framework.options && framework.options.drawPoints && framework.options.drawPoints.onRender && typeof framework.options.drawPoints.onRender == 'function') {
      callback = framework.options.drawPoints.onRender;
    }

    // override it with the group onRender if defined
    if (group.group.options && group.group.options.drawPoints && group.group.options.drawPoints.onRender && typeof group.group.options.drawPoints.onRender == 'function') {
      callback = group.group.options.drawPoints.onRender;
    }
    return callback;
  }

  module.exports = Points;

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";

  var DOMutil = __webpack_require__(8);

  function Line(groupId, options) {}

  Line.calcPath = function (dataset, group) {
      if (dataset != null) {
          if (dataset.length > 0) {
              var d = [];

              // construct path from dataset
              if (group.options.interpolation.enabled == true) {
                  d = Line._catmullRom(dataset, group);
              } else {
                  d = Line._linear(dataset);
              }
              return d;
          }
      }
  };

  Line.drawIcon = function (group, x, y, iconWidth, iconHeight, framework) {
      var fillHeight = iconHeight * 0.5;
      var path, fillPath;

      var outline = DOMutil.getSVGElement("rect", framework.svgElements, framework.svg);
      outline.setAttributeNS(null, "x", x);
      outline.setAttributeNS(null, "y", y - fillHeight);
      outline.setAttributeNS(null, "width", iconWidth);
      outline.setAttributeNS(null, "height", 2 * fillHeight);
      outline.setAttributeNS(null, "class", "vis-outline");

      path = DOMutil.getSVGElement("path", framework.svgElements, framework.svg);
      path.setAttributeNS(null, "class", group.className);
      if (group.style !== undefined) {
          path.setAttributeNS(null, "style", group.style);
      }

      path.setAttributeNS(null, "d", "M" + x + "," + y + " L" + (x + iconWidth) + "," + y + "");
      if (group.options.shaded.enabled == true) {
          fillPath = DOMutil.getSVGElement("path", framework.svgElements, framework.svg);
          if (group.options.shaded.orientation == 'top') {
              fillPath.setAttributeNS(null, "d", "M" + x + ", " + (y - fillHeight) + "L" + x + "," + y + " L" + (x + iconWidth) + "," + y + " L" + (x + iconWidth) + "," + (y - fillHeight));
          } else {
              fillPath.setAttributeNS(null, "d", "M" + x + "," + y + " " + "L" + x + "," + (y + fillHeight) + " " + "L" + (x + iconWidth) + "," + (y + fillHeight) + "L" + (x + iconWidth) + "," + y);
          }
          fillPath.setAttributeNS(null, "class", group.className + " vis-icon-fill");
          if (group.options.shaded.style !== undefined && group.options.shaded.style !== "") {
              fillPath.setAttributeNS(null, "style", group.options.shaded.style);
          }
      }

      if (group.options.drawPoints.enabled == true) {
          var groupTemplate = {
              style: group.options.drawPoints.style,
              styles: group.options.drawPoints.styles,
              size: group.options.drawPoints.size,
              className: group.className
          };
          DOMutil.drawPoint(x + 0.5 * iconWidth, y, groupTemplate, framework.svgElements, framework.svg);
      }
  };

  Line.drawShading = function (pathArray, group, subPathArray, framework) {
      // append shading to the path
      if (group.options.shaded.enabled == true) {
          var svgHeight = Number(framework.svg.style.height.replace('px', ''));
          var fillPath = DOMutil.getSVGElement('path', framework.svgElements, framework.svg);
          var type = "L";
          if (group.options.interpolation.enabled == true) {
              type = "C";
          }
          var dFill;
          var zero = 0;
          if (group.options.shaded.orientation == 'top') {
              zero = 0;
          } else if (group.options.shaded.orientation == 'bottom') {
              zero = svgHeight;
          } else {
              zero = Math.min(Math.max(0, group.zeroPosition), svgHeight);
          }
          if (group.options.shaded.orientation == 'group' && subPathArray != null && subPathArray != undefined) {
              dFill = 'M' + pathArray[0][0] + "," + pathArray[0][1] + " " + this.serializePath(pathArray, type, false) + ' L' + subPathArray[subPathArray.length - 1][0] + "," + subPathArray[subPathArray.length - 1][1] + " " + this.serializePath(subPathArray, type, true) + subPathArray[0][0] + "," + subPathArray[0][1] + " Z";
          } else {
              dFill = 'M' + pathArray[0][0] + "," + pathArray[0][1] + " " + this.serializePath(pathArray, type, false) + ' V' + zero + ' H' + pathArray[0][0] + " Z";
          }

          fillPath.setAttributeNS(null, 'class', group.className + ' vis-fill');
          if (group.options.shaded.style !== undefined) {
              fillPath.setAttributeNS(null, 'style', group.options.shaded.style);
          }
          fillPath.setAttributeNS(null, 'd', dFill);
      }
  };

  /**
   * draw a line graph
   *
   * @param dataset
   * @param group
   */
  Line.draw = function (pathArray, group, framework) {
      if (pathArray != null && pathArray != undefined) {
          var path = DOMutil.getSVGElement('path', framework.svgElements, framework.svg);
          path.setAttributeNS(null, "class", group.className);
          if (group.style !== undefined) {
              path.setAttributeNS(null, "style", group.style);
          }

          var type = "L";
          if (group.options.interpolation.enabled == true) {
              type = "C";
          }
          // copy properties to path for drawing.
          path.setAttributeNS(null, 'd', 'M' + pathArray[0][0] + "," + pathArray[0][1] + " " + this.serializePath(pathArray, type, false));
      }
  };

  Line.serializePath = function (pathArray, type, inverse) {
      if (pathArray.length < 2) {
          //Too little data to create a path.
          return "";
      }
      var d = type;
      if (inverse) {
          for (var i = pathArray.length - 2; i > 0; i--) {
              d += pathArray[i][0] + "," + pathArray[i][1] + " ";
          }
      } else {
          for (var i = 1; i < pathArray.length; i++) {
              d += pathArray[i][0] + "," + pathArray[i][1] + " ";
          }
      }
      return d;
  };

  /**
   * This uses an uniform parametrization of the interpolation algorithm:
   * 'On the Parameterization of Catmull-Rom Curves' by Cem Yuksel et al.
   * @param data
   * @returns {string}
   * @private
   */
  Line._catmullRomUniform = function (data) {
      // catmull rom
      var p0, p1, p2, p3, bp1, bp2;
      var d = [];
      d.push([Math.round(data[0].screen_x), Math.round(data[0].screen_y)]);
      var normalization = 1 / 6;
      var length = data.length;
      for (var i = 0; i < length - 1; i++) {

          p0 = i == 0 ? data[0] : data[i - 1];
          p1 = data[i];
          p2 = data[i + 1];
          p3 = i + 2 < length ? data[i + 2] : p2;

          // Catmull-Rom to Cubic Bezier conversion matrix
          //    0       1       0       0
          //  -1/6      1      1/6      0
          //    0      1/6      1     -1/6
          //    0       0       1       0

          //    bp0 = { x: p1.x,                               y: p1.y };
          bp1 = {
              screen_x: (-p0.screen_x + 6 * p1.screen_x + p2.screen_x) * normalization,
              screen_y: (-p0.screen_y + 6 * p1.screen_y + p2.screen_y) * normalization
          };
          bp2 = {
              screen_x: (p1.screen_x + 6 * p2.screen_x - p3.screen_x) * normalization,
              screen_y: (p1.screen_y + 6 * p2.screen_y - p3.screen_y) * normalization
          };
          //    bp0 = { x: p2.x,                               y: p2.y };

          d.push([bp1.screen_x, bp1.screen_y]);
          d.push([bp2.screen_x, bp2.screen_y]);
          d.push([p2.screen_x, p2.screen_y]);
      }

      return d;
  };

  /**
   * This uses either the chordal or centripetal parameterization of the catmull-rom algorithm.
   * By default, the centripetal parameterization is used because this gives the nicest results.
   * These parameterizations are relatively heavy because the distance between 4 points have to be calculated.
   *
   * One optimization can be used to reuse distances since this is a sliding window approach.
   * @param data
   * @param group
   * @returns {string}
   * @private
   */
  Line._catmullRom = function (data, group) {
      var alpha = group.options.interpolation.alpha;
      if (alpha == 0 || alpha === undefined) {
          return this._catmullRomUniform(data);
      } else {
          var p0, p1, p2, p3, bp1, bp2, d1, d2, d3, A, B, N, M;
          var d3powA, d2powA, d3pow2A, d2pow2A, d1pow2A, d1powA;
          var d = [];
          d.push([Math.round(data[0].screen_x), Math.round(data[0].screen_y)]);
          var length = data.length;
          for (var i = 0; i < length - 1; i++) {

              p0 = i == 0 ? data[0] : data[i - 1];
              p1 = data[i];
              p2 = data[i + 1];
              p3 = i + 2 < length ? data[i + 2] : p2;

              d1 = Math.sqrt(Math.pow(p0.screen_x - p1.screen_x, 2) + Math.pow(p0.screen_y - p1.screen_y, 2));
              d2 = Math.sqrt(Math.pow(p1.screen_x - p2.screen_x, 2) + Math.pow(p1.screen_y - p2.screen_y, 2));
              d3 = Math.sqrt(Math.pow(p2.screen_x - p3.screen_x, 2) + Math.pow(p2.screen_y - p3.screen_y, 2));

              // Catmull-Rom to Cubic Bezier conversion matrix

              // A = 2d1^2a + 3d1^a * d2^a + d3^2a
              // B = 2d3^2a + 3d3^a * d2^a + d2^2a

              // [   0             1            0          0          ]
              // [   -d2^2a /N     A/N          d1^2a /N   0          ]
              // [   0             d3^2a /M     B/M        -d2^2a /M  ]
              // [   0             0            1          0          ]

              d3powA = Math.pow(d3, alpha);
              d3pow2A = Math.pow(d3, 2 * alpha);
              d2powA = Math.pow(d2, alpha);
              d2pow2A = Math.pow(d2, 2 * alpha);
              d1powA = Math.pow(d1, alpha);
              d1pow2A = Math.pow(d1, 2 * alpha);

              A = 2 * d1pow2A + 3 * d1powA * d2powA + d2pow2A;
              B = 2 * d3pow2A + 3 * d3powA * d2powA + d2pow2A;
              N = 3 * d1powA * (d1powA + d2powA);
              if (N > 0) {
                  N = 1 / N;
              }
              M = 3 * d3powA * (d3powA + d2powA);
              if (M > 0) {
                  M = 1 / M;
              }

              bp1 = {
                  screen_x: (-d2pow2A * p0.screen_x + A * p1.screen_x + d1pow2A * p2.screen_x) * N,
                  screen_y: (-d2pow2A * p0.screen_y + A * p1.screen_y + d1pow2A * p2.screen_y) * N
              };

              bp2 = {
                  screen_x: (d3pow2A * p1.screen_x + B * p2.screen_x - d2pow2A * p3.screen_x) * M,
                  screen_y: (d3pow2A * p1.screen_y + B * p2.screen_y - d2pow2A * p3.screen_y) * M
              };

              if (bp1.screen_x == 0 && bp1.screen_y == 0) {
                  bp1 = p1;
              }
              if (bp2.screen_x == 0 && bp2.screen_y == 0) {
                  bp2 = p2;
              }
              d.push([bp1.screen_x, bp1.screen_y]);
              d.push([bp2.screen_x, bp2.screen_y]);
              d.push([p2.screen_x, p2.screen_y]);
          }

          return d;
      }
  };

  /**
   * this generates the SVG path for a linear drawing between datapoints.
   * @param data
   * @returns {string}
   * @private
   */
  Line._linear = function (data) {
      // linear
      var d = [];
      for (var i = 0; i < data.length; i++) {
          d.push([data[i].screen_x, data[i].screen_y]);
      }
      return d;
  };

  module.exports = Line;

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);
  var DOMutil = __webpack_require__(8);
  var Component = __webpack_require__(33);

  /**
   * Legend for Graph2d
   */
  function Legend(body, options, side, linegraphOptions) {
    this.body = body;
    this.defaultOptions = {
      enabled: false,
      icons: true,
      iconSize: 20,
      iconSpacing: 6,
      left: {
        visible: true,
        position: 'top-left' // top/bottom - left,center,right
      },
      right: {
        visible: true,
        position: 'top-right' // top/bottom - left,center,right
      }
    };

    this.side = side;
    this.options = util.extend({}, this.defaultOptions);
    this.linegraphOptions = linegraphOptions;

    this.svgElements = {};
    this.dom = {};
    this.groups = {};
    this.amountOfGroups = 0;
    this._create();
    this.framework = { svg: this.svg, svgElements: this.svgElements, options: this.options, groups: this.groups };

    this.setOptions(options);
  }

  Legend.prototype = new Component();

  Legend.prototype.clear = function () {
    this.groups = {};
    this.amountOfGroups = 0;
  };

  Legend.prototype.addGroup = function (label, graphOptions) {

    // Include a group only if the group option 'excludeFromLegend: false' is not set.
    if (graphOptions.options.excludeFromLegend != true) {
      if (!this.groups.hasOwnProperty(label)) {
        this.groups[label] = graphOptions;
      }
      this.amountOfGroups += 1;
    }
  };

  Legend.prototype.updateGroup = function (label, graphOptions) {
    this.groups[label] = graphOptions;
  };

  Legend.prototype.removeGroup = function (label) {
    if (this.groups.hasOwnProperty(label)) {
      delete this.groups[label];
      this.amountOfGroups -= 1;
    }
  };

  Legend.prototype._create = function () {
    this.dom.frame = document.createElement('div');
    this.dom.frame.className = 'vis-legend';
    this.dom.frame.style.position = "absolute";
    this.dom.frame.style.top = "10px";
    this.dom.frame.style.display = "block";

    this.dom.textArea = document.createElement('div');
    this.dom.textArea.className = 'vis-legend-text';
    this.dom.textArea.style.position = "relative";
    this.dom.textArea.style.top = "0px";

    this.svg = document.createElementNS('http://www.w3.org/2000/svg', "svg");
    this.svg.style.position = 'absolute';
    this.svg.style.top = 0 + 'px';
    this.svg.style.width = this.options.iconSize + 5 + 'px';
    this.svg.style.height = '100%';

    this.dom.frame.appendChild(this.svg);
    this.dom.frame.appendChild(this.dom.textArea);
  };

  /**
   * Hide the component from the DOM
   */
  Legend.prototype.hide = function () {
    // remove the frame containing the items
    if (this.dom.frame.parentNode) {
      this.dom.frame.parentNode.removeChild(this.dom.frame);
    }
  };

  /**
   * Show the component in the DOM (when not already visible).
   * @return {Boolean} changed
   */
  Legend.prototype.show = function () {
    // show frame containing the items
    if (!this.dom.frame.parentNode) {
      this.body.dom.center.appendChild(this.dom.frame);
    }
  };

  Legend.prototype.setOptions = function (options) {
    var fields = ['enabled', 'orientation', 'icons', 'left', 'right'];
    util.selectiveDeepExtend(fields, this.options, options);
  };

  Legend.prototype.redraw = function () {
    var activeGroups = 0;
    var groupArray = Object.keys(this.groups);
    groupArray.sort(function (a, b) {
      return a < b ? -1 : 1;
    });

    for (var i = 0; i < groupArray.length; i++) {
      var groupId = groupArray[i];
      if (this.groups[groupId].visible == true && (this.linegraphOptions.visibility[groupId] === undefined || this.linegraphOptions.visibility[groupId] == true)) {
        activeGroups++;
      }
    }

    if (this.options[this.side].visible == false || this.amountOfGroups == 0 || this.options.enabled == false || activeGroups == 0) {
      this.hide();
    } else {
      this.show();
      if (this.options[this.side].position == 'top-left' || this.options[this.side].position == 'bottom-left') {
        this.dom.frame.style.left = '4px';
        this.dom.frame.style.textAlign = "left";
        this.dom.textArea.style.textAlign = "left";
        this.dom.textArea.style.left = this.options.iconSize + 15 + 'px';
        this.dom.textArea.style.right = '';
        this.svg.style.left = 0 + 'px';
        this.svg.style.right = '';
      } else {
        this.dom.frame.style.right = '4px';
        this.dom.frame.style.textAlign = "right";
        this.dom.textArea.style.textAlign = "right";
        this.dom.textArea.style.right = this.options.iconSize + 15 + 'px';
        this.dom.textArea.style.left = '';
        this.svg.style.right = 0 + 'px';
        this.svg.style.left = '';
      }

      if (this.options[this.side].position == 'top-left' || this.options[this.side].position == 'top-right') {
        this.dom.frame.style.top = 4 - Number(this.body.dom.center.style.top.replace("px", "")) + 'px';
        this.dom.frame.style.bottom = '';
      } else {
        var scrollableHeight = this.body.domProps.center.height - this.body.domProps.centerContainer.height;
        this.dom.frame.style.bottom = 4 + scrollableHeight + Number(this.body.dom.center.style.top.replace("px", "")) + 'px';
        this.dom.frame.style.top = '';
      }

      if (this.options.icons == false) {
        this.dom.frame.style.width = this.dom.textArea.offsetWidth + 10 + 'px';
        this.dom.textArea.style.right = '';
        this.dom.textArea.style.left = '';
        this.svg.style.width = '0px';
      } else {
        this.dom.frame.style.width = this.options.iconSize + 15 + this.dom.textArea.offsetWidth + 10 + 'px';
        this.drawLegendIcons();
      }

      var content = '';
      for (var i = 0; i < groupArray.length; i++) {
        var groupId = groupArray[i];
        if (this.groups[groupId].visible == true && (this.linegraphOptions.visibility[groupId] === undefined || this.linegraphOptions.visibility[groupId] == true)) {
          content += this.groups[groupId].content + '<br />';
        }
      }
      this.dom.textArea.innerHTML = content;
      this.dom.textArea.style.lineHeight = 0.75 * this.options.iconSize + this.options.iconSpacing + 'px';
    }
  };

  Legend.prototype.drawLegendIcons = function () {
    if (this.dom.frame.parentNode) {
      var groupArray = Object.keys(this.groups);
      groupArray.sort(function (a, b) {
        return a < b ? -1 : 1;
      });

      // this resets the elements so the order is maintained
      DOMutil.resetElements(this.svgElements);

      var padding = window.getComputedStyle(this.dom.frame).paddingTop;
      var iconOffset = Number(padding.replace('px', ''));
      var x = iconOffset;
      var iconWidth = this.options.iconSize;
      var iconHeight = 0.75 * this.options.iconSize;
      var y = iconOffset + 0.5 * iconHeight + 3;

      this.svg.style.width = iconWidth + 5 + iconOffset + 'px';

      for (var i = 0; i < groupArray.length; i++) {
        var groupId = groupArray[i];
        if (this.groups[groupId].visible == true && (this.linegraphOptions.visibility[groupId] === undefined || this.linegraphOptions.visibility[groupId] == true)) {
          this.groups[groupId].getLegend(iconWidth, iconHeight, this.framework, x, y);
          y += iconHeight + this.options.iconSpacing;
        }
      }
    }
  };

  module.exports = Legend;

/***/ },
/* 61 */
/***/ function(module, exports) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /**
   * This object contains all possible options. It will check if the types are correct, if required if the option is one
   * of the allowed values.
   *
   * __any__ means that the name of the property does not matter.
   * __type__ is a required field for all objects and contains the allowed types of all objects
   */
  var string = 'string';
  var boolean = 'boolean';
  var number = 'number';
  var array = 'array';
  var date = 'date';
  var object = 'object'; // should only be in a __type__ property
  var dom = 'dom';
  var moment = 'moment';
  var any = 'any';

  var allOptions = {
    configure: {
      enabled: { boolean: boolean },
      filter: { boolean: boolean, 'function': 'function' },
      container: { dom: dom },
      __type__: { object: object, boolean: boolean, 'function': 'function' }
    },

    //globals :
    yAxisOrientation: { string: ['left', 'right'] },
    defaultGroup: { string: string },
    sort: { boolean: boolean },
    sampling: { boolean: boolean },
    stack: { boolean: boolean },
    graphHeight: { string: string, number: number },
    shaded: {
      enabled: { boolean: boolean },
      orientation: { string: ['bottom', 'top', 'zero', 'group'] }, // top, bottom, zero, group
      groupId: { object: object },
      __type__: { boolean: boolean, object: object }
    },
    style: { string: ['line', 'bar', 'points'] }, // line, bar
    barChart: {
      width: { number: number },
      minWidth: { number: number },
      sideBySide: { boolean: boolean },
      align: { string: ['left', 'center', 'right'] },
      __type__: { object: object }
    },
    interpolation: {
      enabled: { boolean: boolean },
      parametrization: { string: ['centripetal', 'chordal', 'uniform'] }, // uniform (alpha = 0.0), chordal (alpha = 1.0), centripetal (alpha = 0.5)
      alpha: { number: number },
      __type__: { object: object, boolean: boolean }
    },
    drawPoints: {
      enabled: { boolean: boolean },
      onRender: { 'function': 'function' },
      size: { number: number },
      style: { string: ['square', 'circle'] }, // square, circle
      __type__: { object: object, boolean: boolean, 'function': 'function' }
    },
    dataAxis: {
      showMinorLabels: { boolean: boolean },
      showMajorLabels: { boolean: boolean },
      icons: { boolean: boolean },
      width: { string: string, number: number },
      visible: { boolean: boolean },
      alignZeros: { boolean: boolean },
      left: {
        range: { min: { number: number }, max: { number: number }, __type__: { object: object } },
        format: { 'function': 'function' },
        title: { text: { string: string, number: number }, style: { string: string }, __type__: { object: object } },
        __type__: { object: object }
      },
      right: {
        range: { min: { number: number }, max: { number: number }, __type__: { object: object } },
        format: { 'function': 'function' },
        title: { text: { string: string, number: number }, style: { string: string }, __type__: { object: object } },
        __type__: { object: object }
      },
      __type__: { object: object }
    },
    legend: {
      enabled: { boolean: boolean },
      icons: { boolean: boolean },
      left: {
        visible: { boolean: boolean },
        position: { string: ['top-right', 'bottom-right', 'top-left', 'bottom-left'] },
        __type__: { object: object }
      },
      right: {
        visible: { boolean: boolean },
        position: { string: ['top-right', 'bottom-right', 'top-left', 'bottom-left'] },
        __type__: { object: object }
      },
      __type__: { object: object, boolean: boolean }
    },
    groups: {
      visibility: { any: any },
      __type__: { object: object }
    },

    autoResize: { boolean: boolean },
    clickToUse: { boolean: boolean },
    end: { number: number, date: date, string: string, moment: moment },
    format: {
      minorLabels: {
        millisecond: { string: string, 'undefined': 'undefined' },
        second: { string: string, 'undefined': 'undefined' },
        minute: { string: string, 'undefined': 'undefined' },
        hour: { string: string, 'undefined': 'undefined' },
        weekday: { string: string, 'undefined': 'undefined' },
        day: { string: string, 'undefined': 'undefined' },
        month: { string: string, 'undefined': 'undefined' },
        year: { string: string, 'undefined': 'undefined' },
        __type__: { object: object }
      },
      majorLabels: {
        millisecond: { string: string, 'undefined': 'undefined' },
        second: { string: string, 'undefined': 'undefined' },
        minute: { string: string, 'undefined': 'undefined' },
        hour: { string: string, 'undefined': 'undefined' },
        weekday: { string: string, 'undefined': 'undefined' },
        day: { string: string, 'undefined': 'undefined' },
        month: { string: string, 'undefined': 'undefined' },
        year: { string: string, 'undefined': 'undefined' },
        __type__: { object: object }
      },
      __type__: { object: object }
    },
    moment: { 'function': 'function' },
    height: { string: string, number: number },
    hiddenDates: {
      start: { date: date, number: number, string: string, moment: moment },
      end: { date: date, number: number, string: string, moment: moment },
      repeat: { string: string },
      __type__: { object: object, array: array }
    },
    locale: { string: string },
    locales: {
      __any__: { any: any },
      __type__: { object: object }
    },
    max: { date: date, number: number, string: string, moment: moment },
    maxHeight: { number: number, string: string },
    maxMinorChars: { number: number },
    min: { date: date, number: number, string: string, moment: moment },
    minHeight: { number: number, string: string },
    moveable: { boolean: boolean },
    multiselect: { boolean: boolean },
    orientation: { string: string },
    showCurrentTime: { boolean: boolean },
    showMajorLabels: { boolean: boolean },
    showMinorLabels: { boolean: boolean },
    start: { date: date, number: number, string: string, moment: moment },
    timeAxis: {
      scale: { string: string, 'undefined': 'undefined' },
      step: { number: number, 'undefined': 'undefined' },
      __type__: { object: object }
    },
    width: { string: string, number: number },
    zoomable: { boolean: boolean },
    zoomKey: { string: ['ctrlKey', 'altKey', 'metaKey', ''] },
    zoomMax: { number: number },
    zoomMin: { number: number },
    zIndex: { number: number },
    __type__: { object: object }
  };

  var configureOptions = {
    global: {
      //yAxisOrientation: ['left','right'], // TDOO: enable as soon as Grahp2d doesn't crash when changing this on the fly
      sort: true,
      sampling: true,
      stack: false,
      shaded: {
        enabled: false,
        orientation: ['zero', 'top', 'bottom', 'group'] // zero, top, bottom
      },
      style: ['line', 'bar', 'points'], // line, bar
      barChart: {
        width: [50, 5, 100, 5],
        minWidth: [50, 5, 100, 5],
        sideBySide: false,
        align: ['left', 'center', 'right'] // left, center, right
      },
      interpolation: {
        enabled: true,
        parametrization: ['centripetal', 'chordal', 'uniform'] // uniform (alpha = 0.0), chordal (alpha = 1.0), centripetal (alpha = 0.5)
      },
      drawPoints: {
        enabled: true,
        size: [6, 2, 30, 1],
        style: ['square', 'circle'] // square, circle
      },
      dataAxis: {
        showMinorLabels: true,
        showMajorLabels: true,
        icons: false,
        width: [40, 0, 200, 1],
        visible: true,
        alignZeros: true,
        left: {
          //range: {min:'undefined': 'undefined'ined,max:'undefined': 'undefined'ined},
          //format: function (value) {return value;},
          title: { text: '', style: '' }
        },
        right: {
          //range: {min:'undefined': 'undefined'ined,max:'undefined': 'undefined'ined},
          //format: function (value) {return value;},
          title: { text: '', style: '' }
        }
      },
      legend: {
        enabled: false,
        icons: true,
        left: {
          visible: true,
          position: ['top-right', 'bottom-right', 'top-left', 'bottom-left'] // top/bottom - left,right
        },
        right: {
          visible: true,
          position: ['top-right', 'bottom-right', 'top-left', 'bottom-left'] // top/bottom - left,right
        }
      },

      autoResize: true,
      clickToUse: false,
      end: '',
      format: {
        minorLabels: {
          millisecond: 'SSS',
          second: 's',
          minute: 'HH:mm',
          hour: 'HH:mm',
          weekday: 'ddd D',
          day: 'D',
          month: 'MMM',
          year: 'YYYY'
        },
        majorLabels: {
          millisecond: 'HH:mm:ss',
          second: 'D MMMM HH:mm',
          minute: 'ddd D MMMM',
          hour: 'ddd D MMMM',
          weekday: 'MMMM YYYY',
          day: 'MMMM YYYY',
          month: 'YYYY',
          year: ''
        }
      },

      height: '',
      locale: '',
      max: '',
      maxHeight: '',
      maxMinorChars: [7, 0, 20, 1],
      min: '',
      minHeight: '',
      moveable: true,
      orientation: ['both', 'bottom', 'top'],
      showCurrentTime: false,
      showMajorLabels: true,
      showMinorLabels: true,
      start: '',
      width: '100%',
      zoomable: true,
      zoomKey: ['ctrlKey', 'altKey', 'metaKey', ''],
      zoomMax: [315360000000000, 10, 315360000000000, 1],
      zoomMin: [10, 10, 315360000000000, 1],
      zIndex: 0
    }
  };

  exports.allOptions = allOptions;
  exports.configureOptions = configureOptions;

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  // utils
  exports.util = __webpack_require__(1);
  exports.DOMutil = __webpack_require__(8);

  // data
  exports.DataSet = __webpack_require__(9);
  exports.DataView = __webpack_require__(11);
  exports.Queue = __webpack_require__(10);

  // Network
  exports.Network = __webpack_require__(63);
  exports.network = {
    Images: __webpack_require__(64),
    dotparser: __webpack_require__(120),
    gephiParser: __webpack_require__(121),
    allOptions: __webpack_require__(116)
  };
  exports.network.convertDot = function (input) {
    return exports.network.dotparser.DOTToGraph(input);
  };
  exports.network.convertGephi = function (input, options) {
    return exports.network.gephiParser.parseGephi(input, options);
  };

  // bundled external libraries
  exports.moment = __webpack_require__(2);
  exports.Hammer = __webpack_require__(22);
  exports.keycharm = __webpack_require__(25);

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _Images = __webpack_require__(64);

  var _Images2 = _interopRequireDefault(_Images);

  var _Groups = __webpack_require__(65);

  var _Groups2 = _interopRequireDefault(_Groups);

  var _NodesHandler = __webpack_require__(66);

  var _NodesHandler2 = _interopRequireDefault(_NodesHandler);

  var _EdgesHandler = __webpack_require__(86);

  var _EdgesHandler2 = _interopRequireDefault(_EdgesHandler);

  var _PhysicsEngine = __webpack_require__(95);

  var _PhysicsEngine2 = _interopRequireDefault(_PhysicsEngine);

  var _Clustering = __webpack_require__(104);

  var _Clustering2 = _interopRequireDefault(_Clustering);

  var _CanvasRenderer = __webpack_require__(107);

  var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

  var _Canvas = __webpack_require__(108);

  var _Canvas2 = _interopRequireDefault(_Canvas);

  var _View = __webpack_require__(109);

  var _View2 = _interopRequireDefault(_View);

  var _InteractionHandler = __webpack_require__(110);

  var _InteractionHandler2 = _interopRequireDefault(_InteractionHandler);

  var _SelectionHandler = __webpack_require__(113);

  var _SelectionHandler2 = _interopRequireDefault(_SelectionHandler);

  var _LayoutEngine = __webpack_require__(114);

  var _LayoutEngine2 = _interopRequireDefault(_LayoutEngine);

  var _ManipulationSystem = __webpack_require__(115);

  var _ManipulationSystem2 = _interopRequireDefault(_ManipulationSystem);

  var _Configurator = __webpack_require__(28);

  var _Configurator2 = _interopRequireDefault(_Configurator);

  var _Validator = __webpack_require__(31);

  var _Validator2 = _interopRequireDefault(_Validator);

  var _options = __webpack_require__(116);

  var _KamadaKawai = __webpack_require__(117);

  var _KamadaKawai2 = _interopRequireDefault(_KamadaKawai);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  // Load custom shapes into CanvasRenderingContext2D
  __webpack_require__(119);

  var Emitter = __webpack_require__(13);
  var util = __webpack_require__(1);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);
  var dotparser = __webpack_require__(120);
  var gephiParser = __webpack_require__(121);
  var Activator = __webpack_require__(47);
  var locales = __webpack_require__(122);

  /**
   * @constructor Network
   * Create a network visualization, displaying nodes and edges.
   *
   * @param {Element} container   The DOM element in which the Network will
   *                                  be created. Normally a div element.
   * @param {Object} data         An object containing parameters
   *                              {Array} nodes
   *                              {Array} edges
   * @param {Object} options      Options
   */
  function Network(container, data, options) {
    var _this = this;

    if (!(this instanceof Network)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // set constant values
    this.options = {};
    this.defaultOptions = {
      locale: 'en',
      locales: locales,
      clickToUse: false
    };
    util.extend(this.options, this.defaultOptions);

    // containers for nodes and edges
    this.body = {
      container: container,
      nodes: {},
      nodeIndices: [],
      edges: {},
      edgeIndices: [],
      emitter: {
        on: this.on.bind(this),
        off: this.off.bind(this),
        emit: this.emit.bind(this),
        once: this.once.bind(this)
      },
      eventListeners: {
        onTap: function onTap() {},
        onTouch: function onTouch() {},
        onDoubleTap: function onDoubleTap() {},
        onHold: function onHold() {},
        onDragStart: function onDragStart() {},
        onDrag: function onDrag() {},
        onDragEnd: function onDragEnd() {},
        onMouseWheel: function onMouseWheel() {},
        onPinch: function onPinch() {},
        onMouseMove: function onMouseMove() {},
        onRelease: function onRelease() {},
        onContext: function onContext() {}
      },
      data: {
        nodes: null, // A DataSet or DataView
        edges: null // A DataSet or DataView
      },
      functions: {
        createNode: function createNode() {},
        createEdge: function createEdge() {},
        getPointer: function getPointer() {}
      },
      modules: {},
      view: {
        scale: 1,
        translation: { x: 0, y: 0 }
      }
    };

    // bind the event listeners
    this.bindEventListeners();

    // setting up all modules
    this.images = new _Images2.default(function () {
      return _this.body.emitter.emit("_requestRedraw");
    }); // object with images
    this.groups = new _Groups2.default(); // object with groups
    this.canvas = new _Canvas2.default(this.body); // DOM handler
    this.selectionHandler = new _SelectionHandler2.default(this.body, this.canvas); // Selection handler
    this.interactionHandler = new _InteractionHandler2.default(this.body, this.canvas, this.selectionHandler); // Interaction handler handles all the hammer bindings (that are bound by canvas), key
    this.view = new _View2.default(this.body, this.canvas); // camera handler, does animations and zooms
    this.renderer = new _CanvasRenderer2.default(this.body, this.canvas); // renderer, starts renderloop, has events that modules can hook into
    this.physics = new _PhysicsEngine2.default(this.body); // physics engine, does all the simulations
    this.layoutEngine = new _LayoutEngine2.default(this.body); // layout engine for inital layout and hierarchical layout
    this.clustering = new _Clustering2.default(this.body); // clustering api
    this.manipulation = new _ManipulationSystem2.default(this.body, this.canvas, this.selectionHandler); // data manipulation system

    this.nodesHandler = new _NodesHandler2.default(this.body, this.images, this.groups, this.layoutEngine); // Handle adding, deleting and updating of nodes as well as global options
    this.edgesHandler = new _EdgesHandler2.default(this.body, this.images, this.groups); // Handle adding, deleting and updating of edges as well as global options

    this.body.modules["kamadaKawai"] = new _KamadaKawai2.default(this.body, 150, 0.05); // Layouting algorithm.
    this.body.modules["clustering"] = this.clustering;

    // create the DOM elements
    this.canvas._create();

    // apply options
    this.setOptions(options);

    // load data (the disable start variable will be the same as the enabled clustering)
    this.setData(data);
  }

  // Extend Network with an Emitter mixin
  Emitter(Network.prototype);

  /**
   * Set options
   * @param {Object} options
   */
  Network.prototype.setOptions = function (options) {
    var _this2 = this;

    if (options !== undefined) {
      var errorFound = _Validator2.default.validate(options, _options.allOptions);
      if (errorFound === true) {
        console.log('%cErrors have been found in the supplied options object.', _Validator.printStyle);
      }

      // copy the global fields over
      var fields = ['locale', 'locales', 'clickToUse'];
      util.selectiveDeepExtend(fields, this.options, options);

      // the hierarchical system can adapt the edges and the physics to it's own options because not all combinations work with the hierarichical system.
      options = this.layoutEngine.setOptions(options.layout, options);

      this.canvas.setOptions(options); // options for canvas are in globals

      // pass the options to the modules
      this.groups.setOptions(options.groups);
      this.nodesHandler.setOptions(options.nodes);
      this.edgesHandler.setOptions(options.edges);
      this.physics.setOptions(options.physics);
      this.manipulation.setOptions(options.manipulation, options, this.options); // manipulation uses the locales in the globals

      this.interactionHandler.setOptions(options.interaction);
      this.renderer.setOptions(options.interaction); // options for rendering are in interaction
      this.selectionHandler.setOptions(options.interaction); // options for selection are in interaction

      // reload the settings of the nodes to apply changes in groups that are not referenced by pointer.
      if (options.groups !== undefined) {
        this.body.emitter.emit("refreshNodes");
      }
      // these two do not have options at the moment, here for completeness
      //this.view.setOptions(options.view);
      //this.clustering.setOptions(options.clustering);

      if ('configure' in options) {
        if (!this.configurator) {
          this.configurator = new _Configurator2.default(this, this.body.container, _options.configureOptions, this.canvas.pixelRatio);
        }

        this.configurator.setOptions(options.configure);
      }

      // if the configuration system is enabled, copy all options and put them into the config system
      if (this.configurator && this.configurator.options.enabled === true) {
        var networkOptions = { nodes: {}, edges: {}, layout: {}, interaction: {}, manipulation: {}, physics: {}, global: {} };
        util.deepExtend(networkOptions.nodes, this.nodesHandler.options);
        util.deepExtend(networkOptions.edges, this.edgesHandler.options);
        util.deepExtend(networkOptions.layout, this.layoutEngine.options);
        // load the selectionHandler and render default options in to the interaction group
        util.deepExtend(networkOptions.interaction, this.selectionHandler.options);
        util.deepExtend(networkOptions.interaction, this.renderer.options);

        util.deepExtend(networkOptions.interaction, this.interactionHandler.options);
        util.deepExtend(networkOptions.manipulation, this.manipulation.options);
        util.deepExtend(networkOptions.physics, this.physics.options);

        // load globals into the global object
        util.deepExtend(networkOptions.global, this.canvas.options);
        util.deepExtend(networkOptions.global, this.options);

        this.configurator.setModuleOptions(networkOptions);
      }

      // handle network global options
      if (options.clickToUse !== undefined) {
        if (options.clickToUse === true) {
          if (this.activator === undefined) {
            this.activator = new Activator(this.canvas.frame);
            this.activator.on('change', function () {
              _this2.body.emitter.emit("activate");
            });
          }
        } else {
          if (this.activator !== undefined) {
            this.activator.destroy();
            delete this.activator;
          }
          this.body.emitter.emit("activate");
        }
      } else {
        this.body.emitter.emit("activate");
      }

      this.canvas.setSize();
      // start the physics simulation. Can be safely called multiple times.
      this.body.emitter.emit("startSimulation");
    }
  };

  /**
   * Update the this.body.nodeIndices with the most recent node index list
   * @private
   */
  Network.prototype._updateVisibleIndices = function () {
    var nodes = this.body.nodes;
    var edges = this.body.edges;
    this.body.nodeIndices = [];
    this.body.edgeIndices = [];

    for (var nodeId in nodes) {
      if (nodes.hasOwnProperty(nodeId)) {
        if (nodes[nodeId].options.hidden === false) {
          this.body.nodeIndices.push(nodes[nodeId].id);
        }
      }
    }

    for (var edgeId in edges) {
      if (edges.hasOwnProperty(edgeId)) {
        if (edges[edgeId].options.hidden === false) {
          this.body.edgeIndices.push(edges[edgeId].id);
        }
      }
    }
  };

  /**
   * Bind all events
   */
  Network.prototype.bindEventListeners = function () {
    var _this3 = this;

    // this event will trigger a rebuilding of the cache everything. Used when nodes or edges have been added or removed.
    this.body.emitter.on("_dataChanged", function () {
      // update shortcut lists
      _this3._updateVisibleIndices();
      _this3.body.emitter.emit("_requestRedraw");
      // call the dataUpdated event because the only difference between the two is the updating of the indices
      _this3.body.emitter.emit("_dataUpdated");
    });

    // this is called when options of EXISTING nodes or edges have changed.
    this.body.emitter.on("_dataUpdated", function () {
      // update values
      _this3._updateValueRange(_this3.body.nodes);
      _this3._updateValueRange(_this3.body.edges);
      // start simulation (can be called safely, even if already running)
      _this3.body.emitter.emit("startSimulation");
      _this3.body.emitter.emit("_requestRedraw");
    });
  };

  /**
   * Set nodes and edges, and optionally options as well.
   *
   * @param {Object} data              Object containing parameters:
   *                                   {Array | DataSet | DataView} [nodes] Array with nodes
   *                                   {Array | DataSet | DataView} [edges] Array with edges
   *                                   {String} [dot] String containing data in DOT format
   *                                   {String} [gephi] String containing data in gephi JSON format
   *                                   {Options} [options] Object with options
   */
  Network.prototype.setData = function (data) {
    // reset the physics engine.
    this.body.emitter.emit("resetPhysics");
    this.body.emitter.emit("_resetData");

    // unselect all to ensure no selections from old data are carried over.
    this.selectionHandler.unselectAll();

    if (data && data.dot && (data.nodes || data.edges)) {
      throw new SyntaxError('Data must contain either parameter "dot" or ' + ' parameter pair "nodes" and "edges", but not both.');
    }

    // set options
    this.setOptions(data && data.options);
    // set all data
    if (data && data.dot) {
      console.log('The dot property has been deprecated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);');
      // parse DOT file
      var dotData = dotparser.DOTToGraph(data.dot);
      this.setData(dotData);
      return;
    } else if (data && data.gephi) {
      // parse DOT file
      console.log('The gephi property has been deprecated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);');
      var gephiData = gephiParser.parseGephi(data.gephi);
      this.setData(gephiData);
      return;
    } else {
      this.nodesHandler.setData(data && data.nodes, true);
      this.edgesHandler.setData(data && data.edges, true);
    }

    // emit change in data
    this.body.emitter.emit("_dataChanged");

    // emit data loaded
    this.body.emitter.emit("_dataLoaded");

    // find a stable position or start animating to a stable position
    this.body.emitter.emit("initPhysics");
  };

  /**
   * Cleans up all bindings of the network, removing it fully from the memory IF the variable is set to null after calling this function.
   * var network = new vis.Network(..);
   * network.destroy();
   * network = null;
   */
  Network.prototype.destroy = function () {
    this.body.emitter.emit("destroy");
    // clear events
    this.body.emitter.off();
    this.off();

    // delete modules
    delete this.groups;
    delete this.canvas;
    delete this.selectionHandler;
    delete this.interactionHandler;
    delete this.view;
    delete this.renderer;
    delete this.physics;
    delete this.layoutEngine;
    delete this.clustering;
    delete this.manipulation;
    delete this.nodesHandler;
    delete this.edgesHandler;
    delete this.configurator;
    delete this.images;

    for (var nodeId in this.body.nodes) {
      delete this.body.nodes[nodeId];
    }
    for (var edgeId in this.body.edges) {
      delete this.body.edges[edgeId];
    }

    // remove the container and everything inside it recursively
    util.recursiveDOMDelete(this.body.container);
  };

  /**
   * Update the values of all object in the given array according to the current
   * value range of the objects in the array.
   * @param {Object} obj    An object containing a set of Edges or Nodes
   *                        The objects must have a method getValue() and
   *                        setValueRange(min, max).
   * @private
   */
  Network.prototype._updateValueRange = function (obj) {
    var id;

    // determine the range of the objects
    var valueMin = undefined;
    var valueMax = undefined;
    var valueTotal = 0;
    for (id in obj) {
      if (obj.hasOwnProperty(id)) {
        var value = obj[id].getValue();
        if (value !== undefined) {
          valueMin = valueMin === undefined ? value : Math.min(value, valueMin);
          valueMax = valueMax === undefined ? value : Math.max(value, valueMax);
          valueTotal += value;
        }
      }
    }

    // adjust the range of all objects
    if (valueMin !== undefined && valueMax !== undefined) {
      for (id in obj) {
        if (obj.hasOwnProperty(id)) {
          obj[id].setValueRange(valueMin, valueMax, valueTotal);
        }
      }
    }
  };

  /**
   * Returns true when the Network is active.
   * @returns {boolean}
   */
  Network.prototype.isActive = function () {
    return !this.activator || this.activator.active;
  };

  Network.prototype.setSize = function () {
    return this.canvas.setSize.apply(this.canvas, arguments);
  };
  Network.prototype.canvasToDOM = function () {
    return this.canvas.canvasToDOM.apply(this.canvas, arguments);
  };
  Network.prototype.DOMtoCanvas = function () {
    return this.canvas.DOMtoCanvas.apply(this.canvas, arguments);
  };
  Network.prototype.findNode = function () {
    return this.clustering.findNode.apply(this.clustering, arguments);
  };
  Network.prototype.isCluster = function () {
    return this.clustering.isCluster.apply(this.clustering, arguments);
  };
  Network.prototype.openCluster = function () {
    return this.clustering.openCluster.apply(this.clustering, arguments);
  };
  Network.prototype.cluster = function () {
    return this.clustering.cluster.apply(this.clustering, arguments);
  };
  Network.prototype.getNodesInCluster = function () {
    return this.clustering.getNodesInCluster.apply(this.clustering, arguments);
  };
  Network.prototype.clusterByConnection = function () {
    return this.clustering.clusterByConnection.apply(this.clustering, arguments);
  };
  Network.prototype.clusterByHubsize = function () {
    return this.clustering.clusterByHubsize.apply(this.clustering, arguments);
  };
  Network.prototype.clusterOutliers = function () {
    return this.clustering.clusterOutliers.apply(this.clustering, arguments);
  };
  Network.prototype.getSeed = function () {
    return this.layoutEngine.getSeed.apply(this.layoutEngine, arguments);
  };
  Network.prototype.enableEditMode = function () {
    return this.manipulation.enableEditMode.apply(this.manipulation, arguments);
  };
  Network.prototype.disableEditMode = function () {
    return this.manipulation.disableEditMode.apply(this.manipulation, arguments);
  };
  Network.prototype.addNodeMode = function () {
    return this.manipulation.addNodeMode.apply(this.manipulation, arguments);
  };
  Network.prototype.editNode = function () {
    return this.manipulation.editNode.apply(this.manipulation, arguments);
  };
  Network.prototype.editNodeMode = function () {
    console.log("Deprecated: Please use editNode instead of editNodeMode.");return this.manipulation.editNode.apply(this.manipulation, arguments);
  };
  Network.prototype.addEdgeMode = function () {
    return this.manipulation.addEdgeMode.apply(this.manipulation, arguments);
  };
  Network.prototype.editEdgeMode = function () {
    return this.manipulation.editEdgeMode.apply(this.manipulation, arguments);
  };
  Network.prototype.deleteSelected = function () {
    return this.manipulation.deleteSelected.apply(this.manipulation, arguments);
  };
  Network.prototype.getPositions = function () {
    return this.nodesHandler.getPositions.apply(this.nodesHandler, arguments);
  };
  Network.prototype.storePositions = function () {
    return this.nodesHandler.storePositions.apply(this.nodesHandler, arguments);
  };
  Network.prototype.moveNode = function () {
    return this.nodesHandler.moveNode.apply(this.nodesHandler, arguments);
  };
  Network.prototype.getBoundingBox = function () {
    return this.nodesHandler.getBoundingBox.apply(this.nodesHandler, arguments);
  };
  Network.prototype.getConnectedNodes = function (objectId) {
    if (this.body.nodes[objectId] !== undefined) {
      return this.nodesHandler.getConnectedNodes.apply(this.nodesHandler, arguments);
    } else {
      return this.edgesHandler.getConnectedNodes.apply(this.edgesHandler, arguments);
    }
  };
  Network.prototype.getConnectedEdges = function () {
    return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler, arguments);
  };
  Network.prototype.startSimulation = function () {
    return this.physics.startSimulation.apply(this.physics, arguments);
  };
  Network.prototype.stopSimulation = function () {
    return this.physics.stopSimulation.apply(this.physics, arguments);
  };
  Network.prototype.stabilize = function () {
    return this.physics.stabilize.apply(this.physics, arguments);
  };
  Network.prototype.getSelection = function () {
    return this.selectionHandler.getSelection.apply(this.selectionHandler, arguments);
  };
  Network.prototype.setSelection = function () {
    return this.selectionHandler.setSelection.apply(this.selectionHandler, arguments);
  };
  Network.prototype.getSelectedNodes = function () {
    return this.selectionHandler.getSelectedNodes.apply(this.selectionHandler, arguments);
  };
  Network.prototype.getSelectedEdges = function () {
    return this.selectionHandler.getSelectedEdges.apply(this.selectionHandler, arguments);
  };
  Network.prototype.getNodeAt = function () {
    var node = this.selectionHandler.getNodeAt.apply(this.selectionHandler, arguments);
    if (node !== undefined && node.id !== undefined) {
      return node.id;
    }
    return node;
  };
  Network.prototype.getEdgeAt = function () {
    var edge = this.selectionHandler.getEdgeAt.apply(this.selectionHandler, arguments);
    if (edge !== undefined && edge.id !== undefined) {
      return edge.id;
    }
    return edge;
  };
  Network.prototype.selectNodes = function () {
    return this.selectionHandler.selectNodes.apply(this.selectionHandler, arguments);
  };
  Network.prototype.selectEdges = function () {
    return this.selectionHandler.selectEdges.apply(this.selectionHandler, arguments);
  };
  Network.prototype.unselectAll = function () {
    this.selectionHandler.unselectAll.apply(this.selectionHandler, arguments);
    this.redraw();
  };
  Network.prototype.redraw = function () {
    return this.renderer.redraw.apply(this.renderer, arguments);
  };
  Network.prototype.getScale = function () {
    return this.view.getScale.apply(this.view, arguments);
  };
  Network.prototype.getViewPosition = function () {
    return this.view.getViewPosition.apply(this.view, arguments);
  };
  Network.prototype.fit = function () {
    return this.view.fit.apply(this.view, arguments);
  };
  Network.prototype.moveTo = function () {
    return this.view.moveTo.apply(this.view, arguments);
  };
  Network.prototype.focus = function () {
    return this.view.focus.apply(this.view, arguments);
  };
  Network.prototype.releaseNode = function () {
    return this.view.releaseNode.apply(this.view, arguments);
  };
  Network.prototype.getOptionsFromConfigurator = function () {
    var options = {};
    if (this.configurator) {
      options = this.configurator.getOptions.apply(this.configurator);
    }
    return options;
  };

  module.exports = Network;

/***/ },
/* 64 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
      value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  /**
   * @class Images
   * This class loads images and keeps them stored.
   */
  var Images = function () {
      function Images(callback) {
          _classCallCheck(this, Images);

          this.images = {};
          this.imageBroken = {};
          this.callback = callback;
      }

      /**
       * @param {string} url                      The Url to cache the image as 
        * @return {Image} imageToLoadBrokenUrlOn  The image object
       */


      _createClass(Images, [{
          key: "_addImageToCache",
          value: function _addImageToCache(url, imageToCache) {
              // IE11 fix -- thanks dponch!
              if (imageToCache.width === 0) {
                  document.body.appendChild(imageToCache);
                  imageToCache.width = imageToCache.offsetWidth;
                  imageToCache.height = imageToCache.offsetHeight;
                  document.body.removeChild(imageToCache);
              }

              this.images[url] = imageToCache;
          }

          /**
           * @param {string} url                      The original Url that failed to load, if the broken image is successfully loaded it will be added to the cache using this Url as the key so that subsequent requests for this Url will return the broken image
           * @param {string} brokenUrl                Url the broken image to try and load
           * @return {Image} imageToLoadBrokenUrlOn   The image object
           */

      }, {
          key: "_tryloadBrokenUrl",
          value: function _tryloadBrokenUrl(url, brokenUrl, imageToLoadBrokenUrlOn) {
              var _this = this;

              //If any of the parameters aren't specified then exit the function because nothing constructive can be done
              if (url === undefined || brokenUrl === undefined || imageToLoadBrokenUrlOn === undefined) return;

              //Clear the old subscription to the error event and put a new in place that only handle errors in loading the brokenImageUrl
              imageToLoadBrokenUrlOn.onerror = function () {
                  console.error("Could not load brokenImage:", brokenUrl);
                  //Add an empty image to the cache so that when subsequent load calls are made for the url we don't try load the image and broken image again
                  _this._addImageToCache(url, new Image());
              };

              //Set the source of the image to the brokenUrl, this is actually what kicks off the loading of the broken image
              imageToLoadBrokenUrlOn.src = brokenUrl;
          }

          /**
           * @return {Image} imageToRedrawWith The images that will be passed to the callback when it is invoked
           */

      }, {
          key: "_redrawWithImage",
          value: function _redrawWithImage(imageToRedrawWith) {
              if (this.callback) {
                  this.callback(imageToRedrawWith);
              }
          }

          /**
           * @param {string} url          Url of the image
           * @param {string} brokenUrl    Url of an image to use if the url image is not found
           * @return {Image} img          The image object
           */

      }, {
          key: "load",
          value: function load(url, brokenUrl, id) {
              var _this2 = this;

              //Try and get the image from the cache, if successful then return the cached image   
              var cachedImage = this.images[url];
              if (cachedImage) return cachedImage;

              //Create a new image
              var img = new Image();

              //Subscribe to the event that is raised if the image loads successfully 
              img.onload = function () {
                  //Add the image to the cache and then request a redraw
                  _this2._addImageToCache(url, img);
                  _this2._redrawWithImage(img);
              };

              //Subscribe to the event that is raised if the image fails to load
              img.onerror = function () {
                  console.error("Could not load image:", url);
                  //Try and load the image specified by the brokenUrl using
                  _this2._tryloadBrokenUrl(url, brokenUrl, img);
              };

              //Set the source of the image to the url, this is actuall what kicks off the loading of the image
              img.src = url;

              //Return the new image
              return img;
          }
      }]);

      return Images;
  }();

  exports.default = Images;

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  /**
   * @class Groups
   * This class can store groups and options specific for groups.
   */

  var Groups = function () {
    function Groups() {
      _classCallCheck(this, Groups);

      this.clear();
      this.defaultIndex = 0;
      this.groupsArray = [];
      this.groupIndex = 0;

      this.defaultGroups = [{ border: "#2B7CE9", background: "#97C2FC", highlight: { border: "#2B7CE9", background: "#D2E5FF" }, hover: { border: "#2B7CE9", background: "#D2E5FF" } }, // 0: blue
      { border: "#FFA500", background: "#FFFF00", highlight: { border: "#FFA500", background: "#FFFFA3" }, hover: { border: "#FFA500", background: "#FFFFA3" } }, // 1: yellow
      { border: "#FA0A10", background: "#FB7E81", highlight: { border: "#FA0A10", background: "#FFAFB1" }, hover: { border: "#FA0A10", background: "#FFAFB1" } }, // 2: red
      { border: "#41A906", background: "#7BE141", highlight: { border: "#41A906", background: "#A1EC76" }, hover: { border: "#41A906", background: "#A1EC76" } }, // 3: green
      { border: "#E129F0", background: "#EB7DF4", highlight: { border: "#E129F0", background: "#F0B3F5" }, hover: { border: "#E129F0", background: "#F0B3F5" } }, // 4: magenta
      { border: "#7C29F0", background: "#AD85E4", highlight: { border: "#7C29F0", background: "#D3BDF0" }, hover: { border: "#7C29F0", background: "#D3BDF0" } }, // 5: purple
      { border: "#C37F00", background: "#FFA807", highlight: { border: "#C37F00", background: "#FFCA66" }, hover: { border: "#C37F00", background: "#FFCA66" } }, // 6: orange
      { border: "#4220FB", background: "#6E6EFD", highlight: { border: "#4220FB", background: "#9B9BFD" }, hover: { border: "#4220FB", background: "#9B9BFD" } }, // 7: darkblue
      { border: "#FD5A77", background: "#FFC0CB", highlight: { border: "#FD5A77", background: "#FFD1D9" }, hover: { border: "#FD5A77", background: "#FFD1D9" } }, // 8: pink
      { border: "#4AD63A", background: "#C2FABC", highlight: { border: "#4AD63A", background: "#E6FFE3" }, hover: { border: "#4AD63A", background: "#E6FFE3" } }, // 9: mint

      { border: "#990000", background: "#EE0000", highlight: { border: "#BB0000", background: "#FF3333" }, hover: { border: "#BB0000", background: "#FF3333" } }, // 10:bright red

      { border: "#FF6000", background: "#FF6000", highlight: { border: "#FF6000", background: "#FF6000" }, hover: { border: "#FF6000", background: "#FF6000" } }, // 12: real orange
      { border: "#97C2FC", background: "#2B7CE9", highlight: { border: "#D2E5FF", background: "#2B7CE9" }, hover: { border: "#D2E5FF", background: "#2B7CE9" } }, // 13: blue
      { border: "#399605", background: "#255C03", highlight: { border: "#399605", background: "#255C03" }, hover: { border: "#399605", background: "#255C03" } }, // 14: green
      { border: "#B70054", background: "#FF007E", highlight: { border: "#B70054", background: "#FF007E" }, hover: { border: "#B70054", background: "#FF007E" } }, // 15: magenta
      { border: "#AD85E4", background: "#7C29F0", highlight: { border: "#D3BDF0", background: "#7C29F0" }, hover: { border: "#D3BDF0", background: "#7C29F0" } }, // 16: purple
      { border: "#4557FA", background: "#000EA1", highlight: { border: "#6E6EFD", background: "#000EA1" }, hover: { border: "#6E6EFD", background: "#000EA1" } }, // 17: darkblue
      { border: "#FFC0CB", background: "#FD5A77", highlight: { border: "#FFD1D9", background: "#FD5A77" }, hover: { border: "#FFD1D9", background: "#FD5A77" } }, // 18: pink
      { border: "#C2FABC", background: "#74D66A", highlight: { border: "#E6FFE3", background: "#74D66A" }, hover: { border: "#E6FFE3", background: "#74D66A" } }, // 19: mint

      { border: "#EE0000", background: "#990000", highlight: { border: "#FF3333", background: "#BB0000" }, hover: { border: "#FF3333", background: "#BB0000" } } // 20:bright red
      ];

      this.options = {};
      this.defaultOptions = {
        useDefaultGroups: true
      };
      util.extend(this.options, this.defaultOptions);
    }

    _createClass(Groups, [{
      key: "setOptions",
      value: function setOptions(options) {
        var optionFields = ['useDefaultGroups'];

        if (options !== undefined) {
          for (var groupName in options) {
            if (options.hasOwnProperty(groupName)) {
              if (optionFields.indexOf(groupName) === -1) {
                var group = options[groupName];
                this.add(groupName, group);
              }
            }
          }
        }
      }

      /**
       * Clear all groups
       */

    }, {
      key: "clear",
      value: function clear() {
        this.groups = {};
        this.groupsArray = [];
      }

      /**
       * get group options of a groupname. If groupname is not found, a new group
       * is added.
       * @param {*} groupname        Can be a number, string, Date, etc.
       * @return {Object} group      The created group, containing all group options
       */

    }, {
      key: "get",
      value: function get(groupname) {
        var group = this.groups[groupname];
        if (group === undefined) {
          if (this.options.useDefaultGroups === false && this.groupsArray.length > 0) {
            // create new group
            var index = this.groupIndex % this.groupsArray.length;
            this.groupIndex++;
            group = {};
            group.color = this.groups[this.groupsArray[index]];
            this.groups[groupname] = group;
          } else {
            // create new group
            var _index = this.defaultIndex % this.defaultGroups.length;
            this.defaultIndex++;
            group = {};
            group.color = this.defaultGroups[_index];
            this.groups[groupname] = group;
          }
        }

        return group;
      }

      /**
       * Add a custom group style
       * @param {String} groupName
       * @param {Object} style       An object containing borderColor,
       *                             backgroundColor, etc.
       * @return {Object} group      The created group object
       */

    }, {
      key: "add",
      value: function add(groupName, style) {
        this.groups[groupName] = style;
        this.groupsArray.push(groupName);
        return style;
      }
    }]);

    return Groups;
  }();

  exports.default = Groups;

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _Node = __webpack_require__(67);

  var _Node2 = _interopRequireDefault(_Node);

  var _Label = __webpack_require__(68);

  var _Label2 = _interopRequireDefault(_Label);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);

  var NodesHandler = function () {
    function NodesHandler(body, images, groups, layoutEngine) {
      var _this = this;

      _classCallCheck(this, NodesHandler);

      this.body = body;
      this.images = images;
      this.groups = groups;
      this.layoutEngine = layoutEngine;

      // create the node API in the body container
      this.body.functions.createNode = this.create.bind(this);

      this.nodesListeners = {
        add: function add(event, params) {
          _this.add(params.items);
        },
        update: function update(event, params) {
          _this.update(params.items, params.data);
        },
        remove: function remove(event, params) {
          _this.remove(params.items);
        }
      };

      this.options = {};
      this.defaultOptions = {
        borderWidth: 1,
        borderWidthSelected: 2,
        brokenImage: undefined,
        color: {
          border: '#2B7CE9',
          background: '#97C2FC',
          highlight: {
            border: '#2B7CE9',
            background: '#D2E5FF'
          },
          hover: {
            border: '#2B7CE9',
            background: '#D2E5FF'
          }
        },
        fixed: {
          x: false,
          y: false
        },
        font: {
          color: '#343434',
          size: 14, // px
          face: 'arial',
          background: 'none',
          strokeWidth: 0, // px
          strokeColor: '#ffffff',
          align: 'center'
        },
        group: undefined,
        hidden: false,
        icon: {
          face: 'FontAwesome', //'FontAwesome',
          code: undefined, //'\uf007',
          size: 50, //50,
          color: '#2B7CE9' //'#aa00ff'
        },
        image: undefined, // --> URL
        label: undefined,
        labelHighlightBold: true,
        level: undefined,
        mass: 1,
        physics: true,
        scaling: {
          min: 10,
          max: 30,
          label: {
            enabled: false,
            min: 14,
            max: 30,
            maxVisible: 30,
            drawThreshold: 5
          },
          customScalingFunction: function customScalingFunction(min, max, total, value) {
            if (max === min) {
              return 0.5;
            } else {
              var scale = 1 / (max - min);
              return Math.max(0, (value - min) * scale);
            }
          }
        },
        shadow: {
          enabled: false,
          color: 'rgba(0,0,0,0.5)',
          size: 10,
          x: 5,
          y: 5
        },
        shape: 'ellipse',
        shapeProperties: {
          borderDashes: false, // only for borders
          borderRadius: 6, // only for box shape
          interpolation: true, // only for image and circularImage shapes
          useImageSize: false, // only for image and circularImage shapes
          useBorderWithImage: false // only for image shape
        },
        size: 25,
        title: undefined,
        value: undefined,
        x: undefined,
        y: undefined
      };
      util.extend(this.options, this.defaultOptions);

      this.bindEventListeners();
    }

    _createClass(NodesHandler, [{
      key: 'bindEventListeners',
      value: function bindEventListeners() {
        var _this2 = this;

        // refresh the nodes. Used when reverting from hierarchical layout
        this.body.emitter.on('refreshNodes', this.refresh.bind(this));
        this.body.emitter.on('refresh', this.refresh.bind(this));
        this.body.emitter.on('destroy', function () {
          util.forEach(_this2.nodesListeners, function (callback, event) {
            if (_this2.body.data.nodes) _this2.body.data.nodes.off(event, callback);
          });
          delete _this2.body.functions.createNode;
          delete _this2.nodesListeners.add;
          delete _this2.nodesListeners.update;
          delete _this2.nodesListeners.remove;
          delete _this2.nodesListeners;
        });
      }
    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {
          _Node2.default.parseOptions(this.options, options);

          // update the shape in all nodes
          if (options.shape !== undefined) {
            for (var nodeId in this.body.nodes) {
              if (this.body.nodes.hasOwnProperty(nodeId)) {
                this.body.nodes[nodeId].updateShape();
              }
            }
          }

          // update the font in all nodes
          if (options.font !== undefined) {
            _Label2.default.parseOptions(this.options.font, options);
            for (var _nodeId in this.body.nodes) {
              if (this.body.nodes.hasOwnProperty(_nodeId)) {
                this.body.nodes[_nodeId].updateLabelModule();
                this.body.nodes[_nodeId]._reset();
              }
            }
          }

          // update the shape size in all nodes
          if (options.size !== undefined) {
            for (var _nodeId2 in this.body.nodes) {
              if (this.body.nodes.hasOwnProperty(_nodeId2)) {
                this.body.nodes[_nodeId2]._reset();
              }
            }
          }

          // update the state of the letiables if needed
          if (options.hidden !== undefined || options.physics !== undefined) {
            this.body.emitter.emit('_dataChanged');
          }
        }
      }

      /**
       * Set a data set with nodes for the network
       * @param {Array | DataSet | DataView} nodes         The data containing the nodes.
       * @private
       */

    }, {
      key: 'setData',
      value: function setData(nodes) {
        var _this3 = this;

        var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var oldNodesData = this.body.data.nodes;

        if (nodes instanceof DataSet || nodes instanceof DataView) {
          this.body.data.nodes = nodes;
        } else if (Array.isArray(nodes)) {
          this.body.data.nodes = new DataSet();
          this.body.data.nodes.add(nodes);
        } else if (!nodes) {
          this.body.data.nodes = new DataSet();
        } else {
          throw new TypeError('Array or DataSet expected');
        }

        if (oldNodesData) {
          // unsubscribe from old dataset
          util.forEach(this.nodesListeners, function (callback, event) {
            oldNodesData.off(event, callback);
          });
        }

        // remove drawn nodes
        this.body.nodes = {};

        if (this.body.data.nodes) {
          (function () {
            // subscribe to new dataset
            var me = _this3;
            util.forEach(_this3.nodesListeners, function (callback, event) {
              me.body.data.nodes.on(event, callback);
            });

            // draw all new nodes
            var ids = _this3.body.data.nodes.getIds();
            _this3.add(ids, true);
          })();
        }

        if (doNotEmit === false) {
          this.body.emitter.emit("_dataChanged");
        }
      }

      /**
       * Add nodes
       * @param {Number[] | String[]} ids
       * @private
       */

    }, {
      key: 'add',
      value: function add(ids) {
        var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var id = void 0;
        var newNodes = [];
        for (var i = 0; i < ids.length; i++) {
          id = ids[i];
          var properties = this.body.data.nodes.get(id);
          var node = this.create(properties);
          newNodes.push(node);
          this.body.nodes[id] = node; // note: this may replace an existing node
        }

        this.layoutEngine.positionInitially(newNodes);

        if (doNotEmit === false) {
          this.body.emitter.emit("_dataChanged");
        }
      }

      /**
       * Update existing nodes, or create them when not yet existing
       * @param {Number[] | String[]} ids
       * @private
       */

    }, {
      key: 'update',
      value: function update(ids, changedData) {
        var nodes = this.body.nodes;
        var dataChanged = false;
        for (var i = 0; i < ids.length; i++) {
          var id = ids[i];
          var node = nodes[id];
          var data = changedData[i];
          if (node !== undefined) {
            // update node
            dataChanged = node.setOptions(data);
          } else {
            dataChanged = true;
            // create node
            node = this.create(data);
            nodes[id] = node;
          }
        }
        if (dataChanged === true) {
          this.body.emitter.emit("_dataChanged");
        } else {
          this.body.emitter.emit("_dataUpdated");
        }
      }

      /**
       * Remove existing nodes. If nodes do not exist, the method will just ignore it.
       * @param {Number[] | String[]} ids
       * @private
       */

    }, {
      key: 'remove',
      value: function remove(ids) {
        var nodes = this.body.nodes;

        for (var i = 0; i < ids.length; i++) {
          var id = ids[i];
          delete nodes[id];
        }

        this.body.emitter.emit("_dataChanged");
      }

      /**
       * create a node
       * @param properties
       * @param constructorClass
       */

    }, {
      key: 'create',
      value: function create(properties) {
        var constructorClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _Node2.default;

        return new constructorClass(properties, this.body, this.images, this.groups, this.options);
      }
    }, {
      key: 'refresh',
      value: function refresh() {
        var clearPositions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        var nodes = this.body.nodes;
        for (var nodeId in nodes) {
          var node = undefined;
          if (nodes.hasOwnProperty(nodeId)) {
            node = nodes[nodeId];
          }
          var data = this.body.data.nodes._data[nodeId];
          if (node !== undefined && data !== undefined) {
            if (clearPositions === true) {
              node.setOptions({ x: null, y: null });
            }
            node.setOptions({ fixed: false });
            node.setOptions(data);
          }
        }
      }

      /**
       * Returns the positions of the nodes.
       * @param ids  --> optional, can be array of nodeIds, can be string
       * @returns {{}}
       */

    }, {
      key: 'getPositions',
      value: function getPositions(ids) {
        var dataArray = {};
        if (ids !== undefined) {
          if (Array.isArray(ids) === true) {
            for (var i = 0; i < ids.length; i++) {
              if (this.body.nodes[ids[i]] !== undefined) {
                var node = this.body.nodes[ids[i]];
                dataArray[ids[i]] = { x: Math.round(node.x), y: Math.round(node.y) };
              }
            }
          } else {
            if (this.body.nodes[ids] !== undefined) {
              var _node = this.body.nodes[ids];
              dataArray[ids] = { x: Math.round(_node.x), y: Math.round(_node.y) };
            }
          }
        } else {
          for (var _i = 0; _i < this.body.nodeIndices.length; _i++) {
            var _node2 = this.body.nodes[this.body.nodeIndices[_i]];
            dataArray[this.body.nodeIndices[_i]] = { x: Math.round(_node2.x), y: Math.round(_node2.y) };
          }
        }
        return dataArray;
      }

      /**
       * Load the XY positions of the nodes into the dataset.
       */

    }, {
      key: 'storePositions',
      value: function storePositions() {
        // todo: add support for clusters and hierarchical.
        var dataArray = [];
        var dataset = this.body.data.nodes.getDataSet();

        for (var nodeId in dataset._data) {
          if (dataset._data.hasOwnProperty(nodeId)) {
            var node = this.body.nodes[nodeId];
            if (dataset._data[nodeId].x != Math.round(node.x) || dataset._data[nodeId].y != Math.round(node.y)) {
              dataArray.push({ id: node.id, x: Math.round(node.x), y: Math.round(node.y) });
            }
          }
        }
        dataset.update(dataArray);
      }

      /**
       * get the bounding box of a node.
       * @param nodeId
       * @returns {j|*}
       */

    }, {
      key: 'getBoundingBox',
      value: function getBoundingBox(nodeId) {
        if (this.body.nodes[nodeId] !== undefined) {
          return this.body.nodes[nodeId].shape.boundingBox;
        }
      }

      /**
       * Get the Ids of nodes connected to this node.
       * @param nodeId
       * @returns {Array}
       */

    }, {
      key: 'getConnectedNodes',
      value: function getConnectedNodes(nodeId) {
        var nodeList = [];
        if (this.body.nodes[nodeId] !== undefined) {
          var node = this.body.nodes[nodeId];
          var nodeObj = {}; // used to quickly check if node already exists
          for (var i = 0; i < node.edges.length; i++) {
            var edge = node.edges[i];
            if (edge.toId == node.id) {
              // these are double equals since ids can be numeric or string
              if (nodeObj[edge.fromId] === undefined) {
                nodeList.push(edge.fromId);
                nodeObj[edge.fromId] = true;
              }
            } else if (edge.fromId == node.id) {
              // these are double equals since ids can be numeric or string
              if (nodeObj[edge.toId] === undefined) {
                nodeList.push(edge.toId);
                nodeObj[edge.toId] = true;
              }
            }
          }
        }
        return nodeList;
      }

      /**
       * Get the ids of the edges connected to this node.
       * @param nodeId
       * @returns {*}
       */

    }, {
      key: 'getConnectedEdges',
      value: function getConnectedEdges(nodeId) {
        var edgeList = [];
        if (this.body.nodes[nodeId] !== undefined) {
          var node = this.body.nodes[nodeId];
          for (var i = 0; i < node.edges.length; i++) {
            edgeList.push(node.edges[i].id);
          }
        } else {
          console.log("NodeId provided for getConnectedEdges does not exist. Provided: ", nodeId);
        }
        return edgeList;
      }

      /**
       * Move a node.
       * @param String nodeId
       * @param Number x
       * @param Number y
       */

    }, {
      key: 'moveNode',
      value: function moveNode(nodeId, x, y) {
        var _this4 = this;

        if (this.body.nodes[nodeId] !== undefined) {
          this.body.nodes[nodeId].x = Number(x);
          this.body.nodes[nodeId].y = Number(y);
          setTimeout(function () {
            _this4.body.emitter.emit("startSimulation");
          }, 0);
        } else {
          console.log("Node id supplied to moveNode does not exist. Provided: ", nodeId);
        }
      }
    }]);

    return NodesHandler;
  }();

  exports.default = NodesHandler;

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _Label = __webpack_require__(68);

  var _Label2 = _interopRequireDefault(_Label);

  var _Box = __webpack_require__(69);

  var _Box2 = _interopRequireDefault(_Box);

  var _Circle = __webpack_require__(71);

  var _Circle2 = _interopRequireDefault(_Circle);

  var _CircularImage = __webpack_require__(73);

  var _CircularImage2 = _interopRequireDefault(_CircularImage);

  var _Database = __webpack_require__(74);

  var _Database2 = _interopRequireDefault(_Database);

  var _Diamond = __webpack_require__(75);

  var _Diamond2 = _interopRequireDefault(_Diamond);

  var _Dot = __webpack_require__(77);

  var _Dot2 = _interopRequireDefault(_Dot);

  var _Ellipse = __webpack_require__(78);

  var _Ellipse2 = _interopRequireDefault(_Ellipse);

  var _Icon = __webpack_require__(79);

  var _Icon2 = _interopRequireDefault(_Icon);

  var _Image = __webpack_require__(80);

  var _Image2 = _interopRequireDefault(_Image);

  var _Square = __webpack_require__(81);

  var _Square2 = _interopRequireDefault(_Square);

  var _Star = __webpack_require__(82);

  var _Star2 = _interopRequireDefault(_Star);

  var _Text = __webpack_require__(83);

  var _Text2 = _interopRequireDefault(_Text);

  var _Triangle = __webpack_require__(84);

  var _Triangle2 = _interopRequireDefault(_Triangle);

  var _TriangleDown = __webpack_require__(85);

  var _TriangleDown2 = _interopRequireDefault(_TriangleDown);

  var _Validator = __webpack_require__(31);

  var _Validator2 = _interopRequireDefault(_Validator);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  /**
   * @class Node
   * A node. A node can be connected to other nodes via one or multiple edges.
   * @param {object} options An object containing options for the node. All
   *                            options are optional, except for the id.
   *                              {number} id     Id of the node. Required
   *                              {string} label  Text label for the node
   *                              {number} x      Horizontal position of the node
   *                              {number} y      Vertical position of the node
   *                              {string} shape  Node shape, available:
   *                                              "database", "circle", "ellipse",
   *                                              "box", "image", "text", "dot",
   *                                              "star", "triangle", "triangleDown",
   *                                              "square", "icon"
   *                              {string} image  An image url
   *                              {string} title  An title text, can be HTML
   *                              {anytype} group A group name or number
   * @param {Network.Images} imagelist    A list with images. Only needed
   *                                            when the node has an image
   * @param {Network.Groups} grouplist    A list with groups. Needed for
   *                                            retrieving group options
   * @param {Object}               constants    An object with default values for
   *                                            example for the color
   *
   */
  var Node = function () {
    function Node(options, body, imagelist, grouplist, globalOptions) {
      _classCallCheck(this, Node);

      this.options = util.bridgeObject(globalOptions);
      this.globalOptions = globalOptions;
      this.body = body;

      this.edges = []; // all edges connected to this node

      // set defaults for the options
      this.id = undefined;
      this.imagelist = imagelist;
      this.grouplist = grouplist;

      // state options
      this.x = undefined;
      this.y = undefined;
      this.baseSize = this.options.size;
      this.baseFontSize = this.options.font.size;
      this.predefinedPosition = false; // used to check if initial fit should just take the range or approximate
      this.selected = false;
      this.hover = false;

      this.labelModule = new _Label2.default(this.body, this.options, false /* Not edge label */);
      this.setOptions(options);
    }

    /**
     * Attach a edge to the node
     * @param {Edge} edge
     */


    _createClass(Node, [{
      key: 'attachEdge',
      value: function attachEdge(edge) {
        if (this.edges.indexOf(edge) === -1) {
          this.edges.push(edge);
        }
      }

      /**
       * Detach a edge from the node
       * @param {Edge} edge
       */

    }, {
      key: 'detachEdge',
      value: function detachEdge(edge) {
        var index = this.edges.indexOf(edge);
        if (index != -1) {
          this.edges.splice(index, 1);
        }
      }

      /**
       * Set or overwrite options for the node
       * @param {Object} options an object with options
       * @param {Object} constants  and object with default, global options
       */

    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        var currentShape = this.options.shape;
        if (!options) {
          return;
        }
        // basic options
        if (options.id !== undefined) {
          this.id = options.id;
        }

        if (this.id === undefined) {
          throw "Node must have an id";
        }

        // set these options locally
        // clear x and y positions
        if (options.x !== undefined) {
          if (options.x === null) {
            this.x = undefined;this.predefinedPosition = false;
          } else {
            this.x = parseInt(options.x);this.predefinedPosition = true;
          }
        }
        if (options.y !== undefined) {
          if (options.y === null) {
            this.y = undefined;this.predefinedPosition = false;
          } else {
            this.y = parseInt(options.y);this.predefinedPosition = true;
          }
        }
        if (options.size !== undefined) {
          this.baseSize = options.size;
        }
        if (options.value !== undefined) {
          options.value = parseFloat(options.value);
        }

        // copy group options
        if (typeof options.group === 'number' || typeof options.group === 'string' && options.group != '') {
          var groupObj = this.grouplist.get(options.group);
          util.deepExtend(this.options, groupObj);
          // the color object needs to be completely defined. Since groups can partially overwrite the colors, we parse it again, just in case.
          this.options.color = util.parseColor(this.options.color);
        }

        // this transforms all shorthands into fully defined options
        Node.parseOptions(this.options, options, true, this.globalOptions);

        // load the images
        if (this.options.image !== undefined) {
          if (this.imagelist) {
            this.imageObj = this.imagelist.load(this.options.image, this.options.brokenImage, this.id);
          } else {
            throw "No imagelist provided";
          }
        }

        this.updateLabelModule();
        this.updateShape(currentShape);

        if (options.hidden !== undefined || options.physics !== undefined) {
          return true;
        }
        return false;
      }

      /**
       * This process all possible shorthands in the new options and makes sure that the parentOptions are fully defined.
       * Static so it can also be used by the handler.
       * @param parentOptions
       * @param newOptions
       * @param allowDeletion
       * @param globalOptions
       */

    }, {
      key: 'updateLabelModule',
      value: function updateLabelModule() {
        if (this.options.label === undefined || this.options.label === null) {
          this.options.label = '';
        }
        this.labelModule.setOptions(this.options, true);
        if (this.labelModule.baseSize !== undefined) {
          this.baseFontSize = this.labelModule.baseSize;
        }
      }
    }, {
      key: 'updateShape',
      value: function updateShape(currentShape) {
        if (currentShape === this.options.shape && this.shape) {
          this.shape.setOptions(this.options, this.imageObj);
        } else {
          // choose draw method depending on the shape
          switch (this.options.shape) {
            case 'box':
              this.shape = new _Box2.default(this.options, this.body, this.labelModule);
              break;
            case 'circle':
              this.shape = new _Circle2.default(this.options, this.body, this.labelModule);
              break;
            case 'circularImage':
              this.shape = new _CircularImage2.default(this.options, this.body, this.labelModule, this.imageObj);
              break;
            case 'database':
              this.shape = new _Database2.default(this.options, this.body, this.labelModule);
              break;
            case 'diamond':
              this.shape = new _Diamond2.default(this.options, this.body, this.labelModule);
              break;
            case 'dot':
              this.shape = new _Dot2.default(this.options, this.body, this.labelModule);
              break;
            case 'ellipse':
              this.shape = new _Ellipse2.default(this.options, this.body, this.labelModule);
              break;
            case 'icon':
              this.shape = new _Icon2.default(this.options, this.body, this.labelModule);
              break;
            case 'image':
              this.shape = new _Image2.default(this.options, this.body, this.labelModule, this.imageObj);
              break;
            case 'square':
              this.shape = new _Square2.default(this.options, this.body, this.labelModule);
              break;
            case 'star':
              this.shape = new _Star2.default(this.options, this.body, this.labelModule);
              break;
            case 'text':
              this.shape = new _Text2.default(this.options, this.body, this.labelModule);
              break;
            case 'triangle':
              this.shape = new _Triangle2.default(this.options, this.body, this.labelModule);
              break;
            case 'triangleDown':
              this.shape = new _TriangleDown2.default(this.options, this.body, this.labelModule);
              break;
            default:
              this.shape = new _Ellipse2.default(this.options, this.body, this.labelModule);
              break;
          }
        }
        this._reset();
      }

      /**
       * select this node
       */

    }, {
      key: 'select',
      value: function select() {
        this.selected = true;
        this._reset();
      }

      /**
       * unselect this node
       */

    }, {
      key: 'unselect',
      value: function unselect() {
        this.selected = false;
        this._reset();
      }

      /**
       * Reset the calculated size of the node, forces it to recalculate its size
       * @private
       */

    }, {
      key: '_reset',
      value: function _reset() {
        this.shape.width = undefined;
        this.shape.height = undefined;
      }

      /**
       * get the title of this node.
       * @return {string} title    The title of the node, or undefined when no title
       *                           has been set.
       */

    }, {
      key: 'getTitle',
      value: function getTitle() {
        return this.options.title;
      }

      /**
       * Calculate the distance to the border of the Node
       * @param {CanvasRenderingContext2D}   ctx
       * @param {Number} angle        Angle in radians
       * @returns {number} distance   Distance to the border in pixels
       */

    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this.shape.distanceToBorder(ctx, angle);
      }

      /**
       * Check if this node has a fixed x and y position
       * @return {boolean}      true if fixed, false if not
       */

    }, {
      key: 'isFixed',
      value: function isFixed() {
        return this.options.fixed.x && this.options.fixed.y;
      }

      /**
       * check if this node is selecte
       * @return {boolean} selected   True if node is selected, else false
       */

    }, {
      key: 'isSelected',
      value: function isSelected() {
        return this.selected;
      }

      /**
       * Retrieve the value of the node. Can be undefined
       * @return {Number} value
       */

    }, {
      key: 'getValue',
      value: function getValue() {
        return this.options.value;
      }

      /**
       * Adjust the value range of the node. The node will adjust it's size
       * based on its value.
       * @param {Number} min
       * @param {Number} max
       */

    }, {
      key: 'setValueRange',
      value: function setValueRange(min, max, total) {
        if (this.options.value !== undefined) {
          var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);
          var sizeDiff = this.options.scaling.max - this.options.scaling.min;
          if (this.options.scaling.label.enabled === true) {
            var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;
            this.options.font.size = this.options.scaling.label.min + scale * fontDiff;
          }
          this.options.size = this.options.scaling.min + scale * sizeDiff;
        } else {
          this.options.size = this.baseSize;
          this.options.font.size = this.baseFontSize;
        }

        this.updateLabelModule();
      }

      /**
       * Draw this node in the given canvas
       * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
       * @param {CanvasRenderingContext2D}   ctx
       */

    }, {
      key: 'draw',
      value: function draw(ctx) {
        this.shape.draw(ctx, this.x, this.y, this.selected, this.hover);
      }

      /**
       * Update the bounding box of the shape
       */

    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(ctx) {
        this.shape.updateBoundingBox(this.x, this.y, ctx);
      }

      /**
       * Recalculate the size of this node in the given canvas
       * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
       * @param {CanvasRenderingContext2D}   ctx
       */

    }, {
      key: 'resize',
      value: function resize(ctx) {
        this.shape.resize(ctx, this.selected);
      }

      /**
       * Check if this object is overlapping with the provided object
       * @param {Object} obj   an object with parameters left, top, right, bottom
       * @return {boolean}     True if location is located on node
       */

    }, {
      key: 'isOverlappingWith',
      value: function isOverlappingWith(obj) {
        return this.shape.left < obj.right && this.shape.left + this.shape.width > obj.left && this.shape.top < obj.bottom && this.shape.top + this.shape.height > obj.top;
      }

      /**
       * Check if this object is overlapping with the provided object
       * @param {Object} obj   an object with parameters left, top, right, bottom
       * @return {boolean}     True if location is located on node
       */

    }, {
      key: 'isBoundingBoxOverlappingWith',
      value: function isBoundingBoxOverlappingWith(obj) {
        return this.shape.boundingBox.left < obj.right && this.shape.boundingBox.right > obj.left && this.shape.boundingBox.top < obj.bottom && this.shape.boundingBox.bottom > obj.top;
      }
    }], [{
      key: 'parseOptions',
      value: function parseOptions(parentOptions, newOptions) {
        var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

        var fields = ['color', 'font', 'fixed', 'shadow'];
        util.selectiveNotDeepExtend(fields, parentOptions, newOptions, allowDeletion);

        // merge the shadow options into the parent.
        util.mergeOptions(parentOptions, newOptions, 'shadow', allowDeletion, globalOptions);

        // individual shape newOptions
        if (newOptions.color !== undefined && newOptions.color !== null) {
          var parsedColor = util.parseColor(newOptions.color);
          util.fillIfDefined(parentOptions.color, parsedColor);
        } else if (allowDeletion === true && newOptions.color === null) {
          parentOptions.color = util.bridgeObject(globalOptions.color); // set the object back to the global options
        }

        // handle the fixed options
        if (newOptions.fixed !== undefined && newOptions.fixed !== null) {
          if (typeof newOptions.fixed === 'boolean') {
            parentOptions.fixed.x = newOptions.fixed;
            parentOptions.fixed.y = newOptions.fixed;
          } else {
            if (newOptions.fixed.x !== undefined && typeof newOptions.fixed.x === 'boolean') {
              parentOptions.fixed.x = newOptions.fixed.x;
            }
            if (newOptions.fixed.y !== undefined && typeof newOptions.fixed.y === 'boolean') {
              parentOptions.fixed.y = newOptions.fixed.y;
            }
          }
        }

        // handle the font options
        if (newOptions.font !== undefined && newOptions.font !== null) {
          _Label2.default.parseOptions(parentOptions.font, newOptions);
        } else if (allowDeletion === true && newOptions.font === null) {
          parentOptions.font = util.bridgeObject(globalOptions.font); // set the object back to the global options
        }

        // handle the scaling options, specifically the label part
        if (newOptions.scaling !== undefined) {
          util.mergeOptions(parentOptions.scaling, newOptions.scaling, 'label', allowDeletion, globalOptions.scaling);
        }
      }
    }]);

    return Node;
  }();

  exports.default = Node;

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var Label = function () {
    function Label(body, options) {
      var edgelabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      _classCallCheck(this, Label);

      this.body = body;

      this.pointToSelf = false;
      this.baseSize = undefined;
      this.fontOptions = {};
      this.setOptions(options);
      this.size = { top: 0, left: 0, width: 0, height: 0, yLine: 0 }; // could be cached
      this.isEdgeLabel = edgelabel;
    }

    _createClass(Label, [{
      key: 'setOptions',
      value: function setOptions(options) {
        var allowDeletion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        this.nodeOptions = options;

        // We want to keep the font options seperated from the node options.
        // The node options have to mirror the globals when they are not overruled.
        this.fontOptions = util.deepExtend({}, options.font, true);

        if (options.label !== undefined) {
          this.labelDirty = true;
        }

        if (options.font !== undefined) {
          Label.parseOptions(this.fontOptions, options, allowDeletion);
          if (typeof options.font === 'string') {
            this.baseSize = this.fontOptions.size;
          } else if (_typeof(options.font) === 'object') {
            if (options.font.size !== undefined) {
              this.baseSize = options.font.size;
            }
          }
        }
      }
    }, {
      key: 'draw',


      /**
       * Main function. This is called from anything that wants to draw a label.
       * @param ctx
       * @param x
       * @param y
       * @param selected
       * @param baseline
       */
      value: function draw(ctx, x, y, selected) {
        var baseline = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'middle';

        // if no label, return
        if (this.nodeOptions.label === undefined) return;

        // check if we have to render the label
        var viewFontSize = this.fontOptions.size * this.body.view.scale;
        if (this.nodeOptions.label && viewFontSize < this.nodeOptions.scaling.label.drawThreshold - 1) return;

        // update the size cache if required
        this.calculateLabelSize(ctx, selected, x, y, baseline);

        // create the fontfill background
        this._drawBackground(ctx);
        // draw text
        this._drawText(ctx, selected, x, y, baseline);
      }

      /**
       * Draws the label background
       * @param {CanvasRenderingContext2D} ctx
       * @private
       */

    }, {
      key: '_drawBackground',
      value: function _drawBackground(ctx) {
        if (this.fontOptions.background !== undefined && this.fontOptions.background !== "none") {
          ctx.fillStyle = this.fontOptions.background;

          var lineMargin = 2;

          if (this.isEdgeLabel) {
            switch (this.fontOptions.align) {
              case 'middle':
                ctx.fillRect(-this.size.width * 0.5, -this.size.height * 0.5, this.size.width, this.size.height);
                break;
              case 'top':
                ctx.fillRect(-this.size.width * 0.5, -(this.size.height + lineMargin), this.size.width, this.size.height);
                break;
              case 'bottom':
                ctx.fillRect(-this.size.width * 0.5, lineMargin, this.size.width, this.size.height);
                break;
              default:
                ctx.fillRect(this.size.left, this.size.top - 0.5 * lineMargin, this.size.width, this.size.height);
                break;
            }
          } else {
            ctx.fillRect(this.size.left, this.size.top - 0.5 * lineMargin, this.size.width, this.size.height);
          }
        }
      }

      /**
       *
       * @param ctx
       * @param x
       * @param baseline
       * @private
       */

    }, {
      key: '_drawText',
      value: function _drawText(ctx, selected, x, y) {
        var baseline = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'middle';

        var fontSize = this.fontOptions.size;
        var viewFontSize = fontSize * this.body.view.scale;
        // this ensures that there will not be HUGE letters on screen by setting an upper limit on the visible text size (regardless of zoomLevel)
        if (viewFontSize >= this.nodeOptions.scaling.label.maxVisible) {
          fontSize = Number(this.nodeOptions.scaling.label.maxVisible) / this.body.view.scale;
        }

        var yLine = this.size.yLine;

        var _getColor2 = this._getColor(viewFontSize),
            _getColor3 = _slicedToArray(_getColor2, 2),
            fontColor = _getColor3[0],
            strokeColor = _getColor3[1];

        // configure context for drawing the text
        var _setAlignment2 = this._setAlignment(ctx, x, yLine, baseline);

        var _setAlignment3 = _slicedToArray(_setAlignment2, 2);

        x = _setAlignment3[0];
        yLine = _setAlignment3[1];
        ctx.font = (selected && this.nodeOptions.labelHighlightBold ? 'bold ' : '') + fontSize + "px " + this.fontOptions.face;
        ctx.fillStyle = fontColor;
        // When the textAlign property is 'left', make label left-justified
        if (!this.isEdgeLabel && this.fontOptions.align === 'left') {
          ctx.textAlign = this.fontOptions.align;
          x = x - 0.5 * this.size.width; // Shift label 1/2-distance to the left
        } else {
          ctx.textAlign = 'center';
        }

        // set the strokeWidth
        if (this.fontOptions.strokeWidth > 0) {
          ctx.lineWidth = this.fontOptions.strokeWidth;
          ctx.strokeStyle = strokeColor;
          ctx.lineJoin = 'round';
        }

        // draw the text
        for (var i = 0; i < this.lineCount; i++) {
          if (this.fontOptions.strokeWidth > 0) {
            ctx.strokeText(this.lines[i], x, yLine);
          }
          ctx.fillText(this.lines[i], x, yLine);
          yLine += fontSize;
        }
      }
    }, {
      key: '_setAlignment',
      value: function _setAlignment(ctx, x, yLine, baseline) {
        // check for label alignment (for edges)
        // TODO: make alignment for nodes
        if (this.isEdgeLabel && this.fontOptions.align !== 'horizontal' && this.pointToSelf === false) {
          x = 0;
          yLine = 0;

          var lineMargin = 2;
          if (this.fontOptions.align === 'top') {
            ctx.textBaseline = 'alphabetic';
            yLine -= 2 * lineMargin; // distance from edge, required because we use alphabetic. Alphabetic has less difference between browsers
          } else if (this.fontOptions.align === 'bottom') {
            ctx.textBaseline = 'hanging';
            yLine += 2 * lineMargin; // distance from edge, required because we use hanging. Hanging has less difference between browsers
          } else {
            ctx.textBaseline = 'middle';
          }
        } else {
          ctx.textBaseline = baseline;
        }

        return [x, yLine];
      }

      /**
       * fade in when relative scale is between threshold and threshold - 1.
       * If the relative scale would be smaller than threshold -1 the draw function would have returned before coming here.
       *
       * @param viewFontSize
       * @returns {*[]}
       * @private
       */

    }, {
      key: '_getColor',
      value: function _getColor(viewFontSize) {
        var fontColor = this.fontOptions.color || '#000000';
        var strokeColor = this.fontOptions.strokeColor || '#ffffff';
        if (viewFontSize <= this.nodeOptions.scaling.label.drawThreshold) {
          var opacity = Math.max(0, Math.min(1, 1 - (this.nodeOptions.scaling.label.drawThreshold - viewFontSize)));
          fontColor = util.overrideOpacity(fontColor, opacity);
          strokeColor = util.overrideOpacity(strokeColor, opacity);
        }
        return [fontColor, strokeColor];
      }

      /**
       *
       * @param ctx
       * @param selected
       * @returns {{width: number, height: number}}
       */

    }, {
      key: 'getTextSize',
      value: function getTextSize(ctx) {
        var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var size = {
          width: this._processLabel(ctx, selected),
          height: this.fontOptions.size * this.lineCount,
          lineCount: this.lineCount
        };
        return size;
      }

      /**
       *
       * @param ctx
       * @param selected
       * @param x
       * @param y
       * @param baseline
       */

    }, {
      key: 'calculateLabelSize',
      value: function calculateLabelSize(ctx, selected) {
        var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var baseline = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'middle';

        if (this.labelDirty === true) {
          this.size.width = this._processLabel(ctx, selected);
        }
        this.size.height = this.fontOptions.size * this.lineCount;
        this.size.left = x - this.size.width * 0.5;
        this.size.top = y - this.size.height * 0.5;
        this.size.yLine = y + (1 - this.lineCount) * 0.5 * this.fontOptions.size;
        if (baseline === "hanging") {
          this.size.top += 0.5 * this.fontOptions.size;
          this.size.top += 4; // distance from node, required because we use hanging. Hanging has less difference between browsers
          this.size.yLine += 4; // distance from node
        }

        this.labelDirty = false;
      }

      /**
       * This calculates the width as well as explodes the label string and calculates the amount of lines.
       * @param ctx
       * @param selected
       * @returns {number}
       * @private
       */

    }, {
      key: '_processLabel',
      value: function _processLabel(ctx, selected) {
        var width = 0;
        var lines = [''];
        var lineCount = 0;
        if (this.nodeOptions.label !== undefined) {
          lines = String(this.nodeOptions.label).split('\n');
          lineCount = lines.length;
          ctx.font = (selected && this.nodeOptions.labelHighlightBold ? 'bold ' : '') + this.fontOptions.size + "px " + this.fontOptions.face;
          width = ctx.measureText(lines[0]).width;
          for (var i = 1; i < lineCount; i++) {
            var lineWidth = ctx.measureText(lines[i]).width;
            width = lineWidth > width ? lineWidth : width;
          }
        }
        this.lines = lines;
        this.lineCount = lineCount;

        return width;
      }
    }], [{
      key: 'parseOptions',
      value: function parseOptions(parentOptions, newOptions) {
        var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (typeof newOptions.font === 'string') {
          var newOptionsArray = newOptions.font.split(" ");
          parentOptions.size = newOptionsArray[0].replace("px", '');
          parentOptions.face = newOptionsArray[1];
          parentOptions.color = newOptionsArray[2];
        } else if (_typeof(newOptions.font) === 'object') {
          util.fillIfDefined(parentOptions, newOptions.font, allowDeletion);
        }
        parentOptions.size = Number(parentOptions.size);
      }
    }]);

    return Label;
  }();

  exports.default = Label;

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NodeBase2 = __webpack_require__(70);

  var _NodeBase3 = _interopRequireDefault(_NodeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Box = function (_NodeBase) {
    _inherits(Box, _NodeBase);

    function Box(options, body, labelModule) {
      _classCallCheck(this, Box);

      return _possibleConstructorReturn(this, (Box.__proto__ || Object.getPrototypeOf(Box)).call(this, options, body, labelModule));
    }

    _createClass(Box, [{
      key: 'resize',
      value: function resize(ctx, selected) {
        if (this.width === undefined) {
          var margin = 5;
          var textSize = this.labelModule.getTextSize(ctx, selected);
          this.width = textSize.width + 2 * margin;
          this.height = textSize.height + 2 * margin;
          this.radius = 0.5 * this.width;
        }
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this.resize(ctx, selected);
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        var borderWidth = this.options.borderWidth;
        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;

        ctx.strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;
        ctx.lineWidth = selected ? selectionLineWidth : borderWidth;
        ctx.lineWidth /= this.body.view.scale;
        ctx.lineWidth = Math.min(this.width, ctx.lineWidth);

        ctx.fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;

        var borderRadius = this.options.shapeProperties.borderRadius; // only effective for box
        ctx.roundRect(this.left, this.top, this.width, this.height, borderRadius);

        // draw shadow if enabled
        this.enableShadow(ctx);
        // draw the background
        ctx.fill();
        // disable shadows for other elements.
        this.disableShadow(ctx);

        //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.
        ctx.save();
        // if borders are zero width, they will be drawn with width 1 by default. This prevents that
        if (borderWidth > 0) {
          this.enableBorderDashes(ctx);
          //draw the border
          ctx.stroke();
          //disable dashed border for other elements
          this.disableBorderDashes(ctx);
        }
        ctx.restore();

        this.updateBoundingBox(x, y, ctx, selected);
        this.labelModule.draw(ctx, x, y, selected);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y, ctx, selected) {
        this.resize(ctx, selected);
        this.left = x - this.width * 0.5;
        this.top = y - this.height * 0.5;

        var borderRadius = this.options.shapeProperties.borderRadius; // only effective for box
        this.boundingBox.left = this.left - borderRadius;
        this.boundingBox.top = this.top - borderRadius;
        this.boundingBox.bottom = this.top + this.height + borderRadius;
        this.boundingBox.right = this.left + this.width + borderRadius;
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        this.resize(ctx);
        var borderWidth = this.options.borderWidth;

        return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;
      }
    }]);

    return Box;
  }(_NodeBase3.default);

  exports.default = Box;

/***/ },
/* 70 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var NodeBase = function () {
    function NodeBase(options, body, labelModule) {
      _classCallCheck(this, NodeBase);

      this.body = body;
      this.labelModule = labelModule;
      this.setOptions(options);
      this.top = undefined;
      this.left = undefined;
      this.height = undefined;
      this.width = undefined;
      this.radius = undefined;
      this.boundingBox = { top: 0, left: 0, right: 0, bottom: 0 };
    }

    _createClass(NodeBase, [{
      key: "setOptions",
      value: function setOptions(options) {
        this.options = options;
      }
    }, {
      key: "_distanceToBorder",
      value: function _distanceToBorder(ctx, angle) {
        var borderWidth = this.options.borderWidth;
        this.resize(ctx);
        return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;
      }
    }, {
      key: "enableShadow",
      value: function enableShadow(ctx) {
        if (this.options.shadow.enabled === true) {
          ctx.shadowColor = this.options.shadow.color;
          ctx.shadowBlur = this.options.shadow.size;
          ctx.shadowOffsetX = this.options.shadow.x;
          ctx.shadowOffsetY = this.options.shadow.y;
        }
      }
    }, {
      key: "disableShadow",
      value: function disableShadow(ctx) {
        if (this.options.shadow.enabled === true) {
          ctx.shadowColor = 'rgba(0,0,0,0)';
          ctx.shadowBlur = 0;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 0;
        }
      }
    }, {
      key: "enableBorderDashes",
      value: function enableBorderDashes(ctx) {
        if (this.options.shapeProperties.borderDashes !== false) {
          if (ctx.setLineDash !== undefined) {
            var dashes = this.options.shapeProperties.borderDashes;
            if (dashes === true) {
              dashes = [5, 15];
            }
            ctx.setLineDash(dashes);
          } else {
            console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used.");
            this.options.shapeProperties.borderDashes = false;
          }
        }
      }
    }, {
      key: "disableBorderDashes",
      value: function disableBorderDashes(ctx) {
        if (this.options.shapeProperties.borderDashes !== false) {
          if (ctx.setLineDash !== undefined) {
            ctx.setLineDash([0]);
          } else {
            console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used.");
            this.options.shapeProperties.borderDashes = false;
          }
        }
      }
    }]);

    return NodeBase;
  }();

  exports.default = NodeBase;

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _CircleImageBase2 = __webpack_require__(72);

  var _CircleImageBase3 = _interopRequireDefault(_CircleImageBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Circle = function (_CircleImageBase) {
    _inherits(Circle, _CircleImageBase);

    function Circle(options, body, labelModule) {
      _classCallCheck(this, Circle);

      return _possibleConstructorReturn(this, (Circle.__proto__ || Object.getPrototypeOf(Circle)).call(this, options, body, labelModule));
    }

    _createClass(Circle, [{
      key: 'resize',
      value: function resize(ctx, selected) {
        if (this.width === undefined) {
          var margin = 5;
          var textSize = this.labelModule.getTextSize(ctx, selected);
          var diameter = Math.max(textSize.width, textSize.height) + 2 * margin;
          this.options.size = diameter / 2;

          this.width = diameter;
          this.height = diameter;
          this.radius = 0.5 * this.width;
        }
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this.resize(ctx, selected);
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        this._drawRawCircle(ctx, x, y, selected, hover, this.options.size);

        this.boundingBox.top = y - this.options.size;
        this.boundingBox.left = x - this.options.size;
        this.boundingBox.right = x + this.options.size;
        this.boundingBox.bottom = y + this.options.size;

        this.updateBoundingBox(x, y);
        this.labelModule.draw(ctx, x, y, selected);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y) {
        this.boundingBox.top = y - this.options.size;
        this.boundingBox.left = x - this.options.size;
        this.boundingBox.right = x + this.options.size;
        this.boundingBox.bottom = y + this.options.size;
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        this.resize(ctx);
        return this.width * 0.5;
      }
    }]);

    return Circle;
  }(_CircleImageBase3.default);

  exports.default = Circle;

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NodeBase2 = __webpack_require__(70);

  var _NodeBase3 = _interopRequireDefault(_NodeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var CircleImageBase = function (_NodeBase) {
    _inherits(CircleImageBase, _NodeBase);

    function CircleImageBase(options, body, labelModule) {
      _classCallCheck(this, CircleImageBase);

      var _this = _possibleConstructorReturn(this, (CircleImageBase.__proto__ || Object.getPrototypeOf(CircleImageBase)).call(this, options, body, labelModule));

      _this.labelOffset = 0;
      _this.imageLoaded = false;
      return _this;
    }

    _createClass(CircleImageBase, [{
      key: 'setOptions',
      value: function setOptions(options, imageObj) {
        this.options = options;
        if (imageObj) {
          this.imageObj = imageObj;
        }
      }

      /**
       * This function resizes the image by the options size when the image has not yet loaded. If the image has loaded, we
       * force the update of the size again.
       *
       * @private
       */

    }, {
      key: '_resizeImage',
      value: function _resizeImage() {
        var force = false;
        if (!this.imageObj.width || !this.imageObj.height) {
          // undefined or 0
          this.imageLoaded = false;
        } else if (this.imageLoaded === false) {
          this.imageLoaded = true;
          force = true;
        }

        if (!this.width || !this.height || force === true) {
          // undefined or 0
          var width, height, ratio;
          if (this.imageObj.width && this.imageObj.height) {
            // not undefined or 0
            width = 0;
            height = 0;
          }
          if (this.options.shapeProperties.useImageSize === false) {
            if (this.imageObj.width > this.imageObj.height) {
              ratio = this.imageObj.width / this.imageObj.height;
              width = this.options.size * 2 * ratio || this.imageObj.width;
              height = this.options.size * 2 || this.imageObj.height;
            } else {
              if (this.imageObj.width && this.imageObj.height) {
                // not undefined or 0
                ratio = this.imageObj.height / this.imageObj.width;
              } else {
                ratio = 1;
              }
              width = this.options.size * 2;
              height = this.options.size * 2 * ratio;
            }
          } else {
            // when not using the size property, we use the image size
            width = this.imageObj.width;
            height = this.imageObj.height;
          }
          this.width = width;
          this.height = height;
          this.radius = 0.5 * this.width;
        }
      }
    }, {
      key: '_drawRawCircle',
      value: function _drawRawCircle(ctx, x, y, selected, hover, size) {
        var neutralborderWidth = this.options.borderWidth;
        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;
        var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;
        ctx.lineWidth = Math.min(this.width, borderWidth);

        ctx.strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;
        ctx.fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;
        ctx.circle(x, y, size);

        // draw shadow if enabled
        this.enableShadow(ctx);
        // draw the background
        ctx.fill();
        // disable shadows for other elements.
        this.disableShadow(ctx);

        //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.
        ctx.save();
        // if borders are zero width, they will be drawn with width 1 by default. This prevents that
        if (borderWidth > 0) {
          this.enableBorderDashes(ctx);
          //draw the border
          ctx.stroke();
          //disable dashed border for other elements
          this.disableBorderDashes(ctx);
        }
        ctx.restore();
      }
    }, {
      key: '_drawImageAtPosition',
      value: function _drawImageAtPosition(ctx) {
        if (this.imageObj.width != 0) {
          // draw the image
          ctx.globalAlpha = 1.0;

          // draw shadow if enabled
          this.enableShadow(ctx);

          var factor = this.imageObj.width / this.width / this.body.view.scale;
          if (factor > 2 && this.options.shapeProperties.interpolation === true) {
            var w = this.imageObj.width;
            var h = this.imageObj.height;
            var can2 = document.createElement('canvas');
            can2.width = w;
            can2.height = w;
            var ctx2 = can2.getContext('2d');

            factor *= 0.5;
            w *= 0.5;
            h *= 0.5;
            ctx2.drawImage(this.imageObj, 0, 0, w, h);

            var distance = 0;
            var iterations = 1;
            while (factor > 2 && iterations < 4) {
              ctx2.drawImage(can2, distance, 0, w, h, distance + w, 0, w / 2, h / 2);
              distance += w;
              factor *= 0.5;
              w *= 0.5;
              h *= 0.5;
              iterations += 1;
            }
            ctx.drawImage(can2, distance, 0, w, h, this.left, this.top, this.width, this.height);
          } else {
            // draw image
            ctx.drawImage(this.imageObj, this.left, this.top, this.width, this.height);
          }

          // disable shadows for other elements.
          this.disableShadow(ctx);
        }
      }
    }, {
      key: '_drawImageLabel',
      value: function _drawImageLabel(ctx, x, y, selected) {
        var yLabel;
        var offset = 0;

        if (this.height !== undefined) {
          offset = this.height * 0.5;
          var labelDimensions = this.labelModule.getTextSize(ctx);
          if (labelDimensions.lineCount >= 1) {
            offset += labelDimensions.height / 2;
          }
        }

        yLabel = y + offset;

        if (this.options.label) {
          this.labelOffset = offset;
        }
        this.labelModule.draw(ctx, x, yLabel, selected, 'hanging');
      }
    }]);

    return CircleImageBase;
  }(_NodeBase3.default);

  exports.default = CircleImageBase;

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _CircleImageBase2 = __webpack_require__(72);

  var _CircleImageBase3 = _interopRequireDefault(_CircleImageBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var CircularImage = function (_CircleImageBase) {
    _inherits(CircularImage, _CircleImageBase);

    function CircularImage(options, body, labelModule, imageObj) {
      _classCallCheck(this, CircularImage);

      var _this = _possibleConstructorReturn(this, (CircularImage.__proto__ || Object.getPrototypeOf(CircularImage)).call(this, options, body, labelModule));

      _this.imageObj = imageObj;
      _this._swapToImageResizeWhenImageLoaded = true;
      return _this;
    }

    _createClass(CircularImage, [{
      key: 'resize',
      value: function resize() {
        if (this.imageObj.src === undefined || this.imageObj.width === undefined || this.imageObj.height === undefined) {
          if (!this.width) {
            var diameter = this.options.size * 2;
            this.width = diameter;
            this.height = diameter;
            this._swapToImageResizeWhenImageLoaded = true;
            this.radius = 0.5 * this.width;
          }
        } else {
          if (this._swapToImageResizeWhenImageLoaded) {
            this.width = undefined;
            this.height = undefined;
            this._swapToImageResizeWhenImageLoaded = false;
          }
          this._resizeImage();
        }
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this.resize();

        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        var size = Math.min(0.5 * this.height, 0.5 * this.width);

        // draw the background circle. IMPORTANT: the stroke in this method is used by the clip method below.
        this._drawRawCircle(ctx, x, y, selected, hover, size);

        // now we draw in the circle, we save so we can revert the clip operation after drawing.
        ctx.save();
        // clip is used to use the stroke in drawRawCircle as an area that we can draw in.
        ctx.clip();
        // draw the image
        this._drawImageAtPosition(ctx);
        // restore so we can again draw on the full canvas
        ctx.restore();

        this._drawImageLabel(ctx, x, y, selected);

        this.updateBoundingBox(x, y);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y) {
        this.boundingBox.top = y - this.options.size;
        this.boundingBox.left = x - this.options.size;
        this.boundingBox.right = x + this.options.size;
        this.boundingBox.bottom = y + this.options.size;
        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        this.resize(ctx);
        return this.width * 0.5;
      }
    }]);

    return CircularImage;
  }(_CircleImageBase3.default);

  exports.default = CircularImage;

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NodeBase2 = __webpack_require__(70);

  var _NodeBase3 = _interopRequireDefault(_NodeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Database = function (_NodeBase) {
    _inherits(Database, _NodeBase);

    function Database(options, body, labelModule) {
      _classCallCheck(this, Database);

      return _possibleConstructorReturn(this, (Database.__proto__ || Object.getPrototypeOf(Database)).call(this, options, body, labelModule));
    }

    _createClass(Database, [{
      key: 'resize',
      value: function resize(ctx, selected) {
        if (this.width === undefined) {
          var margin = 5;
          var textSize = this.labelModule.getTextSize(ctx, selected);
          var size = textSize.width + 2 * margin;
          this.width = size;
          this.height = size;
          this.radius = 0.5 * this.width;
        }
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this.resize(ctx, selected);
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        var neutralborderWidth = this.options.borderWidth;
        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;
        var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;
        ctx.lineWidth = Math.min(this.width, borderWidth);

        ctx.strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;

        ctx.fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;
        ctx.database(x - this.width / 2, y - this.height * 0.5, this.width, this.height);

        // draw shadow if enabled
        this.enableShadow(ctx);
        // draw the background
        ctx.fill();
        // disable shadows for other elements.
        this.disableShadow(ctx);

        //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.
        ctx.save();
        // if borders are zero width, they will be drawn with width 1 by default. This prevents that
        if (borderWidth > 0) {
          this.enableBorderDashes(ctx);
          //draw the border
          ctx.stroke();
          //disable dashed border for other elements
          this.disableBorderDashes(ctx);
        }
        ctx.restore();

        this.updateBoundingBox(x, y, ctx, selected);
        this.labelModule.draw(ctx, x, y, selected);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y, ctx, selected) {
        this.resize(ctx, selected);

        this.left = x - this.width * 0.5;
        this.top = y - this.height * 0.5;

        this.boundingBox.left = this.left;
        this.boundingBox.top = this.top;
        this.boundingBox.bottom = this.top + this.height;
        this.boundingBox.right = this.left + this.width;
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return Database;
  }(_NodeBase3.default);

  exports.default = Database;

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _ShapeBase2 = __webpack_require__(76);

  var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Diamond = function (_ShapeBase) {
    _inherits(Diamond, _ShapeBase);

    function Diamond(options, body, labelModule) {
      _classCallCheck(this, Diamond);

      return _possibleConstructorReturn(this, (Diamond.__proto__ || Object.getPrototypeOf(Diamond)).call(this, options, body, labelModule));
    }

    _createClass(Diamond, [{
      key: 'resize',
      value: function resize(ctx) {
        this._resizeShape();
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this._drawShape(ctx, 'diamond', 4, x, y, selected, hover);
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return Diamond;
  }(_ShapeBase3.default);

  exports.default = Diamond;

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NodeBase2 = __webpack_require__(70);

  var _NodeBase3 = _interopRequireDefault(_NodeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var ShapeBase = function (_NodeBase) {
    _inherits(ShapeBase, _NodeBase);

    function ShapeBase(options, body, labelModule) {
      _classCallCheck(this, ShapeBase);

      return _possibleConstructorReturn(this, (ShapeBase.__proto__ || Object.getPrototypeOf(ShapeBase)).call(this, options, body, labelModule));
    }

    _createClass(ShapeBase, [{
      key: '_resizeShape',
      value: function _resizeShape() {
        if (this.width === undefined) {
          var size = 2 * this.options.size;
          this.width = size;
          this.height = size;
          this.radius = 0.5 * this.width;
        }
      }
    }, {
      key: '_drawShape',
      value: function _drawShape(ctx, shape, sizeMultiplier, x, y, selected, hover) {
        this._resizeShape();

        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        var neutralborderWidth = this.options.borderWidth;
        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;
        var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;
        ctx.lineWidth = Math.min(this.width, borderWidth);

        ctx.strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;
        ctx.fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;
        ctx[shape](x, y, this.options.size);

        // draw shadow if enabled
        this.enableShadow(ctx);
        // draw the background
        ctx.fill();
        // disable shadows for other elements.
        this.disableShadow(ctx);

        //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.
        ctx.save();
        // if borders are zero width, they will be drawn with width 1 by default. This prevents that
        if (borderWidth > 0) {
          this.enableBorderDashes(ctx);
          //draw the border
          ctx.stroke();
          //disable dashed border for other elements
          this.disableBorderDashes(ctx);
        }
        ctx.restore();

        if (this.options.label !== undefined) {
          var yLabel = y + 0.5 * this.height + 3; // the + 3 is to offset it a bit below the node.
          this.labelModule.draw(ctx, x, yLabel, selected, 'hanging');
        }

        this.updateBoundingBox(x, y);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y) {
        this.boundingBox.top = y - this.options.size;
        this.boundingBox.left = x - this.options.size;
        this.boundingBox.right = x + this.options.size;
        this.boundingBox.bottom = y + this.options.size;

        if (this.options.label !== undefined && this.labelModule.size.width > 0) {
          this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
          this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
          this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height + 3);
        }
      }
    }]);

    return ShapeBase;
  }(_NodeBase3.default);

  exports.default = ShapeBase;

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _ShapeBase2 = __webpack_require__(76);

  var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Dot = function (_ShapeBase) {
    _inherits(Dot, _ShapeBase);

    function Dot(options, body, labelModule) {
      _classCallCheck(this, Dot);

      return _possibleConstructorReturn(this, (Dot.__proto__ || Object.getPrototypeOf(Dot)).call(this, options, body, labelModule));
    }

    _createClass(Dot, [{
      key: 'resize',
      value: function resize(ctx) {
        this._resizeShape();
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this._drawShape(ctx, 'circle', 2, x, y, selected, hover);
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        this.resize(ctx);
        return this.options.size;
      }
    }]);

    return Dot;
  }(_ShapeBase3.default);

  exports.default = Dot;

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NodeBase2 = __webpack_require__(70);

  var _NodeBase3 = _interopRequireDefault(_NodeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Ellipse = function (_NodeBase) {
    _inherits(Ellipse, _NodeBase);

    function Ellipse(options, body, labelModule) {
      _classCallCheck(this, Ellipse);

      return _possibleConstructorReturn(this, (Ellipse.__proto__ || Object.getPrototypeOf(Ellipse)).call(this, options, body, labelModule));
    }

    _createClass(Ellipse, [{
      key: 'resize',
      value: function resize(ctx, selected) {
        if (this.width === undefined) {
          var textSize = this.labelModule.getTextSize(ctx, selected);

          this.height = textSize.height * 2;
          this.width = textSize.width + this.height;
          this.radius = 0.5 * this.width;
        }
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this.resize(ctx, selected);
        this.left = x - this.width * 0.5;
        this.top = y - this.height * 0.5;

        var neutralborderWidth = this.options.borderWidth;
        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;
        var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;
        ctx.lineWidth = Math.min(this.width, borderWidth);

        ctx.strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;

        ctx.fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;
        ctx.ellipse(this.left, this.top, this.width, this.height);

        // draw shadow if enabled
        this.enableShadow(ctx);
        // draw the background
        ctx.fill();
        // disable shadows for other elements.
        this.disableShadow(ctx);

        //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.
        ctx.save();

        // if borders are zero width, they will be drawn with width 1 by default. This prevents that
        if (borderWidth > 0) {
          this.enableBorderDashes(ctx);
          //draw the border
          ctx.stroke();
          //disable dashed border for other elements
          this.disableBorderDashes(ctx);
        }

        ctx.restore();

        this.updateBoundingBox(x, y, ctx, selected);
        this.labelModule.draw(ctx, x, y, selected);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y, ctx, selected) {
        this.resize(ctx, selected); // just in case

        this.left = x - this.width * 0.5;
        this.top = y - this.height * 0.5;

        this.boundingBox.left = this.left;
        this.boundingBox.top = this.top;
        this.boundingBox.bottom = this.top + this.height;
        this.boundingBox.right = this.left + this.width;
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        this.resize(ctx);
        var a = this.width * 0.5;
        var b = this.height * 0.5;
        var w = Math.sin(angle) * a;
        var h = Math.cos(angle) * b;
        return a * b / Math.sqrt(w * w + h * h);
      }
    }]);

    return Ellipse;
  }(_NodeBase3.default);

  exports.default = Ellipse;

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NodeBase2 = __webpack_require__(70);

  var _NodeBase3 = _interopRequireDefault(_NodeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Icon = function (_NodeBase) {
    _inherits(Icon, _NodeBase);

    function Icon(options, body, labelModule) {
      _classCallCheck(this, Icon);

      return _possibleConstructorReturn(this, (Icon.__proto__ || Object.getPrototypeOf(Icon)).call(this, options, body, labelModule));
    }

    _createClass(Icon, [{
      key: 'resize',
      value: function resize(ctx) {
        if (this.width === undefined) {
          var margin = 5;
          var iconSize = {
            width: Number(this.options.icon.size),
            height: Number(this.options.icon.size)
          };
          this.width = iconSize.width + 2 * margin;
          this.height = iconSize.height + 2 * margin;
          this.radius = 0.5 * this.width;
        }
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this.resize(ctx);
        this.options.icon.size = this.options.icon.size || 50;

        this.left = x - this.width * 0.5;
        this.top = y - this.height * 0.5;
        this._icon(ctx, x, y, selected);

        if (this.options.label !== undefined) {
          var iconTextSpacing = 5;
          this.labelModule.draw(ctx, x, y + this.height * 0.5 + iconTextSpacing, selected);
        }

        this.updateBoundingBox(x, y);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y) {
        this.boundingBox.top = y - this.options.icon.size * 0.5;
        this.boundingBox.left = x - this.options.icon.size * 0.5;
        this.boundingBox.right = x + this.options.icon.size * 0.5;
        this.boundingBox.bottom = y + this.options.icon.size * 0.5;

        if (this.options.label !== undefined && this.labelModule.size.width > 0) {
          var iconTextSpacing = 5;
          this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
          this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
          this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height + iconTextSpacing);
        }
      }
    }, {
      key: '_icon',
      value: function _icon(ctx, x, y, selected) {
        var iconSize = Number(this.options.icon.size);

        if (this.options.icon.code !== undefined) {
          ctx.font = (selected ? "bold " : "") + iconSize + "px " + this.options.icon.face;

          // draw icon
          ctx.fillStyle = this.options.icon.color || "black";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";

          // draw shadow if enabled
          this.enableShadow(ctx);
          ctx.fillText(this.options.icon.code, x, y);

          // disable shadows for other elements.
          this.disableShadow(ctx);
        } else {
          console.error('When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.');
        }
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return Icon;
  }(_NodeBase3.default);

  exports.default = Icon;

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _CircleImageBase2 = __webpack_require__(72);

  var _CircleImageBase3 = _interopRequireDefault(_CircleImageBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Image = function (_CircleImageBase) {
    _inherits(Image, _CircleImageBase);

    function Image(options, body, labelModule, imageObj) {
      _classCallCheck(this, Image);

      var _this = _possibleConstructorReturn(this, (Image.__proto__ || Object.getPrototypeOf(Image)).call(this, options, body, labelModule));

      _this.imageObj = imageObj;
      return _this;
    }

    _createClass(Image, [{
      key: 'resize',
      value: function resize() {
        this._resizeImage();
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this.resize();
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        if (this.options.shapeProperties.useBorderWithImage === true) {
          var neutralborderWidth = this.options.borderWidth;
          var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;
          var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;
          ctx.lineWidth = Math.min(this.width, borderWidth);

          ctx.beginPath();

          // setup the line properties.
          ctx.strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;

          // set a fillstyle
          ctx.fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;

          // draw a rectangle to form the border around. This rectangle is filled so the opacity of a picture (in future vis releases?) can be used to tint the image
          ctx.rect(this.left - 0.5 * ctx.lineWidth, this.top - 0.5 * ctx.lineWidth, this.width + ctx.lineWidth, this.height + ctx.lineWidth);
          ctx.fill();

          //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.
          ctx.save();
          // if borders are zero width, they will be drawn with width 1 by default. This prevents that
          if (borderWidth > 0) {
            this.enableBorderDashes(ctx);
            //draw the border
            ctx.stroke();
            //disable dashed border for other elements
            this.disableBorderDashes(ctx);
          }
          ctx.restore();

          ctx.closePath();
        }

        this._drawImageAtPosition(ctx);

        this._drawImageLabel(ctx, x, y, selected || hover);

        this.updateBoundingBox(x, y);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y) {
        this.resize();
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        this.boundingBox.top = this.top;
        this.boundingBox.left = this.left;
        this.boundingBox.right = this.left + this.width;
        this.boundingBox.bottom = this.top + this.height;

        if (this.options.label !== undefined && this.labelModule.size.width > 0) {
          this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
          this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
          this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);
        }
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return Image;
  }(_CircleImageBase3.default);

  exports.default = Image;

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _ShapeBase2 = __webpack_require__(76);

  var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Square = function (_ShapeBase) {
    _inherits(Square, _ShapeBase);

    function Square(options, body, labelModule) {
      _classCallCheck(this, Square);

      return _possibleConstructorReturn(this, (Square.__proto__ || Object.getPrototypeOf(Square)).call(this, options, body, labelModule));
    }

    _createClass(Square, [{
      key: 'resize',
      value: function resize() {
        this._resizeShape();
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this._drawShape(ctx, 'square', 2, x, y, selected, hover);
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return Square;
  }(_ShapeBase3.default);

  exports.default = Square;

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _ShapeBase2 = __webpack_require__(76);

  var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Star = function (_ShapeBase) {
    _inherits(Star, _ShapeBase);

    function Star(options, body, labelModule) {
      _classCallCheck(this, Star);

      return _possibleConstructorReturn(this, (Star.__proto__ || Object.getPrototypeOf(Star)).call(this, options, body, labelModule));
    }

    _createClass(Star, [{
      key: 'resize',
      value: function resize(ctx) {
        this._resizeShape();
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this._drawShape(ctx, 'star', 4, x, y, selected, hover);
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return Star;
  }(_ShapeBase3.default);

  exports.default = Star;

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NodeBase2 = __webpack_require__(70);

  var _NodeBase3 = _interopRequireDefault(_NodeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Text = function (_NodeBase) {
    _inherits(Text, _NodeBase);

    function Text(options, body, labelModule) {
      _classCallCheck(this, Text);

      return _possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).call(this, options, body, labelModule));
    }

    _createClass(Text, [{
      key: 'resize',
      value: function resize(ctx, selected) {
        if (this.width === undefined) {
          var margin = 5;
          var textSize = this.labelModule.getTextSize(ctx, selected);
          this.width = textSize.width + 2 * margin;
          this.height = textSize.height + 2 * margin;
          this.radius = 0.5 * this.width;
        }
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this.resize(ctx, selected || hover);
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        // draw shadow if enabled
        this.enableShadow(ctx);
        this.labelModule.draw(ctx, x, y, selected || hover);

        // disable shadows for other elements.
        this.disableShadow(ctx);

        this.updateBoundingBox(x, y, ctx, selected);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y, ctx, selected) {
        this.resize(ctx, selected);

        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        this.boundingBox.top = this.top;
        this.boundingBox.left = this.left;
        this.boundingBox.right = this.left + this.width;
        this.boundingBox.bottom = this.top + this.height;
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return Text;
  }(_NodeBase3.default);

  exports.default = Text;

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _ShapeBase2 = __webpack_require__(76);

  var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Triangle = function (_ShapeBase) {
    _inherits(Triangle, _ShapeBase);

    function Triangle(options, body, labelModule) {
      _classCallCheck(this, Triangle);

      return _possibleConstructorReturn(this, (Triangle.__proto__ || Object.getPrototypeOf(Triangle)).call(this, options, body, labelModule));
    }

    _createClass(Triangle, [{
      key: 'resize',
      value: function resize(ctx) {
        this._resizeShape();
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this._drawShape(ctx, 'triangle', 3, x, y, selected, hover);
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return Triangle;
  }(_ShapeBase3.default);

  exports.default = Triangle;

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _ShapeBase2 = __webpack_require__(76);

  var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var TriangleDown = function (_ShapeBase) {
    _inherits(TriangleDown, _ShapeBase);

    function TriangleDown(options, body, labelModule) {
      _classCallCheck(this, TriangleDown);

      return _possibleConstructorReturn(this, (TriangleDown.__proto__ || Object.getPrototypeOf(TriangleDown)).call(this, options, body, labelModule));
    }

    _createClass(TriangleDown, [{
      key: 'resize',
      value: function resize(ctx) {
        this._resizeShape();
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this._drawShape(ctx, 'triangleDown', 3, x, y, selected, hover);
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return TriangleDown;
  }(_ShapeBase3.default);

  exports.default = TriangleDown;

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _Edge = __webpack_require__(87);

  var _Edge2 = _interopRequireDefault(_Edge);

  var _Label = __webpack_require__(68);

  var _Label2 = _interopRequireDefault(_Label);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);

  var EdgesHandler = function () {
    function EdgesHandler(body, images, groups) {
      var _this = this;

      _classCallCheck(this, EdgesHandler);

      this.body = body;
      this.images = images;
      this.groups = groups;

      // create the edge API in the body container
      this.body.functions.createEdge = this.create.bind(this);

      this.edgesListeners = {
        add: function add(event, params) {
          _this.add(params.items);
        },
        update: function update(event, params) {
          _this.update(params.items);
        },
        remove: function remove(event, params) {
          _this.remove(params.items);
        }
      };

      this.options = {};
      this.defaultOptions = {
        arrows: {
          to: { enabled: false, scaleFactor: 1, type: 'arrow' }, // boolean / {arrowScaleFactor:1} / {enabled: false, arrowScaleFactor:1}
          middle: { enabled: false, scaleFactor: 1, type: 'arrow' },
          from: { enabled: false, scaleFactor: 1, type: 'arrow' }
        },
        arrowStrikethrough: true,
        color: {
          color: '#848484',
          highlight: '#848484',
          hover: '#848484',
          inherit: 'from',
          opacity: 1.0
        },
        dashes: false,
        font: {
          color: '#343434',
          size: 14, // px
          face: 'arial',
          background: 'none',
          strokeWidth: 2, // px
          strokeColor: '#ffffff',
          align: 'horizontal'
        },
        hidden: false,
        hoverWidth: 1.5,
        label: undefined,
        labelHighlightBold: true,
        length: undefined,
        physics: true,
        scaling: {
          min: 1,
          max: 15,
          label: {
            enabled: true,
            min: 14,
            max: 30,
            maxVisible: 30,
            drawThreshold: 5
          },
          customScalingFunction: function customScalingFunction(min, max, total, value) {
            if (max === min) {
              return 0.5;
            } else {
              var scale = 1 / (max - min);
              return Math.max(0, (value - min) * scale);
            }
          }
        },
        selectionWidth: 1.5,
        selfReferenceSize: 20,
        shadow: {
          enabled: false,
          color: 'rgba(0,0,0,0.5)',
          size: 10,
          x: 5,
          y: 5
        },
        smooth: {
          enabled: true,
          type: "dynamic",
          forceDirection: 'none',
          roundness: 0.5
        },
        title: undefined,
        width: 1,
        value: undefined
      };

      util.extend(this.options, this.defaultOptions);

      this.bindEventListeners();
    }

    _createClass(EdgesHandler, [{
      key: 'bindEventListeners',
      value: function bindEventListeners() {
        var _this2 = this;

        // this allows external modules to force all dynamic curves to turn static.
        this.body.emitter.on("_forceDisableDynamicCurves", function (type) {
          if (type === 'dynamic') {
            type = 'continuous';
          }
          var emitChange = false;
          for (var edgeId in _this2.body.edges) {
            if (_this2.body.edges.hasOwnProperty(edgeId)) {
              var edge = _this2.body.edges[edgeId];
              var edgeData = _this2.body.data.edges._data[edgeId];

              // only forcibly remove the smooth curve if the data has been set of the edge has the smooth curves defined.
              // this is because a change in the global would not affect these curves.
              if (edgeData !== undefined) {
                var edgeOptions = edgeData.smooth;
                if (edgeOptions !== undefined) {
                  if (edgeOptions.enabled === true && edgeOptions.type === 'dynamic') {
                    if (type === undefined) {
                      edge.setOptions({ smooth: false });
                    } else {
                      edge.setOptions({ smooth: { type: type } });
                    }
                    emitChange = true;
                  }
                }
              }
            }
          }
          if (emitChange === true) {
            _this2.body.emitter.emit("_dataChanged");
          }
        });

        // this is called when options of EXISTING nodes or edges have changed.
        this.body.emitter.on("_dataUpdated", function () {
          _this2.reconnectEdges();
          _this2.markAllEdgesAsDirty();
        });

        // refresh the edges. Used when reverting from hierarchical layout
        this.body.emitter.on("refreshEdges", this.refresh.bind(this));
        this.body.emitter.on("refresh", this.refresh.bind(this));
        this.body.emitter.on("destroy", function () {
          util.forEach(_this2.edgesListeners, function (callback, event) {
            if (_this2.body.data.edges) _this2.body.data.edges.off(event, callback);
          });
          delete _this2.body.functions.createEdge;
          delete _this2.edgesListeners.add;
          delete _this2.edgesListeners.update;
          delete _this2.edgesListeners.remove;
          delete _this2.edgesListeners;
        });
      }
    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {
          // use the parser from the Edge class to fill in all shorthand notations
          _Edge2.default.parseOptions(this.options, options);

          // handle multiple input cases for color
          if (options.color !== undefined) {
            this.markAllEdgesAsDirty();
          }

          // update smooth settings in all edges
          var dataChanged = false;
          if (options.smooth !== undefined) {
            for (var edgeId in this.body.edges) {
              if (this.body.edges.hasOwnProperty(edgeId)) {
                dataChanged = this.body.edges[edgeId].updateEdgeType() || dataChanged;
              }
            }
          }

          // update fonts in all edges
          if (options.font !== undefined) {
            // use the parser from the Label class to fill in all shorthand notations
            _Label2.default.parseOptions(this.options.font, options);
            for (var _edgeId in this.body.edges) {
              if (this.body.edges.hasOwnProperty(_edgeId)) {
                this.body.edges[_edgeId].updateLabelModule();
              }
            }
          }

          // update the state of the variables if needed
          if (options.hidden !== undefined || options.physics !== undefined || dataChanged === true) {
            this.body.emitter.emit('_dataChanged');
          }
        }
      }

      /**
       * Load edges by reading the data table
       * @param {Array | DataSet | DataView} edges    The data containing the edges.
       * @private
       * @private
       */

    }, {
      key: 'setData',
      value: function setData(edges) {
        var _this3 = this;

        var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var oldEdgesData = this.body.data.edges;

        if (edges instanceof DataSet || edges instanceof DataView) {
          this.body.data.edges = edges;
        } else if (Array.isArray(edges)) {
          this.body.data.edges = new DataSet();
          this.body.data.edges.add(edges);
        } else if (!edges) {
          this.body.data.edges = new DataSet();
        } else {
          throw new TypeError('Array or DataSet expected');
        }

        // TODO: is this null or undefined or false?
        if (oldEdgesData) {
          // unsubscribe from old dataset
          util.forEach(this.edgesListeners, function (callback, event) {
            oldEdgesData.off(event, callback);
          });
        }

        // remove drawn edges
        this.body.edges = {};

        // TODO: is this null or undefined or false?
        if (this.body.data.edges) {
          // subscribe to new dataset
          util.forEach(this.edgesListeners, function (callback, event) {
            _this3.body.data.edges.on(event, callback);
          });

          // draw all new nodes
          var ids = this.body.data.edges.getIds();
          this.add(ids, true);
        }

        if (doNotEmit === false) {
          this.body.emitter.emit("_dataChanged");
        }
      }

      /**
       * Add edges
       * @param {Number[] | String[]} ids
       * @private
       */

    }, {
      key: 'add',
      value: function add(ids) {
        var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var edges = this.body.edges;
        var edgesData = this.body.data.edges;

        for (var i = 0; i < ids.length; i++) {
          var id = ids[i];

          var oldEdge = edges[id];
          if (oldEdge) {
            oldEdge.disconnect();
          }

          var data = edgesData.get(id, { "showInternalIds": true });
          edges[id] = this.create(data);
        }

        if (doNotEmit === false) {
          this.body.emitter.emit("_dataChanged");
        }
      }

      /**
       * Update existing edges, or create them when not yet existing
       * @param {Number[] | String[]} ids
       * @private
       */

    }, {
      key: 'update',
      value: function update(ids) {
        var edges = this.body.edges;
        var edgesData = this.body.data.edges;
        var dataChanged = false;
        for (var i = 0; i < ids.length; i++) {
          var id = ids[i];
          var data = edgesData.get(id);
          var edge = edges[id];
          if (edge !== undefined) {
            // update edge
            edge.disconnect();
            dataChanged = edge.setOptions(data) || dataChanged; // if a support node is added, data can be changed.
            edge.connect();
          } else {
            // create edge
            this.body.edges[id] = this.create(data);
            dataChanged = true;
          }
        }

        if (dataChanged === true) {
          this.body.emitter.emit("_dataChanged");
        } else {
          this.body.emitter.emit("_dataUpdated");
        }
      }

      /**
       * Remove existing edges. Non existing ids will be ignored
       * @param {Number[] | String[]} ids
       * @private
       */

    }, {
      key: 'remove',
      value: function remove(ids) {
        var edges = this.body.edges;
        for (var i = 0; i < ids.length; i++) {
          var id = ids[i];
          var edge = edges[id];
          if (edge !== undefined) {
            edge.cleanup();
            edge.disconnect();
            delete edges[id];
          }
        }

        this.body.emitter.emit("_dataChanged");
      }
    }, {
      key: 'refresh',
      value: function refresh() {
        var edges = this.body.edges;
        for (var edgeId in edges) {
          var edge = undefined;
          if (edges.hasOwnProperty(edgeId)) {
            edge = edges[edgeId];
          }
          var data = this.body.data.edges._data[edgeId];
          if (edge !== undefined && data !== undefined) {
            edge.setOptions(data);
          }
        }
      }
    }, {
      key: 'create',
      value: function create(properties) {
        return new _Edge2.default(properties, this.body, this.options);
      }
    }, {
      key: 'markAllEdgesAsDirty',
      value: function markAllEdgesAsDirty() {
        for (var edgeId in this.body.edges) {
          this.body.edges[edgeId].edgeType.colorDirty = true;
        }
      }

      /**
       * Reconnect all edges
       * @private
       */

    }, {
      key: 'reconnectEdges',
      value: function reconnectEdges() {
        var id;
        var nodes = this.body.nodes;
        var edges = this.body.edges;

        for (id in nodes) {
          if (nodes.hasOwnProperty(id)) {
            nodes[id].edges = [];
          }
        }

        for (id in edges) {
          if (edges.hasOwnProperty(id)) {
            var edge = edges[id];
            edge.from = null;
            edge.to = null;
            edge.connect();
          }
        }
      }
    }, {
      key: 'getConnectedNodes',
      value: function getConnectedNodes(edgeId) {
        var nodeList = [];
        if (this.body.edges[edgeId] !== undefined) {
          var edge = this.body.edges[edgeId];
          if (edge.fromId) {
            nodeList.push(edge.fromId);
          }
          if (edge.toId) {
            nodeList.push(edge.toId);
          }
        }
        return nodeList;
      }
    }]);

    return EdgesHandler;
  }();

  exports.default = EdgesHandler;

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _Label = __webpack_require__(68);

  var _Label2 = _interopRequireDefault(_Label);

  var _CubicBezierEdge = __webpack_require__(88);

  var _CubicBezierEdge2 = _interopRequireDefault(_CubicBezierEdge);

  var _BezierEdgeDynamic = __webpack_require__(92);

  var _BezierEdgeDynamic2 = _interopRequireDefault(_BezierEdgeDynamic);

  var _BezierEdgeStatic = __webpack_require__(93);

  var _BezierEdgeStatic2 = _interopRequireDefault(_BezierEdgeStatic);

  var _StraightEdge = __webpack_require__(94);

  var _StraightEdge2 = _interopRequireDefault(_StraightEdge);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  /**
   * @class Edge
   *
   * A edge connects two nodes
   * @param {Object} properties     Object with options. Must contain
   *                                At least options from and to.
   *                                Available options: from (number),
   *                                to (number), label (string, color (string),
   *                                width (number), style (string),
   *                                length (number), title (string)
   * @param {Network} network       A Network object, used to find and edge to
   *                                nodes.
   * @param {Object} constants      An object with default values for
   *                                example for the color
   */
  var Edge = function () {
    function Edge(options, body, globalOptions) {
      _classCallCheck(this, Edge);

      if (body === undefined) {
        throw "No body provided";
      }
      this.options = util.bridgeObject(globalOptions);
      this.globalOptions = globalOptions;
      this.body = body;

      // initialize variables
      this.id = undefined;
      this.fromId = undefined;
      this.toId = undefined;
      this.selected = false;
      this.hover = false;
      this.labelDirty = true;
      this.colorDirty = true;

      this.baseWidth = this.options.width;
      this.baseFontSize = this.options.font.size;

      this.from = undefined; // a node
      this.to = undefined; // a node

      this.edgeType = undefined;

      this.connected = false;

      this.labelModule = new _Label2.default(this.body, this.options, true /* It's an edge label */);

      this.setOptions(options);
    }

    /**
     * Set or overwrite options for the edge
     * @param {Object} options  an object with options
     * @param doNotEmit
     */


    _createClass(Edge, [{
      key: 'setOptions',
      value: function setOptions(options) {
        if (!options) {
          return;
        }
        this.colorDirty = true;

        Edge.parseOptions(this.options, options, true, this.globalOptions);

        if (options.id !== undefined) {
          this.id = options.id;
        }
        if (options.from !== undefined) {
          this.fromId = options.from;
        }
        if (options.to !== undefined) {
          this.toId = options.to;
        }
        if (options.title !== undefined) {
          this.title = options.title;
        }
        if (options.value !== undefined) {
          options.value = parseFloat(options.value);
        }

        // update label Module
        this.updateLabelModule();

        var dataChanged = this.updateEdgeType();

        // if anything has been updates, reset the selection width and the hover width
        this._setInteractionWidths();

        // A node is connected when it has a from and to node that both exist in the network.body.nodes.
        this.connect();

        if (options.hidden !== undefined || options.physics !== undefined) {
          dataChanged = true;
        }

        return dataChanged;
      }
    }, {
      key: 'updateLabelModule',


      /**
       * update the options in the label module
       */
      value: function updateLabelModule() {
        this.labelModule.setOptions(this.options, true);
        if (this.labelModule.baseSize !== undefined) {
          this.baseFontSize = this.labelModule.baseSize;
        }
      }

      /**
       * update the edge type, set the options
       * @returns {boolean}
       */

    }, {
      key: 'updateEdgeType',
      value: function updateEdgeType() {
        var dataChanged = false;
        var changeInType = true;
        var smooth = this.options.smooth;
        if (this.edgeType !== undefined) {
          if (this.edgeType instanceof _BezierEdgeDynamic2.default && smooth.enabled === true && smooth.type === 'dynamic') {
            changeInType = false;
          }
          if (this.edgeType instanceof _CubicBezierEdge2.default && smooth.enabled === true && smooth.type === 'cubicBezier') {
            changeInType = false;
          }
          if (this.edgeType instanceof _BezierEdgeStatic2.default && smooth.enabled === true && smooth.type !== 'dynamic' && smooth.type !== 'cubicBezier') {
            changeInType = false;
          }
          if (this.edgeType instanceof _StraightEdge2.default && smooth.enabled === false) {
            changeInType = false;
          }

          if (changeInType === true) {
            dataChanged = this.cleanup();
          }
        }

        if (changeInType === true) {
          if (this.options.smooth.enabled === true) {
            if (this.options.smooth.type === 'dynamic') {
              dataChanged = true;
              this.edgeType = new _BezierEdgeDynamic2.default(this.options, this.body, this.labelModule);
            } else if (this.options.smooth.type === 'cubicBezier') {
              this.edgeType = new _CubicBezierEdge2.default(this.options, this.body, this.labelModule);
            } else {
              this.edgeType = new _BezierEdgeStatic2.default(this.options, this.body, this.labelModule);
            }
          } else {
            this.edgeType = new _StraightEdge2.default(this.options, this.body, this.labelModule);
          }
        } else {
          // if nothing changes, we just set the options.
          this.edgeType.setOptions(this.options);
        }

        return dataChanged;
      }

      /**
       * Connect an edge to its nodes
       */

    }, {
      key: 'connect',
      value: function connect() {
        this.disconnect();

        this.from = this.body.nodes[this.fromId] || undefined;
        this.to = this.body.nodes[this.toId] || undefined;
        this.connected = this.from !== undefined && this.to !== undefined;

        if (this.connected === true) {
          this.from.attachEdge(this);
          this.to.attachEdge(this);
        } else {
          if (this.from) {
            this.from.detachEdge(this);
          }
          if (this.to) {
            this.to.detachEdge(this);
          }
        }

        this.edgeType.connect();
      }

      /**
       * Disconnect an edge from its nodes
       */

    }, {
      key: 'disconnect',
      value: function disconnect() {
        if (this.from) {
          this.from.detachEdge(this);
          this.from = undefined;
        }
        if (this.to) {
          this.to.detachEdge(this);
          this.to = undefined;
        }

        this.connected = false;
      }

      /**
       * get the title of this edge.
       * @return {string} title    The title of the edge, or undefined when no title
       *                           has been set.
       */

    }, {
      key: 'getTitle',
      value: function getTitle() {
        return this.title;
      }

      /**
       * check if this node is selecte
       * @return {boolean} selected   True if node is selected, else false
       */

    }, {
      key: 'isSelected',
      value: function isSelected() {
        return this.selected;
      }

      /**
       * Retrieve the value of the edge. Can be undefined
       * @return {Number} value
       */

    }, {
      key: 'getValue',
      value: function getValue() {
        return this.options.value;
      }

      /**
       * Adjust the value range of the edge. The edge will adjust it's width
       * based on its value.
       * @param {Number} min
       * @param {Number} max
       * @param total
       */

    }, {
      key: 'setValueRange',
      value: function setValueRange(min, max, total) {
        if (this.options.value !== undefined) {
          var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);
          var widthDiff = this.options.scaling.max - this.options.scaling.min;
          if (this.options.scaling.label.enabled === true) {
            var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;
            this.options.font.size = this.options.scaling.label.min + scale * fontDiff;
          }
          this.options.width = this.options.scaling.min + scale * widthDiff;
        } else {
          this.options.width = this.baseWidth;
          this.options.font.size = this.baseFontSize;
        }

        this._setInteractionWidths();
        this.updateLabelModule();
      }
    }, {
      key: '_setInteractionWidths',
      value: function _setInteractionWidths() {
        if (typeof this.options.hoverWidth === 'function') {
          this.edgeType.hoverWidth = this.options.hoverWidth(this.options.width);
        } else {
          this.edgeType.hoverWidth = this.options.hoverWidth + this.options.width;
        }

        if (typeof this.options.selectionWidth === 'function') {
          this.edgeType.selectionWidth = this.options.selectionWidth(this.options.width);
        } else {
          this.edgeType.selectionWidth = this.options.selectionWidth + this.options.width;
        }
      }

      /**
       * Redraw a edge
       * Draw this edge in the given canvas
       * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
       * @param {CanvasRenderingContext2D}   ctx
       */

    }, {
      key: 'draw',
      value: function draw(ctx) {
        // get the via node from the edge type
        var viaNode = this.edgeType.getViaNode();
        var arrowData = {};

        // restore edge targets to defaults
        this.edgeType.fromPoint = this.edgeType.from;
        this.edgeType.toPoint = this.edgeType.to;

        // from and to arrows give a different end point for edges. we set them here
        if (this.options.arrows.from.enabled === true) {
          arrowData.from = this.edgeType.getArrowData(ctx, 'from', viaNode, this.selected, this.hover);
          if (this.options.arrowStrikethrough === false) this.edgeType.fromPoint = arrowData.from.core;
        }
        if (this.options.arrows.to.enabled === true) {
          arrowData.to = this.edgeType.getArrowData(ctx, 'to', viaNode, this.selected, this.hover);
          if (this.options.arrowStrikethrough === false) this.edgeType.toPoint = arrowData.to.core;
        }

        // the middle arrow depends on the line, which can depend on the to and from arrows so we do this one lastly.
        if (this.options.arrows.middle.enabled === true) {
          arrowData.middle = this.edgeType.getArrowData(ctx, 'middle', viaNode, this.selected, this.hover);
        }

        // draw everything
        this.edgeType.drawLine(ctx, this.selected, this.hover, viaNode);
        this.drawArrows(ctx, arrowData);
        this.drawLabel(ctx, viaNode);
      }
    }, {
      key: 'drawArrows',
      value: function drawArrows(ctx, arrowData) {
        if (this.options.arrows.from.enabled === true) {
          this.edgeType.drawArrowHead(ctx, this.selected, this.hover, arrowData.from);
        }
        if (this.options.arrows.middle.enabled === true) {
          this.edgeType.drawArrowHead(ctx, this.selected, this.hover, arrowData.middle);
        }
        if (this.options.arrows.to.enabled === true) {
          this.edgeType.drawArrowHead(ctx, this.selected, this.hover, arrowData.to);
        }
      }
    }, {
      key: 'drawLabel',
      value: function drawLabel(ctx, viaNode) {
        if (this.options.label !== undefined) {
          // set style
          var node1 = this.from;
          var node2 = this.to;
          var selected = this.from.selected || this.to.selected || this.selected;
          if (node1.id != node2.id) {
            this.labelModule.pointToSelf = false;
            var point = this.edgeType.getPoint(0.5, viaNode);
            ctx.save();

            // if the label has to be rotated:
            if (this.options.font.align !== "horizontal") {
              this.labelModule.calculateLabelSize(ctx, selected, point.x, point.y);
              ctx.translate(point.x, this.labelModule.size.yLine);
              this._rotateForLabelAlignment(ctx);
            }

            // draw the label
            this.labelModule.draw(ctx, point.x, point.y, selected);
            ctx.restore();
          } else {
            // Ignore the orientations.
            this.labelModule.pointToSelf = true;
            var x, y;
            var radius = this.options.selfReferenceSize;
            if (node1.shape.width > node1.shape.height) {
              x = node1.x + node1.shape.width * 0.5;
              y = node1.y - radius;
            } else {
              x = node1.x + radius;
              y = node1.y - node1.shape.height * 0.5;
            }
            point = this._pointOnCircle(x, y, radius, 0.125);
            this.labelModule.draw(ctx, point.x, point.y, selected);
          }
        }
      }

      /**
       * Check if this object is overlapping with the provided object
       * @param {Object} obj   an object with parameters left, top
       * @return {boolean}     True if location is located on the edge
       */

    }, {
      key: 'isOverlappingWith',
      value: function isOverlappingWith(obj) {
        if (this.connected) {
          var distMax = 10;
          var xFrom = this.from.x;
          var yFrom = this.from.y;
          var xTo = this.to.x;
          var yTo = this.to.y;
          var xObj = obj.left;
          var yObj = obj.top;

          var dist = this.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, xObj, yObj);

          return dist < distMax;
        } else {
          return false;
        }
      }

      /**
       * Rotates the canvas so the text is most readable
       * @param {CanvasRenderingContext2D} ctx
       * @private
       */

    }, {
      key: '_rotateForLabelAlignment',
      value: function _rotateForLabelAlignment(ctx) {
        var dy = this.from.y - this.to.y;
        var dx = this.from.x - this.to.x;
        var angleInDegrees = Math.atan2(dy, dx);

        // rotate so label it is readable
        if (angleInDegrees < -1 && dx < 0 || angleInDegrees > 0 && dx < 0) {
          angleInDegrees = angleInDegrees + Math.PI;
        }

        ctx.rotate(angleInDegrees);
      }

      /**
       * Get a point on a circle
       * @param {Number} x
       * @param {Number} y
       * @param {Number} radius
       * @param {Number} percentage. Value between 0 (line start) and 1 (line end)
       * @return {Object} point
       * @private
       */

    }, {
      key: '_pointOnCircle',
      value: function _pointOnCircle(x, y, radius, percentage) {
        var angle = percentage * 2 * Math.PI;
        return {
          x: x + radius * Math.cos(angle),
          y: y - radius * Math.sin(angle)
        };
      }
    }, {
      key: 'select',
      value: function select() {
        this.selected = true;
      }
    }, {
      key: 'unselect',
      value: function unselect() {
        this.selected = false;
      }

      /**
       * cleans all required things on delete
       * @returns {*}
       */

    }, {
      key: 'cleanup',
      value: function cleanup() {
        return this.edgeType.cleanup();
      }
    }], [{
      key: 'parseOptions',
      value: function parseOptions(parentOptions, newOptions) {
        var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

        var fields = ['arrowStrikethrough', 'id', 'from', 'hidden', 'hoverWidth', 'label', 'labelHighlightBold', 'length', 'line', 'opacity', 'physics', 'scaling', 'selectionWidth', 'selfReferenceSize', 'to', 'title', 'value', 'width'];

        // only deep extend the items in the field array. These do not have shorthand.
        util.selectiveDeepExtend(fields, parentOptions, newOptions, allowDeletion);

        util.mergeOptions(parentOptions, newOptions, 'smooth', allowDeletion, globalOptions);
        util.mergeOptions(parentOptions, newOptions, 'shadow', allowDeletion, globalOptions);

        if (newOptions.dashes !== undefined && newOptions.dashes !== null) {
          parentOptions.dashes = newOptions.dashes;
        } else if (allowDeletion === true && newOptions.dashes === null) {
          parentOptions.dashes = Object.create(globalOptions.dashes); // this sets the pointer of the option back to the global option.
        }

        // set the scaling newOptions
        if (newOptions.scaling !== undefined && newOptions.scaling !== null) {
          if (newOptions.scaling.min !== undefined) {
            parentOptions.scaling.min = newOptions.scaling.min;
          }
          if (newOptions.scaling.max !== undefined) {
            parentOptions.scaling.max = newOptions.scaling.max;
          }
          util.mergeOptions(parentOptions.scaling, newOptions.scaling, 'label', allowDeletion, globalOptions.scaling);
        } else if (allowDeletion === true && newOptions.scaling === null) {
          parentOptions.scaling = Object.create(globalOptions.scaling); // this sets the pointer of the option back to the global option.
        }

        // handle multiple input cases for arrows
        if (newOptions.arrows !== undefined && newOptions.arrows !== null) {
          if (typeof newOptions.arrows === 'string') {
            var arrows = newOptions.arrows.toLowerCase();
            parentOptions.arrows.to.enabled = arrows.indexOf("to") != -1;
            parentOptions.arrows.middle.enabled = arrows.indexOf("middle") != -1;
            parentOptions.arrows.from.enabled = arrows.indexOf("from") != -1;
          } else if (_typeof(newOptions.arrows) === 'object') {
            util.mergeOptions(parentOptions.arrows, newOptions.arrows, 'to', allowDeletion, globalOptions.arrows);
            util.mergeOptions(parentOptions.arrows, newOptions.arrows, 'middle', allowDeletion, globalOptions.arrows);
            util.mergeOptions(parentOptions.arrows, newOptions.arrows, 'from', allowDeletion, globalOptions.arrows);
          } else {
            throw new Error("The arrow newOptions can only be an object or a string. Refer to the documentation. You used:" + JSON.stringify(newOptions.arrows));
          }
        } else if (allowDeletion === true && newOptions.arrows === null) {
          parentOptions.arrows = Object.create(globalOptions.arrows); // this sets the pointer of the option back to the global option.
        }

        // handle multiple input cases for color
        if (newOptions.color !== undefined && newOptions.color !== null) {
          // make a copy of the parent object in case this is referring to the global one (due to object create once, then update)
          parentOptions.color = util.deepExtend({}, parentOptions.color, true);
          if (util.isString(newOptions.color)) {
            parentOptions.color.color = newOptions.color;
            parentOptions.color.highlight = newOptions.color;
            parentOptions.color.hover = newOptions.color;
            parentOptions.color.inherit = false;
          } else {
            var colorsDefined = false;
            if (newOptions.color.color !== undefined) {
              parentOptions.color.color = newOptions.color.color;colorsDefined = true;
            }
            if (newOptions.color.highlight !== undefined) {
              parentOptions.color.highlight = newOptions.color.highlight;colorsDefined = true;
            }
            if (newOptions.color.hover !== undefined) {
              parentOptions.color.hover = newOptions.color.hover;colorsDefined = true;
            }
            if (newOptions.color.inherit !== undefined) {
              parentOptions.color.inherit = newOptions.color.inherit;
            }
            if (newOptions.color.opacity !== undefined) {
              parentOptions.color.opacity = Math.min(1, Math.max(0, newOptions.color.opacity));
            }

            if (newOptions.color.inherit === undefined && colorsDefined === true) {
              parentOptions.color.inherit = false;
            }
          }
        } else if (allowDeletion === true && newOptions.color === null) {
          parentOptions.color = util.bridgeObject(globalOptions.color); // set the object back to the global options
        }

        // handle the font settings
        if (newOptions.font !== undefined && newOptions.font !== null) {
          _Label2.default.parseOptions(parentOptions.font, newOptions);
        } else if (allowDeletion === true && newOptions.font === null) {
          parentOptions.font = util.bridgeObject(globalOptions.font); // set the object back to the global options
        }
      }
    }]);

    return Edge;
  }();

  exports.default = Edge;

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _CubicBezierEdgeBase2 = __webpack_require__(89);

  var _CubicBezierEdgeBase3 = _interopRequireDefault(_CubicBezierEdgeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var CubicBezierEdge = function (_CubicBezierEdgeBase) {
    _inherits(CubicBezierEdge, _CubicBezierEdgeBase);

    function CubicBezierEdge(options, body, labelModule) {
      _classCallCheck(this, CubicBezierEdge);

      return _possibleConstructorReturn(this, (CubicBezierEdge.__proto__ || Object.getPrototypeOf(CubicBezierEdge)).call(this, options, body, labelModule));
    }

    /**
     * Draw a line between two nodes
     * @param {CanvasRenderingContext2D} ctx
     * @private
     */


    _createClass(CubicBezierEdge, [{
      key: '_line',
      value: function _line(ctx, viaNodes) {
        // get the coordinates of the support points.
        var via1 = viaNodes[0];
        var via2 = viaNodes[1];

        // start drawing the line.
        ctx.beginPath();
        ctx.moveTo(this.fromPoint.x, this.fromPoint.y);

        // fallback to normal straight edges
        if (viaNodes === undefined || via1.x === undefined) {
          ctx.lineTo(this.toPoint.x, this.toPoint.y);
        } else {
          ctx.bezierCurveTo(via1.x, via1.y, via2.x, via2.y, this.toPoint.x, this.toPoint.y);
        }
        // draw shadow if enabled
        this.enableShadow(ctx);
        ctx.stroke();
        this.disableShadow(ctx);
      }
    }, {
      key: '_getViaCoordinates',
      value: function _getViaCoordinates() {
        var dx = this.from.x - this.to.x;
        var dy = this.from.y - this.to.y;

        var x1 = void 0,
            y1 = void 0,
            x2 = void 0,
            y2 = void 0;
        var roundness = this.options.smooth.roundness;

        // horizontal if x > y or if direction is forced or if direction is horizontal
        if ((Math.abs(dx) > Math.abs(dy) || this.options.smooth.forceDirection === true || this.options.smooth.forceDirection === 'horizontal') && this.options.smooth.forceDirection !== 'vertical') {
          y1 = this.from.y;
          y2 = this.to.y;
          x1 = this.from.x - roundness * dx;
          x2 = this.to.x + roundness * dx;
        } else {
          y1 = this.from.y - roundness * dy;
          y2 = this.to.y + roundness * dy;
          x1 = this.from.x;
          x2 = this.to.x;
        }

        return [{ x: x1, y: y1 }, { x: x2, y: y2 }];
      }
    }, {
      key: 'getViaNode',
      value: function getViaNode() {
        return this._getViaCoordinates();
      }
    }, {
      key: '_findBorderPosition',
      value: function _findBorderPosition(nearNode, ctx) {
        return this._findBorderPositionBezier(nearNode, ctx);
      }
    }, {
      key: '_getDistanceToEdge',
      value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
        var _ref = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this._getViaCoordinates(),
            _ref2 = _slicedToArray(_ref, 2),
            via1 = _ref2[0],
            via2 = _ref2[1];

        // x3,y3 is the point
        return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via1, via2);
      }

      /**
       * Combined function of pointOnLine and pointOnBezier. This gives the coordinates of a point on the line at a certain percentage of the way
       * @param percentage
       * @param via
       * @returns {{x: number, y: number}}
       * @private
       */

    }, {
      key: 'getPoint',
      value: function getPoint(percentage) {
        var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._getViaCoordinates(),
            _ref4 = _slicedToArray(_ref3, 2),
            via1 = _ref4[0],
            via2 = _ref4[1];

        var t = percentage;
        var vec = [];
        vec[0] = Math.pow(1 - t, 3);
        vec[1] = 3 * t * Math.pow(1 - t, 2);
        vec[2] = 3 * Math.pow(t, 2) * (1 - t);
        vec[3] = Math.pow(t, 3);
        var x = vec[0] * this.fromPoint.x + vec[1] * via1.x + vec[2] * via2.x + vec[3] * this.toPoint.x;
        var y = vec[0] * this.fromPoint.y + vec[1] * via1.y + vec[2] * via2.y + vec[3] * this.toPoint.y;

        return { x: x, y: y };
      }
    }]);

    return CubicBezierEdge;
  }(_CubicBezierEdgeBase3.default);

  exports.default = CubicBezierEdge;

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _BezierEdgeBase2 = __webpack_require__(90);

  var _BezierEdgeBase3 = _interopRequireDefault(_BezierEdgeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var CubicBezierEdgeBase = function (_BezierEdgeBase) {
    _inherits(CubicBezierEdgeBase, _BezierEdgeBase);

    function CubicBezierEdgeBase(options, body, labelModule) {
      _classCallCheck(this, CubicBezierEdgeBase);

      return _possibleConstructorReturn(this, (CubicBezierEdgeBase.__proto__ || Object.getPrototypeOf(CubicBezierEdgeBase)).call(this, options, body, labelModule));
    }

    /**
     * Calculate the distance between a point (x3,y3) and a line segment from
     * (x1,y1) to (x2,y2).
     * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
     * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
     * @param {number} x1 from x
     * @param {number} y1 from y
     * @param {number} x2 to x
     * @param {number} y2 to y
     * @param {number} x3 point to check x
     * @param {number} y3 point to check y
     * @private
     */


    _createClass(CubicBezierEdgeBase, [{
      key: '_getDistanceToBezierEdge',
      value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via1, via2) {
        // x3,y3 is the point
        var minDistance = 1e9;
        var distance = void 0;
        var i = void 0,
            t = void 0,
            x = void 0,
            y = void 0;
        var lastX = x1;
        var lastY = y1;
        var vec = [0, 0, 0, 0];
        for (i = 1; i < 10; i++) {
          t = 0.1 * i;
          vec[0] = Math.pow(1 - t, 3);
          vec[1] = 3 * t * Math.pow(1 - t, 2);
          vec[2] = 3 * Math.pow(t, 2) * (1 - t);
          vec[3] = Math.pow(t, 3);
          x = vec[0] * x1 + vec[1] * via1.x + vec[2] * via2.x + vec[3] * x2;
          y = vec[0] * y1 + vec[1] * via1.y + vec[2] * via2.y + vec[3] * y2;
          if (i > 0) {
            distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);
            minDistance = distance < minDistance ? distance : minDistance;
          }
          lastX = x;
          lastY = y;
        }

        return minDistance;
      }
    }]);

    return CubicBezierEdgeBase;
  }(_BezierEdgeBase3.default);

  exports.default = CubicBezierEdgeBase;

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _EdgeBase2 = __webpack_require__(91);

  var _EdgeBase3 = _interopRequireDefault(_EdgeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var BezierEdgeBase = function (_EdgeBase) {
    _inherits(BezierEdgeBase, _EdgeBase);

    function BezierEdgeBase(options, body, labelModule) {
      _classCallCheck(this, BezierEdgeBase);

      return _possibleConstructorReturn(this, (BezierEdgeBase.__proto__ || Object.getPrototypeOf(BezierEdgeBase)).call(this, options, body, labelModule));
    }

    /**
     * This function uses binary search to look for the point where the bezier curve crosses the border of the node.
     *
     * @param nearNode
     * @param ctx
     * @param viaNode
     * @param nearNode
     * @param ctx
     * @param viaNode
     * @param nearNode
     * @param ctx
     * @param viaNode
     */


    _createClass(BezierEdgeBase, [{
      key: '_findBorderPositionBezier',
      value: function _findBorderPositionBezier(nearNode, ctx) {
        var viaNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._getViaCoordinates();

        var maxIterations = 10;
        var iteration = 0;
        var low = 0;
        var high = 1;
        var pos, angle, distanceToBorder, distanceToPoint, difference;
        var threshold = 0.2;
        var node = this.to;
        var from = false;
        if (nearNode.id === this.from.id) {
          node = this.from;
          from = true;
        }

        while (low <= high && iteration < maxIterations) {
          var middle = (low + high) * 0.5;

          pos = this.getPoint(middle, viaNode);
          angle = Math.atan2(node.y - pos.y, node.x - pos.x);
          distanceToBorder = node.distanceToBorder(ctx, angle);
          distanceToPoint = Math.sqrt(Math.pow(pos.x - node.x, 2) + Math.pow(pos.y - node.y, 2));
          difference = distanceToBorder - distanceToPoint;
          if (Math.abs(difference) < threshold) {
            break; // found
          } else if (difference < 0) {
            // distance to nodes is larger than distance to border --> t needs to be bigger if we're looking at the to node.
            if (from === false) {
              low = middle;
            } else {
              high = middle;
            }
          } else {
            if (from === false) {
              high = middle;
            } else {
              low = middle;
            }
          }

          iteration++;
        }
        pos.t = middle;

        return pos;
      }

      /**
       * Calculate the distance between a point (x3,y3) and a line segment from
       * (x1,y1) to (x2,y2).
       * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
       * @param {number} x1 from x
       * @param {number} y1 from y
       * @param {number} x2 to x
       * @param {number} y2 to y
       * @param {number} x3 point to check x
       * @param {number} y3 point to check y
       * @private
       */

    }, {
      key: '_getDistanceToBezierEdge',
      value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via) {
        // x3,y3 is the point
        var minDistance = 1e9;
        var distance = void 0;
        var i = void 0,
            t = void 0,
            x = void 0,
            y = void 0;
        var lastX = x1;
        var lastY = y1;
        for (i = 1; i < 10; i++) {
          t = 0.1 * i;
          x = Math.pow(1 - t, 2) * x1 + 2 * t * (1 - t) * via.x + Math.pow(t, 2) * x2;
          y = Math.pow(1 - t, 2) * y1 + 2 * t * (1 - t) * via.y + Math.pow(t, 2) * y2;
          if (i > 0) {
            distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);
            minDistance = distance < minDistance ? distance : minDistance;
          }
          lastX = x;
          lastY = y;
        }

        return minDistance;
      }
    }]);

    return BezierEdgeBase;
  }(_EdgeBase3.default);

  exports.default = BezierEdgeBase;

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var EdgeBase = function () {
    function EdgeBase(options, body, labelModule) {
      _classCallCheck(this, EdgeBase);

      this.body = body;
      this.labelModule = labelModule;
      this.options = {};
      this.setOptions(options);
      this.colorDirty = true;
      this.color = {};
      this.selectionWidth = 2;
      this.hoverWidth = 1.5;
      this.fromPoint = this.from;
      this.toPoint = this.to;
    }

    _createClass(EdgeBase, [{
      key: 'connect',
      value: function connect() {
        this.from = this.body.nodes[this.options.from];
        this.to = this.body.nodes[this.options.to];
      }
    }, {
      key: 'cleanup',
      value: function cleanup() {
        return false;
      }
    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        this.options = options;
        this.from = this.body.nodes[this.options.from];
        this.to = this.body.nodes[this.options.to];
        this.id = this.options.id;
      }

      /**
       * Redraw a edge as a line
       * Draw this edge in the given canvas
       * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
       * @param {CanvasRenderingContext2D}   ctx
       * @private
       */

    }, {
      key: 'drawLine',
      value: function drawLine(ctx, selected, hover, viaNode) {
        // set style
        ctx.strokeStyle = this.getColor(ctx, selected, hover);
        ctx.lineWidth = this.getLineWidth(selected, hover);

        if (this.options.dashes !== false) {
          this._drawDashedLine(ctx, viaNode);
        } else {
          this._drawLine(ctx, viaNode);
        }
      }
    }, {
      key: '_drawLine',
      value: function _drawLine(ctx, viaNode, fromPoint, toPoint) {
        if (this.from != this.to) {
          // draw line
          this._line(ctx, viaNode, fromPoint, toPoint);
        } else {
          var _getCircleData2 = this._getCircleData(ctx),
              _getCircleData3 = _slicedToArray(_getCircleData2, 3),
              x = _getCircleData3[0],
              y = _getCircleData3[1],
              radius = _getCircleData3[2];

          this._circle(ctx, x, y, radius);
        }
      }
    }, {
      key: '_drawDashedLine',
      value: function _drawDashedLine(ctx, viaNode, fromPoint, toPoint) {
        ctx.lineCap = 'round';
        var pattern = [5, 5];
        if (Array.isArray(this.options.dashes) === true) {
          pattern = this.options.dashes;
        }

        // only firefox and chrome support this method, else we use the legacy one.
        if (ctx.setLineDash !== undefined) {
          ctx.save();

          // set dash settings for chrome or firefox
          ctx.setLineDash(pattern);
          ctx.lineDashOffset = 0;

          // draw the line
          if (this.from != this.to) {
            // draw line
            this._line(ctx, viaNode);
          } else {
            var _getCircleData4 = this._getCircleData(ctx),
                _getCircleData5 = _slicedToArray(_getCircleData4, 3),
                x = _getCircleData5[0],
                y = _getCircleData5[1],
                radius = _getCircleData5[2];

            this._circle(ctx, x, y, radius);
          }

          // restore the dash settings.
          ctx.setLineDash([0]);
          ctx.lineDashOffset = 0;
          ctx.restore();
        } else {
          // unsupporting smooth lines
          if (this.from != this.to) {
            // draw line
            ctx.dashedLine(this.from.x, this.from.y, this.to.x, this.to.y, pattern);
          } else {
            var _getCircleData6 = this._getCircleData(ctx),
                _getCircleData7 = _slicedToArray(_getCircleData6, 3),
                _x = _getCircleData7[0],
                _y = _getCircleData7[1],
                _radius = _getCircleData7[2];

            this._circle(ctx, _x, _y, _radius);
          }
          // draw shadow if enabled
          this.enableShadow(ctx);

          ctx.stroke();

          // disable shadows for other elements.
          this.disableShadow(ctx);
        }
      }
    }, {
      key: 'findBorderPosition',
      value: function findBorderPosition(nearNode, ctx, options) {
        if (this.from != this.to) {
          return this._findBorderPosition(nearNode, ctx, options);
        } else {
          return this._findBorderPositionCircle(nearNode, ctx, options);
        }
      }
    }, {
      key: 'findBorderPositions',
      value: function findBorderPositions(ctx) {
        var from = {};
        var to = {};
        if (this.from != this.to) {
          from = this._findBorderPosition(this.from, ctx);
          to = this._findBorderPosition(this.to, ctx);
        } else {
          var _getCircleData8 = this._getCircleData(ctx),
              _getCircleData9 = _slicedToArray(_getCircleData8, 3),
              x = _getCircleData9[0],
              y = _getCircleData9[1],
              radius = _getCircleData9[2];

          from = this._findBorderPositionCircle(this.from, ctx, { x: x, y: y, low: 0.25, high: 0.6, direction: -1 });
          to = this._findBorderPositionCircle(this.from, ctx, { x: x, y: y, low: 0.6, high: 0.8, direction: 1 });
        }
        return { from: from, to: to };
      }
    }, {
      key: '_getCircleData',
      value: function _getCircleData(ctx) {
        var x = void 0,
            y = void 0;
        var node = this.from;
        var radius = this.options.selfReferenceSize;

        if (ctx !== undefined) {
          if (node.shape.width === undefined) {
            node.shape.resize(ctx);
          }
        }

        // get circle coordinates
        if (node.shape.width > node.shape.height) {
          x = node.x + node.shape.width * 0.5;
          y = node.y - radius;
        } else {
          x = node.x + radius;
          y = node.y - node.shape.height * 0.5;
        }
        return [x, y, radius];
      }

      /**
       * Get a point on a circle
       * @param {Number} x
       * @param {Number} y
       * @param {Number} radius
       * @param {Number} percentage. Value between 0 (line start) and 1 (line end)
       * @return {Object} point
       * @private
       */

    }, {
      key: '_pointOnCircle',
      value: function _pointOnCircle(x, y, radius, percentage) {
        var angle = percentage * 2 * Math.PI;
        return {
          x: x + radius * Math.cos(angle),
          y: y - radius * Math.sin(angle)
        };
      }

      /**
       * This function uses binary search to look for the point where the circle crosses the border of the node.
       * @param node
       * @param ctx
       * @param options
       * @returns {*}
       * @private
       */

    }, {
      key: '_findBorderPositionCircle',
      value: function _findBorderPositionCircle(node, ctx, options) {
        var x = options.x;
        var y = options.y;
        var low = options.low;
        var high = options.high;
        var direction = options.direction;

        var maxIterations = 10;
        var iteration = 0;
        var radius = this.options.selfReferenceSize;
        var pos = void 0,
            angle = void 0,
            distanceToBorder = void 0,
            distanceToPoint = void 0,
            difference = void 0;
        var threshold = 0.05;
        var middle = (low + high) * 0.5;

        while (low <= high && iteration < maxIterations) {
          middle = (low + high) * 0.5;

          pos = this._pointOnCircle(x, y, radius, middle);
          angle = Math.atan2(node.y - pos.y, node.x - pos.x);
          distanceToBorder = node.distanceToBorder(ctx, angle);
          distanceToPoint = Math.sqrt(Math.pow(pos.x - node.x, 2) + Math.pow(pos.y - node.y, 2));
          difference = distanceToBorder - distanceToPoint;
          if (Math.abs(difference) < threshold) {
            break; // found
          } else if (difference > 0) {
            // distance to nodes is larger than distance to border --> t needs to be bigger if we're looking at the to node.
            if (direction > 0) {
              low = middle;
            } else {
              high = middle;
            }
          } else {
            if (direction > 0) {
              high = middle;
            } else {
              low = middle;
            }
          }
          iteration++;
        }
        pos.t = middle;

        return pos;
      }

      /**
       * Get the line width of the edge. Depends on width and whether one of the
       * connected nodes is selected.
       * @return {Number} width
       * @private
       */

    }, {
      key: 'getLineWidth',
      value: function getLineWidth(selected, hover) {
        if (selected === true) {
          return Math.max(this.selectionWidth, 0.3 / this.body.view.scale);
        } else {
          if (hover === true) {
            return Math.max(this.hoverWidth, 0.3 / this.body.view.scale);
          } else {
            return Math.max(this.options.width, 0.3 / this.body.view.scale);
          }
        }
      }
    }, {
      key: 'getColor',
      value: function getColor(ctx, selected, hover) {
        var colorOptions = this.options.color;
        if (colorOptions.inherit !== false) {
          // when this is a loop edge, just use the 'from' method
          if (colorOptions.inherit === 'both' && this.from.id !== this.to.id) {
            var grd = ctx.createLinearGradient(this.from.x, this.from.y, this.to.x, this.to.y);
            var fromColor = void 0,
                toColor = void 0;
            fromColor = this.from.options.color.highlight.border;
            toColor = this.to.options.color.highlight.border;

            if (this.from.selected === false && this.to.selected === false) {
              fromColor = util.overrideOpacity(this.from.options.color.border, this.options.color.opacity);
              toColor = util.overrideOpacity(this.to.options.color.border, this.options.color.opacity);
            } else if (this.from.selected === true && this.to.selected === false) {
              toColor = this.to.options.color.border;
            } else if (this.from.selected === false && this.to.selected === true) {
              fromColor = this.from.options.color.border;
            }
            grd.addColorStop(0, fromColor);
            grd.addColorStop(1, toColor);

            // -------------------- this returns -------------------- //
            return grd;
          }

          if (this.colorDirty === true) {
            if (colorOptions.inherit === "to") {
              this.color.highlight = this.to.options.color.highlight.border;
              this.color.hover = this.to.options.color.hover.border;
              this.color.color = util.overrideOpacity(this.to.options.color.border, colorOptions.opacity);
            } else {
              // (this.options.color.inherit.source === "from") {
              this.color.highlight = this.from.options.color.highlight.border;
              this.color.hover = this.from.options.color.hover.border;
              this.color.color = util.overrideOpacity(this.from.options.color.border, colorOptions.opacity);
            }
          }
        } else if (this.colorDirty === true) {
          this.color.highlight = colorOptions.highlight;
          this.color.hover = colorOptions.hover;
          this.color.color = util.overrideOpacity(colorOptions.color, colorOptions.opacity);
        }

        // if color inherit is on and gradients are used, the function has already returned by now.
        this.colorDirty = false;

        if (selected === true) {
          return this.color.highlight;
        } else if (hover === true) {
          return this.color.hover;
        } else {
          return this.color.color;
        }
      }

      /**
       * Draw a line from a node to itself, a circle
       * @param {CanvasRenderingContext2D} ctx
       * @param {Number} x
       * @param {Number} y
       * @param {Number} radius
       * @private
       */

    }, {
      key: '_circle',
      value: function _circle(ctx, x, y, radius) {
        // draw shadow if enabled
        this.enableShadow(ctx);

        // draw a circle
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI, false);
        ctx.stroke();

        // disable shadows for other elements.
        this.disableShadow(ctx);
      }

      /**
       * Calculate the distance between a point (x3,y3) and a line segment from
       * (x1,y1) to (x2,y2).
       * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
       * @param {number} x1
       * @param {number} y1
       * @param {number} x2
       * @param {number} y2
       * @param {number} x3
       * @param {number} y3
       * @private
       */

    }, {
      key: 'getDistanceToEdge',
      value: function getDistanceToEdge(x1, y1, x2, y2, x3, y3, via) {
        // x3,y3 is the point
        var returnValue = 0;
        if (this.from != this.to) {
          returnValue = this._getDistanceToEdge(x1, y1, x2, y2, x3, y3, via);
        } else {
          var _getCircleData10 = this._getCircleData(),
              _getCircleData11 = _slicedToArray(_getCircleData10, 3),
              x = _getCircleData11[0],
              y = _getCircleData11[1],
              radius = _getCircleData11[2];

          var dx = x - x3;
          var dy = y - y3;
          returnValue = Math.abs(Math.sqrt(dx * dx + dy * dy) - radius);
        }

        if (this.labelModule.size.left < x3 && this.labelModule.size.left + this.labelModule.size.width > x3 && this.labelModule.size.top < y3 && this.labelModule.size.top + this.labelModule.size.height > y3) {
          return 0;
        } else {
          return returnValue;
        }
      }
    }, {
      key: '_getDistanceToLine',
      value: function _getDistanceToLine(x1, y1, x2, y2, x3, y3) {
        var px = x2 - x1;
        var py = y2 - y1;
        var something = px * px + py * py;
        var u = ((x3 - x1) * px + (y3 - y1) * py) / something;

        if (u > 1) {
          u = 1;
        } else if (u < 0) {
          u = 0;
        }

        var x = x1 + u * px;
        var y = y1 + u * py;
        var dx = x - x3;
        var dy = y - y3;

        //# Note: If the actual distance does not matter,
        //# if you only want to compare what this function
        //# returns to other results of this function, you
        //# can just return the squared distance instead
        //# (i.e. remove the sqrt) to gain a little performance

        return Math.sqrt(dx * dx + dy * dy);
      }

      /**
       *
       * @param ctx
       * @param position
       * @param viaNode
       */

    }, {
      key: 'getArrowData',
      value: function getArrowData(ctx, position, viaNode, selected, hover) {
        // set lets
        var angle = void 0;
        var arrowPoint = void 0;
        var node1 = void 0;
        var node2 = void 0;
        var guideOffset = void 0;
        var scaleFactor = void 0;
        var type = void 0;
        var lineWidth = this.getLineWidth(selected, hover);

        if (position === 'from') {
          node1 = this.from;
          node2 = this.to;
          guideOffset = 0.1;
          scaleFactor = this.options.arrows.from.scaleFactor;
          type = this.options.arrows.from.type;
        } else if (position === 'to') {
          node1 = this.to;
          node2 = this.from;
          guideOffset = -0.1;
          scaleFactor = this.options.arrows.to.scaleFactor;
          type = this.options.arrows.to.type;
        } else {
          node1 = this.to;
          node2 = this.from;
          scaleFactor = this.options.arrows.middle.scaleFactor;
          type = this.options.arrows.middle.type;
        }

        // if not connected to itself
        if (node1 != node2) {
          if (position !== 'middle') {
            // draw arrow head
            if (this.options.smooth.enabled === true) {
              arrowPoint = this.findBorderPosition(node1, ctx, { via: viaNode });
              var guidePos = this.getPoint(Math.max(0.0, Math.min(1.0, arrowPoint.t + guideOffset)), viaNode);
              angle = Math.atan2(arrowPoint.y - guidePos.y, arrowPoint.x - guidePos.x);
            } else {
              angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
              arrowPoint = this.findBorderPosition(node1, ctx);
            }
          } else {
            angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
            arrowPoint = this.getPoint(0.5, viaNode); // this is 0.6 to account for the size of the arrow.
          }
        } else {
          // draw circle
          var _getCircleData12 = this._getCircleData(ctx),
              _getCircleData13 = _slicedToArray(_getCircleData12, 3),
              x = _getCircleData13[0],
              y = _getCircleData13[1],
              radius = _getCircleData13[2];

          if (position === 'from') {
            arrowPoint = this.findBorderPosition(this.from, ctx, { x: x, y: y, low: 0.25, high: 0.6, direction: -1 });
            angle = arrowPoint.t * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;
          } else if (position === 'to') {
            arrowPoint = this.findBorderPosition(this.from, ctx, { x: x, y: y, low: 0.6, high: 1.0, direction: 1 });
            angle = arrowPoint.t * -2 * Math.PI + 1.5 * Math.PI - 1.1 * Math.PI;
          } else {
            arrowPoint = this._pointOnCircle(x, y, radius, 0.175);
            angle = 3.9269908169872414; // === 0.175 * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;
          }
        }

        var length = 15 * scaleFactor + 3 * lineWidth; // 3* lineWidth is the width of the edge.

        var xi = arrowPoint.x - length * 0.9 * Math.cos(angle);
        var yi = arrowPoint.y - length * 0.9 * Math.sin(angle);
        var arrowCore = { x: xi, y: yi };

        return { point: arrowPoint, core: arrowCore, angle: angle, length: length, type: type };
      }

      /**
       *
       * @param ctx
       * @param selected
       * @param hover
       * @param arrowData
       */

    }, {
      key: 'drawArrowHead',
      value: function drawArrowHead(ctx, selected, hover, arrowData) {
        // set style
        ctx.strokeStyle = this.getColor(ctx, selected, hover);
        ctx.fillStyle = ctx.strokeStyle;
        ctx.lineWidth = this.getLineWidth(selected, hover);

        if (arrowData.type && arrowData.type.toLowerCase() === 'circle') {
          // draw circle at the end of the line
          ctx.circleEndpoint(arrowData.point.x, arrowData.point.y, arrowData.angle, arrowData.length);
        } else {
          // draw arrow at the end of the line
          ctx.arrowEndpoint(arrowData.point.x, arrowData.point.y, arrowData.angle, arrowData.length);
        }

        // draw shadow if enabled
        this.enableShadow(ctx);
        ctx.fill();
        // disable shadows for other elements.
        this.disableShadow(ctx);
      }
    }, {
      key: 'enableShadow',
      value: function enableShadow(ctx) {
        if (this.options.shadow.enabled === true) {
          ctx.shadowColor = this.options.shadow.color;
          ctx.shadowBlur = this.options.shadow.size;
          ctx.shadowOffsetX = this.options.shadow.x;
          ctx.shadowOffsetY = this.options.shadow.y;
        }
      }
    }, {
      key: 'disableShadow',
      value: function disableShadow(ctx) {
        if (this.options.shadow.enabled === true) {
          ctx.shadowColor = 'rgba(0,0,0,0)';
          ctx.shadowBlur = 0;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 0;
        }
      }
    }]);

    return EdgeBase;
  }();

  exports.default = EdgeBase;

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _BezierEdgeBase2 = __webpack_require__(90);

  var _BezierEdgeBase3 = _interopRequireDefault(_BezierEdgeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var BezierEdgeDynamic = function (_BezierEdgeBase) {
    _inherits(BezierEdgeDynamic, _BezierEdgeBase);

    function BezierEdgeDynamic(options, body, labelModule) {
      _classCallCheck(this, BezierEdgeDynamic);

      // --> this calls the setOptions below
      var _this = _possibleConstructorReturn(this, (BezierEdgeDynamic.__proto__ || Object.getPrototypeOf(BezierEdgeDynamic)).call(this, options, body, labelModule));
      //this.via = undefined; // Here for completeness but not allowed to defined before super() is invoked.


      _this._boundFunction = function () {
        _this.positionBezierNode();
      };
      _this.body.emitter.on("_repositionBezierNodes", _this._boundFunction);
      return _this;
    }

    _createClass(BezierEdgeDynamic, [{
      key: "setOptions",
      value: function setOptions(options) {
        // check if the physics has changed.
        var physicsChange = false;
        if (this.options.physics !== options.physics) {
          physicsChange = true;
        }

        // set the options and the to and from nodes
        this.options = options;
        this.id = this.options.id;
        this.from = this.body.nodes[this.options.from];
        this.to = this.body.nodes[this.options.to];

        // setup the support node and connect
        this.setupSupportNode();
        this.connect();

        // when we change the physics state of the edge, we reposition the support node.
        if (physicsChange === true) {
          this.via.setOptions({ physics: this.options.physics });
          this.positionBezierNode();
        }
      }
    }, {
      key: "connect",
      value: function connect() {
        this.from = this.body.nodes[this.options.from];
        this.to = this.body.nodes[this.options.to];
        if (this.from === undefined || this.to === undefined || this.options.physics === false) {
          this.via.setOptions({ physics: false });
        } else {
          // fix weird behaviour where a self referencing node has physics enabled
          if (this.from.id === this.to.id) {
            this.via.setOptions({ physics: false });
          } else {
            this.via.setOptions({ physics: true });
          }
        }
      }

      /**
       * remove the support nodes
       * @returns {boolean}
       */

    }, {
      key: "cleanup",
      value: function cleanup() {
        this.body.emitter.off("_repositionBezierNodes", this._boundFunction);
        if (this.via !== undefined) {
          delete this.body.nodes[this.via.id];
          this.via = undefined;
          return true;
        }
        return false;
      }

      /**
       * Bezier curves require an anchor point to calculate the smooth flow. These points are nodes. These nodes are invisible but
       * are used for the force calculation.
       *
       * The changed data is not called, if needed, it is returned by the main edge constructor.
       * @private
       */

    }, {
      key: "setupSupportNode",
      value: function setupSupportNode() {
        if (this.via === undefined) {
          var nodeId = "edgeId:" + this.id;
          var node = this.body.functions.createNode({
            id: nodeId,
            shape: 'circle',
            physics: true,
            hidden: true
          });
          this.body.nodes[nodeId] = node;
          this.via = node;
          this.via.parentEdgeId = this.id;
          this.positionBezierNode();
        }
      }
    }, {
      key: "positionBezierNode",
      value: function positionBezierNode() {
        if (this.via !== undefined && this.from !== undefined && this.to !== undefined) {
          this.via.x = 0.5 * (this.from.x + this.to.x);
          this.via.y = 0.5 * (this.from.y + this.to.y);
        } else if (this.via !== undefined) {
          this.via.x = 0;
          this.via.y = 0;
        }
      }

      /**
       * Draw a line between two nodes
       * @param {CanvasRenderingContext2D} ctx
       * @private
       */

    }, {
      key: "_line",
      value: function _line(ctx, viaNode) {
        // draw a straight line
        ctx.beginPath();
        ctx.moveTo(this.fromPoint.x, this.fromPoint.y);
        // fallback to normal straight edges
        if (viaNode.x === undefined) {
          ctx.lineTo(this.toPoint.x, this.toPoint.y);
        } else {
          ctx.quadraticCurveTo(viaNode.x, viaNode.y, this.toPoint.x, this.toPoint.y);
        }
        // draw shadow if enabled
        this.enableShadow(ctx);
        ctx.stroke();
        this.disableShadow(ctx);
      }
    }, {
      key: "getViaNode",
      value: function getViaNode() {
        return this.via;
      }

      /**
       * Combined function of pointOnLine and pointOnBezier. This gives the coordinates of a point on the line at a certain percentage of the way
       * @param percentage
       * @param viaNode
       * @returns {{x: number, y: number}}
       * @private
       */

    }, {
      key: "getPoint",
      value: function getPoint(percentage) {
        var viaNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.via;

        var t = percentage;
        var x = void 0,
            y = void 0;
        if (this.from === this.to) {
          var _getCircleData = this._getCircleData(this.from),
              _getCircleData2 = _slicedToArray(_getCircleData, 3),
              cx = _getCircleData2[0],
              cy = _getCircleData2[1],
              cr = _getCircleData2[2];

          var a = 2 * Math.PI * (1 - t);
          x = cx + cr * Math.sin(a);
          y = cy + cr - cr * (1 - Math.cos(a));
        } else {
          x = Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * viaNode.x + Math.pow(t, 2) * this.toPoint.x;
          y = Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * viaNode.y + Math.pow(t, 2) * this.toPoint.y;
        }

        return { x: x, y: y };
      }
    }, {
      key: "_findBorderPosition",
      value: function _findBorderPosition(nearNode, ctx) {
        return this._findBorderPositionBezier(nearNode, ctx, this.via);
      }
    }, {
      key: "_getDistanceToEdge",
      value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
        // x3,y3 is the point
        return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, this.via);
      }
    }]);

    return BezierEdgeDynamic;
  }(_BezierEdgeBase3.default);

  exports.default = BezierEdgeDynamic;

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _BezierEdgeBase2 = __webpack_require__(90);

  var _BezierEdgeBase3 = _interopRequireDefault(_BezierEdgeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var BezierEdgeStatic = function (_BezierEdgeBase) {
    _inherits(BezierEdgeStatic, _BezierEdgeBase);

    function BezierEdgeStatic(options, body, labelModule) {
      _classCallCheck(this, BezierEdgeStatic);

      return _possibleConstructorReturn(this, (BezierEdgeStatic.__proto__ || Object.getPrototypeOf(BezierEdgeStatic)).call(this, options, body, labelModule));
    }

    /**
     * Draw a line between two nodes
     * @param {CanvasRenderingContext2D} ctx
     * @private
     */


    _createClass(BezierEdgeStatic, [{
      key: '_line',
      value: function _line(ctx, viaNode) {
        // draw a straight line
        ctx.beginPath();
        ctx.moveTo(this.fromPoint.x, this.fromPoint.y);

        // fallback to normal straight edges
        if (viaNode.x === undefined) {
          ctx.lineTo(this.toPoint.x, this.toPoint.y);
        } else {
          ctx.quadraticCurveTo(viaNode.x, viaNode.y, this.toPoint.x, this.toPoint.y);
        }
        // draw shadow if enabled
        this.enableShadow(ctx);
        ctx.stroke();
        this.disableShadow(ctx);
      }
    }, {
      key: 'getViaNode',
      value: function getViaNode() {
        return this._getViaCoordinates();
      }

      /**
       * We do not use the to and fromPoints here to make the via nodes the same as edges without arrows.
       * @returns {{x: undefined, y: undefined}}
       * @private
       */

    }, {
      key: '_getViaCoordinates',
      value: function _getViaCoordinates() {
        var xVia = undefined;
        var yVia = undefined;
        var factor = this.options.smooth.roundness;
        var type = this.options.smooth.type;
        var dx = Math.abs(this.from.x - this.to.x);
        var dy = Math.abs(this.from.y - this.to.y);
        if (type === 'discrete' || type === 'diagonalCross') {
          if (Math.abs(this.from.x - this.to.x) <= Math.abs(this.from.y - this.to.y)) {
            if (this.from.y >= this.to.y) {
              if (this.from.x <= this.to.x) {
                xVia = this.from.x + factor * dy;
                yVia = this.from.y - factor * dy;
              } else if (this.from.x > this.to.x) {
                xVia = this.from.x - factor * dy;
                yVia = this.from.y - factor * dy;
              }
            } else if (this.from.y < this.to.y) {
              if (this.from.x <= this.to.x) {
                xVia = this.from.x + factor * dy;
                yVia = this.from.y + factor * dy;
              } else if (this.from.x > this.to.x) {
                xVia = this.from.x - factor * dy;
                yVia = this.from.y + factor * dy;
              }
            }
            if (type === "discrete") {
              xVia = dx < factor * dy ? this.from.x : xVia;
            }
          } else if (Math.abs(this.from.x - this.to.x) > Math.abs(this.from.y - this.to.y)) {
            if (this.from.y >= this.to.y) {
              if (this.from.x <= this.to.x) {
                xVia = this.from.x + factor * dx;
                yVia = this.from.y - factor * dx;
              } else if (this.from.x > this.to.x) {
                xVia = this.from.x - factor * dx;
                yVia = this.from.y - factor * dx;
              }
            } else if (this.from.y < this.to.y) {
              if (this.from.x <= this.to.x) {
                xVia = this.from.x + factor * dx;
                yVia = this.from.y + factor * dx;
              } else if (this.from.x > this.to.x) {
                xVia = this.from.x - factor * dx;
                yVia = this.from.y + factor * dx;
              }
            }
            if (type === "discrete") {
              yVia = dy < factor * dx ? this.from.y : yVia;
            }
          }
        } else if (type === "straightCross") {
          if (Math.abs(this.from.x - this.to.x) <= Math.abs(this.from.y - this.to.y)) {
            // up - down
            xVia = this.from.x;
            if (this.from.y < this.to.y) {
              yVia = this.to.y - (1 - factor) * dy;
            } else {
              yVia = this.to.y + (1 - factor) * dy;
            }
          } else if (Math.abs(this.from.x - this.to.x) > Math.abs(this.from.y - this.to.y)) {
            // left - right
            if (this.from.x < this.to.x) {
              xVia = this.to.x - (1 - factor) * dx;
            } else {
              xVia = this.to.x + (1 - factor) * dx;
            }
            yVia = this.from.y;
          }
        } else if (type === 'horizontal') {
          if (this.from.x < this.to.x) {
            xVia = this.to.x - (1 - factor) * dx;
          } else {
            xVia = this.to.x + (1 - factor) * dx;
          }
          yVia = this.from.y;
        } else if (type === 'vertical') {
          xVia = this.from.x;
          if (this.from.y < this.to.y) {
            yVia = this.to.y - (1 - factor) * dy;
          } else {
            yVia = this.to.y + (1 - factor) * dy;
          }
        } else if (type === 'curvedCW') {
          dx = this.to.x - this.from.x;
          dy = this.from.y - this.to.y;
          var radius = Math.sqrt(dx * dx + dy * dy);
          var pi = Math.PI;

          var originalAngle = Math.atan2(dy, dx);
          var myAngle = (originalAngle + (factor * 0.5 + 0.5) * pi) % (2 * pi);

          xVia = this.from.x + (factor * 0.5 + 0.5) * radius * Math.sin(myAngle);
          yVia = this.from.y + (factor * 0.5 + 0.5) * radius * Math.cos(myAngle);
        } else if (type === 'curvedCCW') {
          dx = this.to.x - this.from.x;
          dy = this.from.y - this.to.y;
          var _radius = Math.sqrt(dx * dx + dy * dy);
          var _pi = Math.PI;

          var _originalAngle = Math.atan2(dy, dx);
          var _myAngle = (_originalAngle + (-factor * 0.5 + 0.5) * _pi) % (2 * _pi);

          xVia = this.from.x + (factor * 0.5 + 0.5) * _radius * Math.sin(_myAngle);
          yVia = this.from.y + (factor * 0.5 + 0.5) * _radius * Math.cos(_myAngle);
        } else {
          // continuous
          if (Math.abs(this.from.x - this.to.x) <= Math.abs(this.from.y - this.to.y)) {
            if (this.from.y >= this.to.y) {
              if (this.from.x <= this.to.x) {
                xVia = this.from.x + factor * dy;
                yVia = this.from.y - factor * dy;
                xVia = this.to.x < xVia ? this.to.x : xVia;
              } else if (this.from.x > this.to.x) {
                xVia = this.from.x - factor * dy;
                yVia = this.from.y - factor * dy;
                xVia = this.to.x > xVia ? this.to.x : xVia;
              }
            } else if (this.from.y < this.to.y) {
              if (this.from.x <= this.to.x) {
                xVia = this.from.x + factor * dy;
                yVia = this.from.y + factor * dy;
                xVia = this.to.x < xVia ? this.to.x : xVia;
              } else if (this.from.x > this.to.x) {
                xVia = this.from.x - factor * dy;
                yVia = this.from.y + factor * dy;
                xVia = this.to.x > xVia ? this.to.x : xVia;
              }
            }
          } else if (Math.abs(this.from.x - this.to.x) > Math.abs(this.from.y - this.to.y)) {
            if (this.from.y >= this.to.y) {
              if (this.from.x <= this.to.x) {
                xVia = this.from.x + factor * dx;
                yVia = this.from.y - factor * dx;
                yVia = this.to.y > yVia ? this.to.y : yVia;
              } else if (this.from.x > this.to.x) {
                xVia = this.from.x - factor * dx;
                yVia = this.from.y - factor * dx;
                yVia = this.to.y > yVia ? this.to.y : yVia;
              }
            } else if (this.from.y < this.to.y) {
              if (this.from.x <= this.to.x) {
                xVia = this.from.x + factor * dx;
                yVia = this.from.y + factor * dx;
                yVia = this.to.y < yVia ? this.to.y : yVia;
              } else if (this.from.x > this.to.x) {
                xVia = this.from.x - factor * dx;
                yVia = this.from.y + factor * dx;
                yVia = this.to.y < yVia ? this.to.y : yVia;
              }
            }
          }
        }
        return { x: xVia, y: yVia };
      }
    }, {
      key: '_findBorderPosition',
      value: function _findBorderPosition(nearNode, ctx) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        return this._findBorderPositionBezier(nearNode, ctx, options.via);
      }
    }, {
      key: '_getDistanceToEdge',
      value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
        var viaNode = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this._getViaCoordinates();
        // x3,y3 is the point
        return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, viaNode);
      }

      /**
       * Combined function of pointOnLine and pointOnBezier. This gives the coordinates of a point on the line at a certain percentage of the way
       * @param percentage
       * @param viaNode
       * @returns {{x: number, y: number}}
       * @private
       */

    }, {
      key: 'getPoint',
      value: function getPoint(percentage) {
        var viaNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._getViaCoordinates();

        var t = percentage;
        var x = Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * viaNode.x + Math.pow(t, 2) * this.toPoint.x;
        var y = Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * viaNode.y + Math.pow(t, 2) * this.toPoint.y;

        return { x: x, y: y };
      }
    }]);

    return BezierEdgeStatic;
  }(_BezierEdgeBase3.default);

  exports.default = BezierEdgeStatic;

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _EdgeBase2 = __webpack_require__(91);

  var _EdgeBase3 = _interopRequireDefault(_EdgeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var StraightEdge = function (_EdgeBase) {
    _inherits(StraightEdge, _EdgeBase);

    function StraightEdge(options, body, labelModule) {
      _classCallCheck(this, StraightEdge);

      return _possibleConstructorReturn(this, (StraightEdge.__proto__ || Object.getPrototypeOf(StraightEdge)).call(this, options, body, labelModule));
    }

    /**
     * Draw a line between two nodes
     * @param {CanvasRenderingContext2D} ctx
     * @private
     */


    _createClass(StraightEdge, [{
      key: '_line',
      value: function _line(ctx) {
        // draw a straight line
        ctx.beginPath();
        ctx.moveTo(this.fromPoint.x, this.fromPoint.y);
        ctx.lineTo(this.toPoint.x, this.toPoint.y);
        // draw shadow if enabled
        this.enableShadow(ctx);
        ctx.stroke();
        this.disableShadow(ctx);
      }
    }, {
      key: 'getViaNode',
      value: function getViaNode() {
        return undefined;
      }

      /**
       * Combined function of pointOnLine and pointOnBezier. This gives the coordinates of a point on the line at a certain percentage of the way
       * @param percentage
       * @param via
       * @returns {{x: number, y: number}}
       * @private
       */

    }, {
      key: 'getPoint',
      value: function getPoint(percentage) {
        return {
          x: (1 - percentage) * this.fromPoint.x + percentage * this.toPoint.x,
          y: (1 - percentage) * this.fromPoint.y + percentage * this.toPoint.y
        };
      }
    }, {
      key: '_findBorderPosition',
      value: function _findBorderPosition(nearNode, ctx) {
        var node1 = this.to;
        var node2 = this.from;
        if (nearNode.id === this.from.id) {
          node1 = this.from;
          node2 = this.to;
        }

        var angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
        var dx = node1.x - node2.x;
        var dy = node1.y - node2.y;
        var edgeSegmentLength = Math.sqrt(dx * dx + dy * dy);
        var toBorderDist = nearNode.distanceToBorder(ctx, angle);
        var toBorderPoint = (edgeSegmentLength - toBorderDist) / edgeSegmentLength;

        var borderPos = {};
        borderPos.x = (1 - toBorderPoint) * node2.x + toBorderPoint * node1.x;
        borderPos.y = (1 - toBorderPoint) * node2.y + toBorderPoint * node1.y;

        return borderPos;
      }
    }, {
      key: '_getDistanceToEdge',
      value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
        // x3,y3 is the point
        return this._getDistanceToLine(x1, y1, x2, y2, x3, y3);
      }
    }]);

    return StraightEdge;
  }(_EdgeBase3.default);

  exports.default = StraightEdge;

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _BarnesHutSolver = __webpack_require__(96);

  var _BarnesHutSolver2 = _interopRequireDefault(_BarnesHutSolver);

  var _RepulsionSolver = __webpack_require__(97);

  var _RepulsionSolver2 = _interopRequireDefault(_RepulsionSolver);

  var _HierarchicalRepulsionSolver = __webpack_require__(98);

  var _HierarchicalRepulsionSolver2 = _interopRequireDefault(_HierarchicalRepulsionSolver);

  var _SpringSolver = __webpack_require__(99);

  var _SpringSolver2 = _interopRequireDefault(_SpringSolver);

  var _HierarchicalSpringSolver = __webpack_require__(100);

  var _HierarchicalSpringSolver2 = _interopRequireDefault(_HierarchicalSpringSolver);

  var _CentralGravitySolver = __webpack_require__(101);

  var _CentralGravitySolver2 = _interopRequireDefault(_CentralGravitySolver);

  var _FA2BasedRepulsionSolver = __webpack_require__(102);

  var _FA2BasedRepulsionSolver2 = _interopRequireDefault(_FA2BasedRepulsionSolver);

  var _FA2BasedCentralGravitySolver = __webpack_require__(103);

  var _FA2BasedCentralGravitySolver2 = _interopRequireDefault(_FA2BasedCentralGravitySolver);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var PhysicsEngine = function () {
    function PhysicsEngine(body) {
      _classCallCheck(this, PhysicsEngine);

      this.body = body;
      this.physicsBody = { physicsNodeIndices: [], physicsEdgeIndices: [], forces: {}, velocities: {} };

      this.physicsEnabled = true;
      this.simulationInterval = 1000 / 60;
      this.requiresTimeout = true;
      this.previousStates = {};
      this.referenceState = {};
      this.freezeCache = {};
      this.renderTimer = undefined;

      // parameters for the adaptive timestep
      this.adaptiveTimestep = false;
      this.adaptiveTimestepEnabled = false;
      this.adaptiveCounter = 0;
      this.adaptiveInterval = 3;

      this.stabilized = false;
      this.startedStabilization = false;
      this.stabilizationIterations = 0;
      this.ready = false; // will be set to true if the stabilize

      // default options
      this.options = {};
      this.defaultOptions = {
        enabled: true,
        barnesHut: {
          theta: 0.5,
          gravitationalConstant: -2000,
          centralGravity: 0.3,
          springLength: 95,
          springConstant: 0.04,
          damping: 0.09,
          avoidOverlap: 0
        },
        forceAtlas2Based: {
          theta: 0.5,
          gravitationalConstant: -50,
          centralGravity: 0.01,
          springConstant: 0.08,
          springLength: 100,
          damping: 0.4,
          avoidOverlap: 0
        },
        repulsion: {
          centralGravity: 0.2,
          springLength: 200,
          springConstant: 0.05,
          nodeDistance: 100,
          damping: 0.09,
          avoidOverlap: 0
        },
        hierarchicalRepulsion: {
          centralGravity: 0.0,
          springLength: 100,
          springConstant: 0.01,
          nodeDistance: 120,
          damping: 0.09
        },
        maxVelocity: 50,
        minVelocity: 0.75, // px/s
        solver: 'barnesHut',
        stabilization: {
          enabled: true,
          iterations: 1000, // maximum number of iteration to stabilize
          updateInterval: 50,
          onlyDynamicEdges: false,
          fit: true
        },
        timestep: 0.5,
        adaptiveTimestep: true
      };
      util.extend(this.options, this.defaultOptions);
      this.timestep = 0.5;
      this.layoutFailed = false;

      this.bindEventListeners();
    }

    _createClass(PhysicsEngine, [{
      key: 'bindEventListeners',
      value: function bindEventListeners() {
        var _this = this;

        this.body.emitter.on('initPhysics', function () {
          _this.initPhysics();
        });
        this.body.emitter.on('_layoutFailed', function () {
          _this.layoutFailed = true;
        });
        this.body.emitter.on('resetPhysics', function () {
          _this.stopSimulation();_this.ready = false;
        });
        this.body.emitter.on('disablePhysics', function () {
          _this.physicsEnabled = false;_this.stopSimulation();
        });
        this.body.emitter.on('restorePhysics', function () {
          _this.setOptions(_this.options);
          if (_this.ready === true) {
            _this.startSimulation();
          }
        });
        this.body.emitter.on('startSimulation', function () {
          if (_this.ready === true) {
            _this.startSimulation();
          }
        });
        this.body.emitter.on('stopSimulation', function () {
          _this.stopSimulation();
        });
        this.body.emitter.on('destroy', function () {
          _this.stopSimulation(false);
          _this.body.emitter.off();
        });
        // this event will trigger a rebuilding of the cache everything. Used when nodes or edges have been added or removed.
        this.body.emitter.on("_dataChanged", function () {
          // update shortcut lists
          _this.updatePhysicsData();
        });

        // debug: show forces
        // this.body.emitter.on("afterDrawing", (ctx) => {this._drawForces(ctx);});
      }

      /**
       * set the physics options
       * @param options
       */

    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {
          if (options === false) {
            this.options.enabled = false;
            this.physicsEnabled = false;
            this.stopSimulation();
          } else {
            this.physicsEnabled = true;
            util.selectiveNotDeepExtend(['stabilization'], this.options, options);
            util.mergeOptions(this.options, options, 'stabilization');

            if (options.enabled === undefined) {
              this.options.enabled = true;
            }

            if (this.options.enabled === false) {
              this.physicsEnabled = false;
              this.stopSimulation();
            }

            // set the timestep
            this.timestep = this.options.timestep;
          }
        }
        this.init();
      }

      /**
       * configure the engine.
       */

    }, {
      key: 'init',
      value: function init() {
        var options;
        if (this.options.solver === 'forceAtlas2Based') {
          options = this.options.forceAtlas2Based;
          this.nodesSolver = new _FA2BasedRepulsionSolver2.default(this.body, this.physicsBody, options);
          this.edgesSolver = new _SpringSolver2.default(this.body, this.physicsBody, options);
          this.gravitySolver = new _FA2BasedCentralGravitySolver2.default(this.body, this.physicsBody, options);
        } else if (this.options.solver === 'repulsion') {
          options = this.options.repulsion;
          this.nodesSolver = new _RepulsionSolver2.default(this.body, this.physicsBody, options);
          this.edgesSolver = new _SpringSolver2.default(this.body, this.physicsBody, options);
          this.gravitySolver = new _CentralGravitySolver2.default(this.body, this.physicsBody, options);
        } else if (this.options.solver === 'hierarchicalRepulsion') {
          options = this.options.hierarchicalRepulsion;
          this.nodesSolver = new _HierarchicalRepulsionSolver2.default(this.body, this.physicsBody, options);
          this.edgesSolver = new _HierarchicalSpringSolver2.default(this.body, this.physicsBody, options);
          this.gravitySolver = new _CentralGravitySolver2.default(this.body, this.physicsBody, options);
        } else {
          // barnesHut
          options = this.options.barnesHut;
          this.nodesSolver = new _BarnesHutSolver2.default(this.body, this.physicsBody, options);
          this.edgesSolver = new _SpringSolver2.default(this.body, this.physicsBody, options);
          this.gravitySolver = new _CentralGravitySolver2.default(this.body, this.physicsBody, options);
        }

        this.modelOptions = options;
      }

      /**
       * initialize the engine
       */

    }, {
      key: 'initPhysics',
      value: function initPhysics() {
        if (this.physicsEnabled === true && this.options.enabled === true) {
          if (this.options.stabilization.enabled === true) {
            this.stabilize();
          } else {
            this.stabilized = false;
            this.ready = true;
            this.body.emitter.emit('fit', {}, this.layoutFailed); // if the layout failed, we use the approximation for the zoom
            this.startSimulation();
          }
        } else {
          this.ready = true;
          this.body.emitter.emit('fit');
        }
      }

      /**
       * Start the simulation
       */

    }, {
      key: 'startSimulation',
      value: function startSimulation() {
        if (this.physicsEnabled === true && this.options.enabled === true) {
          this.stabilized = false;

          // when visible, adaptivity is disabled.
          this.adaptiveTimestep = false;

          // this sets the width of all nodes initially which could be required for the avoidOverlap
          this.body.emitter.emit("_resizeNodes");
          if (this.viewFunction === undefined) {
            this.viewFunction = this.simulationStep.bind(this);
            this.body.emitter.on('initRedraw', this.viewFunction);
            this.body.emitter.emit('_startRendering');
          }
        } else {
          this.body.emitter.emit('_redraw');
        }
      }

      /**
       * Stop the simulation, force stabilization.
       */

    }, {
      key: 'stopSimulation',
      value: function stopSimulation() {
        var emit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        this.stabilized = true;
        if (emit === true) {
          this._emitStabilized();
        }
        if (this.viewFunction !== undefined) {
          this.body.emitter.off('initRedraw', this.viewFunction);
          this.viewFunction = undefined;
          if (emit === true) {
            this.body.emitter.emit('_stopRendering');
          }
        }
      }

      /**
       * The viewFunction inserts this step into each render loop. It calls the physics tick and handles the cleanup at stabilized.
       *
       */

    }, {
      key: 'simulationStep',
      value: function simulationStep() {
        // check if the physics have settled
        var startTime = Date.now();
        this.physicsTick();
        var physicsTime = Date.now() - startTime;

        // run double speed if it is a little graph
        if ((physicsTime < 0.4 * this.simulationInterval || this.runDoubleSpeed === true) && this.stabilized === false) {
          this.physicsTick();

          // this makes sure there is no jitter. The decision is taken once to run it at double speed.
          this.runDoubleSpeed = true;
        }

        if (this.stabilized === true) {
          this.stopSimulation();
        }
      }

      /**
       * trigger the stabilized event.
       * @private
       */

    }, {
      key: '_emitStabilized',
      value: function _emitStabilized() {
        var _this2 = this;

        var amountOfIterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.stabilizationIterations;

        if (this.stabilizationIterations > 1 || this.startedStabilization === true) {
          setTimeout(function () {
            _this2.body.emitter.emit('stabilized', { iterations: amountOfIterations });
            _this2.startedStabilization = false;
            _this2.stabilizationIterations = 0;
          }, 0);
        }
      }

      /**
       * A single simulation step (or 'tick') in the physics simulation
       *
       * @private
       */

    }, {
      key: 'physicsTick',
      value: function physicsTick() {
        // this is here to ensure that there is no start event when the network is already stable.
        if (this.startedStabilization === false) {
          this.body.emitter.emit('startStabilizing');
          this.startedStabilization = true;
        }

        if (this.stabilized === false) {
          // adaptivity means the timestep adapts to the situation, only applicable for stabilization
          if (this.adaptiveTimestep === true && this.adaptiveTimestepEnabled === true) {
            // this is the factor for increasing the timestep on success.
            var factor = 1.2;

            // we assume the adaptive interval is
            if (this.adaptiveCounter % this.adaptiveInterval === 0) {
              // we leave the timestep stable for "interval" iterations.
              // first the big step and revert. Revert saves the reference state.
              this.timestep = 2 * this.timestep;
              this.calculateForces();
              this.moveNodes();
              this.revert();

              // now the normal step. Since this is the last step, it is the more stable one and we will take this.
              this.timestep = 0.5 * this.timestep;

              // since it's half the step, we do it twice.
              this.calculateForces();
              this.moveNodes();
              this.calculateForces();
              this.moveNodes();

              // we compare the two steps. if it is acceptable we double the step.
              if (this._evaluateStepQuality() === true) {
                this.timestep = factor * this.timestep;
              } else {
                // if not, we decrease the step to a minimum of the options timestep.
                // if the decreased timestep is smaller than the options step, we do not reset the counter
                // we assume that the options timestep is stable enough.
                if (this.timestep / factor < this.options.timestep) {
                  this.timestep = this.options.timestep;
                } else {
                  // if the timestep was larger than 2 times the option one we check the adaptivity again to ensure
                  // that large instabilities do not form.
                  this.adaptiveCounter = -1; // check again next iteration
                  this.timestep = Math.max(this.options.timestep, this.timestep / factor);
                }
              }
            } else {
              // normal step, keeping timestep constant
              this.calculateForces();
              this.moveNodes();
            }

            // increment the counter
            this.adaptiveCounter += 1;
          } else {
            // case for the static timestep, we reset it to the one in options and take a normal step.
            this.timestep = this.options.timestep;
            this.calculateForces();
            this.moveNodes();
          }

          // determine if the network has stabilzied
          if (this.stabilized === true) {
            this.revert();
          }

          this.stabilizationIterations++;
        }
      }

      /**
       * Nodes and edges can have the physics toggles on or off. A collection of indices is created here so we can skip the check all the time.
       *
       * @private
       */

    }, {
      key: 'updatePhysicsData',
      value: function updatePhysicsData() {
        this.physicsBody.forces = {};
        this.physicsBody.physicsNodeIndices = [];
        this.physicsBody.physicsEdgeIndices = [];
        var nodes = this.body.nodes;
        var edges = this.body.edges;

        // get node indices for physics
        for (var nodeId in nodes) {
          if (nodes.hasOwnProperty(nodeId)) {
            if (nodes[nodeId].options.physics === true) {
              this.physicsBody.physicsNodeIndices.push(nodes[nodeId].id);
            }
          }
        }

        // get edge indices for physics
        for (var edgeId in edges) {
          if (edges.hasOwnProperty(edgeId)) {
            if (edges[edgeId].options.physics === true) {
              this.physicsBody.physicsEdgeIndices.push(edges[edgeId].id);
            }
          }
        }

        // get the velocity and the forces vector
        for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {
          var _nodeId = this.physicsBody.physicsNodeIndices[i];
          this.physicsBody.forces[_nodeId] = { x: 0, y: 0 };

          // forces can be reset because they are recalculated. Velocities have to persist.
          if (this.physicsBody.velocities[_nodeId] === undefined) {
            this.physicsBody.velocities[_nodeId] = { x: 0, y: 0 };
          }
        }

        // clean deleted nodes from the velocity vector
        for (var _nodeId2 in this.physicsBody.velocities) {
          if (nodes[_nodeId2] === undefined) {
            delete this.physicsBody.velocities[_nodeId2];
          }
        }
      }

      /**
       * Revert the simulation one step. This is done so after stabilization, every new start of the simulation will also say stabilized.
       */

    }, {
      key: 'revert',
      value: function revert() {
        var nodeIds = Object.keys(this.previousStates);
        var nodes = this.body.nodes;
        var velocities = this.physicsBody.velocities;
        this.referenceState = {};

        for (var i = 0; i < nodeIds.length; i++) {
          var nodeId = nodeIds[i];
          if (nodes[nodeId] !== undefined) {
            if (nodes[nodeId].options.physics === true) {
              this.referenceState[nodeId] = {
                positions: { x: nodes[nodeId].x, y: nodes[nodeId].y }
              };
              velocities[nodeId].x = this.previousStates[nodeId].vx;
              velocities[nodeId].y = this.previousStates[nodeId].vy;
              nodes[nodeId].x = this.previousStates[nodeId].x;
              nodes[nodeId].y = this.previousStates[nodeId].y;
            }
          } else {
            delete this.previousStates[nodeId];
          }
        }
      }

      /**
       * This compares the reference state to the current state
       */

    }, {
      key: '_evaluateStepQuality',
      value: function _evaluateStepQuality() {
        var dx = void 0,
            dy = void 0,
            dpos = void 0;
        var nodes = this.body.nodes;
        var reference = this.referenceState;
        var posThreshold = 0.3;

        for (var nodeId in this.referenceState) {
          if (this.referenceState.hasOwnProperty(nodeId) && nodes[nodeId] !== undefined) {
            dx = nodes[nodeId].x - reference[nodeId].positions.x;
            dy = nodes[nodeId].y - reference[nodeId].positions.y;

            dpos = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));

            if (dpos > posThreshold) {
              return false;
            }
          }
        }
        return true;
      }

      /**
       * move the nodes one timestep and check if they are stabilized
       * @returns {boolean}
       */

    }, {
      key: 'moveNodes',
      value: function moveNodes() {
        var nodeIndices = this.physicsBody.physicsNodeIndices;
        var maxVelocity = this.options.maxVelocity ? this.options.maxVelocity : 1e9;
        var maxNodeVelocity = 0;
        var averageNodeVelocity = 0;

        // the velocity threshold (energy in the system) for the adaptivity toggle
        var velocityAdaptiveThreshold = 5;

        for (var i = 0; i < nodeIndices.length; i++) {
          var nodeId = nodeIndices[i];
          var nodeVelocity = this._performStep(nodeId, maxVelocity);
          // stabilized is true if stabilized is true and velocity is smaller than vmin --> all nodes must be stabilized
          maxNodeVelocity = Math.max(maxNodeVelocity, nodeVelocity);
          averageNodeVelocity += nodeVelocity;
        }

        // evaluating the stabilized and adaptiveTimestepEnabled conditions
        this.adaptiveTimestepEnabled = averageNodeVelocity / nodeIndices.length < velocityAdaptiveThreshold;
        this.stabilized = maxNodeVelocity < this.options.minVelocity;
      }

      /**
       * Perform the actual step
       *
       * @param nodeId
       * @param maxVelocity
       * @returns {number}
       * @private
       */

    }, {
      key: '_performStep',
      value: function _performStep(nodeId, maxVelocity) {
        var node = this.body.nodes[nodeId];
        var timestep = this.timestep;
        var forces = this.physicsBody.forces;
        var velocities = this.physicsBody.velocities;

        // store the state so we can revert
        this.previousStates[nodeId] = { x: node.x, y: node.y, vx: velocities[nodeId].x, vy: velocities[nodeId].y };

        if (node.options.fixed.x === false) {
          var dx = this.modelOptions.damping * velocities[nodeId].x; // damping force
          var ax = (forces[nodeId].x - dx) / node.options.mass; // acceleration
          velocities[nodeId].x += ax * timestep; // velocity
          velocities[nodeId].x = Math.abs(velocities[nodeId].x) > maxVelocity ? velocities[nodeId].x > 0 ? maxVelocity : -maxVelocity : velocities[nodeId].x;
          node.x += velocities[nodeId].x * timestep; // position
        } else {
          forces[nodeId].x = 0;
          velocities[nodeId].x = 0;
        }

        if (node.options.fixed.y === false) {
          var dy = this.modelOptions.damping * velocities[nodeId].y; // damping force
          var ay = (forces[nodeId].y - dy) / node.options.mass; // acceleration
          velocities[nodeId].y += ay * timestep; // velocity
          velocities[nodeId].y = Math.abs(velocities[nodeId].y) > maxVelocity ? velocities[nodeId].y > 0 ? maxVelocity : -maxVelocity : velocities[nodeId].y;
          node.y += velocities[nodeId].y * timestep; // position
        } else {
          forces[nodeId].y = 0;
          velocities[nodeId].y = 0;
        }

        var totalVelocity = Math.sqrt(Math.pow(velocities[nodeId].x, 2) + Math.pow(velocities[nodeId].y, 2));
        return totalVelocity;
      }

      /**
       * calculate the forces for one physics iteration.
       */

    }, {
      key: 'calculateForces',
      value: function calculateForces() {
        this.gravitySolver.solve();
        this.nodesSolver.solve();
        this.edgesSolver.solve();
      }

      /**
       * When initializing and stabilizing, we can freeze nodes with a predefined position. This greatly speeds up stabilization
       * because only the supportnodes for the smoothCurves have to settle.
       *
       * @private
       */

    }, {
      key: '_freezeNodes',
      value: function _freezeNodes() {
        var nodes = this.body.nodes;
        for (var id in nodes) {
          if (nodes.hasOwnProperty(id)) {
            if (nodes[id].x && nodes[id].y) {
              this.freezeCache[id] = { x: nodes[id].options.fixed.x, y: nodes[id].options.fixed.y };
              nodes[id].options.fixed.x = true;
              nodes[id].options.fixed.y = true;
            }
          }
        }
      }

      /**
       * Unfreezes the nodes that have been frozen by _freezeDefinedNodes.
       *
       * @private
       */

    }, {
      key: '_restoreFrozenNodes',
      value: function _restoreFrozenNodes() {
        var nodes = this.body.nodes;
        for (var id in nodes) {
          if (nodes.hasOwnProperty(id)) {
            if (this.freezeCache[id] !== undefined) {
              nodes[id].options.fixed.x = this.freezeCache[id].x;
              nodes[id].options.fixed.y = this.freezeCache[id].y;
            }
          }
        }
        this.freezeCache = {};
      }

      /**
       * Find a stable position for all nodes
       */

    }, {
      key: 'stabilize',
      value: function stabilize() {
        var _this3 = this;

        var iterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.stabilization.iterations;

        if (typeof iterations !== 'number') {
          console.log('The stabilize method needs a numeric amount of iterations. Switching to default: ', this.options.stabilization.iterations);
          iterations = this.options.stabilization.iterations;
        }

        if (this.physicsBody.physicsNodeIndices.length === 0) {
          this.ready = true;
          return;
        }

        // enable adaptive timesteps
        this.adaptiveTimestep = true && this.options.adaptiveTimestep;

        // this sets the width of all nodes initially which could be required for the avoidOverlap
        this.body.emitter.emit("_resizeNodes");

        // stop the render loop
        this.stopSimulation();

        // set stabilze to false
        this.stabilized = false;

        // block redraw requests
        this.body.emitter.emit('_blockRedraw');
        this.targetIterations = iterations;

        // start the stabilization
        if (this.options.stabilization.onlyDynamicEdges === true) {
          this._freezeNodes();
        }
        this.stabilizationIterations = 0;

        setTimeout(function () {
          return _this3._stabilizationBatch();
        }, 0);
      }

      /**
       * One batch of stabilization
       * @private
       */

    }, {
      key: '_stabilizationBatch',
      value: function _stabilizationBatch() {
        // this is here to ensure that there is at least one start event.
        if (this.startedStabilization === false) {
          this.body.emitter.emit('startStabilizing');
          this.startedStabilization = true;
        }

        var count = 0;
        while (this.stabilized === false && count < this.options.stabilization.updateInterval && this.stabilizationIterations < this.targetIterations) {
          this.physicsTick();
          count++;
        }

        if (this.stabilized === false && this.stabilizationIterations < this.targetIterations) {
          this.body.emitter.emit('stabilizationProgress', { iterations: this.stabilizationIterations, total: this.targetIterations });
          setTimeout(this._stabilizationBatch.bind(this), 0);
        } else {
          this._finalizeStabilization();
        }
      }

      /**
       * Wrap up the stabilization, fit and emit the events.
       * @private
       */

    }, {
      key: '_finalizeStabilization',
      value: function _finalizeStabilization() {
        this.body.emitter.emit('_allowRedraw');
        if (this.options.stabilization.fit === true) {
          this.body.emitter.emit('fit');
        }

        if (this.options.stabilization.onlyDynamicEdges === true) {
          this._restoreFrozenNodes();
        }

        this.body.emitter.emit('stabilizationIterationsDone');
        this.body.emitter.emit('_requestRedraw');

        if (this.stabilized === true) {
          this._emitStabilized();
        } else {
          this.startSimulation();
        }

        this.ready = true;
      }
    }, {
      key: '_drawForces',
      value: function _drawForces(ctx) {
        for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {
          var node = this.body.nodes[this.physicsBody.physicsNodeIndices[i]];
          var force = this.physicsBody.forces[this.physicsBody.physicsNodeIndices[i]];
          var factor = 20;
          var colorFactor = 0.03;
          var forceSize = Math.sqrt(Math.pow(force.x, 2) + Math.pow(force.x, 2));

          var size = Math.min(Math.max(5, forceSize), 15);
          var arrowSize = 3 * size;

          var color = util.HSVToHex((180 - Math.min(1, Math.max(0, colorFactor * forceSize)) * 180) / 360, 1, 1);

          ctx.lineWidth = size;
          ctx.strokeStyle = color;
          ctx.beginPath();
          ctx.moveTo(node.x, node.y);
          ctx.lineTo(node.x + factor * force.x, node.y + factor * force.y);
          ctx.stroke();

          var angle = Math.atan2(force.y, force.x);
          ctx.fillStyle = color;
          ctx.arrowEndpoint(node.x + factor * force.x + Math.cos(angle) * arrowSize, node.y + factor * force.y + Math.sin(angle) * arrowSize, angle, arrowSize);
          ctx.fill();
        }
      }
    }]);

    return PhysicsEngine;
  }();

  exports.default = PhysicsEngine;

/***/ },
/* 96 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var BarnesHutSolver = function () {
    function BarnesHutSolver(body, physicsBody, options) {
      _classCallCheck(this, BarnesHutSolver);

      this.body = body;
      this.physicsBody = physicsBody;
      this.barnesHutTree;
      this.setOptions(options);
      this.randomSeed = 5;

      // debug: show grid
      //this.body.emitter.on("afterDrawing", (ctx) => {this._debug(ctx,'#ff0000')})
    }

    _createClass(BarnesHutSolver, [{
      key: "setOptions",
      value: function setOptions(options) {
        this.options = options;
        this.thetaInversed = 1 / this.options.theta;
        this.overlapAvoidanceFactor = 1 - Math.max(0, Math.min(1, this.options.avoidOverlap)); // if 1 then min distance = 0.5, if 0.5 then min distance = 0.5 + 0.5*node.shape.radius
      }
    }, {
      key: "seededRandom",
      value: function seededRandom() {
        var x = Math.sin(this.randomSeed++) * 10000;
        return x - Math.floor(x);
      }

      /**
       * This function calculates the forces the nodes apply on each other based on a gravitational model.
       * The Barnes Hut method is used to speed up this N-body simulation.
       *
       * @private
       */

    }, {
      key: "solve",
      value: function solve() {
        if (this.options.gravitationalConstant !== 0 && this.physicsBody.physicsNodeIndices.length > 0) {
          var node = void 0;
          var nodes = this.body.nodes;
          var nodeIndices = this.physicsBody.physicsNodeIndices;
          var nodeCount = nodeIndices.length;

          // create the tree
          var barnesHutTree = this._formBarnesHutTree(nodes, nodeIndices);

          // for debugging
          this.barnesHutTree = barnesHutTree;

          // place the nodes one by one recursively
          for (var i = 0; i < nodeCount; i++) {
            node = nodes[nodeIndices[i]];
            if (node.options.mass > 0) {
              // starting with root is irrelevant, it never passes the BarnesHutSolver condition
              this._getForceContribution(barnesHutTree.root.children.NW, node);
              this._getForceContribution(barnesHutTree.root.children.NE, node);
              this._getForceContribution(barnesHutTree.root.children.SW, node);
              this._getForceContribution(barnesHutTree.root.children.SE, node);
            }
          }
        }
      }

      /**
       * This function traverses the barnesHutTree. It checks when it can approximate distant nodes with their center of mass.
       * If a region contains a single node, we check if it is not itself, then we apply the force.
       *
       * @param parentBranch
       * @param node
       * @private
       */

    }, {
      key: "_getForceContribution",
      value: function _getForceContribution(parentBranch, node) {
        // we get no force contribution from an empty region
        if (parentBranch.childrenCount > 0) {
          var dx = void 0,
              dy = void 0,
              distance = void 0;

          // get the distance from the center of mass to the node.
          dx = parentBranch.centerOfMass.x - node.x;
          dy = parentBranch.centerOfMass.y - node.y;
          distance = Math.sqrt(dx * dx + dy * dy);

          // BarnesHutSolver condition
          // original condition : s/d < theta = passed  ===  d/s > 1/theta = passed
          // calcSize = 1/s --> d * 1/s > 1/theta = passed
          if (distance * parentBranch.calcSize > this.thetaInversed) {
            this._calculateForces(distance, dx, dy, node, parentBranch);
          } else {
            // Did not pass the condition, go into children if available
            if (parentBranch.childrenCount === 4) {
              this._getForceContribution(parentBranch.children.NW, node);
              this._getForceContribution(parentBranch.children.NE, node);
              this._getForceContribution(parentBranch.children.SW, node);
              this._getForceContribution(parentBranch.children.SE, node);
            } else {
              // parentBranch must have only one node, if it was empty we wouldnt be here
              if (parentBranch.children.data.id != node.id) {
                // if it is not self
                this._calculateForces(distance, dx, dy, node, parentBranch);
              }
            }
          }
        }
      }

      /**
       * Calculate the forces based on the distance.
       *
       * @param distance
       * @param dx
       * @param dy
       * @param node
       * @param parentBranch
       * @private
       */

    }, {
      key: "_calculateForces",
      value: function _calculateForces(distance, dx, dy, node, parentBranch) {
        if (distance === 0) {
          distance = 0.1;
          dx = distance;
        }

        if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {
          distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);
        }

        // the dividing by the distance cubed instead of squared allows us to get the fx and fy components without sines and cosines
        // it is shorthand for gravityforce with distance squared and fx = dx/distance * gravityForce
        var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass / Math.pow(distance, 3);
        var fx = dx * gravityForce;
        var fy = dy * gravityForce;

        this.physicsBody.forces[node.id].x += fx;
        this.physicsBody.forces[node.id].y += fy;
      }

      /**
       * This function constructs the barnesHut tree recursively. It creates the root, splits it and starts placing the nodes.
       *
       * @param nodes
       * @param nodeIndices
       * @private
       */

    }, {
      key: "_formBarnesHutTree",
      value: function _formBarnesHutTree(nodes, nodeIndices) {
        var node = void 0;
        var nodeCount = nodeIndices.length;

        var minX = nodes[nodeIndices[0]].x;
        var minY = nodes[nodeIndices[0]].y;
        var maxX = nodes[nodeIndices[0]].x;
        var maxY = nodes[nodeIndices[0]].y;

        // get the range of the nodes
        for (var i = 1; i < nodeCount; i++) {
          var x = nodes[nodeIndices[i]].x;
          var y = nodes[nodeIndices[i]].y;
          if (nodes[nodeIndices[i]].options.mass > 0) {
            if (x < minX) {
              minX = x;
            }
            if (x > maxX) {
              maxX = x;
            }
            if (y < minY) {
              minY = y;
            }
            if (y > maxY) {
              maxY = y;
            }
          }
        }
        // make the range a square
        var sizeDiff = Math.abs(maxX - minX) - Math.abs(maxY - minY); // difference between X and Y
        if (sizeDiff > 0) {
          minY -= 0.5 * sizeDiff;
          maxY += 0.5 * sizeDiff;
        } // xSize > ySize
        else {
            minX += 0.5 * sizeDiff;
            maxX -= 0.5 * sizeDiff;
          } // xSize < ySize


        var minimumTreeSize = 1e-5;
        var rootSize = Math.max(minimumTreeSize, Math.abs(maxX - minX));
        var halfRootSize = 0.5 * rootSize;
        var centerX = 0.5 * (minX + maxX),
            centerY = 0.5 * (minY + maxY);

        // construct the barnesHutTree
        var barnesHutTree = {
          root: {
            centerOfMass: { x: 0, y: 0 },
            mass: 0,
            range: {
              minX: centerX - halfRootSize, maxX: centerX + halfRootSize,
              minY: centerY - halfRootSize, maxY: centerY + halfRootSize
            },
            size: rootSize,
            calcSize: 1 / rootSize,
            children: { data: null },
            maxWidth: 0,
            level: 0,
            childrenCount: 4
          }
        };
        this._splitBranch(barnesHutTree.root);

        // place the nodes one by one recursively
        for (var _i = 0; _i < nodeCount; _i++) {
          node = nodes[nodeIndices[_i]];
          if (node.options.mass > 0) {
            this._placeInTree(barnesHutTree.root, node);
          }
        }

        // make global
        return barnesHutTree;
      }

      /**
       * this updates the mass of a branch. this is increased by adding a node.
       *
       * @param parentBranch
       * @param node
       * @private
       */

    }, {
      key: "_updateBranchMass",
      value: function _updateBranchMass(parentBranch, node) {
        var totalMass = parentBranch.mass + node.options.mass;
        var totalMassInv = 1 / totalMass;

        parentBranch.centerOfMass.x = parentBranch.centerOfMass.x * parentBranch.mass + node.x * node.options.mass;
        parentBranch.centerOfMass.x *= totalMassInv;

        parentBranch.centerOfMass.y = parentBranch.centerOfMass.y * parentBranch.mass + node.y * node.options.mass;
        parentBranch.centerOfMass.y *= totalMassInv;

        parentBranch.mass = totalMass;
        var biggestSize = Math.max(Math.max(node.height, node.radius), node.width);
        parentBranch.maxWidth = parentBranch.maxWidth < biggestSize ? biggestSize : parentBranch.maxWidth;
      }

      /**
       * determine in which branch the node will be placed.
       *
       * @param parentBranch
       * @param node
       * @param skipMassUpdate
       * @private
       */

    }, {
      key: "_placeInTree",
      value: function _placeInTree(parentBranch, node, skipMassUpdate) {
        if (skipMassUpdate != true || skipMassUpdate === undefined) {
          // update the mass of the branch.
          this._updateBranchMass(parentBranch, node);
        }

        if (parentBranch.children.NW.range.maxX > node.x) {
          // in NW or SW
          if (parentBranch.children.NW.range.maxY > node.y) {
            // in NW
            this._placeInRegion(parentBranch, node, "NW");
          } else {
            // in SW
            this._placeInRegion(parentBranch, node, "SW");
          }
        } else {
          // in NE or SE
          if (parentBranch.children.NW.range.maxY > node.y) {
            // in NE
            this._placeInRegion(parentBranch, node, "NE");
          } else {
            // in SE
            this._placeInRegion(parentBranch, node, "SE");
          }
        }
      }

      /**
       * actually place the node in a region (or branch)
       *
       * @param parentBranch
       * @param node
       * @param region
       * @private
       */

    }, {
      key: "_placeInRegion",
      value: function _placeInRegion(parentBranch, node, region) {
        switch (parentBranch.children[region].childrenCount) {
          case 0:
            // place node here
            parentBranch.children[region].children.data = node;
            parentBranch.children[region].childrenCount = 1;
            this._updateBranchMass(parentBranch.children[region], node);
            break;
          case 1:
            // convert into children
            // if there are two nodes exactly overlapping (on init, on opening of cluster etc.)
            // we move one node a little bit and we do not put it in the tree.
            if (parentBranch.children[region].children.data.x === node.x && parentBranch.children[region].children.data.y === node.y) {
              node.x += this.seededRandom();
              node.y += this.seededRandom();
            } else {
              this._splitBranch(parentBranch.children[region]);
              this._placeInTree(parentBranch.children[region], node);
            }
            break;
          case 4:
            // place in branch
            this._placeInTree(parentBranch.children[region], node);
            break;
        }
      }

      /**
       * this function splits a branch into 4 sub branches. If the branch contained a node, we place it in the subbranch
       * after the split is complete.
       *
       * @param parentBranch
       * @private
       */

    }, {
      key: "_splitBranch",
      value: function _splitBranch(parentBranch) {
        // if the branch is shaded with a node, replace the node in the new subset.
        var containedNode = null;
        if (parentBranch.childrenCount === 1) {
          containedNode = parentBranch.children.data;
          parentBranch.mass = 0;
          parentBranch.centerOfMass.x = 0;
          parentBranch.centerOfMass.y = 0;
        }
        parentBranch.childrenCount = 4;
        parentBranch.children.data = null;
        this._insertRegion(parentBranch, "NW");
        this._insertRegion(parentBranch, "NE");
        this._insertRegion(parentBranch, "SW");
        this._insertRegion(parentBranch, "SE");

        if (containedNode != null) {
          this._placeInTree(parentBranch, containedNode);
        }
      }

      /**
       * This function subdivides the region into four new segments.
       * Specifically, this inserts a single new segment.
       * It fills the children section of the parentBranch
       *
       * @param parentBranch
       * @param region
       * @param parentRange
       * @private
       */

    }, {
      key: "_insertRegion",
      value: function _insertRegion(parentBranch, region) {
        var minX = void 0,
            maxX = void 0,
            minY = void 0,
            maxY = void 0;
        var childSize = 0.5 * parentBranch.size;
        switch (region) {
          case "NW":
            minX = parentBranch.range.minX;
            maxX = parentBranch.range.minX + childSize;
            minY = parentBranch.range.minY;
            maxY = parentBranch.range.minY + childSize;
            break;
          case "NE":
            minX = parentBranch.range.minX + childSize;
            maxX = parentBranch.range.maxX;
            minY = parentBranch.range.minY;
            maxY = parentBranch.range.minY + childSize;
            break;
          case "SW":
            minX = parentBranch.range.minX;
            maxX = parentBranch.range.minX + childSize;
            minY = parentBranch.range.minY + childSize;
            maxY = parentBranch.range.maxY;
            break;
          case "SE":
            minX = parentBranch.range.minX + childSize;
            maxX = parentBranch.range.maxX;
            minY = parentBranch.range.minY + childSize;
            maxY = parentBranch.range.maxY;
            break;
        }

        parentBranch.children[region] = {
          centerOfMass: { x: 0, y: 0 },
          mass: 0,
          range: { minX: minX, maxX: maxX, minY: minY, maxY: maxY },
          size: 0.5 * parentBranch.size,
          calcSize: 2 * parentBranch.calcSize,
          children: { data: null },
          maxWidth: 0,
          level: parentBranch.level + 1,
          childrenCount: 0
        };
      }

      //---------------------------  DEBUGGING BELOW  ---------------------------//


      /**
       * This function is for debugging purposed, it draws the tree.
       *
       * @param ctx
       * @param color
       * @private
       */

    }, {
      key: "_debug",
      value: function _debug(ctx, color) {
        if (this.barnesHutTree !== undefined) {

          ctx.lineWidth = 1;

          this._drawBranch(this.barnesHutTree.root, ctx, color);
        }
      }

      /**
       * This function is for debugging purposes. It draws the branches recursively.
       *
       * @param branch
       * @param ctx
       * @param color
       * @private
       */

    }, {
      key: "_drawBranch",
      value: function _drawBranch(branch, ctx, color) {
        if (color === undefined) {
          color = "#FF0000";
        }

        if (branch.childrenCount === 4) {
          this._drawBranch(branch.children.NW, ctx);
          this._drawBranch(branch.children.NE, ctx);
          this._drawBranch(branch.children.SE, ctx);
          this._drawBranch(branch.children.SW, ctx);
        }
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(branch.range.minX, branch.range.minY);
        ctx.lineTo(branch.range.maxX, branch.range.minY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(branch.range.maxX, branch.range.minY);
        ctx.lineTo(branch.range.maxX, branch.range.maxY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(branch.range.maxX, branch.range.maxY);
        ctx.lineTo(branch.range.minX, branch.range.maxY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(branch.range.minX, branch.range.maxY);
        ctx.lineTo(branch.range.minX, branch.range.minY);
        ctx.stroke();

        /*
         if (branch.mass > 0) {
         ctx.circle(branch.centerOfMass.x, branch.centerOfMass.y, 3*branch.mass);
         ctx.stroke();
         }
         */
      }
    }]);

    return BarnesHutSolver;
  }();

  exports.default = BarnesHutSolver;

/***/ },
/* 97 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var RepulsionSolver = function () {
    function RepulsionSolver(body, physicsBody, options) {
      _classCallCheck(this, RepulsionSolver);

      this.body = body;
      this.physicsBody = physicsBody;
      this.setOptions(options);
    }

    _createClass(RepulsionSolver, [{
      key: "setOptions",
      value: function setOptions(options) {
        this.options = options;
      }
      /**
       * Calculate the forces the nodes apply on each other based on a repulsion field.
       * This field is linearly approximated.
       *
       * @private
       */

    }, {
      key: "solve",
      value: function solve() {
        var dx, dy, distance, fx, fy, repulsingForce, node1, node2;

        var nodes = this.body.nodes;
        var nodeIndices = this.physicsBody.physicsNodeIndices;
        var forces = this.physicsBody.forces;

        // repulsing forces between nodes
        var nodeDistance = this.options.nodeDistance;

        // approximation constants
        var a = -2 / 3 / nodeDistance;
        var b = 4 / 3;

        // we loop from i over all but the last entree in the array
        // j loops from i+1 to the last. This way we do not double count any of the indices, nor i === j
        for (var i = 0; i < nodeIndices.length - 1; i++) {
          node1 = nodes[nodeIndices[i]];
          for (var j = i + 1; j < nodeIndices.length; j++) {
            node2 = nodes[nodeIndices[j]];

            dx = node2.x - node1.x;
            dy = node2.y - node1.y;
            distance = Math.sqrt(dx * dx + dy * dy);

            // same condition as BarnesHutSolver, making sure nodes are never 100% overlapping.
            if (distance === 0) {
              distance = 0.1 * Math.random();
              dx = distance;
            }

            if (distance < 2 * nodeDistance) {
              if (distance < 0.5 * nodeDistance) {
                repulsingForce = 1.0;
              } else {
                repulsingForce = a * distance + b; // linear approx of  1 / (1 + Math.exp((distance / nodeDistance - 1) * steepness))
              }
              repulsingForce = repulsingForce / distance;

              fx = dx * repulsingForce;
              fy = dy * repulsingForce;

              forces[node1.id].x -= fx;
              forces[node1.id].y -= fy;
              forces[node2.id].x += fx;
              forces[node2.id].y += fy;
            }
          }
        }
      }
    }]);

    return RepulsionSolver;
  }();

  exports.default = RepulsionSolver;

/***/ },
/* 98 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var HierarchicalRepulsionSolver = function () {
    function HierarchicalRepulsionSolver(body, physicsBody, options) {
      _classCallCheck(this, HierarchicalRepulsionSolver);

      this.body = body;
      this.physicsBody = physicsBody;
      this.setOptions(options);
    }

    _createClass(HierarchicalRepulsionSolver, [{
      key: "setOptions",
      value: function setOptions(options) {
        this.options = options;
      }

      /**
       * Calculate the forces the nodes apply on each other based on a repulsion field.
       * This field is linearly approximated.
       *
       * @private
       */

    }, {
      key: "solve",
      value: function solve() {
        var dx, dy, distance, fx, fy, repulsingForce, node1, node2, i, j;

        var nodes = this.body.nodes;
        var nodeIndices = this.physicsBody.physicsNodeIndices;
        var forces = this.physicsBody.forces;

        // repulsing forces between nodes
        var nodeDistance = this.options.nodeDistance;

        // we loop from i over all but the last entree in the array
        // j loops from i+1 to the last. This way we do not double count any of the indices, nor i === j
        for (i = 0; i < nodeIndices.length - 1; i++) {
          node1 = nodes[nodeIndices[i]];
          for (j = i + 1; j < nodeIndices.length; j++) {
            node2 = nodes[nodeIndices[j]];

            // nodes only affect nodes on their level
            if (node1.level === node2.level) {
              dx = node2.x - node1.x;
              dy = node2.y - node1.y;
              distance = Math.sqrt(dx * dx + dy * dy);

              var steepness = 0.05;
              if (distance < nodeDistance) {
                repulsingForce = -Math.pow(steepness * distance, 2) + Math.pow(steepness * nodeDistance, 2);
              } else {
                repulsingForce = 0;
              }
              // normalize force with
              if (distance === 0) {
                distance = 0.01;
              } else {
                repulsingForce = repulsingForce / distance;
              }
              fx = dx * repulsingForce;
              fy = dy * repulsingForce;

              forces[node1.id].x -= fx;
              forces[node1.id].y -= fy;
              forces[node2.id].x += fx;
              forces[node2.id].y += fy;
            }
          }
        }
      }
    }]);

    return HierarchicalRepulsionSolver;
  }();

  exports.default = HierarchicalRepulsionSolver;

/***/ },
/* 99 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var SpringSolver = function () {
    function SpringSolver(body, physicsBody, options) {
      _classCallCheck(this, SpringSolver);

      this.body = body;
      this.physicsBody = physicsBody;
      this.setOptions(options);
    }

    _createClass(SpringSolver, [{
      key: "setOptions",
      value: function setOptions(options) {
        this.options = options;
      }

      /**
       * This function calculates the springforces on the nodes, accounting for the support nodes.
       *
       * @private
       */

    }, {
      key: "solve",
      value: function solve() {
        var edgeLength = void 0,
            edge = void 0;
        var edgeIndices = this.physicsBody.physicsEdgeIndices;
        var edges = this.body.edges;
        var node1 = void 0,
            node2 = void 0,
            node3 = void 0;

        // forces caused by the edges, modelled as springs
        for (var i = 0; i < edgeIndices.length; i++) {
          edge = edges[edgeIndices[i]];
          if (edge.connected === true && edge.toId !== edge.fromId) {
            // only calculate forces if nodes are in the same sector
            if (this.body.nodes[edge.toId] !== undefined && this.body.nodes[edge.fromId] !== undefined) {
              if (edge.edgeType.via !== undefined) {
                edgeLength = edge.options.length === undefined ? this.options.springLength : edge.options.length;
                node1 = edge.to;
                node2 = edge.edgeType.via;
                node3 = edge.from;

                this._calculateSpringForce(node1, node2, 0.5 * edgeLength);
                this._calculateSpringForce(node2, node3, 0.5 * edgeLength);
              } else {
                // the * 1.5 is here so the edge looks as large as a smooth edge. It does not initially because the smooth edges use
                // the support nodes which exert a repulsive force on the to and from nodes, making the edge appear larger.
                edgeLength = edge.options.length === undefined ? this.options.springLength * 1.5 : edge.options.length;
                this._calculateSpringForce(edge.from, edge.to, edgeLength);
              }
            }
          }
        }
      }

      /**
       * This is the code actually performing the calculation for the function above.
       *
       * @param node1
       * @param node2
       * @param edgeLength
       * @private
       */

    }, {
      key: "_calculateSpringForce",
      value: function _calculateSpringForce(node1, node2, edgeLength) {
        var dx = node1.x - node2.x;
        var dy = node1.y - node2.y;
        var distance = Math.max(Math.sqrt(dx * dx + dy * dy), 0.01);

        // the 1/distance is so the fx and fy can be calculated without sine or cosine.
        var springForce = this.options.springConstant * (edgeLength - distance) / distance;

        var fx = dx * springForce;
        var fy = dy * springForce;

        // handle the case where one node is not part of the physcis
        if (this.physicsBody.forces[node1.id] !== undefined) {
          this.physicsBody.forces[node1.id].x += fx;
          this.physicsBody.forces[node1.id].y += fy;
        }

        if (this.physicsBody.forces[node2.id] !== undefined) {
          this.physicsBody.forces[node2.id].x -= fx;
          this.physicsBody.forces[node2.id].y -= fy;
        }
      }
    }]);

    return SpringSolver;
  }();

  exports.default = SpringSolver;

/***/ },
/* 100 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var HierarchicalSpringSolver = function () {
    function HierarchicalSpringSolver(body, physicsBody, options) {
      _classCallCheck(this, HierarchicalSpringSolver);

      this.body = body;
      this.physicsBody = physicsBody;
      this.setOptions(options);
    }

    _createClass(HierarchicalSpringSolver, [{
      key: "setOptions",
      value: function setOptions(options) {
        this.options = options;
      }

      /**
       * This function calculates the springforces on the nodes, accounting for the support nodes.
       *
       * @private
       */

    }, {
      key: "solve",
      value: function solve() {
        var edgeLength, edge;
        var dx, dy, fx, fy, springForce, distance;
        var edges = this.body.edges;
        var factor = 0.5;

        var edgeIndices = this.physicsBody.physicsEdgeIndices;
        var nodeIndices = this.physicsBody.physicsNodeIndices;
        var forces = this.physicsBody.forces;

        // initialize the spring force counters
        for (var i = 0; i < nodeIndices.length; i++) {
          var nodeId = nodeIndices[i];
          forces[nodeId].springFx = 0;
          forces[nodeId].springFy = 0;
        }

        // forces caused by the edges, modelled as springs
        for (var _i = 0; _i < edgeIndices.length; _i++) {
          edge = edges[edgeIndices[_i]];
          if (edge.connected === true) {
            edgeLength = edge.options.length === undefined ? this.options.springLength : edge.options.length;

            dx = edge.from.x - edge.to.x;
            dy = edge.from.y - edge.to.y;
            distance = Math.sqrt(dx * dx + dy * dy);
            distance = distance === 0 ? 0.01 : distance;

            // the 1/distance is so the fx and fy can be calculated without sine or cosine.
            springForce = this.options.springConstant * (edgeLength - distance) / distance;

            fx = dx * springForce;
            fy = dy * springForce;

            if (edge.to.level != edge.from.level) {
              if (forces[edge.toId] !== undefined) {
                forces[edge.toId].springFx -= fx;
                forces[edge.toId].springFy -= fy;
              }
              if (forces[edge.fromId] !== undefined) {
                forces[edge.fromId].springFx += fx;
                forces[edge.fromId].springFy += fy;
              }
            } else {
              if (forces[edge.toId] !== undefined) {
                forces[edge.toId].x -= factor * fx;
                forces[edge.toId].y -= factor * fy;
              }
              if (forces[edge.fromId] !== undefined) {
                forces[edge.fromId].x += factor * fx;
                forces[edge.fromId].y += factor * fy;
              }
            }
          }
        }

        // normalize spring forces
        var springForce = 1;
        var springFx, springFy;
        for (var _i2 = 0; _i2 < nodeIndices.length; _i2++) {
          var _nodeId = nodeIndices[_i2];
          springFx = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFx));
          springFy = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFy));

          forces[_nodeId].x += springFx;
          forces[_nodeId].y += springFy;
        }

        // retain energy balance
        var totalFx = 0;
        var totalFy = 0;
        for (var _i3 = 0; _i3 < nodeIndices.length; _i3++) {
          var _nodeId2 = nodeIndices[_i3];
          totalFx += forces[_nodeId2].x;
          totalFy += forces[_nodeId2].y;
        }
        var correctionFx = totalFx / nodeIndices.length;
        var correctionFy = totalFy / nodeIndices.length;

        for (var _i4 = 0; _i4 < nodeIndices.length; _i4++) {
          var _nodeId3 = nodeIndices[_i4];
          forces[_nodeId3].x -= correctionFx;
          forces[_nodeId3].y -= correctionFy;
        }
      }
    }]);

    return HierarchicalSpringSolver;
  }();

  exports.default = HierarchicalSpringSolver;

/***/ },
/* 101 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var CentralGravitySolver = function () {
    function CentralGravitySolver(body, physicsBody, options) {
      _classCallCheck(this, CentralGravitySolver);

      this.body = body;
      this.physicsBody = physicsBody;
      this.setOptions(options);
    }

    _createClass(CentralGravitySolver, [{
      key: "setOptions",
      value: function setOptions(options) {
        this.options = options;
      }
    }, {
      key: "solve",
      value: function solve() {
        var dx = void 0,
            dy = void 0,
            distance = void 0,
            node = void 0;
        var nodes = this.body.nodes;
        var nodeIndices = this.physicsBody.physicsNodeIndices;
        var forces = this.physicsBody.forces;

        for (var i = 0; i < nodeIndices.length; i++) {
          var nodeId = nodeIndices[i];
          node = nodes[nodeId];
          dx = -node.x;
          dy = -node.y;
          distance = Math.sqrt(dx * dx + dy * dy);

          this._calculateForces(distance, dx, dy, forces, node);
        }
      }

      /**
       * Calculate the forces based on the distance.
       * @private
       */

    }, {
      key: "_calculateForces",
      value: function _calculateForces(distance, dx, dy, forces, node) {
        var gravityForce = distance === 0 ? 0 : this.options.centralGravity / distance;
        forces[node.id].x = dx * gravityForce;
        forces[node.id].y = dy * gravityForce;
      }
    }]);

    return CentralGravitySolver;
  }();

  exports.default = CentralGravitySolver;

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _BarnesHutSolver2 = __webpack_require__(96);

  var _BarnesHutSolver3 = _interopRequireDefault(_BarnesHutSolver2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var ForceAtlas2BasedRepulsionSolver = function (_BarnesHutSolver) {
    _inherits(ForceAtlas2BasedRepulsionSolver, _BarnesHutSolver);

    function ForceAtlas2BasedRepulsionSolver(body, physicsBody, options) {
      _classCallCheck(this, ForceAtlas2BasedRepulsionSolver);

      return _possibleConstructorReturn(this, (ForceAtlas2BasedRepulsionSolver.__proto__ || Object.getPrototypeOf(ForceAtlas2BasedRepulsionSolver)).call(this, body, physicsBody, options));
    }

    /**
     * Calculate the forces based on the distance.
     *
     * @param distance
     * @param dx
     * @param dy
     * @param node
     * @param parentBranch
     * @private
     */


    _createClass(ForceAtlas2BasedRepulsionSolver, [{
      key: "_calculateForces",
      value: function _calculateForces(distance, dx, dy, node, parentBranch) {
        if (distance === 0) {
          distance = 0.1 * Math.random();
          dx = distance;
        }

        if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {
          distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);
        }

        var degree = node.edges.length + 1;
        // the dividing by the distance cubed instead of squared allows us to get the fx and fy components without sines and cosines
        // it is shorthand for gravityforce with distance squared and fx = dx/distance * gravityForce
        var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass * degree / Math.pow(distance, 2);
        var fx = dx * gravityForce;
        var fy = dy * gravityForce;

        this.physicsBody.forces[node.id].x += fx;
        this.physicsBody.forces[node.id].y += fy;
      }
    }]);

    return ForceAtlas2BasedRepulsionSolver;
  }(_BarnesHutSolver3.default);

  exports.default = ForceAtlas2BasedRepulsionSolver;

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _CentralGravitySolver2 = __webpack_require__(101);

  var _CentralGravitySolver3 = _interopRequireDefault(_CentralGravitySolver2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var ForceAtlas2BasedCentralGravitySolver = function (_CentralGravitySolver) {
    _inherits(ForceAtlas2BasedCentralGravitySolver, _CentralGravitySolver);

    function ForceAtlas2BasedCentralGravitySolver(body, physicsBody, options) {
      _classCallCheck(this, ForceAtlas2BasedCentralGravitySolver);

      return _possibleConstructorReturn(this, (ForceAtlas2BasedCentralGravitySolver.__proto__ || Object.getPrototypeOf(ForceAtlas2BasedCentralGravitySolver)).call(this, body, physicsBody, options));
    }

    /**
     * Calculate the forces based on the distance.
     * @private
     */


    _createClass(ForceAtlas2BasedCentralGravitySolver, [{
      key: "_calculateForces",
      value: function _calculateForces(distance, dx, dy, forces, node) {
        if (distance > 0) {
          var degree = node.edges.length + 1;
          var gravityForce = this.options.centralGravity * degree * node.options.mass;
          forces[node.id].x = dx * gravityForce;
          forces[node.id].y = dy * gravityForce;
        }
      }
    }]);

    return ForceAtlas2BasedCentralGravitySolver;
  }(_CentralGravitySolver3.default);

  exports.default = ForceAtlas2BasedCentralGravitySolver;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NetworkUtil = __webpack_require__(105);

  var _NetworkUtil2 = _interopRequireDefault(_NetworkUtil);

  var _Cluster = __webpack_require__(106);

  var _Cluster2 = _interopRequireDefault(_Cluster);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var ClusterEngine = function () {
    function ClusterEngine(body) {
      var _this = this;

      _classCallCheck(this, ClusterEngine);

      this.body = body;
      this.clusteredNodes = {};
      this.clusteredEdges = {};

      this.options = {};
      this.defaultOptions = {};
      util.extend(this.options, this.defaultOptions);

      this.body.emitter.on('_resetData', function () {
        _this.clusteredNodes = {};_this.clusteredEdges = {};
      });
    }

    /**
    *
    * @param hubsize
    * @param options
    */


    _createClass(ClusterEngine, [{
      key: 'clusterByHubsize',
      value: function clusterByHubsize(hubsize, options) {
        if (hubsize === undefined) {
          hubsize = this._getHubSize();
        } else if ((typeof hubsize === 'undefined' ? 'undefined' : _typeof(hubsize)) === "object") {
          options = this._checkOptions(hubsize);
          hubsize = this._getHubSize();
        }

        var nodesToCluster = [];
        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          var node = this.body.nodes[this.body.nodeIndices[i]];
          if (node.edges.length >= hubsize) {
            nodesToCluster.push(node.id);
          }
        }

        for (var _i = 0; _i < nodesToCluster.length; _i++) {
          this.clusterByConnection(nodesToCluster[_i], options, true);
        }

        this.body.emitter.emit('_dataChanged');
      }

      /**
      * loop over all nodes, check if they adhere to the condition and cluster if needed.
      * @param options
      * @param refreshData
      */

    }, {
      key: 'cluster',
      value: function cluster() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        if (options.joinCondition === undefined) {
          throw new Error("Cannot call clusterByNodeData without a joinCondition function in the options.");
        }

        // check if the options object is fine, append if needed
        options = this._checkOptions(options);

        var childNodesObj = {};
        var childEdgesObj = {};

        // collect the nodes that will be in the cluster
        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          var nodeId = this.body.nodeIndices[i];
          var node = this.body.nodes[nodeId];
          var clonedOptions = _NetworkUtil2.default.cloneOptions(node);
          if (options.joinCondition(clonedOptions) === true) {
            childNodesObj[nodeId] = this.body.nodes[nodeId];

            // collect the nodes that will be in the cluster
            for (var _i2 = 0; _i2 < node.edges.length; _i2++) {
              var edge = node.edges[_i2];
              if (this.clusteredEdges[edge.id] === undefined) {
                childEdgesObj[edge.id] = edge;
              }
            }
          }
        }

        this._cluster(childNodesObj, childEdgesObj, options, refreshData);
      }

      /**
       * Cluster all nodes in the network that have only X edges
       * @param edgeCount
       * @param options
       * @param refreshData
       */

    }, {
      key: 'clusterByEdgeCount',
      value: function clusterByEdgeCount(edgeCount, options) {
        var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

        options = this._checkOptions(options);
        var clusters = [];
        var usedNodes = {};
        var edge = void 0,
            edges = void 0,
            node = void 0,
            nodeId = void 0,
            relevantEdgeCount = void 0;
        // collect the nodes that will be in the cluster
        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          var childNodesObj = {};
          var childEdgesObj = {};
          nodeId = this.body.nodeIndices[i];

          // if this node is already used in another cluster this session, we do not have to re-evaluate it.
          if (usedNodes[nodeId] === undefined) {
            relevantEdgeCount = 0;
            node = this.body.nodes[nodeId];
            edges = [];
            for (var j = 0; j < node.edges.length; j++) {
              edge = node.edges[j];
              if (this.clusteredEdges[edge.id] === undefined) {
                if (edge.toId !== edge.fromId) {
                  relevantEdgeCount++;
                }
                edges.push(edge);
              }
            }

            // this node qualifies, we collect its neighbours to start the clustering process.
            if (relevantEdgeCount === edgeCount) {
              var gatheringSuccessful = true;
              for (var _j = 0; _j < edges.length; _j++) {
                edge = edges[_j];
                var childNodeId = this._getConnectedId(edge, nodeId);
                // add the nodes to the list by the join condition.
                if (options.joinCondition === undefined) {
                  childEdgesObj[edge.id] = edge;
                  childNodesObj[nodeId] = this.body.nodes[nodeId];
                  childNodesObj[childNodeId] = this.body.nodes[childNodeId];
                  usedNodes[nodeId] = true;
                } else {
                  var clonedOptions = _NetworkUtil2.default.cloneOptions(this.body.nodes[nodeId]);
                  if (options.joinCondition(clonedOptions) === true) {
                    childEdgesObj[edge.id] = edge;
                    childNodesObj[nodeId] = this.body.nodes[nodeId];
                    usedNodes[nodeId] = true;
                  } else {
                    // this node does not qualify after all.
                    gatheringSuccessful = false;
                    break;
                  }
                }
              }

              // add to the cluster queue
              if (Object.keys(childNodesObj).length > 0 && Object.keys(childEdgesObj).length > 0 && gatheringSuccessful === true) {
                clusters.push({ nodes: childNodesObj, edges: childEdgesObj });
              }
            }
          }
        }

        for (var _i3 = 0; _i3 < clusters.length; _i3++) {
          this._cluster(clusters[_i3].nodes, clusters[_i3].edges, options, false);
        }

        if (refreshData === true) {
          this.body.emitter.emit('_dataChanged');
        }
      }

      /**
      * Cluster all nodes in the network that have only 1 edge
      * @param options
      * @param refreshData
      */

    }, {
      key: 'clusterOutliers',
      value: function clusterOutliers(options) {
        var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        this.clusterByEdgeCount(1, options, refreshData);
      }

      /**
       * Cluster all nodes in the network that have only 2 edge
       * @param options
       * @param refreshData
       */

    }, {
      key: 'clusterBridges',
      value: function clusterBridges(options) {
        var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        this.clusterByEdgeCount(2, options, refreshData);
      }

      /**
      * suck all connected nodes of a node into the node.
      * @param nodeId
      * @param options
      * @param refreshData
      */

    }, {
      key: 'clusterByConnection',
      value: function clusterByConnection(nodeId, options) {
        var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

        // kill conditions
        if (nodeId === undefined) {
          throw new Error("No nodeId supplied to clusterByConnection!");
        }
        if (this.body.nodes[nodeId] === undefined) {
          throw new Error("The nodeId given to clusterByConnection does not exist!");
        }

        var node = this.body.nodes[nodeId];
        options = this._checkOptions(options, node);
        if (options.clusterNodeProperties.x === undefined) {
          options.clusterNodeProperties.x = node.x;
        }
        if (options.clusterNodeProperties.y === undefined) {
          options.clusterNodeProperties.y = node.y;
        }
        if (options.clusterNodeProperties.fixed === undefined) {
          options.clusterNodeProperties.fixed = {};
          options.clusterNodeProperties.fixed.x = node.options.fixed.x;
          options.clusterNodeProperties.fixed.y = node.options.fixed.y;
        }

        var childNodesObj = {};
        var childEdgesObj = {};
        var parentNodeId = node.id;
        var parentClonedOptions = _NetworkUtil2.default.cloneOptions(node);
        childNodesObj[parentNodeId] = node;

        // collect the nodes that will be in the cluster
        for (var i = 0; i < node.edges.length; i++) {
          var edge = node.edges[i];
          if (this.clusteredEdges[edge.id] === undefined) {
            var childNodeId = this._getConnectedId(edge, parentNodeId);

            // if the child node is not in a cluster
            if (this.clusteredNodes[childNodeId] === undefined) {
              if (childNodeId !== parentNodeId) {
                if (options.joinCondition === undefined) {
                  childEdgesObj[edge.id] = edge;
                  childNodesObj[childNodeId] = this.body.nodes[childNodeId];
                } else {
                  // clone the options and insert some additional parameters that could be interesting.
                  var childClonedOptions = _NetworkUtil2.default.cloneOptions(this.body.nodes[childNodeId]);
                  if (options.joinCondition(parentClonedOptions, childClonedOptions) === true) {
                    childEdgesObj[edge.id] = edge;
                    childNodesObj[childNodeId] = this.body.nodes[childNodeId];
                  }
                }
              } else {
                // swallow the edge if it is self-referencing.
                childEdgesObj[edge.id] = edge;
              }
            }
          }
        }
        var childNodeIDs = Object.keys(childNodesObj).map(function (childNode) {
          return childNodesObj[childNode].id;
        });

        for (childNode in childNodesObj) {
          var childNode = childNodesObj[childNode];
          for (var y = 0; y < childNode.edges.length; y++) {
            var childEdge = childNode.edges[y];
            if (childNodeIDs.indexOf(this._getConnectedId(childEdge, childNode.id)) > -1) {
              childEdgesObj[childEdge.id] = childEdge;
            }
          }
        }
        this._cluster(childNodesObj, childEdgesObj, options, refreshData);
      }

      /**
      * This function creates the edges that will be attached to the cluster
      * It looks for edges that are connected to the nodes from the "outside' of the cluster.
      *
      * @param childNodesObj
      * @param childEdgesObj
      * @param clusterNodeProperties
      * @param clusterEdgeProperties
      * @private
      */

    }, {
      key: '_createClusterEdges',
      value: function _createClusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, clusterEdgeProperties) {
        var edge = void 0,
            childNodeId = void 0,
            childNode = void 0,
            toId = void 0,
            fromId = void 0,
            otherNodeId = void 0;

        // loop over all child nodes and their edges to find edges going out of the cluster
        // these edges will be replaced by clusterEdges.
        var childKeys = Object.keys(childNodesObj);
        var createEdges = [];
        for (var i = 0; i < childKeys.length; i++) {
          childNodeId = childKeys[i];
          childNode = childNodesObj[childNodeId];

          // construct new edges from the cluster to others
          for (var j = 0; j < childNode.edges.length; j++) {
            edge = childNode.edges[j];
            // we only handle edges that are visible to the system, not the disabled ones from the clustering process.
            if (this.clusteredEdges[edge.id] === undefined) {
              // self-referencing edges will be added to the "hidden" list
              if (edge.toId == edge.fromId) {
                childEdgesObj[edge.id] = edge;
              } else {
                // set up the from and to.
                if (edge.toId == childNodeId) {
                  // this is a double equals because ints and strings can be interchanged here.
                  toId = clusterNodeProperties.id;
                  fromId = edge.fromId;
                  otherNodeId = fromId;
                } else {
                  toId = edge.toId;
                  fromId = clusterNodeProperties.id;
                  otherNodeId = toId;
                }
              }

              // Only edges from the cluster outwards are being replaced.
              if (childNodesObj[otherNodeId] === undefined) {
                createEdges.push({ edge: edge, fromId: fromId, toId: toId });
              }
            }
          }
        }

        // here we actually create the replacement edges. We could not do this in the loop above as the creation process
        // would add an edge to the edges array we are iterating over.
        for (var _j2 = 0; _j2 < createEdges.length; _j2++) {
          var _edge = createEdges[_j2].edge;
          // copy the options of the edge we will replace
          var clonedOptions = _NetworkUtil2.default.cloneOptions(_edge, 'edge');
          // make sure the properties of clusterEdges are superimposed on it
          util.deepExtend(clonedOptions, clusterEdgeProperties);

          // set up the edge
          clonedOptions.from = createEdges[_j2].fromId;
          clonedOptions.to = createEdges[_j2].toId;
          clonedOptions.id = 'clusterEdge:' + util.randomUUID();
          //clonedOptions.id = '(cf: ' + createEdges[j].fromId + " to: " + createEdges[j].toId + ")" + Math.random();

          // create the edge and give a reference to the one it replaced.
          var newEdge = this.body.functions.createEdge(clonedOptions);
          newEdge.clusteringEdgeReplacingId = _edge.id;

          // also reference the new edge in the old edge
          this.body.edges[_edge.id].edgeReplacedById = newEdge.id;

          // connect the edge.
          this.body.edges[newEdge.id] = newEdge;
          newEdge.connect();

          // hide the replaced edge
          this._backupEdgeOptions(_edge);
          _edge.setOptions({ physics: false, hidden: true });
        }
      }

      /**
      * This function checks the options that can be supplied to the different cluster functions
      * for certain fields and inserts defaults if needed
      * @param options
      * @returns {*}
      * @private
      */

    }, {
      key: '_checkOptions',
      value: function _checkOptions() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (options.clusterEdgeProperties === undefined) {
          options.clusterEdgeProperties = {};
        }
        if (options.clusterNodeProperties === undefined) {
          options.clusterNodeProperties = {};
        }

        return options;
      }

      /**
      *
      * @param {Object}    childNodesObj         | object with node objects, id as keys, same as childNodes except it also contains a source node
      * @param {Object}    childEdgesObj         | object with edge objects, id as keys
      * @param {Array}     options               | object with {clusterNodeProperties, clusterEdgeProperties, processProperties}
      * @param {Boolean}   refreshData | when true, do not wrap up
      * @private
      */

    }, {
      key: '_cluster',
      value: function _cluster(childNodesObj, childEdgesObj, options) {
        var refreshData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

        // kill condition: no nodes don't bother
        if (Object.keys(childNodesObj).length == 0) {
          return;
        }

        // allow clusters of 1 if options allow
        if (Object.keys(childNodesObj).length == 1 && options.clusterNodeProperties.allowSingleNodeCluster != true) {
          return;
        }

        // check if this cluster call is not trying to cluster anything that is in another cluster.
        for (var nodeId in childNodesObj) {
          if (childNodesObj.hasOwnProperty(nodeId)) {
            if (this.clusteredNodes[nodeId] !== undefined) {
              return;
            }
          }
        }

        var clusterNodeProperties = util.deepExtend({}, options.clusterNodeProperties);

        // construct the clusterNodeProperties
        if (options.processProperties !== undefined) {
          // get the childNode options
          var childNodesOptions = [];
          for (var _nodeId in childNodesObj) {
            if (childNodesObj.hasOwnProperty(_nodeId)) {
              var clonedOptions = _NetworkUtil2.default.cloneOptions(childNodesObj[_nodeId]);
              childNodesOptions.push(clonedOptions);
            }
          }

          // get cluster properties based on childNodes
          var childEdgesOptions = [];
          for (var edgeId in childEdgesObj) {
            if (childEdgesObj.hasOwnProperty(edgeId)) {
              // these cluster edges will be removed on creation of the cluster.
              if (edgeId.substr(0, 12) !== "clusterEdge:") {
                var _clonedOptions = _NetworkUtil2.default.cloneOptions(childEdgesObj[edgeId], 'edge');
                childEdgesOptions.push(_clonedOptions);
              }
            }
          }

          clusterNodeProperties = options.processProperties(clusterNodeProperties, childNodesOptions, childEdgesOptions);
          if (!clusterNodeProperties) {
            throw new Error("The processProperties function does not return properties!");
          }
        }

        // check if we have an unique id;
        if (clusterNodeProperties.id === undefined) {
          clusterNodeProperties.id = 'cluster:' + util.randomUUID();
        }
        var clusterId = clusterNodeProperties.id;

        if (clusterNodeProperties.label === undefined) {
          clusterNodeProperties.label = 'cluster';
        }

        // give the clusterNode a position if it does not have one.
        var pos = undefined;
        if (clusterNodeProperties.x === undefined) {
          pos = this._getClusterPosition(childNodesObj);
          clusterNodeProperties.x = pos.x;
        }
        if (clusterNodeProperties.y === undefined) {
          if (pos === undefined) {
            pos = this._getClusterPosition(childNodesObj);
          }
          clusterNodeProperties.y = pos.y;
        }

        // force the ID to remain the same
        clusterNodeProperties.id = clusterId;

        // create the clusterNode
        var clusterNode = this.body.functions.createNode(clusterNodeProperties, _Cluster2.default);
        clusterNode.isCluster = true;
        clusterNode.containedNodes = childNodesObj;
        clusterNode.containedEdges = childEdgesObj;
        // cache a copy from the cluster edge properties if we have to reconnect others later on
        clusterNode.clusterEdgeProperties = options.clusterEdgeProperties;

        // finally put the cluster node into global
        this.body.nodes[clusterNodeProperties.id] = clusterNode;

        // create the new edges that will connect to the cluster, all self-referencing edges will be added to childEdgesObject here.
        this._createClusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, options.clusterEdgeProperties);

        // disable the childEdges
        for (var _edgeId in childEdgesObj) {
          if (childEdgesObj.hasOwnProperty(_edgeId)) {
            if (this.body.edges[_edgeId] !== undefined) {
              var edge = this.body.edges[_edgeId];
              // cache the options before changing
              this._backupEdgeOptions(edge);
              // disable physics and hide the edge
              edge.setOptions({ physics: false, hidden: true });
            }
          }
        }

        // disable the childNodes
        for (var _nodeId2 in childNodesObj) {
          if (childNodesObj.hasOwnProperty(_nodeId2)) {
            this.clusteredNodes[_nodeId2] = { clusterId: clusterNodeProperties.id, node: this.body.nodes[_nodeId2] };
            this.body.nodes[_nodeId2].setOptions({ hidden: true, physics: false });
          }
        }

        // set ID to undefined so no duplicates arise
        clusterNodeProperties.id = undefined;

        // wrap up
        if (refreshData === true) {
          this.body.emitter.emit('_dataChanged');
        }
      }
    }, {
      key: '_backupEdgeOptions',
      value: function _backupEdgeOptions(edge) {
        if (this.clusteredEdges[edge.id] === undefined) {
          this.clusteredEdges[edge.id] = { physics: edge.options.physics, hidden: edge.options.hidden };
        }
      }
    }, {
      key: '_restoreEdge',
      value: function _restoreEdge(edge) {
        var originalOptions = this.clusteredEdges[edge.id];
        if (originalOptions !== undefined) {
          edge.setOptions({ physics: originalOptions.physics, hidden: originalOptions.hidden });
          delete this.clusteredEdges[edge.id];
        }
      }

      /**
      * Check if a node is a cluster.
      * @param nodeId
      * @returns {*}
      */

    }, {
      key: 'isCluster',
      value: function isCluster(nodeId) {
        if (this.body.nodes[nodeId] !== undefined) {
          return this.body.nodes[nodeId].isCluster === true;
        } else {
          console.log("Node does not exist.");
          return false;
        }
      }

      /**
      * get the position of the cluster node based on what's inside
      * @param {object} childNodesObj    | object with node objects, id as keys
      * @returns {{x: number, y: number}}
      * @private
      */

    }, {
      key: '_getClusterPosition',
      value: function _getClusterPosition(childNodesObj) {
        var childKeys = Object.keys(childNodesObj);
        var minX = childNodesObj[childKeys[0]].x;
        var maxX = childNodesObj[childKeys[0]].x;
        var minY = childNodesObj[childKeys[0]].y;
        var maxY = childNodesObj[childKeys[0]].y;
        var node = void 0;
        for (var i = 1; i < childKeys.length; i++) {
          node = childNodesObj[childKeys[i]];
          minX = node.x < minX ? node.x : minX;
          maxX = node.x > maxX ? node.x : maxX;
          minY = node.y < minY ? node.y : minY;
          maxY = node.y > maxY ? node.y : maxY;
        }

        return { x: 0.5 * (minX + maxX), y: 0.5 * (minY + maxY) };
      }

      /**
      * Open a cluster by calling this function.
      * @param {String}  clusterNodeId | the ID of the cluster node
      * @param {Boolean} refreshData | wrap up afterwards if not true
      */

    }, {
      key: 'openCluster',
      value: function openCluster(clusterNodeId, options) {
        var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

        // kill conditions
        if (clusterNodeId === undefined) {
          throw new Error("No clusterNodeId supplied to openCluster.");
        }
        if (this.body.nodes[clusterNodeId] === undefined) {
          throw new Error("The clusterNodeId supplied to openCluster does not exist.");
        }
        if (this.body.nodes[clusterNodeId].containedNodes === undefined) {
          console.log("The node:" + clusterNodeId + " is not a cluster.");
          return;
        }
        var clusterNode = this.body.nodes[clusterNodeId];
        var containedNodes = clusterNode.containedNodes;
        var containedEdges = clusterNode.containedEdges;

        // allow the user to position the nodes after release.
        if (options !== undefined && options.releaseFunction !== undefined && typeof options.releaseFunction === 'function') {
          var positions = {};
          var clusterPosition = { x: clusterNode.x, y: clusterNode.y };
          for (var nodeId in containedNodes) {
            if (containedNodes.hasOwnProperty(nodeId)) {
              var containedNode = this.body.nodes[nodeId];
              positions[nodeId] = { x: containedNode.x, y: containedNode.y };
            }
          }
          var newPositions = options.releaseFunction(clusterPosition, positions);

          for (var _nodeId3 in containedNodes) {
            if (containedNodes.hasOwnProperty(_nodeId3)) {
              var _containedNode = this.body.nodes[_nodeId3];
              if (newPositions[_nodeId3] !== undefined) {
                _containedNode.x = newPositions[_nodeId3].x === undefined ? clusterNode.x : newPositions[_nodeId3].x;
                _containedNode.y = newPositions[_nodeId3].y === undefined ? clusterNode.y : newPositions[_nodeId3].y;
              }
            }
          }
        } else {
          // copy the position from the cluster
          for (var _nodeId4 in containedNodes) {
            if (containedNodes.hasOwnProperty(_nodeId4)) {
              var _containedNode2 = this.body.nodes[_nodeId4];
              _containedNode2 = containedNodes[_nodeId4];
              // inherit position
              if (_containedNode2.options.fixed.x === false) {
                _containedNode2.x = clusterNode.x;
              }
              if (_containedNode2.options.fixed.y === false) {
                _containedNode2.y = clusterNode.y;
              }
            }
          }
        }

        // release nodes
        for (var _nodeId5 in containedNodes) {
          if (containedNodes.hasOwnProperty(_nodeId5)) {
            var _containedNode3 = this.body.nodes[_nodeId5];

            // inherit speed
            _containedNode3.vx = clusterNode.vx;
            _containedNode3.vy = clusterNode.vy;

            // we use these methods to avoid re-instantiating the shape, which happens with setOptions.
            _containedNode3.setOptions({ hidden: false, physics: true });

            delete this.clusteredNodes[_nodeId5];
          }
        }

        // copy the clusterNode edges because we cannot iterate over an object that we add or remove from.
        var edgesToBeDeleted = [];
        for (var i = 0; i < clusterNode.edges.length; i++) {
          edgesToBeDeleted.push(clusterNode.edges[i]);
        }

        // actually handling the deleting.
        for (var _i4 = 0; _i4 < edgesToBeDeleted.length; _i4++) {
          var edge = edgesToBeDeleted[_i4];

          var otherNodeId = this._getConnectedId(edge, clusterNodeId);
          // if the other node is in another cluster, we transfer ownership of this edge to the other cluster
          if (this.clusteredNodes[otherNodeId] !== undefined) {
            // transfer ownership:
            var otherCluster = this.body.nodes[this.clusteredNodes[otherNodeId].clusterId];
            var transferEdge = this.body.edges[edge.clusteringEdgeReplacingId];
            if (transferEdge !== undefined) {
              otherCluster.containedEdges[transferEdge.id] = transferEdge;

              // delete local reference
              delete containedEdges[transferEdge.id];

              // create new cluster edge from the otherCluster:
              // get to and from
              var fromId = transferEdge.fromId;
              var toId = transferEdge.toId;
              if (transferEdge.toId == otherNodeId) {
                toId = this.clusteredNodes[otherNodeId].clusterId;
              } else {
                fromId = this.clusteredNodes[otherNodeId].clusterId;
              }

              // clone the options and apply the cluster options to them
              var clonedOptions = _NetworkUtil2.default.cloneOptions(transferEdge, 'edge');
              util.deepExtend(clonedOptions, otherCluster.clusterEdgeProperties);

              // apply the edge specific options to it.
              var id = 'clusterEdge:' + util.randomUUID();
              util.deepExtend(clonedOptions, { from: fromId, to: toId, hidden: false, physics: true, id: id });

              // create it
              var newEdge = this.body.functions.createEdge(clonedOptions);
              newEdge.clusteringEdgeReplacingId = transferEdge.id;
              this.body.edges[id] = newEdge;
              this.body.edges[id].connect();
            }
          } else {
            var replacedEdge = this.body.edges[edge.clusteringEdgeReplacingId];
            if (replacedEdge !== undefined) {
              this._restoreEdge(replacedEdge);
            }
          }
          edge.cleanup();
          // this removes the edge from node.edges, which is why edgeIds is formed
          edge.disconnect();
          delete this.body.edges[edge.id];
        }

        // handle the releasing of the edges
        for (var edgeId in containedEdges) {
          if (containedEdges.hasOwnProperty(edgeId)) {
            this._restoreEdge(containedEdges[edgeId]);
          }
        }

        // remove clusterNode
        delete this.body.nodes[clusterNodeId];

        if (refreshData === true) {
          this.body.emitter.emit('_dataChanged');
        }
      }
    }, {
      key: 'getNodesInCluster',
      value: function getNodesInCluster(clusterId) {
        var nodesArray = [];
        if (this.isCluster(clusterId) === true) {
          var containedNodes = this.body.nodes[clusterId].containedNodes;
          for (var nodeId in containedNodes) {
            if (containedNodes.hasOwnProperty(nodeId)) {
              nodesArray.push(this.body.nodes[nodeId].id);
            }
          }
        }

        return nodesArray;
      }

      /**
      * Get the stack clusterId's that a certain node resides in. cluster A -> cluster B -> cluster C -> node
      * @param nodeId
      * @returns {Array}
      */

    }, {
      key: 'findNode',
      value: function findNode(nodeId) {
        var stack = [];
        var max = 100;
        var counter = 0;

        while (this.clusteredNodes[nodeId] !== undefined && counter < max) {
          stack.push(this.body.nodes[nodeId].id);
          nodeId = this.clusteredNodes[nodeId].clusterId;
          counter++;
        }
        stack.push(this.body.nodes[nodeId].id);
        stack.reverse();

        return stack;
      }

      /**
      * Using a clustered nodeId, update with the new options
      * @param clusteredNodeId
      * @param {object} newOptions
      */

    }, {
      key: 'updateClusteredNode',
      value: function updateClusteredNode(clusteredNodeId, newOptions) {
        if (clusteredNodeId === undefined) {
          throw new Error("No clusteredNodeId supplied to updateClusteredNode.");
        }
        if (newOptions === undefined) {
          throw new Error("No newOptions supplied to updateClusteredNode.");
        }
        if (this.body.nodes[clusteredNodeId] === undefined) {
          throw new Error("The clusteredNodeId supplied to updateClusteredNode does not exist.");
        }

        this.body.nodes[clusteredNodeId].setOptions(newOptions);
        this.body.emitter.emit('_dataChanged');
      }

      /**
      * Using a base edgeId, update all related clustered edges with the new options
      * @param startEdgeId
      * @param {object} newOptions
      */

    }, {
      key: 'updateEdge',
      value: function updateEdge(startEdgeId, newOptions) {
        if (startEdgeId === undefined) {
          throw new Error("No startEdgeId supplied to updateEdge.");
        }
        if (newOptions === undefined) {
          throw new Error("No newOptions supplied to updateEdge.");
        }
        if (this.body.edges[startEdgeId] === undefined) {
          throw new Error("The startEdgeId supplied to updateEdge does not exist.");
        }

        var allEdgeIds = this.getClusteredEdges(startEdgeId);
        for (var i = 0; i < allEdgeIds.length; i++) {
          var edge = this.body.edges[allEdgeIds[i]];
          edge.setOptions(newOptions);
        }
        this.body.emitter.emit('_dataChanged');
      }

      /**
      * Get a stack of clusterEdgeId's (+base edgeid) that a base edge is the same as. cluster edge C -> cluster edge B -> cluster edge A -> base edge(edgeId)
      * @param edgeId
      * @returns {Array}
      */

    }, {
      key: 'getClusteredEdges',
      value: function getClusteredEdges(edgeId) {
        var stack = [];
        var max = 100;
        var counter = 0;

        while (edgeId !== undefined && this.body.edges[edgeId] !== undefined && counter < max) {
          stack.push(this.body.edges[edgeId].id);
          edgeId = this.body.edges[edgeId].edgeReplacedById;
          counter++;
        }
        stack.reverse();
        return stack;
      }

      /**
      * Get the base edge id of clusterEdgeId. cluster edge (clusteredEdgeId) -> cluster edge B -> cluster edge C -> base edge
      * @param clusteredEdgeId
      * @returns baseEdgeId
      */

    }, {
      key: 'getBaseEdge',
      value: function getBaseEdge(clusteredEdgeId) {
        var baseEdgeId = clusteredEdgeId;
        var max = 100;
        var counter = 0;

        while (clusteredEdgeId !== undefined && this.body.edges[clusteredEdgeId] !== undefined && counter < max) {
          clusteredEdgeId = this.body.edges[clusteredEdgeId].clusteringEdgeReplacingId;
          counter++;
          if (clusteredEdgeId !== undefined) {
            baseEdgeId = clusteredEdgeId;
          }
        }
        return baseEdgeId;
      }

      /**
      * Get the Id the node is connected to
      * @param edge
      * @param nodeId
      * @returns {*}
      * @private
      */

    }, {
      key: '_getConnectedId',
      value: function _getConnectedId(edge, nodeId) {
        if (edge.toId != nodeId) {
          return edge.toId;
        } else if (edge.fromId != nodeId) {
          return edge.fromId;
        } else {
          return edge.fromId;
        }
      }

      /**
      * We determine how many connections denote an important hub.
      * We take the mean + 2*std as the important hub size. (Assuming a normal distribution of data, ~2.2%)
      *
      * @private
      */

    }, {
      key: '_getHubSize',
      value: function _getHubSize() {
        var average = 0;
        var averageSquared = 0;
        var hubCounter = 0;
        var largestHub = 0;

        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          var node = this.body.nodes[this.body.nodeIndices[i]];
          if (node.edges.length > largestHub) {
            largestHub = node.edges.length;
          }
          average += node.edges.length;
          averageSquared += Math.pow(node.edges.length, 2);
          hubCounter += 1;
        }
        average = average / hubCounter;
        averageSquared = averageSquared / hubCounter;

        var variance = averageSquared - Math.pow(average, 2);
        var standardDeviation = Math.sqrt(variance);

        var hubThreshold = Math.floor(average + 2 * standardDeviation);

        // always have at least one to cluster
        if (hubThreshold > largestHub) {
          hubThreshold = largestHub;
        }

        return hubThreshold;
      }
    }]);

    return ClusterEngine;
  }();

  exports.default = ClusterEngine;

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var NetworkUtil = function () {
    function NetworkUtil() {
      _classCallCheck(this, NetworkUtil);
    }

    /**
     * Find the center position of the network considering the bounding boxes
     */


    _createClass(NetworkUtil, null, [{
      key: "getRange",
      value: function getRange(allNodes) {
        var specificNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

        var minY = 1e9,
            maxY = -1e9,
            minX = 1e9,
            maxX = -1e9,
            node;
        if (specificNodes.length > 0) {
          for (var i = 0; i < specificNodes.length; i++) {
            node = allNodes[specificNodes[i]];
            if (minX > node.shape.boundingBox.left) {
              minX = node.shape.boundingBox.left;
            }
            if (maxX < node.shape.boundingBox.right) {
              maxX = node.shape.boundingBox.right;
            }
            if (minY > node.shape.boundingBox.top) {
              minY = node.shape.boundingBox.top;
            } // top is negative, bottom is positive
            if (maxY < node.shape.boundingBox.bottom) {
              maxY = node.shape.boundingBox.bottom;
            } // top is negative, bottom is positive
          }
        }

        if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {
          minY = 0, maxY = 0, minX = 0, maxX = 0;
        }
        return { minX: minX, maxX: maxX, minY: minY, maxY: maxY };
      }

      /**
       * Find the center position of the network
       */

    }, {
      key: "getRangeCore",
      value: function getRangeCore(allNodes) {
        var specificNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

        var minY = 1e9,
            maxY = -1e9,
            minX = 1e9,
            maxX = -1e9,
            node;
        if (specificNodes.length > 0) {
          for (var i = 0; i < specificNodes.length; i++) {
            node = allNodes[specificNodes[i]];
            if (minX > node.x) {
              minX = node.x;
            }
            if (maxX < node.x) {
              maxX = node.x;
            }
            if (minY > node.y) {
              minY = node.y;
            } // top is negative, bottom is positive
            if (maxY < node.y) {
              maxY = node.y;
            } // top is negative, bottom is positive
          }
        }

        if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {
          minY = 0, maxY = 0, minX = 0, maxX = 0;
        }
        return { minX: minX, maxX: maxX, minY: minY, maxY: maxY };
      }

      /**
       * @param {object} range = {minX: minX, maxX: maxX, minY: minY, maxY: maxY};
       * @returns {{x: number, y: number}}
       */

    }, {
      key: "findCenter",
      value: function findCenter(range) {
        return { x: 0.5 * (range.maxX + range.minX),
          y: 0.5 * (range.maxY + range.minY) };
      }

      /**
       * This returns a clone of the options or options of the edge or node to be used for construction of new edges or check functions for new nodes.
       * @param item
       * @param type
       * @returns {{}}
       */

    }, {
      key: "cloneOptions",
      value: function cloneOptions(item, type) {
        var clonedOptions = {};
        if (type === undefined || type === 'node') {
          util.deepExtend(clonedOptions, item.options, true);
          clonedOptions.x = item.x;
          clonedOptions.y = item.y;
          clonedOptions.amountOfConnections = item.edges.length;
        } else {
          util.deepExtend(clonedOptions, item.options, true);
        }
        return clonedOptions;
      }
    }]);

    return NetworkUtil;
  }();

  exports.default = NetworkUtil;

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _Node2 = __webpack_require__(67);

  var _Node3 = _interopRequireDefault(_Node2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  /**
   *
   */
  var Cluster = function (_Node) {
    _inherits(Cluster, _Node);

    function Cluster(options, body, imagelist, grouplist, globalOptions) {
      _classCallCheck(this, Cluster);

      var _this = _possibleConstructorReturn(this, (Cluster.__proto__ || Object.getPrototypeOf(Cluster)).call(this, options, body, imagelist, grouplist, globalOptions));

      _this.isCluster = true;
      _this.containedNodes = {};
      _this.containedEdges = {};
      return _this;
    }

    return Cluster;
  }(_Node3.default);

  exports.default = Cluster;

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  if (typeof window !== 'undefined') {
    window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  }

  var util = __webpack_require__(1);

  var CanvasRenderer = function () {
    function CanvasRenderer(body, canvas) {
      _classCallCheck(this, CanvasRenderer);

      this.body = body;
      this.canvas = canvas;

      this.redrawRequested = false;
      this.renderTimer = undefined;
      this.requiresTimeout = true;
      this.renderingActive = false;
      this.renderRequests = 0;
      this.pixelRatio = undefined;
      this.allowRedraw = true;

      this.dragging = false;
      this.options = {};
      this.defaultOptions = {
        hideEdgesOnDrag: false,
        hideNodesOnDrag: false
      };
      util.extend(this.options, this.defaultOptions);

      this._determineBrowserMethod();
      this.bindEventListeners();
    }

    _createClass(CanvasRenderer, [{
      key: 'bindEventListeners',
      value: function bindEventListeners() {
        var _this = this;

        this.body.emitter.on("dragStart", function () {
          _this.dragging = true;
        });
        this.body.emitter.on("dragEnd", function () {
          return _this.dragging = false;
        });
        this.body.emitter.on("_resizeNodes", function () {
          return _this._resizeNodes();
        });
        this.body.emitter.on("_redraw", function () {
          if (_this.renderingActive === false) {
            _this._redraw();
          }
        });
        this.body.emitter.on("_blockRedraw", function () {
          _this.allowRedraw = false;
        });
        this.body.emitter.on("_allowRedraw", function () {
          _this.allowRedraw = true;_this.redrawRequested = false;
        });
        this.body.emitter.on("_requestRedraw", this._requestRedraw.bind(this));
        this.body.emitter.on("_startRendering", function () {
          _this.renderRequests += 1;
          _this.renderingActive = true;
          _this._startRendering();
        });
        this.body.emitter.on("_stopRendering", function () {
          _this.renderRequests -= 1;
          _this.renderingActive = _this.renderRequests > 0;
          _this.renderTimer = undefined;
        });
        this.body.emitter.on('destroy', function () {
          _this.renderRequests = 0;
          _this.allowRedraw = false;
          _this.renderingActive = false;
          if (_this.requiresTimeout === true) {
            clearTimeout(_this.renderTimer);
          } else {
            cancelAnimationFrame(_this.renderTimer);
          }
          _this.body.emitter.off();
        });
      }
    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {
          var fields = ['hideEdgesOnDrag', 'hideNodesOnDrag'];
          util.selectiveDeepExtend(fields, this.options, options);
        }
      }
    }, {
      key: '_startRendering',
      value: function _startRendering() {
        if (this.renderingActive === true) {
          if (this.renderTimer === undefined) {
            if (this.requiresTimeout === true) {
              this.renderTimer = window.setTimeout(this._renderStep.bind(this), this.simulationInterval); // wait this.renderTimeStep milliseconds and perform the animation step function
            } else {
              this.renderTimer = window.requestAnimationFrame(this._renderStep.bind(this)); // wait this.renderTimeStep milliseconds and perform the animation step function
            }
          }
        }
      }
    }, {
      key: '_renderStep',
      value: function _renderStep() {
        if (this.renderingActive === true) {
          // reset the renderTimer so a new scheduled animation step can be set
          this.renderTimer = undefined;

          if (this.requiresTimeout === true) {
            // this schedules a new simulation step
            this._startRendering();
          }

          this._redraw();

          if (this.requiresTimeout === false) {
            // this schedules a new simulation step
            this._startRendering();
          }
        }
      }

      /**
       * Redraw the network with the current data
       * chart will be resized too.
       */

    }, {
      key: 'redraw',
      value: function redraw() {
        this.body.emitter.emit('setSize');
        this._redraw();
      }

      /**
       * Redraw the network with the current data
       * @param hidden | used to get the first estimate of the node sizes. only the nodes are drawn after which they are quickly drawn over.
       * @private
       */

    }, {
      key: '_requestRedraw',
      value: function _requestRedraw() {
        var _this2 = this;

        if (this.redrawRequested !== true && this.renderingActive === false && this.allowRedraw === true) {
          this.redrawRequested = true;
          if (this.requiresTimeout === true) {
            window.setTimeout(function () {
              _this2._redraw(false);
            }, 0);
          } else {
            window.requestAnimationFrame(function () {
              _this2._redraw(false);
            });
          }
        }
      }
    }, {
      key: '_redraw',
      value: function _redraw() {
        var hidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        if (this.allowRedraw === true) {
          this.body.emitter.emit("initRedraw");

          this.redrawRequested = false;
          var ctx = this.canvas.frame.canvas.getContext('2d');

          // when the container div was hidden, this fixes it back up!
          if (this.canvas.frame.canvas.width === 0 || this.canvas.frame.canvas.height === 0) {
            this.canvas.setSize();
          }

          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);

          ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);

          // clear the canvas
          var w = this.canvas.frame.canvas.clientWidth;
          var h = this.canvas.frame.canvas.clientHeight;
          ctx.clearRect(0, 0, w, h);

          // if the div is hidden, we stop the redraw here for performance.
          if (this.canvas.frame.clientWidth === 0) {
            return;
          }

          // set scaling and translation
          ctx.save();
          ctx.translate(this.body.view.translation.x, this.body.view.translation.y);
          ctx.scale(this.body.view.scale, this.body.view.scale);

          ctx.beginPath();
          this.body.emitter.emit("beforeDrawing", ctx);
          ctx.closePath();

          if (hidden === false) {
            if (this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) {
              this._drawEdges(ctx);
            }
          }

          if (this.dragging === false || this.dragging === true && this.options.hideNodesOnDrag === false) {
            this._drawNodes(ctx, hidden);
          }

          ctx.beginPath();
          this.body.emitter.emit("afterDrawing", ctx);
          ctx.closePath();

          // restore original scaling and translation
          ctx.restore();
          if (hidden === true) {
            ctx.clearRect(0, 0, w, h);
          }
        }
      }

      /**
       * Redraw all nodes
       * The 2d context of a HTML canvas can be retrieved by canvas.getContext('2d');
       * @param {CanvasRenderingContext2D}   ctx
       * @param {Boolean} [alwaysShow]
       * @private
       */

    }, {
      key: '_resizeNodes',
      value: function _resizeNodes() {
        var ctx = this.canvas.frame.canvas.getContext('2d');
        if (this.pixelRatio === undefined) {
          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
        }
        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
        ctx.save();
        ctx.translate(this.body.view.translation.x, this.body.view.translation.y);
        ctx.scale(this.body.view.scale, this.body.view.scale);

        var nodes = this.body.nodes;
        var node = void 0;

        // resize all nodes
        for (var nodeId in nodes) {
          if (nodes.hasOwnProperty(nodeId)) {
            node = nodes[nodeId];
            node.resize(ctx);
            node.updateBoundingBox(ctx, node.selected);
          }
        }

        // restore original scaling and translation
        ctx.restore();
      }

      /**
       * Redraw all nodes
       * The 2d context of a HTML canvas can be retrieved by canvas.getContext('2d');
       * @param {CanvasRenderingContext2D}   ctx
       * @param {Boolean} [alwaysShow]
       * @private
       */

    }, {
      key: '_drawNodes',
      value: function _drawNodes(ctx) {
        var alwaysShow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var nodes = this.body.nodes;
        var nodeIndices = this.body.nodeIndices;
        var node = void 0;
        var selected = [];
        var margin = 20;
        var topLeft = this.canvas.DOMtoCanvas({ x: -margin, y: -margin });
        var bottomRight = this.canvas.DOMtoCanvas({
          x: this.canvas.frame.canvas.clientWidth + margin,
          y: this.canvas.frame.canvas.clientHeight + margin
        });
        var viewableArea = { top: topLeft.y, left: topLeft.x, bottom: bottomRight.y, right: bottomRight.x };

        // draw unselected nodes;
        for (var i = 0; i < nodeIndices.length; i++) {
          node = nodes[nodeIndices[i]];
          // set selected nodes aside
          if (node.isSelected()) {
            selected.push(nodeIndices[i]);
          } else {
            if (alwaysShow === true) {
              node.draw(ctx);
            } else if (node.isBoundingBoxOverlappingWith(viewableArea) === true) {
              node.draw(ctx);
            } else {
              node.updateBoundingBox(ctx, node.selected);
            }
          }
        }

        // draw the selected nodes on top
        for (var _i = 0; _i < selected.length; _i++) {
          node = nodes[selected[_i]];
          node.draw(ctx);
        }
      }

      /**
       * Redraw all edges
       * The 2d context of a HTML canvas can be retrieved by canvas.getContext('2d');
       * @param {CanvasRenderingContext2D}   ctx
       * @private
       */

    }, {
      key: '_drawEdges',
      value: function _drawEdges(ctx) {
        var edges = this.body.edges;
        var edgeIndices = this.body.edgeIndices;
        var edge = void 0;

        for (var i = 0; i < edgeIndices.length; i++) {
          edge = edges[edgeIndices[i]];
          if (edge.connected === true) {
            edge.draw(ctx);
          }
        }
      }

      /**
       * Determine if the browser requires a setTimeout or a requestAnimationFrame. This was required because
       * some implementations (safari and IE9) did not support requestAnimationFrame
       * @private
       */

    }, {
      key: '_determineBrowserMethod',
      value: function _determineBrowserMethod() {
        if (typeof window !== 'undefined') {
          var browserType = navigator.userAgent.toLowerCase();
          this.requiresTimeout = false;
          if (browserType.indexOf('msie 9.0') != -1) {
            // IE 9
            this.requiresTimeout = true;
          } else if (browserType.indexOf('safari') != -1) {
            // safari
            if (browserType.indexOf('chrome') <= -1) {
              this.requiresTimeout = true;
            }
          }
        } else {
          this.requiresTimeout = true;
        }
      }
    }]);

    return CanvasRenderer;
  }();

  exports.default = CanvasRenderer;

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var Hammer = __webpack_require__(22);
  var hammerUtil = __webpack_require__(30);

  var util = __webpack_require__(1);

  /**
   * Create the main frame for the Network.
   * This function is executed once when a Network object is created. The frame
   * contains a canvas, and this canvas contains all objects like the axis and
   * nodes.
   * @private
   */

  var Canvas = function () {
    function Canvas(body) {
      _classCallCheck(this, Canvas);

      this.body = body;
      this.pixelRatio = 1;
      this.resizeTimer = undefined;
      this.resizeFunction = this._onResize.bind(this);
      this.cameraState = {};
      this.initialized = false;
      this.canvasViewCenter = {};

      this.options = {};
      this.defaultOptions = {
        autoResize: true,
        height: '100%',
        width: '100%'
      };
      util.extend(this.options, this.defaultOptions);

      this.bindEventListeners();
    }

    _createClass(Canvas, [{
      key: 'bindEventListeners',
      value: function bindEventListeners() {
        var _this = this;

        // bind the events
        this.body.emitter.once("resize", function (obj) {
          if (obj.width !== 0) {
            _this.body.view.translation.x = obj.width * 0.5;
          }
          if (obj.height !== 0) {
            _this.body.view.translation.y = obj.height * 0.5;
          }
        });
        this.body.emitter.on("setSize", this.setSize.bind(this));
        this.body.emitter.on("destroy", function () {
          _this.hammerFrame.destroy();
          _this.hammer.destroy();
          _this._cleanUp();
        });
      }
    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        var _this2 = this;

        if (options !== undefined) {
          var fields = ['width', 'height', 'autoResize'];
          util.selectiveDeepExtend(fields, this.options, options);
        }

        if (this.options.autoResize === true) {
          // automatically adapt to a changing size of the browser.
          this._cleanUp();
          this.resizeTimer = setInterval(function () {
            var changed = _this2.setSize();
            if (changed === true) {
              _this2.body.emitter.emit("_requestRedraw");
            }
          }, 1000);
          this.resizeFunction = this._onResize.bind(this);
          util.addEventListener(window, 'resize', this.resizeFunction);
        }
      }
    }, {
      key: '_cleanUp',
      value: function _cleanUp() {
        // automatically adapt to a changing size of the browser.
        if (this.resizeTimer !== undefined) {
          clearInterval(this.resizeTimer);
        }
        util.removeEventListener(window, 'resize', this.resizeFunction);
        this.resizeFunction = undefined;
      }
    }, {
      key: '_onResize',
      value: function _onResize() {
        this.setSize();
        this.body.emitter.emit("_redraw");
      }

      /**
       * Get and store the cameraState
       * @private
       */

    }, {
      key: '_getCameraState',
      value: function _getCameraState() {
        var pixelRatio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.pixelRatio;

        if (this.initialized === true) {
          this.cameraState.previousWidth = this.frame.canvas.width / pixelRatio;
          this.cameraState.previousHeight = this.frame.canvas.height / pixelRatio;
          this.cameraState.scale = this.body.view.scale;
          this.cameraState.position = this.DOMtoCanvas({
            x: 0.5 * this.frame.canvas.width / pixelRatio,
            y: 0.5 * this.frame.canvas.height / pixelRatio
          });
        }
      }

      /**
       * Set the cameraState
       * @private
       */

    }, {
      key: '_setCameraState',
      value: function _setCameraState() {
        if (this.cameraState.scale !== undefined && this.frame.canvas.clientWidth !== 0 && this.frame.canvas.clientHeight !== 0 && this.pixelRatio !== 0 && this.cameraState.previousWidth > 0) {

          var widthRatio = this.frame.canvas.width / this.pixelRatio / this.cameraState.previousWidth;
          var heightRatio = this.frame.canvas.height / this.pixelRatio / this.cameraState.previousHeight;
          var newScale = this.cameraState.scale;

          if (widthRatio != 1 && heightRatio != 1) {
            newScale = this.cameraState.scale * 0.5 * (widthRatio + heightRatio);
          } else if (widthRatio != 1) {
            newScale = this.cameraState.scale * widthRatio;
          } else if (heightRatio != 1) {
            newScale = this.cameraState.scale * heightRatio;
          }

          this.body.view.scale = newScale;
          // this comes from the view module.
          var currentViewCenter = this.DOMtoCanvas({
            x: 0.5 * this.frame.canvas.clientWidth,
            y: 0.5 * this.frame.canvas.clientHeight
          });

          var distanceFromCenter = { // offset from view, distance view has to change by these x and y to center the node
            x: currentViewCenter.x - this.cameraState.position.x,
            y: currentViewCenter.y - this.cameraState.position.y
          };
          this.body.view.translation.x += distanceFromCenter.x * this.body.view.scale;
          this.body.view.translation.y += distanceFromCenter.y * this.body.view.scale;
        }
      }
    }, {
      key: '_prepareValue',
      value: function _prepareValue(value) {
        if (typeof value === 'number') {
          return value + 'px';
        } else if (typeof value === 'string') {
          if (value.indexOf('%') !== -1 || value.indexOf('px') !== -1) {
            return value;
          } else if (value.indexOf('%') === -1) {
            return value + 'px';
          }
        }
        throw new Error('Could not use the value supplied for width or height:' + value);
      }

      /**
       * Create the HTML
       */

    }, {
      key: '_create',
      value: function _create() {
        // remove all elements from the container element.
        while (this.body.container.hasChildNodes()) {
          this.body.container.removeChild(this.body.container.firstChild);
        }

        this.frame = document.createElement('div');
        this.frame.className = 'vis-network';
        this.frame.style.position = 'relative';
        this.frame.style.overflow = 'hidden';
        this.frame.tabIndex = 900; // tab index is required for keycharm to bind keystrokes to the div instead of the window

        //////////////////////////////////////////////////////////////////

        this.frame.canvas = document.createElement("canvas");
        this.frame.canvas.style.position = 'relative';
        this.frame.appendChild(this.frame.canvas);

        if (!this.frame.canvas.getContext) {
          var noCanvas = document.createElement('DIV');
          noCanvas.style.color = 'red';
          noCanvas.style.fontWeight = 'bold';
          noCanvas.style.padding = '10px';
          noCanvas.innerHTML = 'Error: your browser does not support HTML canvas';
          this.frame.canvas.appendChild(noCanvas);
        } else {
          var ctx = this.frame.canvas.getContext("2d");
          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);

          this.frame.canvas.getContext("2d").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
        }

        // add the frame to the container element
        this.body.container.appendChild(this.frame);

        this.body.view.scale = 1;
        this.body.view.translation = { x: 0.5 * this.frame.canvas.clientWidth, y: 0.5 * this.frame.canvas.clientHeight };

        this._bindHammer();
      }

      /**
       * This function binds hammer, it can be repeated over and over due to the uniqueness check.
       * @private
       */

    }, {
      key: '_bindHammer',
      value: function _bindHammer() {
        var _this3 = this;

        if (this.hammer !== undefined) {
          this.hammer.destroy();
        }
        this.drag = {};
        this.pinch = {};

        // init hammer
        this.hammer = new Hammer(this.frame.canvas);
        this.hammer.get('pinch').set({ enable: true });
        // enable to get better response, todo: test on mobile.
        this.hammer.get('pan').set({ threshold: 5, direction: Hammer.DIRECTION_ALL });

        hammerUtil.onTouch(this.hammer, function (event) {
          _this3.body.eventListeners.onTouch(event);
        });
        this.hammer.on('tap', function (event) {
          _this3.body.eventListeners.onTap(event);
        });
        this.hammer.on('doubletap', function (event) {
          _this3.body.eventListeners.onDoubleTap(event);
        });
        this.hammer.on('press', function (event) {
          _this3.body.eventListeners.onHold(event);
        });
        this.hammer.on('panstart', function (event) {
          _this3.body.eventListeners.onDragStart(event);
        });
        this.hammer.on('panmove', function (event) {
          _this3.body.eventListeners.onDrag(event);
        });
        this.hammer.on('panend', function (event) {
          _this3.body.eventListeners.onDragEnd(event);
        });
        this.hammer.on('pinch', function (event) {
          _this3.body.eventListeners.onPinch(event);
        });

        // TODO: neatly cleanup these handlers when re-creating the Canvas, IF these are done with hammer, event.stopPropagation will not work?
        this.frame.canvas.addEventListener('mousewheel', function (event) {
          _this3.body.eventListeners.onMouseWheel(event);
        });
        this.frame.canvas.addEventListener('DOMMouseScroll', function (event) {
          _this3.body.eventListeners.onMouseWheel(event);
        });

        this.frame.canvas.addEventListener('mousemove', function (event) {
          _this3.body.eventListeners.onMouseMove(event);
        });
        this.frame.canvas.addEventListener('contextmenu', function (event) {
          _this3.body.eventListeners.onContext(event);
        });

        this.hammerFrame = new Hammer(this.frame);
        hammerUtil.onRelease(this.hammerFrame, function (event) {
          _this3.body.eventListeners.onRelease(event);
        });
      }

      /**
       * Set a new size for the network
       * @param {string} width   Width in pixels or percentage (for example '800px'
       *                         or '50%')
       * @param {string} height  Height in pixels or percentage  (for example '400px'
       *                         or '30%')
       */

    }, {
      key: 'setSize',
      value: function setSize() {
        var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.width;
        var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.height;

        width = this._prepareValue(width);
        height = this._prepareValue(height);

        var emitEvent = false;
        var oldWidth = this.frame.canvas.width;
        var oldHeight = this.frame.canvas.height;

        // update the pixel ratio
        var ctx = this.frame.canvas.getContext("2d");
        var previousRatio = this.pixelRatio; // we cache this because the camera state storage needs the old value
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);

        if (width != this.options.width || height != this.options.height || this.frame.style.width != width || this.frame.style.height != height) {
          this._getCameraState(previousRatio);

          this.frame.style.width = width;
          this.frame.style.height = height;

          this.frame.canvas.style.width = '100%';
          this.frame.canvas.style.height = '100%';

          this.frame.canvas.width = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);
          this.frame.canvas.height = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);

          this.options.width = width;
          this.options.height = height;

          this.canvasViewCenter = {
            x: 0.5 * this.frame.clientWidth,
            y: 0.5 * this.frame.clientHeight
          };

          emitEvent = true;
        } else {
          // this would adapt the width of the canvas to the width from 100% if and only if
          // there is a change.

          // store the camera if there is a change in size.
          if (this.frame.canvas.width != Math.round(this.frame.canvas.clientWidth * this.pixelRatio) || this.frame.canvas.height != Math.round(this.frame.canvas.clientHeight * this.pixelRatio)) {
            this._getCameraState(previousRatio);
          }

          if (this.frame.canvas.width != Math.round(this.frame.canvas.clientWidth * this.pixelRatio)) {
            this.frame.canvas.width = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);
            emitEvent = true;
          }
          if (this.frame.canvas.height != Math.round(this.frame.canvas.clientHeight * this.pixelRatio)) {
            this.frame.canvas.height = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);
            emitEvent = true;
          }
        }

        if (emitEvent === true) {
          this.body.emitter.emit('resize', {
            width: Math.round(this.frame.canvas.width / this.pixelRatio),
            height: Math.round(this.frame.canvas.height / this.pixelRatio),
            oldWidth: Math.round(oldWidth / this.pixelRatio),
            oldHeight: Math.round(oldHeight / this.pixelRatio)
          });

          // restore the camera on change.
          this._setCameraState();
        }

        // set initialized so the get and set camera will work from now on.
        this.initialized = true;
        return emitEvent;
      }
    }, {
      key: '_XconvertDOMtoCanvas',


      /**
       * Convert the X coordinate in DOM-space (coordinate point in browser relative to the container div) to
       * the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon)
       * @param {number} x
       * @returns {number}
       * @private
       */
      value: function _XconvertDOMtoCanvas(x) {
        return (x - this.body.view.translation.x) / this.body.view.scale;
      }

      /**
       * Convert the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to
       * the X coordinate in DOM-space (coordinate point in browser relative to the container div)
       * @param {number} x
       * @returns {number}
       * @private
       */

    }, {
      key: '_XconvertCanvasToDOM',
      value: function _XconvertCanvasToDOM(x) {
        return x * this.body.view.scale + this.body.view.translation.x;
      }

      /**
       * Convert the Y coordinate in DOM-space (coordinate point in browser relative to the container div) to
       * the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon)
       * @param {number} y
       * @returns {number}
       * @private
       */

    }, {
      key: '_YconvertDOMtoCanvas',
      value: function _YconvertDOMtoCanvas(y) {
        return (y - this.body.view.translation.y) / this.body.view.scale;
      }

      /**
       * Convert the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to
       * the Y coordinate in DOM-space (coordinate point in browser relative to the container div)
       * @param {number} y
       * @returns {number}
       * @private
       */

    }, {
      key: '_YconvertCanvasToDOM',
      value: function _YconvertCanvasToDOM(y) {
        return y * this.body.view.scale + this.body.view.translation.y;
      }

      /**
       *
       * @param {object} pos   = {x: number, y: number}
       * @returns {{x: number, y: number}}
       * @constructor
       */

    }, {
      key: 'canvasToDOM',
      value: function canvasToDOM(pos) {
        return { x: this._XconvertCanvasToDOM(pos.x), y: this._YconvertCanvasToDOM(pos.y) };
      }

      /**
       *
       * @param {object} pos   = {x: number, y: number}
       * @returns {{x: number, y: number}}
       * @constructor
       */

    }, {
      key: 'DOMtoCanvas',
      value: function DOMtoCanvas(pos) {
        return { x: this._XconvertDOMtoCanvas(pos.x), y: this._YconvertDOMtoCanvas(pos.y) };
      }
    }]);

    return Canvas;
  }();

  exports.default = Canvas;

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NetworkUtil = __webpack_require__(105);

  var _NetworkUtil2 = _interopRequireDefault(_NetworkUtil);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var View = function () {
    function View(body, canvas) {
      var _this = this;

      _classCallCheck(this, View);

      this.body = body;
      this.canvas = canvas;

      this.animationSpeed = 1 / this.renderRefreshRate;
      this.animationEasingFunction = "easeInOutQuint";
      this.easingTime = 0;
      this.sourceScale = 0;
      this.targetScale = 0;
      this.sourceTranslation = 0;
      this.targetTranslation = 0;
      this.lockedOnNodeId = undefined;
      this.lockedOnNodeOffset = undefined;
      this.touchTime = 0;

      this.viewFunction = undefined;

      this.body.emitter.on("fit", this.fit.bind(this));
      this.body.emitter.on("animationFinished", function () {
        _this.body.emitter.emit("_stopRendering");
      });
      this.body.emitter.on("unlockNode", this.releaseNode.bind(this));
    }

    _createClass(View, [{
      key: 'setOptions',
      value: function setOptions() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        this.options = options;
      }

      /**
       * This function zooms out to fit all data on screen based on amount of nodes
       * @param {Object} Options
       * @param {Boolean} [initialZoom]  | zoom based on fitted formula or range, true = fitted, default = false;
       */

    }, {
      key: 'fit',
      value: function fit() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { nodes: [] };
        var initialZoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var range = void 0;
        var zoomLevel = void 0;
        if (options.nodes === undefined || options.nodes.length === 0) {
          options.nodes = this.body.nodeIndices;
        }

        if (initialZoom === true) {
          // check if more than half of the nodes have a predefined position. If so, we use the range, not the approximation.
          var positionDefined = 0;
          for (var nodeId in this.body.nodes) {
            if (this.body.nodes.hasOwnProperty(nodeId)) {
              var node = this.body.nodes[nodeId];
              if (node.predefinedPosition === true) {
                positionDefined += 1;
              }
            }
          }
          if (positionDefined > 0.5 * this.body.nodeIndices.length) {
            this.fit(options, false);
            return;
          }

          range = _NetworkUtil2.default.getRange(this.body.nodes, options.nodes);

          var numberOfNodes = this.body.nodeIndices.length;
          zoomLevel = 12.662 / (numberOfNodes + 7.4147) + 0.0964822; // this is obtained from fitting a dataset from 5 points with scale levels that looked good.

          // correct for larger canvasses.
          var factor = Math.min(this.canvas.frame.canvas.clientWidth / 600, this.canvas.frame.canvas.clientHeight / 600);
          zoomLevel *= factor;
        } else {
          this.body.emitter.emit("_resizeNodes");
          range = _NetworkUtil2.default.getRange(this.body.nodes, options.nodes);

          var xDistance = Math.abs(range.maxX - range.minX) * 1.1;
          var yDistance = Math.abs(range.maxY - range.minY) * 1.1;

          var xZoomLevel = this.canvas.frame.canvas.clientWidth / xDistance;
          var yZoomLevel = this.canvas.frame.canvas.clientHeight / yDistance;

          zoomLevel = xZoomLevel <= yZoomLevel ? xZoomLevel : yZoomLevel;
        }

        if (zoomLevel > 1.0) {
          zoomLevel = 1.0;
        } else if (zoomLevel === 0) {
          zoomLevel = 1.0;
        }

        var center = _NetworkUtil2.default.findCenter(range);
        var animationOptions = { position: center, scale: zoomLevel, animation: options.animation };
        this.moveTo(animationOptions);
      }

      // animation

      /**
       * Center a node in view.
       *
       * @param {Number} nodeId
       * @param {Number} [options]
       */

    }, {
      key: 'focus',
      value: function focus(nodeId) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (this.body.nodes[nodeId] !== undefined) {
          var nodePosition = { x: this.body.nodes[nodeId].x, y: this.body.nodes[nodeId].y };
          options.position = nodePosition;
          options.lockedOnNode = nodeId;

          this.moveTo(options);
        } else {
          console.log("Node: " + nodeId + " cannot be found.");
        }
      }

      /**
       *
       * @param {Object} options  |  options.offset   = {x:Number, y:Number}   // offset from the center in DOM pixels
       *                          |  options.scale    = Number                 // scale to move to
       *                          |  options.position = {x:Number, y:Number}   // position to move to
       *                          |  options.animation = {duration:Number, easingFunction:String} || Boolean   // position to move to
       */

    }, {
      key: 'moveTo',
      value: function moveTo(options) {
        if (options === undefined) {
          options = {};
          return;
        }
        if (options.offset === undefined) {
          options.offset = { x: 0, y: 0 };
        }
        if (options.offset.x === undefined) {
          options.offset.x = 0;
        }
        if (options.offset.y === undefined) {
          options.offset.y = 0;
        }
        if (options.scale === undefined) {
          options.scale = this.body.view.scale;
        }
        if (options.position === undefined) {
          options.position = this.getViewPosition();
        }
        if (options.animation === undefined) {
          options.animation = { duration: 0 };
        }
        if (options.animation === false) {
          options.animation = { duration: 0 };
        }
        if (options.animation === true) {
          options.animation = {};
        }
        if (options.animation.duration === undefined) {
          options.animation.duration = 1000;
        } // default duration
        if (options.animation.easingFunction === undefined) {
          options.animation.easingFunction = "easeInOutQuad";
        } // default easing function

        this.animateView(options);
      }

      /**
       *
       * @param {Object} options  |  options.offset   = {x:Number, y:Number}   // offset from the center in DOM pixels
       *                          |  options.time     = Number                 // animation time in milliseconds
       *                          |  options.scale    = Number                 // scale to animate to
       *                          |  options.position = {x:Number, y:Number}   // position to animate to
       *                          |  options.easingFunction = String           // linear, easeInQuad, easeOutQuad, easeInOutQuad,
       *                                                                       // easeInCubic, easeOutCubic, easeInOutCubic,
       *                                                                       // easeInQuart, easeOutQuart, easeInOutQuart,
       *                                                                       // easeInQuint, easeOutQuint, easeInOutQuint
       */

    }, {
      key: 'animateView',
      value: function animateView(options) {
        if (options === undefined) {
          return;
        }
        this.animationEasingFunction = options.animation.easingFunction;
        // release if something focussed on the node
        this.releaseNode();
        if (options.locked === true) {
          this.lockedOnNodeId = options.lockedOnNode;
          this.lockedOnNodeOffset = options.offset;
        }

        // forcefully complete the old animation if it was still running
        if (this.easingTime != 0) {
          this._transitionRedraw(true); // by setting easingtime to 1, we finish the animation.
        }

        this.sourceScale = this.body.view.scale;
        this.sourceTranslation = this.body.view.translation;
        this.targetScale = options.scale;

        // set the scale so the viewCenter is based on the correct zoom level. This is overridden in the transitionRedraw
        // but at least then we'll have the target transition
        this.body.view.scale = this.targetScale;
        var viewCenter = this.canvas.DOMtoCanvas({ x: 0.5 * this.canvas.frame.canvas.clientWidth, y: 0.5 * this.canvas.frame.canvas.clientHeight });

        var distanceFromCenter = { // offset from view, distance view has to change by these x and y to center the node
          x: viewCenter.x - options.position.x,
          y: viewCenter.y - options.position.y
        };
        this.targetTranslation = {
          x: this.sourceTranslation.x + distanceFromCenter.x * this.targetScale + options.offset.x,
          y: this.sourceTranslation.y + distanceFromCenter.y * this.targetScale + options.offset.y
        };

        // if the time is set to 0, don't do an animation
        if (options.animation.duration === 0) {
          if (this.lockedOnNodeId != undefined) {
            this.viewFunction = this._lockedRedraw.bind(this);
            this.body.emitter.on("initRedraw", this.viewFunction);
          } else {
            this.body.view.scale = this.targetScale;
            this.body.view.translation = this.targetTranslation;
            this.body.emitter.emit("_requestRedraw");
          }
        } else {
          this.animationSpeed = 1 / (60 * options.animation.duration * 0.001) || 1 / 60; // 60 for 60 seconds, 0.001 for milli's
          this.animationEasingFunction = options.animation.easingFunction;

          this.viewFunction = this._transitionRedraw.bind(this);
          this.body.emitter.on("initRedraw", this.viewFunction);
          this.body.emitter.emit("_startRendering");
        }
      }

      /**
       * used to animate smoothly by hijacking the redraw function.
       * @private
       */

    }, {
      key: '_lockedRedraw',
      value: function _lockedRedraw() {
        var nodePosition = { x: this.body.nodes[this.lockedOnNodeId].x, y: this.body.nodes[this.lockedOnNodeId].y };
        var viewCenter = this.canvas.DOMtoCanvas({ x: 0.5 * this.canvas.frame.canvas.clientWidth, y: 0.5 * this.canvas.frame.canvas.clientHeight });
        var distanceFromCenter = { // offset from view, distance view has to change by these x and y to center the node
          x: viewCenter.x - nodePosition.x,
          y: viewCenter.y - nodePosition.y
        };
        var sourceTranslation = this.body.view.translation;
        var targetTranslation = {
          x: sourceTranslation.x + distanceFromCenter.x * this.body.view.scale + this.lockedOnNodeOffset.x,
          y: sourceTranslation.y + distanceFromCenter.y * this.body.view.scale + this.lockedOnNodeOffset.y
        };

        this.body.view.translation = targetTranslation;
      }
    }, {
      key: 'releaseNode',
      value: function releaseNode() {
        if (this.lockedOnNodeId !== undefined && this.viewFunction !== undefined) {
          this.body.emitter.off("initRedraw", this.viewFunction);
          this.lockedOnNodeId = undefined;
          this.lockedOnNodeOffset = undefined;
        }
      }

      /**
       *
       * @param easingTime
       * @private
       */

    }, {
      key: '_transitionRedraw',
      value: function _transitionRedraw() {
        var finished = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        this.easingTime += this.animationSpeed;
        this.easingTime = finished === true ? 1.0 : this.easingTime;

        var progress = util.easingFunctions[this.animationEasingFunction](this.easingTime);

        this.body.view.scale = this.sourceScale + (this.targetScale - this.sourceScale) * progress;
        this.body.view.translation = {
          x: this.sourceTranslation.x + (this.targetTranslation.x - this.sourceTranslation.x) * progress,
          y: this.sourceTranslation.y + (this.targetTranslation.y - this.sourceTranslation.y) * progress
        };

        // cleanup
        if (this.easingTime >= 1.0) {
          this.body.emitter.off("initRedraw", this.viewFunction);
          this.easingTime = 0;
          if (this.lockedOnNodeId != undefined) {
            this.viewFunction = this._lockedRedraw.bind(this);
            this.body.emitter.on("initRedraw", this.viewFunction);
          }
          this.body.emitter.emit("animationFinished");
        }
      }
    }, {
      key: 'getScale',
      value: function getScale() {
        return this.body.view.scale;
      }
    }, {
      key: 'getViewPosition',
      value: function getViewPosition() {
        return this.canvas.DOMtoCanvas({ x: 0.5 * this.canvas.frame.canvas.clientWidth, y: 0.5 * this.canvas.frame.canvas.clientHeight });
      }
    }]);

    return View;
  }();

  exports.default = View;

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NavigationHandler = __webpack_require__(111);

  var _NavigationHandler2 = _interopRequireDefault(_NavigationHandler);

  var _Popup = __webpack_require__(112);

  var _Popup2 = _interopRequireDefault(_Popup);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var InteractionHandler = function () {
    function InteractionHandler(body, canvas, selectionHandler) {
      _classCallCheck(this, InteractionHandler);

      this.body = body;
      this.canvas = canvas;
      this.selectionHandler = selectionHandler;
      this.navigationHandler = new _NavigationHandler2.default(body, canvas);

      // bind the events from hammer to functions in this object
      this.body.eventListeners.onTap = this.onTap.bind(this);
      this.body.eventListeners.onTouch = this.onTouch.bind(this);
      this.body.eventListeners.onDoubleTap = this.onDoubleTap.bind(this);
      this.body.eventListeners.onHold = this.onHold.bind(this);
      this.body.eventListeners.onDragStart = this.onDragStart.bind(this);
      this.body.eventListeners.onDrag = this.onDrag.bind(this);
      this.body.eventListeners.onDragEnd = this.onDragEnd.bind(this);
      this.body.eventListeners.onMouseWheel = this.onMouseWheel.bind(this);
      this.body.eventListeners.onPinch = this.onPinch.bind(this);
      this.body.eventListeners.onMouseMove = this.onMouseMove.bind(this);
      this.body.eventListeners.onRelease = this.onRelease.bind(this);
      this.body.eventListeners.onContext = this.onContext.bind(this);

      this.touchTime = 0;
      this.drag = {};
      this.pinch = {};
      this.popup = undefined;
      this.popupObj = undefined;
      this.popupTimer = undefined;

      this.body.functions.getPointer = this.getPointer.bind(this);

      this.options = {};
      this.defaultOptions = {
        dragNodes: true,
        dragView: true,
        hover: false,
        keyboard: {
          enabled: false,
          speed: { x: 10, y: 10, zoom: 0.02 },
          bindToWindow: true
        },
        navigationButtons: false,
        tooltipDelay: 300,
        zoomView: true
      };
      util.extend(this.options, this.defaultOptions);

      this.bindEventListeners();
    }

    _createClass(InteractionHandler, [{
      key: 'bindEventListeners',
      value: function bindEventListeners() {
        var _this = this;

        this.body.emitter.on('destroy', function () {
          clearTimeout(_this.popupTimer);
          delete _this.body.functions.getPointer;
        });
      }
    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {
          // extend all but the values in fields
          var fields = ['hideEdgesOnDrag', 'hideNodesOnDrag', 'keyboard', 'multiselect', 'selectable', 'selectConnectedEdges'];
          util.selectiveNotDeepExtend(fields, this.options, options);

          // merge the keyboard options in.
          util.mergeOptions(this.options, options, 'keyboard');

          if (options.tooltip) {
            util.extend(this.options.tooltip, options.tooltip);
            if (options.tooltip.color) {
              this.options.tooltip.color = util.parseColor(options.tooltip.color);
            }
          }
        }

        this.navigationHandler.setOptions(this.options);
      }

      /**
       * Get the pointer location from a touch location
       * @param {{x: Number, y: Number}} touch
       * @return {{x: Number, y: Number}} pointer
       * @private
       */

    }, {
      key: 'getPointer',
      value: function getPointer(touch) {
        return {
          x: touch.x - util.getAbsoluteLeft(this.canvas.frame.canvas),
          y: touch.y - util.getAbsoluteTop(this.canvas.frame.canvas)
        };
      }

      /**
       * On start of a touch gesture, store the pointer
       * @param event
       * @private
       */

    }, {
      key: 'onTouch',
      value: function onTouch(event) {
        if (new Date().valueOf() - this.touchTime > 50) {
          this.drag.pointer = this.getPointer(event.center);
          this.drag.pinched = false;
          this.pinch.scale = this.body.view.scale;
          // to avoid double fireing of this event because we have two hammer instances. (on canvas and on frame)
          this.touchTime = new Date().valueOf();
        }
      }

      /**
       * handle tap/click event: select/unselect a node
       * @private
       */

    }, {
      key: 'onTap',
      value: function onTap(event) {
        var pointer = this.getPointer(event.center);
        var multiselect = this.selectionHandler.options.multiselect && (event.changedPointers[0].ctrlKey || event.changedPointers[0].metaKey);

        this.checkSelectionChanges(pointer, event, multiselect);
        this.selectionHandler._generateClickEvent('click', event, pointer);
      }

      /**
       * handle doubletap event
       * @private
       */

    }, {
      key: 'onDoubleTap',
      value: function onDoubleTap(event) {
        var pointer = this.getPointer(event.center);
        this.selectionHandler._generateClickEvent('doubleClick', event, pointer);
      }

      /**
       * handle long tap event: multi select nodes
       * @private
       */

    }, {
      key: 'onHold',
      value: function onHold(event) {
        var pointer = this.getPointer(event.center);
        var multiselect = this.selectionHandler.options.multiselect;

        this.checkSelectionChanges(pointer, event, multiselect);

        this.selectionHandler._generateClickEvent('click', event, pointer);
        this.selectionHandler._generateClickEvent('hold', event, pointer);
      }

      /**
       * handle the release of the screen
       *
       * @private
       */

    }, {
      key: 'onRelease',
      value: function onRelease(event) {
        if (new Date().valueOf() - this.touchTime > 10) {
          var pointer = this.getPointer(event.center);
          this.selectionHandler._generateClickEvent('release', event, pointer);
          // to avoid double fireing of this event because we have two hammer instances. (on canvas and on frame)
          this.touchTime = new Date().valueOf();
        }
      }
    }, {
      key: 'onContext',
      value: function onContext(event) {
        var pointer = this.getPointer({ x: event.clientX, y: event.clientY });
        this.selectionHandler._generateClickEvent('oncontext', event, pointer);
      }

      /**
       *
       * @param pointer
       * @param add
       */

    }, {
      key: 'checkSelectionChanges',
      value: function checkSelectionChanges(pointer, event) {
        var add = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        var previouslySelectedEdgeCount = this.selectionHandler._getSelectedEdgeCount();
        var previouslySelectedNodeCount = this.selectionHandler._getSelectedNodeCount();
        var previousSelection = this.selectionHandler.getSelection();
        var selected = void 0;
        if (add === true) {
          selected = this.selectionHandler.selectAdditionalOnPoint(pointer);
        } else {
          selected = this.selectionHandler.selectOnPoint(pointer);
        }
        var selectedEdgesCount = this.selectionHandler._getSelectedEdgeCount();
        var selectedNodesCount = this.selectionHandler._getSelectedNodeCount();
        var currentSelection = this.selectionHandler.getSelection();

        var _determineIfDifferent2 = this._determineIfDifferent(previousSelection, currentSelection),
            nodesChanged = _determineIfDifferent2.nodesChanged,
            edgesChanged = _determineIfDifferent2.edgesChanged;

        var nodeSelected = false;

        if (selectedNodesCount - previouslySelectedNodeCount > 0) {
          // node was selected
          this.selectionHandler._generateClickEvent('selectNode', event, pointer);
          selected = true;
          nodeSelected = true;
        } else if (nodesChanged === true && selectedNodesCount > 0) {
          this.selectionHandler._generateClickEvent('deselectNode', event, pointer, previousSelection);
          this.selectionHandler._generateClickEvent('selectNode', event, pointer);
          nodeSelected = true;
          selected = true;
        } else if (selectedNodesCount - previouslySelectedNodeCount < 0) {
          // node was deselected
          this.selectionHandler._generateClickEvent('deselectNode', event, pointer, previousSelection);
          selected = true;
        }

        // handle the selected edges
        if (selectedEdgesCount - previouslySelectedEdgeCount > 0 && nodeSelected === false) {
          // edge was selected
          this.selectionHandler._generateClickEvent('selectEdge', event, pointer);
          selected = true;
        } else if (selectedEdgesCount > 0 && edgesChanged === true) {
          this.selectionHandler._generateClickEvent('deselectEdge', event, pointer, previousSelection);
          this.selectionHandler._generateClickEvent('selectEdge', event, pointer);
          selected = true;
        } else if (selectedEdgesCount - previouslySelectedEdgeCount < 0) {
          // edge was deselected
          this.selectionHandler._generateClickEvent('deselectEdge', event, pointer, previousSelection);
          selected = true;
        }

        // fire the select event if anything has been selected or deselected
        if (selected === true) {
          // select or unselect
          this.selectionHandler._generateClickEvent('select', event, pointer);
        }
      }

      /**
       * This function checks if the nodes and edges previously selected have changed.
       * @param previousSelection
       * @param currentSelection
       * @returns {{nodesChanged: boolean, edgesChanged: boolean}}
       * @private
       */

    }, {
      key: '_determineIfDifferent',
      value: function _determineIfDifferent(previousSelection, currentSelection) {
        var nodesChanged = false;
        var edgesChanged = false;

        for (var i = 0; i < previousSelection.nodes.length; i++) {
          if (currentSelection.nodes.indexOf(previousSelection.nodes[i]) === -1) {
            nodesChanged = true;
          }
        }
        for (var _i = 0; _i < currentSelection.nodes.length; _i++) {
          if (previousSelection.nodes.indexOf(previousSelection.nodes[_i]) === -1) {
            nodesChanged = true;
          }
        }
        for (var _i2 = 0; _i2 < previousSelection.edges.length; _i2++) {
          if (currentSelection.edges.indexOf(previousSelection.edges[_i2]) === -1) {
            edgesChanged = true;
          }
        }
        for (var _i3 = 0; _i3 < currentSelection.edges.length; _i3++) {
          if (previousSelection.edges.indexOf(previousSelection.edges[_i3]) === -1) {
            edgesChanged = true;
          }
        }

        return { nodesChanged: nodesChanged, edgesChanged: edgesChanged };
      }

      /**
       * This function is called by onDragStart.
       * It is separated out because we can then overload it for the datamanipulation system.
       *
       * @private
       */

    }, {
      key: 'onDragStart',
      value: function onDragStart(event) {
        //in case the touch event was triggered on an external div, do the initial touch now.
        if (this.drag.pointer === undefined) {
          this.onTouch(event);
        }

        // note: drag.pointer is set in onTouch to get the initial touch location
        var node = this.selectionHandler.getNodeAt(this.drag.pointer);

        this.drag.dragging = true;
        this.drag.selection = [];
        this.drag.translation = util.extend({}, this.body.view.translation); // copy the object
        this.drag.nodeId = undefined;

        if (node !== undefined && this.options.dragNodes === true) {
          this.drag.nodeId = node.id;
          // select the clicked node if not yet selected
          if (node.isSelected() === false) {
            this.selectionHandler.unselectAll();
            this.selectionHandler.selectObject(node);
          }

          // after select to contain the node
          this.selectionHandler._generateClickEvent('dragStart', event, this.drag.pointer);

          var selection = this.selectionHandler.selectionObj.nodes;
          // create an array with the selected nodes and their original location and status
          for (var nodeId in selection) {
            if (selection.hasOwnProperty(nodeId)) {
              var object = selection[nodeId];
              var s = {
                id: object.id,
                node: object,

                // store original x, y, xFixed and yFixed, make the node temporarily Fixed
                x: object.x,
                y: object.y,
                xFixed: object.options.fixed.x,
                yFixed: object.options.fixed.y
              };

              object.options.fixed.x = true;
              object.options.fixed.y = true;

              this.drag.selection.push(s);
            }
          }
        } else {
          // fallback if no node is selected and thus the view is dragged.
          this.selectionHandler._generateClickEvent('dragStart', event, this.drag.pointer, undefined, true);
        }
      }

      /**
       * handle drag event
       * @private
       */

    }, {
      key: 'onDrag',
      value: function onDrag(event) {
        var _this2 = this;

        if (this.drag.pinched === true) {
          return;
        }

        // remove the focus on node if it is focussed on by the focusOnNode
        this.body.emitter.emit('unlockNode');

        var pointer = this.getPointer(event.center);

        var selection = this.drag.selection;
        if (selection && selection.length && this.options.dragNodes === true) {
          (function () {
            _this2.selectionHandler._generateClickEvent('dragging', event, pointer);

            // calculate delta's and new location
            var deltaX = pointer.x - _this2.drag.pointer.x;
            var deltaY = pointer.y - _this2.drag.pointer.y;

            // update position of all selected nodes
            selection.forEach(function (selection) {
              var node = selection.node;
              // only move the node if it was not fixed initially
              if (selection.xFixed === false) {
                node.x = _this2.canvas._XconvertDOMtoCanvas(_this2.canvas._XconvertCanvasToDOM(selection.x) + deltaX);
              }
              // only move the node if it was not fixed initially
              if (selection.yFixed === false) {
                node.y = _this2.canvas._YconvertDOMtoCanvas(_this2.canvas._YconvertCanvasToDOM(selection.y) + deltaY);
              }
            });

            // start the simulation of the physics
            _this2.body.emitter.emit('startSimulation');
          })();
        } else {
          // move the network
          if (this.options.dragView === true) {
            this.selectionHandler._generateClickEvent('dragging', event, pointer, undefined, true);

            // if the drag was not started properly because the click started outside the network div, start it now.
            if (this.drag.pointer === undefined) {
              this.onDragStart(event);
              return;
            }
            var diffX = pointer.x - this.drag.pointer.x;
            var diffY = pointer.y - this.drag.pointer.y;

            this.body.view.translation = { x: this.drag.translation.x + diffX, y: this.drag.translation.y + diffY };
            this.body.emitter.emit('_redraw');
          }
        }
      }

      /**
       * handle drag start event
       * @private
       */

    }, {
      key: 'onDragEnd',
      value: function onDragEnd(event) {
        this.drag.dragging = false;
        var selection = this.drag.selection;
        if (selection && selection.length) {
          selection.forEach(function (s) {
            // restore original xFixed and yFixed
            s.node.options.fixed.x = s.xFixed;
            s.node.options.fixed.y = s.yFixed;
          });
          this.selectionHandler._generateClickEvent('dragEnd', event, this.getPointer(event.center));
          this.body.emitter.emit('startSimulation');
        } else {
          this.selectionHandler._generateClickEvent('dragEnd', event, this.getPointer(event.center), undefined, true);
          this.body.emitter.emit('_requestRedraw');
        }
      }

      /**
       * Handle pinch event
       * @param event
       * @private
       */

    }, {
      key: 'onPinch',
      value: function onPinch(event) {
        var pointer = this.getPointer(event.center);

        this.drag.pinched = true;
        if (this.pinch['scale'] === undefined) {
          this.pinch.scale = 1;
        }

        // TODO: enabled moving while pinching?
        var scale = this.pinch.scale * event.scale;
        this.zoom(scale, pointer);
      }

      /**
       * Zoom the network in or out
       * @param {Number} scale a number around 1, and between 0.01 and 10
       * @param {{x: Number, y: Number}} pointer    Position on screen
       * @return {Number} appliedScale    scale is limited within the boundaries
       * @private
       */

    }, {
      key: 'zoom',
      value: function zoom(scale, pointer) {
        if (this.options.zoomView === true) {
          var scaleOld = this.body.view.scale;
          if (scale < 0.00001) {
            scale = 0.00001;
          }
          if (scale > 10) {
            scale = 10;
          }

          var preScaleDragPointer = undefined;
          if (this.drag !== undefined) {
            if (this.drag.dragging === true) {
              preScaleDragPointer = this.canvas.DOMtoCanvas(this.drag.pointer);
            }
          }
          // + this.canvas.frame.canvas.clientHeight / 2
          var translation = this.body.view.translation;

          var scaleFrac = scale / scaleOld;
          var tx = (1 - scaleFrac) * pointer.x + translation.x * scaleFrac;
          var ty = (1 - scaleFrac) * pointer.y + translation.y * scaleFrac;

          this.body.view.scale = scale;
          this.body.view.translation = { x: tx, y: ty };

          if (preScaleDragPointer != undefined) {
            var postScaleDragPointer = this.canvas.canvasToDOM(preScaleDragPointer);
            this.drag.pointer.x = postScaleDragPointer.x;
            this.drag.pointer.y = postScaleDragPointer.y;
          }

          this.body.emitter.emit('_requestRedraw');

          if (scaleOld < scale) {
            this.body.emitter.emit('zoom', { direction: '+', scale: this.body.view.scale });
          } else {
            this.body.emitter.emit('zoom', { direction: '-', scale: this.body.view.scale });
          }
        }
      }

      /**
       * Event handler for mouse wheel event, used to zoom the timeline
       * See http://adomas.org/javascript-mouse-wheel/
       *     https://github.com/EightMedia/hammer.js/issues/256
       * @param {MouseEvent}  event
       * @private
       */

    }, {
      key: 'onMouseWheel',
      value: function onMouseWheel(event) {
        if (this.options.zoomView === true) {
          // retrieve delta
          var delta = 0;
          if (event.wheelDelta) {
            /* IE/Opera. */
            delta = event.wheelDelta / 120;
          } else if (event.detail) {
            /* Mozilla case. */
            // In Mozilla, sign of delta is different than in IE.
            // Also, delta is multiple of 3.
            delta = -event.detail / 3;
          }

          // If delta is nonzero, handle it.
          // Basically, delta is now positive if wheel was scrolled up,
          // and negative, if wheel was scrolled down.
          if (delta !== 0) {

            // calculate the new scale
            var scale = this.body.view.scale;
            var zoom = delta / 10;
            if (delta < 0) {
              zoom = zoom / (1 - zoom);
            }
            scale *= 1 + zoom;

            // calculate the pointer location
            var pointer = this.getPointer({ x: event.clientX, y: event.clientY });

            // apply the new scale
            this.zoom(scale, pointer);
          }

          // Prevent default actions caused by mouse wheel.
          event.preventDefault();
        }
      }

      /**
       * Mouse move handler for checking whether the title moves over a node with a title.
       * @param  {Event} event
       * @private
       */

    }, {
      key: 'onMouseMove',
      value: function onMouseMove(event) {
        var _this3 = this;

        var pointer = this.getPointer({ x: event.clientX, y: event.clientY });
        var popupVisible = false;

        // check if the previously selected node is still selected
        if (this.popup !== undefined) {
          if (this.popup.hidden === false) {
            this._checkHidePopup(pointer);
          }

          // if the popup was not hidden above
          if (this.popup.hidden === false) {
            popupVisible = true;
            this.popup.setPosition(pointer.x + 3, pointer.y - 5);
            this.popup.show();
          }
        }

        // if we bind the keyboard to the div, we have to highlight it to use it. This highlights it on mouse over.
        if (this.options.keyboard.bindToWindow === false && this.options.keyboard.enabled === true) {
          this.canvas.frame.focus();
        }

        // start a timeout that will check if the mouse is positioned above an element
        if (popupVisible === false) {
          if (this.popupTimer !== undefined) {
            clearInterval(this.popupTimer); // stop any running calculationTimer
            this.popupTimer = undefined;
          }
          if (!this.drag.dragging) {
            this.popupTimer = setTimeout(function () {
              return _this3._checkShowPopup(pointer);
            }, this.options.tooltipDelay);
          }
        }

        /**
        * Adding hover highlights
        */
        if (this.options.hover === true) {
          // adding hover highlights
          var obj = this.selectionHandler.getNodeAt(pointer);
          if (obj === undefined) {
            obj = this.selectionHandler.getEdgeAt(pointer);
          }
          this.selectionHandler.hoverObject(obj);
        }
      }

      /**
       * Check if there is an element on the given position in the network
       * (a node or edge). If so, and if this element has a title,
       * show a popup window with its title.
       *
       * @param {{x:Number, y:Number}} pointer
       * @private
       */

    }, {
      key: '_checkShowPopup',
      value: function _checkShowPopup(pointer) {
        var x = this.canvas._XconvertDOMtoCanvas(pointer.x);
        var y = this.canvas._YconvertDOMtoCanvas(pointer.y);
        var pointerObj = {
          left: x,
          top: y,
          right: x,
          bottom: y
        };

        var previousPopupObjId = this.popupObj === undefined ? undefined : this.popupObj.id;
        var nodeUnderCursor = false;
        var popupType = 'node';

        // check if a node is under the cursor.
        if (this.popupObj === undefined) {
          // search the nodes for overlap, select the top one in case of multiple nodes
          var nodeIndices = this.body.nodeIndices;
          var nodes = this.body.nodes;
          var node = void 0;
          var overlappingNodes = [];
          for (var i = 0; i < nodeIndices.length; i++) {
            node = nodes[nodeIndices[i]];
            if (node.isOverlappingWith(pointerObj) === true) {
              if (node.getTitle() !== undefined) {
                overlappingNodes.push(nodeIndices[i]);
              }
            }
          }

          if (overlappingNodes.length > 0) {
            // if there are overlapping nodes, select the last one, this is the one which is drawn on top of the others
            this.popupObj = nodes[overlappingNodes[overlappingNodes.length - 1]];
            // if you hover over a node, the title of the edge is not supposed to be shown.
            nodeUnderCursor = true;
          }
        }

        if (this.popupObj === undefined && nodeUnderCursor === false) {
          // search the edges for overlap
          var edgeIndices = this.body.edgeIndices;
          var edges = this.body.edges;
          var edge = void 0;
          var overlappingEdges = [];
          for (var _i4 = 0; _i4 < edgeIndices.length; _i4++) {
            edge = edges[edgeIndices[_i4]];
            if (edge.isOverlappingWith(pointerObj) === true) {
              if (edge.connected === true && edge.getTitle() !== undefined) {
                overlappingEdges.push(edgeIndices[_i4]);
              }
            }
          }

          if (overlappingEdges.length > 0) {
            this.popupObj = edges[overlappingEdges[overlappingEdges.length - 1]];
            popupType = 'edge';
          }
        }

        if (this.popupObj !== undefined) {
          // show popup message window
          if (this.popupObj.id !== previousPopupObjId) {
            if (this.popup === undefined) {
              this.popup = new _Popup2.default(this.canvas.frame);
            }

            this.popup.popupTargetType = popupType;
            this.popup.popupTargetId = this.popupObj.id;

            // adjust a small offset such that the mouse cursor is located in the
            // bottom left location of the popup, and you can easily move over the
            // popup area
            this.popup.setPosition(pointer.x + 3, pointer.y - 5);
            this.popup.setText(this.popupObj.getTitle());
            this.popup.show();
            this.body.emitter.emit('showPopup', this.popupObj.id);
          }
        } else {
          if (this.popup !== undefined) {
            this.popup.hide();
            this.body.emitter.emit('hidePopup');
          }
        }
      }

      /**
       * Check if the popup must be hidden, which is the case when the mouse is no
       * longer hovering on the object
       * @param {{x:Number, y:Number}} pointer
       * @private
       */

    }, {
      key: '_checkHidePopup',
      value: function _checkHidePopup(pointer) {
        var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);

        var stillOnObj = false;
        if (this.popup.popupTargetType === 'node') {
          if (this.body.nodes[this.popup.popupTargetId] !== undefined) {
            stillOnObj = this.body.nodes[this.popup.popupTargetId].isOverlappingWith(pointerObj);

            // if the mouse is still one the node, we have to check if it is not also on one that is drawn on top of it.
            // we initially only check stillOnObj because this is much faster.
            if (stillOnObj === true) {
              var overNode = this.selectionHandler.getNodeAt(pointer);
              stillOnObj = overNode.id === this.popup.popupTargetId;
            }
          }
        } else {
          if (this.selectionHandler.getNodeAt(pointer) === undefined) {
            if (this.body.edges[this.popup.popupTargetId] !== undefined) {
              stillOnObj = this.body.edges[this.popup.popupTargetId].isOverlappingWith(pointerObj);
            }
          }
        }

        if (stillOnObj === false) {
          this.popupObj = undefined;
          this.popup.hide();
          this.body.emitter.emit('hidePopup');
        }
      }
    }]);

    return InteractionHandler;
  }();

  exports.default = InteractionHandler;

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);
  var Hammer = __webpack_require__(22);
  var hammerUtil = __webpack_require__(30);
  var keycharm = __webpack_require__(25);

  var NavigationHandler = function () {
    function NavigationHandler(body, canvas) {
      var _this = this;

      _classCallCheck(this, NavigationHandler);

      this.body = body;
      this.canvas = canvas;

      this.iconsCreated = false;
      this.navigationHammers = [];
      this.boundFunctions = {};
      this.touchTime = 0;
      this.activated = false;

      this.body.emitter.on("activate", function () {
        _this.activated = true;_this.configureKeyboardBindings();
      });
      this.body.emitter.on("deactivate", function () {
        _this.activated = false;_this.configureKeyboardBindings();
      });
      this.body.emitter.on("destroy", function () {
        if (_this.keycharm !== undefined) {
          _this.keycharm.destroy();
        }
      });

      this.options = {};
    }

    _createClass(NavigationHandler, [{
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {
          this.options = options;
          this.create();
        }
      }
    }, {
      key: 'create',
      value: function create() {
        if (this.options.navigationButtons === true) {
          if (this.iconsCreated === false) {
            this.loadNavigationElements();
          }
        } else if (this.iconsCreated === true) {
          this.cleanNavigation();
        }

        this.configureKeyboardBindings();
      }
    }, {
      key: 'cleanNavigation',
      value: function cleanNavigation() {
        // clean hammer bindings
        if (this.navigationHammers.length != 0) {
          for (var i = 0; i < this.navigationHammers.length; i++) {
            this.navigationHammers[i].destroy();
          }
          this.navigationHammers = [];
        }

        // clean up previous navigation items
        if (this.navigationDOM && this.navigationDOM['wrapper'] && this.navigationDOM['wrapper'].parentNode) {
          this.navigationDOM['wrapper'].parentNode.removeChild(this.navigationDOM['wrapper']);
        }

        this.iconsCreated = false;
      }

      /**
       * Creation of the navigation controls nodes. They are drawn over the rest of the nodes and are not affected by scale and translation
       * they have a triggerFunction which is called on click. If the position of the navigation controls is dependent
       * on this.frame.canvas.clientWidth or this.frame.canvas.clientHeight, we flag horizontalAlignLeft and verticalAlignTop false.
       * This means that the location will be corrected by the _relocateNavigation function on a size change of the canvas.
       *
       * @private
       */

    }, {
      key: 'loadNavigationElements',
      value: function loadNavigationElements() {
        var _this2 = this;

        this.cleanNavigation();

        this.navigationDOM = {};
        var navigationDivs = ['up', 'down', 'left', 'right', 'zoomIn', 'zoomOut', 'zoomExtends'];
        var navigationDivActions = ['_moveUp', '_moveDown', '_moveLeft', '_moveRight', '_zoomIn', '_zoomOut', '_fit'];

        this.navigationDOM['wrapper'] = document.createElement('div');
        this.navigationDOM['wrapper'].className = 'vis-navigation';
        this.canvas.frame.appendChild(this.navigationDOM['wrapper']);

        for (var i = 0; i < navigationDivs.length; i++) {
          this.navigationDOM[navigationDivs[i]] = document.createElement('div');
          this.navigationDOM[navigationDivs[i]].className = 'vis-button vis-' + navigationDivs[i];
          this.navigationDOM['wrapper'].appendChild(this.navigationDOM[navigationDivs[i]]);

          var hammer = new Hammer(this.navigationDOM[navigationDivs[i]]);
          if (navigationDivActions[i] === "_fit") {
            hammerUtil.onTouch(hammer, this._fit.bind(this));
          } else {
            hammerUtil.onTouch(hammer, this.bindToRedraw.bind(this, navigationDivActions[i]));
          }

          this.navigationHammers.push(hammer);
        }

        // use a hammer for the release so we do not require the one used in the rest of the network
        // the one the rest uses can be overloaded by the manipulation system.
        var hammerFrame = new Hammer(this.canvas.frame);
        hammerUtil.onRelease(hammerFrame, function () {
          _this2._stopMovement();
        });
        this.navigationHammers.push(hammerFrame);

        this.iconsCreated = true;
      }
    }, {
      key: 'bindToRedraw',
      value: function bindToRedraw(action) {
        if (this.boundFunctions[action] === undefined) {
          this.boundFunctions[action] = this[action].bind(this);
          this.body.emitter.on("initRedraw", this.boundFunctions[action]);
          this.body.emitter.emit("_startRendering");
        }
      }
    }, {
      key: 'unbindFromRedraw',
      value: function unbindFromRedraw(action) {
        if (this.boundFunctions[action] !== undefined) {
          this.body.emitter.off("initRedraw", this.boundFunctions[action]);
          this.body.emitter.emit("_stopRendering");
          delete this.boundFunctions[action];
        }
      }

      /**
       * this stops all movement induced by the navigation buttons
       *
       * @private
       */

    }, {
      key: '_fit',
      value: function _fit() {
        if (new Date().valueOf() - this.touchTime > 700) {
          // TODO: fix ugly hack to avoid hammer's double fireing of event (because we use release?)
          this.body.emitter.emit("fit", { duration: 700 });
          this.touchTime = new Date().valueOf();
        }
      }

      /**
       * this stops all movement induced by the navigation buttons
       *
       * @private
       */

    }, {
      key: '_stopMovement',
      value: function _stopMovement() {
        for (var boundAction in this.boundFunctions) {
          if (this.boundFunctions.hasOwnProperty(boundAction)) {
            this.body.emitter.off("initRedraw", this.boundFunctions[boundAction]);
            this.body.emitter.emit("_stopRendering");
          }
        }
        this.boundFunctions = {};
      }
    }, {
      key: '_moveUp',
      value: function _moveUp() {
        this.body.view.translation.y += this.options.keyboard.speed.y;
      }
    }, {
      key: '_moveDown',
      value: function _moveDown() {
        this.body.view.translation.y -= this.options.keyboard.speed.y;
      }
    }, {
      key: '_moveLeft',
      value: function _moveLeft() {
        this.body.view.translation.x += this.options.keyboard.speed.x;
      }
    }, {
      key: '_moveRight',
      value: function _moveRight() {
        this.body.view.translation.x -= this.options.keyboard.speed.x;
      }
    }, {
      key: '_zoomIn',
      value: function _zoomIn() {
        var scaleOld = this.body.view.scale;
        var scale = this.body.view.scale * (1 + this.options.keyboard.speed.zoom);
        var translation = this.body.view.translation;
        var scaleFrac = scale / scaleOld;
        var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;
        var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;

        this.body.view.scale = scale;
        this.body.view.translation = { x: tx, y: ty };
        this.body.emitter.emit('zoom', { direction: '+', scale: this.body.view.scale });
      }
    }, {
      key: '_zoomOut',
      value: function _zoomOut() {
        var scaleOld = this.body.view.scale;
        var scale = this.body.view.scale / (1 + this.options.keyboard.speed.zoom);
        var translation = this.body.view.translation;
        var scaleFrac = scale / scaleOld;
        var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;
        var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;

        this.body.view.scale = scale;
        this.body.view.translation = { x: tx, y: ty };
        this.body.emitter.emit('zoom', { direction: '-', scale: this.body.view.scale });
      }

      /**
       * bind all keys using keycharm.
       */

    }, {
      key: 'configureKeyboardBindings',
      value: function configureKeyboardBindings() {
        var _this3 = this;

        if (this.keycharm !== undefined) {
          this.keycharm.destroy();
        }

        if (this.options.keyboard.enabled === true) {
          if (this.options.keyboard.bindToWindow === true) {
            this.keycharm = keycharm({ container: window, preventDefault: true });
          } else {
            this.keycharm = keycharm({ container: this.canvas.frame, preventDefault: true });
          }

          this.keycharm.reset();

          if (this.activated === true) {
            this.keycharm.bind("up", function () {
              _this3.bindToRedraw("_moveUp");
            }, "keydown");
            this.keycharm.bind("down", function () {
              _this3.bindToRedraw("_moveDown");
            }, "keydown");
            this.keycharm.bind("left", function () {
              _this3.bindToRedraw("_moveLeft");
            }, "keydown");
            this.keycharm.bind("right", function () {
              _this3.bindToRedraw("_moveRight");
            }, "keydown");
            this.keycharm.bind("=", function () {
              _this3.bindToRedraw("_zoomIn");
            }, "keydown");
            this.keycharm.bind("num+", function () {
              _this3.bindToRedraw("_zoomIn");
            }, "keydown");
            this.keycharm.bind("num-", function () {
              _this3.bindToRedraw("_zoomOut");
            }, "keydown");
            this.keycharm.bind("-", function () {
              _this3.bindToRedraw("_zoomOut");
            }, "keydown");
            this.keycharm.bind("[", function () {
              _this3.bindToRedraw("_zoomOut");
            }, "keydown");
            this.keycharm.bind("]", function () {
              _this3.bindToRedraw("_zoomIn");
            }, "keydown");
            this.keycharm.bind("pageup", function () {
              _this3.bindToRedraw("_zoomIn");
            }, "keydown");
            this.keycharm.bind("pagedown", function () {
              _this3.bindToRedraw("_zoomOut");
            }, "keydown");

            this.keycharm.bind("up", function () {
              _this3.unbindFromRedraw("_moveUp");
            }, "keyup");
            this.keycharm.bind("down", function () {
              _this3.unbindFromRedraw("_moveDown");
            }, "keyup");
            this.keycharm.bind("left", function () {
              _this3.unbindFromRedraw("_moveLeft");
            }, "keyup");
            this.keycharm.bind("right", function () {
              _this3.unbindFromRedraw("_moveRight");
            }, "keyup");
            this.keycharm.bind("=", function () {
              _this3.unbindFromRedraw("_zoomIn");
            }, "keyup");
            this.keycharm.bind("num+", function () {
              _this3.unbindFromRedraw("_zoomIn");
            }, "keyup");
            this.keycharm.bind("num-", function () {
              _this3.unbindFromRedraw("_zoomOut");
            }, "keyup");
            this.keycharm.bind("-", function () {
              _this3.unbindFromRedraw("_zoomOut");
            }, "keyup");
            this.keycharm.bind("[", function () {
              _this3.unbindFromRedraw("_zoomOut");
            }, "keyup");
            this.keycharm.bind("]", function () {
              _this3.unbindFromRedraw("_zoomIn");
            }, "keyup");
            this.keycharm.bind("pageup", function () {
              _this3.unbindFromRedraw("_zoomIn");
            }, "keyup");
            this.keycharm.bind("pagedown", function () {
              _this3.unbindFromRedraw("_zoomOut");
            }, "keyup");
          }
        }
      }
    }]);

    return NavigationHandler;
  }();

  exports.default = NavigationHandler;

/***/ },
/* 112 */
/***/ function(module, exports) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  /**
   * Popup is a class to create a popup window with some text
   * @param {Element}  container     The container object.
   * @param {Number} [x]
   * @param {Number} [y]
   * @param {String} [text]
   * @param {Object} [style]     An object containing borderColor,
   *                             backgroundColor, etc.
   */
  var Popup = function () {
    function Popup(container) {
      _classCallCheck(this, Popup);

      this.container = container;

      this.x = 0;
      this.y = 0;
      this.padding = 5;
      this.hidden = false;

      // create the frame
      this.frame = document.createElement('div');
      this.frame.className = 'vis-network-tooltip';
      this.container.appendChild(this.frame);
    }

    /**
     * @param {number} x   Horizontal position of the popup window
     * @param {number} y   Vertical position of the popup window
     */


    _createClass(Popup, [{
      key: 'setPosition',
      value: function setPosition(x, y) {
        this.x = parseInt(x);
        this.y = parseInt(y);
      }

      /**
       * Set the content for the popup window. This can be HTML code or text.
       * @param {string | Element} content
       */

    }, {
      key: 'setText',
      value: function setText(content) {
        if (content instanceof Element) {
          this.frame.innerHTML = '';
          this.frame.appendChild(content);
        } else {
          this.frame.innerHTML = content; // string containing text or HTML
        }
      }

      /**
       * Show the popup window
       * @param {boolean} [doShow]    Show or hide the window
       */

    }, {
      key: 'show',
      value: function show(doShow) {
        if (doShow === undefined) {
          doShow = true;
        }

        if (doShow === true) {
          var height = this.frame.clientHeight;
          var width = this.frame.clientWidth;
          var maxHeight = this.frame.parentNode.clientHeight;
          var maxWidth = this.frame.parentNode.clientWidth;

          var top = this.y - height;
          if (top + height + this.padding > maxHeight) {
            top = maxHeight - height - this.padding;
          }
          if (top < this.padding) {
            top = this.padding;
          }

          var left = this.x;
          if (left + width + this.padding > maxWidth) {
            left = maxWidth - width - this.padding;
          }
          if (left < this.padding) {
            left = this.padding;
          }

          this.frame.style.left = left + "px";
          this.frame.style.top = top + "px";
          this.frame.style.visibility = "visible";
          this.hidden = false;
        } else {
          this.hide();
        }
      }

      /**
       * Hide the popup window
       */

    }, {
      key: 'hide',
      value: function hide() {
        this.hidden = true;
        this.frame.style.visibility = "hidden";
      }
    }]);

    return Popup;
  }();

  exports.default = Popup;

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _Node = __webpack_require__(67);

  var _Node2 = _interopRequireDefault(_Node);

  var _Edge = __webpack_require__(87);

  var _Edge2 = _interopRequireDefault(_Edge);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var SelectionHandler = function () {
    function SelectionHandler(body, canvas) {
      var _this = this;

      _classCallCheck(this, SelectionHandler);

      this.body = body;
      this.canvas = canvas;
      this.selectionObj = { nodes: [], edges: [] };
      this.hoverObj = { nodes: {}, edges: {} };

      this.options = {};
      this.defaultOptions = {
        multiselect: false,
        selectable: true,
        selectConnectedEdges: true,
        hoverConnectedEdges: true
      };
      util.extend(this.options, this.defaultOptions);

      this.body.emitter.on("_dataChanged", function () {
        _this.updateSelection();
      });
    }

    _createClass(SelectionHandler, [{
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {
          var fields = ['multiselect', 'hoverConnectedEdges', 'selectable', 'selectConnectedEdges'];
          util.selectiveDeepExtend(fields, this.options, options);
        }
      }

      /**
       * handles the selection part of the tap;
       *
       * @param {Object} pointer
       * @private
       */

    }, {
      key: 'selectOnPoint',
      value: function selectOnPoint(pointer) {
        var selected = false;
        if (this.options.selectable === true) {
          var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);

          // unselect after getting the objects in order to restore width and height.
          this.unselectAll();

          if (obj !== undefined) {
            selected = this.selectObject(obj);
          }
          this.body.emitter.emit("_requestRedraw");
        }
        return selected;
      }
    }, {
      key: 'selectAdditionalOnPoint',
      value: function selectAdditionalOnPoint(pointer) {
        var selectionChanged = false;
        if (this.options.selectable === true) {
          var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);

          if (obj !== undefined) {
            selectionChanged = true;
            if (obj.isSelected() === true) {
              this.deselectObject(obj);
            } else {
              this.selectObject(obj);
            }

            this.body.emitter.emit("_requestRedraw");
          }
        }
        return selectionChanged;
      }
    }, {
      key: '_generateClickEvent',
      value: function _generateClickEvent(eventType, event, pointer, oldSelection) {
        var emptySelection = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

        var properties = void 0;
        if (emptySelection === true) {
          properties = { nodes: [], edges: [] };
        } else {
          properties = this.getSelection();
        }
        properties['pointer'] = {
          DOM: { x: pointer.x, y: pointer.y },
          canvas: this.canvas.DOMtoCanvas(pointer)
        };
        properties['event'] = event;

        if (oldSelection !== undefined) {
          properties['previousSelection'] = oldSelection;
        }
        this.body.emitter.emit(eventType, properties);
      }
    }, {
      key: 'selectObject',
      value: function selectObject(obj) {
        var highlightEdges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.selectConnectedEdges;

        if (obj !== undefined) {
          if (obj instanceof _Node2.default) {
            if (highlightEdges === true) {
              this._selectConnectedEdges(obj);
            }
          }
          obj.select();
          this._addToSelection(obj);
          return true;
        }
        return false;
      }
    }, {
      key: 'deselectObject',
      value: function deselectObject(obj) {
        if (obj.isSelected() === true) {
          obj.selected = false;
          this._removeFromSelection(obj);
        }
      }

      /**
       * retrieve all nodes overlapping with given object
       * @param {Object} object  An object with parameters left, top, right, bottom
       * @return {Number[]}   An array with id's of the overlapping nodes
       * @private
       */

    }, {
      key: '_getAllNodesOverlappingWith',
      value: function _getAllNodesOverlappingWith(object) {
        var overlappingNodes = [];
        var nodes = this.body.nodes;
        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          var nodeId = this.body.nodeIndices[i];
          if (nodes[nodeId].isOverlappingWith(object)) {
            overlappingNodes.push(nodeId);
          }
        }
        return overlappingNodes;
      }

      /**
       * Return a position object in canvasspace from a single point in screenspace
       *
       * @param pointer
       * @returns {{left: number, top: number, right: number, bottom: number}}
       * @private
       */

    }, {
      key: '_pointerToPositionObject',
      value: function _pointerToPositionObject(pointer) {
        var canvasPos = this.canvas.DOMtoCanvas(pointer);
        return {
          left: canvasPos.x - 1,
          top: canvasPos.y + 1,
          right: canvasPos.x + 1,
          bottom: canvasPos.y - 1
        };
      }

      /**
       * Get the top node at the a specific point (like a click)
       *
       * @param {{x: Number, y: Number}} pointer
       * @return {Node | undefined} node
       */

    }, {
      key: 'getNodeAt',
      value: function getNodeAt(pointer) {
        var returnNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        // we first check if this is an navigation controls element
        var positionObject = this._pointerToPositionObject(pointer);
        var overlappingNodes = this._getAllNodesOverlappingWith(positionObject);
        // if there are overlapping nodes, select the last one, this is the
        // one which is drawn on top of the others
        if (overlappingNodes.length > 0) {
          if (returnNode === true) {
            return this.body.nodes[overlappingNodes[overlappingNodes.length - 1]];
          } else {
            return overlappingNodes[overlappingNodes.length - 1];
          }
        } else {
          return undefined;
        }
      }

      /**
       * retrieve all edges overlapping with given object, selector is around center
       * @param {Object} object  An object with parameters left, top, right, bottom
       * @return {Number[]}   An array with id's of the overlapping nodes
       * @private
       */

    }, {
      key: '_getEdgesOverlappingWith',
      value: function _getEdgesOverlappingWith(object, overlappingEdges) {
        var edges = this.body.edges;
        for (var i = 0; i < this.body.edgeIndices.length; i++) {
          var edgeId = this.body.edgeIndices[i];
          if (edges[edgeId].isOverlappingWith(object)) {
            overlappingEdges.push(edgeId);
          }
        }
      }

      /**
       * retrieve all nodes overlapping with given object
       * @param {Object} object  An object with parameters left, top, right, bottom
       * @return {Number[]}   An array with id's of the overlapping nodes
       * @private
       */

    }, {
      key: '_getAllEdgesOverlappingWith',
      value: function _getAllEdgesOverlappingWith(object) {
        var overlappingEdges = [];
        this._getEdgesOverlappingWith(object, overlappingEdges);
        return overlappingEdges;
      }

      /**
       * Place holder. To implement change the getNodeAt to a _getObjectAt. Have the _getObjectAt call
       * getNodeAt and _getEdgesAt, then priortize the selection to user preferences.
       *
       * @param pointer
       * @returns {undefined}
       */

    }, {
      key: 'getEdgeAt',
      value: function getEdgeAt(pointer) {
        var returnEdge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        // Iterate over edges, pick closest within 10
        var canvasPos = this.canvas.DOMtoCanvas(pointer);
        var mindist = 10;
        var overlappingEdge = null;
        var edges = this.body.edges;
        for (var i = 0; i < this.body.edgeIndices.length; i++) {
          var edgeId = this.body.edgeIndices[i];
          var edge = edges[edgeId];
          if (edge.connected) {
            var xFrom = edge.from.x;
            var yFrom = edge.from.y;
            var xTo = edge.to.x;
            var yTo = edge.to.y;
            var dist = edge.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, canvasPos.x, canvasPos.y);
            if (dist < mindist) {
              overlappingEdge = edgeId;
              mindist = dist;
            }
          }
        }
        if (overlappingEdge) {
          if (returnEdge === true) {
            return this.body.edges[overlappingEdge];
          } else {
            return overlappingEdge;
          }
        } else {
          return undefined;
        }
      }

      /**
       * Add object to the selection array.
       *
       * @param obj
       * @private
       */

    }, {
      key: '_addToSelection',
      value: function _addToSelection(obj) {
        if (obj instanceof _Node2.default) {
          this.selectionObj.nodes[obj.id] = obj;
        } else {
          this.selectionObj.edges[obj.id] = obj;
        }
      }

      /**
       * Add object to the selection array.
       *
       * @param obj
       * @private
       */

    }, {
      key: '_addToHover',
      value: function _addToHover(obj) {
        if (obj instanceof _Node2.default) {
          this.hoverObj.nodes[obj.id] = obj;
        } else {
          this.hoverObj.edges[obj.id] = obj;
        }
      }

      /**
       * Remove a single option from selection.
       *
       * @param {Object} obj
       * @private
       */

    }, {
      key: '_removeFromSelection',
      value: function _removeFromSelection(obj) {
        if (obj instanceof _Node2.default) {
          delete this.selectionObj.nodes[obj.id];
          this._unselectConnectedEdges(obj);
        } else {
          delete this.selectionObj.edges[obj.id];
        }
      }

      /**
       * Unselect all. The selectionObj is useful for this.
       */

    }, {
      key: 'unselectAll',
      value: function unselectAll() {
        for (var nodeId in this.selectionObj.nodes) {
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
            this.selectionObj.nodes[nodeId].unselect();
          }
        }
        for (var edgeId in this.selectionObj.edges) {
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
            this.selectionObj.edges[edgeId].unselect();
          }
        }

        this.selectionObj = { nodes: {}, edges: {} };
      }

      /**
       * return the number of selected nodes
       *
       * @returns {number}
       * @private
       */

    }, {
      key: '_getSelectedNodeCount',
      value: function _getSelectedNodeCount() {
        var count = 0;
        for (var nodeId in this.selectionObj.nodes) {
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
            count += 1;
          }
        }
        return count;
      }

      /**
       * return the selected node
       *
       * @returns {number}
       * @private
       */

    }, {
      key: '_getSelectedNode',
      value: function _getSelectedNode() {
        for (var nodeId in this.selectionObj.nodes) {
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
            return this.selectionObj.nodes[nodeId];
          }
        }
        return undefined;
      }

      /**
       * return the selected edge
       *
       * @returns {number}
       * @private
       */

    }, {
      key: '_getSelectedEdge',
      value: function _getSelectedEdge() {
        for (var edgeId in this.selectionObj.edges) {
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
            return this.selectionObj.edges[edgeId];
          }
        }
        return undefined;
      }

      /**
       * return the number of selected edges
       *
       * @returns {number}
       * @private
       */

    }, {
      key: '_getSelectedEdgeCount',
      value: function _getSelectedEdgeCount() {
        var count = 0;
        for (var edgeId in this.selectionObj.edges) {
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
            count += 1;
          }
        }
        return count;
      }

      /**
       * return the number of selected objects.
       *
       * @returns {number}
       * @private
       */

    }, {
      key: '_getSelectedObjectCount',
      value: function _getSelectedObjectCount() {
        var count = 0;
        for (var nodeId in this.selectionObj.nodes) {
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
            count += 1;
          }
        }
        for (var edgeId in this.selectionObj.edges) {
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
            count += 1;
          }
        }
        return count;
      }

      /**
       * Check if anything is selected
       *
       * @returns {boolean}
       * @private
       */

    }, {
      key: '_selectionIsEmpty',
      value: function _selectionIsEmpty() {
        for (var nodeId in this.selectionObj.nodes) {
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
            return false;
          }
        }
        for (var edgeId in this.selectionObj.edges) {
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
            return false;
          }
        }
        return true;
      }

      /**
       * check if one of the selected nodes is a cluster.
       *
       * @returns {boolean}
       * @private
       */

    }, {
      key: '_clusterInSelection',
      value: function _clusterInSelection() {
        for (var nodeId in this.selectionObj.nodes) {
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
            if (this.selectionObj.nodes[nodeId].clusterSize > 1) {
              return true;
            }
          }
        }
        return false;
      }

      /**
       * select the edges connected to the node that is being selected
       *
       * @param {Node} node
       * @private
       */

    }, {
      key: '_selectConnectedEdges',
      value: function _selectConnectedEdges(node) {
        for (var i = 0; i < node.edges.length; i++) {
          var edge = node.edges[i];
          edge.select();
          this._addToSelection(edge);
        }
      }

      /**
       * select the edges connected to the node that is being selected
       *
       * @param {Node} node
       * @private
       */

    }, {
      key: '_hoverConnectedEdges',
      value: function _hoverConnectedEdges(node) {
        for (var i = 0; i < node.edges.length; i++) {
          var edge = node.edges[i];
          edge.hover = true;
          this._addToHover(edge);
        }
      }

      /**
       * unselect the edges connected to the node that is being selected
       *
       * @param {Node} node
       * @private
       */

    }, {
      key: '_unselectConnectedEdges',
      value: function _unselectConnectedEdges(node) {
        for (var i = 0; i < node.edges.length; i++) {
          var edge = node.edges[i];
          edge.unselect();
          this._removeFromSelection(edge);
        }
      }

      /**
       * This is called when someone clicks on a node. either select or deselect it.
       * If there is an existing selection and we don't want to append to it, clear the existing selection
       *
       * @param {Node || Edge} object
       * @private
       */

    }, {
      key: 'blurObject',
      value: function blurObject(object) {
        if (object.hover === true) {
          object.hover = false;
          if (object instanceof _Node2.default) {
            this.body.emitter.emit("blurNode", { node: object.id });
          } else {
            this.body.emitter.emit("blurEdge", { edge: object.id });
          }
        }
      }

      /**
       * This is called when someone clicks on a node. either select or deselect it.
       * If there is an existing selection and we don't want to append to it, clear the existing selection
       *
       * @param {Node || Edge} object
       * @private
       */

    }, {
      key: 'hoverObject',
      value: function hoverObject(object) {
        var hoverChanged = false;
        // remove all node hover highlights
        for (var nodeId in this.hoverObj.nodes) {
          if (this.hoverObj.nodes.hasOwnProperty(nodeId)) {
            if (object === undefined || object instanceof _Node2.default && object.id != nodeId || object instanceof _Edge2.default) {
              this.blurObject(this.hoverObj.nodes[nodeId]);
              delete this.hoverObj.nodes[nodeId];
              hoverChanged = true;
            }
          }
        }

        // removing all edge hover highlights
        for (var edgeId in this.hoverObj.edges) {
          if (this.hoverObj.edges.hasOwnProperty(edgeId)) {
            // if the hover has been changed here it means that the node has been hovered over or off
            // we then do not use the blurObject method here.
            if (hoverChanged === true) {
              this.hoverObj.edges[edgeId].hover = false;
              delete this.hoverObj.edges[edgeId];
            }
            // if the blur remains the same and the object is undefined (mouse off) or another
            // edge has been hovered, we blur the edge
            else if (object === undefined || object instanceof _Edge2.default) {
                this.blurObject(this.hoverObj.edges[edgeId]);
                delete this.hoverObj.edges[edgeId];
                hoverChanged = true;
              }
          }
        }

        if (object !== undefined) {
          if (object.hover === false) {
            object.hover = true;
            this._addToHover(object);
            hoverChanged = true;
            if (object instanceof _Node2.default) {
              this.body.emitter.emit("hoverNode", { node: object.id });
            } else {
              this.body.emitter.emit("hoverEdge", { edge: object.id });
            }
          }
          if (object instanceof _Node2.default && this.options.hoverConnectedEdges === true) {
            this._hoverConnectedEdges(object);
          }
        }

        if (hoverChanged === true) {
          this.body.emitter.emit('_requestRedraw');
        }
      }

      /**
       *
       * retrieve the currently selected objects
       * @return {{nodes: Array.<String>, edges: Array.<String>}} selection
       */

    }, {
      key: 'getSelection',
      value: function getSelection() {
        var nodeIds = this.getSelectedNodes();
        var edgeIds = this.getSelectedEdges();
        return { nodes: nodeIds, edges: edgeIds };
      }

      /**
       *
       * retrieve the currently selected nodes
       * @return {String[]} selection    An array with the ids of the
       *                                            selected nodes.
       */

    }, {
      key: 'getSelectedNodes',
      value: function getSelectedNodes() {
        var idArray = [];
        if (this.options.selectable === true) {
          for (var nodeId in this.selectionObj.nodes) {
            if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
              idArray.push(this.selectionObj.nodes[nodeId].id);
            }
          }
        }
        return idArray;
      }

      /**
       *
       * retrieve the currently selected edges
       * @return {Array} selection    An array with the ids of the
       *                                            selected nodes.
       */

    }, {
      key: 'getSelectedEdges',
      value: function getSelectedEdges() {
        var idArray = [];
        if (this.options.selectable === true) {
          for (var edgeId in this.selectionObj.edges) {
            if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
              idArray.push(this.selectionObj.edges[edgeId].id);
            }
          }
        }
        return idArray;
      }

      /**
       * Updates the current selection
       * @param {{nodes: Array.<String>, edges: Array.<String>}} Selection
       * @param {Object} options                                 Options
       */

    }, {
      key: 'setSelection',
      value: function setSelection(selection) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var i = void 0,
            id = void 0;

        if (!selection || !selection.nodes && !selection.edges) throw 'Selection must be an object with nodes and/or edges properties';
        // first unselect any selected node, if option is true or undefined
        if (options.unselectAll || options.unselectAll === undefined) {
          this.unselectAll();
        }
        if (selection.nodes) {
          for (i = 0; i < selection.nodes.length; i++) {
            id = selection.nodes[i];

            var node = this.body.nodes[id];
            if (!node) {
              throw new RangeError('Node with id "' + id + '" not found');
            }
            // don't select edges with it
            this.selectObject(node, options.highlightEdges);
          }
        }

        if (selection.edges) {
          for (i = 0; i < selection.edges.length; i++) {
            id = selection.edges[i];

            var edge = this.body.edges[id];
            if (!edge) {
              throw new RangeError('Edge with id "' + id + '" not found');
            }
            this.selectObject(edge);
          }
        }
        this.body.emitter.emit('_requestRedraw');
      }

      /**
       * select zero or more nodes with the option to highlight edges
       * @param {Number[] | String[]} selection     An array with the ids of the
       *                                            selected nodes.
       * @param {boolean} [highlightEdges]
       */

    }, {
      key: 'selectNodes',
      value: function selectNodes(selection) {
        var highlightEdges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        if (!selection || selection.length === undefined) throw 'Selection must be an array with ids';

        this.setSelection({ nodes: selection }, { highlightEdges: highlightEdges });
      }

      /**
       * select zero or more edges
       * @param {Number[] | String[]} selection     An array with the ids of the
       *                                            selected nodes.
       */

    }, {
      key: 'selectEdges',
      value: function selectEdges(selection) {
        if (!selection || selection.length === undefined) throw 'Selection must be an array with ids';

        this.setSelection({ edges: selection });
      }

      /**
       * Validate the selection: remove ids of nodes which no longer exist
       * @private
       */

    }, {
      key: 'updateSelection',
      value: function updateSelection() {
        for (var nodeId in this.selectionObj.nodes) {
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
            if (!this.body.nodes.hasOwnProperty(nodeId)) {
              delete this.selectionObj.nodes[nodeId];
            }
          }
        }
        for (var edgeId in this.selectionObj.edges) {
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
            if (!this.body.edges.hasOwnProperty(edgeId)) {
              delete this.selectionObj.edges[edgeId];
            }
          }
        }
      }
    }]);

    return SelectionHandler;
  }();

  exports.default = SelectionHandler;

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NetworkUtil = __webpack_require__(105);

  var _NetworkUtil2 = _interopRequireDefault(_NetworkUtil);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var LayoutEngine = function () {
    function LayoutEngine(body) {
      _classCallCheck(this, LayoutEngine);

      this.body = body;

      this.initialRandomSeed = Math.round(Math.random() * 1000000);
      this.randomSeed = this.initialRandomSeed;
      this.setPhysics = false;
      this.options = {};
      this.optionsBackup = { physics: {} };

      this.defaultOptions = {
        randomSeed: undefined,
        improvedLayout: true,
        hierarchical: {
          enabled: false,
          levelSeparation: 150,
          nodeSpacing: 100,
          treeSpacing: 200,
          blockShifting: true,
          edgeMinimization: true,
          parentCentralization: true,
          direction: 'UD', // UD, DU, LR, RL
          sortMethod: 'hubsize' // hubsize, directed
        }
      };
      util.extend(this.options, this.defaultOptions);
      this.bindEventListeners();
    }

    _createClass(LayoutEngine, [{
      key: 'bindEventListeners',
      value: function bindEventListeners() {
        var _this = this;

        this.body.emitter.on('_dataChanged', function () {
          _this.setupHierarchicalLayout();
        });
        this.body.emitter.on('_dataLoaded', function () {
          _this.layoutNetwork();
        });
        this.body.emitter.on('_resetHierarchicalLayout', function () {
          _this.setupHierarchicalLayout();
        });
      }
    }, {
      key: 'setOptions',
      value: function setOptions(options, allOptions) {
        if (options !== undefined) {
          var prevHierarchicalState = this.options.hierarchical.enabled;
          util.selectiveDeepExtend(["randomSeed", "improvedLayout"], this.options, options);
          util.mergeOptions(this.options, options, 'hierarchical');
          if (options.randomSeed !== undefined) {
            this.initialRandomSeed = options.randomSeed;
          }

          if (this.options.hierarchical.enabled === true) {
            if (prevHierarchicalState === true) {
              // refresh the overridden options for nodes and edges.
              this.body.emitter.emit('refresh', true);
            }

            // make sure the level separation is the right way up
            if (this.options.hierarchical.direction === 'RL' || this.options.hierarchical.direction === 'DU') {
              if (this.options.hierarchical.levelSeparation > 0) {
                this.options.hierarchical.levelSeparation *= -1;
              }
            } else {
              if (this.options.hierarchical.levelSeparation < 0) {
                this.options.hierarchical.levelSeparation *= -1;
              }
            }

            this.body.emitter.emit('_resetHierarchicalLayout');
            // because the hierarchical system needs it's own physics and smooth curve settings, we adapt the other options if needed.
            return this.adaptAllOptionsForHierarchicalLayout(allOptions);
          } else {
            if (prevHierarchicalState === true) {
              // refresh the overridden options for nodes and edges.
              this.body.emitter.emit('refresh');
              return util.deepExtend(allOptions, this.optionsBackup);
            }
          }
        }
        return allOptions;
      }
    }, {
      key: 'adaptAllOptionsForHierarchicalLayout',
      value: function adaptAllOptionsForHierarchicalLayout(allOptions) {
        if (this.options.hierarchical.enabled === true) {
          // set the physics
          if (allOptions.physics === undefined || allOptions.physics === true) {
            allOptions.physics = {
              enabled: this.optionsBackup.physics.enabled === undefined ? true : this.optionsBackup.physics.enabled,
              solver: 'hierarchicalRepulsion'
            };
            this.optionsBackup.physics.enabled = this.optionsBackup.physics.enabled === undefined ? true : this.optionsBackup.physics.enabled;
            this.optionsBackup.physics.solver = this.optionsBackup.physics.solver || 'barnesHut';
          } else if (_typeof(allOptions.physics) === 'object') {
            this.optionsBackup.physics.enabled = allOptions.physics.enabled === undefined ? true : allOptions.physics.enabled;
            this.optionsBackup.physics.solver = allOptions.physics.solver || 'barnesHut';
            allOptions.physics.solver = 'hierarchicalRepulsion';
          } else if (allOptions.physics !== false) {
            this.optionsBackup.physics.solver = 'barnesHut';
            allOptions.physics = { solver: 'hierarchicalRepulsion' };
          }

          // get the type of static smooth curve in case it is required
          var type = 'horizontal';
          if (this.options.hierarchical.direction === 'RL' || this.options.hierarchical.direction === 'LR') {
            type = 'vertical';
          }

          // disable smooth curves if nothing is defined. If smooth curves have been turned on, turn them into static smooth curves.
          if (allOptions.edges === undefined) {
            this.optionsBackup.edges = { smooth: { enabled: true, type: 'dynamic' } };
            allOptions.edges = { smooth: false };
          } else if (allOptions.edges.smooth === undefined) {
            this.optionsBackup.edges = { smooth: { enabled: true, type: 'dynamic' } };
            allOptions.edges.smooth = false;
          } else {
            if (typeof allOptions.edges.smooth === 'boolean') {
              this.optionsBackup.edges = { smooth: allOptions.edges.smooth };
              allOptions.edges.smooth = { enabled: allOptions.edges.smooth, type: type };
            } else {
              // allow custom types except for dynamic
              if (allOptions.edges.smooth.type !== undefined && allOptions.edges.smooth.type !== 'dynamic') {
                type = allOptions.edges.smooth.type;
              }

              this.optionsBackup.edges = {
                smooth: allOptions.edges.smooth.enabled === undefined ? true : allOptions.edges.smooth.enabled,
                type: allOptions.edges.smooth.type === undefined ? 'dynamic' : allOptions.edges.smooth.type,
                roundness: allOptions.edges.smooth.roundness === undefined ? 0.5 : allOptions.edges.smooth.roundness,
                forceDirection: allOptions.edges.smooth.forceDirection === undefined ? false : allOptions.edges.smooth.forceDirection
              };
              allOptions.edges.smooth = {
                enabled: allOptions.edges.smooth.enabled === undefined ? true : allOptions.edges.smooth.enabled,
                type: type,
                roundness: allOptions.edges.smooth.roundness === undefined ? 0.5 : allOptions.edges.smooth.roundness,
                forceDirection: allOptions.edges.smooth.forceDirection === undefined ? false : allOptions.edges.smooth.forceDirection
              };
            }
          }

          // force all edges into static smooth curves. Only applies to edges that do not use the global options for smooth.
          this.body.emitter.emit('_forceDisableDynamicCurves', type);
        }

        return allOptions;
      }
    }, {
      key: 'seededRandom',
      value: function seededRandom() {
        var x = Math.sin(this.randomSeed++) * 10000;
        return x - Math.floor(x);
      }
    }, {
      key: 'positionInitially',
      value: function positionInitially(nodesArray) {
        if (this.options.hierarchical.enabled !== true) {
          this.randomSeed = this.initialRandomSeed;
          for (var i = 0; i < nodesArray.length; i++) {
            var node = nodesArray[i];
            var radius = 10 * 0.1 * nodesArray.length + 10;
            var angle = 2 * Math.PI * this.seededRandom();
            if (node.x === undefined) {
              node.x = radius * Math.cos(angle);
            }
            if (node.y === undefined) {
              node.y = radius * Math.sin(angle);
            }
          }
        }
      }

      /**
       * Use Kamada Kawai to position nodes. This is quite a heavy algorithm so if there are a lot of nodes we
       * cluster them first to reduce the amount.
       */

    }, {
      key: 'layoutNetwork',
      value: function layoutNetwork() {
        if (this.options.hierarchical.enabled !== true && this.options.improvedLayout === true) {
          // first check if we should Kamada Kawai to layout. The threshold is if less than half of the visible
          // nodes have predefined positions we use this.
          var positionDefined = 0;
          for (var i = 0; i < this.body.nodeIndices.length; i++) {
            var node = this.body.nodes[this.body.nodeIndices[i]];
            if (node.predefinedPosition === true) {
              positionDefined += 1;
            }
          }

          // if less than half of the nodes have a predefined position we continue
          if (positionDefined < 0.5 * this.body.nodeIndices.length) {
            var MAX_LEVELS = 10;
            var level = 0;
            var clusterThreshold = 100;
            // if there are a lot of nodes, we cluster before we run the algorithm.
            if (this.body.nodeIndices.length > clusterThreshold) {
              var startLength = this.body.nodeIndices.length;
              while (this.body.nodeIndices.length > clusterThreshold) {
                //console.time("clustering")
                level += 1;
                var before = this.body.nodeIndices.length;
                // if there are many nodes we do a hubsize cluster
                if (level % 3 === 0) {
                  this.body.modules.clustering.clusterBridges();
                } else {
                  this.body.modules.clustering.clusterOutliers();
                }
                var after = this.body.nodeIndices.length;
                if (before == after && level % 3 !== 0 || level > MAX_LEVELS) {
                  this._declusterAll();
                  this.body.emitter.emit("_layoutFailed");
                  console.info("This network could not be positioned by this version of the improved layout algorithm. Please disable improvedLayout for better performance.");
                  return;
                }
                //console.timeEnd("clustering")
                //console.log(level,after)
              }
              // increase the size of the edges
              this.body.modules.kamadaKawai.setOptions({ springLength: Math.max(150, 2 * startLength) });
            }

            // position the system for these nodes and edges
            this.body.modules.kamadaKawai.solve(this.body.nodeIndices, this.body.edgeIndices, true);

            // shift to center point
            this._shiftToCenter();

            // perturb the nodes a little bit to force the physics to kick in
            var offset = 70;
            for (var _i = 0; _i < this.body.nodeIndices.length; _i++) {
              // Only perturb the nodes that aren't fixed
              if (this.body.nodes[this.body.nodeIndices[_i]].predefinedPosition === false) {
                this.body.nodes[this.body.nodeIndices[_i]].x += (0.5 - this.seededRandom()) * offset;
                this.body.nodes[this.body.nodeIndices[_i]].y += (0.5 - this.seededRandom()) * offset;
              }
            }

            // uncluster all clusters
            this._declusterAll();

            // reposition all bezier nodes.
            this.body.emitter.emit("_repositionBezierNodes");
          }
        }
      }

      /**
       * Move all the nodes towards to the center so gravitational pull wil not move the nodes away from view
       * @private
       */

    }, {
      key: '_shiftToCenter',
      value: function _shiftToCenter() {
        var range = _NetworkUtil2.default.getRangeCore(this.body.nodes, this.body.nodeIndices);
        var center = _NetworkUtil2.default.findCenter(range);
        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          this.body.nodes[this.body.nodeIndices[i]].x -= center.x;
          this.body.nodes[this.body.nodeIndices[i]].y -= center.y;
        }
      }
    }, {
      key: '_declusterAll',
      value: function _declusterAll() {
        var clustersPresent = true;
        while (clustersPresent === true) {
          clustersPresent = false;
          for (var i = 0; i < this.body.nodeIndices.length; i++) {
            if (this.body.nodes[this.body.nodeIndices[i]].isCluster === true) {
              clustersPresent = true;
              this.body.modules.clustering.openCluster(this.body.nodeIndices[i], {}, false);
            }
          }
          if (clustersPresent === true) {
            this.body.emitter.emit('_dataChanged');
          }
        }
      }
    }, {
      key: 'getSeed',
      value: function getSeed() {
        return this.initialRandomSeed;
      }

      /**
       * This is the main function to layout the nodes in a hierarchical way.
       * It checks if the node details are supplied correctly
       *
       * @private
       */

    }, {
      key: 'setupHierarchicalLayout',
      value: function setupHierarchicalLayout() {
        if (this.options.hierarchical.enabled === true && this.body.nodeIndices.length > 0) {
          // get the size of the largest hubs and check if the user has defined a level for a node.
          var node = void 0,
              nodeId = void 0;
          var definedLevel = false;
          var definedPositions = true;
          var undefinedLevel = false;
          this.hierarchicalLevels = {};
          this.lastNodeOnLevel = {};
          this.hierarchicalChildrenReference = {};
          this.hierarchicalParentReference = {};
          this.hierarchicalTrees = {};
          this.treeIndex = -1;

          this.distributionOrdering = {};
          this.distributionIndex = {};
          this.distributionOrderingPresence = {};

          for (nodeId in this.body.nodes) {
            if (this.body.nodes.hasOwnProperty(nodeId)) {
              node = this.body.nodes[nodeId];
              if (node.options.x === undefined && node.options.y === undefined) {
                definedPositions = false;
              }
              if (node.options.level !== undefined) {
                definedLevel = true;
                this.hierarchicalLevels[nodeId] = node.options.level;
              } else {
                undefinedLevel = true;
              }
            }
          }

          // if the user defined some levels but not all, alert and run without hierarchical layout
          if (undefinedLevel === true && definedLevel === true) {
            throw new Error('To use the hierarchical layout, nodes require either no predefined levels or levels have to be defined for all nodes.');
            return;
          } else {
            // define levels if undefined by the users. Based on hubsize.
            if (undefinedLevel === true) {
              if (this.options.hierarchical.sortMethod === 'hubsize') {
                this._determineLevelsByHubsize();
              } else if (this.options.hierarchical.sortMethod === 'directed') {
                this._determineLevelsDirected();
              } else if (this.options.hierarchical.sortMethod === 'custom') {
                this._determineLevelsCustomCallback();
              }
            }

            // fallback for cases where there are nodes but no edges
            for (var _nodeId in this.body.nodes) {
              if (this.body.nodes.hasOwnProperty(_nodeId)) {
                if (this.hierarchicalLevels[_nodeId] === undefined) {
                  this.hierarchicalLevels[_nodeId] = 0;
                }
              }
            }
            // check the distribution of the nodes per level.
            var distribution = this._getDistribution();

            // get the parent children relations.
            this._generateMap();

            // place the nodes on the canvas.
            this._placeNodesByHierarchy(distribution);

            // condense the whitespace.
            this._condenseHierarchy();

            // shift to center so gravity does not have to do much
            this._shiftToCenter();
          }
        }
      }

      /**
       * @private
       */

    }, {
      key: '_condenseHierarchy',
      value: function _condenseHierarchy() {
        var _this2 = this;

        // Global var in this scope to define when the movement has stopped.
        var stillShifting = false;
        var branches = {};
        // first we have some methods to help shifting trees around.
        // the main method to shift the trees
        var shiftTrees = function shiftTrees() {
          var treeSizes = getTreeSizes();
          for (var i = 0; i < treeSizes.length - 1; i++) {
            var diff = treeSizes[i].max - treeSizes[i + 1].min;
            shiftTree(i + 1, diff + _this2.options.hierarchical.treeSpacing);
          }
        };

        // shift a single tree by an offset
        var shiftTree = function shiftTree(index, offset) {
          for (var nodeId in _this2.hierarchicalTrees) {
            if (_this2.hierarchicalTrees.hasOwnProperty(nodeId)) {
              if (_this2.hierarchicalTrees[nodeId] === index) {
                var node = _this2.body.nodes[nodeId];
                var pos = _this2._getPositionForHierarchy(node);
                _this2._setPositionForHierarchy(node, pos + offset, undefined, true);
              }
            }
          }
        };

        // get the width of a tree
        var getTreeSize = function getTreeSize(index) {
          var min = 1e9;
          var max = -1e9;
          for (var nodeId in _this2.hierarchicalTrees) {
            if (_this2.hierarchicalTrees.hasOwnProperty(nodeId)) {
              if (_this2.hierarchicalTrees[nodeId] === index) {
                var pos = _this2._getPositionForHierarchy(_this2.body.nodes[nodeId]);
                min = Math.min(pos, min);
                max = Math.max(pos, max);
              }
            }
          }
          return { min: min, max: max };
        };

        // get the width of all trees
        var getTreeSizes = function getTreeSizes() {
          var treeWidths = [];
          for (var i = 0; i <= _this2.treeIndex; i++) {
            treeWidths.push(getTreeSize(i));
          }
          return treeWidths;
        };

        // get a map of all nodes in this branch
        var getBranchNodes = function getBranchNodes(source, map) {
          map[source.id] = true;
          if (_this2.hierarchicalChildrenReference[source.id]) {
            var children = _this2.hierarchicalChildrenReference[source.id];
            if (children.length > 0) {
              for (var i = 0; i < children.length; i++) {
                getBranchNodes(_this2.body.nodes[children[i]], map);
              }
            }
          }
        };

        // get a min max width as well as the maximum movement space it has on either sides
        // we use min max terminology because width and height can interchange depending on the direction of the layout
        var getBranchBoundary = function getBranchBoundary(branchMap) {
          var maxLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e9;

          var minSpace = 1e9;
          var maxSpace = 1e9;
          var min = 1e9;
          var max = -1e9;
          for (var branchNode in branchMap) {
            if (branchMap.hasOwnProperty(branchNode)) {
              var node = _this2.body.nodes[branchNode];
              var level = _this2.hierarchicalLevels[node.id];
              var position = _this2._getPositionForHierarchy(node);

              // get the space around the node.

              var _getSpaceAroundNode2 = _this2._getSpaceAroundNode(node, branchMap),
                  _getSpaceAroundNode3 = _slicedToArray(_getSpaceAroundNode2, 2),
                  minSpaceNode = _getSpaceAroundNode3[0],
                  maxSpaceNode = _getSpaceAroundNode3[1];

              minSpace = Math.min(minSpaceNode, minSpace);
              maxSpace = Math.min(maxSpaceNode, maxSpace);

              // the width is only relevant for the levels two nodes have in common. This is why we filter on this.
              if (level <= maxLevel) {
                min = Math.min(position, min);
                max = Math.max(position, max);
              }
            }
          }

          return [min, max, minSpace, maxSpace];
        };

        // get the maximum level of a branch.
        var getMaxLevel = function getMaxLevel(nodeId) {
          var level = _this2.hierarchicalLevels[nodeId];
          if (_this2.hierarchicalChildrenReference[nodeId]) {
            var children = _this2.hierarchicalChildrenReference[nodeId];
            if (children.length > 0) {
              for (var i = 0; i < children.length; i++) {
                level = Math.max(level, getMaxLevel(children[i]));
              }
            }
          }
          return level;
        };

        // check what the maximum level is these nodes have in common.
        var getCollisionLevel = function getCollisionLevel(node1, node2) {
          var maxLevel1 = getMaxLevel(node1.id);
          var maxLevel2 = getMaxLevel(node2.id);
          return Math.min(maxLevel1, maxLevel2);
        };

        // check if two nodes have the same parent(s)
        var hasSameParent = function hasSameParent(node1, node2) {
          var parents1 = _this2.hierarchicalParentReference[node1.id];
          var parents2 = _this2.hierarchicalParentReference[node2.id];
          if (parents1 === undefined || parents2 === undefined) {
            return false;
          }

          for (var i = 0; i < parents1.length; i++) {
            for (var j = 0; j < parents2.length; j++) {
              if (parents1[i] == parents2[j]) {
                return true;
              }
            }
          }
          return false;
        };

        // condense elements. These can be nodes or branches depending on the callback.
        var shiftElementsCloser = function shiftElementsCloser(callback, levels, centerParents) {
          for (var i = 0; i < levels.length; i++) {
            var level = levels[i];
            var levelNodes = _this2.distributionOrdering[level];
            if (levelNodes.length > 1) {
              for (var j = 0; j < levelNodes.length - 1; j++) {
                if (hasSameParent(levelNodes[j], levelNodes[j + 1]) === true) {
                  if (_this2.hierarchicalTrees[levelNodes[j].id] === _this2.hierarchicalTrees[levelNodes[j + 1].id]) {
                    callback(levelNodes[j], levelNodes[j + 1], centerParents);
                  }
                }
              }
            }
          }
        };

        // callback for shifting branches
        var branchShiftCallback = function branchShiftCallback(node1, node2) {
          var centerParent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          //window.CALLBACKS.push(() => {
          var pos1 = _this2._getPositionForHierarchy(node1);
          var pos2 = _this2._getPositionForHierarchy(node2);
          var diffAbs = Math.abs(pos2 - pos1);
          //console.log("NOW CHEcKING:", node1.id, node2.id, diffAbs);
          if (diffAbs > _this2.options.hierarchical.nodeSpacing) {
            var branchNodes1 = {};branchNodes1[node1.id] = true;
            var branchNodes2 = {};branchNodes2[node2.id] = true;

            getBranchNodes(node1, branchNodes1);
            getBranchNodes(node2, branchNodes2);

            // check the largest distance between the branches
            var maxLevel = getCollisionLevel(node1, node2);

            var _getBranchBoundary = getBranchBoundary(branchNodes1, maxLevel),
                _getBranchBoundary2 = _slicedToArray(_getBranchBoundary, 4),
                min1 = _getBranchBoundary2[0],
                max1 = _getBranchBoundary2[1],
                minSpace1 = _getBranchBoundary2[2],
                maxSpace1 = _getBranchBoundary2[3];

            var _getBranchBoundary3 = getBranchBoundary(branchNodes2, maxLevel),
                _getBranchBoundary4 = _slicedToArray(_getBranchBoundary3, 4),
                min2 = _getBranchBoundary4[0],
                max2 = _getBranchBoundary4[1],
                minSpace2 = _getBranchBoundary4[2],
                maxSpace2 = _getBranchBoundary4[3];

            //console.log(node1.id, getBranchBoundary(branchNodes1, maxLevel), node2.id, getBranchBoundary(branchNodes2, maxLevel), maxLevel);


            var diffBranch = Math.abs(max1 - min2);
            if (diffBranch > _this2.options.hierarchical.nodeSpacing) {
              var offset = max1 - min2 + _this2.options.hierarchical.nodeSpacing;
              if (offset < -minSpace2 + _this2.options.hierarchical.nodeSpacing) {
                offset = -minSpace2 + _this2.options.hierarchical.nodeSpacing;
                //console.log("RESETTING OFFSET", max1 - min2 + this.options.hierarchical.nodeSpacing, -minSpace2, offset);
              }
              if (offset < 0) {
                //console.log("SHIFTING", node2.id, offset);
                _this2._shiftBlock(node2.id, offset);
                stillShifting = true;

                if (centerParent === true) _this2._centerParent(node2);
              }
            }
          }
          //this.body.emitter.emit("_redraw");})
        };

        var minimizeEdgeLength = function minimizeEdgeLength(iterations, node) {
          //window.CALLBACKS.push(() => {
          //  console.log("ts",node.id);
          var nodeId = node.id;
          var allEdges = node.edges;
          var nodeLevel = _this2.hierarchicalLevels[node.id];

          // gather constants
          var C2 = _this2.options.hierarchical.levelSeparation * _this2.options.hierarchical.levelSeparation;
          var referenceNodes = {};
          var aboveEdges = [];
          for (var i = 0; i < allEdges.length; i++) {
            var edge = allEdges[i];
            if (edge.toId != edge.fromId) {
              var otherNode = edge.toId == nodeId ? edge.from : edge.to;
              referenceNodes[allEdges[i].id] = otherNode;
              if (_this2.hierarchicalLevels[otherNode.id] < nodeLevel) {
                aboveEdges.push(edge);
              }
            }
          }

          // differentiated sum of lengths based on only moving one node over one axis
          var getFx = function getFx(point, edges) {
            var sum = 0;
            for (var _i2 = 0; _i2 < edges.length; _i2++) {
              if (referenceNodes[edges[_i2].id] !== undefined) {
                var a = _this2._getPositionForHierarchy(referenceNodes[edges[_i2].id]) - point;
                sum += a / Math.sqrt(a * a + C2);
              }
            }
            return sum;
          };

          // doubly differentiated sum of lengths based on only moving one node over one axis
          var getDFx = function getDFx(point, edges) {
            var sum = 0;
            for (var _i3 = 0; _i3 < edges.length; _i3++) {
              if (referenceNodes[edges[_i3].id] !== undefined) {
                var a = _this2._getPositionForHierarchy(referenceNodes[edges[_i3].id]) - point;
                sum -= C2 * Math.pow(a * a + C2, -1.5);
              }
            }
            return sum;
          };

          var getGuess = function getGuess(iterations, edges) {
            var guess = _this2._getPositionForHierarchy(node);
            // Newton's method for optimization
            var guessMap = {};
            for (var _i4 = 0; _i4 < iterations; _i4++) {
              var fx = getFx(guess, edges);
              var dfx = getDFx(guess, edges);

              // we limit the movement to avoid instability.
              var limit = 40;
              var ratio = Math.max(-limit, Math.min(limit, Math.round(fx / dfx)));
              guess = guess - ratio;
              // reduce duplicates
              if (guessMap[guess] !== undefined) {
                break;
              }
              guessMap[guess] = _i4;
            }
            return guess;
          };

          var moveBranch = function moveBranch(guess) {
            // position node if there is space
            var nodePosition = _this2._getPositionForHierarchy(node);

            // check movable area of the branch
            if (branches[node.id] === undefined) {
              var branchNodes = {};
              branchNodes[node.id] = true;
              getBranchNodes(node, branchNodes);
              branches[node.id] = branchNodes;
            }

            var _getBranchBoundary5 = getBranchBoundary(branches[node.id]),
                _getBranchBoundary6 = _slicedToArray(_getBranchBoundary5, 4),
                minBranch = _getBranchBoundary6[0],
                maxBranch = _getBranchBoundary6[1],
                minSpaceBranch = _getBranchBoundary6[2],
                maxSpaceBranch = _getBranchBoundary6[3];

            var diff = guess - nodePosition;

            // check if we are allowed to move the node:
            var branchOffset = 0;
            if (diff > 0) {
              branchOffset = Math.min(diff, maxSpaceBranch - _this2.options.hierarchical.nodeSpacing);
            } else if (diff < 0) {
              branchOffset = -Math.min(-diff, minSpaceBranch - _this2.options.hierarchical.nodeSpacing);
            }

            if (branchOffset != 0) {
              //console.log("moving branch:",branchOffset, maxSpaceBranch, minSpaceBranch)
              _this2._shiftBlock(node.id, branchOffset);
              //this.body.emitter.emit("_redraw");
              stillShifting = true;
            }
          };

          var moveNode = function moveNode(guess) {
            var nodePosition = _this2._getPositionForHierarchy(node);

            // position node if there is space

            var _getSpaceAroundNode4 = _this2._getSpaceAroundNode(node),
                _getSpaceAroundNode5 = _slicedToArray(_getSpaceAroundNode4, 2),
                minSpace = _getSpaceAroundNode5[0],
                maxSpace = _getSpaceAroundNode5[1];

            var diff = guess - nodePosition;
            // check if we are allowed to move the node:
            var newPosition = nodePosition;
            if (diff > 0) {
              newPosition = Math.min(nodePosition + (maxSpace - _this2.options.hierarchical.nodeSpacing), guess);
            } else if (diff < 0) {
              newPosition = Math.max(nodePosition - (minSpace - _this2.options.hierarchical.nodeSpacing), guess);
            }

            if (newPosition !== nodePosition) {
              //console.log("moving Node:",diff, minSpace, maxSpace);
              _this2._setPositionForHierarchy(node, newPosition, undefined, true);
              //this.body.emitter.emit("_redraw");
              stillShifting = true;
            }
          };

          var guess = getGuess(iterations, aboveEdges);
          moveBranch(guess);
          guess = getGuess(iterations, allEdges);
          moveNode(guess);
          //})
        };

        // method to remove whitespace between branches. Because we do bottom up, we can center the parents.
        var minimizeEdgeLengthBottomUp = function minimizeEdgeLengthBottomUp(iterations) {
          var levels = Object.keys(_this2.distributionOrdering);
          levels = levels.reverse();
          for (var i = 0; i < iterations; i++) {
            stillShifting = false;
            for (var j = 0; j < levels.length; j++) {
              var level = levels[j];
              var levelNodes = _this2.distributionOrdering[level];
              for (var k = 0; k < levelNodes.length; k++) {
                minimizeEdgeLength(1000, levelNodes[k]);
              }
            }
            if (stillShifting !== true) {
              //console.log("FINISHED minimizeEdgeLengthBottomUp IN " + i);
              break;
            }
          }
        };

        // method to remove whitespace between branches. Because we do bottom up, we can center the parents.
        var shiftBranchesCloserBottomUp = function shiftBranchesCloserBottomUp(iterations) {
          var levels = Object.keys(_this2.distributionOrdering);
          levels = levels.reverse();
          for (var i = 0; i < iterations; i++) {
            stillShifting = false;
            shiftElementsCloser(branchShiftCallback, levels, true);
            if (stillShifting !== true) {
              //console.log("FINISHED shiftBranchesCloserBottomUp IN " + (i+1));
              break;
            }
          }
        };

        // center all parents
        var centerAllParents = function centerAllParents() {
          for (var nodeId in _this2.body.nodes) {
            if (_this2.body.nodes.hasOwnProperty(nodeId)) _this2._centerParent(_this2.body.nodes[nodeId]);
          }
        };

        // center all parents
        var centerAllParentsBottomUp = function centerAllParentsBottomUp() {
          var levels = Object.keys(_this2.distributionOrdering);
          levels = levels.reverse();
          for (var i = 0; i < levels.length; i++) {
            var level = levels[i];
            var levelNodes = _this2.distributionOrdering[level];
            for (var j = 0; j < levelNodes.length; j++) {
              _this2._centerParent(levelNodes[j]);
            }
          }
        };

        // the actual work is done here.
        if (this.options.hierarchical.blockShifting === true) {
          shiftBranchesCloserBottomUp(5);
          centerAllParents();
        }

        // minimize edge length
        if (this.options.hierarchical.edgeMinimization === true) {
          minimizeEdgeLengthBottomUp(20);
        }

        if (this.options.hierarchical.parentCentralization === true) {
          centerAllParentsBottomUp();
        }

        shiftTrees();
      }

      /**
       * This gives the space around the node. IF a map is supplied, it will only check against nodes NOT in the map.
       * This is used to only get the distances to nodes outside of a branch.
       * @param node
       * @param map
       * @returns {*[]}
       * @private
       */

    }, {
      key: '_getSpaceAroundNode',
      value: function _getSpaceAroundNode(node, map) {
        var useMap = true;
        if (map === undefined) {
          useMap = false;
        }
        var level = this.hierarchicalLevels[node.id];
        if (level !== undefined) {
          var index = this.distributionIndex[node.id];
          var position = this._getPositionForHierarchy(node);
          var minSpace = 1e9;
          var maxSpace = 1e9;
          if (index !== 0) {
            var prevNode = this.distributionOrdering[level][index - 1];
            if (useMap === true && map[prevNode.id] === undefined || useMap === false) {
              var prevPos = this._getPositionForHierarchy(prevNode);
              minSpace = position - prevPos;
            }
          }

          if (index != this.distributionOrdering[level].length - 1) {
            var nextNode = this.distributionOrdering[level][index + 1];
            if (useMap === true && map[nextNode.id] === undefined || useMap === false) {
              var nextPos = this._getPositionForHierarchy(nextNode);
              maxSpace = Math.min(maxSpace, nextPos - position);
            }
          }

          return [minSpace, maxSpace];
        } else {
          return [0, 0];
        }
      }

      /**
       * We use this method to center a parent node and check if it does not cross other nodes when it does.
       * @param node
       * @private
       */

    }, {
      key: '_centerParent',
      value: function _centerParent(node) {
        if (this.hierarchicalParentReference[node.id]) {
          var parents = this.hierarchicalParentReference[node.id];
          for (var i = 0; i < parents.length; i++) {
            var parentId = parents[i];
            var parentNode = this.body.nodes[parentId];
            if (this.hierarchicalChildrenReference[parentId]) {
              // get the range of the children
              var minPos = 1e9;
              var maxPos = -1e9;
              var children = this.hierarchicalChildrenReference[parentId];
              if (children.length > 0) {
                for (var _i5 = 0; _i5 < children.length; _i5++) {
                  var childNode = this.body.nodes[children[_i5]];
                  minPos = Math.min(minPos, this._getPositionForHierarchy(childNode));
                  maxPos = Math.max(maxPos, this._getPositionForHierarchy(childNode));
                }
              }

              var position = this._getPositionForHierarchy(parentNode);

              var _getSpaceAroundNode6 = this._getSpaceAroundNode(parentNode),
                  _getSpaceAroundNode7 = _slicedToArray(_getSpaceAroundNode6, 2),
                  minSpace = _getSpaceAroundNode7[0],
                  maxSpace = _getSpaceAroundNode7[1];

              var newPosition = 0.5 * (minPos + maxPos);
              var diff = position - newPosition;
              if (diff < 0 && Math.abs(diff) < maxSpace - this.options.hierarchical.nodeSpacing || diff > 0 && Math.abs(diff) < minSpace - this.options.hierarchical.nodeSpacing) {
                this._setPositionForHierarchy(parentNode, newPosition, undefined, true);
              }
            }
          }
        }
      }

      /**
       * This function places the nodes on the canvas based on the hierarchial distribution.
       *
       * @param {Object} distribution | obtained by the function this._getDistribution()
       * @private
       */

    }, {
      key: '_placeNodesByHierarchy',
      value: function _placeNodesByHierarchy(distribution) {
        this.positionedNodes = {};
        // start placing all the level 0 nodes first. Then recursively position their branches.
        for (var level in distribution) {
          if (distribution.hasOwnProperty(level)) {
            // sort nodes in level by position:
            var nodeArray = Object.keys(distribution[level]);
            nodeArray = this._indexArrayToNodes(nodeArray);
            this._sortNodeArray(nodeArray);
            var handledNodeCount = 0;

            for (var i = 0; i < nodeArray.length; i++) {
              var node = nodeArray[i];
              if (this.positionedNodes[node.id] === undefined) {
                var pos = this.options.hierarchical.nodeSpacing * handledNodeCount;
                // we get the X or Y values we need and store them in pos and previousPos. The get and set make sure we get X or Y
                if (handledNodeCount > 0) {
                  pos = this._getPositionForHierarchy(nodeArray[i - 1]) + this.options.hierarchical.nodeSpacing;
                }
                this._setPositionForHierarchy(node, pos, level);
                this._validataPositionAndContinue(node, level, pos);

                handledNodeCount++;
              }
            }
          }
        }
      }

      /**
       * This is a recursively called function to enumerate the branches from the largest hubs and place the nodes
       * on a X position that ensures there will be no overlap.
       *
       * @param parentId
       * @param parentLevel
       * @private
       */

    }, {
      key: '_placeBranchNodes',
      value: function _placeBranchNodes(parentId, parentLevel) {
        // if this is not a parent, cancel the placing. This can happen with multiple parents to one child.
        if (this.hierarchicalChildrenReference[parentId] === undefined) {
          return;
        }

        // get a list of childNodes
        var childNodes = [];
        for (var i = 0; i < this.hierarchicalChildrenReference[parentId].length; i++) {
          childNodes.push(this.body.nodes[this.hierarchicalChildrenReference[parentId][i]]);
        }

        // use the positions to order the nodes.
        this._sortNodeArray(childNodes);

        // position the childNodes
        for (var _i6 = 0; _i6 < childNodes.length; _i6++) {
          var childNode = childNodes[_i6];
          var childNodeLevel = this.hierarchicalLevels[childNode.id];
          // check if the child node is below the parent node and if it has already been positioned.
          if (childNodeLevel > parentLevel && this.positionedNodes[childNode.id] === undefined) {
            // get the amount of space required for this node. If parent the width is based on the amount of children.
            var pos = void 0;

            // we get the X or Y values we need and store them in pos and previousPos. The get and set make sure we get X or Y
            if (_i6 === 0) {
              pos = this._getPositionForHierarchy(this.body.nodes[parentId]);
            } else {
              pos = this._getPositionForHierarchy(childNodes[_i6 - 1]) + this.options.hierarchical.nodeSpacing;
            }
            this._setPositionForHierarchy(childNode, pos, childNodeLevel);
            this._validataPositionAndContinue(childNode, childNodeLevel, pos);
          } else {
            return;
          }
        }

        // center the parent nodes.
        var minPos = 1e9;
        var maxPos = -1e9;
        for (var _i7 = 0; _i7 < childNodes.length; _i7++) {
          var childNodeId = childNodes[_i7].id;
          minPos = Math.min(minPos, this._getPositionForHierarchy(this.body.nodes[childNodeId]));
          maxPos = Math.max(maxPos, this._getPositionForHierarchy(this.body.nodes[childNodeId]));
        }
        this._setPositionForHierarchy(this.body.nodes[parentId], 0.5 * (minPos + maxPos), parentLevel);
      }

      /**
       * This method checks for overlap and if required shifts the branch. It also keeps records of positioned nodes.
       * Finally it will call _placeBranchNodes to place the branch nodes.
       * @param node
       * @param level
       * @param pos
       * @private
       */

    }, {
      key: '_validataPositionAndContinue',
      value: function _validataPositionAndContinue(node, level, pos) {
        // if overlap has been detected, we shift the branch
        if (this.lastNodeOnLevel[level] !== undefined) {
          var previousPos = this._getPositionForHierarchy(this.body.nodes[this.lastNodeOnLevel[level]]);
          if (pos - previousPos < this.options.hierarchical.nodeSpacing) {
            var diff = previousPos + this.options.hierarchical.nodeSpacing - pos;
            var sharedParent = this._findCommonParent(this.lastNodeOnLevel[level], node.id);
            this._shiftBlock(sharedParent.withChild, diff);
          }
        }

        // store change in position.
        this.lastNodeOnLevel[level] = node.id;

        this.positionedNodes[node.id] = true;

        this._placeBranchNodes(node.id, level);
      }

      /**
       * Receives an array with node indices and returns an array with the actual node references. Used for sorting based on
       * node properties.
       * @param idArray
       */

    }, {
      key: '_indexArrayToNodes',
      value: function _indexArrayToNodes(idArray) {
        var array = [];
        for (var i = 0; i < idArray.length; i++) {
          array.push(this.body.nodes[idArray[i]]);
        }
        return array;
      }

      /**
       * This function get the distribution of levels based on hubsize
       *
       * @returns {Object}
       * @private
       */

    }, {
      key: '_getDistribution',
      value: function _getDistribution() {
        var distribution = {};
        var nodeId = void 0,
            node = void 0;

        // we fix Y because the hierarchy is vertical, we fix X so we do not give a node an x position for a second time.
        // the fix of X is removed after the x value has been set.
        for (nodeId in this.body.nodes) {
          if (this.body.nodes.hasOwnProperty(nodeId)) {
            node = this.body.nodes[nodeId];
            var level = this.hierarchicalLevels[nodeId] === undefined ? 0 : this.hierarchicalLevels[nodeId];
            if (this.options.hierarchical.direction === 'UD' || this.options.hierarchical.direction === 'DU') {
              node.y = this.options.hierarchical.levelSeparation * level;
              node.options.fixed.y = true;
            } else {
              node.x = this.options.hierarchical.levelSeparation * level;
              node.options.fixed.x = true;
            }
            if (distribution[level] === undefined) {
              distribution[level] = {};
            }
            distribution[level][nodeId] = node;
          }
        }
        return distribution;
      }

      /**
       * Get the hubsize from all remaining unlevelled nodes.
       *
       * @returns {number}
       * @private
       */

    }, {
      key: '_getHubSize',
      value: function _getHubSize() {
        var hubSize = 0;
        for (var nodeId in this.body.nodes) {
          if (this.body.nodes.hasOwnProperty(nodeId)) {
            var node = this.body.nodes[nodeId];
            if (this.hierarchicalLevels[nodeId] === undefined) {
              hubSize = node.edges.length < hubSize ? hubSize : node.edges.length;
            }
          }
        }
        return hubSize;
      }

      /**
       * this function allocates nodes in levels based on the recursive branching from the largest hubs.
       *
       * @param hubsize
       * @private
       */

    }, {
      key: '_determineLevelsByHubsize',
      value: function _determineLevelsByHubsize() {
        var _this3 = this;

        var hubSize = 1;

        var levelDownstream = function levelDownstream(nodeA, nodeB) {
          if (_this3.hierarchicalLevels[nodeB.id] === undefined) {
            // set initial level
            if (_this3.hierarchicalLevels[nodeA.id] === undefined) {
              _this3.hierarchicalLevels[nodeA.id] = 0;
            }
            // set level
            _this3.hierarchicalLevels[nodeB.id] = _this3.hierarchicalLevels[nodeA.id] + 1;
          }
        };

        while (hubSize > 0) {
          // determine hubs
          hubSize = this._getHubSize();
          if (hubSize === 0) break;

          for (var nodeId in this.body.nodes) {
            if (this.body.nodes.hasOwnProperty(nodeId)) {
              var node = this.body.nodes[nodeId];
              if (node.edges.length === hubSize) {
                this._crawlNetwork(levelDownstream, nodeId);
              }
            }
          }
        }
      }

      /**
       * TODO: release feature
       * @private
       */

    }, {
      key: '_determineLevelsCustomCallback',
      value: function _determineLevelsCustomCallback() {
        var _this4 = this;

        var minLevel = 100000;

        // TODO: this should come from options.
        var customCallback = function customCallback(nodeA, nodeB, edge) {};

        var levelByDirection = function levelByDirection(nodeA, nodeB, edge) {
          var levelA = _this4.hierarchicalLevels[nodeA.id];
          // set initial level
          if (levelA === undefined) {
            _this4.hierarchicalLevels[nodeA.id] = minLevel;
          }

          var diff = customCallback(_NetworkUtil2.default.cloneOptions(nodeA, 'node'), _NetworkUtil2.default.cloneOptions(nodeB, 'node'), _NetworkUtil2.default.cloneOptions(edge, 'edge'));

          _this4.hierarchicalLevels[nodeB.id] = _this4.hierarchicalLevels[nodeA.id] + diff;
        };

        this._crawlNetwork(levelByDirection);
        this._setMinLevelToZero();
      }

      /**
       * this function allocates nodes in levels based on the direction of the edges
       *
       * @param hubsize
       * @private
       */

    }, {
      key: '_determineLevelsDirected',
      value: function _determineLevelsDirected() {
        var _this5 = this;

        var minLevel = 10000;
        var levelByDirection = function levelByDirection(nodeA, nodeB, edge) {
          var levelA = _this5.hierarchicalLevels[nodeA.id];
          // set initial level
          if (levelA === undefined) {
            _this5.hierarchicalLevels[nodeA.id] = minLevel;
          }
          if (edge.toId == nodeB.id) {
            _this5.hierarchicalLevels[nodeB.id] = _this5.hierarchicalLevels[nodeA.id] + 1;
          } else {
            _this5.hierarchicalLevels[nodeB.id] = _this5.hierarchicalLevels[nodeA.id] - 1;
          }
        };
        this._crawlNetwork(levelByDirection);
        this._setMinLevelToZero();
      }

      /**
       * Small util method to set the minimum levels of the nodes to zero.
       * @private
       */

    }, {
      key: '_setMinLevelToZero',
      value: function _setMinLevelToZero() {
        var minLevel = 1e9;
        // get the minimum level
        for (var nodeId in this.body.nodes) {
          if (this.body.nodes.hasOwnProperty(nodeId)) {
            if (this.hierarchicalLevels[nodeId] !== undefined) {
              minLevel = Math.min(this.hierarchicalLevels[nodeId], minLevel);
            }
          }
        }

        // subtract the minimum from the set so we have a range starting from 0
        for (var _nodeId2 in this.body.nodes) {
          if (this.body.nodes.hasOwnProperty(_nodeId2)) {
            if (this.hierarchicalLevels[_nodeId2] !== undefined) {
              this.hierarchicalLevels[_nodeId2] -= minLevel;
            }
          }
        }
      }

      /**
       * Update the bookkeeping of parent and child.
       * @private
       */

    }, {
      key: '_generateMap',
      value: function _generateMap() {
        var _this6 = this;

        var fillInRelations = function fillInRelations(parentNode, childNode) {
          if (_this6.hierarchicalLevels[childNode.id] > _this6.hierarchicalLevels[parentNode.id]) {
            var parentNodeId = parentNode.id;
            var childNodeId = childNode.id;
            if (_this6.hierarchicalChildrenReference[parentNodeId] === undefined) {
              _this6.hierarchicalChildrenReference[parentNodeId] = [];
            }
            _this6.hierarchicalChildrenReference[parentNodeId].push(childNodeId);
            if (_this6.hierarchicalParentReference[childNodeId] === undefined) {
              _this6.hierarchicalParentReference[childNodeId] = [];
            }
            _this6.hierarchicalParentReference[childNodeId].push(parentNodeId);
          }
        };

        this._crawlNetwork(fillInRelations);
      }

      /**
       * Crawl over the entire network and use a callback on each node couple that is connected to each other.
       * @param callback          | will receive nodeA nodeB and the connecting edge. A and B are unique.
       * @param startingNodeId
       * @private
       */

    }, {
      key: '_crawlNetwork',
      value: function _crawlNetwork() {
        var _this7 = this;

        var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
        var startingNodeId = arguments[1];

        var progress = {};
        var treeIndex = 0;

        var crawler = function crawler(node, tree) {
          if (progress[node.id] === undefined) {

            if (_this7.hierarchicalTrees[node.id] === undefined) {
              _this7.hierarchicalTrees[node.id] = tree;
              _this7.treeIndex = Math.max(tree, _this7.treeIndex);
            }

            progress[node.id] = true;
            var childNode = void 0;
            for (var i = 0; i < node.edges.length; i++) {
              if (node.edges[i].connected === true) {
                if (node.edges[i].toId === node.id) {
                  childNode = node.edges[i].from;
                } else {
                  childNode = node.edges[i].to;
                }

                if (node.id !== childNode.id) {
                  callback(node, childNode, node.edges[i]);
                  crawler(childNode, tree);
                }
              }
            }
          }
        };

        // we can crawl from a specific node or over all nodes.
        if (startingNodeId === undefined) {
          for (var i = 0; i < this.body.nodeIndices.length; i++) {
            var node = this.body.nodes[this.body.nodeIndices[i]];
            if (progress[node.id] === undefined) {
              crawler(node, treeIndex);
              treeIndex += 1;
            }
          }
        } else {
          var _node = this.body.nodes[startingNodeId];
          if (_node === undefined) {
            console.error("Node not found:", startingNodeId);
            return;
          }
          crawler(_node);
        }
      }

      /**
       * Shift a branch a certain distance
       * @param parentId
       * @param diff
       * @private
       */

    }, {
      key: '_shiftBlock',
      value: function _shiftBlock(parentId, diff) {
        if (this.options.hierarchical.direction === 'UD' || this.options.hierarchical.direction === 'DU') {
          this.body.nodes[parentId].x += diff;
        } else {
          this.body.nodes[parentId].y += diff;
        }
        if (this.hierarchicalChildrenReference[parentId] !== undefined) {
          for (var i = 0; i < this.hierarchicalChildrenReference[parentId].length; i++) {
            this._shiftBlock(this.hierarchicalChildrenReference[parentId][i], diff);
          }
        }
      }

      /**
       * Find a common parent between branches.
       * @param childA
       * @param childB
       * @returns {{foundParent, withChild}}
       * @private
       */

    }, {
      key: '_findCommonParent',
      value: function _findCommonParent(childA, childB) {
        var _this8 = this;

        var parents = {};
        var iterateParents = function iterateParents(parents, child) {
          if (_this8.hierarchicalParentReference[child] !== undefined) {
            for (var i = 0; i < _this8.hierarchicalParentReference[child].length; i++) {
              var parent = _this8.hierarchicalParentReference[child][i];
              parents[parent] = true;
              iterateParents(parents, parent);
            }
          }
        };
        var findParent = function findParent(parents, child) {
          if (_this8.hierarchicalParentReference[child] !== undefined) {
            for (var i = 0; i < _this8.hierarchicalParentReference[child].length; i++) {
              var parent = _this8.hierarchicalParentReference[child][i];
              if (parents[parent] !== undefined) {
                return { foundParent: parent, withChild: child };
              }
              var branch = findParent(parents, parent);
              if (branch.foundParent !== null) {
                return branch;
              }
            }
          }
          return { foundParent: null, withChild: child };
        };

        iterateParents(parents, childA);
        return findParent(parents, childB);
      }

      /**
       * Abstract the getting of the position so we won't have to repeat the check for direction all the time
       * @param node
       * @param position
       * @param level
       * @private
       */

    }, {
      key: '_setPositionForHierarchy',
      value: function _setPositionForHierarchy(node, position, level) {
        var doNotUpdate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

        //console.log('_setPositionForHierarchy',node.id, position)
        if (doNotUpdate !== true) {
          if (this.distributionOrdering[level] === undefined) {
            this.distributionOrdering[level] = [];
            this.distributionOrderingPresence[level] = {};
          }

          if (this.distributionOrderingPresence[level][node.id] === undefined) {
            this.distributionOrdering[level].push(node);
            this.distributionIndex[node.id] = this.distributionOrdering[level].length - 1;
          }
          this.distributionOrderingPresence[level][node.id] = true;
        }

        if (this.options.hierarchical.direction === 'UD' || this.options.hierarchical.direction === 'DU') {
          node.x = position;
        } else {
          node.y = position;
        }
      }

      /**
       * Abstract the getting of the position of a node so we do not have to repeat the direction check all the time.
       * @param node
       * @returns {number|*}
       * @private
       */

    }, {
      key: '_getPositionForHierarchy',
      value: function _getPositionForHierarchy(node) {
        if (this.options.hierarchical.direction === 'UD' || this.options.hierarchical.direction === 'DU') {
          return node.x;
        } else {
          return node.y;
        }
      }

      /**
       * Use the x or y value to sort the array, allowing users to specify order.
       * @param nodeArray
       * @private
       */

    }, {
      key: '_sortNodeArray',
      value: function _sortNodeArray(nodeArray) {
        if (nodeArray.length > 1) {
          if (this.options.hierarchical.direction === 'UD' || this.options.hierarchical.direction === 'DU') {
            nodeArray.sort(function (a, b) {
              return a.x - b.x;
            });
          } else {
            nodeArray.sort(function (a, b) {
              return a.y - b.y;
            });
          }
        }
      }
    }]);

    return LayoutEngine;
  }();

  exports.default = LayoutEngine;

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);
  var Hammer = __webpack_require__(22);
  var hammerUtil = __webpack_require__(30);

  /**
   * clears the toolbar div element of children
   *
   * @private
   */

  var ManipulationSystem = function () {
    function ManipulationSystem(body, canvas, selectionHandler) {
      var _this = this;

      _classCallCheck(this, ManipulationSystem);

      this.body = body;
      this.canvas = canvas;
      this.selectionHandler = selectionHandler;

      this.editMode = false;
      this.manipulationDiv = undefined;
      this.editModeDiv = undefined;
      this.closeDiv = undefined;

      this.manipulationHammers = [];
      this.temporaryUIFunctions = {};
      this.temporaryEventFunctions = [];

      this.touchTime = 0;
      this.temporaryIds = { nodes: [], edges: [] };
      this.guiEnabled = false;
      this.inMode = false;
      this.selectedControlNode = undefined;

      this.options = {};
      this.defaultOptions = {
        enabled: false,
        initiallyActive: false,
        addNode: true,
        addEdge: true,
        editNode: undefined,
        editEdge: true,
        deleteNode: true,
        deleteEdge: true,
        controlNodeStyle: {
          shape: 'dot',
          size: 6,
          color: { background: '#ff0000', border: '#3c3c3c', highlight: { background: '#07f968', border: '#3c3c3c' } },
          borderWidth: 2,
          borderWidthSelected: 2
        }
      };
      util.extend(this.options, this.defaultOptions);

      this.body.emitter.on('destroy', function () {
        _this._clean();
      });
      this.body.emitter.on('_dataChanged', this._restore.bind(this));
      this.body.emitter.on('_resetData', this._restore.bind(this));
    }

    /**
     * If something changes in the data during editing, switch back to the initial datamanipulation state and close all edit modes.
     * @private
     */


    _createClass(ManipulationSystem, [{
      key: '_restore',
      value: function _restore() {
        if (this.inMode !== false) {
          if (this.options.initiallyActive === true) {
            this.enableEditMode();
          } else {
            this.disableEditMode();
          }
        }
      }

      /**
       * Set the Options
       * @param options
       */

    }, {
      key: 'setOptions',
      value: function setOptions(options, allOptions, globalOptions) {
        if (allOptions !== undefined) {
          if (allOptions.locale !== undefined) {
            this.options.locale = allOptions.locale;
          } else {
            this.options.locale = globalOptions.locale;
          }
          if (allOptions.locales !== undefined) {
            this.options.locales = allOptions.locales;
          } else {
            this.options.locales = globalOptions.locales;
          }
        }

        if (options !== undefined) {
          if (typeof options === 'boolean') {
            this.options.enabled = options;
          } else {
            this.options.enabled = true;
            util.deepExtend(this.options, options);
          }
          if (this.options.initiallyActive === true) {
            this.editMode = true;
          }
          this._setup();
        }
      }

      /**
       * Enable or disable edit-mode. Draws the DOM required and cleans up after itself.
       *
       * @private
       */

    }, {
      key: 'toggleEditMode',
      value: function toggleEditMode() {
        if (this.editMode === true) {
          this.disableEditMode();
        } else {
          this.enableEditMode();
        }
      }
    }, {
      key: 'enableEditMode',
      value: function enableEditMode() {
        this.editMode = true;

        this._clean();
        if (this.guiEnabled === true) {
          this.manipulationDiv.style.display = 'block';
          this.closeDiv.style.display = 'block';
          this.editModeDiv.style.display = 'none';
          this.showManipulatorToolbar();
        }
      }
    }, {
      key: 'disableEditMode',
      value: function disableEditMode() {
        this.editMode = false;

        this._clean();
        if (this.guiEnabled === true) {
          this.manipulationDiv.style.display = 'none';
          this.closeDiv.style.display = 'none';
          this.editModeDiv.style.display = 'block';
          this._createEditButton();
        }
      }

      /**
       * Creates the main toolbar. Removes functions bound to the select event. Binds all the buttons of the toolbar.
       *
       * @private
       */

    }, {
      key: 'showManipulatorToolbar',
      value: function showManipulatorToolbar() {
        // restore the state of any bound functions or events, remove control nodes, restore physics
        this._clean();

        // reset global variables
        this.manipulationDOM = {};

        // if the gui is enabled, draw all elements.
        if (this.guiEnabled === true) {
          // a _restore will hide these menus
          this.editMode = true;
          this.manipulationDiv.style.display = 'block';
          this.closeDiv.style.display = 'block';

          var selectedNodeCount = this.selectionHandler._getSelectedNodeCount();
          var selectedEdgeCount = this.selectionHandler._getSelectedEdgeCount();
          var selectedTotalCount = selectedNodeCount + selectedEdgeCount;
          var locale = this.options.locales[this.options.locale];
          var needSeperator = false;

          if (this.options.addNode !== false) {
            this._createAddNodeButton(locale);
            needSeperator = true;
          }
          if (this.options.addEdge !== false) {
            if (needSeperator === true) {
              this._createSeperator(1);
            } else {
              needSeperator = true;
            }
            this._createAddEdgeButton(locale);
          }

          if (selectedNodeCount === 1 && typeof this.options.editNode === 'function') {
            if (needSeperator === true) {
              this._createSeperator(2);
            } else {
              needSeperator = true;
            }
            this._createEditNodeButton(locale);
          } else if (selectedEdgeCount === 1 && selectedNodeCount === 0 && this.options.editEdge !== false) {
            if (needSeperator === true) {
              this._createSeperator(3);
            } else {
              needSeperator = true;
            }
            this._createEditEdgeButton(locale);
          }

          // remove buttons
          if (selectedTotalCount !== 0) {
            if (selectedNodeCount > 0 && this.options.deleteNode !== false) {
              if (needSeperator === true) {
                this._createSeperator(4);
              }
              this._createDeleteButton(locale);
            } else if (selectedNodeCount === 0 && this.options.deleteEdge !== false) {
              if (needSeperator === true) {
                this._createSeperator(4);
              }
              this._createDeleteButton(locale);
            }
          }

          // bind the close button
          this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));

          // refresh this bar based on what has been selected
          this._temporaryBindEvent('select', this.showManipulatorToolbar.bind(this));
        }

        // redraw to show any possible changes
        this.body.emitter.emit('_redraw');
      }

      /**
       * Create the toolbar for adding Nodes
       */

    }, {
      key: 'addNodeMode',
      value: function addNodeMode() {
        // when using the gui, enable edit mode if it wasnt already.
        if (this.editMode !== true) {
          this.enableEditMode();
        }

        // restore the state of any bound functions or events, remove control nodes, restore physics
        this._clean();

        this.inMode = 'addNode';
        if (this.guiEnabled === true) {
          var locale = this.options.locales[this.options.locale];
          this.manipulationDOM = {};
          this._createBackButton(locale);
          this._createSeperator();
          this._createDescription(locale['addDescription'] || this.options.locales['en']['addDescription']);

          // bind the close button
          this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));
        }

        this._temporaryBindEvent('click', this._performAddNode.bind(this));
      }

      /**
       * call the bound function to handle the editing of the node. The node has to be selected.
       */

    }, {
      key: 'editNode',
      value: function editNode() {
        var _this2 = this;

        // when using the gui, enable edit mode if it wasnt already.
        if (this.editMode !== true) {
          this.enableEditMode();
        }

        // restore the state of any bound functions or events, remove control nodes, restore physics
        this._clean();
        var node = this.selectionHandler._getSelectedNode();
        if (node !== undefined) {
          this.inMode = 'editNode';
          if (typeof this.options.editNode === 'function') {
            if (node.isCluster !== true) {
              var data = util.deepExtend({}, node.options, false);
              data.x = node.x;
              data.y = node.y;

              if (this.options.editNode.length === 2) {
                this.options.editNode(data, function (finalizedData) {
                  if (finalizedData !== null && finalizedData !== undefined && _this2.inMode === 'editNode') {
                    // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {
                    _this2.body.data.nodes.getDataSet().update(finalizedData);
                  }
                  _this2.showManipulatorToolbar();
                });
              } else {
                throw new Error('The function for edit does not support two arguments (data, callback)');
              }
            } else {
              alert(this.options.locales[this.options.locale]['editClusterError'] || this.options.locales['en']['editClusterError']);
            }
          } else {
            throw new Error('No function has been configured to handle the editing of nodes.');
          }
        } else {
          this.showManipulatorToolbar();
        }
      }

      /**
       * create the toolbar to connect nodes
       */

    }, {
      key: 'addEdgeMode',
      value: function addEdgeMode() {
        // when using the gui, enable edit mode if it wasnt already.
        if (this.editMode !== true) {
          this.enableEditMode();
        }

        // restore the state of any bound functions or events, remove control nodes, restore physics
        this._clean();

        this.inMode = 'addEdge';
        if (this.guiEnabled === true) {
          var locale = this.options.locales[this.options.locale];
          this.manipulationDOM = {};
          this._createBackButton(locale);
          this._createSeperator();
          this._createDescription(locale['edgeDescription'] || this.options.locales['en']['edgeDescription']);

          // bind the close button
          this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));
        }

        // temporarily overload functions
        this._temporaryBindUI('onTouch', this._handleConnect.bind(this));
        this._temporaryBindUI('onDragEnd', this._finishConnect.bind(this));
        this._temporaryBindUI('onDrag', this._dragControlNode.bind(this));
        this._temporaryBindUI('onRelease', this._finishConnect.bind(this));

        this._temporaryBindUI('onDragStart', function () {});
        this._temporaryBindUI('onHold', function () {});
      }

      /**
       * create the toolbar to edit edges
       */

    }, {
      key: 'editEdgeMode',
      value: function editEdgeMode() {
        var _this3 = this;

        // when using the gui, enable edit mode if it wasn't already.
        if (this.editMode !== true) {
          this.enableEditMode();
        }

        // restore the state of any bound functions or events, remove control nodes, restore physics
        this._clean();

        this.inMode = 'editEdge';
        if (this.guiEnabled === true) {
          var locale = this.options.locales[this.options.locale];
          this.manipulationDOM = {};
          this._createBackButton(locale);
          this._createSeperator();
          this._createDescription(locale['editEdgeDescription'] || this.options.locales['en']['editEdgeDescription']);

          // bind the close button
          this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));
        }

        this.edgeBeingEditedId = this.selectionHandler.getSelectedEdges()[0];
        if (this.edgeBeingEditedId !== undefined) {
          (function () {
            var edge = _this3.body.edges[_this3.edgeBeingEditedId];

            // create control nodes
            var controlNodeFrom = _this3._getNewTargetNode(edge.from.x, edge.from.y);
            var controlNodeTo = _this3._getNewTargetNode(edge.to.x, edge.to.y);

            _this3.temporaryIds.nodes.push(controlNodeFrom.id);
            _this3.temporaryIds.nodes.push(controlNodeTo.id);

            _this3.body.nodes[controlNodeFrom.id] = controlNodeFrom;
            _this3.body.nodeIndices.push(controlNodeFrom.id);
            _this3.body.nodes[controlNodeTo.id] = controlNodeTo;
            _this3.body.nodeIndices.push(controlNodeTo.id);

            // temporarily overload UI functions, cleaned up automatically because of _temporaryBindUI
            _this3._temporaryBindUI('onTouch', _this3._controlNodeTouch.bind(_this3)); // used to get the position
            _this3._temporaryBindUI('onTap', function () {}); // disabled
            _this3._temporaryBindUI('onHold', function () {}); // disabled
            _this3._temporaryBindUI('onDragStart', _this3._controlNodeDragStart.bind(_this3)); // used to select control node
            _this3._temporaryBindUI('onDrag', _this3._controlNodeDrag.bind(_this3)); // used to drag control node
            _this3._temporaryBindUI('onDragEnd', _this3._controlNodeDragEnd.bind(_this3)); // used to connect or revert control nodes
            _this3._temporaryBindUI('onMouseMove', function () {}); // disabled

            // create function to position control nodes correctly on movement
            // automatically cleaned up because we use the temporary bind
            _this3._temporaryBindEvent('beforeDrawing', function (ctx) {
              var positions = edge.edgeType.findBorderPositions(ctx);
              if (controlNodeFrom.selected === false) {
                controlNodeFrom.x = positions.from.x;
                controlNodeFrom.y = positions.from.y;
              }
              if (controlNodeTo.selected === false) {
                controlNodeTo.x = positions.to.x;
                controlNodeTo.y = positions.to.y;
              }
            });

            _this3.body.emitter.emit('_redraw');
          })();
        } else {
          this.showManipulatorToolbar();
        }
      }

      /**
       * delete everything in the selection
       */

    }, {
      key: 'deleteSelected',
      value: function deleteSelected() {
        var _this4 = this;

        // when using the gui, enable edit mode if it wasnt already.
        if (this.editMode !== true) {
          this.enableEditMode();
        }

        // restore the state of any bound functions or events, remove control nodes, restore physics
        this._clean();

        this.inMode = 'delete';
        var selectedNodes = this.selectionHandler.getSelectedNodes();
        var selectedEdges = this.selectionHandler.getSelectedEdges();
        var deleteFunction = undefined;
        if (selectedNodes.length > 0) {
          for (var i = 0; i < selectedNodes.length; i++) {
            if (this.body.nodes[selectedNodes[i]].isCluster === true) {
              alert(this.options.locales[this.options.locale]['deleteClusterError'] || this.options.locales['en']['deleteClusterError']);
              return;
            }
          }

          if (typeof this.options.deleteNode === 'function') {
            deleteFunction = this.options.deleteNode;
          }
        } else if (selectedEdges.length > 0) {
          if (typeof this.options.deleteEdge === 'function') {
            deleteFunction = this.options.deleteEdge;
          }
        }

        if (typeof deleteFunction === 'function') {
          var data = { nodes: selectedNodes, edges: selectedEdges };
          if (deleteFunction.length === 2) {
            deleteFunction(data, function (finalizedData) {
              if (finalizedData !== null && finalizedData !== undefined && _this4.inMode === 'delete') {
                // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {
                _this4.body.data.edges.getDataSet().remove(finalizedData.edges);
                _this4.body.data.nodes.getDataSet().remove(finalizedData.nodes);
                _this4.body.emitter.emit('startSimulation');
                _this4.showManipulatorToolbar();
              } else {
                _this4.body.emitter.emit('startSimulation');
                _this4.showManipulatorToolbar();
              }
            });
          } else {
            throw new Error('The function for delete does not support two arguments (data, callback)');
          }
        } else {
          this.body.data.edges.getDataSet().remove(selectedEdges);
          this.body.data.nodes.getDataSet().remove(selectedNodes);
          this.body.emitter.emit('startSimulation');
          this.showManipulatorToolbar();
        }
      }

      //********************************************** PRIVATE ***************************************//

      /**
       * draw or remove the DOM
       * @private
       */

    }, {
      key: '_setup',
      value: function _setup() {
        if (this.options.enabled === true) {
          // Enable the GUI
          this.guiEnabled = true;

          this._createWrappers();
          if (this.editMode === false) {
            this._createEditButton();
          } else {
            this.showManipulatorToolbar();
          }
        } else {
          this._removeManipulationDOM();

          // disable the gui
          this.guiEnabled = false;
        }
      }

      /**
       * create the div overlays that contain the DOM
       * @private
       */

    }, {
      key: '_createWrappers',
      value: function _createWrappers() {
        // load the manipulator HTML elements. All styling done in css.
        if (this.manipulationDiv === undefined) {
          this.manipulationDiv = document.createElement('div');
          this.manipulationDiv.className = 'vis-manipulation';
          if (this.editMode === true) {
            this.manipulationDiv.style.display = 'block';
          } else {
            this.manipulationDiv.style.display = 'none';
          }
          this.canvas.frame.appendChild(this.manipulationDiv);
        }

        // container for the edit button.
        if (this.editModeDiv === undefined) {
          this.editModeDiv = document.createElement('div');
          this.editModeDiv.className = 'vis-edit-mode';
          if (this.editMode === true) {
            this.editModeDiv.style.display = 'none';
          } else {
            this.editModeDiv.style.display = 'block';
          }
          this.canvas.frame.appendChild(this.editModeDiv);
        }

        // container for the close div button
        if (this.closeDiv === undefined) {
          this.closeDiv = document.createElement('div');
          this.closeDiv.className = 'vis-close';
          this.closeDiv.style.display = this.manipulationDiv.style.display;
          this.canvas.frame.appendChild(this.closeDiv);
        }
      }

      /**
       * generate a new target node. Used for creating new edges and editing edges
       * @param x
       * @param y
       * @returns {*}
       * @private
       */

    }, {
      key: '_getNewTargetNode',
      value: function _getNewTargetNode(x, y) {
        var controlNodeStyle = util.deepExtend({}, this.options.controlNodeStyle);

        controlNodeStyle.id = 'targetNode' + util.randomUUID();
        controlNodeStyle.hidden = false;
        controlNodeStyle.physics = false;
        controlNodeStyle.x = x;
        controlNodeStyle.y = y;

        // we have to define the bounding box in order for the nodes to be drawn immediately
        var node = this.body.functions.createNode(controlNodeStyle);
        node.shape.boundingBox = { left: x, right: x, top: y, bottom: y };

        return node;
      }

      /**
       * Create the edit button
       */

    }, {
      key: '_createEditButton',
      value: function _createEditButton() {
        // restore everything to it's original state (if applicable)
        this._clean();

        // reset the manipulationDOM
        this.manipulationDOM = {};

        // empty the editModeDiv
        util.recursiveDOMDelete(this.editModeDiv);

        // create the contents for the editMode button
        var locale = this.options.locales[this.options.locale];
        var button = this._createButton('editMode', 'vis-button vis-edit vis-edit-mode', locale['edit'] || this.options.locales['en']['edit']);
        this.editModeDiv.appendChild(button);

        // bind a hammer listener to the button, calling the function toggleEditMode.
        this._bindHammerToDiv(button, this.toggleEditMode.bind(this));
      }

      /**
       * this function cleans up after everything this module does. Temporary elements, functions and events are removed, physics restored, hammers removed.
       * @private
       */

    }, {
      key: '_clean',
      value: function _clean() {
        // not in mode
        this.inMode = false;

        // _clean the divs
        if (this.guiEnabled === true) {
          util.recursiveDOMDelete(this.editModeDiv);
          util.recursiveDOMDelete(this.manipulationDiv);

          // removes all the bindings and overloads
          this._cleanManipulatorHammers();
        }

        // remove temporary nodes and edges
        this._cleanupTemporaryNodesAndEdges();

        // restore overloaded UI functions
        this._unbindTemporaryUIs();

        // remove the temporaryEventFunctions
        this._unbindTemporaryEvents();

        // restore the physics if required
        this.body.emitter.emit('restorePhysics');
      }

      /**
       * Each dom element has it's own hammer. They are stored in this.manipulationHammers. This cleans them up.
       * @private
       */

    }, {
      key: '_cleanManipulatorHammers',
      value: function _cleanManipulatorHammers() {
        // _clean hammer bindings
        if (this.manipulationHammers.length != 0) {
          for (var i = 0; i < this.manipulationHammers.length; i++) {
            this.manipulationHammers[i].destroy();
          }
          this.manipulationHammers = [];
        }
      }

      /**
       * Remove all DOM elements created by this module.
       * @private
       */

    }, {
      key: '_removeManipulationDOM',
      value: function _removeManipulationDOM() {
        // removes all the bindings and overloads
        this._clean();

        // empty the manipulation divs
        util.recursiveDOMDelete(this.manipulationDiv);
        util.recursiveDOMDelete(this.editModeDiv);
        util.recursiveDOMDelete(this.closeDiv);

        // remove the manipulation divs
        if (this.manipulationDiv) {
          this.canvas.frame.removeChild(this.manipulationDiv);
        }
        if (this.editModeDiv) {
          this.canvas.frame.removeChild(this.editModeDiv);
        }
        if (this.closeDiv) {
          this.canvas.frame.removeChild(this.closeDiv);
        }

        // set the references to undefined
        this.manipulationDiv = undefined;
        this.editModeDiv = undefined;
        this.closeDiv = undefined;
      }

      /**
       * create a seperator line. the index is to differentiate in the manipulation dom
       * @param index
       * @private
       */

    }, {
      key: '_createSeperator',
      value: function _createSeperator() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

        this.manipulationDOM['seperatorLineDiv' + index] = document.createElement('div');
        this.manipulationDOM['seperatorLineDiv' + index].className = 'vis-separator-line';
        this.manipulationDiv.appendChild(this.manipulationDOM['seperatorLineDiv' + index]);
      }

      // ----------------------    DOM functions for buttons    --------------------------//

    }, {
      key: '_createAddNodeButton',
      value: function _createAddNodeButton(locale) {
        var button = this._createButton('addNode', 'vis-button vis-add', locale['addNode'] || this.options.locales['en']['addNode']);
        this.manipulationDiv.appendChild(button);
        this._bindHammerToDiv(button, this.addNodeMode.bind(this));
      }
    }, {
      key: '_createAddEdgeButton',
      value: function _createAddEdgeButton(locale) {
        var button = this._createButton('addEdge', 'vis-button vis-connect', locale['addEdge'] || this.options.locales['en']['addEdge']);
        this.manipulationDiv.appendChild(button);
        this._bindHammerToDiv(button, this.addEdgeMode.bind(this));
      }
    }, {
      key: '_createEditNodeButton',
      value: function _createEditNodeButton(locale) {
        var button = this._createButton('editNode', 'vis-button vis-edit', locale['editNode'] || this.options.locales['en']['editNode']);
        this.manipulationDiv.appendChild(button);
        this._bindHammerToDiv(button, this.editNode.bind(this));
      }
    }, {
      key: '_createEditEdgeButton',
      value: function _createEditEdgeButton(locale) {
        var button = this._createButton('editEdge', 'vis-button vis-edit', locale['editEdge'] || this.options.locales['en']['editEdge']);
        this.manipulationDiv.appendChild(button);
        this._bindHammerToDiv(button, this.editEdgeMode.bind(this));
      }
    }, {
      key: '_createDeleteButton',
      value: function _createDeleteButton(locale) {
        if (this.options.rtl) {
          var deleteBtnClass = 'vis-button vis-delete-rtl';
        } else {
          var deleteBtnClass = 'vis-button vis-delete';
        }
        var button = this._createButton('delete', deleteBtnClass, locale['del'] || this.options.locales['en']['del']);
        this.manipulationDiv.appendChild(button);
        this._bindHammerToDiv(button, this.deleteSelected.bind(this));
      }
    }, {
      key: '_createBackButton',
      value: function _createBackButton(locale) {
        var button = this._createButton('back', 'vis-button vis-back', locale['back'] || this.options.locales['en']['back']);
        this.manipulationDiv.appendChild(button);
        this._bindHammerToDiv(button, this.showManipulatorToolbar.bind(this));
      }
    }, {
      key: '_createButton',
      value: function _createButton(id, className, label) {
        var labelClassName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'vis-label';


        this.manipulationDOM[id + 'Div'] = document.createElement('div');
        this.manipulationDOM[id + 'Div'].className = className;
        this.manipulationDOM[id + 'Label'] = document.createElement('div');
        this.manipulationDOM[id + 'Label'].className = labelClassName;
        this.manipulationDOM[id + 'Label'].innerHTML = label;
        this.manipulationDOM[id + 'Div'].appendChild(this.manipulationDOM[id + 'Label']);
        return this.manipulationDOM[id + 'Div'];
      }
    }, {
      key: '_createDescription',
      value: function _createDescription(label) {
        this.manipulationDiv.appendChild(this._createButton('description', 'vis-button vis-none', label));
      }

      // -------------------------- End of DOM functions for buttons ------------------------------//

      /**
       * this binds an event until cleanup by the clean functions.
       * @param event
       * @param newFunction
       * @private
       */

    }, {
      key: '_temporaryBindEvent',
      value: function _temporaryBindEvent(event, newFunction) {
        this.temporaryEventFunctions.push({ event: event, boundFunction: newFunction });
        this.body.emitter.on(event, newFunction);
      }

      /**
       * this overrides an UI function until cleanup by the clean function
       * @param UIfunctionName
       * @param newFunction
       * @private
       */

    }, {
      key: '_temporaryBindUI',
      value: function _temporaryBindUI(UIfunctionName, newFunction) {
        if (this.body.eventListeners[UIfunctionName] !== undefined) {
          this.temporaryUIFunctions[UIfunctionName] = this.body.eventListeners[UIfunctionName];
          this.body.eventListeners[UIfunctionName] = newFunction;
        } else {
          throw new Error('This UI function does not exist. Typo? You tried: ' + UIfunctionName + ' possible are: ' + JSON.stringify(Object.keys(this.body.eventListeners)));
        }
      }

      /**
       * Restore the overridden UI functions to their original state.
       *
       * @private
       */

    }, {
      key: '_unbindTemporaryUIs',
      value: function _unbindTemporaryUIs() {
        for (var functionName in this.temporaryUIFunctions) {
          if (this.temporaryUIFunctions.hasOwnProperty(functionName)) {
            this.body.eventListeners[functionName] = this.temporaryUIFunctions[functionName];
            delete this.temporaryUIFunctions[functionName];
          }
        }
        this.temporaryUIFunctions = {};
      }

      /**
       * Unbind the events created by _temporaryBindEvent
       * @private
       */

    }, {
      key: '_unbindTemporaryEvents',
      value: function _unbindTemporaryEvents() {
        for (var i = 0; i < this.temporaryEventFunctions.length; i++) {
          var eventName = this.temporaryEventFunctions[i].event;
          var boundFunction = this.temporaryEventFunctions[i].boundFunction;
          this.body.emitter.off(eventName, boundFunction);
        }
        this.temporaryEventFunctions = [];
      }

      /**
       * Bind an hammer instance to a DOM element.
       * @param domElement
       * @param funct
       */

    }, {
      key: '_bindHammerToDiv',
      value: function _bindHammerToDiv(domElement, boundFunction) {
        var hammer = new Hammer(domElement, {});
        hammerUtil.onTouch(hammer, boundFunction);
        this.manipulationHammers.push(hammer);
      }

      /**
       * Neatly clean up temporary edges and nodes
       * @private
       */

    }, {
      key: '_cleanupTemporaryNodesAndEdges',
      value: function _cleanupTemporaryNodesAndEdges() {
        // _clean temporary edges
        for (var i = 0; i < this.temporaryIds.edges.length; i++) {
          this.body.edges[this.temporaryIds.edges[i]].disconnect();
          delete this.body.edges[this.temporaryIds.edges[i]];
          var indexTempEdge = this.body.edgeIndices.indexOf(this.temporaryIds.edges[i]);
          if (indexTempEdge !== -1) {
            this.body.edgeIndices.splice(indexTempEdge, 1);
          }
        }

        // _clean temporary nodes
        for (var _i = 0; _i < this.temporaryIds.nodes.length; _i++) {
          delete this.body.nodes[this.temporaryIds.nodes[_i]];
          var indexTempNode = this.body.nodeIndices.indexOf(this.temporaryIds.nodes[_i]);
          if (indexTempNode !== -1) {
            this.body.nodeIndices.splice(indexTempNode, 1);
          }
        }

        this.temporaryIds = { nodes: [], edges: [] };
      }

      // ------------------------------------------ EDIT EDGE FUNCTIONS -----------------------------------------//

      /**
       * the touch is used to get the position of the initial click
       * @param event
       * @private
       */

    }, {
      key: '_controlNodeTouch',
      value: function _controlNodeTouch(event) {
        this.selectionHandler.unselectAll();
        this.lastTouch = this.body.functions.getPointer(event.center);
        this.lastTouch.translation = util.extend({}, this.body.view.translation); // copy the object
      }

      /**
       * the drag start is used to mark one of the control nodes as selected.
       * @param event
       * @private
       */

    }, {
      key: '_controlNodeDragStart',
      value: function _controlNodeDragStart(event) {
        var pointer = this.lastTouch;
        var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);
        var from = this.body.nodes[this.temporaryIds.nodes[0]];
        var to = this.body.nodes[this.temporaryIds.nodes[1]];
        var edge = this.body.edges[this.edgeBeingEditedId];
        this.selectedControlNode = undefined;

        var fromSelect = from.isOverlappingWith(pointerObj);
        var toSelect = to.isOverlappingWith(pointerObj);

        if (fromSelect === true) {
          this.selectedControlNode = from;
          edge.edgeType.from = from;
        } else if (toSelect === true) {
          this.selectedControlNode = to;
          edge.edgeType.to = to;
        }

        // we use the selection to find the node that is being dragged. We explicitly select it here.
        if (this.selectedControlNode !== undefined) {
          this.selectionHandler.selectObject(this.selectedControlNode);
        }

        this.body.emitter.emit('_redraw');
      }

      /**
       * dragging the control nodes or the canvas
       * @param event
       * @private
       */

    }, {
      key: '_controlNodeDrag',
      value: function _controlNodeDrag(event) {
        this.body.emitter.emit('disablePhysics');
        var pointer = this.body.functions.getPointer(event.center);
        var pos = this.canvas.DOMtoCanvas(pointer);
        if (this.selectedControlNode !== undefined) {
          this.selectedControlNode.x = pos.x;
          this.selectedControlNode.y = pos.y;
        } else {
          // if the drag was not started properly because the click started outside the network div, start it now.
          var diffX = pointer.x - this.lastTouch.x;
          var diffY = pointer.y - this.lastTouch.y;
          this.body.view.translation = { x: this.lastTouch.translation.x + diffX, y: this.lastTouch.translation.y + diffY };
        }
        this.body.emitter.emit('_redraw');
      }

      /**
       * connecting or restoring the control nodes.
       * @param event
       * @private
       */

    }, {
      key: '_controlNodeDragEnd',
      value: function _controlNodeDragEnd(event) {
        var pointer = this.body.functions.getPointer(event.center);
        var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);
        var edge = this.body.edges[this.edgeBeingEditedId];
        // if the node that was dragged is not a control node, return
        if (this.selectedControlNode === undefined) {
          return;
        }

        // we use the selection to find the node that is being dragged. We explicitly DEselect the control node here.
        this.selectionHandler.unselectAll();
        var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);
        var node = undefined;
        for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
          if (overlappingNodeIds[i] !== this.selectedControlNode.id) {
            node = this.body.nodes[overlappingNodeIds[i]];
            break;
          }
        }
        // perform the connection
        if (node !== undefined && this.selectedControlNode !== undefined) {
          if (node.isCluster === true) {
            alert(this.options.locales[this.options.locale]['createEdgeError'] || this.options.locales['en']['createEdgeError']);
          } else {
            var from = this.body.nodes[this.temporaryIds.nodes[0]];
            if (this.selectedControlNode.id === from.id) {
              this._performEditEdge(node.id, edge.to.id);
            } else {
              this._performEditEdge(edge.from.id, node.id);
            }
          }
        } else {
          edge.updateEdgeType();
          this.body.emitter.emit('restorePhysics');
        }
        this.body.emitter.emit('_redraw');
      }

      // ------------------------------------ END OF EDIT EDGE FUNCTIONS -----------------------------------------//


      // ------------------------------------------- ADD EDGE FUNCTIONS -----------------------------------------//
      /**
       * the function bound to the selection event. It checks if you want to connect a cluster and changes the description
       * to walk the user through the process.
       *
       * @private
       */

    }, {
      key: '_handleConnect',
      value: function _handleConnect(event) {
        // check to avoid double fireing of this function.
        if (new Date().valueOf() - this.touchTime > 100) {
          this.lastTouch = this.body.functions.getPointer(event.center);
          this.lastTouch.translation = util.extend({}, this.body.view.translation); // copy the object

          var pointer = this.lastTouch;
          var node = this.selectionHandler.getNodeAt(pointer);

          if (node !== undefined) {
            if (node.isCluster === true) {
              alert(this.options.locales[this.options.locale]['createEdgeError'] || this.options.locales['en']['createEdgeError']);
            } else {
              // create a node the temporary line can look at
              var targetNode = this._getNewTargetNode(node.x, node.y);
              this.body.nodes[targetNode.id] = targetNode;
              this.body.nodeIndices.push(targetNode.id);

              // create a temporary edge
              var connectionEdge = this.body.functions.createEdge({
                id: 'connectionEdge' + util.randomUUID(),
                from: node.id,
                to: targetNode.id,
                physics: false,
                smooth: {
                  enabled: true,
                  type: 'continuous',
                  roundness: 0.5
                }
              });
              this.body.edges[connectionEdge.id] = connectionEdge;
              this.body.edgeIndices.push(connectionEdge.id);

              this.temporaryIds.nodes.push(targetNode.id);
              this.temporaryIds.edges.push(connectionEdge.id);
            }
          }
          this.touchTime = new Date().valueOf();
        }
      }
    }, {
      key: '_dragControlNode',
      value: function _dragControlNode(event) {
        var pointer = this.body.functions.getPointer(event.center);
        if (this.temporaryIds.nodes[0] !== undefined) {
          var targetNode = this.body.nodes[this.temporaryIds.nodes[0]]; // there is only one temp node in the add edge mode.
          targetNode.x = this.canvas._XconvertDOMtoCanvas(pointer.x);
          targetNode.y = this.canvas._YconvertDOMtoCanvas(pointer.y);
          this.body.emitter.emit('_redraw');
        } else {
          var diffX = pointer.x - this.lastTouch.x;
          var diffY = pointer.y - this.lastTouch.y;
          this.body.view.translation = { x: this.lastTouch.translation.x + diffX, y: this.lastTouch.translation.y + diffY };
        }
      }

      /**
       * Connect the new edge to the target if one exists, otherwise remove temp line
       * @param event
       * @private
       */

    }, {
      key: '_finishConnect',
      value: function _finishConnect(event) {
        var pointer = this.body.functions.getPointer(event.center);
        var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);

        // remember the edge id
        var connectFromId = undefined;
        if (this.temporaryIds.edges[0] !== undefined) {
          connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;
        }

        // get the overlapping node but NOT the temporary node;
        var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);
        var node = undefined;
        for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
          // if the node id is NOT a temporary node, accept the node.
          if (this.temporaryIds.nodes.indexOf(overlappingNodeIds[i]) === -1) {
            node = this.body.nodes[overlappingNodeIds[i]];
            break;
          }
        }

        // clean temporary nodes and edges.
        this._cleanupTemporaryNodesAndEdges();

        // perform the connection
        if (node !== undefined) {
          if (node.isCluster === true) {
            alert(this.options.locales[this.options.locale]['createEdgeError'] || this.options.locales['en']['createEdgeError']);
          } else {
            if (this.body.nodes[connectFromId] !== undefined && this.body.nodes[node.id] !== undefined) {
              this._performAddEdge(connectFromId, node.id);
            }
          }
        }
        this.body.emitter.emit('_redraw');
      }

      // --------------------------------------- END OF ADD EDGE FUNCTIONS -------------------------------------//


      // ------------------------------ Performing all the actual data manipulation ------------------------//

      /**
       * Adds a node on the specified location
       */

    }, {
      key: '_performAddNode',
      value: function _performAddNode(clickData) {
        var _this5 = this;

        var defaultData = {
          id: util.randomUUID(),
          x: clickData.pointer.canvas.x,
          y: clickData.pointer.canvas.y,
          label: 'new'
        };

        if (typeof this.options.addNode === 'function') {
          if (this.options.addNode.length === 2) {
            this.options.addNode(defaultData, function (finalizedData) {
              if (finalizedData !== null && finalizedData !== undefined && _this5.inMode === 'addNode') {
                // if for whatever reason the mode has changes (due to dataset change) disregard the callback
                _this5.body.data.nodes.getDataSet().add(finalizedData);
                _this5.showManipulatorToolbar();
              }
            });
          } else {
            throw new Error('The function for add does not support two arguments (data,callback)');
            this.showManipulatorToolbar();
          }
        } else {
          this.body.data.nodes.getDataSet().add(defaultData);
          this.showManipulatorToolbar();
        }
      }

      /**
       * connect two nodes with a new edge.
       *
       * @private
       */

    }, {
      key: '_performAddEdge',
      value: function _performAddEdge(sourceNodeId, targetNodeId) {
        var _this6 = this;

        var defaultData = { from: sourceNodeId, to: targetNodeId };
        if (typeof this.options.addEdge === 'function') {
          if (this.options.addEdge.length === 2) {
            this.options.addEdge(defaultData, function (finalizedData) {
              if (finalizedData !== null && finalizedData !== undefined && _this6.inMode === 'addEdge') {
                // if for whatever reason the mode has changes (due to dataset change) disregard the callback
                _this6.body.data.edges.getDataSet().add(finalizedData);
                _this6.selectionHandler.unselectAll();
                _this6.showManipulatorToolbar();
              }
            });
          } else {
            throw new Error('The function for connect does not support two arguments (data,callback)');
          }
        } else {
          this.body.data.edges.getDataSet().add(defaultData);
          this.selectionHandler.unselectAll();
          this.showManipulatorToolbar();
        }
      }

      /**
       * connect two nodes with a new edge.
       *
       * @private
       */

    }, {
      key: '_performEditEdge',
      value: function _performEditEdge(sourceNodeId, targetNodeId) {
        var _this7 = this;

        var defaultData = { id: this.edgeBeingEditedId, from: sourceNodeId, to: targetNodeId };
        if (typeof this.options.editEdge === 'function') {
          if (this.options.editEdge.length === 2) {
            this.options.editEdge(defaultData, function (finalizedData) {
              if (finalizedData === null || finalizedData === undefined || _this7.inMode !== 'editEdge') {
                // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {
                _this7.body.edges[defaultData.id].updateEdgeType();
                _this7.body.emitter.emit('_redraw');
              } else {
                _this7.body.data.edges.getDataSet().update(finalizedData);
                _this7.selectionHandler.unselectAll();
                _this7.showManipulatorToolbar();
              }
            });
          } else {
            throw new Error('The function for edit does not support two arguments (data, callback)');
          }
        } else {
          this.body.data.edges.getDataSet().update(defaultData);
          this.selectionHandler.unselectAll();
          this.showManipulatorToolbar();
        }
      }
    }]);

    return ManipulationSystem;
  }();

  exports.default = ManipulationSystem;

/***/ },
/* 116 */
/***/ function(module, exports) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /**
   * This object contains all possible options. It will check if the types are correct, if required if the option is one
   * of the allowed values.
   *
   * __any__ means that the name of the property does not matter.
   * __type__ is a required field for all objects and contains the allowed types of all objects
   */
  var string = 'string';
  var boolean = 'boolean';
  var number = 'number';
  var array = 'array';
  var object = 'object'; // should only be in a __type__ property
  var dom = 'dom';
  var any = 'any';

  var allOptions = {
    configure: {
      enabled: { boolean: boolean },
      filter: { boolean: boolean, string: string, array: array, 'function': 'function' },
      container: { dom: dom },
      showButton: { boolean: boolean },
      __type__: { object: object, boolean: boolean, string: string, array: array, 'function': 'function' }
    },
    edges: {
      arrows: {
        to: { enabled: { boolean: boolean }, scaleFactor: { number: number }, type: { string: ['arrow', 'circle'] }, __type__: { object: object, boolean: boolean } },
        middle: { enabled: { boolean: boolean }, scaleFactor: { number: number }, type: { string: ['arrow', 'circle'] }, __type__: { object: object, boolean: boolean } },
        from: { enabled: { boolean: boolean }, scaleFactor: { number: number }, type: { string: ['arrow', 'circle'] }, __type__: { object: object, boolean: boolean } },
        __type__: { string: ['from', 'to', 'middle'], object: object }
      },
      arrowStrikethrough: { boolean: boolean },
      color: {
        color: { string: string },
        highlight: { string: string },
        hover: { string: string },
        inherit: { string: ['from', 'to', 'both'], boolean: boolean },
        opacity: { number: number },
        __type__: { object: object, string: string }
      },
      dashes: { boolean: boolean, array: array },
      font: {
        color: { string: string },
        size: { number: number }, // px
        face: { string: string },
        background: { string: string },
        strokeWidth: { number: number }, // px
        strokeColor: { string: string },
        align: { string: ['horizontal', 'top', 'middle', 'bottom'] },
        __type__: { object: object, string: string }
      },
      hidden: { boolean: boolean },
      hoverWidth: { 'function': 'function', number: number },
      label: { string: string, 'undefined': 'undefined' },
      labelHighlightBold: { boolean: boolean },
      length: { number: number, 'undefined': 'undefined' },
      physics: { boolean: boolean },
      scaling: {
        min: { number: number },
        max: { number: number },
        label: {
          enabled: { boolean: boolean },
          min: { number: number },
          max: { number: number },
          maxVisible: { number: number },
          drawThreshold: { number: number },
          __type__: { object: object, boolean: boolean }
        },
        customScalingFunction: { 'function': 'function' },
        __type__: { object: object }
      },
      selectionWidth: { 'function': 'function', number: number },
      selfReferenceSize: { number: number },
      shadow: {
        enabled: { boolean: boolean },
        color: { string: string },
        size: { number: number },
        x: { number: number },
        y: { number: number },
        __type__: { object: object, boolean: boolean }
      },
      smooth: {
        enabled: { boolean: boolean },
        type: { string: ['dynamic', 'continuous', 'discrete', 'diagonalCross', 'straightCross', 'horizontal', 'vertical', 'curvedCW', 'curvedCCW', 'cubicBezier'] },
        roundness: { number: number },
        forceDirection: { string: ['horizontal', 'vertical', 'none'], boolean: boolean },
        __type__: { object: object, boolean: boolean }
      },
      title: { string: string, 'undefined': 'undefined' },
      width: { number: number },
      value: { number: number, 'undefined': 'undefined' },
      __type__: { object: object }
    },
    groups: {
      useDefaultGroups: { boolean: boolean },
      __any__: 'get from nodes, will be overwritten below',
      __type__: { object: object }
    },
    interaction: {
      dragNodes: { boolean: boolean },
      dragView: { boolean: boolean },
      hideEdgesOnDrag: { boolean: boolean },
      hideNodesOnDrag: { boolean: boolean },
      hover: { boolean: boolean },
      keyboard: {
        enabled: { boolean: boolean },
        speed: { x: { number: number }, y: { number: number }, zoom: { number: number }, __type__: { object: object } },
        bindToWindow: { boolean: boolean },
        __type__: { object: object, boolean: boolean }
      },
      multiselect: { boolean: boolean },
      navigationButtons: { boolean: boolean },
      selectable: { boolean: boolean },
      selectConnectedEdges: { boolean: boolean },
      hoverConnectedEdges: { boolean: boolean },
      tooltipDelay: { number: number },
      zoomView: { boolean: boolean },
      __type__: { object: object }
    },
    layout: {
      randomSeed: { 'undefined': 'undefined', number: number },
      improvedLayout: { boolean: boolean },
      hierarchical: {
        enabled: { boolean: boolean },
        levelSeparation: { number: number },
        nodeSpacing: { number: number },
        treeSpacing: { number: number },
        blockShifting: { boolean: boolean },
        edgeMinimization: { boolean: boolean },
        parentCentralization: { boolean: boolean },
        direction: { string: ['UD', 'DU', 'LR', 'RL'] }, // UD, DU, LR, RL
        sortMethod: { string: ['hubsize', 'directed'] }, // hubsize, directed
        __type__: { object: object, boolean: boolean }
      },
      __type__: { object: object }
    },
    manipulation: {
      enabled: { boolean: boolean },
      initiallyActive: { boolean: boolean },
      addNode: { boolean: boolean, 'function': 'function' },
      addEdge: { boolean: boolean, 'function': 'function' },
      editNode: { 'function': 'function' },
      editEdge: { boolean: boolean, 'function': 'function' },
      deleteNode: { boolean: boolean, 'function': 'function' },
      deleteEdge: { boolean: boolean, 'function': 'function' },
      controlNodeStyle: 'get from nodes, will be overwritten below',
      __type__: { object: object, boolean: boolean }
    },
    nodes: {
      borderWidth: { number: number },
      borderWidthSelected: { number: number, 'undefined': 'undefined' },
      brokenImage: { string: string, 'undefined': 'undefined' },
      color: {
        border: { string: string },
        background: { string: string },
        highlight: {
          border: { string: string },
          background: { string: string },
          __type__: { object: object, string: string }
        },
        hover: {
          border: { string: string },
          background: { string: string },
          __type__: { object: object, string: string }
        },
        __type__: { object: object, string: string }
      },
      fixed: {
        x: { boolean: boolean },
        y: { boolean: boolean },
        __type__: { object: object, boolean: boolean }
      },
      font: {
        align: { string: string },
        color: { string: string },
        size: { number: number }, // px
        face: { string: string },
        background: { string: string },
        strokeWidth: { number: number }, // px
        strokeColor: { string: string },
        __type__: { object: object, string: string }
      },
      group: { string: string, number: number, 'undefined': 'undefined' },
      hidden: { boolean: boolean },
      icon: {
        face: { string: string },
        code: { string: string }, //'\uf007',
        size: { number: number }, //50,
        color: { string: string },
        __type__: { object: object }
      },
      id: { string: string, number: number },
      image: { string: string, 'undefined': 'undefined' }, // --> URL
      label: { string: string, 'undefined': 'undefined' },
      labelHighlightBold: { boolean: boolean },
      level: { number: number, 'undefined': 'undefined' },
      mass: { number: number },
      physics: { boolean: boolean },
      scaling: {
        min: { number: number },
        max: { number: number },
        label: {
          enabled: { boolean: boolean },
          min: { number: number },
          max: { number: number },
          maxVisible: { number: number },
          drawThreshold: { number: number },
          __type__: { object: object, boolean: boolean }
        },
        customScalingFunction: { 'function': 'function' },
        __type__: { object: object }
      },
      shadow: {
        enabled: { boolean: boolean },
        color: { string: string },
        size: { number: number },
        x: { number: number },
        y: { number: number },
        __type__: { object: object, boolean: boolean }
      },
      shape: { string: ['ellipse', 'circle', 'database', 'box', 'text', 'image', 'circularImage', 'diamond', 'dot', 'star', 'triangle', 'triangleDown', 'square', 'icon'] },
      shapeProperties: {
        borderDashes: { boolean: boolean, array: array },
        borderRadius: { number: number },
        interpolation: { boolean: boolean },
        useImageSize: { boolean: boolean },
        useBorderWithImage: { boolean: boolean },
        __type__: { object: object }
      },
      size: { number: number },
      title: { string: string, 'undefined': 'undefined' },
      value: { number: number, 'undefined': 'undefined' },
      x: { number: number },
      y: { number: number },
      __type__: { object: object }
    },
    physics: {
      enabled: { boolean: boolean },
      barnesHut: {
        gravitationalConstant: { number: number },
        centralGravity: { number: number },
        springLength: { number: number },
        springConstant: { number: number },
        damping: { number: number },
        avoidOverlap: { number: number },
        __type__: { object: object }
      },
      forceAtlas2Based: {
        gravitationalConstant: { number: number },
        centralGravity: { number: number },
        springLength: { number: number },
        springConstant: { number: number },
        damping: { number: number },
        avoidOverlap: { number: number },
        __type__: { object: object }
      },
      repulsion: {
        centralGravity: { number: number },
        springLength: { number: number },
        springConstant: { number: number },
        nodeDistance: { number: number },
        damping: { number: number },
        __type__: { object: object }
      },
      hierarchicalRepulsion: {
        centralGravity: { number: number },
        springLength: { number: number },
        springConstant: { number: number },
        nodeDistance: { number: number },
        damping: { number: number },
        __type__: { object: object }
      },
      maxVelocity: { number: number },
      minVelocity: { number: number }, // px/s
      solver: { string: ['barnesHut', 'repulsion', 'hierarchicalRepulsion', 'forceAtlas2Based'] },
      stabilization: {
        enabled: { boolean: boolean },
        iterations: { number: number }, // maximum number of iteration to stabilize
        updateInterval: { number: number },
        onlyDynamicEdges: { boolean: boolean },
        fit: { boolean: boolean },
        __type__: { object: object, boolean: boolean }
      },
      timestep: { number: number },
      adaptiveTimestep: { boolean: boolean },
      __type__: { object: object, boolean: boolean }
    },

    //globals :
    autoResize: { boolean: boolean },
    clickToUse: { boolean: boolean },
    locale: { string: string },
    locales: {
      __any__: { any: any },
      __type__: { object: object }
    },
    height: { string: string },
    width: { string: string },
    __type__: { object: object }
  };

  allOptions.groups.__any__ = allOptions.nodes;
  allOptions.manipulation.controlNodeStyle = allOptions.nodes;

  var configureOptions = {
    nodes: {
      borderWidth: [1, 0, 10, 1],
      borderWidthSelected: [2, 0, 10, 1],
      color: {
        border: ['color', '#2B7CE9'],
        background: ['color', '#97C2FC'],
        highlight: {
          border: ['color', '#2B7CE9'],
          background: ['color', '#D2E5FF']
        },
        hover: {
          border: ['color', '#2B7CE9'],
          background: ['color', '#D2E5FF']
        }
      },
      fixed: {
        x: false,
        y: false
      },
      font: {
        color: ['color', '#343434'],
        size: [14, 0, 100, 1], // px
        face: ['arial', 'verdana', 'tahoma'],
        background: ['color', 'none'],
        strokeWidth: [0, 0, 50, 1], // px
        strokeColor: ['color', '#ffffff']
      },
      //group: 'string',
      hidden: false,
      labelHighlightBold: true,
      //icon: {
      //  face: 'string',  //'FontAwesome',
      //  code: 'string',  //'\uf007',
      //  size: [50, 0, 200, 1],  //50,
      //  color: ['color','#2B7CE9']   //'#aa00ff'
      //},
      //image: 'string', // --> URL
      physics: true,
      scaling: {
        min: [10, 0, 200, 1],
        max: [30, 0, 200, 1],
        label: {
          enabled: false,
          min: [14, 0, 200, 1],
          max: [30, 0, 200, 1],
          maxVisible: [30, 0, 200, 1],
          drawThreshold: [5, 0, 20, 1]
        }
      },
      shadow: {
        enabled: false,
        color: 'rgba(0,0,0,0.5)',
        size: [10, 0, 20, 1],
        x: [5, -30, 30, 1],
        y: [5, -30, 30, 1]
      },
      shape: ['ellipse', 'box', 'circle', 'database', 'diamond', 'dot', 'square', 'star', 'text', 'triangle', 'triangleDown'],
      shapeProperties: {
        borderDashes: false,
        borderRadius: [6, 0, 20, 1],
        interpolation: true,
        useImageSize: false
      },
      size: [25, 0, 200, 1]
    },
    edges: {
      arrows: {
        to: { enabled: false, scaleFactor: [1, 0, 3, 0.05], type: 'arrow' },
        middle: { enabled: false, scaleFactor: [1, 0, 3, 0.05], type: 'arrow' },
        from: { enabled: false, scaleFactor: [1, 0, 3, 0.05], type: 'arrow' }
      },
      arrowStrikethrough: true,
      color: {
        color: ['color', '#848484'],
        highlight: ['color', '#848484'],
        hover: ['color', '#848484'],
        inherit: ['from', 'to', 'both', true, false],
        opacity: [1, 0, 1, 0.05]
      },
      dashes: false,
      font: {
        color: ['color', '#343434'],
        size: [14, 0, 100, 1], // px
        face: ['arial', 'verdana', 'tahoma'],
        background: ['color', 'none'],
        strokeWidth: [2, 0, 50, 1], // px
        strokeColor: ['color', '#ffffff'],
        align: ['horizontal', 'top', 'middle', 'bottom']
      },
      hidden: false,
      hoverWidth: [1.5, 0, 5, 0.1],
      labelHighlightBold: true,
      physics: true,
      scaling: {
        min: [1, 0, 100, 1],
        max: [15, 0, 100, 1],
        label: {
          enabled: true,
          min: [14, 0, 200, 1],
          max: [30, 0, 200, 1],
          maxVisible: [30, 0, 200, 1],
          drawThreshold: [5, 0, 20, 1]
        }
      },
      selectionWidth: [1.5, 0, 5, 0.1],
      selfReferenceSize: [20, 0, 200, 1],
      shadow: {
        enabled: false,
        color: 'rgba(0,0,0,0.5)',
        size: [10, 0, 20, 1],
        x: [5, -30, 30, 1],
        y: [5, -30, 30, 1]
      },
      smooth: {
        enabled: true,
        type: ['dynamic', 'continuous', 'discrete', 'diagonalCross', 'straightCross', 'horizontal', 'vertical', 'curvedCW', 'curvedCCW', 'cubicBezier'],
        forceDirection: ['horizontal', 'vertical', 'none'],
        roundness: [0.5, 0, 1, 0.05]
      },
      width: [1, 0, 30, 1]
    },
    layout: {
      //randomSeed: [0, 0, 500, 1],
      //improvedLayout: true,
      hierarchical: {
        enabled: false,
        levelSeparation: [150, 20, 500, 5],
        nodeSpacing: [100, 20, 500, 5],
        treeSpacing: [200, 20, 500, 5],
        blockShifting: true,
        edgeMinimization: true,
        parentCentralization: true,
        direction: ['UD', 'DU', 'LR', 'RL'], // UD, DU, LR, RL
        sortMethod: ['hubsize', 'directed'] // hubsize, directed
      }
    },
    interaction: {
      dragNodes: true,
      dragView: true,
      hideEdgesOnDrag: false,
      hideNodesOnDrag: false,
      hover: false,
      keyboard: {
        enabled: false,
        speed: { x: [10, 0, 40, 1], y: [10, 0, 40, 1], zoom: [0.02, 0, 0.1, 0.005] },
        bindToWindow: true
      },
      multiselect: false,
      navigationButtons: false,
      selectable: true,
      selectConnectedEdges: true,
      hoverConnectedEdges: true,
      tooltipDelay: [300, 0, 1000, 25],
      zoomView: true
    },
    manipulation: {
      enabled: false,
      initiallyActive: false
    },
    physics: {
      enabled: true,
      barnesHut: {
        //theta: [0.5, 0.1, 1, 0.05],
        gravitationalConstant: [-2000, -30000, 0, 50],
        centralGravity: [0.3, 0, 10, 0.05],
        springLength: [95, 0, 500, 5],
        springConstant: [0.04, 0, 1.2, 0.005],
        damping: [0.09, 0, 1, 0.01],
        avoidOverlap: [0, 0, 1, 0.01]
      },
      forceAtlas2Based: {
        //theta: [0.5, 0.1, 1, 0.05],
        gravitationalConstant: [-50, -500, 0, 1],
        centralGravity: [0.01, 0, 1, 0.005],
        springLength: [95, 0, 500, 5],
        springConstant: [0.08, 0, 1.2, 0.005],
        damping: [0.4, 0, 1, 0.01],
        avoidOverlap: [0, 0, 1, 0.01]
      },
      repulsion: {
        centralGravity: [0.2, 0, 10, 0.05],
        springLength: [200, 0, 500, 5],
        springConstant: [0.05, 0, 1.2, 0.005],
        nodeDistance: [100, 0, 500, 5],
        damping: [0.09, 0, 1, 0.01]
      },
      hierarchicalRepulsion: {
        centralGravity: [0.2, 0, 10, 0.05],
        springLength: [100, 0, 500, 5],
        springConstant: [0.01, 0, 1.2, 0.005],
        nodeDistance: [120, 0, 500, 5],
        damping: [0.09, 0, 1, 0.01]
      },
      maxVelocity: [50, 0, 150, 1],
      minVelocity: [0.1, 0.01, 0.5, 0.01],
      solver: ['barnesHut', 'forceAtlas2Based', 'repulsion', 'hierarchicalRepulsion'],
      timestep: [0.5, 0.01, 1, 0.01]
    }
  };

  exports.allOptions = allOptions;
  exports.configureOptions = configureOptions;

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // distance finding algorithm


  var _FloydWarshall = __webpack_require__(118);

  var _FloydWarshall2 = _interopRequireDefault(_FloydWarshall);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  /**
   * KamadaKawai positions the nodes initially based on
   *
   * "AN ALGORITHM FOR DRAWING GENERAL UNDIRECTED GRAPHS"
   * -- Tomihisa KAMADA and Satoru KAWAI in 1989
   *
   * Possible optimizations in the distance calculation can be implemented.
   */
  var KamadaKawai = function () {
    function KamadaKawai(body, edgeLength, edgeStrength) {
      _classCallCheck(this, KamadaKawai);

      this.body = body;
      this.springLength = edgeLength;
      this.springConstant = edgeStrength;
      this.distanceSolver = new _FloydWarshall2.default();
    }

    /**
     * Not sure if needed but can be used to update the spring length and spring constant
     * @param options
     */


    _createClass(KamadaKawai, [{
      key: "setOptions",
      value: function setOptions(options) {
        if (options) {
          if (options.springLength) {
            this.springLength = options.springLength;
          }
          if (options.springConstant) {
            this.springConstant = options.springConstant;
          }
        }
      }

      /**
       * Position the system
       * @param nodesArray
       * @param edgesArray
       */

    }, {
      key: "solve",
      value: function solve(nodesArray, edgesArray) {
        var ignoreClusters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        // get distance matrix
        var D_matrix = this.distanceSolver.getDistances(this.body, nodesArray, edgesArray); // distance matrix

        // get the L Matrix
        this._createL_matrix(D_matrix);

        // get the K Matrix
        this._createK_matrix(D_matrix);

        // calculate positions
        var threshold = 0.01;
        var innerThreshold = 1;
        var iterations = 0;
        var maxIterations = Math.max(1000, Math.min(10 * this.body.nodeIndices.length, 6000));
        var maxInnerIterations = 5;

        var maxEnergy = 1e9;
        var highE_nodeId = 0,
            dE_dx = 0,
            dE_dy = 0,
            delta_m = 0,
            subIterations = 0;

        while (maxEnergy > threshold && iterations < maxIterations) {
          iterations += 1;

          var _getHighestEnergyNode2 = this._getHighestEnergyNode(ignoreClusters);

          var _getHighestEnergyNode3 = _slicedToArray(_getHighestEnergyNode2, 4);

          highE_nodeId = _getHighestEnergyNode3[0];
          maxEnergy = _getHighestEnergyNode3[1];
          dE_dx = _getHighestEnergyNode3[2];
          dE_dy = _getHighestEnergyNode3[3];

          delta_m = maxEnergy;
          subIterations = 0;
          while (delta_m > innerThreshold && subIterations < maxInnerIterations) {
            subIterations += 1;
            this._moveNode(highE_nodeId, dE_dx, dE_dy);

            var _getEnergy2 = this._getEnergy(highE_nodeId);

            var _getEnergy3 = _slicedToArray(_getEnergy2, 3);

            delta_m = _getEnergy3[0];
            dE_dx = _getEnergy3[1];
            dE_dy = _getEnergy3[2];
          }
        }
      }

      /**
       * get the node with the highest energy
       * @returns {*[]}
       * @private
       */

    }, {
      key: "_getHighestEnergyNode",
      value: function _getHighestEnergyNode(ignoreClusters) {
        var nodesArray = this.body.nodeIndices;
        var nodes = this.body.nodes;
        var maxEnergy = 0;
        var maxEnergyNodeId = nodesArray[0];
        var dE_dx_max = 0,
            dE_dy_max = 0;

        for (var nodeIdx = 0; nodeIdx < nodesArray.length; nodeIdx++) {
          var m = nodesArray[nodeIdx];
          // by not evaluating nodes with predefined positions we should only move nodes that have no positions.
          if (nodes[m].predefinedPosition === false || nodes[m].isCluster === true && ignoreClusters === true || nodes[m].options.fixed.x === true || nodes[m].options.fixed.y === true) {
            var _getEnergy4 = this._getEnergy(m),
                _getEnergy5 = _slicedToArray(_getEnergy4, 3),
                delta_m = _getEnergy5[0],
                dE_dx = _getEnergy5[1],
                dE_dy = _getEnergy5[2];

            if (maxEnergy < delta_m) {
              maxEnergy = delta_m;
              maxEnergyNodeId = m;
              dE_dx_max = dE_dx;
              dE_dy_max = dE_dy;
            }
          }
        }

        return [maxEnergyNodeId, maxEnergy, dE_dx_max, dE_dy_max];
      }

      /**
       * calculate the energy of a single node
       * @param m
       * @returns {*[]}
       * @private
       */

    }, {
      key: "_getEnergy",
      value: function _getEnergy(m) {
        var nodesArray = this.body.nodeIndices;
        var nodes = this.body.nodes;

        var x_m = nodes[m].x;
        var y_m = nodes[m].y;
        var dE_dx = 0;
        var dE_dy = 0;
        for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {
          var i = nodesArray[iIdx];
          if (i !== m) {
            var x_i = nodes[i].x;
            var y_i = nodes[i].y;
            var denominator = 1.0 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));
            dE_dx += this.K_matrix[m][i] * (x_m - x_i - this.L_matrix[m][i] * (x_m - x_i) * denominator);
            dE_dy += this.K_matrix[m][i] * (y_m - y_i - this.L_matrix[m][i] * (y_m - y_i) * denominator);
          }
        }

        var delta_m = Math.sqrt(Math.pow(dE_dx, 2) + Math.pow(dE_dy, 2));
        return [delta_m, dE_dx, dE_dy];
      }

      /**
       * move the node based on it's energy
       * the dx and dy are calculated from the linear system proposed by Kamada and Kawai
       * @param m
       * @param dE_dx
       * @param dE_dy
       * @private
       */

    }, {
      key: "_moveNode",
      value: function _moveNode(m, dE_dx, dE_dy) {
        var nodesArray = this.body.nodeIndices;
        var nodes = this.body.nodes;
        var d2E_dx2 = 0;
        var d2E_dxdy = 0;
        var d2E_dy2 = 0;

        var x_m = nodes[m].x;
        var y_m = nodes[m].y;
        for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {
          var i = nodesArray[iIdx];
          if (i !== m) {
            var x_i = nodes[i].x;
            var y_i = nodes[i].y;
            var denominator = 1.0 / Math.pow(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2), 1.5);
            d2E_dx2 += this.K_matrix[m][i] * (1 - this.L_matrix[m][i] * Math.pow(y_m - y_i, 2) * denominator);
            d2E_dxdy += this.K_matrix[m][i] * (this.L_matrix[m][i] * (x_m - x_i) * (y_m - y_i) * denominator);
            d2E_dy2 += this.K_matrix[m][i] * (1 - this.L_matrix[m][i] * Math.pow(x_m - x_i, 2) * denominator);
          }
        }
        // make the variable names easier to make the solving of the linear system easier to read
        var A = d2E_dx2,
            B = d2E_dxdy,
            C = dE_dx,
            D = d2E_dy2,
            E = dE_dy;

        // solve the linear system for dx and dy
        var dy = (C / A + E / B) / (B / A - D / B);
        var dx = -(B * dy + C) / A;

        // move the node
        nodes[m].x += dx;
        nodes[m].y += dy;
      }

      /**
       * Create the L matrix: edge length times shortest path
       * @param D_matrix
       * @private
       */

    }, {
      key: "_createL_matrix",
      value: function _createL_matrix(D_matrix) {
        var nodesArray = this.body.nodeIndices;
        var edgeLength = this.springLength;

        this.L_matrix = [];
        for (var i = 0; i < nodesArray.length; i++) {
          this.L_matrix[nodesArray[i]] = {};
          for (var j = 0; j < nodesArray.length; j++) {
            this.L_matrix[nodesArray[i]][nodesArray[j]] = edgeLength * D_matrix[nodesArray[i]][nodesArray[j]];
          }
        }
      }

      /**
       * Create the K matrix: spring constants times shortest path
       * @param D_matrix
       * @private
       */

    }, {
      key: "_createK_matrix",
      value: function _createK_matrix(D_matrix) {
        var nodesArray = this.body.nodeIndices;
        var edgeStrength = this.springConstant;

        this.K_matrix = [];
        for (var i = 0; i < nodesArray.length; i++) {
          this.K_matrix[nodesArray[i]] = {};
          for (var j = 0; j < nodesArray.length; j++) {
            this.K_matrix[nodesArray[i]][nodesArray[j]] = edgeStrength * Math.pow(D_matrix[nodesArray[i]][nodesArray[j]], -2);
          }
        }
      }
    }]);

    return KamadaKawai;
  }();

  exports.default = KamadaKawai;

/***/ },
/* 118 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  /**
   * Created by Alex on 10-Aug-15.
   */

  var FloydWarshall = function () {
    function FloydWarshall() {
      _classCallCheck(this, FloydWarshall);
    }

    _createClass(FloydWarshall, [{
      key: "getDistances",
      value: function getDistances(body, nodesArray, edgesArray) {
        var D_matrix = {};
        var edges = body.edges;

        // prepare matrix with large numbers
        for (var i = 0; i < nodesArray.length; i++) {
          D_matrix[nodesArray[i]] = {};
          D_matrix[nodesArray[i]] = {};
          for (var j = 0; j < nodesArray.length; j++) {
            D_matrix[nodesArray[i]][nodesArray[j]] = i == j ? 0 : 1e9;
            D_matrix[nodesArray[i]][nodesArray[j]] = i == j ? 0 : 1e9;
          }
        }

        // put the weights for the edges in. This assumes unidirectionality.
        for (var _i = 0; _i < edgesArray.length; _i++) {
          var edge = edges[edgesArray[_i]];
          // edge has to be connected if it counts to the distances. If it is connected to inner clusters it will crash so we also check if it is in the D_matrix
          if (edge.connected === true && D_matrix[edge.fromId] !== undefined && D_matrix[edge.toId] !== undefined) {
            D_matrix[edge.fromId][edge.toId] = 1;
            D_matrix[edge.toId][edge.fromId] = 1;
          }
        }

        var nodeCount = nodesArray.length;

        // Adapted FloydWarshall based on unidirectionality to greatly reduce complexity.
        for (var k = 0; k < nodeCount; k++) {
          for (var _i2 = 0; _i2 < nodeCount - 1; _i2++) {
            for (var _j = _i2 + 1; _j < nodeCount; _j++) {
              D_matrix[nodesArray[_i2]][nodesArray[_j]] = Math.min(D_matrix[nodesArray[_i2]][nodesArray[_j]], D_matrix[nodesArray[_i2]][nodesArray[k]] + D_matrix[nodesArray[k]][nodesArray[_j]]);
              D_matrix[nodesArray[_j]][nodesArray[_i2]] = D_matrix[nodesArray[_i2]][nodesArray[_j]];
            }
          }
        }

        return D_matrix;
      }
    }]);

    return FloydWarshall;
  }();

  exports.default = FloydWarshall;

/***/ },
/* 119 */
/***/ function(module, exports) {

  'use strict';

  /**
   * Canvas shapes used by Network
   */
  if (typeof CanvasRenderingContext2D !== 'undefined') {

    /**
     * Draw a circle shape
     */
    CanvasRenderingContext2D.prototype.circle = function (x, y, r) {
      this.beginPath();
      this.arc(x, y, r, 0, 2 * Math.PI, false);
      this.closePath();
    };

    /**
     * Draw a square shape
     * @param {Number} x horizontal center
     * @param {Number} y vertical center
     * @param {Number} r   size, width and height of the square
     */
    CanvasRenderingContext2D.prototype.square = function (x, y, r) {
      this.beginPath();
      this.rect(x - r, y - r, r * 2, r * 2);
      this.closePath();
    };

    /**
     * Draw a triangle shape
     * @param {Number} x horizontal center
     * @param {Number} y vertical center
     * @param {Number} r   radius, half the length of the sides of the triangle
     */
    CanvasRenderingContext2D.prototype.triangle = function (x, y, r) {
      // http://en.wikipedia.org/wiki/Equilateral_triangle
      this.beginPath();

      // the change in radius and the offset is here to center the shape
      r *= 1.15;
      y += 0.275 * r;

      var s = r * 2;
      var s2 = s / 2;
      var ir = Math.sqrt(3) / 6 * s; // radius of inner circle
      var h = Math.sqrt(s * s - s2 * s2); // height


      this.moveTo(x, y - (h - ir));
      this.lineTo(x + s2, y + ir);
      this.lineTo(x - s2, y + ir);
      this.lineTo(x, y - (h - ir));
      this.closePath();
    };

    /**
     * Draw a triangle shape in downward orientation
     * @param {Number} x horizontal center
     * @param {Number} y vertical center
     * @param {Number} r radius
     */
    CanvasRenderingContext2D.prototype.triangleDown = function (x, y, r) {
      // http://en.wikipedia.org/wiki/Equilateral_triangle
      this.beginPath();

      // the change in radius and the offset is here to center the shape
      r *= 1.15;
      y -= 0.275 * r;

      var s = r * 2;
      var s2 = s / 2;
      var ir = Math.sqrt(3) / 6 * s; // radius of inner circle
      var h = Math.sqrt(s * s - s2 * s2); // height

      this.moveTo(x, y + (h - ir));
      this.lineTo(x + s2, y - ir);
      this.lineTo(x - s2, y - ir);
      this.lineTo(x, y + (h - ir));
      this.closePath();
    };

    /**
     * Draw a star shape, a star with 5 points
     * @param {Number} x horizontal center
     * @param {Number} y vertical center
     * @param {Number} r   radius, half the length of the sides of the triangle
     */
    CanvasRenderingContext2D.prototype.star = function (x, y, r) {
      // http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/
      this.beginPath();

      // the change in radius and the offset is here to center the shape
      r *= 0.82;
      y += 0.1 * r;

      for (var n = 0; n < 10; n++) {
        var radius = n % 2 === 0 ? r * 1.3 : r * 0.5;
        this.lineTo(x + radius * Math.sin(n * 2 * Math.PI / 10), y - radius * Math.cos(n * 2 * Math.PI / 10));
      }

      this.closePath();
    };

    /**
     * Draw a Diamond shape
     * @param {Number} x horizontal center
     * @param {Number} y vertical center
     * @param {Number} r   radius, half the length of the sides of the triangle
     */
    CanvasRenderingContext2D.prototype.diamond = function (x, y, r) {
      // http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/
      this.beginPath();

      this.lineTo(x, y + r);
      this.lineTo(x + r, y);
      this.lineTo(x, y - r);
      this.lineTo(x - r, y);

      this.closePath();
    };

    /**
     * http://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas
     */
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
      var r2d = Math.PI / 180;
      if (w - 2 * r < 0) {
        r = w / 2;
      } //ensure that the radius isn't too large for x
      if (h - 2 * r < 0) {
        r = h / 2;
      } //ensure that the radius isn't too large for y
      this.beginPath();
      this.moveTo(x + r, y);
      this.lineTo(x + w - r, y);
      this.arc(x + w - r, y + r, r, r2d * 270, r2d * 360, false);
      this.lineTo(x + w, y + h - r);
      this.arc(x + w - r, y + h - r, r, 0, r2d * 90, false);
      this.lineTo(x + r, y + h);
      this.arc(x + r, y + h - r, r, r2d * 90, r2d * 180, false);
      this.lineTo(x, y + r);
      this.arc(x + r, y + r, r, r2d * 180, r2d * 270, false);
      this.closePath();
    };

    /**
     * http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
     */
    CanvasRenderingContext2D.prototype.ellipse = function (x, y, w, h) {
      var kappa = .5522848,
          ox = w / 2 * kappa,
          // control point offset horizontal
      oy = h / 2 * kappa,
          // control point offset vertical
      xe = x + w,
          // x-end
      ye = y + h,
          // y-end
      xm = x + w / 2,
          // x-middle
      ym = y + h / 2; // y-middle

      this.beginPath();
      this.moveTo(x, ym);
      this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
      this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
      this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
      this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
      this.closePath();
    };

    /**
     * http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
     */
    CanvasRenderingContext2D.prototype.database = function (x, y, w, h) {
      var f = 1 / 3;
      var wEllipse = w;
      var hEllipse = h * f;

      var kappa = .5522848,
          ox = wEllipse / 2 * kappa,
          // control point offset horizontal
      oy = hEllipse / 2 * kappa,
          // control point offset vertical
      xe = x + wEllipse,
          // x-end
      ye = y + hEllipse,
          // y-end
      xm = x + wEllipse / 2,
          // x-middle
      ym = y + hEllipse / 2,
          // y-middle
      ymb = y + (h - hEllipse / 2),
          // y-midlle, bottom ellipse
      yeb = y + h; // y-end, bottom ellipse

      this.beginPath();
      this.moveTo(xe, ym);

      this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
      this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);

      this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
      this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);

      this.lineTo(xe, ymb);

      this.bezierCurveTo(xe, ymb + oy, xm + ox, yeb, xm, yeb);
      this.bezierCurveTo(xm - ox, yeb, x, ymb + oy, x, ymb);

      this.lineTo(x, ym);
    };

    /**
     * Draw an arrow at the end of a line with the given angle.
     */
    CanvasRenderingContext2D.prototype.arrowEndpoint = function (x, y, angle, length) {
      // tail
      var xt = x - length * Math.cos(angle);
      var yt = y - length * Math.sin(angle);

      // inner tail
      var xi = x - length * 0.9 * Math.cos(angle);
      var yi = y - length * 0.9 * Math.sin(angle);

      // left
      var xl = xt + length / 3 * Math.cos(angle + 0.5 * Math.PI);
      var yl = yt + length / 3 * Math.sin(angle + 0.5 * Math.PI);

      // right
      var xr = xt + length / 3 * Math.cos(angle - 0.5 * Math.PI);
      var yr = yt + length / 3 * Math.sin(angle - 0.5 * Math.PI);

      this.beginPath();
      this.moveTo(x, y);
      this.lineTo(xl, yl);
      this.lineTo(xi, yi);
      this.lineTo(xr, yr);
      this.closePath();
    };

    /**
     * Draw an circle an the end of an line with the given angle.
     */
    CanvasRenderingContext2D.prototype.circleEndpoint = function (x, y, angle, length) {
      var radius = length * 0.4;
      var xc = x - radius * Math.cos(angle);
      var yc = y - radius * Math.sin(angle);
      this.circle(xc, yc, radius);
    };

    /**
     * Sets up the dashedLine functionality for drawing
     * Original code came from http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas
     * @author David Jordan
     * @date 2012-08-08
     */
    CanvasRenderingContext2D.prototype.dashedLine = function (x, y, x2, y2, pattern) {
      this.beginPath();
      this.moveTo(x, y);

      var patternLength = pattern.length;
      var dx = x2 - x;
      var dy = y2 - y;
      var slope = dy / dx;
      var distRemaining = Math.sqrt(dx * dx + dy * dy);
      var patternIndex = 0;
      var draw = true;
      var xStep = 0;
      var dashLength = pattern[0];

      while (distRemaining >= 0.1) {
        dashLength = pattern[patternIndex++ % patternLength];
        if (dashLength > distRemaining) {
          dashLength = distRemaining;
        }

        xStep = Math.sqrt(dashLength * dashLength / (1 + slope * slope));
        xStep = dx < 0 ? -xStep : xStep;
        x += xStep;
        y += slope * xStep;

        if (draw === true) {
          this.lineTo(x, y);
        } else {
          this.moveTo(x, y);
        }

        distRemaining -= dashLength;
        draw = !draw;
      }
    };
  }

/***/ },
/* 120 */
/***/ function(module, exports) {

  'use strict';

  /**
   * Parse a text source containing data in DOT language into a JSON object.
   * The object contains two lists: one with nodes and one with edges.
   *
   * DOT language reference: http://www.graphviz.org/doc/info/lang.html
   *
   * DOT language attributes: http://graphviz.org/content/attrs
   *
   * @param {String} data     Text containing a graph in DOT-notation
   * @return {Object} graph   An object containing two parameters:
   *                          {Object[]} nodes
   *                          {Object[]} edges
   */
  function parseDOT(data) {
    dot = data;
    return parseGraph();
  }

  // mapping of attributes from DOT (the keys) to vis.js (the values)
  var NODE_ATTR_MAPPING = {
    'fontsize': 'font.size',
    'fontcolor': 'font.color',
    'labelfontcolor': 'font.color',
    'fontname': 'font.face',
    'color': ['color.border', 'color.background'],
    'fillcolor': 'color.background',
    'tooltip': 'title',
    'labeltooltip': 'title'
  };
  var EDGE_ATTR_MAPPING = Object.create(NODE_ATTR_MAPPING);
  EDGE_ATTR_MAPPING.color = 'color.color';

  // token types enumeration
  var TOKENTYPE = {
    NULL: 0,
    DELIMITER: 1,
    IDENTIFIER: 2,
    UNKNOWN: 3
  };

  // map with all delimiters
  var DELIMITERS = {
    '{': true,
    '}': true,
    '[': true,
    ']': true,
    ';': true,
    '=': true,
    ',': true,

    '->': true,
    '--': true
  };

  var dot = ''; // current dot file
  var index = 0; // current index in dot file
  var c = ''; // current token character in expr
  var token = ''; // current token
  var tokenType = TOKENTYPE.NULL; // type of the token

  /**
   * Get the first character from the dot file.
   * The character is stored into the char c. If the end of the dot file is
   * reached, the function puts an empty string in c.
   */
  function first() {
    index = 0;
    c = dot.charAt(0);
  }

  /**
   * Get the next character from the dot file.
   * The character is stored into the char c. If the end of the dot file is
   * reached, the function puts an empty string in c.
   */
  function next() {
    index++;
    c = dot.charAt(index);
  }

  /**
   * Preview the next character from the dot file.
   * @return {String} cNext
   */
  function nextPreview() {
    return dot.charAt(index + 1);
  }

  /**
   * Test whether given character is alphabetic or numeric
   * @param {String} c
   * @return {Boolean} isAlphaNumeric
   */
  var regexAlphaNumeric = /[a-zA-Z_0-9.:#]/;
  function isAlphaNumeric(c) {
    return regexAlphaNumeric.test(c);
  }

  /**
   * Merge all options of object b into object b
   * @param {Object} a
   * @param {Object} b
   * @return {Object} a
   */
  function merge(a, b) {
    if (!a) {
      a = {};
    }

    if (b) {
      for (var name in b) {
        if (b.hasOwnProperty(name)) {
          a[name] = b[name];
        }
      }
    }
    return a;
  }

  /**
   * Set a value in an object, where the provided parameter name can be a
   * path with nested parameters. For example:
   *
   *     var obj = {a: 2};
   *     setValue(obj, 'b.c', 3);     // obj = {a: 2, b: {c: 3}}
   *
   * @param {Object} obj
   * @param {String} path  A parameter name or dot-separated parameter path,
   *                      like "color.highlight.border".
   * @param {*} value
   */
  function setValue(obj, path, value) {
    var keys = path.split('.');
    var o = obj;
    while (keys.length) {
      var key = keys.shift();
      if (keys.length) {
        // this isn't the end point
        if (!o[key]) {
          o[key] = {};
        }
        o = o[key];
      } else {
        // this is the end point
        o[key] = value;
      }
    }
  }

  /**
   * Add a node to a graph object. If there is already a node with
   * the same id, their attributes will be merged.
   * @param {Object} graph
   * @param {Object} node
   */
  function addNode(graph, node) {
    var i, len;
    var current = null;

    // find root graph (in case of subgraph)
    var graphs = [graph]; // list with all graphs from current graph to root graph
    var root = graph;
    while (root.parent) {
      graphs.push(root.parent);
      root = root.parent;
    }

    // find existing node (at root level) by its id
    if (root.nodes) {
      for (i = 0, len = root.nodes.length; i < len; i++) {
        if (node.id === root.nodes[i].id) {
          current = root.nodes[i];
          break;
        }
      }
    }

    if (!current) {
      // this is a new node
      current = {
        id: node.id
      };
      if (graph.node) {
        // clone default attributes
        current.attr = merge(current.attr, graph.node);
      }
    }

    // add node to this (sub)graph and all its parent graphs
    for (i = graphs.length - 1; i >= 0; i--) {
      var g = graphs[i];

      if (!g.nodes) {
        g.nodes = [];
      }
      if (g.nodes.indexOf(current) === -1) {
        g.nodes.push(current);
      }
    }

    // merge attributes
    if (node.attr) {
      current.attr = merge(current.attr, node.attr);
    }
  }

  /**
   * Add an edge to a graph object
   * @param {Object} graph
   * @param {Object} edge
   */
  function addEdge(graph, edge) {
    if (!graph.edges) {
      graph.edges = [];
    }
    graph.edges.push(edge);
    if (graph.edge) {
      var attr = merge({}, graph.edge); // clone default attributes
      edge.attr = merge(attr, edge.attr); // merge attributes
    }
  }

  /**
   * Create an edge to a graph object
   * @param {Object} graph
   * @param {String | Number | Object} from
   * @param {String | Number | Object} to
   * @param {String} type
   * @param {Object | null} attr
   * @return {Object} edge
   */
  function createEdge(graph, from, to, type, attr) {
    var edge = {
      from: from,
      to: to,
      type: type
    };

    if (graph.edge) {
      edge.attr = merge({}, graph.edge); // clone default attributes
    }
    edge.attr = merge(edge.attr || {}, attr); // merge attributes

    return edge;
  }

  /**
   * Get next token in the current dot file.
   * The token and token type are available as token and tokenType
   */
  function getToken() {
    tokenType = TOKENTYPE.NULL;
    token = '';

    // skip over whitespaces
    while (c === ' ' || c === '\t' || c === '\n' || c === '\r') {
      // space, tab, enter
      next();
    }

    do {
      var isComment = false;

      // skip comment
      if (c === '#') {
        // find the previous non-space character
        var i = index - 1;
        while (dot.charAt(i) === ' ' || dot.charAt(i) === '\t') {
          i--;
        }
        if (dot.charAt(i) === '\n' || dot.charAt(i) === '') {
          // the # is at the start of a line, this is indeed a line comment
          while (c != '' && c != '\n') {
            next();
          }
          isComment = true;
        }
      }
      if (c === '/' && nextPreview() === '/') {
        // skip line comment
        while (c != '' && c != '\n') {
          next();
        }
        isComment = true;
      }
      if (c === '/' && nextPreview() === '*') {
        // skip block comment
        while (c != '') {
          if (c === '*' && nextPreview() === '/') {
            // end of block comment found. skip these last two characters
            next();
            next();
            break;
          } else {
            next();
          }
        }
        isComment = true;
      }

      // skip over whitespaces
      while (c === ' ' || c === '\t' || c === '\n' || c === '\r') {
        // space, tab, enter
        next();
      }
    } while (isComment);

    // check for end of dot file
    if (c === '') {
      // token is still empty
      tokenType = TOKENTYPE.DELIMITER;
      return;
    }

    // check for delimiters consisting of 2 characters
    var c2 = c + nextPreview();
    if (DELIMITERS[c2]) {
      tokenType = TOKENTYPE.DELIMITER;
      token = c2;
      next();
      next();
      return;
    }

    // check for delimiters consisting of 1 character
    if (DELIMITERS[c]) {
      tokenType = TOKENTYPE.DELIMITER;
      token = c;
      next();
      return;
    }

    // check for an identifier (number or string)
    // TODO: more precise parsing of numbers/strings (and the port separator ':')
    if (isAlphaNumeric(c) || c === '-') {
      token += c;
      next();

      while (isAlphaNumeric(c)) {
        token += c;
        next();
      }
      if (token === 'false') {
        token = false; // convert to boolean
      } else if (token === 'true') {
        token = true; // convert to boolean
      } else if (!isNaN(Number(token))) {
        token = Number(token); // convert to number
      }
      tokenType = TOKENTYPE.IDENTIFIER;
      return;
    }

    // check for a string enclosed by double quotes
    if (c === '"') {
      next();
      while (c != '' && (c != '"' || c === '"' && nextPreview() === '"')) {
        token += c;
        if (c === '"') {
          // skip the escape character
          next();
        }
        next();
      }
      if (c != '"') {
        throw newSyntaxError('End of string " expected');
      }
      next();
      tokenType = TOKENTYPE.IDENTIFIER;
      return;
    }

    // something unknown is found, wrong characters, a syntax error
    tokenType = TOKENTYPE.UNKNOWN;
    while (c != '') {
      token += c;
      next();
    }
    throw new SyntaxError('Syntax error in part "' + chop(token, 30) + '"');
  }

  /**
   * Parse a graph.
   * @returns {Object} graph
   */
  function parseGraph() {
    var graph = {};

    first();
    getToken();

    // optional strict keyword
    if (token === 'strict') {
      graph.strict = true;
      getToken();
    }

    // graph or digraph keyword
    if (token === 'graph' || token === 'digraph') {
      graph.type = token;
      getToken();
    }

    // optional graph id
    if (tokenType === TOKENTYPE.IDENTIFIER) {
      graph.id = token;
      getToken();
    }

    // open angle bracket
    if (token != '{') {
      throw newSyntaxError('Angle bracket { expected');
    }
    getToken();

    // statements
    parseStatements(graph);

    // close angle bracket
    if (token != '}') {
      throw newSyntaxError('Angle bracket } expected');
    }
    getToken();

    // end of file
    if (token !== '') {
      throw newSyntaxError('End of file expected');
    }
    getToken();

    // remove temporary default options
    delete graph.node;
    delete graph.edge;
    delete graph.graph;

    return graph;
  }

  /**
   * Parse a list with statements.
   * @param {Object} graph
   */
  function parseStatements(graph) {
    while (token !== '' && token != '}') {
      parseStatement(graph);
      if (token === ';') {
        getToken();
      }
    }
  }

  /**
   * Parse a single statement. Can be a an attribute statement, node
   * statement, a series of node statements and edge statements, or a
   * parameter.
   * @param {Object} graph
   */
  function parseStatement(graph) {
    // parse subgraph
    var subgraph = parseSubgraph(graph);
    if (subgraph) {
      // edge statements
      parseEdge(graph, subgraph);

      return;
    }

    // parse an attribute statement
    var attr = parseAttributeStatement(graph);
    if (attr) {
      return;
    }

    // parse node
    if (tokenType != TOKENTYPE.IDENTIFIER) {
      throw newSyntaxError('Identifier expected');
    }
    var id = token; // id can be a string or a number
    getToken();

    if (token === '=') {
      // id statement
      getToken();
      if (tokenType != TOKENTYPE.IDENTIFIER) {
        throw newSyntaxError('Identifier expected');
      }
      graph[id] = token;
      getToken();
      // TODO: implement comma separated list with "a_list: ID=ID [','] [a_list] "
    } else {
      parseNodeStatement(graph, id);
    }
  }

  /**
   * Parse a subgraph
   * @param {Object} graph    parent graph object
   * @return {Object | null} subgraph
   */
  function parseSubgraph(graph) {
    var subgraph = null;

    // optional subgraph keyword
    if (token === 'subgraph') {
      subgraph = {};
      subgraph.type = 'subgraph';
      getToken();

      // optional graph id
      if (tokenType === TOKENTYPE.IDENTIFIER) {
        subgraph.id = token;
        getToken();
      }
    }

    // open angle bracket
    if (token === '{') {
      getToken();

      if (!subgraph) {
        subgraph = {};
      }
      subgraph.parent = graph;
      subgraph.node = graph.node;
      subgraph.edge = graph.edge;
      subgraph.graph = graph.graph;

      // statements
      parseStatements(subgraph);

      // close angle bracket
      if (token != '}') {
        throw newSyntaxError('Angle bracket } expected');
      }
      getToken();

      // remove temporary default options
      delete subgraph.node;
      delete subgraph.edge;
      delete subgraph.graph;
      delete subgraph.parent;

      // register at the parent graph
      if (!graph.subgraphs) {
        graph.subgraphs = [];
      }
      graph.subgraphs.push(subgraph);
    }

    return subgraph;
  }

  /**
   * parse an attribute statement like "node [shape=circle fontSize=16]".
   * Available keywords are 'node', 'edge', 'graph'.
   * The previous list with default attributes will be replaced
   * @param {Object} graph
   * @returns {String | null} keyword Returns the name of the parsed attribute
   *                                  (node, edge, graph), or null if nothing
   *                                  is parsed.
   */
  function parseAttributeStatement(graph) {
    // attribute statements
    if (token === 'node') {
      getToken();

      // node attributes
      graph.node = parseAttributeList();
      return 'node';
    } else if (token === 'edge') {
      getToken();

      // edge attributes
      graph.edge = parseAttributeList();
      return 'edge';
    } else if (token === 'graph') {
      getToken();

      // graph attributes
      graph.graph = parseAttributeList();
      return 'graph';
    }

    return null;
  }

  /**
   * parse a node statement
   * @param {Object} graph
   * @param {String | Number} id
   */
  function parseNodeStatement(graph, id) {
    // node statement
    var node = {
      id: id
    };
    var attr = parseAttributeList();
    if (attr) {
      node.attr = attr;
    }
    addNode(graph, node);

    // edge statements
    parseEdge(graph, id);
  }

  /**
   * Parse an edge or a series of edges
   * @param {Object} graph
   * @param {String | Number} from        Id of the from node
   */
  function parseEdge(graph, from) {
    while (token === '->' || token === '--') {
      var to;
      var type = token;
      getToken();

      var subgraph = parseSubgraph(graph);
      if (subgraph) {
        to = subgraph;
      } else {
        if (tokenType != TOKENTYPE.IDENTIFIER) {
          throw newSyntaxError('Identifier or subgraph expected');
        }
        to = token;
        addNode(graph, {
          id: to
        });
        getToken();
      }

      // parse edge attributes
      var attr = parseAttributeList();

      // create edge
      var edge = createEdge(graph, from, to, type, attr);
      addEdge(graph, edge);

      from = to;
    }
  }

  /**
   * Parse a set with attributes,
   * for example [label="1.000", shape=solid]
   * @return {Object | null} attr
   */
  function parseAttributeList() {
    var attr = null;

    while (token === '[') {
      getToken();
      attr = {};
      while (token !== '' && token != ']') {
        if (tokenType != TOKENTYPE.IDENTIFIER) {
          throw newSyntaxError('Attribute name expected');
        }
        var name = token;

        getToken();
        if (token != '=') {
          throw newSyntaxError('Equal sign = expected');
        }
        getToken();

        if (tokenType != TOKENTYPE.IDENTIFIER) {
          throw newSyntaxError('Attribute value expected');
        }
        var value = token;
        setValue(attr, name, value); // name can be a path

        getToken();
        if (token == ',') {
          getToken();
        }
      }

      if (token != ']') {
        throw newSyntaxError('Bracket ] expected');
      }
      getToken();
    }

    return attr;
  }

  /**
   * Create a syntax error with extra information on current token and index.
   * @param {String} message
   * @returns {SyntaxError} err
   */
  function newSyntaxError(message) {
    return new SyntaxError(message + ', got "' + chop(token, 30) + '" (char ' + index + ')');
  }

  /**
   * Chop off text after a maximum length
   * @param {String} text
   * @param {Number} maxLength
   * @returns {String}
   */
  function chop(text, maxLength) {
    return text.length <= maxLength ? text : text.substr(0, 27) + '...';
  }

  /**
   * Execute a function fn for each pair of elements in two arrays
   * @param {Array | *} array1
   * @param {Array | *} array2
   * @param {function} fn
   */
  function forEach2(array1, array2, fn) {
    if (Array.isArray(array1)) {
      array1.forEach(function (elem1) {
        if (Array.isArray(array2)) {
          array2.forEach(function (elem2) {
            fn(elem1, elem2);
          });
        } else {
          fn(elem1, array2);
        }
      });
    } else {
      if (Array.isArray(array2)) {
        array2.forEach(function (elem2) {
          fn(array1, elem2);
        });
      } else {
        fn(array1, array2);
      }
    }
  }

  /**
   * Set a nested property on an object
   * When nested objects are missing, they will be created.
   * For example setProp({}, 'font.color', 'red') will return {font: {color: 'red'}}
   * @param {Object} object
   * @param {string} path   A dot separated string like 'font.color'
   * @param {*} value       Value for the property
   * @return {Object} Returns the original object, allows for chaining.
   */
  function setProp(object, path, value) {
    var names = path.split('.');
    var prop = names.pop();

    // traverse over the nested objects
    var obj = object;
    for (var i = 0; i < names.length; i++) {
      var name = names[i];
      if (!(name in obj)) {
        obj[name] = {};
      }
      obj = obj[name];
    }

    // set the property value
    obj[prop] = value;

    return object;
  }

  /**
   * Convert an object with DOT attributes to their vis.js equivalents.
   * @param {Object} attr     Object with DOT attributes
   * @param {Object} mapping
   * @return {Object}         Returns an object with vis.js attributes
   */
  function convertAttr(attr, mapping) {
    var converted = {};

    for (var prop in attr) {
      if (attr.hasOwnProperty(prop)) {
        var visProp = mapping[prop];
        if (Array.isArray(visProp)) {
          visProp.forEach(function (visPropI) {
            setProp(converted, visPropI, attr[prop]);
          });
        } else if (typeof visProp === 'string') {
          setProp(converted, visProp, attr[prop]);
        } else {
          setProp(converted, prop, attr[prop]);
        }
      }
    }

    return converted;
  }

  /**
   * Convert a string containing a graph in DOT language into a map containing
   * with nodes and edges in the format of graph.
   * @param {String} data         Text containing a graph in DOT-notation
   * @return {Object} graphData
   */
  function DOTToGraph(data) {
    // parse the DOT file
    var dotData = parseDOT(data);
    var graphData = {
      nodes: [],
      edges: [],
      options: {}
    };

    // copy the nodes
    if (dotData.nodes) {
      dotData.nodes.forEach(function (dotNode) {
        var graphNode = {
          id: dotNode.id,
          label: String(dotNode.label || dotNode.id)
        };
        merge(graphNode, convertAttr(dotNode.attr, NODE_ATTR_MAPPING));
        if (graphNode.image) {
          graphNode.shape = 'image';
        }
        graphData.nodes.push(graphNode);
      });
    }

    // copy the edges
    if (dotData.edges) {
      /**
       * Convert an edge in DOT format to an edge with VisGraph format
       * @param {Object} dotEdge
       * @returns {Object} graphEdge
       */
      var convertEdge = function convertEdge(dotEdge) {
        var graphEdge = {
          from: dotEdge.from,
          to: dotEdge.to
        };
        merge(graphEdge, convertAttr(dotEdge.attr, EDGE_ATTR_MAPPING));
        graphEdge.arrows = dotEdge.type === '->' ? 'to' : undefined;

        return graphEdge;
      };

      dotData.edges.forEach(function (dotEdge) {
        var from, to;
        if (dotEdge.from instanceof Object) {
          from = dotEdge.from.nodes;
        } else {
          from = {
            id: dotEdge.from
          };
        }

        // TODO: support of solid/dotted/dashed edges (attr = 'style')
        // TODO: support for attributes 'dir' and 'arrowhead' (edge arrows)

        if (dotEdge.to instanceof Object) {
          to = dotEdge.to.nodes;
        } else {
          to = {
            id: dotEdge.to
          };
        }

        if (dotEdge.from instanceof Object && dotEdge.from.edges) {
          dotEdge.from.edges.forEach(function (subEdge) {
            var graphEdge = convertEdge(subEdge);
            graphData.edges.push(graphEdge);
          });
        }

        forEach2(from, to, function (from, to) {
          var subEdge = createEdge(graphData, from.id, to.id, dotEdge.type, dotEdge.attr);
          var graphEdge = convertEdge(subEdge);
          graphData.edges.push(graphEdge);
        });

        if (dotEdge.to instanceof Object && dotEdge.to.edges) {
          dotEdge.to.edges.forEach(function (subEdge) {
            var graphEdge = convertEdge(subEdge);
            graphData.edges.push(graphEdge);
          });
        }
      });
    }

    // copy the options
    if (dotData.attr) {
      graphData.options = dotData.attr;
    }

    return graphData;
  }

  // exports
  exports.parseDOT = parseDOT;
  exports.DOTToGraph = DOTToGraph;

/***/ },
/* 121 */
/***/ function(module, exports) {

  'use strict';

  function parseGephi(gephiJSON, optionsObj) {
    var edges = [];
    var nodes = [];
    var options = {
      edges: {
        inheritColor: false
      },
      nodes: {
        fixed: false,
        parseColor: false
      }
    };

    if (optionsObj !== undefined) {
      if (optionsObj.fixed !== undefined) {
        options.nodes.fixed = optionsObj.fixed;
      }
      if (optionsObj.parseColor !== undefined) {
        options.nodes.parseColor = optionsObj.parseColor;
      }
      if (optionsObj.inheritColor !== undefined) {
        options.edges.inheritColor = optionsObj.inheritColor;
      }
    }

    var gEdges = gephiJSON.edges;
    var gNodes = gephiJSON.nodes;
    for (var i = 0; i < gEdges.length; i++) {
      var edge = {};
      var gEdge = gEdges[i];
      edge['id'] = gEdge.id;
      edge['from'] = gEdge.source;
      edge['to'] = gEdge.target;
      edge['attributes'] = gEdge.attributes;
      edge['label'] = gEdge.label;
      edge['title'] = gEdge.attributes !== undefined ? gEdge.attributes.title : undefined;
      if (gEdge['type'] === 'Directed') {
        edge['arrows'] = 'to';
      }
      //    edge['value'] = gEdge.attributes !== undefined ? gEdge.attributes.Weight : undefined;
      //    edge['width'] = edge['value'] !== undefined ? undefined : edgegEdge.size;
      if (gEdge.color && options.inheritColor === false) {
        edge['color'] = gEdge.color;
      }
      edges.push(edge);
    }

    for (var i = 0; i < gNodes.length; i++) {
      var node = {};
      var gNode = gNodes[i];
      node['id'] = gNode.id;
      node['attributes'] = gNode.attributes;
      node['title'] = gNode.title;
      node['x'] = gNode.x;
      node['y'] = gNode.y;
      node['label'] = gNode.label;
      node['title'] = gNode.attributes !== undefined ? gNode.attributes.title : undefined;
      if (options.nodes.parseColor === true) {
        node['color'] = gNode.color;
      } else {
        node['color'] = gNode.color !== undefined ? { background: gNode.color, border: gNode.color, highlight: { background: gNode.color, border: gNode.color }, hover: { background: gNode.color, border: gNode.color } } : undefined;
      }
      node['size'] = gNode.size;
      node['fixed'] = options.nodes.fixed && gNode.x !== undefined && gNode.y !== undefined;
      nodes.push(node);
    }

    return { nodes: nodes, edges: edges };
  }

  exports.parseGephi = parseGephi;

/***/ },
/* 122 */
/***/ function(module, exports) {

  'use strict';

  // English
  exports['en'] = {
    edit: 'Edit',
    del: 'Delete selected',
    back: 'Back',
    addNode: 'Add Node',
    addEdge: 'Add Edge',
    editNode: 'Edit Node',
    editEdge: 'Edit Edge',
    addDescription: 'Click in an empty space to place a new node.',
    edgeDescription: 'Click on a node and drag the edge to another node to connect them.',
    editEdgeDescription: 'Click on the control points and drag them to a node to connect to it.',
    createEdgeError: 'Cannot link edges to a cluster.',
    deleteClusterError: 'Clusters cannot be deleted.',
    editClusterError: 'Clusters cannot be edited.'
  };
  exports['en_EN'] = exports['en'];
  exports['en_US'] = exports['en'];

  // German
  exports['de'] = {
    edit: 'Editieren',
    del: 'L\xF6sche Auswahl',
    back: 'Zur\xFCck',
    addNode: 'Knoten hinzuf\xFCgen',
    addEdge: 'Kante hinzuf\xFCgen',
    editNode: 'Knoten editieren',
    editEdge: 'Kante editieren',
    addDescription: 'Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.',
    edgeDescription: 'Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.',
    editEdgeDescription: 'Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.',
    createEdgeError: 'Es ist nicht m\xF6glich, Kanten mit Clustern zu verbinden.',
    deleteClusterError: 'Cluster k\xF6nnen nicht gel\xF6scht werden.',
    editClusterError: 'Cluster k\xF6nnen nicht editiert werden.'
  };
  exports['de_DE'] = exports['de'];

  // Spanish
  exports['es'] = {
    edit: 'Editar',
    del: 'Eliminar selecci\xF3n',
    back: '\xC1tras',
    addNode: 'A\xF1adir nodo',
    addEdge: 'A\xF1adir arista',
    editNode: 'Editar nodo',
    editEdge: 'Editar arista',
    addDescription: 'Haga clic en un lugar vac\xEDo para colocar un nuevo nodo.',
    edgeDescription: 'Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.',
    editEdgeDescription: 'Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.',
    createEdgeError: 'No se puede conectar una arista a un grupo.',
    deleteClusterError: 'No es posible eliminar grupos.',
    editClusterError: 'No es posible editar grupos.'
  };
  exports['es_ES'] = exports['es'];

  //Italiano
  exports['it'] = {
    edit: 'Modifica',
    del: 'Cancella la selezione',
    back: 'Indietro',
    addNode: 'Aggiungi un nodo',
    addEdge: 'Aggiungi un vertice',
    editNode: 'Modifica il nodo',
    editEdge: 'Modifica il vertice',
    addDescription: 'Clicca per aggiungere un nuovo nodo',
    edgeDescription: 'Clicca su un nodo e trascinalo ad un altro nodo per connetterli.',
    editEdgeDescription: 'Clicca sui Punti di controllo e trascinali ad un nodo per connetterli.',
    createEdgeError: 'Non si possono collegare vertici ad un cluster',
    deleteClusterError: 'I cluster non possono essere cancellati',
    editClusterError: 'I clusters non possono essere modificati.'
  };
  exports['it_IT'] = exports['it'];

  // Dutch
  exports['nl'] = {
    edit: 'Wijzigen',
    del: 'Selectie verwijderen',
    back: 'Terug',
    addNode: 'Node toevoegen',
    addEdge: 'Link toevoegen',
    editNode: 'Node wijzigen',
    editEdge: 'Link wijzigen',
    addDescription: 'Klik op een leeg gebied om een nieuwe node te maken.',
    edgeDescription: 'Klik op een node en sleep de link naar een andere node om ze te verbinden.',
    editEdgeDescription: 'Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.',
    createEdgeError: 'Kan geen link maken naar een cluster.',
    deleteClusterError: 'Clusters kunnen niet worden verwijderd.',
    editClusterError: 'Clusters kunnen niet worden aangepast.'
  };
  exports['nl_NL'] = exports['nl'];
  exports['nl_BE'] = exports['nl'];

  // Portuguese Brazil
  exports['pt-br'] = {
    edit: 'Editar',
    del: 'Remover selecionado',
    back: 'Voltar',
    addNode: 'Adicionar n',
    addEdge: 'Adicionar aresta',
    editNode: 'Editar n',
    editEdge: 'Editar aresta',
    addDescription: 'Clique em um espao em branco para adicionar um novo n',
    edgeDescription: 'Clique em um n e arraste a aresta at outro n para conect-los',
    editEdgeDescription: 'Clique nos pontos de controle e os arraste para um n para conect-los',
    createEdgeError: 'No foi possvel linkar arestas a um cluster.',
    deleteClusterError: 'Clusters no puderam ser removidos.',
    editClusterError: 'Clusters no puderam ser editados.'
  };
  exports['pt-BR'] = exports['pt-br'];
  exports['pt_BR'] = exports['pt-br'];
  exports['pt_br'] = exports['pt-br'];

  // Russian
  exports['ru'] = {
    edit: '',
    del: ' ',
    back: '',
    addNode: ' ',
    addEdge: ' ',
    editNode: ' ',
    editEdge: ' ',
    addDescription: '   ,    .',
    edgeDescription: '        ,   .',
    editEdgeDescription: '        ,    .',
    createEdgeError: '    .',
    deleteClusterError: '    ',
    editClusterError: '   .'
  };
  exports['ru_RU'] = exports['ru'];

/***/ }
/******/ ])
});
;
},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJleGFtcGxlL2pzL2FwcC5qcyIsImluZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Zpcy9kaXN0L3Zpcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwidmFyIHZpcyA9IHJlcXVpcmUoJ3ZpcycpO1xyXG5yZXF1aXJlKCcuLi8uLi9pbmRleC5qcycpO1xyXG5cclxuY29uc29sZS5sb2codmlzKTtcclxuXHJcbnZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndmlzJyk7XHJcbmNvbnNvbGUubG9nKGNvbnRhaW5lcik7XHJcblxyXG4vLyBDcmVhdGUgYSBEYXRhU2V0IChhbGxvd3MgdHdvIHdheSBkYXRhLWJpbmRpbmcpXHJcbnZhciBpdGVtcyA9IG5ldyB2aXMuRGF0YVNldChbXHJcbiAge3N0YXJ0OiAnMjAxMy0wNCd9XHJcbl0pO1xyXG5cclxuLy8gQ29uZmlndXJhdGlvbiBmb3IgdGhlIFRpbWVsaW5lXHJcbnZhciBvcHRpb25zID0ge1xyXG4gICAgLy8gdGVtcGxhdGU6IHRlbXBsYXRlLFxyXG4gICAgLy8gYWxpZ246ICdyaWdodCcsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9zaXRpb25cclxuICAgIGF1dG9SZXNpemU6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBiZXR0ZXIgdHJ1ZSwgdGltZWxpbmUgY2VudGVyIHBvaW50IHN0YXlzIGF0IHRoZSBzYW1lIHBsYWNlXHJcbiAgICBtdWx0aXNlbGVjdDogdHJ1ZSxcclxuICAgIC8vIGNvbmZpZ3VyZTogdHJ1ZSxcclxuICAgIC8vIGRhdGFBdHRyaWJ1dGVzOiAnYWxsJyxcclxuICAgIC8vIGVkaXRhYmxlOiB0cnVlLFxyXG4gICAgLy8gZ3JvdXBFZGl0YWJsZTogdHJ1ZSxcclxufTtcclxuXHJcbi8vIENyZWF0ZSBhIFRpbWVsaW5lXHJcbnZhciB0aW1lbGluZSA9IG5ldyB2aXMuVGltZWxpbmUoY29udGFpbmVyLCBpdGVtcywgb3B0aW9ucyk7XHJcbiIsIiIsIi8qKlxuICogdmlzLmpzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYWxtZW5kZS92aXNcbiAqXG4gKiBBIGR5bmFtaWMsIGJyb3dzZXItYmFzZWQgdmlzdWFsaXphdGlvbiBsaWJyYXJ5LlxuICpcbiAqIEB2ZXJzaW9uIDQuMTcuMFxuICogQGRhdGUgICAgMjAxNi0xMS0wNVxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTEtMjAxNiBBbG1lbmRlIEIuViwgaHR0cDovL2FsbWVuZGUuY29tXG4gKlxuICogVmlzLmpzIGlzIGR1YWwgbGljZW5zZWQgdW5kZXIgYm90aFxuICpcbiAqICogVGhlIEFwYWNoZSAyLjAgTGljZW5zZVxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBhbmRcbiAqXG4gKiAqIFRoZSBNSVQgTGljZW5zZVxuICogICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKlxuICogVmlzLmpzIG1heSBiZSBkaXN0cmlidXRlZCB1bmRlciBlaXRoZXIgbGljZW5zZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1widmlzXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInZpc1wiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG5cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG5cblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIC8vIEdyYXBoM2RcbiAgdXRpbC5leHRlbmQoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyg3KSk7XG5cbiAgLy8gVGltZWxpbmUgJiBHcmFwaDJkXG4gIHV0aWwuZXh0ZW5kKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMjYpKTtcblxuICAvLyBOZXR3b3JrXG4gIHV0aWwuZXh0ZW5kKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oNjIpKTtcblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbiAgLy8gdXRpbGl0eSBmdW5jdGlvbnNcblxuICAvLyBmaXJzdCBjaGVjayBpZiBtb21lbnQuanMgaXMgYWxyZWFkeSBsb2FkZWQgaW4gdGhlIGJyb3dzZXIgd2luZG93LCBpZiBzbyxcbiAgLy8gdXNlIHRoaXMgaW5zdGFuY2UuIEVsc2UsIGxvYWQgdmlhIGNvbW1vbmpzLlxuXG5cbiAgdmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4gIHZhciB1dWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIGdpdmVuIG9iamVjdCBpcyBhIG51bWJlclxuICAgKiBAcGFyYW0geyp9IG9iamVjdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBpc051bWJlclxuICAgKi9cbiAgZXhwb3J0cy5pc051bWJlciA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgTnVtYmVyIHx8IHR5cGVvZiBvYmplY3QgPT0gJ251bWJlcic7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBldmVyeXRoaW5nIGluIHRoZSBET00gb2JqZWN0XG4gICAqIEBwYXJhbSBET01vYmplY3RcbiAgICovXG4gIGV4cG9ydHMucmVjdXJzaXZlRE9NRGVsZXRlID0gZnVuY3Rpb24gKERPTW9iamVjdCkge1xuICAgIGlmIChET01vYmplY3QpIHtcbiAgICAgIHdoaWxlIChET01vYmplY3QuaGFzQ2hpbGROb2RlcygpID09PSB0cnVlKSB7XG4gICAgICAgIGV4cG9ydHMucmVjdXJzaXZlRE9NRGVsZXRlKERPTW9iamVjdC5maXJzdENoaWxkKTtcbiAgICAgICAgRE9Nb2JqZWN0LnJlbW92ZUNoaWxkKERPTW9iamVjdC5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIHRoaXMgZnVuY3Rpb24gZ2l2ZXMgeW91IGEgcmFuZ2UgYmV0d2VlbiAwIGFuZCAxIGJhc2VkIG9uIHRoZSBtaW4gYW5kIG1heCB2YWx1ZXMgaW4gdGhlIHNldCwgdGhlIHRvdGFsIHN1bSBvZiBhbGwgdmFsdWVzIGFuZCB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIG1pblxuICAgKiBAcGFyYW0gbWF4XG4gICAqIEBwYXJhbSB0b3RhbFxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGV4cG9ydHMuZ2l2ZVJhbmdlID0gZnVuY3Rpb24gKG1pbiwgbWF4LCB0b3RhbCwgdmFsdWUpIHtcbiAgICBpZiAobWF4ID09IG1pbikge1xuICAgICAgcmV0dXJuIDAuNTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNjYWxlID0gMSAvIChtYXggLSBtaW4pO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsICh2YWx1ZSAtIG1pbikgKiBzY2FsZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgZ2l2ZW4gb2JqZWN0IGlzIGEgc3RyaW5nXG4gICAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGlzU3RyaW5nXG4gICAqL1xuICBleHBvcnRzLmlzU3RyaW5nID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdHlwZW9mIG9iamVjdCA9PSAnc3RyaW5nJztcbiAgfTtcblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIGdpdmVuIG9iamVjdCBpcyBhIERhdGUsIG9yIGEgU3RyaW5nIGNvbnRhaW5pbmcgYSBEYXRlXG4gICAqIEBwYXJhbSB7RGF0ZSB8IFN0cmluZ30gb2JqZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGlzRGF0ZVxuICAgKi9cbiAgZXhwb3J0cy5pc0RhdGUgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZXhwb3J0cy5pc1N0cmluZyhvYmplY3QpKSB7XG4gICAgICAvLyB0ZXN0IHdoZXRoZXIgdGhpcyBzdHJpbmcgY29udGFpbnMgYSBkYXRlXG4gICAgICB2YXIgbWF0Y2ggPSBBU1BEYXRlUmVnZXguZXhlYyhvYmplY3QpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmICghaXNOYU4oRGF0ZS5wYXJzZShvYmplY3QpKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNlbWkgVVVJRFxuICAgKiBzb3VyY2U6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEwNTA3NC8xMjYyNzUzXG4gICAqIEByZXR1cm4ge1N0cmluZ30gdXVpZFxuICAgKi9cbiAgZXhwb3J0cy5yYW5kb21VVUlEID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1dWlkLnY0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIGFzc2lnbiBhbGwga2V5cyBvZiBhbiBvYmplY3QgdGhhdCBhcmUgbm90IG5lc3RlZCBvYmplY3RzIHRvIGEgY2VydGFpbiB2YWx1ZSAodXNlZCBmb3IgY29sb3Igb2JqZWN0cykuXG4gICAqIEBwYXJhbSBvYmpcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqL1xuICBleHBvcnRzLmFzc2lnbkFsbEtleXMgPSBmdW5jdGlvbiAob2JqLCB2YWx1ZSkge1xuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIGlmIChfdHlwZW9mKG9ialtwcm9wXSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgb2JqW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbGwgYW4gb2JqZWN0IHdpdGggYSBwb3NzaWJseSBwYXJ0aWFsbHkgZGVmaW5lZCBvdGhlciBvYmplY3QuIE9ubHkgY29waWVzIHZhbHVlcyBpZiB0aGUgYSBvYmplY3QgaGFzIGFuIG9iamVjdCByZXF1aXJpbmcgdmFsdWVzLlxuICAgKiBUaGF0IG1lYW5zIGFuIG9iamVjdCBpcyBub3QgY3JlYXRlZCBvbiBhIHByb3BlcnR5IGlmIG9ubHkgdGhlIGIgb2JqZWN0IGhhcyBpdC5cbiAgICogQHBhcmFtIG9ialxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICovXG4gIGV4cG9ydHMuZmlsbElmRGVmaW5lZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBhKSB7XG4gICAgICBpZiAoYltwcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChfdHlwZW9mKGJbcHJvcF0pICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmICgoYltwcm9wXSA9PT0gdW5kZWZpbmVkIHx8IGJbcHJvcF0gPT09IG51bGwpICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZCAmJiBhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICBkZWxldGUgYVtwcm9wXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChfdHlwZW9mKGFbcHJvcF0pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZXhwb3J0cy5maWxsSWZEZWZpbmVkKGFbcHJvcF0sIGJbcHJvcF0sIGFsbG93RGVsZXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRXh0ZW5kIG9iamVjdCBhIHdpdGggdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIgb3IgYSBzZXJpZXMgb2Ygb2JqZWN0c1xuICAgKiBPbmx5IHByb3BlcnRpZXMgd2l0aCBkZWZpbmVkIHZhbHVlcyBhcmUgY29waWVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gICAqIEBwYXJhbSB7Li4uIE9iamVjdH0gYlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGFcbiAgICovXG4gIGV4cG9ydHMucHJvdG9FeHRlbmQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBwcm9wIGluIG90aGVyKSB7XG4gICAgICAgIGFbcHJvcF0gPSBvdGhlcltwcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4dGVuZCBvYmplY3QgYSB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiIG9yIGEgc2VyaWVzIG9mIG9iamVjdHNcbiAgICogT25seSBwcm9wZXJ0aWVzIHdpdGggZGVmaW5lZCB2YWx1ZXMgYXJlIGNvcGllZFxuICAgKiBAcGFyYW0ge09iamVjdH0gYVxuICAgKiBAcGFyYW0gey4uLiBPYmplY3R9IGJcbiAgICogQHJldHVybiB7T2JqZWN0fSBhXG4gICAqL1xuICBleHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gb3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgYVtwcm9wXSA9IG90aGVyW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeHRlbmQgb2JqZWN0IGEgd2l0aCBzZWxlY3RlZCBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiIG9yIGEgc2VyaWVzIG9mIG9iamVjdHNcbiAgICogT25seSBwcm9wZXJ0aWVzIHdpdGggZGVmaW5lZCB2YWx1ZXMgYXJlIGNvcGllZFxuICAgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBwcm9wc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYVxuICAgKiBAcGFyYW0ge09iamVjdH0gYlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGFcbiAgICovXG4gIGV4cG9ydHMuc2VsZWN0aXZlRXh0ZW5kID0gZnVuY3Rpb24gKHByb3BzLCBhLCBiKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheSB3aXRoIHByb3BlcnR5IG5hbWVzIGV4cGVjdGVkIGFzIGZpcnN0IGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwcm9wcy5sZW5ndGg7IHArKykge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW3BdO1xuICAgICAgICBpZiAob3RoZXIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICBhW3Byb3BdID0gb3RoZXJbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4dGVuZCBvYmplY3QgYSB3aXRoIHNlbGVjdGVkIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIgb3IgYSBzZXJpZXMgb2Ygb2JqZWN0c1xuICAgKiBPbmx5IHByb3BlcnRpZXMgd2l0aCBkZWZpbmVkIHZhbHVlcyBhcmUgY29waWVkXG4gICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IHByb3BzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gICAqIEByZXR1cm4ge09iamVjdH0gYVxuICAgKi9cbiAgZXhwb3J0cy5zZWxlY3RpdmVEZWVwRXh0ZW5kID0gZnVuY3Rpb24gKHByb3BzLCBhLCBiKSB7XG4gICAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuXG4gICAgLy8gVE9ETzogYWRkIHN1cHBvcnQgZm9yIEFycmF5cyB0byBkZWVwRXh0ZW5kXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBieSBkZWVwRXh0ZW5kJyk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHByb3BzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbcF07XG4gICAgICAgIGlmIChvdGhlci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgIGlmIChiW3Byb3BdICYmIGJbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGFbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBhW3Byb3BdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYVtwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICAgIGV4cG9ydHMuZGVlcEV4dGVuZChhW3Byb3BdLCBiW3Byb3BdLCBmYWxzZSwgYWxsb3dEZWxldGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoYltwcm9wXSA9PT0gbnVsbCAmJiBhW3Byb3BdICE9PSB1bmRlZmluZWQgJiYgYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBhW3Byb3BdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFbcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJbcHJvcF0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYltwcm9wXSA9PT0gbnVsbCAmJiBhW3Byb3BdICE9PSB1bmRlZmluZWQgJiYgYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBkZWxldGUgYVtwcm9wXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFbcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfTtcblxuICAvKipcbiAgICogRXh0ZW5kIG9iamVjdCBhIHdpdGggc2VsZWN0ZWQgcHJvcGVydGllcyBvZiBvYmplY3QgYiBvciBhIHNlcmllcyBvZiBvYmplY3RzXG4gICAqIE9ubHkgcHJvcGVydGllcyB3aXRoIGRlZmluZWQgdmFsdWVzIGFyZSBjb3BpZWRcbiAgICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gcHJvcHNcbiAgICogQHBhcmFtIHtPYmplY3R9IGFcbiAgICogQHBhcmFtIHtPYmplY3R9IGJcbiAgICogQHJldHVybiB7T2JqZWN0fSBhXG4gICAqL1xuICBleHBvcnRzLnNlbGVjdGl2ZU5vdERlZXBFeHRlbmQgPSBmdW5jdGlvbiAocHJvcHMsIGEsIGIpIHtcbiAgICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG5cbiAgICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgQXJyYXlzIHRvIGRlZXBFeHRlbmRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGRlZXBFeHRlbmQnKTtcbiAgICB9XG4gICAgZm9yICh2YXIgcHJvcCBpbiBiKSB7XG4gICAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICBpZiAocHJvcHMuaW5kZXhPZihwcm9wKSA9PSAtMSkge1xuICAgICAgICAgIGlmIChiW3Byb3BdICYmIGJbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGFbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBhW3Byb3BdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYVtwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICAgIGV4cG9ydHMuZGVlcEV4dGVuZChhW3Byb3BdLCBiW3Byb3BdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChiW3Byb3BdID09PSBudWxsICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZCAmJiBhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGFbcHJvcF07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYltwcm9wXSkpIHtcbiAgICAgICAgICAgIGFbcHJvcF0gPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYltwcm9wXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBhW3Byb3BdLnB1c2goYltwcm9wXVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChiW3Byb3BdID09PSBudWxsICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZCAmJiBhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBhW3Byb3BdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWVwIGV4dGVuZCBhbiBvYmplY3QgYSB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gICAqIEBwYXJhbSBbQm9vbGVhbl0gcHJvdG9FeHRlbmQgLS0+IG9wdGlvbmFsIHBhcmFtZXRlci4gSWYgdHJ1ZSwgdGhlIHByb3RvdHlwZSB2YWx1ZXMgd2lsbCBhbHNvIGJlIGV4dGVuZGVkLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaWUuIHRoZSBvcHRpb25zIG9iamVjdHMgdGhhdCBpbmhlcml0IGZyb20gb3RoZXJzIHdpbGwgYWxzbyBnZXQgdGhlIGluaGVyaXRlZCBvcHRpb25zKVxuICAgKiBAcGFyYW0gW0Jvb2xlYW5dIGdsb2JhbCAgICAgIC0tPiBvcHRpb25hbCBwYXJhbWV0ZXIuIElmIHRydWUsIHRoZSB2YWx1ZXMgb2YgZmllbGRzIHRoYXQgYXJlIG51bGwgd2lsbCBub3QgZGVsZXRlZFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgZXhwb3J0cy5kZWVwRXh0ZW5kID0gZnVuY3Rpb24gKGEsIGIsIHByb3RvRXh0ZW5kLCBhbGxvd0RlbGV0aW9uKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBiKSB7XG4gICAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCBwcm90b0V4dGVuZCA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoYltwcm9wXSAmJiBiW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICBpZiAoYVtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhW3Byb3BdID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuZGVlcEV4dGVuZChhW3Byb3BdLCBiW3Byb3BdLCBwcm90b0V4dGVuZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChiW3Byb3BdID09PSBudWxsICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZCAmJiBhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBhW3Byb3BdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYltwcm9wXSkpIHtcbiAgICAgICAgICBhW3Byb3BdID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiW3Byb3BdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhW3Byb3BdLnB1c2goYltwcm9wXVtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChiW3Byb3BdID09PSBudWxsICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZCAmJiBhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICBkZWxldGUgYVtwcm9wXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgYWxsIGVsZW1lbnRzIGluIHR3byBhcnJheXMgYXJlIGVxdWFsLlxuICAgKiBAcGFyYW0ge0FycmF5fSBhXG4gICAqIEBwYXJhbSB7QXJyYXl9IGJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGJvdGggYXJyYXlzIGhhdmUgdGhlIHNhbWUgbGVuZ3RoIGFuZCBzYW1lXG4gICAqICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLlxuICAgKi9cbiAgZXhwb3J0cy5lcXVhbEFycmF5ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSAhPSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gb2JqZWN0IHRvIGFub3RoZXIgdHlwZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW4gfCBOdW1iZXIgfCBTdHJpbmcgfCBEYXRlIHwgTW9tZW50IHwgTnVsbCB8IHVuZGVmaW5lZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nIHwgdW5kZWZpbmVkfSB0eXBlICAgTmFtZSBvZiB0aGUgdHlwZS4gQXZhaWxhYmxlIHR5cGVzOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdCb29sZWFuJywgJ051bWJlcicsICdTdHJpbmcnLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdEYXRlJywgJ01vbWVudCcsIElTT0RhdGUnLCAnQVNQRGF0ZScuXG4gICAqIEByZXR1cm4geyp9IG9iamVjdFxuICAgKiBAdGhyb3dzIEVycm9yXG4gICAqL1xuICBleHBvcnRzLmNvbnZlcnQgPSBmdW5jdGlvbiAob2JqZWN0LCB0eXBlKSB7XG4gICAgdmFyIG1hdGNoO1xuXG4gICAgaWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAob2JqZWN0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIGlmICghKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykgJiYgISh0eXBlIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeXBlIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICAgIHJldHVybiBCb29sZWFuKG9iamVjdCk7XG5cbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICBpZiAoIWlzTmFOKERhdGUucGFyc2Uob2JqZWN0KSkpIHtcbiAgICAgICAgICByZXR1cm4gbW9tZW50KG9iamVjdCkudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBOdW1iZXIob2JqZWN0LnZhbHVlT2YoKSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdTdHJpbmcnOlxuICAgICAgICByZXR1cm4gU3RyaW5nKG9iamVjdCk7XG5cbiAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgICBpZiAoZXhwb3J0cy5pc051bWJlcihvYmplY3QpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUob2JqZWN0LnZhbHVlT2YoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAobW9tZW50LmlzTW9tZW50KG9iamVjdCkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUob2JqZWN0LnZhbHVlT2YoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cG9ydHMuaXNTdHJpbmcob2JqZWN0KSkge1xuICAgICAgICAgIG1hdGNoID0gQVNQRGF0ZVJlZ2V4LmV4ZWMob2JqZWN0KTtcbiAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIG9iamVjdCBpcyBhbiBBU1AgZGF0ZVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE51bWJlcihtYXRjaFsxXSkpOyAvLyBwYXJzZSBudW1iZXJcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1vbWVudChuZXcgRGF0ZShvYmplY3QpKS50b0RhdGUoKTsgLy8gcGFyc2Ugc3RyaW5nXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgb2JqZWN0IG9mIHR5cGUgJyArIGV4cG9ydHMuZ2V0VHlwZShvYmplY3QpICsgJyB0byB0eXBlIERhdGUnKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdNb21lbnQnOlxuICAgICAgICBpZiAoZXhwb3J0cy5pc051bWJlcihvYmplY3QpKSB7XG4gICAgICAgICAgcmV0dXJuIG1vbWVudChvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIG1vbWVudChvYmplY3QudmFsdWVPZigpKTtcbiAgICAgICAgfSBlbHNlIGlmIChtb21lbnQuaXNNb21lbnQob2JqZWN0KSkge1xuICAgICAgICAgIHJldHVybiBtb21lbnQob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwb3J0cy5pc1N0cmluZyhvYmplY3QpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBBU1BEYXRlUmVnZXguZXhlYyhvYmplY3QpO1xuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgLy8gb2JqZWN0IGlzIGFuIEFTUCBkYXRlXG4gICAgICAgICAgICByZXR1cm4gbW9tZW50KE51bWJlcihtYXRjaFsxXSkpOyAvLyBwYXJzZSBudW1iZXJcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1vbWVudChvYmplY3QpOyAvLyBwYXJzZSBzdHJpbmdcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29udmVydCBvYmplY3Qgb2YgdHlwZSAnICsgZXhwb3J0cy5nZXRUeXBlKG9iamVjdCkgKyAnIHRvIHR5cGUgRGF0ZScpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ0lTT0RhdGUnOlxuICAgICAgICBpZiAoZXhwb3J0cy5pc051bWJlcihvYmplY3QpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iamVjdCk7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmIChtb21lbnQuaXNNb21lbnQob2JqZWN0KSkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmIChleHBvcnRzLmlzU3RyaW5nKG9iamVjdCkpIHtcbiAgICAgICAgICBtYXRjaCA9IEFTUERhdGVSZWdleC5leGVjKG9iamVjdCk7XG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAvLyBvYmplY3QgaXMgYW4gQVNQIGRhdGVcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShOdW1iZXIobWF0Y2hbMV0pKS50b0lTT1N0cmluZygpOyAvLyBwYXJzZSBudW1iZXJcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1vbWVudChvYmplY3QpLmZvcm1hdCgpOyAvLyBJU08gODYwMVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IG9iamVjdCBvZiB0eXBlICcgKyBleHBvcnRzLmdldFR5cGUob2JqZWN0KSArICcgdG8gdHlwZSBJU09EYXRlJyk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnQVNQRGF0ZSc6XG4gICAgICAgIGlmIChleHBvcnRzLmlzTnVtYmVyKG9iamVjdCkpIHtcbiAgICAgICAgICByZXR1cm4gJy9EYXRlKCcgKyBvYmplY3QgKyAnKS8nO1xuICAgICAgICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICByZXR1cm4gJy9EYXRlKCcgKyBvYmplY3QudmFsdWVPZigpICsgJykvJztcbiAgICAgICAgfSBlbHNlIGlmIChleHBvcnRzLmlzU3RyaW5nKG9iamVjdCkpIHtcbiAgICAgICAgICBtYXRjaCA9IEFTUERhdGVSZWdleC5leGVjKG9iamVjdCk7XG4gICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgLy8gb2JqZWN0IGlzIGFuIEFTUCBkYXRlXG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKE51bWJlcihtYXRjaFsxXSkpLnZhbHVlT2YoKTsgLy8gcGFyc2UgbnVtYmVyXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUob2JqZWN0KS52YWx1ZU9mKCk7IC8vIHBhcnNlIHN0cmluZ1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJy9EYXRlKCcgKyB2YWx1ZSArICcpLyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29udmVydCBvYmplY3Qgb2YgdHlwZSAnICsgZXhwb3J0cy5nZXRUeXBlKG9iamVjdCkgKyAnIHRvIHR5cGUgQVNQRGF0ZScpO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlIFwiJyArIHR5cGUgKyAnXCInKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gcGFyc2UgQVNQLk5ldCBEYXRlIHBhdHRlcm4sXG4gIC8vIGZvciBleGFtcGxlICcvRGF0ZSgxMTk4OTA4NzE3MDU2KS8nIG9yICcvRGF0ZSgxMTk4OTA4NzE3MDU2LTA3MDApLydcbiAgLy8gY29kZSBmcm9tIGh0dHA6Ly9tb21lbnRqcy5jb20vXG4gIHZhciBBU1BEYXRlUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHR5cGUgb2YgYW4gb2JqZWN0LCBmb3IgZXhhbXBsZSBleHBvcnRzLmdldFR5cGUoW10pIHJldHVybnMgJ0FycmF5J1xuICAgKiBAcGFyYW0geyp9IG9iamVjdFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IHR5cGVcbiAgICovXG4gIGV4cG9ydHMuZ2V0VHlwZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iamVjdCk7XG5cbiAgICBpZiAodHlwZSA9PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICAgICAgcmV0dXJuICdCb29sZWFuJztcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuICdOdW1iZXInO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICByZXR1cm4gJ1N0cmluZyc7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiAnQXJyYXknO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdEYXRlJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnT2JqZWN0JztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiAnTnVtYmVyJztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm4gJ0Jvb2xlYW4nO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuICdTdHJpbmcnO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZXh0ZW5kIGFuIGFycmF5IGFuZCBjb3B5IGl0LiBUaGlzIGlzIHVzZWQgdG8gcHJvcGFnYXRlIHBhdGhzIHJlY3Vyc2l2ZWx5LlxuICAgKlxuICAgKiBAcGFyYW0gYXJyXG4gICAqIEBwYXJhbSBuZXdWYWx1ZVxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICBleHBvcnRzLmNvcHlBbmRFeHRlbmRBcnJheSA9IGZ1bmN0aW9uIChhcnIsIG5ld1ZhbHVlKSB7XG4gICAgdmFyIG5ld0FyciA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuZXdBcnIucHVzaChhcnJbaV0pO1xuICAgIH1cbiAgICBuZXdBcnIucHVzaChuZXdWYWx1ZSk7XG4gICAgcmV0dXJuIG5ld0FycjtcbiAgfTtcblxuICAvKipcbiAgICogVXNlZCB0byBleHRlbmQgYW4gYXJyYXkgYW5kIGNvcHkgaXQuIFRoaXMgaXMgdXNlZCB0byBwcm9wYWdhdGUgcGF0aHMgcmVjdXJzaXZlbHkuXG4gICAqXG4gICAqIEBwYXJhbSBhcnJcbiAgICogQHBhcmFtIG5ld1ZhbHVlXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG4gIGV4cG9ydHMuY29weUFycmF5ID0gZnVuY3Rpb24gKGFycikge1xuICAgIHZhciBuZXdBcnIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgbmV3QXJyLnB1c2goYXJyW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0FycjtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIGFic29sdXRlIGxlZnQgdmFsdWUgb2YgYSBET00gZWxlbWVudFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW0gICAgICAgIEEgZG9tIGVsZW1lbnQsIGZvciBleGFtcGxlIGEgZGl2XG4gICAqIEByZXR1cm4ge251bWJlcn0gbGVmdCAgICAgICAgVGhlIGFic29sdXRlIGxlZnQgcG9zaXRpb24gb2YgdGhpcyBlbGVtZW50XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdGhlIGJyb3dzZXIgcGFnZS5cbiAgICovXG4gIGV4cG9ydHMuZ2V0QWJzb2x1dGVMZWZ0ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICByZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICB9O1xuXG4gIGV4cG9ydHMuZ2V0QWJzb2x1dGVSaWdodCA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgcmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBhYnNvbHV0ZSB0b3AgdmFsdWUgb2YgYSBET00gZWxlbWVudFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW0gICAgICAgIEEgZG9tIGVsZW1lbnQsIGZvciBleGFtcGxlIGEgZGl2XG4gICAqIEByZXR1cm4ge251bWJlcn0gdG9wICAgICAgICBUaGUgYWJzb2x1dGUgdG9wIHBvc2l0aW9uIG9mIHRoaXMgZWxlbWVudFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRoZSBicm93c2VyIHBhZ2UuXG4gICAqL1xuICBleHBvcnRzLmdldEFic29sdXRlVG9wID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICByZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gIH07XG5cbiAgLyoqXG4gICAqIGFkZCBhIGNsYXNzTmFtZSB0byB0aGUgZ2l2ZW4gZWxlbWVudHMgc3R5bGVcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGV4cG9ydHMuYWRkQ2xhc3NOYW1lID0gZnVuY3Rpb24gKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgIHZhciBjbGFzc2VzID0gZWxlbS5jbGFzc05hbWUuc3BsaXQoJyAnKTtcbiAgICBpZiAoY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSkgPT0gLTEpIHtcbiAgICAgIGNsYXNzZXMucHVzaChjbGFzc05hbWUpOyAvLyBhZGQgdGhlIGNsYXNzIHRvIHRoZSBhcnJheVxuICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIGFkZCBhIGNsYXNzTmFtZSB0byB0aGUgZ2l2ZW4gZWxlbWVudHMgc3R5bGVcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGV4cG9ydHMucmVtb3ZlQ2xhc3NOYW1lID0gZnVuY3Rpb24gKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgIHZhciBjbGFzc2VzID0gZWxlbS5jbGFzc05hbWUuc3BsaXQoJyAnKTtcbiAgICB2YXIgaW5kZXggPSBjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKTtcbiAgICBpZiAoaW5kZXggIT0gLTEpIHtcbiAgICAgIGNsYXNzZXMuc3BsaWNlKGluZGV4LCAxKTsgLy8gcmVtb3ZlIHRoZSBjbGFzcyBmcm9tIHRoZSBhcnJheVxuICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvciBlYWNoIG1ldGhvZCBmb3IgYm90aCBhcnJheXMgYW5kIG9iamVjdHMuXG4gICAqIEluIGNhc2Ugb2YgYW4gYXJyYXksIHRoZSBidWlsdC1pbiBBcnJheS5mb3JFYWNoKCkgaXMgYXBwbGllZC5cbiAgICogSW4gY2FzZSBvZiBhbiBPYmplY3QsIHRoZSBtZXRob2QgbG9vcHMgb3ZlciBhbGwgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdCB8IEFycmF5fSBvYmplY3QgICBBbiBPYmplY3Qgb3IgQXJyYXlcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICAgICAgQ2FsbGJhY2sgbWV0aG9kLCBjYWxsZWQgZm9yIGVhY2ggaXRlbSBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgb2JqZWN0IG9yIGFycmF5IHdpdGggdGhyZWUgcGFyYW1ldGVyczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodmFsdWUsIGluZGV4LCBvYmplY3QpXG4gICAqL1xuICBleHBvcnRzLmZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHZhciBpLCBsZW47XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgLy8gYXJyYXlcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG9iamVjdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjYWxsYmFjayhvYmplY3RbaV0sIGksIG9iamVjdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG9iamVjdFxuICAgICAgZm9yIChpIGluIG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgY2FsbGJhY2sob2JqZWN0W2ldLCBpLCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGFuIGFycmF5OiBhbGwgb2JqZWN0cyBwcm9wZXJ0aWVzIGFyZSBwdXQgaW50byB0aGVcbiAgICogYXJyYXkuIFRoZSByZXN1bHRpbmcgYXJyYXkgaXMgdW5vcmRlcmVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAqL1xuICBleHBvcnRzLnRvQXJyYXkgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIGFycmF5ID0gW107XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgYXJyYXkucHVzaChvYmplY3RbcHJvcF0pO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGEgcHJvcGVydHkgaW4gYW4gb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGNoYW5nZWRcbiAgICovXG4gIGV4cG9ydHMudXBkYXRlUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKG9iamVjdFtrZXldICE9PSB2YWx1ZSkge1xuICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUaHJvdHRsZSB0aGUgZ2l2ZW4gZnVuY3Rpb24gdG8gYmUgb25seSBleGVjdXRlZCBvbmNlIHBlciBhbmltYXRpb24gZnJhbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm5cbiAgICogQHJldHVybnMge2Z1bmN0aW9ufSBSZXR1cm5zIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAgICovXG4gIGV4cG9ydHMudGhyb3R0bGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgc2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gdGhyb3R0bGVkKCkge1xuICAgICAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICBmbigpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYW5kIGV2ZW50IGxpc3RlbmVyLiBXb3JrcyBmb3IgYWxsIGJyb3dzZXJzXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gICAgIGVsZW1lbnQgICAgQW4gaHRtbCBlbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgIGFjdGlvbiAgICAgVGhlIGFjdGlvbiwgZm9yIGV4YW1wbGUgXCJjbGlja1wiLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhvdXQgdGhlIHByZWZpeCBcIm9uXCJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gICAgbGlzdGVuZXIgICBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgW3VzZUNhcHR1cmVdXG4gICAqL1xuICBleHBvcnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgYWN0aW9uLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICAgIGlmIChlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGlmICh1c2VDYXB0dXJlID09PSB1bmRlZmluZWQpIHVzZUNhcHR1cmUgPSBmYWxzZTtcblxuICAgICAgaWYgKGFjdGlvbiA9PT0gXCJtb3VzZXdoZWVsXCIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSA+PSAwKSB7XG4gICAgICAgIGFjdGlvbiA9IFwiRE9NTW91c2VTY3JvbGxcIjsgLy8gRm9yIEZpcmVmb3hcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LmF0dGFjaEV2ZW50KFwib25cIiArIGFjdGlvbiwgbGlzdGVuZXIpOyAvLyBJRSBicm93c2Vyc1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gYW4gZWxlbWVudFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9ICAgICBlbGVtZW50ICAgICAgICAgQW4gaHRtbCBkb20gZWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICBhY3Rpb24gICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LCBmb3IgZXhhbXBsZSBcIm1vdXNlZG93blwiXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259ICAgIGxpc3RlbmVyICAgICAgICBUaGUgbGlzdGVuZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgW3VzZUNhcHR1cmVdXG4gICAqL1xuICBleHBvcnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgYWN0aW9uLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICAgIGlmIChlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIC8vIG5vbi1JRSBicm93c2Vyc1xuICAgICAgaWYgKHVzZUNhcHR1cmUgPT09IHVuZGVmaW5lZCkgdXNlQ2FwdHVyZSA9IGZhbHNlO1xuXG4gICAgICBpZiAoYWN0aW9uID09PSBcIm1vdXNld2hlZWxcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJGaXJlZm94XCIpID49IDApIHtcbiAgICAgICAgYWN0aW9uID0gXCJET01Nb3VzZVNjcm9sbFwiOyAvLyBGb3IgRmlyZWZveFxuICAgICAgfVxuXG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoYWN0aW9uLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElFIGJyb3dzZXJzXG4gICAgICBlbGVtZW50LmRldGFjaEV2ZW50KFwib25cIiArIGFjdGlvbiwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FuY2VscyB0aGUgZXZlbnQgaWYgaXQgaXMgY2FuY2VsYWJsZSwgd2l0aG91dCBzdG9wcGluZyBmdXJ0aGVyIHByb3BhZ2F0aW9uIG9mIHRoZSBldmVudC5cbiAgICovXG4gIGV4cG9ydHMucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50KSBldmVudCA9IHdpbmRvdy5ldmVudDtcblxuICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gbm9uLUlFIGJyb3dzZXJzXG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7IC8vIElFIGJyb3dzZXJzXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgSFRNTCBlbGVtZW50IHdoaWNoIGlzIHRoZSB0YXJnZXQgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IHRhcmdldCBlbGVtZW50XG4gICAqL1xuICBleHBvcnRzLmdldFRhcmdldCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGNvZGUgZnJvbSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICBldmVudCA9IHdpbmRvdy5ldmVudDtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0O1xuXG4gICAgaWYgKGV2ZW50LnRhcmdldCkge1xuICAgICAgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIH0gZWxzZSBpZiAoZXZlbnQuc3JjRWxlbWVudCkge1xuICAgICAgdGFyZ2V0ID0gZXZlbnQuc3JjRWxlbWVudDtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0Lm5vZGVUeXBlICE9IHVuZGVmaW5lZCAmJiB0YXJnZXQubm9kZVR5cGUgPT0gMykge1xuICAgICAgLy8gZGVmZWF0IFNhZmFyaSBidWdcbiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGdpdmVuIGVsZW1lbnQgY29udGFpbnMgZ2l2ZW4gcGFyZW50IHNvbWV3aGVyZSBpbiB0aGUgRE9NIHRyZWVcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50XG4gICAqL1xuICBleHBvcnRzLmhhc1BhcmVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBwYXJlbnQpIHtcbiAgICB2YXIgZSA9IGVsZW1lbnQ7XG5cbiAgICB3aGlsZSAoZSkge1xuICAgICAgaWYgKGUgPT09IHBhcmVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGUgPSBlLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMub3B0aW9uID0ge307XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIGEgYm9vbGVhblxuICAgKiBAcGFyYW0ge0Jvb2xlYW4gfCBmdW5jdGlvbiB8IHVuZGVmaW5lZH0gdmFsdWVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZGVmYXVsdFZhbHVlXVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYm9vbFxuICAgKi9cbiAgZXhwb3J0cy5vcHRpb24uYXNCb29sZWFuID0gZnVuY3Rpb24gKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBhIHZhbHVlIGludG8gYSBudW1iZXJcbiAgICogQHBhcmFtIHtCb29sZWFuIHwgZnVuY3Rpb24gfCB1bmRlZmluZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVmYXVsdFZhbHVlXVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBudW1iZXJcbiAgICovXG4gIGV4cG9ydHMub3B0aW9uLmFzTnVtYmVyID0gZnVuY3Rpb24gKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSkgfHwgZGVmYXVsdFZhbHVlIHx8IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgdmFsdWUgaW50byBhIHN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZyB8IGZ1bmN0aW9uIHwgdW5kZWZpbmVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2RlZmF1bHRWYWx1ZV1cbiAgICogQHJldHVybnMge1N0cmluZ30gc3RyXG4gICAqL1xuICBleHBvcnRzLm9wdGlvbi5hc1N0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBhIHNpemUgb3IgbG9jYXRpb24gaW50byBhIHN0cmluZyB3aXRoIHBpeGVscyBvciBhIHBlcmNlbnRhZ2VcbiAgICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXIgfCBmdW5jdGlvbiB8IHVuZGVmaW5lZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtkZWZhdWx0VmFsdWVdXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHNpemVcbiAgICovXG4gIGV4cG9ydHMub3B0aW9uLmFzU2l6ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gICAgfVxuXG4gICAgaWYgKGV4cG9ydHMuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChleHBvcnRzLmlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlICsgJ3B4JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBhIHZhbHVlIGludG8gYSBET00gZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgZnVuY3Rpb24gfCB1bmRlZmluZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtkZWZhdWx0VmFsdWVdXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9IGRvbVxuICAgKi9cbiAgZXhwb3J0cy5vcHRpb24uYXNFbGVtZW50ID0gZnVuY3Rpb24gKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUgfHwgZGVmYXVsdFZhbHVlIHx8IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTYyMzgzOC9yZ2ItdG8taGV4LWFuZC1oZXgtdG8tcmdiXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBoZXhcbiAgICogQHJldHVybnMge3tyOiAqLCBnOiAqLCBiOiAqfX0gfCAyNTUgcmFuZ2VcbiAgICovXG4gIGV4cG9ydHMuaGV4VG9SR0IgPSBmdW5jdGlvbiAoaGV4KSB7XG4gICAgLy8gRXhwYW5kIHNob3J0aGFuZCBmb3JtIChlLmcuIFwiMDNGXCIpIHRvIGZ1bGwgZm9ybSAoZS5nLiBcIjAwMzNGRlwiKVxuICAgIHZhciBzaG9ydGhhbmRSZWdleCA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2k7XG4gICAgaGV4ID0gaGV4LnJlcGxhY2Uoc2hvcnRoYW5kUmVnZXgsIGZ1bmN0aW9uIChtLCByLCBnLCBiKSB7XG4gICAgICByZXR1cm4gciArIHIgKyBnICsgZyArIGIgKyBiO1xuICAgIH0pO1xuICAgIHZhciByZXN1bHQgPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLmV4ZWMoaGV4KTtcbiAgICByZXR1cm4gcmVzdWx0ID8ge1xuICAgICAgcjogcGFyc2VJbnQocmVzdWx0WzFdLCAxNiksXG4gICAgICBnOiBwYXJzZUludChyZXN1bHRbMl0sIDE2KSxcbiAgICAgIGI6IHBhcnNlSW50KHJlc3VsdFszXSwgMTYpXG4gICAgfSA6IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgY29sb3IgaW4gaGV4IGZvcm1hdCBvciByZ2IoKSBvciByZ2JhKCkgZm9ybWF0IGFuZCBvdmVycmlkZXMgdGhlIG9wYWNpdHkuIFJldHVybnMgcmdiYSgpIHN0cmluZy5cbiAgICogQHBhcmFtIGNvbG9yXG4gICAqIEBwYXJhbSBvcGFjaXR5XG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgZXhwb3J0cy5vdmVycmlkZU9wYWNpdHkgPSBmdW5jdGlvbiAoY29sb3IsIG9wYWNpdHkpIHtcbiAgICBpZiAoY29sb3IuaW5kZXhPZihcInJnYmFcIikgIT0gLTEpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9IGVsc2UgaWYgKGNvbG9yLmluZGV4T2YoXCJyZ2JcIikgIT0gLTEpIHtcbiAgICAgIHZhciByZ2IgPSBjb2xvci5zdWJzdHIoY29sb3IuaW5kZXhPZihcIihcIikgKyAxKS5yZXBsYWNlKFwiKVwiLCBcIlwiKS5zcGxpdChcIixcIik7XG4gICAgICByZXR1cm4gXCJyZ2JhKFwiICsgcmdiWzBdICsgXCIsXCIgKyByZ2JbMV0gKyBcIixcIiArIHJnYlsyXSArIFwiLFwiICsgb3BhY2l0eSArIFwiKVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmdiID0gZXhwb3J0cy5oZXhUb1JHQihjb2xvcik7XG4gICAgICBpZiAocmdiID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwicmdiYShcIiArIHJnYi5yICsgXCIsXCIgKyByZ2IuZyArIFwiLFwiICsgcmdiLmIgKyBcIixcIiArIG9wYWNpdHkgKyBcIilcIjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSByZWQgICAgIDAgLS0gMjU1XG4gICAqIEBwYXJhbSBncmVlbiAgIDAgLS0gMjU1XG4gICAqIEBwYXJhbSBibHVlICAgIDAgLS0gMjU1XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZXhwb3J0cy5SR0JUb0hleCA9IGZ1bmN0aW9uIChyZWQsIGdyZWVuLCBibHVlKSB7XG4gICAgcmV0dXJuIFwiI1wiICsgKCgxIDw8IDI0KSArIChyZWQgPDwgMTYpICsgKGdyZWVuIDw8IDgpICsgYmx1ZSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSBhIGNvbG9yIHByb3BlcnR5IGludG8gYW4gb2JqZWN0IHdpdGggYm9yZGVyLCBiYWNrZ3JvdW5kLCBhbmRcbiAgICogaGlnaGxpZ2h0IGNvbG9yc1xuICAgKiBAcGFyYW0ge09iamVjdCB8IFN0cmluZ30gY29sb3JcbiAgICogQHJldHVybiB7T2JqZWN0fSBjb2xvck9iamVjdFxuICAgKi9cbiAgZXhwb3J0cy5wYXJzZUNvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgdmFyIGM7XG4gICAgaWYgKGV4cG9ydHMuaXNTdHJpbmcoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICBpZiAoZXhwb3J0cy5pc1ZhbGlkUkdCKGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgcmdiID0gY29sb3Iuc3Vic3RyKDQpLnN1YnN0cigwLCBjb2xvci5sZW5ndGggLSA1KS5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29sb3IgPSBleHBvcnRzLlJHQlRvSGV4KHJnYlswXSwgcmdiWzFdLCByZ2JbMl0pO1xuICAgICAgfVxuICAgICAgaWYgKGV4cG9ydHMuaXNWYWxpZEhleChjb2xvcikgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGhzdiA9IGV4cG9ydHMuaGV4VG9IU1YoY29sb3IpO1xuICAgICAgICB2YXIgbGlnaHRlckNvbG9ySFNWID0geyBoOiBoc3YuaCwgczogaHN2LnMgKiAwLjgsIHY6IE1hdGgubWluKDEsIGhzdi52ICogMS4wMikgfTtcbiAgICAgICAgdmFyIGRhcmtlckNvbG9ySFNWID0geyBoOiBoc3YuaCwgczogTWF0aC5taW4oMSwgaHN2LnMgKiAxLjI1KSwgdjogaHN2LnYgKiAwLjggfTtcbiAgICAgICAgdmFyIGRhcmtlckNvbG9ySGV4ID0gZXhwb3J0cy5IU1ZUb0hleChkYXJrZXJDb2xvckhTVi5oLCBkYXJrZXJDb2xvckhTVi5zLCBkYXJrZXJDb2xvckhTVi52KTtcbiAgICAgICAgdmFyIGxpZ2h0ZXJDb2xvckhleCA9IGV4cG9ydHMuSFNWVG9IZXgobGlnaHRlckNvbG9ySFNWLmgsIGxpZ2h0ZXJDb2xvckhTVi5zLCBsaWdodGVyQ29sb3JIU1Yudik7XG4gICAgICAgIGMgPSB7XG4gICAgICAgICAgYmFja2dyb3VuZDogY29sb3IsXG4gICAgICAgICAgYm9yZGVyOiBkYXJrZXJDb2xvckhleCxcbiAgICAgICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IGxpZ2h0ZXJDb2xvckhleCxcbiAgICAgICAgICAgIGJvcmRlcjogZGFya2VyQ29sb3JIZXhcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBsaWdodGVyQ29sb3JIZXgsXG4gICAgICAgICAgICBib3JkZXI6IGRhcmtlckNvbG9ySGV4XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYyA9IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvcixcbiAgICAgICAgICBib3JkZXI6IGNvbG9yLFxuICAgICAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICAgICAgYmFja2dyb3VuZDogY29sb3IsXG4gICAgICAgICAgICBib3JkZXI6IGNvbG9yXG4gICAgICAgICAgfSxcbiAgICAgICAgICBob3Zlcjoge1xuICAgICAgICAgICAgYmFja2dyb3VuZDogY29sb3IsXG4gICAgICAgICAgICBib3JkZXI6IGNvbG9yXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjID0ge307XG4gICAgICBjLmJhY2tncm91bmQgPSBjb2xvci5iYWNrZ3JvdW5kIHx8IHVuZGVmaW5lZDtcbiAgICAgIGMuYm9yZGVyID0gY29sb3IuYm9yZGVyIHx8IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGV4cG9ydHMuaXNTdHJpbmcoY29sb3IuaGlnaGxpZ2h0KSkge1xuICAgICAgICBjLmhpZ2hsaWdodCA9IHtcbiAgICAgICAgICBib3JkZXI6IGNvbG9yLmhpZ2hsaWdodCxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvci5oaWdobGlnaHRcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGMuaGlnaGxpZ2h0ID0ge307XG4gICAgICAgIGMuaGlnaGxpZ2h0LmJhY2tncm91bmQgPSBjb2xvci5oaWdobGlnaHQgJiYgY29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQgfHwgdW5kZWZpbmVkO1xuICAgICAgICBjLmhpZ2hsaWdodC5ib3JkZXIgPSBjb2xvci5oaWdobGlnaHQgJiYgY29sb3IuaGlnaGxpZ2h0LmJvcmRlciB8fCB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChleHBvcnRzLmlzU3RyaW5nKGNvbG9yLmhvdmVyKSkge1xuICAgICAgICBjLmhvdmVyID0ge1xuICAgICAgICAgIGJvcmRlcjogY29sb3IuaG92ZXIsXG4gICAgICAgICAgYmFja2dyb3VuZDogY29sb3IuaG92ZXJcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGMuaG92ZXIgPSB7fTtcbiAgICAgICAgYy5ob3Zlci5iYWNrZ3JvdW5kID0gY29sb3IuaG92ZXIgJiYgY29sb3IuaG92ZXIuYmFja2dyb3VuZCB8fCB1bmRlZmluZWQ7XG4gICAgICAgIGMuaG92ZXIuYm9yZGVyID0gY29sb3IuaG92ZXIgJiYgY29sb3IuaG92ZXIuYm9yZGVyIHx8IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYztcbiAgfTtcblxuICAvKipcbiAgICogaHR0cDovL3d3dy5qYXZhc2NyaXB0ZXIubmV0L2ZhcS9yZ2IyaHN2Lmh0bVxuICAgKlxuICAgKiBAcGFyYW0gcmVkXG4gICAqIEBwYXJhbSBncmVlblxuICAgKiBAcGFyYW0gYmx1ZVxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBleHBvcnRzLlJHQlRvSFNWID0gZnVuY3Rpb24gKHJlZCwgZ3JlZW4sIGJsdWUpIHtcbiAgICByZWQgPSByZWQgLyAyNTU7Z3JlZW4gPSBncmVlbiAvIDI1NTtibHVlID0gYmx1ZSAvIDI1NTtcbiAgICB2YXIgbWluUkdCID0gTWF0aC5taW4ocmVkLCBNYXRoLm1pbihncmVlbiwgYmx1ZSkpO1xuICAgIHZhciBtYXhSR0IgPSBNYXRoLm1heChyZWQsIE1hdGgubWF4KGdyZWVuLCBibHVlKSk7XG5cbiAgICAvLyBCbGFjay1ncmF5LXdoaXRlXG4gICAgaWYgKG1pblJHQiA9PSBtYXhSR0IpIHtcbiAgICAgIHJldHVybiB7IGg6IDAsIHM6IDAsIHY6IG1pblJHQiB9O1xuICAgIH1cblxuICAgIC8vIENvbG9ycyBvdGhlciB0aGFuIGJsYWNrLWdyYXktd2hpdGU6XG4gICAgdmFyIGQgPSByZWQgPT0gbWluUkdCID8gZ3JlZW4gLSBibHVlIDogYmx1ZSA9PSBtaW5SR0IgPyByZWQgLSBncmVlbiA6IGJsdWUgLSByZWQ7XG4gICAgdmFyIGggPSByZWQgPT0gbWluUkdCID8gMyA6IGJsdWUgPT0gbWluUkdCID8gMSA6IDU7XG4gICAgdmFyIGh1ZSA9IDYwICogKGggLSBkIC8gKG1heFJHQiAtIG1pblJHQikpIC8gMzYwO1xuICAgIHZhciBzYXR1cmF0aW9uID0gKG1heFJHQiAtIG1pblJHQikgLyBtYXhSR0I7XG4gICAgdmFyIHZhbHVlID0gbWF4UkdCO1xuICAgIHJldHVybiB7IGg6IGh1ZSwgczogc2F0dXJhdGlvbiwgdjogdmFsdWUgfTtcbiAgfTtcblxuICB2YXIgY3NzVXRpbCA9IHtcbiAgICAvLyBzcGxpdCBhIHN0cmluZyB3aXRoIGNzcyBzdHlsZXMgaW50byBhbiBvYmplY3Qgd2l0aCBrZXkvdmFsdWVzXG4gICAgc3BsaXQ6IGZ1bmN0aW9uIHNwbGl0KGNzc1RleHQpIHtcbiAgICAgIHZhciBzdHlsZXMgPSB7fTtcblxuICAgICAgY3NzVGV4dC5zcGxpdCgnOycpLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgIGlmIChzdHlsZS50cmltKCkgIT0gJycpIHtcbiAgICAgICAgICB2YXIgcGFydHMgPSBzdHlsZS5zcGxpdCgnOicpO1xuICAgICAgICAgIHZhciBrZXkgPSBwYXJ0c1swXS50cmltKCk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gcGFydHNbMV0udHJpbSgpO1xuICAgICAgICAgIHN0eWxlc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH0sXG5cbiAgICAvLyBidWlsZCBhIGNzcyB0ZXh0IHN0cmluZyBmcm9tIGFuIG9iamVjdCB3aXRoIGtleS92YWx1ZXNcbiAgICBqb2luOiBmdW5jdGlvbiBqb2luKHN0eWxlcykge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0eWxlcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSArICc6ICcgKyBzdHlsZXNba2V5XTtcbiAgICAgIH0pLmpvaW4oJzsgJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBcHBlbmQgYSBzdHJpbmcgd2l0aCBjc3Mgc3R5bGVzIHRvIGFuIGVsZW1lbnRcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjc3NUZXh0XG4gICAqL1xuICBleHBvcnRzLmFkZENzc1RleHQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY3NzVGV4dCkge1xuICAgIHZhciBjdXJyZW50U3R5bGVzID0gY3NzVXRpbC5zcGxpdChlbGVtZW50LnN0eWxlLmNzc1RleHQpO1xuICAgIHZhciBuZXdTdHlsZXMgPSBjc3NVdGlsLnNwbGl0KGNzc1RleHQpO1xuICAgIHZhciBzdHlsZXMgPSBleHBvcnRzLmV4dGVuZChjdXJyZW50U3R5bGVzLCBuZXdTdHlsZXMpO1xuXG4gICAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gY3NzVXRpbC5qb2luKHN0eWxlcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHN0cmluZyB3aXRoIGNzcyBzdHlsZXMgZnJvbSBhbiBlbGVtZW50XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY3NzVGV4dFxuICAgKi9cbiAgZXhwb3J0cy5yZW1vdmVDc3NUZXh0ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNzc1RleHQpIHtcbiAgICB2YXIgc3R5bGVzID0gY3NzVXRpbC5zcGxpdChlbGVtZW50LnN0eWxlLmNzc1RleHQpO1xuICAgIHZhciByZW1vdmVTdHlsZXMgPSBjc3NVdGlsLnNwbGl0KGNzc1RleHQpO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHJlbW92ZVN0eWxlcykge1xuICAgICAgaWYgKHJlbW92ZVN0eWxlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGRlbGV0ZSBzdHlsZXNba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBjc3NVdGlsLmpvaW4oc3R5bGVzKTtcbiAgfTtcblxuICAvKipcbiAgICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbWppamFja3Nvbi81MzExMjU2XG4gICAqIEBwYXJhbSBoXG4gICAqIEBwYXJhbSBzXG4gICAqIEBwYXJhbSB2XG4gICAqIEByZXR1cm5zIHt7cjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlcn19XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZXhwb3J0cy5IU1ZUb1JHQiA9IGZ1bmN0aW9uIChoLCBzLCB2KSB7XG4gICAgdmFyIHIsIGcsIGI7XG5cbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoaCAqIDYpO1xuICAgIHZhciBmID0gaCAqIDYgLSBpO1xuICAgIHZhciBwID0gdiAqICgxIC0gcyk7XG4gICAgdmFyIHEgPSB2ICogKDEgLSBmICogcyk7XG4gICAgdmFyIHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyk7XG5cbiAgICBzd2l0Y2ggKGkgJSA2KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHIgPSB2LCBnID0gdCwgYiA9IHA7YnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHIgPSBxLCBnID0gdiwgYiA9IHA7YnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHIgPSBwLCBnID0gdiwgYiA9IHQ7YnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHIgPSBwLCBnID0gcSwgYiA9IHY7YnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHIgPSB0LCBnID0gcCwgYiA9IHY7YnJlYWs7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHIgPSB2LCBnID0gcCwgYiA9IHE7YnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcjogTWF0aC5mbG9vcihyICogMjU1KSwgZzogTWF0aC5mbG9vcihnICogMjU1KSwgYjogTWF0aC5mbG9vcihiICogMjU1KSB9O1xuICB9O1xuXG4gIGV4cG9ydHMuSFNWVG9IZXggPSBmdW5jdGlvbiAoaCwgcywgdikge1xuICAgIHZhciByZ2IgPSBleHBvcnRzLkhTVlRvUkdCKGgsIHMsIHYpO1xuICAgIHJldHVybiBleHBvcnRzLlJHQlRvSGV4KHJnYi5yLCByZ2IuZywgcmdiLmIpO1xuICB9O1xuXG4gIGV4cG9ydHMuaGV4VG9IU1YgPSBmdW5jdGlvbiAoaGV4KSB7XG4gICAgdmFyIHJnYiA9IGV4cG9ydHMuaGV4VG9SR0IoaGV4KTtcbiAgICByZXR1cm4gZXhwb3J0cy5SR0JUb0hTVihyZ2IuciwgcmdiLmcsIHJnYi5iKTtcbiAgfTtcblxuICBleHBvcnRzLmlzVmFsaWRIZXggPSBmdW5jdGlvbiAoaGV4KSB7XG4gICAgdmFyIGlzT2sgPSAvKF4jWzAtOUEtRl17Nn0kKXwoXiNbMC05QS1GXXszfSQpL2kudGVzdChoZXgpO1xuICAgIHJldHVybiBpc09rO1xuICB9O1xuXG4gIGV4cG9ydHMuaXNWYWxpZFJHQiA9IGZ1bmN0aW9uIChyZ2IpIHtcbiAgICByZ2IgPSByZ2IucmVwbGFjZShcIiBcIiwgXCJcIik7XG4gICAgdmFyIGlzT2sgPSAvcmdiXFwoKFxcZHsxLDN9KSwoXFxkezEsM30pLChcXGR7MSwzfSlcXCkvaS50ZXN0KHJnYik7XG4gICAgcmV0dXJuIGlzT2s7XG4gIH07XG4gIGV4cG9ydHMuaXNWYWxpZFJHQkEgPSBmdW5jdGlvbiAocmdiYSkge1xuICAgIHJnYmEgPSByZ2JhLnJlcGxhY2UoXCIgXCIsIFwiXCIpO1xuICAgIHZhciBpc09rID0gL3JnYmFcXCgoXFxkezEsM30pLChcXGR7MSwzfSksKFxcZHsxLDN9KSwoLnsxLDN9KVxcKS9pLnRlc3QocmdiYSk7XG4gICAgcmV0dXJuIGlzT2s7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgcmVjdXJzaXZlbHkgcmVkaXJlY3RzIHRoZSBwcm90b3R5cGUgb2YgSlNPTiBvYmplY3RzIHRvIHRoZSByZWZlcmVuY2VPYmplY3RcbiAgICogVGhpcyBpcyB1c2VkIGZvciBkZWZhdWx0IG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSByZWZlcmVuY2VPYmplY3RcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBleHBvcnRzLnNlbGVjdGl2ZUJyaWRnZU9iamVjdCA9IGZ1bmN0aW9uIChmaWVsZHMsIHJlZmVyZW5jZU9iamVjdCkge1xuICAgIGlmICgodHlwZW9mIHJlZmVyZW5jZU9iamVjdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocmVmZXJlbmNlT2JqZWN0KSkgPT0gXCJvYmplY3RcIikge1xuICAgICAgdmFyIG9iamVjdFRvID0gT2JqZWN0LmNyZWF0ZShyZWZlcmVuY2VPYmplY3QpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJlZmVyZW5jZU9iamVjdC5oYXNPd25Qcm9wZXJ0eShmaWVsZHNbaV0pKSB7XG4gICAgICAgICAgaWYgKF90eXBlb2YocmVmZXJlbmNlT2JqZWN0W2ZpZWxkc1tpXV0pID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIG9iamVjdFRvW2ZpZWxkc1tpXV0gPSBleHBvcnRzLmJyaWRnZU9iamVjdChyZWZlcmVuY2VPYmplY3RbZmllbGRzW2ldXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0VG87XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGhpcyByZWN1cnNpdmVseSByZWRpcmVjdHMgdGhlIHByb3RvdHlwZSBvZiBKU09OIG9iamVjdHMgdG8gdGhlIHJlZmVyZW5jZU9iamVjdFxuICAgKiBUaGlzIGlzIHVzZWQgZm9yIGRlZmF1bHQgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHJlZmVyZW5jZU9iamVjdFxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGV4cG9ydHMuYnJpZGdlT2JqZWN0ID0gZnVuY3Rpb24gKHJlZmVyZW5jZU9iamVjdCkge1xuICAgIGlmICgodHlwZW9mIHJlZmVyZW5jZU9iamVjdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocmVmZXJlbmNlT2JqZWN0KSkgPT0gXCJvYmplY3RcIikge1xuICAgICAgdmFyIG9iamVjdFRvID0gT2JqZWN0LmNyZWF0ZShyZWZlcmVuY2VPYmplY3QpO1xuICAgICAgZm9yICh2YXIgaSBpbiByZWZlcmVuY2VPYmplY3QpIHtcbiAgICAgICAgaWYgKHJlZmVyZW5jZU9iamVjdC5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIGlmIChfdHlwZW9mKHJlZmVyZW5jZU9iamVjdFtpXSkgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgb2JqZWN0VG9baV0gPSBleHBvcnRzLmJyaWRnZU9iamVjdChyZWZlcmVuY2VPYmplY3RbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdFRvO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHByb3ZpZGVzIGEgc3RhYmxlIHNvcnQgaW1wbGVtZW50YXRpb24sIHZlcnkgZmFzdCBmb3IgcHJlc29ydGVkIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIGEgdGhlIGFycmF5XG4gICAqIEBwYXJhbSBhIG9yZGVyIGNvbXBhcmF0b3JcbiAgICogQHJldHVybnMge3RoZSBhcnJheX1cbiAgICovXG4gIGV4cG9ydHMuaW5zZXJ0U29ydCA9IGZ1bmN0aW9uIChhLCBjb21wYXJlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgayA9IGFbaV07XG4gICAgICBmb3IgKHZhciBqID0gaTsgaiA+IDAgJiYgY29tcGFyZShrLCBhW2ogLSAxXSkgPCAwOyBqLS0pIHtcbiAgICAgICAgYVtqXSA9IGFbaiAtIDFdO1xuICAgICAgfVxuICAgICAgYVtqXSA9IGs7XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIC8qKlxuICAgKiB0aGlzIGlzIHVzZWQgdG8gc2V0IHRoZSBvcHRpb25zIG9mIHN1Ym9iamVjdHMgaW4gdGhlIG9wdGlvbnMgb2JqZWN0LiBBIHJlcXVpcmVtZW50IG9mIHRoZXNlIHN1Ym9iamVjdHNcbiAgICogaXMgdGhhdCB0aGV5IGhhdmUgYW4gJ2VuYWJsZWQnIGVsZW1lbnQgd2hpY2ggaXMgb3B0aW9uYWwgZm9yIHRoZSB1c2VyIGJ1dCBtYW5kYXRvcnkgZm9yIHRoZSBwcm9ncmFtLlxuICAgKlxuICAgKiBAcGFyYW0gW29iamVjdF0gbWVyZ2VUYXJnZXQgfCB0aGlzIGlzIGVpdGhlciB0aGlzLm9wdGlvbnMgb3IgdGhlIG9wdGlvbnMgdXNlZCBmb3IgdGhlIGdyb3Vwcy5cbiAgICogQHBhcmFtIFtvYmplY3RdIG9wdGlvbnMgICAgIHwgb3B0aW9uc1xuICAgKiBAcGFyYW0gW1N0cmluZ10gb3B0aW9uICAgICAgfCB0aGlzIGlzIHRoZSBvcHRpb24ga2V5IGluIHRoZSBvcHRpb25zIGFyZ3VtZW50XG4gICAqL1xuICBleHBvcnRzLm1lcmdlT3B0aW9ucyA9IGZ1bmN0aW9uIChtZXJnZVRhcmdldCwgb3B0aW9ucywgb3B0aW9uKSB7XG4gICAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuICAgIHZhciBnbG9iYWxPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB7fTtcblxuICAgIGlmIChvcHRpb25zW29wdGlvbl0gPT09IG51bGwpIHtcbiAgICAgIG1lcmdlVGFyZ2V0W29wdGlvbl0gPSBPYmplY3QuY3JlYXRlKGdsb2JhbE9wdGlvbnNbb3B0aW9uXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25zW29wdGlvbl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNbb3B0aW9uXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgbWVyZ2VUYXJnZXRbb3B0aW9uXS5lbmFibGVkID0gb3B0aW9uc1tvcHRpb25dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChvcHRpb25zW29wdGlvbl0uZW5hYmxlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtZXJnZVRhcmdldFtvcHRpb25dLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnNbb3B0aW9uXSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnNbb3B0aW9uXS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICBtZXJnZVRhcmdldFtvcHRpb25dW3Byb3BdID0gb3B0aW9uc1tvcHRpb25dW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBkb2VzIGEgYmluYXJ5IHNlYXJjaCBmb3IgYSB2aXNpYmxlIGl0ZW0gaW4gYSBzb3J0ZWQgbGlzdC4gSWYgd2UgZmluZCBhIHZpc2libGUgaXRlbSwgdGhlIGNvZGUgdGhhdCB1c2VzXG4gICAqIHRoaXMgZnVuY3Rpb24gd2lsbCB0aGVuIGl0ZXJhdGUgaW4gYm90aCBkaXJlY3Rpb25zIG92ZXIgdGhpcyBzb3J0ZWQgbGlzdCB0byBmaW5kIGFsbCB2aXNpYmxlIGl0ZW1zLlxuICAgKlxuICAgKiBAcGFyYW0ge0l0ZW1bXX0gb3JkZXJlZEl0ZW1zICAgICAgIHwgSXRlbXMgb3JkZXJlZCBieSBzdGFydFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yICAgICAgIHwgLTEgaXMgbG93ZXIsIDAgaXMgZXF1YWwsIDEgaXMgaGlnaGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZmllbGQyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBleHBvcnRzLmJpbmFyeVNlYXJjaEN1c3RvbSA9IGZ1bmN0aW9uIChvcmRlcmVkSXRlbXMsIGNvbXBhcmF0b3IsIGZpZWxkLCBmaWVsZDIpIHtcbiAgICB2YXIgbWF4SXRlcmF0aW9ucyA9IDEwMDAwO1xuICAgIHZhciBpdGVyYXRpb24gPSAwO1xuICAgIHZhciBsb3cgPSAwO1xuICAgIHZhciBoaWdoID0gb3JkZXJlZEl0ZW1zLmxlbmd0aCAtIDE7XG5cbiAgICB3aGlsZSAobG93IDw9IGhpZ2ggJiYgaXRlcmF0aW9uIDwgbWF4SXRlcmF0aW9ucykge1xuICAgICAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG5cbiAgICAgIHZhciBpdGVtID0gb3JkZXJlZEl0ZW1zW21pZGRsZV07XG4gICAgICB2YXIgdmFsdWUgPSBmaWVsZDIgPT09IHVuZGVmaW5lZCA/IGl0ZW1bZmllbGRdIDogaXRlbVtmaWVsZF1bZmllbGQyXTtcblxuICAgICAgdmFyIHNlYXJjaFJlc3VsdCA9IGNvbXBhcmF0b3IodmFsdWUpO1xuICAgICAgaWYgKHNlYXJjaFJlc3VsdCA9PSAwKSB7XG4gICAgICAgIC8vIGppaGFhLCBmb3VuZCBhIHZpc2libGUgaXRlbSFcbiAgICAgICAgcmV0dXJuIG1pZGRsZTtcbiAgICAgIH0gZWxzZSBpZiAoc2VhcmNoUmVzdWx0ID09IC0xKSB7XG4gICAgICAgIC8vIGl0IGlzIHRvbyBzbWFsbCAtLT4gaW5jcmVhc2UgbG93XG4gICAgICAgIGxvdyA9IG1pZGRsZSArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpdCBpcyB0b28gYmlnIC0tPiBkZWNyZWFzZSBoaWdoXG4gICAgICAgIGhpZ2ggPSBtaWRkbGUgLSAxO1xuICAgICAgfVxuXG4gICAgICBpdGVyYXRpb24rKztcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gZG9lcyBhIGJpbmFyeSBzZWFyY2ggZm9yIGEgc3BlY2lmaWMgdmFsdWUgaW4gYSBzb3J0ZWQgYXJyYXkuIElmIGl0IGRvZXMgbm90IGV4aXN0IGJ1dCBpcyBpbiBiZXR3ZWVuIG9mXG4gICAqIHR3byB2YWx1ZXMsIHdlIHJldHVybiBlaXRoZXIgdGhlIG9uZSBiZWZvcmUgb3IgdGhlIG9uZSBhZnRlciwgZGVwZW5kaW5nIG9uIHVzZXIgaW5wdXRcbiAgICogSWYgaXQgaXMgZm91bmQsIHdlIHJldHVybiB0aGUgaW5kZXgsIGVsc2UgLTEuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IG9yZGVyZWRJdGVtc1xuICAgKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHRhcmdldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNpZGVQcmVmZXJlbmNlICAgJ2JlZm9yZScgb3IgJ2FmdGVyJ1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yIGFuIG9wdGlvbmFsIGNvbXBhcmF0b3IsIHJldHVybmluZyAtMSwwLDEgZm9yIDwsPT0sPi5cbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGV4cG9ydHMuYmluYXJ5U2VhcmNoVmFsdWUgPSBmdW5jdGlvbiAob3JkZXJlZEl0ZW1zLCB0YXJnZXQsIGZpZWxkLCBzaWRlUHJlZmVyZW5jZSwgY29tcGFyYXRvcikge1xuICAgIHZhciBtYXhJdGVyYXRpb25zID0gMTAwMDA7XG4gICAgdmFyIGl0ZXJhdGlvbiA9IDA7XG4gICAgdmFyIGxvdyA9IDA7XG4gICAgdmFyIGhpZ2ggPSBvcmRlcmVkSXRlbXMubGVuZ3RoIC0gMTtcbiAgICB2YXIgcHJldlZhbHVlLCB2YWx1ZSwgbmV4dFZhbHVlLCBtaWRkbGU7XG5cbiAgICB2YXIgY29tcGFyYXRvciA9IGNvbXBhcmF0b3IgIT0gdW5kZWZpbmVkID8gY29tcGFyYXRvciA6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYSA9PSBiID8gMCA6IGEgPCBiID8gLTEgOiAxO1xuICAgIH07XG5cbiAgICB3aGlsZSAobG93IDw9IGhpZ2ggJiYgaXRlcmF0aW9uIDwgbWF4SXRlcmF0aW9ucykge1xuICAgICAgLy8gZ2V0IGEgbmV3IGd1ZXNzXG4gICAgICBtaWRkbGUgPSBNYXRoLmZsb29yKDAuNSAqIChoaWdoICsgbG93KSk7XG4gICAgICBwcmV2VmFsdWUgPSBvcmRlcmVkSXRlbXNbTWF0aC5tYXgoMCwgbWlkZGxlIC0gMSldW2ZpZWxkXTtcbiAgICAgIHZhbHVlID0gb3JkZXJlZEl0ZW1zW21pZGRsZV1bZmllbGRdO1xuICAgICAgbmV4dFZhbHVlID0gb3JkZXJlZEl0ZW1zW01hdGgubWluKG9yZGVyZWRJdGVtcy5sZW5ndGggLSAxLCBtaWRkbGUgKyAxKV1bZmllbGRdO1xuXG4gICAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgdGFyZ2V0KSA9PSAwKSB7XG4gICAgICAgIC8vIHdlIGZvdW5kIHRoZSB0YXJnZXRcbiAgICAgICAgcmV0dXJuIG1pZGRsZTtcbiAgICAgIH0gZWxzZSBpZiAoY29tcGFyYXRvcihwcmV2VmFsdWUsIHRhcmdldCkgPCAwICYmIGNvbXBhcmF0b3IodmFsdWUsIHRhcmdldCkgPiAwKSB7XG4gICAgICAgIC8vIHRhcmdldCBpcyBpbiBiZXR3ZWVuIG9mIHRoZSBwcmV2aW91cyBhbmQgdGhlIGN1cnJlbnRcbiAgICAgICAgcmV0dXJuIHNpZGVQcmVmZXJlbmNlID09ICdiZWZvcmUnID8gTWF0aC5tYXgoMCwgbWlkZGxlIC0gMSkgOiBtaWRkbGU7XG4gICAgICB9IGVsc2UgaWYgKGNvbXBhcmF0b3IodmFsdWUsIHRhcmdldCkgPCAwICYmIGNvbXBhcmF0b3IobmV4dFZhbHVlLCB0YXJnZXQpID4gMCkge1xuICAgICAgICAvLyB0YXJnZXQgaXMgaW4gYmV0d2VlbiBvZiB0aGUgY3VycmVudCBhbmQgdGhlIG5leHRcbiAgICAgICAgcmV0dXJuIHNpZGVQcmVmZXJlbmNlID09ICdiZWZvcmUnID8gbWlkZGxlIDogTWF0aC5taW4ob3JkZXJlZEl0ZW1zLmxlbmd0aCAtIDEsIG1pZGRsZSArIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGlkbnQgZmluZCB0aGUgdGFyZ2V0LCB3ZSBuZWVkIHRvIGNoYW5nZSBvdXIgYm91bmRhcmllcy5cbiAgICAgICAgaWYgKGNvbXBhcmF0b3IodmFsdWUsIHRhcmdldCkgPCAwKSB7XG4gICAgICAgICAgLy8gaXQgaXMgdG9vIHNtYWxsIC0tPiBpbmNyZWFzZSBsb3dcbiAgICAgICAgICBsb3cgPSBtaWRkbGUgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGl0IGlzIHRvbyBiaWcgLS0+IGRlY3JlYXNlIGhpZ2hcbiAgICAgICAgICBoaWdoID0gbWlkZGxlIC0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXRlcmF0aW9uKys7XG4gICAgfVxuXG4gICAgLy8gZGlkbnQgZmluZCBhbnl0aGluZy4gUmV0dXJuIC0xLlxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICAvKlxuICAgKiBFYXNpbmcgRnVuY3Rpb25zIC0gaW5zcGlyZWQgZnJvbSBodHRwOi8vZ2l6bWEuY29tL2Vhc2luZy9cbiAgICogb25seSBjb25zaWRlcmluZyB0aGUgdCB2YWx1ZSBmb3IgdGhlIHJhbmdlIFswLCAxXSA9PiBbMCwgMV1cbiAgICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ3JlLzE2NTAyOTRcbiAgICovXG4gIGV4cG9ydHMuZWFzaW5nRnVuY3Rpb25zID0ge1xuICAgIC8vIG5vIGVhc2luZywgbm8gYWNjZWxlcmF0aW9uXG4gICAgbGluZWFyOiBmdW5jdGlvbiBsaW5lYXIodCkge1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfSxcbiAgICAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gICAgZWFzZUluUXVhZDogZnVuY3Rpb24gZWFzZUluUXVhZCh0KSB7XG4gICAgICByZXR1cm4gdCAqIHQ7XG4gICAgfSxcbiAgICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICAgIGVhc2VPdXRRdWFkOiBmdW5jdGlvbiBlYXNlT3V0UXVhZCh0KSB7XG4gICAgICByZXR1cm4gdCAqICgyIC0gdCk7XG4gICAgfSxcbiAgICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgICBlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbiBlYXNlSW5PdXRRdWFkKHQpIHtcbiAgICAgIHJldHVybiB0IDwgLjUgPyAyICogdCAqIHQgOiAtMSArICg0IC0gMiAqIHQpICogdDtcbiAgICB9LFxuICAgIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgICBlYXNlSW5DdWJpYzogZnVuY3Rpb24gZWFzZUluQ3ViaWModCkge1xuICAgICAgcmV0dXJuIHQgKiB0ICogdDtcbiAgICB9LFxuICAgIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gICAgZWFzZU91dEN1YmljOiBmdW5jdGlvbiBlYXNlT3V0Q3ViaWModCkge1xuICAgICAgcmV0dXJuIC0tdCAqIHQgKiB0ICsgMTtcbiAgICB9LFxuICAgIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICAgIGVhc2VJbk91dEN1YmljOiBmdW5jdGlvbiBlYXNlSW5PdXRDdWJpYyh0KSB7XG4gICAgICByZXR1cm4gdCA8IC41ID8gNCAqIHQgKiB0ICogdCA6ICh0IC0gMSkgKiAoMiAqIHQgLSAyKSAqICgyICogdCAtIDIpICsgMTtcbiAgICB9LFxuICAgIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgICBlYXNlSW5RdWFydDogZnVuY3Rpb24gZWFzZUluUXVhcnQodCkge1xuICAgICAgcmV0dXJuIHQgKiB0ICogdCAqIHQ7XG4gICAgfSxcbiAgICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICAgIGVhc2VPdXRRdWFydDogZnVuY3Rpb24gZWFzZU91dFF1YXJ0KHQpIHtcbiAgICAgIHJldHVybiAxIC0gLS10ICogdCAqIHQgKiB0O1xuICAgIH0sXG4gICAgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gICAgZWFzZUluT3V0UXVhcnQ6IGZ1bmN0aW9uIGVhc2VJbk91dFF1YXJ0KHQpIHtcbiAgICAgIHJldHVybiB0IDwgLjUgPyA4ICogdCAqIHQgKiB0ICogdCA6IDEgLSA4ICogLS10ICogdCAqIHQgKiB0O1xuICAgIH0sXG4gICAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICAgIGVhc2VJblF1aW50OiBmdW5jdGlvbiBlYXNlSW5RdWludCh0KSB7XG4gICAgICByZXR1cm4gdCAqIHQgKiB0ICogdCAqIHQ7XG4gICAgfSxcbiAgICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICAgIGVhc2VPdXRRdWludDogZnVuY3Rpb24gZWFzZU91dFF1aW50KHQpIHtcbiAgICAgIHJldHVybiAxICsgLS10ICogdCAqIHQgKiB0ICogdDtcbiAgICB9LFxuICAgIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICAgIGVhc2VJbk91dFF1aW50OiBmdW5jdGlvbiBlYXNlSW5PdXRRdWludCh0KSB7XG4gICAgICByZXR1cm4gdCA8IC41ID8gMTYgKiB0ICogdCAqIHQgKiB0ICogdCA6IDEgKyAxNiAqIC0tdCAqIHQgKiB0ICogdCAqIHQ7XG4gICAgfVxuICB9O1xuXG4gIGV4cG9ydHMuZ2V0U2Nyb2xsQmFyV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgIGlubmVyLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgaW5uZXIuc3R5bGUuaGVpZ2h0ID0gXCIyMDBweFwiO1xuXG4gICAgdmFyIG91dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgb3V0ZXIuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgb3V0ZXIuc3R5bGUudG9wID0gXCIwcHhcIjtcbiAgICBvdXRlci5zdHlsZS5sZWZ0ID0gXCIwcHhcIjtcbiAgICBvdXRlci5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICBvdXRlci5zdHlsZS53aWR0aCA9IFwiMjAwcHhcIjtcbiAgICBvdXRlci5zdHlsZS5oZWlnaHQgPSBcIjE1MHB4XCI7XG4gICAgb3V0ZXIuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgIG91dGVyLmFwcGVuZENoaWxkKGlubmVyKTtcblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3V0ZXIpO1xuICAgIHZhciB3MSA9IGlubmVyLm9mZnNldFdpZHRoO1xuICAgIG91dGVyLnN0eWxlLm92ZXJmbG93ID0gJ3Njcm9sbCc7XG4gICAgdmFyIHcyID0gaW5uZXIub2Zmc2V0V2lkdGg7XG4gICAgaWYgKHcxID09IHcyKSB3MiA9IG91dGVyLmNsaWVudFdpZHRoO1xuXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChvdXRlcik7XG5cbiAgICByZXR1cm4gdzEgLSB3MjtcbiAgfTtcblxuLyoqKi8gfSxcbi8qIDIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBmaXJzdCBjaGVjayBpZiBtb21lbnQuanMgaXMgYWxyZWFkeSBsb2FkZWQgaW4gdGhlIGJyb3dzZXIgd2luZG93LCBpZiBzbyxcbiAgLy8gdXNlIHRoaXMgaW5zdGFuY2UuIEVsc2UsIGxvYWQgdmlhIGNvbW1vbmpzLlxuICBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvd1snbW9tZW50J10gfHwgX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuLyoqKi8gfSxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gIC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihtb2R1bGUpIHsvLyEgbW9tZW50LmpzXG4gIC8vISB2ZXJzaW9uIDogMi4xNS4yXG4gIC8vISBhdXRob3JzIDogVGltIFdvb2QsIElza3JlbiBDaGVybmV2LCBNb21lbnQuanMgY29udHJpYnV0b3JzXG4gIC8vISBsaWNlbnNlIDogTUlUXG4gIC8vISBtb21lbnRqcy5jb21cblxuICA7KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICAgICB0cnVlID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbiAgfSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgICAgdmFyIGhvb2tDYWxsYmFjaztcblxuICAgICAgZnVuY3Rpb24gdXRpbHNfaG9va3NfX2hvb2tzICgpIHtcbiAgICAgICAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4gICAgICAvLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICAgIGZ1bmN0aW9uIHNldEhvb2tDYWxsYmFjayAoY2FsbGJhY2spIHtcbiAgICAgICAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICAgICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5IHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzT2JqZWN0KGlucHV0KSB7XG4gICAgICAgICAgLy8gSUU4IHdpbGwgdHJlYXQgdW5kZWZpbmVkIGFuZCBudWxsIGFzIG9iamVjdCBpZiBpdCB3YXNuJ3QgZm9yXG4gICAgICAgICAgLy8gaW5wdXQgIT0gbnVsbFxuICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc09iamVjdEVtcHR5KG9iaikge1xuICAgICAgICAgIHZhciBrO1xuICAgICAgICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgICAgICAgLy8gZXZlbiBpZiBpdHMgbm90IG93biBwcm9wZXJ0eSBJJ2Qgc3RpbGwgY2FsbCBpdCBub24tZW1wdHlcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1hcChhcnIsIGZuKSB7XG4gICAgICAgICAgdmFyIHJlcyA9IFtdLCBpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGIsIGkpKSB7XG4gICAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgICAgICAgIGEudG9TdHJpbmcgPSBiLnRvU3RyaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjcmVhdGVfdXRjX19jcmVhdGVVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZWZhdWx0UGFyc2luZ0ZsYWdzKCkge1xuICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBlbXB0eSAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgdW51c2VkVG9rZW5zICAgIDogW10sXG4gICAgICAgICAgICAgIHVudXNlZElucHV0ICAgICA6IFtdLFxuICAgICAgICAgICAgICBvdmVyZmxvdyAgICAgICAgOiAtMixcbiAgICAgICAgICAgICAgY2hhcnNMZWZ0T3ZlciAgIDogMCxcbiAgICAgICAgICAgICAgbnVsbElucHV0ICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICAgIGludmFsaWRNb250aCAgICA6IG51bGwsXG4gICAgICAgICAgICAgIGludmFsaWRGb3JtYXQgICA6IGZhbHNlLFxuICAgICAgICAgICAgICB1c2VySW52YWxpZGF0ZWQgOiBmYWxzZSxcbiAgICAgICAgICAgICAgaXNvICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICAgIHBhcnNlZERhdGVQYXJ0cyA6IFtdLFxuICAgICAgICAgICAgICBtZXJpZGllbSAgICAgICAgOiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICAgICAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBtLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG0uX3BmO1xuICAgICAgfVxuXG4gICAgICB2YXIgc29tZTtcbiAgICAgIGlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgICAgICAgIHNvbWUgPSBBcnJheS5wcm90b3R5cGUuc29tZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XG4gICAgICAgICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaSBpbiB0ICYmIGZ1bi5jYWxsKHRoaXMsIHRbaV0sIGksIHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdmFsaWRfX2lzVmFsaWQobSkge1xuICAgICAgICAgIGlmIChtLl9pc1ZhbGlkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIGZsYWdzID0gZ2V0UGFyc2luZ0ZsYWdzKG0pO1xuICAgICAgICAgICAgICB2YXIgcGFyc2VkUGFydHMgPSBzb21lLmNhbGwoZmxhZ3MucGFyc2VkRGF0ZVBhcnRzLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgIT0gbnVsbDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHZhciBpc05vd1ZhbGlkID0gIWlzTmFOKG0uX2QuZ2V0VGltZSgpKSAmJlxuICAgICAgICAgICAgICAgICAgZmxhZ3Mub3ZlcmZsb3cgPCAwICYmXG4gICAgICAgICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkTW9udGggJiZcbiAgICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkV2Vla2RheSAmJlxuICAgICAgICAgICAgICAgICAgIWZsYWdzLm51bGxJbnB1dCAmJlxuICAgICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRGb3JtYXQgJiZcbiAgICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcbiAgICAgICAgICAgICAgICAgICghZmxhZ3MubWVyaWRpZW0gfHwgKGZsYWdzLm1lcmlkaWVtICYmIHBhcnNlZFBhcnRzKSk7XG5cbiAgICAgICAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgICAgICAgaXNOb3dWYWxpZCA9IGlzTm93VmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICBmbGFncy5jaGFyc0xlZnRPdmVyID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgZmxhZ3MudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgIGZsYWdzLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4gPT0gbnVsbCB8fCAhT2JqZWN0LmlzRnJvemVuKG0pKSB7XG4gICAgICAgICAgICAgICAgICBtLl9pc1ZhbGlkID0gaXNOb3dWYWxpZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpc05vd1ZhbGlkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB2YWxpZF9fY3JlYXRlSW52YWxpZCAoZmxhZ3MpIHtcbiAgICAgICAgICB2YXIgbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhOYU4pO1xuICAgICAgICAgIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGV4dGVuZChnZXRQYXJzaW5nRmxhZ3MobSksIGZsYWdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS51c2VySW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBtO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChpbnB1dCkge1xuICAgICAgICAgIHJldHVybiBpbnB1dCA9PT0gdm9pZCAwO1xuICAgICAgfVxuXG4gICAgICAvLyBQbHVnaW5zIHRoYXQgYWRkIHByb3BlcnRpZXMgc2hvdWxkIGFsc28gYWRkIHRoZSBrZXkgaGVyZSAobnVsbCB2YWx1ZSksXG4gICAgICAvLyBzbyB3ZSBjYW4gcHJvcGVybHkgY2xvbmUgb3Vyc2VsdmVzLlxuICAgICAgdmFyIG1vbWVudFByb3BlcnRpZXMgPSB1dGlsc19ob29rc19faG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiBjb3B5Q29uZmlnKHRvLCBmcm9tKSB7XG4gICAgICAgICAgdmFyIGksIHByb3AsIHZhbDtcblxuICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgICAgICAgIHRvLl9pID0gZnJvbS5faTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICAgICAgICB0by5fZiA9IGZyb20uX2Y7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGZvciAoaSBpbiBtb21lbnRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICBwcm9wID0gbW9tZW50UHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0b1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0bztcbiAgICAgIH1cblxuICAgICAgdmFyIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbiAgICAgIGZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICAgICAgICBjb3B5Q29uZmlnKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgICAgICAgIC8vIG9iamVjdHMuXG4gICAgICAgICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc01vbWVudCAob2JqKSB7XG4gICAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFic0Zsb29yIChudW1iZXIpIHtcbiAgICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgICAvLyAtMCAtPiAwXG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKSB8fCAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0b0ludChhcmd1bWVudEZvckNvZXJjaW9uKSB7XG4gICAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgICAgICAgaWYgKGNvZXJjZWROdW1iZXIgIT09IDAgJiYgaXNGaW5pdGUoY29lcmNlZE51bWJlcikpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcbiAgICAgIGZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYXJyYXkxLCBhcnJheTIsIGRvbnRDb252ZXJ0KSB7XG4gICAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgICBkaWZmcyA9IDAsXG4gICAgICAgICAgICAgIGk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmICgoZG9udENvbnZlcnQgJiYgYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHx8XG4gICAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpKSB7XG4gICAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgICAgICAgaWYgKHV0aWxzX2hvb2tzX19ob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgICAodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gd2FybmluZzogJyArIG1zZyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xuICAgICAgICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmICh1dGlsc19ob29rc19faG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgdmFyIGFyZztcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYXJnID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSAnXFxuWycgKyBpICsgJ10gJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9IGtleSArICc6ICcgKyBhcmd1bWVudHNbMF1ba2V5XSArICcsICc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDAsIC0yKTsgLy8gUmVtb3ZlIHRyYWlsaW5nIGNvbW1hIGFuZCBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB3YXJuKG1zZyArICdcXG5Bcmd1bWVudHM6ICcgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKS5qb2luKCcnKSArICdcXG4nICsgKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgICAgICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9LCBmbik7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZXByZWNhdGlvbnMgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gZGVwcmVjYXRlU2ltcGxlKG5hbWUsIG1zZykge1xuICAgICAgICAgIGlmICh1dGlsc19ob29rc19faG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihuYW1lLCBtc2cpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgICB3YXJuKG1zZyk7XG4gICAgICAgICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB1dGlsc19ob29rc19faG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XG4gICAgICB1dGlsc19ob29rc19faG9va3MuZGVwcmVjYXRpb25IYW5kbGVyID0gbnVsbDtcblxuICAgICAgZnVuY3Rpb24gaXNGdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxvY2FsZV9zZXRfX3NldCAoY29uZmlnKSB7XG4gICAgICAgICAgdmFyIHByb3AsIGk7XG4gICAgICAgICAgZm9yIChpIGluIGNvbmZpZykge1xuICAgICAgICAgICAgICBwcm9wID0gY29uZmlnW2ldO1xuICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgICAgICAgLy8gbnVtYmVyICsgKHBvc3NpYmx5KSBzdHVmZiBjb21pbmcgZnJvbSBfb3JkaW5hbFBhcnNlTGVuaWVudC5cbiAgICAgICAgICB0aGlzLl9vcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cCh0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlICsgJ3wnICsgKC9cXGR7MSwyfS8pLnNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSwgcHJvcDtcbiAgICAgICAgICBmb3IgKHByb3AgaW4gY2hpbGRDb25maWcpIHtcbiAgICAgICAgICAgICAgaWYgKGhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBwYXJlbnRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGRDb25maWdbcHJvcF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGNoaWxkQ29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAocHJvcCBpbiBwYXJlbnRDb25maWcpIHtcbiAgICAgICAgICAgICAgaWYgKGhhc093blByb3AocGFyZW50Q29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICFoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICAgICAgIGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcbiAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGV4dGVuZCh7fSwgcmVzW3Byb3BdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XG4gICAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2V0KGNvbmZpZyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIga2V5cztcblxuICAgICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICB2YXIgaSwgcmVzID0gW107XG4gICAgICAgICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWZhdWx0Q2FsZW5kYXIgPSB7XG4gICAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXG4gICAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGxvY2FsZV9jYWxlbmRhcl9fY2FsZW5kYXIgKGtleSwgbW9tLCBub3cpIHtcbiAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XSB8fCB0aGlzLl9jYWxlbmRhclsnc2FtZUVsc2UnXTtcbiAgICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgICAgICAgIExUUyAgOiAnaDptbTpzcyBBJyxcbiAgICAgICAgICBMVCAgIDogJ2g6bW0gQScsXG4gICAgICAgICAgTCAgICA6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgICBMTCAgIDogJ01NTU0gRCwgWVlZWScsXG4gICAgICAgICAgTExMICA6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICAgICAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnXG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBsb25nRGF0ZUZvcm1hdCAoa2V5KSB7XG4gICAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgICAgICAgIGZvcm1hdFVwcGVyID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldO1xuXG4gICAgICAgICAgaWYgKGZvcm1hdCB8fCAhZm9ybWF0VXBwZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gZm9ybWF0VXBwZXIucmVwbGFjZSgvTU1NTXxNTXxERHxkZGRkL2csIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVmYXVsdEludmFsaWREYXRlID0gJ0ludmFsaWQgZGF0ZSc7XG5cbiAgICAgIGZ1bmN0aW9uIGludmFsaWREYXRlICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWZhdWx0T3JkaW5hbCA9ICclZCc7XG4gICAgICB2YXIgZGVmYXVsdE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICAgIGZ1bmN0aW9uIG9yZGluYWwgKG51bWJlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XG4gICAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcbiAgICAgICAgICBwYXN0ICAgOiAnJXMgYWdvJyxcbiAgICAgICAgICBzICA6ICdhIGZldyBzZWNvbmRzJyxcbiAgICAgICAgICBtICA6ICdhIG1pbnV0ZScsXG4gICAgICAgICAgbW0gOiAnJWQgbWludXRlcycsXG4gICAgICAgICAgaCAgOiAnYW4gaG91cicsXG4gICAgICAgICAgaGggOiAnJWQgaG91cnMnLFxuICAgICAgICAgIGQgIDogJ2EgZGF5JyxcbiAgICAgICAgICBkZCA6ICclZCBkYXlzJyxcbiAgICAgICAgICBNICA6ICdhIG1vbnRoJyxcbiAgICAgICAgICBNTSA6ICclZCBtb250aHMnLFxuICAgICAgICAgIHkgIDogJ2EgeWVhcicsXG4gICAgICAgICAgeXkgOiAnJWQgeWVhcnMnXG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiByZWxhdGl2ZV9fcmVsYXRpdmVUaW1lIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcbiAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW3N0cmluZ107XG4gICAgICAgICAgcmV0dXJuIChpc0Z1bmN0aW9uKG91dHB1dCkpID9cbiAgICAgICAgICAgICAgb3V0cHV0KG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkgOlxuICAgICAgICAgICAgICBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGFzdEZ1dHVyZSAoZGlmZiwgb3V0cHV0KSB7XG4gICAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcbiAgICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFsaWFzZXMgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gYWRkVW5pdEFsaWFzICh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICAgICAgICB2YXIgbG93ZXJDYXNlID0gdW5pdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGFsaWFzZXNbbG93ZXJDYXNlXSA9IGFsaWFzZXNbbG93ZXJDYXNlICsgJ3MnXSA9IGFsaWFzZXNbc2hvcnRoYW5kXSA9IHVuaXQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZycgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldIDogdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBub3JtYWxpemVPYmplY3RVbml0cyhpbnB1dE9iamVjdCkge1xuICAgICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgICAgICAgIHByb3A7XG5cbiAgICAgICAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvcCA9IG5vcm1hbGl6ZVVuaXRzKHByb3ApO1xuICAgICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRJbnB1dDtcbiAgICAgIH1cblxuICAgICAgdmFyIHByaW9yaXRpZXMgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gYWRkVW5pdFByaW9yaXR5KHVuaXQsIHByaW9yaXR5KSB7XG4gICAgICAgICAgcHJpb3JpdGllc1t1bml0XSA9IHByaW9yaXR5O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzT2JqKSB7XG4gICAgICAgICAgdmFyIHVuaXRzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgdSBpbiB1bml0c09iaikge1xuICAgICAgICAgICAgICB1bml0cy5wdXNoKHt1bml0OiB1LCBwcmlvcml0eTogcHJpb3JpdGllc1t1XX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdW5pdHM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1ha2VHZXRTZXQgKHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZ2V0X3NldF9fc2V0KHRoaXMsIHVuaXQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0X3NldF9fZ2V0KHRoaXMsIHVuaXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0X3NldF9fZ2V0IChtb20sIHVuaXQpIHtcbiAgICAgICAgICByZXR1cm4gbW9tLmlzVmFsaWQoKSA/XG4gICAgICAgICAgICAgIG1vbS5fZFsnZ2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSgpIDogTmFOO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRfc2V0X19zZXQgKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAobW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTU9NRU5UU1xuXG4gICAgICBmdW5jdGlvbiBzdHJpbmdHZXQgKHVuaXRzKSB7XG4gICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuXG4gICAgICBmdW5jdGlvbiBzdHJpbmdTZXQgKHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdW5pdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplT2JqZWN0VW5pdHModW5pdHMpO1xuICAgICAgICAgICAgICB2YXIgcHJpb3JpdGl6ZWQgPSBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmlvcml0aXplZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgdGhpc1twcmlvcml0aXplZFtpXS51bml0XSh1bml0c1twcmlvcml0aXplZFtpXS51bml0XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10odmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB6ZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCwgZm9yY2VTaWduKSB7XG4gICAgICAgICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICAgICAgICBzaWduID0gbnVtYmVyID49IDA7XG4gICAgICAgICAgcmV0dXJuIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgK1xuICAgICAgICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArIGFic051bWJlcjtcbiAgICAgIH1cblxuICAgICAgdmFyIGZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oW0hoXW1tKHNzKT98TW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UW8/fFlZWVlZWXxZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fGtrP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nO1xuXG4gICAgICB2YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcblxuICAgICAgdmFyIGZvcm1hdEZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgICB2YXIgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuICAgICAgLy8gdG9rZW46ICAgICdNJ1xuICAgICAgLy8gcGFkZGVkOiAgIFsnTU0nLCAyXVxuICAgICAgLy8gb3JkaW5hbDogICdNbydcbiAgICAgIC8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuICAgICAgZnVuY3Rpb24gYWRkRm9ybWF0VG9rZW4gKHRva2VuLCBwYWRkZWQsIG9yZGluYWwsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBjYWxsYmFjaztcbiAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbY2FsbGJhY2tdKCk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFkZGVkKSB7XG4gICAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gemVyb0ZpbGwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBwYWRkZWRbMV0sIHBhZGRlZFsyXSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcmRpbmFsKSB7XG4gICAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW29yZGluYWxdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGlucHV0KSB7XG4gICAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksIGksIGxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV0pIHtcbiAgICAgICAgICAgICAgICAgIGFycmF5W2ldID0gZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYXJyYXlbaV0gPSByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGFycmF5W2ldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobW9tKSB7XG4gICAgICAgICAgICAgIHZhciBvdXRwdXQgPSAnJywgaTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYXJyYXlbaV0gaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpIDogYXJyYXlbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbiAgICAgIGZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcbiAgICAgICAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9IGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdIHx8IG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpO1xuXG4gICAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBleHBhbmRGb3JtYXQoZm9ybWF0LCBsb2NhbGUpIHtcbiAgICAgICAgICB2YXIgaSA9IDU7XG5cbiAgICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5sb25nRGF0ZUZvcm1hdChpbnB1dCkgfHwgaW5wdXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBsb2NhbEZvcm1hdHRpbmdUb2tlbnMudGVzdChmb3JtYXQpKSB7XG4gICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKGxvY2FsRm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKTtcbiAgICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2gxICAgICAgICAgPSAvXFxkLzsgICAgICAgICAgICAvLyAgICAgICAwIC0gOVxuICAgICAgdmFyIG1hdGNoMiAgICAgICAgID0gL1xcZFxcZC87ICAgICAgICAgIC8vICAgICAgMDAgLSA5OVxuICAgICAgdmFyIG1hdGNoMyAgICAgICAgID0gL1xcZHszfS87ICAgICAgICAgLy8gICAgIDAwMCAtIDk5OVxuICAgICAgdmFyIG1hdGNoNCAgICAgICAgID0gL1xcZHs0fS87ICAgICAgICAgLy8gICAgMDAwMCAtIDk5OTlcbiAgICAgIHZhciBtYXRjaDYgICAgICAgICA9IC9bKy1dP1xcZHs2fS87ICAgIC8vIC05OTk5OTkgLSA5OTk5OTlcbiAgICAgIHZhciBtYXRjaDF0bzIgICAgICA9IC9cXGRcXGQ/LzsgICAgICAgICAvLyAgICAgICAwIC0gOTlcbiAgICAgIHZhciBtYXRjaDN0bzQgICAgICA9IC9cXGRcXGRcXGRcXGQ/LzsgICAgIC8vICAgICA5OTkgLSA5OTk5XG4gICAgICB2YXIgbWF0Y2g1dG82ICAgICAgPSAvXFxkXFxkXFxkXFxkXFxkXFxkPy87IC8vICAgOTk5OTkgLSA5OTk5OTlcbiAgICAgIHZhciBtYXRjaDF0bzMgICAgICA9IC9cXGR7MSwzfS87ICAgICAgIC8vICAgICAgIDAgLSA5OTlcbiAgICAgIHZhciBtYXRjaDF0bzQgICAgICA9IC9cXGR7MSw0fS87ICAgICAgIC8vICAgICAgIDAgLSA5OTk5XG4gICAgICB2YXIgbWF0Y2gxdG82ICAgICAgPSAvWystXT9cXGR7MSw2fS87ICAvLyAtOTk5OTk5IC0gOTk5OTk5XG5cbiAgICAgIHZhciBtYXRjaFVuc2lnbmVkICA9IC9cXGQrLzsgICAgICAgICAgIC8vICAgICAgIDAgLSBpbmZcbiAgICAgIHZhciBtYXRjaFNpZ25lZCAgICA9IC9bKy1dP1xcZCsvOyAgICAgIC8vICAgIC1pbmYgLSBpbmZcblxuICAgICAgdmFyIG1hdGNoT2Zmc2V0ICAgID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpOyAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICAgIHZhciBtYXRjaFNob3J0T2Zmc2V0ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vZ2k7IC8vICswMCAtMDAgKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG5cbiAgICAgIHZhciBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy87IC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG5cbiAgICAgIC8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuICAgICAgLy8gaW5jbHVkZXMgc2NvdHRpc2ggZ2FlbGljIHR3byB3b3JkIGFuZCBoeXBoZW5hdGVkIG1vbnRoc1xuICAgICAgdmFyIG1hdGNoV29yZCA9IC9bMC05XSpbJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rfFtcXHUwNjAwLVxcdTA2RkZcXC9dKyhcXHMqP1tcXHUwNjAwLVxcdTA2RkZdKyl7MSwyfS9pO1xuXG5cbiAgICAgIHZhciByZWdleGVzID0ge307XG5cbiAgICAgIGZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4gKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICAgICAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpID8gcmVnZXggOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChpc1N0cmljdCAmJiBzdHJpY3RSZWdleCkgPyBzdHJpY3RSZWdleCA6IHJlZ2V4O1xuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFBhcnNlUmVnZXhGb3JUb2tlbiAodG9rZW4sIGNvbmZpZykge1xuICAgICAgICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuICAgICAgZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgICAgICAgIHJldHVybiByZWdleEVzY2FwZShzLnJlcGxhY2UoJ1xcXFwnLCAnJykucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHAxIHx8IHAyIHx8IHAzIHx8IHA0O1xuICAgICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVnZXhFc2NhcGUocykge1xuICAgICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG9rZW5zID0ge307XG5cbiAgICAgIGZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBpLCBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICAgICAgICAgICAgYXJyYXlbY2FsbGJhY2tdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgICAgIGlmIChpbnB1dCAhPSBudWxsICYmIGhhc093blByb3AodG9rZW5zLCB0b2tlbikpIHtcbiAgICAgICAgICAgICAgdG9rZW5zW3Rva2VuXShpbnB1dCwgY29uZmlnLl9hLCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBZRUFSID0gMDtcbiAgICAgIHZhciBNT05USCA9IDE7XG4gICAgICB2YXIgREFURSA9IDI7XG4gICAgICB2YXIgSE9VUiA9IDM7XG4gICAgICB2YXIgTUlOVVRFID0gNDtcbiAgICAgIHZhciBTRUNPTkQgPSA1O1xuICAgICAgdmFyIE1JTExJU0VDT05EID0gNjtcbiAgICAgIHZhciBXRUVLID0gNztcbiAgICAgIHZhciBXRUVLREFZID0gODtcblxuICAgICAgdmFyIGluZGV4T2Y7XG5cbiAgICAgIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgICAgICAgIGluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAgIC8vIEkga25vd1xuICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSBvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoICsgMSwgMCkpLmdldFVUQ0RhdGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gRk9STUFUVElOR1xuXG4gICAgICBhZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xuICAgICAgfSk7XG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgICB9KTtcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFMSUFTRVNcblxuICAgICAgYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbiAgICAgIC8vIFBSSU9SSVRZXG5cbiAgICAgIGFkZFVuaXRQcmlvcml0eSgnbW9udGgnLCA4KTtcblxuICAgICAgLy8gUEFSU0lOR1xuXG4gICAgICBhZGRSZWdleFRva2VuKCdNJywgICAgbWF0Y2gxdG8yKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ01NJywgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgICBhZGRSZWdleFRva2VuKCdNTU0nLCAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xuICAgICAgfSk7XG4gICAgICBhZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1JlZ2V4KGlzU3RyaWN0KTtcbiAgICAgIH0pO1xuXG4gICAgICBhZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgYXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcbiAgICAgIH0pO1xuXG4gICAgICBhZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgIHZhciBtb250aCA9IGNvbmZpZy5fbG9jYWxlLm1vbnRoc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgICAgICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGFycmF5W01PTlRIXSA9IG1vbnRoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBMT0NBTEVTXG5cbiAgICAgIHZhciBNT05USFNfSU5fRk9STUFUID0gL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccykrTU1NTT8vO1xuICAgICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKTtcbiAgICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSwgZm9ybWF0KSB7XG4gICAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXSA6XG4gICAgICAgICAgICAgIHRoaXMuX21vbnRoc1sodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID0gJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpO1xuICAgICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQgKG0sIGZvcm1hdCkge1xuICAgICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV0gOlxuICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFtNT05USFNfSU5fRk9STUFULnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB1bml0c19tb250aF9faGFuZGxlU3RyaWN0UGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSBtb250aE5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHVzZWRcbiAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZSAobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVuaXRzX21vbnRoX19oYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUT0RPOiBhZGQgc29ydGluZ1xuICAgICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXJcbiAgICAgICAgICAvLyBzZWUgc29ydGluZyBpbiBjb21wdXRlTW9udGhzUGFyc2VcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghc3RyaWN0ICYmICF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKSArICd8XicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU1NJyAmJiB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NJyAmJiB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBNT01FTlRTXG5cbiAgICAgIGZ1bmN0aW9uIHNldE1vbnRoIChtb20sIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGRheU9mTW9udGg7XG5cbiAgICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBpZiAoL15cXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtb20ubG9jYWxlRGF0YSgpLm1vbnRoc1BhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXlPZk1vbnRoID0gTWF0aC5taW4obW9tLmRhdGUoKSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcbiAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgICAgICAgIHJldHVybiBtb207XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFNldE1vbnRoICh2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldF9zZXRfX2dldCh0aGlzLCAnTW9udGgnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldERheXNJbk1vbnRoICgpIHtcbiAgICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWZhdWx0TW9udGhzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbiAgICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgICAgZnVuY3Rpb24gbW9udGhzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IGRlZmF1bHRNb250aHNSZWdleDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNvbXB1dGVNb250aHNQYXJzZSAoKSB7XG4gICAgICAgICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgICAgaSwgbW9tO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgICBtb20gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgICAgICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgfVxuXG4gICAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKCdZJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB5ID0gdGhpcy55ZWFyKCk7XG4gICAgICAgICAgcmV0dXJuIHkgPD0gOTk5OSA/ICcnICsgeSA6ICcrJyArIHk7XG4gICAgICB9KTtcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMueWVhcigpICUgMTAwO1xuICAgICAgfSk7XG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsICAgNF0sICAgICAgIDAsICd5ZWFyJyk7XG4gICAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgIDVdLCAgICAgICAwLCAneWVhcicpO1xuICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcblxuICAgICAgLy8gQUxJQVNFU1xuXG4gICAgICBhZGRVbml0QWxpYXMoJ3llYXInLCAneScpO1xuXG4gICAgICAvLyBQUklPUklUSUVTXG5cbiAgICAgIGFkZFVuaXRQcmlvcml0eSgneWVhcicsIDEpO1xuXG4gICAgICAvLyBQQVJTSU5HXG5cbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ1knLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ1lZJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVknLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgICAgYWRkUGFyc2VUb2tlbihbJ1lZWVlZJywgJ1lZWVlZWSddLCBZRUFSKTtcbiAgICAgIGFkZFBhcnNlVG9rZW4oJ1lZWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgYXJyYXlbWUVBUl0gPSBpbnB1dC5sZW5ndGggPT09IDIgPyB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpIDogdG9JbnQoaW5wdXQpO1xuICAgICAgfSk7XG4gICAgICBhZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICBhcnJheVtZRUFSXSA9IHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgICB9KTtcbiAgICAgIGFkZFBhcnNlVG9rZW4oJ1knLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEhFTFBFUlNcblxuICAgICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgICAgICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gSE9PS1NcblxuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgcmV0dXJuIHRvSW50KGlucHV0KSArICh0b0ludChpbnB1dCkgPiA2OCA/IDE5MDAgOiAyMDAwKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIE1PTUVOVFNcblxuICAgICAgdmFyIGdldFNldFllYXIgPSBtYWtlR2V0U2V0KCdGdWxsWWVhcicsIHRydWUpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRJc0xlYXBZZWFyICgpIHtcbiAgICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGUgKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgICAgICAgLy9jYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAgICAgICAvL2h0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTgxMzQ4L2luc3RhbnRpYXRpbmctYS1qYXZhc2NyaXB0LW9iamVjdC1ieS1jYWxsaW5nLXByb3RvdHlwZS1jb25zdHJ1Y3Rvci1hcHBseVxuICAgICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuXG4gICAgICAgICAgLy90aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSAoeSkge1xuICAgICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG5cbiAgICAgICAgICAvL3RoZSBEYXRlLlVUQyBmdW5jdGlvbiByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgIH1cblxuICAgICAgLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbiAgICAgIGZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICAgIHZhciAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICAgICAgICAgICAgZndkID0gNyArIGRvdyAtIGRveSxcbiAgICAgICAgICAgICAgLy8gZmlyc3Qtd2VlayBkYXkgbG9jYWwgd2Vla2RheSAtLSB3aGljaCBsb2NhbCB3ZWVrZGF5IGlzIGZ3ZFxuICAgICAgICAgICAgICBmd2RsdyA9ICg3ICsgY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCBmd2QpLmdldFVUQ0RheSgpIC0gZG93KSAlIDc7XG5cbiAgICAgICAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbiAgICAgIH1cblxuICAgICAgLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG4gICAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla3MoeWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgICB2YXIgbG9jYWxXZWVrZGF5ID0gKDcgKyB3ZWVrZGF5IC0gZG93KSAlIDcsXG4gICAgICAgICAgICAgIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgICBkYXlPZlllYXIgPSAxICsgNyAqICh3ZWVrIC0gMSkgKyBsb2NhbFdlZWtkYXkgKyB3ZWVrT2Zmc2V0LFxuICAgICAgICAgICAgICByZXNZZWFyLCByZXNEYXlPZlllYXI7XG5cbiAgICAgICAgICBpZiAoZGF5T2ZZZWFyIDw9IDApIHtcbiAgICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xuICAgICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlzSW5ZZWFyKHJlc1llYXIpICsgZGF5T2ZZZWFyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyKSkge1xuICAgICAgICAgICAgICByZXNZZWFyID0geWVhciArIDE7XG4gICAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhciAtIGRheXNJblllYXIoeWVhcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzWWVhciA9IHllYXI7XG4gICAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB5ZWFyOiByZXNZZWFyLFxuICAgICAgICAgICAgICBkYXlPZlllYXI6IHJlc0RheU9mWWVhclxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KG1vbS55ZWFyKCksIGRvdywgZG95KSxcbiAgICAgICAgICAgICAgd2VlayA9IE1hdGguZmxvb3IoKG1vbS5kYXlPZlllYXIoKSAtIHdlZWtPZmZzZXQgLSAxKSAvIDcpICsgMSxcbiAgICAgICAgICAgICAgcmVzV2VlaywgcmVzWWVhcjtcblxuICAgICAgICAgIGlmICh3ZWVrIDwgMSkge1xuICAgICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSAtIDE7XG4gICAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrICsgd2Vla3NJblllYXIocmVzWWVhciwgZG93LCBkb3kpO1xuICAgICAgICAgIH0gZWxzZSBpZiAod2VlayA+IHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KSkge1xuICAgICAgICAgICAgICByZXNXZWVrID0gd2VlayAtIHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KTtcbiAgICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpO1xuICAgICAgICAgICAgICByZXNXZWVrID0gd2VlaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB3ZWVrOiByZXNXZWVrLFxuICAgICAgICAgICAgICB5ZWFyOiByZXNZZWFyXG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgICAgICAgIHdlZWtPZmZzZXROZXh0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIgKyAxLCBkb3csIGRveSk7XG4gICAgICAgICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG4gICAgICB9XG5cbiAgICAgIC8vIEZPUk1BVFRJTkdcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG4gICAgICBhZGRGb3JtYXRUb2tlbignVycsIFsnV1cnLCAyXSwgJ1dvJywgJ2lzb1dlZWsnKTtcblxuICAgICAgLy8gQUxJQVNFU1xuXG4gICAgICBhZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuICAgICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrJywgJ1cnKTtcblxuICAgICAgLy8gUFJJT1JJVElFU1xuXG4gICAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcbiAgICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2VlaycsIDUpO1xuXG4gICAgICAvLyBQQVJTSU5HXG5cbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ3cnLCAgbWF0Y2gxdG8yKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ3d3JywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgICAgYWRkUmVnZXhUb2tlbignVycsICBtYXRjaDF0bzIpO1xuICAgICAgYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICAgIGFkZFdlZWtQYXJzZVRva2VuKFsndycsICd3dycsICdXJywgJ1dXJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBIRUxQRVJTXG5cbiAgICAgIC8vIExPQ0FMRVNcblxuICAgICAgZnVuY3Rpb24gbG9jYWxlV2VlayAobW9tKSB7XG4gICAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIobW9tLCB0aGlzLl93ZWVrLmRvdywgdGhpcy5fd2Vlay5kb3kpLndlZWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICAgICAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mV2VlayAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mWWVhciAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xuICAgICAgfVxuXG4gICAgICAvLyBNT01FTlRTXG5cbiAgICAgIGZ1bmN0aW9uIGdldFNldFdlZWsgKGlucHV0KSB7XG4gICAgICAgICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayAoaW5wdXQpIHtcbiAgICAgICAgICB2YXIgd2VlayA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkud2VlaztcbiAgICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZPUk1BVFRJTkdcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcbiAgICAgIH0pO1xuXG4gICAgICBhZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgICB9KTtcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzKHRoaXMsIGZvcm1hdCk7XG4gICAgICB9KTtcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuICAgICAgYWRkRm9ybWF0VG9rZW4oJ0UnLCAwLCAwLCAnaXNvV2Vla2RheScpO1xuXG4gICAgICAvLyBBTElBU0VTXG5cbiAgICAgIGFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbiAgICAgIGFkZFVuaXRBbGlhcygnd2Vla2RheScsICdlJyk7XG4gICAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4gICAgICAvLyBQUklPUklUWVxuICAgICAgYWRkVW5pdFByaW9yaXR5KCdkYXknLCAxMSk7XG4gICAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtkYXknLCAxMSk7XG4gICAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtkYXknLCAxMSk7XG5cbiAgICAgIC8vIFBBUlNJTkdcblxuICAgICAgYWRkUmVnZXhUb2tlbignZCcsICAgIG1hdGNoMXRvMik7XG4gICAgICBhZGRSZWdleFRva2VuKCdlJywgICAgbWF0Y2gxdG8yKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ0UnLCAgICBtYXRjaDF0bzIpO1xuICAgICAgYWRkUmVnZXhUb2tlbignZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KTtcbiAgICAgIH0pO1xuICAgICAgYWRkUmVnZXhUb2tlbignZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICAgIH0pO1xuICAgICAgYWRkUmVnZXhUb2tlbignZGRkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUmVnZXgoaXNTdHJpY3QpO1xuICAgICAgfSk7XG5cbiAgICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYSB3ZWVrZGF5IG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZFxuICAgICAgICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEhFTFBFUlNcblxuICAgICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5wdXQgPSBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCkgJSA3IHx8IDc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpc05hTihpbnB1dCkgPyBudWxsIDogaW5wdXQ7XG4gICAgICB9XG5cbiAgICAgIC8vIExPQ0FMRVNcblxuICAgICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKTtcbiAgICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzIChtLCBmb3JtYXQpIHtcbiAgICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl93ZWVrZGF5cykgPyB0aGlzLl93ZWVrZGF5c1ttLmRheSgpXSA6XG4gICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzW3RoaXMuX3dlZWtkYXlzLmlzRm9ybWF0LnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLmRheSgpXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0ID0gJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKTtcbiAgICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzU2hvcnQgKG0pIHtcbiAgICAgICAgICByZXR1cm4gKG0pID8gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzU2hvcnQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyk7XG4gICAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c01pbiAobSkge1xuICAgICAgICAgIHJldHVybiAobSkgPyB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzTWluO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkYXlfb2Zfd2Vla19faGFuZGxlU3RyaWN0UGFyc2Uod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgICAgdmFyIGksIGlpLCBtb20sIGxsYyA9IHdlZWtkYXlOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcblxuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgKytpKSB7XG4gICAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNQYXJzZSAod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBkYXlfb2Zfd2Vla19faGFuZGxlU3RyaWN0UGFyc2UuY2FsbCh0aGlzLCB3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcblxuICAgICAgICAgICAgICBtb20gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGRkJyAmJiB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZCcgJiYgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGQnICYmIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE1PTUVOVFNcblxuICAgICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGF5ID0gdGhpcy5faXNVVEMgPyB0aGlzLl9kLmdldFVUQ0RheSgpIDogdGhpcy5fZC5nZXREYXkoKTtcbiAgICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoaW5wdXQgLSBkYXksICdkJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRheTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHdlZWtkYXkgPSAodGhpcy5kYXkoKSArIDcgLSB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3cpICUgNztcbiAgICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChpbnB1dCAtIHdlZWtkYXksICdkJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFNldElTT0RheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgICAgICAgLy8gYXMgYSBnZXR0ZXIsIHJldHVybnMgNyBpbnN0ZWFkIG9mIDAgKDEtNyByYW5nZSBpbnN0ZWFkIG9mIDAtNilcbiAgICAgICAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG5cbiAgICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgd2Vla2RheSA9IHBhcnNlSXNvV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyB3ZWVrZGF5IDogd2Vla2RheSAtIDcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSgpIHx8IDc7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZGVmYXVsdFdlZWtkYXlzUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgICBmdW5jdGlvbiB3ZWVrZGF5c1JlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1JlZ2V4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgICBmdW5jdGlvbiB3ZWVrZGF5c1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgICAgZnVuY3Rpb24gd2Vla2RheXNNaW5SZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c01pblJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSBkZWZhdWx0V2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cblxuICAgICAgZnVuY3Rpb24gY29tcHV0ZVdlZWtkYXlzUGFyc2UgKCkge1xuICAgICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBtaW5QaWVjZXMgPSBbXSwgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgICBpLCBtb20sIG1pbnAsIHNob3J0cCwgbG9uZ3A7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgICBtaW5wID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgICAgc2hvcnRwID0gdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgICBsb25ncCA9IHRoaXMud2Vla2RheXMobW9tLCAnJyk7XG4gICAgICAgICAgICAgIG1pblBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgd2Vla2RheSAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgICBtaW5QaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG5cbiAgICAgICAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaW5QaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgfVxuXG4gICAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICAgIGZ1bmN0aW9uIGhGb3JtYXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBrRm9ybWF0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgfHwgMjQ7XG4gICAgICB9XG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xuICAgICAgYWRkRm9ybWF0VG9rZW4oJ2gnLCBbJ2hoJywgMl0sIDAsIGhGb3JtYXQpO1xuICAgICAgYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xuXG4gICAgICBhZGRGb3JtYXRUb2tlbignaG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgICB9KTtcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oJ2htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMik7XG4gICAgICB9KTtcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgICB9KTtcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBtZXJpZGllbSAodG9rZW4sIGxvd2VyY2FzZSkge1xuICAgICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCBsb3dlcmNhc2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBtZXJpZGllbSgnYScsIHRydWUpO1xuICAgICAgbWVyaWRpZW0oJ0EnLCBmYWxzZSk7XG5cbiAgICAgIC8vIEFMSUFTRVNcblxuICAgICAgYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuICAgICAgLy8gUFJJT1JJVFlcbiAgICAgIGFkZFVuaXRQcmlvcml0eSgnaG91cicsIDEzKTtcblxuICAgICAgLy8gUEFSU0lOR1xuXG4gICAgICBmdW5jdGlvbiBtYXRjaE1lcmlkaWVtIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbiAgICAgIH1cblxuICAgICAgYWRkUmVnZXhUb2tlbignYScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ0EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgICBhZGRSZWdleFRva2VuKCdIJywgIG1hdGNoMXRvMik7XG4gICAgICBhZGRSZWdleFRva2VuKCdoJywgIG1hdGNoMXRvMik7XG4gICAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ2hoJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgICBhZGRSZWdleFRva2VuKCdobW0nLCBtYXRjaDN0bzQpO1xuICAgICAgYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuICAgICAgYWRkUmVnZXhUb2tlbignSG1tJywgbWF0Y2gzdG80KTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ0htbXNzJywgbWF0Y2g1dG82KTtcblxuICAgICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgICBhZGRQYXJzZVRva2VuKFsnYScsICdBJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICAgIGNvbmZpZy5faXNQbSA9IGNvbmZpZy5fbG9jYWxlLmlzUE0oaW5wdXQpO1xuICAgICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICAgIH0pO1xuICAgICAgYWRkUGFyc2VUb2tlbihbJ2gnLCAnaGgnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIGFkZFBhcnNlVG9rZW4oJ0htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICB9KTtcbiAgICAgIGFkZFBhcnNlVG9rZW4oJ0htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gTE9DQUxFU1xuXG4gICAgICBmdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xuICAgICAgICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcbiAgICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICAgICAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2k7XG4gICAgICBmdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2FtJyA6ICdBTSc7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgICAgIC8vIE1PTUVOVFNcblxuICAgICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgICAvLyBzcGVjaWZpZWQgd2hpY2ggaG91ciBoZSB3YW50cy4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4gICAgICAvLyBhIG5ldyB0aW1lem9uZSkgbWFrZXMgc2Vuc2UuIEFkZGluZy9zdWJ0cmFjdGluZyBob3VycyBkb2VzIG5vdCBmb2xsb3dcbiAgICAgIC8vIHRoaXMgcnVsZS5cbiAgICAgIHZhciBnZXRTZXRIb3VyID0gbWFrZUdldFNldCgnSG91cnMnLCB0cnVlKTtcblxuICAgICAgdmFyIGJhc2VDb25maWcgPSB7XG4gICAgICAgICAgY2FsZW5kYXI6IGRlZmF1bHRDYWxlbmRhcixcbiAgICAgICAgICBsb25nRGF0ZUZvcm1hdDogZGVmYXVsdExvbmdEYXRlRm9ybWF0LFxuICAgICAgICAgIGludmFsaWREYXRlOiBkZWZhdWx0SW52YWxpZERhdGUsXG4gICAgICAgICAgb3JkaW5hbDogZGVmYXVsdE9yZGluYWwsXG4gICAgICAgICAgb3JkaW5hbFBhcnNlOiBkZWZhdWx0T3JkaW5hbFBhcnNlLFxuICAgICAgICAgIHJlbGF0aXZlVGltZTogZGVmYXVsdFJlbGF0aXZlVGltZSxcblxuICAgICAgICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICAgICAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxuXG4gICAgICAgICAgd2VlazogZGVmYXVsdExvY2FsZVdlZWssXG5cbiAgICAgICAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgICAgICAgIHdlZWtkYXlzTWluOiBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4sXG4gICAgICAgICAgd2Vla2RheXNTaG9ydDogZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQsXG5cbiAgICAgICAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZVxuICAgICAgfTtcblxuICAgICAgLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbG9jYWxlIGNvbmZpZyBmaWxlc1xuICAgICAgdmFyIGxvY2FsZXMgPSB7fTtcbiAgICAgIHZhciBnbG9iYWxMb2NhbGU7XG5cbiAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZShrZXkpIHtcbiAgICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgICB9XG5cbiAgICAgIC8vIHBpY2sgdGhlIGxvY2FsZSBmcm9tIHRoZSBhcnJheVxuICAgICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAgIC8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbiAgICAgIGZ1bmN0aW9uIGNob29zZUxvY2FsZShuYW1lcykge1xuICAgICAgICAgIHZhciBpID0gMCwgaiwgbmV4dCwgbG9jYWxlLCBzcGxpdDtcblxuICAgICAgICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XG4gICAgICAgICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQubGVuZ3RoID49IGogJiYgY29tcGFyZUFycmF5cyhzcGxpdCwgbmV4dCwgdHJ1ZSkgPj0gaiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgICAgICAgdmFyIG9sZExvY2FsZSA9IG51bGw7XG4gICAgICAgICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICAgICAgICBpZiAoIWxvY2FsZXNbbmFtZV0gJiYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICAgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBvbGRMb2NhbGUgPSBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgICAgICAgICAgICAgICAhKGZ1bmN0aW9uIHdlYnBhY2tNaXNzaW5nTW9kdWxlKCkgeyB2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSBcXFwiLi9sb2NhbGVcXFwiXCIpOyBlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7IHRocm93IGU7IH0oKSk7XG4gICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGRlZmluZUxvY2FsZSBjdXJyZW50bHkgYWxzbyBzZXRzIHRoZSBnbG9iYWwgbG9jYWxlLCB3ZVxuICAgICAgICAgICAgICAgICAgLy8gd2FudCB0byB1bmRvIHRoYXQgZm9yIGxhenkgbG9hZGVkIGxvY2FsZXNcbiAgICAgICAgICAgICAgICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCBsb2NhbGUgYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgbG9jYWxlLiAgSWZcbiAgICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXG4gICAgICAvLyBsb2NhbGUga2V5LlxuICAgICAgZnVuY3Rpb24gbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICBkYXRhID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICBnbG9iYWxMb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVmaW5lTG9jYWxlIChuYW1lLCBjb25maWcpIHtcbiAgICAgICAgICBpZiAoY29uZmlnICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuICAgICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZSgnZGVmaW5lTG9jYWxlT3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhbiBleGlzdGluZyBsb2NhbGUuIG1vbWVudC5kZWZpbmVMb2NhbGUobG9jYWxlTmFtZSwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdjb25maWcpIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIGNyZWF0aW5nIGEgbmV3IGxvY2FsZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW25hbWVdLl9jb25maWc7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXS5fY29uZmlnO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyB0cmVhdCBhcyBpZiB0aGVyZSBpcyBubyBiYXNlIGNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZSgncGFyZW50TG9jYWxlVW5kZWZpbmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzcGVjaWZpZWQgcGFyZW50TG9jYWxlIGlzIG5vdCBkZWZpbmVkIHlldC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvcGFyZW50LWxvY2FsZS8nKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbmV3IExvY2FsZShtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpKTtcblxuICAgICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZShuYW1lKTtcblxuICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdXBkYXRlTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgbG9jYWxlLCBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuICAgICAgICAgICAgICAvLyBNRVJHRVxuICAgICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW25hbWVdLl9jb25maWc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uZmlnID0gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKTtcbiAgICAgICAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xuICAgICAgICAgICAgICBsb2NhbGUucGFyZW50TG9jYWxlID0gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZTtcblxuICAgICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBwYXNzIG51bGwgZm9yIGNvbmZpZyB0byB1bnVwZGF0ZSwgdXNlZnVsIGZvciB0ZXN0c1xuICAgICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgICB9XG5cbiAgICAgIC8vIHJldHVybnMgbG9jYWxlIGRhdGFcbiAgICAgIGZ1bmN0aW9uIGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUgKGtleSkge1xuICAgICAgICAgIHZhciBsb2NhbGU7XG5cbiAgICAgICAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XG4gICAgICAgICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGtleSk7XG4gICAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAga2V5ID0gW2tleV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNob29zZUxvY2FsZShrZXkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsb2NhbGVfbG9jYWxlc19fbGlzdExvY2FsZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIGtleXMobG9jYWxlcyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICAgICAgICB2YXIgb3ZlcmZsb3c7XG4gICAgICAgICAgdmFyIGEgPSBtLl9hO1xuXG4gICAgICAgICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgICBvdmVyZmxvdyA9XG4gICAgICAgICAgICAgICAgICBhW01PTlRIXSAgICAgICA8IDAgfHwgYVtNT05USF0gICAgICAgPiAxMSAgPyBNT05USCA6XG4gICAgICAgICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgICAgICAgIGFbSE9VUl0gICAgICAgIDwgMCB8fCBhW0hPVVJdICAgICAgICA+IDI0IHx8IChhW0hPVVJdID09PSAyNCAmJiAoYVtNSU5VVEVdICE9PSAwIHx8IGFbU0VDT05EXSAhPT0gMCB8fCBhW01JTExJU0VDT05EXSAhPT0gMCkpID8gSE9VUiA6XG4gICAgICAgICAgICAgICAgICBhW01JTlVURV0gICAgICA8IDAgfHwgYVtNSU5VVEVdICAgICAgPiA1OSAgPyBNSU5VVEUgOlxuICAgICAgICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdIDwgMCB8fCBhW01JTExJU0VDT05EXSA+IDk5OSA/IE1JTExJU0VDT05EIDpcbiAgICAgICAgICAgICAgICAgIC0xO1xuXG4gICAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG07XG4gICAgICB9XG5cbiAgICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgICAvLyAwMDAwLTAwLTAwIDAwMDAtVzAwIG9yIDAwMDAtVzAwLTAgKyBUICsgMDAgb3IgMDA6MDAgb3IgMDA6MDA6MDAgb3IgMDA6MDA6MDAuMDAwICsgKzAwOjAwIG9yICswMDAwIG9yICswMClcbiAgICAgIHZhciBleHRlbmRlZElzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzpcXGRcXGQtXFxkXFxkfFdcXGRcXGQtXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86OlxcZFxcZCg/OjpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPy87XG4gICAgICB2YXIgYmFzaWNJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSkoPzpcXGRcXGRcXGRcXGR8V1xcZFxcZFxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OlxcZFxcZCg/OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/LztcblxuICAgICAgdmFyIHR6UmVnZXggPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy87XG5cbiAgICAgIHZhciBpc29EYXRlcyA9IFtcbiAgICAgICAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcbiAgICAgICAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L10sXG4gICAgICAgICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgICAgWydZWVlZWVlNTUREJywgL1srLV1cXGR7MTB9L10sXG4gICAgICAgICAgWydZWVlZTU1ERCcsIC9cXGR7OH0vXSxcbiAgICAgICAgICAvLyBZWVlZTU0gaXMgTk9UIGFsbG93ZWQgYnkgdGhlIHN0YW5kYXJkXG4gICAgICAgICAgWydHR0dHW1ddV1dFJywgL1xcZHs0fVdcXGR7M30vXSxcbiAgICAgICAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxuICAgICAgICAgIFsnWVlZWURERCcsIC9cXGR7N30vXVxuICAgICAgXTtcblxuICAgICAgLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xuICAgICAgdmFyIGlzb1RpbWVzID0gW1xuICAgICAgICAgIFsnSEg6bW06c3MuU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgICBbJ0hIOm1tOnNzLFNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQsXFxkKy9dLFxuICAgICAgICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgICBbJ0hIOm1tJywgL1xcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgICBbJ0hIbW1zcy5TU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgICAgICAgWydISG1tc3MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkL10sXG4gICAgICAgICAgWydISG1tJywgL1xcZFxcZFxcZFxcZC9dLFxuICAgICAgICAgIFsnSEgnLCAvXFxkXFxkL11cbiAgICAgIF07XG5cbiAgICAgIHZhciBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4gICAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuICAgICAgZnVuY3Rpb24gY29uZmlnRnJvbUlTTyhjb25maWcpIHtcbiAgICAgICAgICB2YXIgaSwgbCxcbiAgICAgICAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgICBtYXRjaCA9IGV4dGVuZGVkSXNvUmVnZXguZXhlYyhzdHJpbmcpIHx8IGJhc2ljSXNvUmVnZXguZXhlYyhzdHJpbmcpLFxuICAgICAgICAgICAgICBhbGxvd1RpbWUsIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIHR6Rm9ybWF0O1xuXG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdCA9IGlzb0RhdGVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICAgIGFsbG93VGltZSA9IGlzb0RhdGVzW2ldWzJdICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29UaW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNvVGltZXNbaV1bMV0uZXhlYyhtYXRjaFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbMl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lRm9ybWF0ID0gKG1hdGNoWzJdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHRpbWVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWFsbG93VGltZSAmJiB0aW1lRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR6UmVnZXguZXhlYyhtYXRjaFs0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0ekZvcm1hdCA9ICdaJztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbmZpZy5fZiA9IGRhdGVGb3JtYXQgKyAodGltZUZvcm1hdCB8fCAnJykgKyAodHpGb3JtYXQgfHwgJycpO1xuICAgICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdCBvciBmYWxsYmFja1xuICAgICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICAgICAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG5cbiAgICAgICAgICBpZiAobWF0Y2hlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB1dGlsc19ob29rc19faG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2sgPSBkZXByZWNhdGUoXG4gICAgICAgICAgJ3ZhbHVlIHByb3ZpZGVkIGlzIG5vdCBpbiBhIHJlY29nbml6ZWQgSVNPIGZvcm1hdC4gbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUoKSwgJyArXG4gICAgICAgICAgJ3doaWNoIGlzIG5vdCByZWxpYWJsZSBhY3Jvc3MgYWxsIGJyb3dzZXJzIGFuZCB2ZXJzaW9ucy4gTm9uIElTTyBkYXRlIGZvcm1hdHMgYXJlICcgK1xuICAgICAgICAgICdkaXNjb3VyYWdlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGFuIHVwY29taW5nIG1ham9yIHJlbGVhc2UuIFBsZWFzZSByZWZlciB0byAnICtcbiAgICAgICAgICAnaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9qcy1kYXRlLyBmb3IgbW9yZSBpbmZvLicsXG4gICAgICAgICAgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIC8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cbiAgICAgIGZ1bmN0aW9uIGRlZmF1bHRzKGEsIGIsIGMpIHtcbiAgICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAgICAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgICAgICAgIHZhciBub3dWYWx1ZSA9IG5ldyBEYXRlKHV0aWxzX2hvb2tzX19ob29rcy5ub3coKSk7XG4gICAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0VVRDRnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0VVRDTW9udGgoKSwgbm93VmFsdWUuZ2V0VVRDRGF0ZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRNb250aCgpLCBub3dWYWx1ZS5nZXREYXRlKCldO1xuICAgICAgfVxuXG4gICAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAgIC8vIHRoZSBhcnJheSBzaG91bGQgbWlycm9yIHRoZSBwYXJhbWV0ZXJzIGJlbG93XG4gICAgICAvLyBub3RlOiBhbGwgdmFsdWVzIHBhc3QgdGhlIHllYXIgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGRlZmF1bHQgdG8gdGhlIGxvd2VzdCBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgICAgZnVuY3Rpb24gY29uZmlnRnJvbUFycmF5IChjb25maWcpIHtcbiAgICAgICAgICB2YXIgaSwgZGF0ZSwgaW5wdXQgPSBbXSwgY3VycmVudERhdGUsIHllYXJUb1VzZTtcblxuICAgICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xuXG4gICAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgICAgICAgIGlmIChjb25maWcuX3cgJiYgY29uZmlnLl9hW0RBVEVdID09IG51bGwgJiYgY29uZmlnLl9hW01PTlRIXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vaWYgdGhlIGRheSBvZiB0aGUgeWVhciBpcyBzZXQsIGZpZ3VyZSBvdXQgd2hhdCBpdCBpc1xuICAgICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhcikge1xuICAgICAgICAgICAgICB5ZWFyVG9Vc2UgPSBkZWZhdWx0cyhjb25maWcuX2FbWUVBUl0sIGN1cnJlbnREYXRlW1lFQVJdKTtcblxuICAgICAgICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkpIHtcbiAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgICAgICAgY29uZmlnLl9hW01PTlRIXSA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IGRhdGUuXG4gICAgICAgICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgICAgICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgICAgLy8gKiBpZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBvbmx5IHllYXJcbiAgICAgICAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gY3VycmVudERhdGVbaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgICAgICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSAoY29uZmlnLl9hW2ldID09IG51bGwpID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIDI0OjAwOjAwLjAwMFxuICAgICAgICAgIGlmIChjb25maWcuX2FbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgY29uZmlnLl9hW1NFQ09ORF0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtNSUxMSVNFQ09ORF0gPT09IDApIHtcbiAgICAgICAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgICAgICAgIC8vIEFwcGx5IHRpbWV6b25lIG9mZnNldCBmcm9tIGlucHV0LiBUaGUgYWN0dWFsIHV0Y09mZnNldCBjYW4gYmUgY2hhbmdlZFxuICAgICAgICAgIC8vIHdpdGggcGFyc2Vab25lLlxuICAgICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAyNDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpIHtcbiAgICAgICAgICB2YXIgdywgd2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95LCB0ZW1wLCB3ZWVrZGF5T3ZlcmZsb3c7XG5cbiAgICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgZG93ID0gMTtcbiAgICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHRha2UgdGhlIGN1cnJlbnQgaXNvV2Vla1llYXIsIGJ1dCB0aGF0IGRlcGVuZHMgb25cbiAgICAgICAgICAgICAgLy8gaG93IHdlIGludGVycHJldCBub3cgKGxvY2FsLCB1dGMsIGZpeGVkIG9mZnNldCkuIFNvIGNyZWF0ZVxuICAgICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgICAvLyBjcmVhdGUgbm93KS5cbiAgICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LkdHLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIobG9jYWxfX2NyZWF0ZUxvY2FsKCksIDEsIDQpLnllYXIpO1xuICAgICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody5XLCAxKTtcbiAgICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMSB8fCB3ZWVrZGF5ID4gNykge1xuICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcbiAgICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5nZywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGxvY2FsX19jcmVhdGVMb2NhbCgpLCBkb3csIGRveSkueWVhcik7XG4gICAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIDEpO1xuXG4gICAgICAgICAgICAgIGlmICh3LmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgLy8gd2Vla2RheSAtLSBsb3cgZGF5IG51bWJlcnMgYXJlIGNvbnNpZGVyZWQgbmV4dCB3ZWVrXG4gICAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAwIHx8IHdlZWtkYXkgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh3LmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgLy8gbG9jYWwgd2Vla2RheSAtLSBjb3VudGluZyBzdGFydHMgZnJvbSBiZWdpbmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5lICsgZG93O1xuICAgICAgICAgICAgICAgICAgaWYgKHcuZSA8IDAgfHwgdy5lID4gNikge1xuICAgICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGJlZ2luaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHdlZWsgPCAxIHx8IHdlZWsgPiB3ZWVrc0luWWVhcih3ZWVrWWVhciwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdlZWtkYXlPdmVyZmxvdyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtkYXkgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRlbXAgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gdGVtcC55ZWFyO1xuICAgICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLklTT184NjAxID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmdcbiAgICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIGFub3RoZXIgcGFydCBvZiB0aGUgY3JlYXRpb24gZmxvdyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcHNcbiAgICAgICAgICBpZiAoY29uZmlnLl9mID09PSB1dGlsc19ob29rc19faG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uZmlnLl9hID0gW107XG4gICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXG4gICAgICAgICAgICAgIGksIHBhcnNlZElucHV0LCB0b2tlbnMsIHRva2VuLCBza2lwcGVkLFxuICAgICAgICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMDtcblxuICAgICAgICAgIHRva2VucyA9IGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGNvbmZpZy5fbG9jYWxlKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICAgIHBhcnNlZElucHV0ID0gKHN0cmluZy5tYXRjaChnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpIHx8IFtdKVswXTtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3Rva2VuJywgdG9rZW4sICdwYXJzZWRJbnB1dCcsIHBhcnNlZElucHV0LFxuICAgICAgICAgICAgICAvLyAgICAgICAgICdyZWdleCcsIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSk7XG4gICAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgc2tpcHBlZCA9IHN0cmluZy5zdWJzdHIoMCwgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpKTtcbiAgICAgICAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHNraXBwZWQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoICs9IHBhcnNlZElucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0pIHtcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLl9zdHJpY3QgJiYgIXBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXG4gICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9IHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBjbGVhciBfMTJoIGZsYWcgaWYgaG91ciBpcyA8PSAxMlxuICAgICAgICAgIGlmIChjb25maWcuX2FbSE9VUl0gPD0gMTIgJiZcbiAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPiAwKSB7XG4gICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucGFyc2VkRGF0ZVBhcnRzID0gY29uZmlnLl9hLnNsaWNlKDApO1xuICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLm1lcmlkaWVtID0gY29uZmlnLl9tZXJpZGllbTtcbiAgICAgICAgICAvLyBoYW5kbGUgbWVyaWRpZW1cbiAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSBtZXJpZGllbUZpeFdyYXAoY29uZmlnLl9sb2NhbGUsIGNvbmZpZy5fYVtIT1VSXSwgY29uZmlnLl9tZXJpZGllbSk7XG5cbiAgICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgICB9XG5cblxuICAgICAgZnVuY3Rpb24gbWVyaWRpZW1GaXhXcmFwIChsb2NhbGUsIGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgICAgICAgdmFyIGlzUG07XG5cbiAgICAgICAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobG9jYWxlLm1lcmlkaWVtSG91ciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gRmFsbGJhY2tcbiAgICAgICAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgICBob3VyICs9IDEyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbiAgICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpIHtcbiAgICAgICAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgICAgICAgYmVzdE1vbWVudCxcblxuICAgICAgICAgICAgICBzY29yZVRvQmVhdCxcbiAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgY3VycmVudFNjb3JlO1xuXG4gICAgICAgICAgaWYgKGNvbmZpZy5fZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEZvcm1hdCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnLl9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XG4gICAgICAgICAgICAgIHRlbXBDb25maWcgPSBjb3B5Q29uZmlnKHt9LCBjb25maWcpO1xuICAgICAgICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdGVtcENvbmZpZy5fdXNlVVRDID0gY29uZmlnLl91c2VVVEM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdCh0ZW1wQ29uZmlnKTtcblxuICAgICAgICAgICAgICBpZiAoIXZhbGlkX19pc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAgICAgICAvL29yIHRva2Vuc1xuICAgICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHRlbmQoY29uZmlnLCBiZXN0TW9tZW50IHx8IHRlbXBDb25maWcpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xuICAgICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKTtcbiAgICAgICAgICBjb25maWcuX2EgPSBtYXAoW2kueWVhciwgaS5tb250aCwgaS5kYXkgfHwgaS5kYXRlLCBpLmhvdXIsIGkubWludXRlLCBpLnNlY29uZCwgaS5taWxsaXNlY29uZF0sIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgICB2YXIgcmVzID0gbmV3IE1vbWVudChjaGVja092ZXJmbG93KHByZXBhcmVDb25maWcoY29uZmlnKSkpO1xuICAgICAgICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgICAgICAgIHJlcy5hZGQoMSwgJ2QnKTtcbiAgICAgICAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHByZXBhcmVDb25maWcgKGNvbmZpZykge1xuICAgICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgICAgZm9ybWF0ID0gY29uZmlnLl9mO1xuXG4gICAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKGNvbmZpZy5fbCk7XG5cbiAgICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkX19jcmVhdGVJbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb25maWcuX2kgPSBpbnB1dCA9IGNvbmZpZy5fbG9jYWxlLnByZXBhcnNlKGlucHV0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNNb21lbnQoaW5wdXQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coaW5wdXQpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgICAgY29uZmlnLl9kID0gaW5wdXQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICAgIH0gIGVsc2Uge1xuICAgICAgICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXZhbGlkX19pc1ZhbGlkKGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgY29uZmlnLl9kID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XG4gICAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pO1xuICAgICAgICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHV0aWxzX2hvb2tzX19ob29rcy5ub3coKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0LnZhbHVlT2YoKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoaW5wdXQpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoaW5wdXQpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbE9yVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgaXNVVEMpIHtcbiAgICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgICAgaWYgKHR5cGVvZihsb2NhbGUpID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgc3RyaWN0ID0gbG9jYWxlO1xuICAgICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKChpc09iamVjdChpbnB1dCkgJiYgaXNPYmplY3RFbXB0eShpbnB1dCkpIHx8XG4gICAgICAgICAgICAgICAgICAoaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICAgICAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgICAgICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XG4gICAgICAgICAgYy5fbCA9IGxvY2FsZTtcbiAgICAgICAgICBjLl9pID0gaW5wdXQ7XG4gICAgICAgICAgYy5fZiA9IGZvcm1hdDtcbiAgICAgICAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICAgICAgICByZXR1cm4gY3JlYXRlRnJvbUNvbmZpZyhjKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbG9jYWxfX2NyZWF0ZUxvY2FsIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm90b3R5cGVNaW4gPSBkZXByZWNhdGUoXG4gICAgICAgICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1heCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBvdGhlciA9IGxvY2FsX19jcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPCB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkX19jcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICB2YXIgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICAgICAgICdtb21lbnQoKS5tYXggaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5taW4gaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZF9fY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbiAgICAgIC8vIG90aGVyLiBUaGlzIHJlbGllcyBvbiB0aGUgZnVuY3Rpb24gZm4gdG8gYmUgdHJhbnNpdGl2ZS5cbiAgICAgIC8vXG4gICAgICAvLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4gICAgICAvLyBmaXJzdCBlbGVtZW50IGlzIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzLlxuICAgICAgZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgICAgICAgdmFyIHJlcywgaTtcbiAgICAgICAgICBpZiAobW9tZW50cy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShtb21lbnRzWzBdKSkge1xuICAgICAgICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFtb21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgICAgICAgZm9yIChpID0gMTsgaSA8IG1vbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG4gICAgICBmdW5jdGlvbiBtaW4gKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbWF4ICgpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogKyhuZXcgRGF0ZSgpKTtcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIER1cmF0aW9uIChkdXJhdGlvbikge1xuICAgICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXG4gICAgICAgICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcbiAgICAgICAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCAwLFxuICAgICAgICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXG4gICAgICAgICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xuXG4gICAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSArbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgICBob3VycyAqIDEwMDAgKiA2MCAqIDYwOyAvL3VzaW5nIDEwMDAgKiA2MCAqIDYwIGluc3RlYWQgb2YgMzZlNSB0byBhdm9pZCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzI5NzhcbiAgICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAgICAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgICAgICAgdGhpcy5fZGF5cyA9ICtkYXlzICtcbiAgICAgICAgICAgICAgd2Vla3MgKiA3O1xuICAgICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcbiAgICAgICAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xuICAgICAgICAgICAgICBxdWFydGVycyAqIDMgK1xuICAgICAgICAgICAgICB5ZWFycyAqIDEyO1xuXG4gICAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgICAgICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSgpO1xuXG4gICAgICAgICAgdGhpcy5fYnViYmxlKCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzRHVyYXRpb24gKG9iaikge1xuICAgICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWJzUm91bmQgKG51bWJlcikge1xuICAgICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKC0xICogbnVtYmVyKSAqIC0xO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlcik7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICAgIGZ1bmN0aW9uIG9mZnNldCAodG9rZW4sIHNlcGFyYXRvcikge1xuICAgICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICAgICAgICB2YXIgc2lnbiA9ICcrJztcbiAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBzaWduICsgemVyb0ZpbGwofn4ob2Zmc2V0IC8gNjApLCAyKSArIHNlcGFyYXRvciArIHplcm9GaWxsKH5+KG9mZnNldCkgJSA2MCwgMik7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIG9mZnNldCgnWicsICc6Jyk7XG4gICAgICBvZmZzZXQoJ1paJywgJycpO1xuXG4gICAgICAvLyBQQVJTSU5HXG5cbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ1onLCAgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgICBhZGRSZWdleFRva2VuKCdaWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgICAgYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgICAgY29uZmlnLl91c2VVVEMgPSB0cnVlO1xuICAgICAgICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gSEVMUEVSU1xuXG4gICAgICAvLyB0aW1lem9uZSBjaHVua2VyXG4gICAgICAvLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbiAgICAgIC8vICctMTUzMCcgID4gWyctMTUnLCAnMzAnXVxuICAgICAgdmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG4gICAgICBmdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoZXIsIHN0cmluZykge1xuICAgICAgICAgIHZhciBtYXRjaGVzID0gKChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoZXIpIHx8IFtdKTtcbiAgICAgICAgICB2YXIgY2h1bmsgICA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXTtcbiAgICAgICAgICB2YXIgcGFydHMgICA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XG4gICAgICAgICAgdmFyIG1pbnV0ZXMgPSArKHBhcnRzWzFdICogNjApICsgdG9JbnQocGFydHNbMl0pO1xuXG4gICAgICAgICAgcmV0dXJuIHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiBhIG1vbWVudCBmcm9tIGlucHV0LCB0aGF0IGlzIGxvY2FsL3V0Yy96b25lIGVxdWl2YWxlbnQgdG8gbW9kZWwuXG4gICAgICBmdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgICAgICAgdmFyIHJlcywgZGlmZjtcbiAgICAgICAgICBpZiAobW9kZWwuX2lzVVRDKSB7XG4gICAgICAgICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgICAgICAgIGRpZmYgPSAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dCkgPyBpbnB1dC52YWx1ZU9mKCkgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLnZhbHVlT2YoKSkgLSByZXMudmFsdWVPZigpO1xuICAgICAgICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgICAgICAgIHJlcy5fZC5zZXRUaW1lKHJlcy5fZC52YWx1ZU9mKCkgKyBkaWZmKTtcbiAgICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KS5sb2NhbCgpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0RGF0ZU9mZnNldCAobSkge1xuICAgICAgICAgIC8vIE9uIEZpcmVmb3guMjQgRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgICAgICAgcmV0dXJuIC1NYXRoLnJvdW5kKG0uX2QuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDE1KSAqIDE1O1xuICAgICAgfVxuXG4gICAgICAvLyBIT09LU1xuXG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4gICAgICAvLyBJdCBpcyBpbnRlbmRlZCB0byBrZWVwIHRoZSBvZmZzZXQgaW4gc3luYyB3aXRoIHRoZSB0aW1lem9uZS5cbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgLy8gTU9NRU5UU1xuXG4gICAgICAvLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbiAgICAgIC8vIGFmZmVjdGluZyB0aGUgbG9jYWwgaG91ci4gU28gNTozMToyNiArMDMwMCAtLVt1dGNPZmZzZXQoMiwgdHJ1ZSldLS0+XG4gICAgICAvLyA1OjMxOjI2ICswMjAwIEl0IGlzIHBvc3NpYmxlIHRoYXQgNTozMToyNiBkb2Vzbid0IGV4aXN0IHdpdGggb2Zmc2V0XG4gICAgICAvLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgICAvL1xuICAgICAgLy8gS2VlcGluZyB0aGUgdGltZSBhY3R1YWxseSBhZGRzL3N1YnRyYWN0cyAob25lIGhvdXIpXG4gICAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAgIC8vIGEgc2Vjb25kIHRpbWUuIEluIGNhc2UgaXQgd2FudHMgdXMgdG8gY2hhbmdlIHRoZSBvZmZzZXQgYWdhaW5cbiAgICAgIC8vIF9jaGFuZ2VJblByb2dyZXNzID09IHRydWUgY2FzZSwgdGhlbiB3ZSBoYXZlIHRvIGFkanVzdCwgYmVjYXVzZVxuICAgICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICAgIGZ1bmN0aW9uIGdldFNldE9mZnNldCAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXG4gICAgICAgICAgICAgIGxvY2FsQWRqdXN0O1xuICAgICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgaW5wdXQgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhpbnB1dCkgPCAxNikge1xuICAgICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xuICAgICAgICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgICAgICAgIGlmIChsb2NhbEFkanVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFkZChsb2NhbEFkanVzdCwgJ20nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oaW5wdXQgLSBvZmZzZXQsICdtJyksIDEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRTZXRab25lIChpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICBpbnB1dCA9IC1pbnB1dDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lKTtcblxuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gLXRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbCAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgIGlmICh0aGlzLl9pc1VUQykge1xuICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICAgICAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcblxuICAgICAgICAgICAgICBpZiAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdChnZXREYXRlT2Zmc2V0KHRoaXMpLCAnbScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3R6bSkge1xuICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHZhciB0Wm9uZSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpO1xuXG4gICAgICAgICAgICAgIGlmICh0Wm9uZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldChvZmZzZXRGcm9tU3RyaW5nKG1hdGNoT2Zmc2V0LCB0aGlzLl9pKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0IChpbnB1dCkge1xuICAgICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnB1dCA9IGlucHV0ID8gbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKSA6IDA7XG5cbiAgICAgICAgICByZXR1cm4gKHRoaXMudXRjT2Zmc2V0KCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWUgKCkge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCg1KS51dGNPZmZzZXQoKVxuICAgICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCAoKSB7XG4gICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9pc0RTVFNoaWZ0ZWQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGMgPSB7fTtcblxuICAgICAgICAgIGNvcHlDb25maWcoYywgdGhpcyk7XG4gICAgICAgICAgYyA9IHByZXBhcmVDb25maWcoYyk7XG5cbiAgICAgICAgICBpZiAoYy5fYSkge1xuICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhjLl9hKSA6IGxvY2FsX19jcmVhdGVMb2NhbChjLl9hKTtcbiAgICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICAgIGNvbXBhcmVBcnJheXMoYy5fYSwgb3RoZXIudG9BcnJheSgpKSA+IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNMb2NhbCAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gIXRoaXMuX2lzVVRDIDogZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzVXRjT2Zmc2V0ICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc1V0YyAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgJiYgdGhpcy5fb2Zmc2V0ID09PSAwIDogZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIEFTUC5ORVQganNvbiBkYXRlIGZvcm1hdCByZWdleFxuICAgICAgdmFyIGFzcE5ldFJlZ2V4ID0gL14oXFwtKT8oPzooXFxkKilbLiBdKT8oXFxkKylcXDooXFxkKykoPzpcXDooXFxkKykoXFwuXFxkKik/KT8kLztcblxuICAgICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAgIC8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcbiAgICAgIC8vIGFuZCBmdXJ0aGVyIG1vZGlmaWVkIHRvIGFsbG93IGZvciBzdHJpbmdzIGNvbnRhaW5pbmcgYm90aCB3ZWVrIGFuZCBkYXlcbiAgICAgIHZhciBpc29SZWdleCA9IC9eKC0pP1AoPzooLT9bMC05LC5dKilZKT8oPzooLT9bMC05LC5dKilNKT8oPzooLT9bMC05LC5dKilXKT8oPzooLT9bMC05LC5dKilEKT8oPzpUKD86KC0/WzAtOSwuXSopSCk/KD86KC0/WzAtOSwuXSopTSk/KD86KC0/WzAtOSwuXSopUyk/KT8kLztcblxuICAgICAgZnVuY3Rpb24gY3JlYXRlX19jcmVhdGVEdXJhdGlvbiAoaW5wdXQsIGtleSkge1xuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IGlucHV0LFxuICAgICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgICBtYXRjaCA9IG51bGwsXG4gICAgICAgICAgICAgIHNpZ24sXG4gICAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgICAgZGlmZlJlcztcblxuICAgICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSkge1xuICAgICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgIG1zIDogaW5wdXQuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgICAgICAgIGQgIDogaW5wdXQuX2RheXMsXG4gICAgICAgICAgICAgICAgICBNICA6IGlucHV0Ll9tb250aHNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9IGlucHV0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gaW5wdXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgeSAgOiAwLFxuICAgICAgICAgICAgICAgICAgZCAgOiB0b0ludChtYXRjaFtEQVRFXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgICAgaCAgOiB0b0ludChtYXRjaFtIT1VSXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgICAgbSAgOiB0b0ludChtYXRjaFtNSU5VVEVdKSAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgICAgcyAgOiB0b0ludChtYXRjaFtTRUNPTkRdKSAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgICAgbXMgOiB0b0ludChhYnNSb3VuZChtYXRjaFtNSUxMSVNFQ09ORF0gKiAxMDAwKSkgKiBzaWduIC8vIHRoZSBtaWxsaXNlY29uZCBkZWNpbWFsIHBvaW50IGlzIGluY2x1ZGVkIGluIHRoZSBtYXRjaFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBpc29SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICB5IDogcGFyc2VJc28obWF0Y2hbMl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgICAgTSA6IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgICAgICAgIHcgOiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgICBkIDogcGFyc2VJc28obWF0Y2hbNV0sIHNpZ24pLFxuICAgICAgICAgICAgICAgICAgaCA6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgICAgICAgIG0gOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgICBzIDogcGFyc2VJc28obWF0Y2hbOF0sIHNpZ24pXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7Ly8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJiAoJ2Zyb20nIGluIGR1cmF0aW9uIHx8ICd0bycgaW4gZHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShsb2NhbF9fY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGxvY2FsX19jcmVhdGVMb2NhbChkdXJhdGlvbi50bykpO1xuXG4gICAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICAgIGR1cmF0aW9uLm1zID0gZGlmZlJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG5cbiAgICAgIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24uZm4gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICAgIGZ1bmN0aW9uIHBhcnNlSXNvIChpbnAsIHNpZ24pIHtcbiAgICAgICAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgICAgICAgIC8vIGNvbnZlcnRzIGZsb2F0cyB0byBpbnRzLlxuICAgICAgICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cbiAgICAgICAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgICAvLyBhcHBseSBzaWduIHdoaWxlIHdlJ3JlIGF0IGl0XG4gICAgICAgICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgICAgdmFyIHJlcyA9IHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG5cbiAgICAgICAgICByZXMubW9udGhzID0gb3RoZXIubW9udGgoKSAtIGJhc2UubW9udGgoKSArXG4gICAgICAgICAgICAgIChvdGhlci55ZWFyKCkgLSBiYXNlLnllYXIoKSkgKiAxMjtcbiAgICAgICAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAgIC0tcmVzLm1vbnRocztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gKyhiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykpO1xuXG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgICB2YXIgcmVzO1xuICAgICAgICAgIGlmICghKGJhc2UuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgICAgICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xuICAgICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcbiAgICAgICAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9IC1yZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogcmVtb3ZlICduYW1lJyBhcmcgYWZ0ZXIgZGVwcmVjYXRpb24gaXMgcmVtb3ZlZFxuICAgICAgZnVuY3Rpb24gY3JlYXRlQWRkZXIoZGlyZWN0aW9uLCBuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xuICAgICAgICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgICAgICAgIC8vaW52ZXJ0IHRoZSBhcmd1bWVudHMsIGJ1dCBjb21wbGFpbiBhYm91dCBpdFxuICAgICAgICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xuICAgICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKG5hbWUsICdtb21lbnQoKS4nICsgbmFtZSAgKyAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgKyBuYW1lICsgJyhudW1iZXIsIHBlcmlvZCkuICcgK1xuICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2FkZC1pbnZlcnRlZC1wYXJhbS8gZm9yIG1vcmUgaW5mby4nKTtcbiAgICAgICAgICAgICAgICAgIHRtcCA9IHZhbDsgdmFsID0gcGVyaW9kOyBwZXJpb2QgPSB0bXA7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YWwgPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/ICt2YWwgOiB2YWw7XG4gICAgICAgICAgICAgIGR1ciA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICAgICAgICBhZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCAobW9tLCBkdXJhdGlvbiwgaXNBZGRpbmcsIHVwZGF0ZU9mZnNldCkge1xuICAgICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgICBkYXlzID0gYWJzUm91bmQoZHVyYXRpb24uX2RheXMpLFxuICAgICAgICAgICAgICBtb250aHMgPSBhYnNSb3VuZChkdXJhdGlvbi5fbW9udGhzKTtcblxuICAgICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgICAgICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgICBnZXRfc2V0X19zZXQobW9tLCAnRGF0ZScsIGdldF9zZXRfX2dldChtb20sICdEYXRlJykgKyBkYXlzICogaXNBZGRpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0X3NldF9fZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBhZGRfc3VidHJhY3RfX2FkZCAgICAgID0gY3JlYXRlQWRkZXIoMSwgJ2FkZCcpO1xuICAgICAgdmFyIGFkZF9zdWJ0cmFjdF9fc3VidHJhY3QgPSBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0Jyk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldENhbGVuZGFyRm9ybWF0KG15TW9tZW50LCBub3cpIHtcbiAgICAgICAgICB2YXIgZGlmZiA9IG15TW9tZW50LmRpZmYobm93LCAnZGF5cycsIHRydWUpO1xuICAgICAgICAgIHJldHVybiBkaWZmIDwgLTYgPyAnc2FtZUVsc2UnIDpcbiAgICAgICAgICAgICAgICAgIGRpZmYgPCAtMSA/ICdsYXN0V2VlaycgOlxuICAgICAgICAgICAgICAgICAgZGlmZiA8IDAgPyAnbGFzdERheScgOlxuICAgICAgICAgICAgICAgICAgZGlmZiA8IDEgPyAnc2FtZURheScgOlxuICAgICAgICAgICAgICAgICAgZGlmZiA8IDIgPyAnbmV4dERheScgOlxuICAgICAgICAgICAgICAgICAgZGlmZiA8IDcgPyAnbmV4dFdlZWsnIDogJ3NhbWVFbHNlJztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbW9tZW50X2NhbGVuZGFyX19jYWxlbmRhciAodGltZSwgZm9ybWF0cykge1xuICAgICAgICAgIC8vIFdlIHdhbnQgdG8gY29tcGFyZSB0aGUgc3RhcnQgb2YgdG9kYXksIHZzIHRoaXMuXG4gICAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgICAgdmFyIG5vdyA9IHRpbWUgfHwgbG9jYWxfX2NyZWF0ZUxvY2FsKCksXG4gICAgICAgICAgICAgIHNvZCA9IGNsb25lV2l0aE9mZnNldChub3csIHRoaXMpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICAgICAgICBmb3JtYXQgPSB1dGlsc19ob29rc19faG9va3MuY2FsZW5kYXJGb3JtYXQodGhpcywgc29kKSB8fCAnc2FtZUVsc2UnO1xuXG4gICAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdHMgJiYgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKSA/IGZvcm1hdHNbZm9ybWF0XS5jYWxsKHRoaXMsIG5vdykgOiBmb3JtYXRzW2Zvcm1hdF0pO1xuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KG91dHB1dCB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGxvY2FsX19jcmVhdGVMb2NhbChub3cpKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID4gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsSW5wdXQudmFsdWVPZigpIDwgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKCFpc1VuZGVmaW5lZCh1bml0cykgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzQmV0d2VlbiAoZnJvbSwgdG8sIHVuaXRzLCBpbmNsdXNpdml0eSkge1xuICAgICAgICAgIGluY2x1c2l2aXR5ID0gaW5jbHVzaXZpdHkgfHwgJygpJztcbiAgICAgICAgICByZXR1cm4gKGluY2x1c2l2aXR5WzBdID09PSAnKCcgPyB0aGlzLmlzQWZ0ZXIoZnJvbSwgdW5pdHMpIDogIXRoaXMuaXNCZWZvcmUoZnJvbSwgdW5pdHMpKSAmJlxuICAgICAgICAgICAgICAoaW5jbHVzaXZpdHlbMV0gPT09ICcpJyA/IHRoaXMuaXNCZWZvcmUodG8sIHVuaXRzKSA6ICF0aGlzLmlzQWZ0ZXIodG8sIHVuaXRzKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzU2FtZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCksXG4gICAgICAgICAgICAgIGlucHV0TXM7XG4gICAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyB8fCAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID09PSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnB1dE1zID0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpIDw9IGlucHV0TXMgJiYgaW5wdXRNcyA8PSB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzU2FtZU9yQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCx1bml0cyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQmVmb3JlKGlucHV0LHVuaXRzKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGlmZiAoaW5wdXQsIHVuaXRzLCBhc0Zsb2F0KSB7XG4gICAgICAgICAgdmFyIHRoYXQsXG4gICAgICAgICAgICAgIHpvbmVEZWx0YSxcbiAgICAgICAgICAgICAgZGVsdGEsIG91dHB1dDtcblxuICAgICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKTtcblxuICAgICAgICAgIGlmICghdGhhdC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB6b25lRGVsdGEgPSAodGhhdC51dGNPZmZzZXQoKSAtIHRoaXMudXRjT2Zmc2V0KCkpICogNmU0O1xuXG4gICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgICBpZiAodW5pdHMgPT09ICd5ZWFyJyB8fCB1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICAgIG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KTtcbiAgICAgICAgICAgICAgaWYgKHVuaXRzID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCAvIDM7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0IC8gMTI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWx0YSA9IHRoaXMgLSB0aGF0O1xuICAgICAgICAgICAgICBvdXRwdXQgPSB1bml0cyA9PT0gJ3NlY29uZCcgPyBkZWx0YSAvIDFlMyA6IC8vIDEwMDBcbiAgICAgICAgICAgICAgICAgIHVuaXRzID09PSAnbWludXRlJyA/IGRlbHRhIC8gNmU0IDogLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ2hvdXInID8gZGVsdGEgLyAzNmU1IDogLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgICAgICAgICAgIHVuaXRzID09PSAnZGF5JyA/IChkZWx0YSAtIHpvbmVEZWx0YSkgLyA4NjRlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgICAgICAgIHVuaXRzID09PSAnd2VlaycgPyAoZGVsdGEgLSB6b25lRGVsdGEpIC8gNjA0OGU1IDogLy8gMTAwMCAqIDYwICogNjAgKiAyNCAqIDcsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgICAgICAgIGRlbHRhO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1vbnRoRGlmZiAoYSwgYikge1xuICAgICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgICAgICAgdmFyIHdob2xlTW9udGhEaWZmID0gKChiLnllYXIoKSAtIGEueWVhcigpKSAqIDEyKSArIChiLm1vbnRoKCkgLSBhLm1vbnRoKCkpLFxuICAgICAgICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICAgICAgICBhbmNob3IgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmLCAnbW9udGhzJyksXG4gICAgICAgICAgICAgIGFuY2hvcjIsIGFkanVzdDtcblxuICAgICAgICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiAtIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yMiAtIGFuY2hvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy9jaGVjayBmb3IgbmVnYXRpdmUgemVybywgcmV0dXJuIHplcm8gaWYgbmVnYXRpdmUgemVyb1xuICAgICAgICAgIHJldHVybiAtKHdob2xlTW9udGhEaWZmICsgYWRqdXN0KSB8fCAwO1xuICAgICAgfVxuXG4gICAgICB1dGlsc19ob29rc19faG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG4gICAgICB1dGlsc19ob29rc19faG9va3MuZGVmYXVsdEZvcm1hdFV0YyA9ICdZWVlZLU1NLUREVEhIOm1tOnNzW1pdJztcblxuICAgICAgZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbW9tZW50X2Zvcm1hdF9fdG9JU09TdHJpbmcgKCkge1xuICAgICAgICAgIHZhciBtID0gdGhpcy5jbG9uZSgpLnV0YygpO1xuICAgICAgICAgIGlmICgwIDwgbS55ZWFyKCkgJiYgbS55ZWFyKCkgPD0gOTk5OSkge1xuICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykpIHtcbiAgICAgICAgICAgICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmb3JtYXQgKGlucHV0U3RyaW5nKSB7XG4gICAgICAgICAgaWYgKCFpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgICBpbnB1dFN0cmluZyA9IHRoaXMuaXNVdGMoKSA/IHV0aWxzX2hvb2tzX19ob29rcy5kZWZhdWx0Rm9ybWF0VXRjIDogdXRpbHNfaG9va3NfX2hvb2tzLmRlZmF1bHRGb3JtYXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRNb21lbnQodGhpcywgaW5wdXRTdHJpbmcpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZyb20gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgICAgICAgbG9jYWxfX2NyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oe3RvOiB0aGlzLCBmcm9tOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZyb21Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tKGxvY2FsX19jcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdG8gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgICAgICAgbG9jYWxfX2NyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oe2Zyb206IHRoaXMsIHRvOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRvTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG8obG9jYWxfX2NyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBwYXNzZWQgYSBsb2NhbGUga2V5LCBpdCB3aWxsIHNldCB0aGUgbG9jYWxlIGZvciB0aGlzXG4gICAgICAvLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXG4gICAgICAvLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgICBmdW5jdGlvbiBsb2NhbGUgKGtleSkge1xuICAgICAgICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3TG9jYWxlRGF0YSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgICAgaWYgKG5ld0xvY2FsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBsYW5nID0gZGVwcmVjYXRlKFxuICAgICAgICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgICAgICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZShrZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgZnVuY3Rpb24gbG9jYWxlRGF0YSAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc3RhcnRPZiAodW5pdHMpIHtcbiAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAvLyB0aGUgZm9sbG93aW5nIHN3aXRjaCBpbnRlbnRpb25hbGx5IG9taXRzIGJyZWFrIGtleXdvcmRzXG4gICAgICAgICAgLy8gdG8gdXRpbGl6ZSBmYWxsaW5nIHRocm91Z2ggdGhlIGNhc2VzLlxuICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKDApO1xuICAgICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKDEpO1xuICAgICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgICAgdGhpcy5ob3VycygwKTtcbiAgICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgICB0aGlzLm1pbnV0ZXMoMCk7XG4gICAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgICB0aGlzLnNlY29uZHMoMCk7XG4gICAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcygwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB3ZWVrcyBhcmUgYSBzcGVjaWFsIGNhc2VcbiAgICAgICAgICBpZiAodW5pdHMgPT09ICd3ZWVrJykge1xuICAgICAgICAgICAgICB0aGlzLndlZWtkYXkoMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh1bml0cyA9PT0gJ2lzb1dlZWsnKSB7XG4gICAgICAgICAgICAgIHRoaXMuaXNvV2Vla2RheSgxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBxdWFydGVycyBhcmUgYWxzbyBzcGVjaWFsXG4gICAgICAgICAgaWYgKHVuaXRzID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgICAgICAgdGhpcy5tb250aChNYXRoLmZsb29yKHRoaXMubW9udGgoKSAvIDMpICogMyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGVuZE9mICh1bml0cykge1xuICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vICdkYXRlJyBpcyBhbiBhbGlhcyBmb3IgJ2RheScsIHNvIGl0IHNob3VsZCBiZSBjb25zaWRlcmVkIGFzIHN1Y2guXG4gICAgICAgICAgaWYgKHVuaXRzID09PSAnZGF0ZScpIHtcbiAgICAgICAgICAgICAgdW5pdHMgPSAnZGF5JztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mKHVuaXRzKS5hZGQoMSwgKHVuaXRzID09PSAnaXNvV2VlaycgPyAnd2VlaycgOiB1bml0cykpLnN1YnRyYWN0KDEsICdtcycpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0b190eXBlX192YWx1ZU9mICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZC52YWx1ZU9mKCkgLSAoKHRoaXMuX29mZnNldCB8fCAwKSAqIDYwMDAwKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdW5peCAoKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkgLyAxMDAwKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdG9EYXRlICgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0b0FycmF5ICgpIHtcbiAgICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIFttLnllYXIoKSwgbS5tb250aCgpLCBtLmRhdGUoKSwgbS5ob3VyKCksIG0ubWludXRlKCksIG0uc2Vjb25kKCksIG0ubWlsbGlzZWNvbmQoKV07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRvT2JqZWN0ICgpIHtcbiAgICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgeWVhcnM6IG0ueWVhcigpLFxuICAgICAgICAgICAgICBtb250aHM6IG0ubW9udGgoKSxcbiAgICAgICAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgICAgICAgIGhvdXJzOiBtLmhvdXJzKCksXG4gICAgICAgICAgICAgIG1pbnV0ZXM6IG0ubWludXRlcygpLFxuICAgICAgICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBtLm1pbGxpc2Vjb25kcygpXG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICAgICAgICAvLyBuZXcgRGF0ZShOYU4pLnRvSlNPTigpID09PSBudWxsXG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy50b0lTT1N0cmluZygpIDogbnVsbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbW9tZW50X3ZhbGlkX19pc1ZhbGlkICgpIHtcbiAgICAgICAgICByZXR1cm4gdmFsaWRfX2lzVmFsaWQodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBhcnNpbmdGbGFncyAoKSB7XG4gICAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW52YWxpZEF0ICgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpLm92ZXJmbG93O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjcmVhdGlvbkRhdGEoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgICAgICAgIGZvcm1hdDogdGhpcy5fZixcbiAgICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgICAgICAgc3RyaWN0OiB0aGlzLl9zdHJpY3RcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG4gICAgICB9KTtcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuICh0b2tlbiwgZ2V0dGVyKSB7XG4gICAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xuICAgICAgfVxuXG4gICAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgICAgICd3ZWVrWWVhcicpO1xuICAgICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAgICAnd2Vla1llYXInKTtcbiAgICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0cnLCAgJ2lzb1dlZWtZZWFyJyk7XG4gICAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4gICAgICAvLyBBTElBU0VTXG5cbiAgICAgIGFkZFVuaXRBbGlhcygnd2Vla1llYXInLCAnZ2cnKTtcbiAgICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuICAgICAgLy8gUFJJT1JJVFlcblxuICAgICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrWWVhcicsIDEpO1xuICAgICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrWWVhcicsIDEpO1xuXG5cbiAgICAgIC8vIFBBUlNJTkdcblxuICAgICAgYWRkUmVnZXhUb2tlbignRycsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgICAgYWRkUmVnZXhUb2tlbignZycsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgICAgYWRkUmVnZXhUb2tlbignR0cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgICAgYWRkUmVnZXhUb2tlbignZ2cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgICAgYWRkUmVnZXhUb2tlbignR0dHRycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgICAgYWRkUmVnZXhUb2tlbignZ2dnZycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgICAgYWRkUmVnZXhUb2tlbignR0dHR0cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgICAgYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAyKV0gPSB0b0ludChpbnB1dCk7XG4gICAgICB9KTtcblxuICAgICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICB3ZWVrW3Rva2VuXSA9IHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gTU9NRU5UU1xuXG4gICAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhciAoaW5wdXQpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICB0aGlzLndlZWsoKSxcbiAgICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheSgpLFxuICAgICAgICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LFxuICAgICAgICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG95KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgICAgICAgIGlucHV0LCB0aGlzLmlzb1dlZWsoKSwgdGhpcy5pc29XZWVrZGF5KCksIDEsIDQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRJU09XZWVrc0luWWVhciAoKSB7XG4gICAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCAxLCA0KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIgKCkge1xuICAgICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhckhlbHBlcihpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgICB2YXIgd2Vla3NUYXJnZXQ7XG4gICAgICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIodGhpcywgZG93LCBkb3kpLnllYXI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xuICAgICAgICAgICAgICBpZiAod2VlayA+IHdlZWtzVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICB3ZWVrID0gd2Vla3NUYXJnZXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHNldFdlZWtBbGwuY2FsbCh0aGlzLCBpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2V0V2Vla0FsbCh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgICB2YXIgZGF5T2ZZZWFyRGF0YSA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpLFxuICAgICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcblxuICAgICAgICAgIHRoaXMueWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpO1xuICAgICAgICAgIHRoaXMubW9udGgoZGF0ZS5nZXRVVENNb250aCgpKTtcbiAgICAgICAgICB0aGlzLmRhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKCdRJywgMCwgJ1FvJywgJ3F1YXJ0ZXInKTtcblxuICAgICAgLy8gQUxJQVNFU1xuXG4gICAgICBhZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4gICAgICAvLyBQUklPUklUWVxuXG4gICAgICBhZGRVbml0UHJpb3JpdHkoJ3F1YXJ0ZXInLCA3KTtcblxuICAgICAgLy8gUEFSU0lOR1xuXG4gICAgICBhZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbiAgICAgIGFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNT01FTlRTXG5cbiAgICAgIGZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIgKGlucHV0KSB7XG4gICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMykgOiB0aGlzLm1vbnRoKChpbnB1dCAtIDEpICogMyArIHRoaXMubW9udGgoKSAlIDMpO1xuICAgICAgfVxuXG4gICAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKCdEJywgWydERCcsIDJdLCAnRG8nLCAnZGF0ZScpO1xuXG4gICAgICAvLyBBTElBU0VTXG5cbiAgICAgIGFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XG5cbiAgICAgIC8vIFBSSU9ST0lUWVxuICAgICAgYWRkVW5pdFByaW9yaXR5KCdkYXRlJywgOSk7XG5cbiAgICAgIC8vIFBBUlNJTkdcblxuICAgICAgYWRkUmVnZXhUb2tlbignRCcsICBtYXRjaDF0bzIpO1xuICAgICAgYWRkUmVnZXhUb2tlbignREQnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgICBhZGRSZWdleFRva2VuKCdEbycsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID8gbG9jYWxlLl9vcmRpbmFsUGFyc2UgOiBsb2NhbGUuX29yZGluYWxQYXJzZUxlbmllbnQ7XG4gICAgICB9KTtcblxuICAgICAgYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG4gICAgICBhZGRQYXJzZVRva2VuKCdEbycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0sIDEwKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNT01FTlRTXG5cbiAgICAgIHZhciBnZXRTZXREYXlPZk1vbnRoID0gbWFrZUdldFNldCgnRGF0ZScsIHRydWUpO1xuXG4gICAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XG5cbiAgICAgIC8vIEFMSUFTRVNcblxuICAgICAgYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XG5cbiAgICAgIC8vIFBSSU9SSVRZXG4gICAgICBhZGRVbml0UHJpb3JpdHkoJ2RheU9mWWVhcicsIDQpO1xuXG4gICAgICAvLyBQQVJTSU5HXG5cbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ0RERCcsICBtYXRjaDF0bzMpO1xuICAgICAgYWRkUmVnZXhUb2tlbignRERERCcsIG1hdGNoMyk7XG4gICAgICBhZGRQYXJzZVRva2VuKFsnREREJywgJ0REREQnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gSEVMUEVSU1xuXG4gICAgICAvLyBNT01FTlRTXG5cbiAgICAgIGZ1bmN0aW9uIGdldFNldERheU9mWWVhciAoaW5wdXQpIHtcbiAgICAgICAgICB2YXIgZGF5T2ZZZWFyID0gTWF0aC5yb3VuZCgodGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpIC0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNSkgKyAxO1xuICAgICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoKGlucHV0IC0gZGF5T2ZZZWFyKSwgJ2QnKTtcbiAgICAgIH1cblxuICAgICAgLy8gRk9STUFUVElOR1xuXG4gICAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4gICAgICAvLyBBTElBU0VTXG5cbiAgICAgIGFkZFVuaXRBbGlhcygnbWludXRlJywgJ20nKTtcblxuICAgICAgLy8gUFJJT1JJVFlcblxuICAgICAgYWRkVW5pdFByaW9yaXR5KCdtaW51dGUnLCAxNCk7XG5cbiAgICAgIC8vIFBBUlNJTkdcblxuICAgICAgYWRkUmVnZXhUb2tlbignbScsICBtYXRjaDF0bzIpO1xuICAgICAgYWRkUmVnZXhUb2tlbignbW0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgICBhZGRQYXJzZVRva2VuKFsnbScsICdtbSddLCBNSU5VVEUpO1xuXG4gICAgICAvLyBNT01FTlRTXG5cbiAgICAgIHZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xuXG4gICAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbiAgICAgIC8vIEFMSUFTRVNcblxuICAgICAgYWRkVW5pdEFsaWFzKCdzZWNvbmQnLCAncycpO1xuXG4gICAgICAvLyBQUklPUklUWVxuXG4gICAgICBhZGRVbml0UHJpb3JpdHkoJ3NlY29uZCcsIDE1KTtcblxuICAgICAgLy8gUEFSU0lOR1xuXG4gICAgICBhZGRSZWdleFRva2VuKCdzJywgIG1hdGNoMXRvMik7XG4gICAgICBhZGRSZWdleFRva2VuKCdzcycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICAgIGFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XG5cbiAgICAgIC8vIE1PTUVOVFNcblxuICAgICAgdmFyIGdldFNldFNlY29uZCA9IG1ha2VHZXRTZXQoJ1NlY29uZHMnLCBmYWxzZSk7XG5cbiAgICAgIC8vIEZPUk1BVFRJTkdcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwMCk7XG4gICAgICB9KTtcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwKTtcbiAgICAgIH0pO1xuXG4gICAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcbiAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTUycsIDRdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwO1xuICAgICAgfSk7XG4gICAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTJywgNV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwO1xuICAgICAgfSk7XG4gICAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTUycsIDZdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDA7XG4gICAgICB9KTtcbiAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTUycsIDddLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwO1xuICAgICAgfSk7XG4gICAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTJywgOF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwO1xuICAgICAgfSk7XG4gICAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTUycsIDldLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDA7XG4gICAgICB9KTtcblxuXG4gICAgICAvLyBBTElBU0VTXG5cbiAgICAgIGFkZFVuaXRBbGlhcygnbWlsbGlzZWNvbmQnLCAnbXMnKTtcblxuICAgICAgLy8gUFJJT1JJVFlcblxuICAgICAgYWRkVW5pdFByaW9yaXR5KCdtaWxsaXNlY29uZCcsIDE2KTtcblxuICAgICAgLy8gUEFSU0lOR1xuXG4gICAgICBhZGRSZWdleFRva2VuKCdTJywgICAgbWF0Y2gxdG8zLCBtYXRjaDEpO1xuICAgICAgYWRkUmVnZXhUb2tlbignU1MnLCAgIG1hdGNoMXRvMywgbWF0Y2gyKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ1NTUycsICBtYXRjaDF0bzMsIG1hdGNoMyk7XG5cbiAgICAgIHZhciB0b2tlbjtcbiAgICAgIGZvciAodG9rZW4gPSAnU1NTUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgICBhZGRSZWdleFRva2VuKHRva2VuLCBtYXRjaFVuc2lnbmVkKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGFyc2VNcyhpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICBhcnJheVtNSUxMSVNFQ09ORF0gPSB0b0ludCgoJzAuJyArIGlucHV0KSAqIDEwMDApO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHRva2VuID0gJ1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgcGFyc2VNcyk7XG4gICAgICB9XG4gICAgICAvLyBNT01FTlRTXG5cbiAgICAgIHZhciBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcblxuICAgICAgLy8gRk9STUFUVElOR1xuXG4gICAgICBhZGRGb3JtYXRUb2tlbigneicsICAwLCAwLCAnem9uZUFiYnInKTtcbiAgICAgIGFkZEZvcm1hdFRva2VuKCd6eicsIDAsIDAsICd6b25lTmFtZScpO1xuXG4gICAgICAvLyBNT01FTlRTXG5cbiAgICAgIGZ1bmN0aW9uIGdldFpvbmVBYmJyICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRab25lTmFtZSAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xuICAgICAgfVxuXG4gICAgICB2YXIgbW9tZW50UHJvdG90eXBlX19wcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uYWRkICAgICAgICAgICAgICAgPSBhZGRfc3VidHJhY3RfX2FkZDtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uY2FsZW5kYXIgICAgICAgICAgPSBtb21lbnRfY2FsZW5kYXJfX2NhbGVuZGFyO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5jbG9uZSAgICAgICAgICAgICA9IGNsb25lO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kaWZmICAgICAgICAgICAgICA9IGRpZmY7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmVuZE9mICAgICAgICAgICAgID0gZW5kT2Y7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmZvcm1hdCAgICAgICAgICAgID0gZm9ybWF0O1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5mcm9tICAgICAgICAgICAgICA9IGZyb207XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmZyb21Ob3cgICAgICAgICAgID0gZnJvbU5vdztcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG8gICAgICAgICAgICAgICAgPSB0bztcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9Ob3cgICAgICAgICAgICAgPSB0b05vdztcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZ2V0ICAgICAgICAgICAgICAgPSBzdHJpbmdHZXQ7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmludmFsaWRBdCAgICAgICAgID0gaW52YWxpZEF0O1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0FmdGVyICAgICAgICAgICA9IGlzQWZ0ZXI7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzQmVmb3JlICAgICAgICAgID0gaXNCZWZvcmU7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzQmV0d2VlbiAgICAgICAgID0gaXNCZXR3ZWVuO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1NhbWUgICAgICAgICAgICA9IGlzU2FtZTtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNTYW1lT3JBZnRlciAgICAgPSBpc1NhbWVPckFmdGVyO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1NhbWVPckJlZm9yZSAgICA9IGlzU2FtZU9yQmVmb3JlO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1ZhbGlkICAgICAgICAgICA9IG1vbWVudF92YWxpZF9faXNWYWxpZDtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubGFuZyAgICAgICAgICAgICAgPSBsYW5nO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sb2NhbGUgICAgICAgICAgICA9IGxvY2FsZTtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubG9jYWxlRGF0YSAgICAgICAgPSBsb2NhbGVEYXRhO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5tYXggICAgICAgICAgICAgICA9IHByb3RvdHlwZU1heDtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWluICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNaW47XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnBhcnNpbmdGbGFncyAgICAgID0gcGFyc2luZ0ZsYWdzO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zZXQgICAgICAgICAgICAgICA9IHN0cmluZ1NldDtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc3RhcnRPZiAgICAgICAgICAgPSBzdGFydE9mO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zdWJ0cmFjdCAgICAgICAgICA9IGFkZF9zdWJ0cmFjdF9fc3VidHJhY3Q7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvQXJyYXkgICAgICAgICAgID0gdG9BcnJheTtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9PYmplY3QgICAgICAgICAgPSB0b09iamVjdDtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9EYXRlICAgICAgICAgICAgPSB0b0RhdGU7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvSVNPU3RyaW5nICAgICAgID0gbW9tZW50X2Zvcm1hdF9fdG9JU09TdHJpbmc7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvSlNPTiAgICAgICAgICAgID0gdG9KU09OO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b1N0cmluZyAgICAgICAgICA9IHRvU3RyaW5nO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by51bml4ICAgICAgICAgICAgICA9IHVuaXg7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnZhbHVlT2YgICAgICAgICAgID0gdG9fdHlwZV9fdmFsdWVPZjtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uY3JlYXRpb25EYXRhICAgICAgPSBjcmVhdGlvbkRhdGE7XG5cbiAgICAgIC8vIFllYXJcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ueWVhciAgICAgICA9IGdldFNldFllYXI7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzTGVhcFllYXIgPSBnZXRJc0xlYXBZZWFyO1xuXG4gICAgICAvLyBXZWVrIFllYXJcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla1llYXIgICAgPSBnZXRTZXRXZWVrWWVhcjtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla1llYXIgPSBnZXRTZXRJU09XZWVrWWVhcjtcblxuICAgICAgLy8gUXVhcnRlclxuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5xdWFydGVyID0gbW9tZW50UHJvdG90eXBlX19wcm90by5xdWFydGVycyA9IGdldFNldFF1YXJ0ZXI7XG5cbiAgICAgIC8vIE1vbnRoXG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1vbnRoICAgICAgID0gZ2V0U2V0TW9udGg7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG5cbiAgICAgIC8vIFdlZWtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2VlayAgICAgICAgICAgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtzICAgICAgICA9IGdldFNldFdlZWs7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWsgICAgICAgID0gbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrcyAgICAgPSBnZXRTZXRJU09XZWVrO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrc0luWWVhciAgICA9IGdldFdlZWtzSW5ZZWFyO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrc0luWWVhciA9IGdldElTT1dlZWtzSW5ZZWFyO1xuXG4gICAgICAvLyBEYXlcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF0ZSAgICAgICA9IGdldFNldERheU9mTW9udGg7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheSAgICAgICAgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheXMgICAgICAgICAgICAgPSBnZXRTZXREYXlPZldlZWs7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtkYXkgICAgPSBnZXRTZXRMb2NhbGVEYXlPZldlZWs7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtkYXkgPSBnZXRTZXRJU09EYXlPZldlZWs7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheU9mWWVhciAgPSBnZXRTZXREYXlPZlllYXI7XG5cbiAgICAgIC8vIEhvdXJcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaG91ciA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xuXG4gICAgICAvLyBNaW51dGVcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWludXRlID0gbW9tZW50UHJvdG90eXBlX19wcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xuXG4gICAgICAvLyBTZWNvbmRcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc2Vjb25kID0gbW9tZW50UHJvdG90eXBlX19wcm90by5zZWNvbmRzID0gZ2V0U2V0U2Vjb25kO1xuXG4gICAgICAvLyBNaWxsaXNlY29uZFxuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5taWxsaXNlY29uZCA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWlsbGlzZWNvbmRzID0gZ2V0U2V0TWlsbGlzZWNvbmQ7XG5cbiAgICAgIC8vIE9mZnNldFxuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by51dGNPZmZzZXQgICAgICAgICAgICA9IGdldFNldE9mZnNldDtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udXRjICAgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1VUQztcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubG9jYWwgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb0xvY2FsO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5wYXJzZVpvbmUgICAgICAgICAgICA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5oYXNBbGlnbmVkSG91ck9mZnNldCA9IGhhc0FsaWduZWRIb3VyT2Zmc2V0O1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0RTVCAgICAgICAgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0xvY2FsICAgICAgICAgICAgICA9IGlzTG9jYWw7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVXRjT2Zmc2V0ICAgICAgICAgID0gaXNVdGNPZmZzZXQ7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVXRjICAgICAgICAgICAgICAgID0gaXNVdGM7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVVRDICAgICAgICAgICAgICAgID0gaXNVdGM7XG5cbiAgICAgIC8vIFRpbWV6b25lXG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnpvbmVBYmJyID0gZ2V0Wm9uZUFiYnI7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG5cbiAgICAgIC8vIERlcHJlY2F0aW9uc1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXRlcyAgPSBkZXByZWNhdGUoJ2RhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuJywgZ2V0U2V0RGF5T2ZNb250aCk7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1vbnRocyA9IGRlcHJlY2F0ZSgnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJywgZ2V0U2V0TW9udGgpO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by55ZWFycyAgPSBkZXByZWNhdGUoJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLCBnZXRTZXRZZWFyKTtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uem9uZSAgID0gZGVwcmVjYXRlKCdtb21lbnQoKS56b25lIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQoKS51dGNPZmZzZXQgaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy96b25lLycsIGdldFNldFpvbmUpO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0RTVFNoaWZ0ZWQgPSBkZXByZWNhdGUoJ2lzRFNUU2hpZnRlZCBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kc3Qtc2hpZnRlZC8gZm9yIG1vcmUgaW5mb3JtYXRpb24nLCBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQpO1xuXG4gICAgICB2YXIgbW9tZW50UHJvdG90eXBlID0gbW9tZW50UHJvdG90eXBlX19wcm90bztcblxuICAgICAgZnVuY3Rpb24gbW9tZW50X19jcmVhdGVVbml4IChpbnB1dCkge1xuICAgICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQgKiAxMDAwKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbW9tZW50X19jcmVhdGVJblpvbmUgKCkge1xuICAgICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0IChzdHJpbmcpIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvdG90eXBlX19wcm90byA9IExvY2FsZS5wcm90b3R5cGU7XG5cbiAgICAgIHByb3RvdHlwZV9fcHJvdG8uY2FsZW5kYXIgICAgICAgID0gbG9jYWxlX2NhbGVuZGFyX19jYWxlbmRhcjtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8ubG9uZ0RhdGVGb3JtYXQgID0gbG9uZ0RhdGVGb3JtYXQ7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLmludmFsaWREYXRlICAgICA9IGludmFsaWREYXRlO1xuICAgICAgcHJvdG90eXBlX19wcm90by5vcmRpbmFsICAgICAgICAgPSBvcmRpbmFsO1xuICAgICAgcHJvdG90eXBlX19wcm90by5wcmVwYXJzZSAgICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLnBvc3Rmb3JtYXQgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8ucmVsYXRpdmVUaW1lICAgID0gcmVsYXRpdmVfX3JlbGF0aXZlVGltZTtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8ucGFzdEZ1dHVyZSAgICAgID0gcGFzdEZ1dHVyZTtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8uc2V0ICAgICAgICAgICAgID0gbG9jYWxlX3NldF9fc2V0O1xuXG4gICAgICAvLyBNb250aFxuICAgICAgcHJvdG90eXBlX19wcm90by5tb250aHMgICAgICAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHM7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRoc1Nob3J0ICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1Nob3J0O1xuICAgICAgcHJvdG90eXBlX19wcm90by5tb250aHNQYXJzZSAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNQYXJzZTtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzUmVnZXggICAgICAgPSBtb250aHNSZWdleDtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzU2hvcnRSZWdleCAgPSBtb250aHNTaG9ydFJlZ2V4O1xuXG4gICAgICAvLyBXZWVrXG4gICAgICBwcm90b3R5cGVfX3Byb3RvLndlZWsgPSBsb2NhbGVXZWVrO1xuICAgICAgcHJvdG90eXBlX19wcm90by5maXJzdERheU9mWWVhciA9IGxvY2FsZUZpcnN0RGF5T2ZZZWFyO1xuICAgICAgcHJvdG90eXBlX19wcm90by5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG4gICAgICAvLyBEYXkgb2YgV2Vla1xuICAgICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5cyAgICAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5cztcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNNaW4gICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNNaW47XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzU2hvcnQgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzU2hvcnQ7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzUGFyc2UgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzUGFyc2U7XG5cbiAgICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNSZWdleCAgICAgICA9ICAgICAgICB3ZWVrZGF5c1JlZ2V4O1xuICAgICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c1Nob3J0UmVnZXggID0gICAgICAgIHdlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNNaW5SZWdleCAgICA9ICAgICAgICB3ZWVrZGF5c01pblJlZ2V4O1xuXG4gICAgICAvLyBIb3Vyc1xuICAgICAgcHJvdG90eXBlX19wcm90by5pc1BNID0gbG9jYWxlSXNQTTtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8ubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcblxuICAgICAgZnVuY3Rpb24gbGlzdHNfX2dldCAoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgICAgICAgIHZhciBsb2NhbGUgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKCk7XG4gICAgICAgICAgdmFyIHV0YyA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICAgICAgICByZXR1cm4gbG9jYWxlW2ZpZWxkXSh1dGMsIGZvcm1hdCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxpc3RNb250aHNJbXBsIChmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcblxuICAgICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsaXN0c19fZ2V0KGZvcm1hdCwgaW5kZXgsIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgICAgb3V0W2ldID0gbGlzdHNfX2dldChmb3JtYXQsIGksIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH1cblxuICAgICAgLy8gKClcbiAgICAgIC8vICg1KVxuICAgICAgLy8gKGZtdCwgNSlcbiAgICAgIC8vIChmbXQpXG4gICAgICAvLyAodHJ1ZSlcbiAgICAgIC8vICh0cnVlLCA1KVxuICAgICAgLy8gKHRydWUsIGZtdCwgNSlcbiAgICAgIC8vICh0cnVlLCBmbXQpXG4gICAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNJbXBsIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGVTb3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvcm1hdCA9IGxvY2FsZVNvcnRlZDtcbiAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgIGxvY2FsZVNvcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGxvY2FsZSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoKSxcbiAgICAgICAgICAgICAgc2hpZnQgPSBsb2NhbGVTb3J0ZWQgPyBsb2NhbGUuX3dlZWsuZG93IDogMDtcblxuICAgICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsaXN0c19fZ2V0KGZvcm1hdCwgKGluZGV4ICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgICBvdXRbaV0gPSBsaXN0c19fZ2V0KGZvcm1hdCwgKGkgKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsaXN0c19fbGlzdE1vbnRocyAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0TW9udGhzU2hvcnQgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRoc1Nob3J0Jyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0V2Vla2RheXMgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0V2Vla2RheXNTaG9ydCAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsaXN0c19fbGlzdFdlZWtkYXlzTWluIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c01pbicpO1xuICAgICAgfVxuXG4gICAgICBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKCdlbicsIHtcbiAgICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSh0aHxzdHxuZHxyZCkvLFxuICAgICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgICBvdXRwdXQgPSAodG9JbnQobnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG4gICAgICB1dGlsc19ob29rc19faG9va3MubGFuZyA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmcgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGUgaW5zdGVhZC4nLCBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKTtcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsIGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUpO1xuXG4gICAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgICBmdW5jdGlvbiBkdXJhdGlvbl9hYnNfX2FicyAoKSB7XG4gICAgICAgICAgdmFyIGRhdGEgICAgICAgICAgID0gdGhpcy5fZGF0YTtcblxuICAgICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9IG1hdGhBYnModGhpcy5fbWlsbGlzZWNvbmRzKTtcbiAgICAgICAgICB0aGlzLl9kYXlzICAgICAgICAgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgICAgICAgIHRoaXMuX21vbnRocyAgICAgICA9IG1hdGhBYnModGhpcy5fbW9udGhzKTtcblxuICAgICAgICAgIGRhdGEubWlsbGlzZWNvbmRzICA9IG1hdGhBYnMoZGF0YS5taWxsaXNlY29uZHMpO1xuICAgICAgICAgIGRhdGEuc2Vjb25kcyAgICAgICA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcbiAgICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICAgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgICAgICAgZGF0YS5ob3VycyAgICAgICAgID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcbiAgICAgICAgICBkYXRhLm1vbnRocyAgICAgICAgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcbiAgICAgICAgICBkYXRhLnllYXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QgKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgICAgICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgICBkdXJhdGlvbi5fZGF5cyAgICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9kYXlzO1xuICAgICAgICAgIGR1cmF0aW9uLl9tb250aHMgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgICAgICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbiAgICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkIChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBpbnB1dCwgdmFsdWUsIDEpO1xuICAgICAgfVxuXG4gICAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuICAgICAgZnVuY3Rpb24gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19zdWJ0cmFjdCAoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFic0NlaWwgKG51bWJlcikge1xuICAgICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuICAgICAgICAgIHZhciBkYXlzICAgICAgICAgPSB0aGlzLl9kYXlzO1xuICAgICAgICAgIHZhciBtb250aHMgICAgICAgPSB0aGlzLl9tb250aHM7XG4gICAgICAgICAgdmFyIGRhdGEgICAgICAgICA9IHRoaXMuX2RhdGE7XG4gICAgICAgICAgdmFyIHNlY29uZHMsIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycywgbW9udGhzRnJvbURheXM7XG5cbiAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgICAgICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgICAgICAgaWYgKCEoKG1pbGxpc2Vjb25kcyA+PSAwICYmIGRheXMgPj0gMCAmJiBtb250aHMgPj0gMCkgfHxcbiAgICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPD0gMCAmJiBkYXlzIDw9IDAgJiYgbW9udGhzIDw9IDApKSkge1xuICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgICAgICAgIGRheXMgPSAwO1xuICAgICAgICAgICAgICBtb250aHMgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcbiAgICAgICAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXG4gICAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgICAgc2Vjb25kcyAgICAgICAgICAgPSBhYnNGbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcbiAgICAgICAgICBkYXRhLnNlY29uZHMgICAgICA9IHNlY29uZHMgJSA2MDtcblxuICAgICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICA9IG1pbnV0ZXMgJSA2MDtcblxuICAgICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgICBkYXRhLmhvdXJzICAgICAgICA9IGhvdXJzICUgMjQ7XG5cbiAgICAgICAgICBkYXlzICs9IGFic0Zsb29yKGhvdXJzIC8gMjQpO1xuXG4gICAgICAgICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgICAgICAgIG1vbnRoc0Zyb21EYXlzID0gYWJzRmxvb3IoZGF5c1RvTW9udGhzKGRheXMpKTtcbiAgICAgICAgICBtb250aHMgKz0gbW9udGhzRnJvbURheXM7XG4gICAgICAgICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICAgIHllYXJzID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICAgIGRhdGEuZGF5cyAgID0gZGF5cztcbiAgICAgICAgICBkYXRhLm1vbnRocyA9IG1vbnRocztcbiAgICAgICAgICBkYXRhLnllYXJzICA9IHllYXJzO1xuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRheXNUb01vbnRocyAoZGF5cykge1xuICAgICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxMiBtb250aHMgPT09IDQ4MDBcbiAgICAgICAgICByZXR1cm4gZGF5cyAqIDQ4MDAgLyAxNDYwOTc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1vbnRoc1RvRGF5cyAobW9udGhzKSB7XG4gICAgICAgICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgICAgICAgcmV0dXJuIG1vbnRocyAqIDE0NjA5NyAvIDQ4MDA7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFzICh1bml0cykge1xuICAgICAgICAgIHZhciBkYXlzO1xuICAgICAgICAgIHZhciBtb250aHM7XG4gICAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcblxuICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgZGF5cyAgID0gdGhpcy5fZGF5cyAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHVuaXRzID09PSAnbW9udGgnID8gbW9udGhzIDogbW9udGhzIC8gMTI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaGFuZGxlIG1pbGxpc2Vjb25kcyBzZXBhcmF0ZWx5IGJlY2F1c2Ugb2YgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGlzc3VlICMxODY3KVxuICAgICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIE1hdGgucm91bmQobW9udGhzVG9EYXlzKHRoaXMuX21vbnRocykpO1xuICAgICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICd3ZWVrJyAgIDogcmV0dXJuIGRheXMgLyA3ICAgICArIG1pbGxpc2Vjb25kcyAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ2RheScgICAgOiByZXR1cm4gZGF5cyAgICAgICAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICAgICAgICBjYXNlICdob3VyJyAgIDogcmV0dXJuIGRheXMgKiAyNCAgICArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgICBjYXNlICdtaW51dGUnIDogcmV0dXJuIGRheXMgKiAxNDQwICArIG1pbGxpc2Vjb25kcyAvIDZlNDtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZCcgOiByZXR1cm4gZGF5cyAqIDg2NDAwICsgbWlsbGlzZWNvbmRzIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiByZXR1cm4gTWF0aC5mbG9vcihkYXlzICogODY0ZTUpICsgbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHVuaXQgJyArIHVuaXRzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG4gICAgICBmdW5jdGlvbiBkdXJhdGlvbl9hc19fdmFsdWVPZiAoKSB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgICAgICAgKHRoaXMuX21vbnRocyAlIDEyKSAqIDI1OTJlNiArXG4gICAgICAgICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTZcbiAgICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtYWtlQXMgKGFsaWFzKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMoYWxpYXMpO1xuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBhc01pbGxpc2Vjb25kcyA9IG1ha2VBcygnbXMnKTtcbiAgICAgIHZhciBhc1NlY29uZHMgICAgICA9IG1ha2VBcygncycpO1xuICAgICAgdmFyIGFzTWludXRlcyAgICAgID0gbWFrZUFzKCdtJyk7XG4gICAgICB2YXIgYXNIb3VycyAgICAgICAgPSBtYWtlQXMoJ2gnKTtcbiAgICAgIHZhciBhc0RheXMgICAgICAgICA9IG1ha2VBcygnZCcpO1xuICAgICAgdmFyIGFzV2Vla3MgICAgICAgID0gbWFrZUFzKCd3Jyk7XG4gICAgICB2YXIgYXNNb250aHMgICAgICAgPSBtYWtlQXMoJ00nKTtcbiAgICAgIHZhciBhc1llYXJzICAgICAgICA9IG1ha2VBcygneScpO1xuXG4gICAgICBmdW5jdGlvbiBkdXJhdGlvbl9nZXRfX2dldCAodW5pdHMpIHtcbiAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICByZXR1cm4gdGhpc1t1bml0cyArICdzJ10oKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFbbmFtZV07XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ21pbGxpc2Vjb25kcycpO1xuICAgICAgdmFyIHNlY29uZHMgICAgICA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKTtcbiAgICAgIHZhciBtaW51dGVzICAgICAgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyk7XG4gICAgICB2YXIgaG91cnMgICAgICAgID0gbWFrZUdldHRlcignaG91cnMnKTtcbiAgICAgIHZhciBkYXlzICAgICAgICAgPSBtYWtlR2V0dGVyKCdkYXlzJyk7XG4gICAgICB2YXIgbW9udGhzICAgICAgID0gbWFrZUdldHRlcignbW9udGhzJyk7XG4gICAgICB2YXIgeWVhcnMgICAgICAgID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuICAgICAgZnVuY3Rpb24gd2Vla3MgKCkge1xuICAgICAgICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuICAgICAgdmFyIHRocmVzaG9sZHMgPSB7XG4gICAgICAgICAgczogNDUsICAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgICAgICAgIG06IDQ1LCAgLy8gbWludXRlcyB0byBob3VyXG4gICAgICAgICAgaDogMjIsICAvLyBob3VycyB0byBkYXlcbiAgICAgICAgICBkOiAyNiwgIC8vIGRheXMgdG8gbW9udGhcbiAgICAgICAgICBNOiAxMSAgIC8vIG1vbnRocyB0byB5ZWFyXG4gICAgICB9O1xuXG4gICAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuICAgICAgZnVuY3Rpb24gc3Vic3RpdHV0ZVRpbWVBZ28oc3RyaW5nLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGlzRnV0dXJlLCBsb2NhbGUpIHtcbiAgICAgICAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZHVyYXRpb25faHVtYW5pemVfX3JlbGF0aXZlVGltZSAocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIGxvY2FsZSkge1xuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpO1xuICAgICAgICAgIHZhciBzZWNvbmRzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpO1xuICAgICAgICAgIHZhciBtaW51dGVzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpO1xuICAgICAgICAgIHZhciBob3VycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpO1xuICAgICAgICAgIHZhciBkYXlzICAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpO1xuICAgICAgICAgIHZhciBtb250aHMgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpO1xuICAgICAgICAgIHZhciB5ZWFycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpO1xuXG4gICAgICAgICAgdmFyIGEgPSBzZWNvbmRzIDwgdGhyZXNob2xkcy5zICYmIFsncycsIHNlY29uZHNdICB8fFxuICAgICAgICAgICAgICAgICAgbWludXRlcyA8PSAxICAgICAgICAgICAmJiBbJ20nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPCB0aHJlc2hvbGRzLm0gJiYgWydtbScsIG1pbnV0ZXNdIHx8XG4gICAgICAgICAgICAgICAgICBob3VycyAgIDw9IDEgICAgICAgICAgICYmIFsnaCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgICAgaG91cnMgICA8IHRocmVzaG9sZHMuaCAmJiBbJ2hoJywgaG91cnNdICAgfHxcbiAgICAgICAgICAgICAgICAgIGRheXMgICAgPD0gMSAgICAgICAgICAgJiYgWydkJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgICBkYXlzICAgIDwgdGhyZXNob2xkcy5kICYmIFsnZGQnLCBkYXlzXSAgICB8fFxuICAgICAgICAgICAgICAgICAgbW9udGhzICA8PSAxICAgICAgICAgICAmJiBbJ00nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICAgIG1vbnRocyAgPCB0aHJlc2hvbGRzLk0gJiYgWydNTScsIG1vbnRoc10gIHx8XG4gICAgICAgICAgICAgICAgICB5ZWFycyAgIDw9IDEgICAgICAgICAgICYmIFsneSddICAgICAgICAgICB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgICAgICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgICAgICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XG4gICAgICAgICAgYVs0XSA9IGxvY2FsZTtcbiAgICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgdGhlIHJvdW5kaW5nIGZ1bmN0aW9uIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2h1bWFuaXplX19nZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZyAocm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICAgIGlmIChyb3VuZGluZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJvdW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mKHJvdW5kaW5nRnVuY3Rpb24pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHJvdW5kID0gcm91bmRpbmdGdW5jdGlvbjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCBhIHRocmVzaG9sZCBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgICBmdW5jdGlvbiBkdXJhdGlvbl9odW1hbml6ZV9fZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkICh0aHJlc2hvbGQsIGxpbWl0KSB7XG4gICAgICAgICAgaWYgKHRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGh1bWFuaXplICh3aXRoU3VmZml4KSB7XG4gICAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICAgIHZhciBvdXRwdXQgPSBkdXJhdGlvbl9odW1hbml6ZV9fcmVsYXRpdmVUaW1lKHRoaXMsICF3aXRoU3VmZml4LCBsb2NhbGUpO1xuXG4gICAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgICAgb3V0cHV0ID0gbG9jYWxlLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc29fc3RyaW5nX19hYnMgPSBNYXRoLmFicztcblxuICAgICAgZnVuY3Rpb24gaXNvX3N0cmluZ19fdG9JU09TdHJpbmcoKSB7XG4gICAgICAgICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAgICAgICAvLyAgKiBtaWxsaXNlY29uZHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIGhvdXJzXG4gICAgICAgICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgICAgICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlcmUgaXMgbm8gY29udGV4dC1mcmVlIGNvbnZlcnNpb24gYmV0d2VlbiBob3VycyBhbmQgZGF5c1xuICAgICAgICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgICAgICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgICAgICAgdmFyIHNlY29uZHMgPSBpc29fc3RyaW5nX19hYnModGhpcy5fbWlsbGlzZWNvbmRzKSAvIDEwMDA7XG4gICAgICAgICAgdmFyIGRheXMgICAgICAgICA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLl9kYXlzKTtcbiAgICAgICAgICB2YXIgbW9udGhzICAgICAgID0gaXNvX3N0cmluZ19fYWJzKHRoaXMuX21vbnRocyk7XG4gICAgICAgICAgdmFyIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycztcblxuICAgICAgICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxuICAgICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgICAgc2Vjb25kcyAlPSA2MDtcbiAgICAgICAgICBtaW51dGVzICU9IDYwO1xuXG4gICAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICAgIHllYXJzICA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgICBtb250aHMgJT0gMTI7XG5cblxuICAgICAgICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgICAgICAgdmFyIFkgPSB5ZWFycztcbiAgICAgICAgICB2YXIgTSA9IG1vbnRocztcbiAgICAgICAgICB2YXIgRCA9IGRheXM7XG4gICAgICAgICAgdmFyIGggPSBob3VycztcbiAgICAgICAgICB2YXIgbSA9IG1pbnV0ZXM7XG4gICAgICAgICAgdmFyIHMgPSBzZWNvbmRzO1xuICAgICAgICAgIHZhciB0b3RhbCA9IHRoaXMuYXNTZWNvbmRzKCk7XG5cbiAgICAgICAgICBpZiAoIXRvdGFsKSB7XG4gICAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgQyMncyAoTm9kYSkgYW5kIHB5dGhvbiAoaXNvZGF0ZSkuLi5cbiAgICAgICAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICAgICAgICByZXR1cm4gJ1AwRCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuICh0b3RhbCA8IDAgPyAnLScgOiAnJykgK1xuICAgICAgICAgICAgICAnUCcgK1xuICAgICAgICAgICAgICAoWSA/IFkgKyAnWScgOiAnJykgK1xuICAgICAgICAgICAgICAoTSA/IE0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgICAoRCA/IEQgKyAnRCcgOiAnJykgK1xuICAgICAgICAgICAgICAoKGggfHwgbSB8fCBzKSA/ICdUJyA6ICcnKSArXG4gICAgICAgICAgICAgIChoID8gaCArICdIJyA6ICcnKSArXG4gICAgICAgICAgICAgIChtID8gbSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAgIChzID8gcyArICdTJyA6ICcnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYWJzICAgICAgICAgICAgPSBkdXJhdGlvbl9hYnNfX2FicztcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYWRkICAgICAgICAgICAgPSBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZDtcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uc3VidHJhY3QgICAgICAgPSBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX3N1YnRyYWN0O1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hcyAgICAgICAgICAgICA9IGFzO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc1NlY29uZHMgICAgICA9IGFzU2Vjb25kcztcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNNaW51dGVzICAgICAgPSBhc01pbnV0ZXM7XG4gICAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzSG91cnMgICAgICAgID0gYXNIb3VycztcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNEYXlzICAgICAgICAgPSBhc0RheXM7XG4gICAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzV2Vla3MgICAgICAgID0gYXNXZWVrcztcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNNb250aHMgICAgICAgPSBhc01vbnRocztcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNZZWFycyAgICAgICAgPSBhc1llYXJzO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by52YWx1ZU9mICAgICAgICA9IGR1cmF0aW9uX2FzX192YWx1ZU9mO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5fYnViYmxlICAgICAgICA9IGJ1YmJsZTtcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uZ2V0ICAgICAgICAgICAgPSBkdXJhdGlvbl9nZXRfX2dldDtcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubWlsbGlzZWNvbmRzICAgPSBtaWxsaXNlY29uZHM7XG4gICAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnNlY29uZHMgICAgICAgID0gc2Vjb25kcztcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubWludXRlcyAgICAgICAgPSBtaW51dGVzO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5ob3VycyAgICAgICAgICA9IGhvdXJzO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5kYXlzICAgICAgICAgICA9IGRheXM7XG4gICAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLndlZWtzICAgICAgICAgID0gd2Vla3M7XG4gICAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLm1vbnRocyAgICAgICAgID0gbW9udGhzO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by55ZWFycyAgICAgICAgICA9IHllYXJzO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5odW1hbml6ZSAgICAgICA9IGh1bWFuaXplO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b0lTT1N0cmluZyAgICA9IGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b1N0cmluZyAgICAgICA9IGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b0pTT04gICAgICAgICA9IGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5sb2NhbGUgICAgICAgICA9IGxvY2FsZTtcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubG9jYWxlRGF0YSAgICAgPSBsb2NhbGVEYXRhO1xuXG4gICAgICAvLyBEZXByZWNhdGlvbnNcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9Jc29TdHJpbmcgPSBkZXByZWNhdGUoJ3RvSXNvU3RyaW5nKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0b0lTT1N0cmluZygpIGluc3RlYWQgKG5vdGljZSB0aGUgY2FwaXRhbHMpJywgaXNvX3N0cmluZ19fdG9JU09TdHJpbmcpO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5sYW5nID0gbGFuZztcblxuICAgICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG4gICAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcbiAgICAgIGFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuICAgICAgLy8gUEFSU0lOR1xuXG4gICAgICBhZGRSZWdleFRva2VuKCd4JywgbWF0Y2hTaWduZWQpO1xuICAgICAgYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbiAgICAgIGFkZFBhcnNlVG9rZW4oJ1gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0LCAxMCkgKiAxMDAwKTtcbiAgICAgIH0pO1xuICAgICAgYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG5cbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy52ZXJzaW9uID0gJzIuMTUuMic7XG5cbiAgICAgIHNldEhvb2tDYWxsYmFjayhsb2NhbF9fY3JlYXRlTG9jYWwpO1xuXG4gICAgICB1dGlsc19ob29rc19faG9va3MuZm4gICAgICAgICAgICAgICAgICAgID0gbW9tZW50UHJvdG90eXBlO1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLm1pbiAgICAgICAgICAgICAgICAgICA9IG1pbjtcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5tYXggICAgICAgICAgICAgICAgICAgPSBtYXg7XG4gICAgICB1dGlsc19ob29rc19faG9va3Mubm93ICAgICAgICAgICAgICAgICAgID0gbm93O1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnV0YyAgICAgICAgICAgICAgICAgICA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQztcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51bml4ICAgICAgICAgICAgICAgICAgPSBtb21lbnRfX2NyZWF0ZVVuaXg7XG4gICAgICB1dGlsc19ob29rc19faG9va3MubW9udGhzICAgICAgICAgICAgICAgID0gbGlzdHNfX2xpc3RNb250aHM7XG4gICAgICB1dGlsc19ob29rc19faG9va3MuaXNEYXRlICAgICAgICAgICAgICAgID0gaXNEYXRlO1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmxvY2FsZSAgICAgICAgICAgICAgICA9IGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGU7XG4gICAgICB1dGlsc19ob29rc19faG9va3MuaW52YWxpZCAgICAgICAgICAgICAgID0gdmFsaWRfX2NyZWF0ZUludmFsaWQ7XG4gICAgICB1dGlsc19ob29rc19faG9va3MuZHVyYXRpb24gICAgICAgICAgICAgID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbjtcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5pc01vbWVudCAgICAgICAgICAgICAgPSBpc01vbWVudDtcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy53ZWVrZGF5cyAgICAgICAgICAgICAgPSBsaXN0c19fbGlzdFdlZWtkYXlzO1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlWm9uZSAgICAgICAgICAgICA9IG1vbWVudF9fY3JlYXRlSW5ab25lO1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmxvY2FsZURhdGEgICAgICAgICAgICA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGU7XG4gICAgICB1dGlsc19ob29rc19faG9va3MuaXNEdXJhdGlvbiAgICAgICAgICAgID0gaXNEdXJhdGlvbjtcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5tb250aHNTaG9ydCAgICAgICAgICAgPSBsaXN0c19fbGlzdE1vbnRoc1Nob3J0O1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLndlZWtkYXlzTWluICAgICAgICAgICA9IGxpc3RzX19saXN0V2Vla2RheXNNaW47XG4gICAgICB1dGlsc19ob29rc19faG9va3MuZGVmaW5lTG9jYWxlICAgICAgICAgID0gZGVmaW5lTG9jYWxlO1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZUxvY2FsZSAgICAgICAgICA9IHVwZGF0ZUxvY2FsZTtcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5sb2NhbGVzICAgICAgICAgICAgICAgPSBsb2NhbGVfbG9jYWxlc19fbGlzdExvY2FsZXM7XG4gICAgICB1dGlsc19ob29rc19faG9va3Mud2Vla2RheXNTaG9ydCAgICAgICAgID0gbGlzdHNfX2xpc3RXZWVrZGF5c1Nob3J0O1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLm5vcm1hbGl6ZVVuaXRzICAgICAgICA9IG5vcm1hbGl6ZVVuaXRzO1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnJlbGF0aXZlVGltZVJvdW5kaW5nID0gZHVyYXRpb25faHVtYW5pemVfX2dldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nO1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGR1cmF0aW9uX2h1bWFuaXplX19nZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQ7XG4gICAgICB1dGlsc19ob29rc19faG9va3MuY2FsZW5kYXJGb3JtYXQgICAgICAgID0gZ2V0Q2FsZW5kYXJGb3JtYXQ7XG4gICAgICB1dGlsc19ob29rc19faG9va3MucHJvdG90eXBlICAgICAgICAgICAgID0gbW9tZW50UHJvdG90eXBlO1xuXG4gICAgICB2YXIgX21vbWVudCA9IHV0aWxzX2hvb2tzX19ob29rcztcblxuICAgICAgcmV0dXJuIF9tb21lbnQ7XG5cbiAgfSkpO1xuICAvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyg0KShtb2R1bGUpKSlcblxuLyoqKi8gfSxcbi8qIDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gIFx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcbiAgXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuICBcdFx0bW9kdWxlLnBhdGhzID0gW107XG4gIFx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcbiAgXHRcdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuICBcdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG4gIFx0fVxuICBcdHJldHVybiBtb2R1bGU7XG4gIH1cblxuXG4vKioqLyB9LFxuLyogNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG4gIFx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJy5cIik7XG4gIH1cbiAgd2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH07XG4gIHdlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dDtcbiAgbW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbiAgd2VicGFja0NvbnRleHQuaWQgPSA1O1xuXG5cbi8qKiovIH0sXG4vKiA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfcm5nO1xuXG4gIHZhciBnbG9iYWxWYXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogbnVsbDtcblxuICBpZiAoZ2xvYmFsVmFyICYmIGdsb2JhbFZhci5jcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIFdIQVRXRyBjcnlwdG8tYmFzZWQgUk5HIC0gaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0NyeXB0b1xuICAgIC8vIE1vZGVyYXRlbHkgZmFzdCwgaGlnaCBxdWFsaXR5XG4gICAgdmFyIF9ybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICBfcm5nID0gZnVuY3Rpb24gd2hhdHdnUk5HKCkge1xuICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhfcm5kczgpO1xuICAgICAgcmV0dXJuIF9ybmRzODtcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFfcm5nKSB7XG4gICAgLy8gTWF0aC5yYW5kb20oKS1iYXNlZCAoUk5HKVxuICAgIC8vXG4gICAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHVzZSBNYXRoLnJhbmRvbSgpLiAgSXQncyBmYXN0LCBidXQgaXMgb2YgdW5zcGVjaWZpZWRcbiAgICAvLyBxdWFsaXR5LlxuICAgIHZhciBfcm5kcyA9IG5ldyBBcnJheSgxNik7XG4gICAgX3JuZyA9IGZ1bmN0aW9uIF9ybmcoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICAgIF9ybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3JuZHM7XG4gICAgfTtcbiAgfVxuXG4gIC8vICAgICB1dWlkLmpzXG4gIC8vXG4gIC8vICAgICBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMiBSb2JlcnQgS2llZmZlclxuICAvLyAgICAgTUlUIExpY2Vuc2UgLSBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cbiAgLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gIFdlIGZlYXR1cmVcbiAgLy8gZGV0ZWN0IHRvIGRldGVybWluZSB0aGUgYmVzdCBSTkcgc291cmNlLCBub3JtYWxpemluZyB0byBhIGZ1bmN0aW9uIHRoYXRcbiAgLy8gcmV0dXJucyAxMjgtYml0cyBvZiByYW5kb21uZXNzLCBzaW5jZSB0aGF0J3Mgd2hhdCdzIHVzdWFsbHkgcmVxdWlyZWRcblxuICAvL3ZhciBfcm5nID0gcmVxdWlyZSgnLi9ybmcnKTtcblxuICAvLyBNYXBzIGZvciBudW1iZXIgPC0+IGhleCBzdHJpbmcgY29udmVyc2lvblxuICB2YXIgX2J5dGVUb0hleCA9IFtdO1xuICB2YXIgX2hleFRvQnl0ZSA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgX2J5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG4gICAgX2hleFRvQnl0ZVtfYnl0ZVRvSGV4W2ldXSA9IGk7XG4gIH1cblxuICAvLyAqKmBwYXJzZSgpYCAtIFBhcnNlIGEgVVVJRCBpbnRvIGl0J3MgY29tcG9uZW50IGJ5dGVzKipcbiAgZnVuY3Rpb24gcGFyc2UocywgYnVmLCBvZmZzZXQpIHtcbiAgICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMCxcbiAgICAgICAgaWkgPSAwO1xuXG4gICAgYnVmID0gYnVmIHx8IFtdO1xuICAgIHMudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bMC05YS1mXXsyfS9nLCBmdW5jdGlvbiAob2N0KSB7XG4gICAgICBpZiAoaWkgPCAxNikge1xuICAgICAgICAvLyBEb24ndCBvdmVyZmxvdyFcbiAgICAgICAgYnVmW2kgKyBpaSsrXSA9IF9oZXhUb0J5dGVbb2N0XTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFplcm8gb3V0IHJlbWFpbmluZyBieXRlcyBpZiBzdHJpbmcgd2FzIHNob3J0XG4gICAgd2hpbGUgKGlpIDwgMTYpIHtcbiAgICAgIGJ1ZltpICsgaWkrK10gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICAvLyAqKmB1bnBhcnNlKClgIC0gQ29udmVydCBVVUlEIGJ5dGUgYXJyYXkgKGFsYSBwYXJzZSgpKSBpbnRvIGEgc3RyaW5nKipcbiAgZnVuY3Rpb24gdW5wYXJzZShidWYsIG9mZnNldCkge1xuICAgIHZhciBpID0gb2Zmc2V0IHx8IDAsXG4gICAgICAgIGJ0aCA9IF9ieXRlVG9IZXg7XG4gICAgcmV0dXJuIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgKyBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgKyBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV07XG4gIH1cblxuICAvLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4gIC8vXG4gIC8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4gIC8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbiAgLy8gcmFuZG9tICMncyB3ZSBuZWVkIHRvIGluaXQgbm9kZSBhbmQgY2xvY2tzZXFcbiAgdmFyIF9zZWVkQnl0ZXMgPSBfcm5nKCk7XG5cbiAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gIHZhciBfbm9kZUlkID0gW19zZWVkQnl0ZXNbMF0gfCAweDAxLCBfc2VlZEJ5dGVzWzFdLCBfc2VlZEJ5dGVzWzJdLCBfc2VlZEJ5dGVzWzNdLCBfc2VlZEJ5dGVzWzRdLCBfc2VlZEJ5dGVzWzVdXTtcblxuICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICB2YXIgX2Nsb2Nrc2VxID0gKF9zZWVkQnl0ZXNbNl0gPDwgOCB8IF9zZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuXG4gIC8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxuICB2YXIgX2xhc3RNU2VjcyA9IDAsXG4gICAgICBfbGFzdE5TZWNzID0gMDtcblxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG4gIGZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gICAgdmFyIGIgPSBidWYgfHwgW107XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7XG5cbiAgICAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAgIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gICAgLy8gdGltZSBpcyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXG4gICAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cbiAgICB2YXIgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gICAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcbiAgICB2YXIgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7XG5cbiAgICAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG4gICAgdmFyIGR0ID0gbXNlY3MgLSBfbGFzdE1TZWNzICsgKG5zZWNzIC0gX2xhc3ROU2VjcykgLyAxMDAwMDtcblxuICAgIC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cbiAgICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgICAvLyB0aW1lIGludGVydmFsXG4gICAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5zZWNzID0gMDtcbiAgICB9XG5cbiAgICAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG4gICAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3V1aWQudjEoKTogQ2FuXFwndCBjcmVhdGUgbW9yZSB0aGFuIDEwTSB1dWlkcy9zZWMnKTtcbiAgICB9XG5cbiAgICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gICAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICAgIF9jbG9ja3NlcSA9IGNsb2Nrc2VxO1xuXG4gICAgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG4gICAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7XG5cbiAgICAvLyBgdGltZV9sb3dgXG4gICAgdmFyIHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICAgIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gICAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gICAgYltpKytdID0gdGwgJiAweGZmO1xuXG4gICAgLy8gYHRpbWVfbWlkYFxuICAgIHZhciB0bWggPSBtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDAgJiAweGZmZmZmZmY7XG4gICAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgICBiW2krK10gPSB0bWggJiAweGZmO1xuXG4gICAgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcbiAgICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG4gICAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7XG5cbiAgICAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcbiAgICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7XG5cbiAgICAvLyBgY2xvY2tfc2VxX2xvd2BcbiAgICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7XG5cbiAgICAvLyBgbm9kZWBcbiAgICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgNjsgbisrKSB7XG4gICAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZiA/IGJ1ZiA6IHVucGFyc2UoYik7XG4gIH1cblxuICAvLyAqKmB2NCgpYCAtIEdlbmVyYXRlIHJhbmRvbSBVVUlEKipcblxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG4gIGZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgLy8gRGVwcmVjYXRlZCAtICdmb3JtYXQnIGFyZ3VtZW50LCBhcyBzdXBwb3J0ZWQgaW4gdjEuMlxuICAgIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdzdHJpbmcnKSB7XG4gICAgICBidWYgPSBvcHRpb25zID09ICdiaW5hcnknID8gbmV3IEFycmF5KDE2KSA6IG51bGw7XG4gICAgICBvcHRpb25zID0gbnVsbDtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBfcm5nKSgpO1xuXG4gICAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICAgIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gICAgcm5kc1s4XSA9IHJuZHNbOF0gJiAweDNmIHwgMHg4MDtcblxuICAgIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICAgIGlmIChidWYpIHtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgaWkrKykge1xuICAgICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWYgfHwgdW5wYXJzZShybmRzKTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBwdWJsaWMgQVBJXG4gIHZhciB1dWlkID0gdjQ7XG4gIHV1aWQudjEgPSB2MTtcbiAgdXVpZC52NCA9IHY0O1xuICB1dWlkLnBhcnNlID0gcGFyc2U7XG4gIHV1aWQudW5wYXJzZSA9IHVucGFyc2U7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB1dWlkO1xuICAvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiA3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gdXRpbHNcbiAgZXhwb3J0cy51dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgZXhwb3J0cy5ET011dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxuICAvLyBkYXRhXG4gIGV4cG9ydHMuRGF0YVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG4gIGV4cG9ydHMuRGF0YVZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbiAgZXhwb3J0cy5RdWV1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG4gIC8vIEdyYXBoM2RcbiAgZXhwb3J0cy5HcmFwaDNkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG4gIGV4cG9ydHMuZ3JhcGgzZCA9IHtcbiAgICBDYW1lcmE6IF9fd2VicGFja19yZXF1aXJlX18oMTYpLFxuICAgIEZpbHRlcjogX193ZWJwYWNrX3JlcXVpcmVfXygxNyksXG4gICAgUG9pbnQyZDogX193ZWJwYWNrX3JlcXVpcmVfXygxNSksXG4gICAgUG9pbnQzZDogX193ZWJwYWNrX3JlcXVpcmVfXygxNCksXG4gICAgU2xpZGVyOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KSxcbiAgICBTdGVwTnVtYmVyOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KVxuICB9O1xuXG4gIC8vIGJ1bmRsZWQgZXh0ZXJuYWwgbGlicmFyaWVzXG4gIGV4cG9ydHMubW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbiAgZXhwb3J0cy5IYW1tZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcbiAgZXhwb3J0cy5rZXljaGFybSA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuXG4vKioqLyB9LFxuLyogOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIERPTSB1dGlsaXR5IG1ldGhvZHNcblxuICAvKipcbiAgICogdGhpcyBwcmVwYXJlcyB0aGUgSlNPTiBjb250YWluZXIgZm9yIGFsbG9jYXRpbmcgU1ZHIGVsZW1lbnRzXG4gICAqIEBwYXJhbSBKU09OY29udGFpbmVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBleHBvcnRzLnByZXBhcmVFbGVtZW50cyA9IGZ1bmN0aW9uIChKU09OY29udGFpbmVyKSB7XG4gICAgLy8gY2xlYW51cCB0aGUgcmVkdW5kYW50IHN2Z0VsZW1lbnRzO1xuICAgIGZvciAodmFyIGVsZW1lbnRUeXBlIGluIEpTT05jb250YWluZXIpIHtcbiAgICAgIGlmIChKU09OY29udGFpbmVyLmhhc093blByb3BlcnR5KGVsZW1lbnRUeXBlKSkge1xuICAgICAgICBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS5yZWR1bmRhbnQgPSBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS51c2VkO1xuICAgICAgICBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS51c2VkID0gW107XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiB0aGlzIGNsZWFucyB1cCBhbGwgdGhlIHVudXNlZCBTVkcgZWxlbWVudHMuIEJ5IGFza2luZyBmb3IgdGhlIHBhcmVudE5vZGUsIHdlIG9ubHkgbmVlZCB0byBzdXBwbHkgdGhlIEpTT04gY29udGFpbmVyIGZyb21cbiAgICogd2hpY2ggdG8gcmVtb3ZlIHRoZSByZWR1bmRhbnQgZWxlbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSBKU09OY29udGFpbmVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBleHBvcnRzLmNsZWFudXBFbGVtZW50cyA9IGZ1bmN0aW9uIChKU09OY29udGFpbmVyKSB7XG4gICAgLy8gY2xlYW51cCB0aGUgcmVkdW5kYW50IHN2Z0VsZW1lbnRzO1xuICAgIGZvciAodmFyIGVsZW1lbnRUeXBlIGluIEpTT05jb250YWluZXIpIHtcbiAgICAgIGlmIChKU09OY29udGFpbmVyLmhhc093blByb3BlcnR5KGVsZW1lbnRUeXBlKSkge1xuICAgICAgICBpZiAoSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS5yZWR1bmRhbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdLnJlZHVuZGFudFtpXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdLnJlZHVuZGFudFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdLnJlZHVuZGFudCA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoYXQgYWxsIGVsZW1lbnRzIGFyZSByZW1vdmVkIGZpcnN0IHVwIHNvIHRoZXkgY2FuIGJlIHJlY3JlYXRlZCBjbGVhbmx5XG4gICAqIEBwYXJhbSBKU09OY29udGFpbmVyXG4gICAqL1xuICBleHBvcnRzLnJlc2V0RWxlbWVudHMgPSBmdW5jdGlvbiAoSlNPTmNvbnRhaW5lcikge1xuICAgIGV4cG9ydHMucHJlcGFyZUVsZW1lbnRzKEpTT05jb250YWluZXIpO1xuICAgIGV4cG9ydHMuY2xlYW51cEVsZW1lbnRzKEpTT05jb250YWluZXIpO1xuICAgIGV4cG9ydHMucHJlcGFyZUVsZW1lbnRzKEpTT05jb250YWluZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBbGxvY2F0ZSBvciBnZW5lcmF0ZSBhbiBTVkcgZWxlbWVudCBpZiBuZWVkZWQuIFN0b3JlIGEgcmVmZXJlbmNlIHRvIGl0IGluIHRoZSBKU09OIGNvbnRhaW5lciBhbmQgZHJhdyBpdCBpbiB0aGUgc3ZnQ29udGFpbmVyXG4gICAqIHRoZSBKU09OIGNvbnRhaW5lciBhbmQgdGhlIFNWRyBjb250YWluZXIgaGF2ZSB0byBiZSBzdXBwbGllZCBzbyBvdGhlciBzdmcgY29udGFpbmVycyAobGlrZSB0aGUgbGVnZW5kKSBjYW4gdXNlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSBlbGVtZW50VHlwZVxuICAgKiBAcGFyYW0gSlNPTmNvbnRhaW5lclxuICAgKiBAcGFyYW0gc3ZnQ29udGFpbmVyXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZXhwb3J0cy5nZXRTVkdFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnRUeXBlLCBKU09OY29udGFpbmVyLCBzdmdDb250YWluZXIpIHtcbiAgICB2YXIgZWxlbWVudDtcbiAgICAvLyBhbGxvY2F0ZSBTVkcgZWxlbWVudCwgaWYgaXQgZG9lc250IHlldCBleGlzdCwgY3JlYXRlIG9uZS5cbiAgICBpZiAoSlNPTmNvbnRhaW5lci5oYXNPd25Qcm9wZXJ0eShlbGVtZW50VHlwZSkpIHtcbiAgICAgIC8vIHRoaXMgZWxlbWVudCBoYXMgYmVlbiBjcmVhdGVkIGJlZm9yZVxuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgaXMgYW4gcmVkdW5kYW50IGVsZW1lbnRcbiAgICAgIGlmIChKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS5yZWR1bmRhbnQubGVuZ3RoID4gMCkge1xuICAgICAgICBlbGVtZW50ID0gSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50WzBdO1xuICAgICAgICBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS5yZWR1bmRhbnQuc2hpZnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBlbGVtZW50IGFuZCBhZGQgaXQgdG8gdGhlIFNWR1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIGVsZW1lbnRUeXBlKTtcbiAgICAgICAgc3ZnQ29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjcmVhdGUgYSBuZXcgZWxlbWVudCBhbmQgYWRkIGl0IHRvIHRoZSBTVkcsIGFsc28gY3JlYXRlIGEgbmV3IG9iamVjdCBpbiB0aGUgc3ZnRWxlbWVudHMgdG8ga2VlcCB0cmFjayBvZiBpdC5cbiAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgZWxlbWVudFR5cGUpO1xuICAgICAgSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0gPSB7IHVzZWQ6IFtdLCByZWR1bmRhbnQ6IFtdIH07XG4gICAgICBzdmdDb250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgfVxuICAgIEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdLnVzZWQucHVzaChlbGVtZW50KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfTtcblxuICAvKipcbiAgICogQWxsb2NhdGUgb3IgZ2VuZXJhdGUgYW4gU1ZHIGVsZW1lbnQgaWYgbmVlZGVkLiBTdG9yZSBhIHJlZmVyZW5jZSB0byBpdCBpbiB0aGUgSlNPTiBjb250YWluZXIgYW5kIGRyYXcgaXQgaW4gdGhlIHN2Z0NvbnRhaW5lclxuICAgKiB0aGUgSlNPTiBjb250YWluZXIgYW5kIHRoZSBTVkcgY29udGFpbmVyIGhhdmUgdG8gYmUgc3VwcGxpZWQgc28gb3RoZXIgc3ZnIGNvbnRhaW5lcnMgKGxpa2UgdGhlIGxlZ2VuZCkgY2FuIHVzZSB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0gZWxlbWVudFR5cGVcbiAgICogQHBhcmFtIEpTT05jb250YWluZXJcbiAgICogQHBhcmFtIERPTUNvbnRhaW5lclxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGV4cG9ydHMuZ2V0RE9NRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50VHlwZSwgSlNPTmNvbnRhaW5lciwgRE9NQ29udGFpbmVyLCBpbnNlcnRCZWZvcmUpIHtcbiAgICB2YXIgZWxlbWVudDtcbiAgICAvLyBhbGxvY2F0ZSBET00gZWxlbWVudCwgaWYgaXQgZG9lc250IHlldCBleGlzdCwgY3JlYXRlIG9uZS5cbiAgICBpZiAoSlNPTmNvbnRhaW5lci5oYXNPd25Qcm9wZXJ0eShlbGVtZW50VHlwZSkpIHtcbiAgICAgIC8vIHRoaXMgZWxlbWVudCBoYXMgYmVlbiBjcmVhdGVkIGJlZm9yZVxuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgaXMgYW4gcmVkdW5kYW50IGVsZW1lbnRcbiAgICAgIGlmIChKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS5yZWR1bmRhbnQubGVuZ3RoID4gMCkge1xuICAgICAgICBlbGVtZW50ID0gSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50WzBdO1xuICAgICAgICBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS5yZWR1bmRhbnQuc2hpZnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBlbGVtZW50IGFuZCBhZGQgaXQgdG8gdGhlIFNWR1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbGVtZW50VHlwZSk7XG4gICAgICAgIGlmIChpbnNlcnRCZWZvcmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIERPTUNvbnRhaW5lci5pbnNlcnRCZWZvcmUoZWxlbWVudCwgaW5zZXJ0QmVmb3JlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBET01Db250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY3JlYXRlIGEgbmV3IGVsZW1lbnQgYW5kIGFkZCBpdCB0byB0aGUgU1ZHLCBhbHNvIGNyZWF0ZSBhIG5ldyBvYmplY3QgaW4gdGhlIHN2Z0VsZW1lbnRzIHRvIGtlZXAgdHJhY2sgb2YgaXQuXG4gICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbGVtZW50VHlwZSk7XG4gICAgICBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXSA9IHsgdXNlZDogW10sIHJlZHVuZGFudDogW10gfTtcbiAgICAgIGlmIChpbnNlcnRCZWZvcmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBET01Db250YWluZXIuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIGluc2VydEJlZm9yZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBET01Db250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdLnVzZWQucHVzaChlbGVtZW50KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfTtcblxuICAvKipcbiAgICogRHJhdyBhIHBvaW50IG9iamVjdC4gVGhpcyBpcyBhIHNlcGFyYXRlIGZ1bmN0aW9uIGJlY2F1c2UgaXQgY2FuIGFsc28gYmUgY2FsbGVkIGJ5IHRoZSBsZWdlbmQuXG4gICAqIFRoZSByZWFzb24gdGhlIEpTT05jb250YWluZXIgYW5kIHRoZSB0YXJnZXQgU1ZHIHN2Z0NvbnRhaW5lciBoYXZlIHRvIGJlIHN1cHBsaWVkIGlzIHNvIHRoZSBsZWdlbmQgY2FuIHVzZSB0aGVzZSBmdW5jdGlvbnNcbiAgICogYXMgd2VsbC5cbiAgICpcbiAgICogQHBhcmFtIHhcbiAgICogQHBhcmFtIHlcbiAgICogQHBhcmFtIGdyb3VwVGVtcGxhdGU6IEEgdGVtcGxhdGUgY29udGFpbmluZyB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIHRvIGRyYXcgdGhlIGRhdGFwb2ludCBlLmcuLCB7c3R5bGU6ICdjaXJjbGUnLCBzaXplOiA1LCBjbGFzc05hbWU6ICdjbGFzc05hbWUnIH1cbiAgICogQHBhcmFtIEpTT05jb250YWluZXJcbiAgICogQHBhcmFtIHN2Z0NvbnRhaW5lclxuICAgKiBAcGFyYW0gbGFiZWxPYmpcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBleHBvcnRzLmRyYXdQb2ludCA9IGZ1bmN0aW9uICh4LCB5LCBncm91cFRlbXBsYXRlLCBKU09OY29udGFpbmVyLCBzdmdDb250YWluZXIsIGxhYmVsT2JqKSB7XG4gICAgdmFyIHBvaW50O1xuICAgIGlmIChncm91cFRlbXBsYXRlLnN0eWxlID09ICdjaXJjbGUnKSB7XG4gICAgICBwb2ludCA9IGV4cG9ydHMuZ2V0U1ZHRWxlbWVudCgnY2lyY2xlJywgSlNPTmNvbnRhaW5lciwgc3ZnQ29udGFpbmVyKTtcbiAgICAgIHBvaW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY3hcIiwgeCk7XG4gICAgICBwb2ludC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImN5XCIsIHkpO1xuICAgICAgcG9pbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJyXCIsIDAuNSAqIGdyb3VwVGVtcGxhdGUuc2l6ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ID0gZXhwb3J0cy5nZXRTVkdFbGVtZW50KCdyZWN0JywgSlNPTmNvbnRhaW5lciwgc3ZnQ29udGFpbmVyKTtcbiAgICAgIHBvaW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCB4IC0gMC41ICogZ3JvdXBUZW1wbGF0ZS5zaXplKTtcbiAgICAgIHBvaW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCB5IC0gMC41ICogZ3JvdXBUZW1wbGF0ZS5zaXplKTtcbiAgICAgIHBvaW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgZ3JvdXBUZW1wbGF0ZS5zaXplKTtcbiAgICAgIHBvaW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIGdyb3VwVGVtcGxhdGUuc2l6ZSk7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwVGVtcGxhdGUuc3R5bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHBvaW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3R5bGVcIiwgZ3JvdXBUZW1wbGF0ZS5zdHlsZXMpO1xuICAgIH1cbiAgICBwb2ludC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsYXNzXCIsIGdyb3VwVGVtcGxhdGUuY2xhc3NOYW1lICsgXCIgdmlzLXBvaW50XCIpO1xuICAgIC8vaGFuZGxlIGxhYmVsXG5cblxuICAgIGlmIChsYWJlbE9iaikge1xuICAgICAgdmFyIGxhYmVsID0gZXhwb3J0cy5nZXRTVkdFbGVtZW50KCd0ZXh0JywgSlNPTmNvbnRhaW5lciwgc3ZnQ29udGFpbmVyKTtcbiAgICAgIGlmIChsYWJlbE9iai54T2Zmc2V0KSB7XG4gICAgICAgIHggPSB4ICsgbGFiZWxPYmoueE9mZnNldDtcbiAgICAgIH1cblxuICAgICAgaWYgKGxhYmVsT2JqLnlPZmZzZXQpIHtcbiAgICAgICAgeSA9IHkgKyBsYWJlbE9iai55T2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKGxhYmVsT2JqLmNvbnRlbnQpIHtcbiAgICAgICAgbGFiZWwudGV4dENvbnRlbnQgPSBsYWJlbE9iai5jb250ZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAobGFiZWxPYmouY2xhc3NOYW1lKSB7XG4gICAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY2xhc3NcIiwgbGFiZWxPYmouY2xhc3NOYW1lICsgXCIgdmlzLWxhYmVsXCIpO1xuICAgICAgfVxuICAgICAgbGFiZWwuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIHgpO1xuICAgICAgbGFiZWwuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIHkpO1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludDtcbiAgfTtcblxuICAvKipcbiAgICogZHJhdyBhIGJhciBTVkcgZWxlbWVudCBjZW50ZXJlZCBvbiB0aGUgWCBjb29yZGluYXRlXG4gICAqXG4gICAqIEBwYXJhbSB4XG4gICAqIEBwYXJhbSB5XG4gICAqIEBwYXJhbSBjbGFzc05hbWVcbiAgICovXG4gIGV4cG9ydHMuZHJhd0JhciA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjbGFzc05hbWUsIEpTT05jb250YWluZXIsIHN2Z0NvbnRhaW5lciwgc3R5bGUpIHtcbiAgICBpZiAoaGVpZ2h0ICE9IDApIHtcbiAgICAgIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgICAgIGhlaWdodCAqPSAtMTtcbiAgICAgICAgeSAtPSBoZWlnaHQ7XG4gICAgICB9XG4gICAgICB2YXIgcmVjdCA9IGV4cG9ydHMuZ2V0U1ZHRWxlbWVudCgncmVjdCcsIEpTT05jb250YWluZXIsIHN2Z0NvbnRhaW5lcik7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCB4IC0gMC41ICogd2lkdGgpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgeSk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgd2lkdGgpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCBoZWlnaHQpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsYXNzXCIsIGNsYXNzTmFtZSk7XG4gICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0eWxlXCIsIHN0eWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qKiovIH0sXG4vKiA5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIFF1ZXVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbiAgLyoqXG4gICAqIERhdGFTZXRcbiAgICpcbiAgICogVXNhZ2U6XG4gICAqICAgICB2YXIgZGF0YVNldCA9IG5ldyBEYXRhU2V0KHtcbiAgICogICAgICAgICBmaWVsZElkOiAnX2lkJyxcbiAgICogICAgICAgICB0eXBlOiB7XG4gICAqICAgICAgICAgICAgIC8vIC4uLlxuICAgKiAgICAgICAgIH1cbiAgICogICAgIH0pO1xuICAgKlxuICAgKiAgICAgZGF0YVNldC5hZGQoaXRlbSk7XG4gICAqICAgICBkYXRhU2V0LmFkZChkYXRhKTtcbiAgICogICAgIGRhdGFTZXQudXBkYXRlKGl0ZW0pO1xuICAgKiAgICAgZGF0YVNldC51cGRhdGUoZGF0YSk7XG4gICAqICAgICBkYXRhU2V0LnJlbW92ZShpZCk7XG4gICAqICAgICBkYXRhU2V0LnJlbW92ZShpZHMpO1xuICAgKiAgICAgdmFyIGRhdGEgPSBkYXRhU2V0LmdldCgpO1xuICAgKiAgICAgdmFyIGRhdGEgPSBkYXRhU2V0LmdldChpZCk7XG4gICAqICAgICB2YXIgZGF0YSA9IGRhdGFTZXQuZ2V0KGlkcyk7XG4gICAqICAgICB2YXIgZGF0YSA9IGRhdGFTZXQuZ2V0KGlkcywgb3B0aW9ucywgZGF0YSk7XG4gICAqICAgICBkYXRhU2V0LmNsZWFyKCk7XG4gICAqXG4gICAqIEEgZGF0YSBzZXQgY2FuOlxuICAgKiAtIGFkZC9yZW1vdmUvdXBkYXRlIGRhdGFcbiAgICogLSBnaXZlcyB0cmlnZ2VycyB1cG9uIGNoYW5nZXMgaW4gdGhlIGRhdGFcbiAgICogLSBjYW4gIGltcG9ydC9leHBvcnQgZGF0YSBpbiB2YXJpb3VzIGRhdGEgZm9ybWF0c1xuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBbZGF0YV0gICAgT3B0aW9uYWwgYXJyYXkgd2l0aCBpbml0aWFsIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gZmllbGRJZCBGaWVsZCBuYW1lIG9mIHRoZSBpZCBpbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMsICdpZCcgYnkgZGVmYXVsdC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3QuPFN0cmluZywgU3RyaW5nfSB0eXBlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEEgbWFwIHdpdGggZmllbGQgbmFtZXMgYXMga2V5LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgdGhlIGZpZWxkIHR5cGUgYXMgdmFsdWUuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0fSBxdWV1ZSAgIFF1ZXVlIGNoYW5nZXMgdG8gdGhlIERhdGFTZXQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoIHRoZW0gYWxsIGF0IG9uY2UuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFF1ZXVlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0ge251bWJlcn0gZGVsYXkgIERlbGF5IGluIG1zLCBudWxsIGJ5IGRlZmF1bHRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB7bnVtYmVyfSBtYXggICAgTWF4aW11bSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgcXVldWUsIEluZmluaXR5IGJ5IGRlZmF1bHRcbiAgICogQGNvbnN0cnVjdG9yIERhdGFTZXRcbiAgICovXG4gIC8vIFRPRE86IGFkZCBhIERhdGFTZXQgY29uc3RydWN0b3IgRGF0YVNldChkYXRhLCBvcHRpb25zKVxuICBmdW5jdGlvbiBEYXRhU2V0KGRhdGEsIG9wdGlvbnMpIHtcbiAgICAvLyBjb3JyZWN0bHkgcmVhZCBvcHRpb25hbCBhcmd1bWVudHNcbiAgICBpZiAoZGF0YSAmJiAhQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgb3B0aW9ucyA9IGRhdGE7XG4gICAgICBkYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLl9kYXRhID0ge307IC8vIG1hcCB3aXRoIGRhdGEgaW5kZXhlZCBieSBpZFxuICAgIHRoaXMubGVuZ3RoID0gMDsgLy8gbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBEYXRhU2V0XG4gICAgdGhpcy5fZmllbGRJZCA9IHRoaXMuX29wdGlvbnMuZmllbGRJZCB8fCAnaWQnOyAvLyBuYW1lIG9mIHRoZSBmaWVsZCBjb250YWluaW5nIGlkXG4gICAgdGhpcy5fdHlwZSA9IHt9OyAvLyBpbnRlcm5hbCBmaWVsZCB0eXBlcyAoTk9URTogdGhpcyBjYW4gZGlmZmVyIGZyb20gdGhpcy5fb3B0aW9ucy50eXBlKVxuXG4gICAgLy8gYWxsIHZhcmlhbnRzIG9mIGEgRGF0ZSBhcmUgaW50ZXJuYWxseSBzdG9yZWQgYXMgRGF0ZSwgc28gd2UgY2FuIGNvbnZlcnRcbiAgICAvLyBmcm9tIGV2ZXJ5dGhpbmcgdG8gZXZlcnl0aGluZyAoYWxzbyBmcm9tIElTT0RhdGUgdG8gTnVtYmVyIGZvciBleGFtcGxlKVxuICAgIGlmICh0aGlzLl9vcHRpb25zLnR5cGUpIHtcbiAgICAgIHZhciBmaWVsZHMgPSBPYmplY3Qua2V5cyh0aGlzLl9vcHRpb25zLnR5cGUpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX29wdGlvbnMudHlwZVtmaWVsZF07XG4gICAgICAgIGlmICh2YWx1ZSA9PSAnRGF0ZScgfHwgdmFsdWUgPT0gJ0lTT0RhdGUnIHx8IHZhbHVlID09ICdBU1BEYXRlJykge1xuICAgICAgICAgIHRoaXMuX3R5cGVbZmllbGRdID0gJ0RhdGUnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3R5cGVbZmllbGRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS4xLjEgKG9yIDIuMC4wPylcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jb252ZXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbiBcImNvbnZlcnRcIiBpcyBkZXByZWNhdGVkLiBVc2UgXCJ0eXBlXCIgaW5zdGVhZC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdWJzY3JpYmVycyA9IHt9OyAvLyBldmVudCBzdWJzY3JpYmVyc1xuXG4gICAgLy8gYWRkIGluaXRpYWwgZGF0YSB3aGVuIHByb3ZpZGVkXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuYWRkKGRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0fSBxdWV1ZSAgIFF1ZXVlIGNoYW5nZXMgdG8gdGhlIERhdGFTZXQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoIHRoZW0gYWxsIGF0IG9uY2UuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFF1ZXVlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0ge251bWJlcn0gZGVsYXkgIERlbGF5IGluIG1zLCBudWxsIGJ5IGRlZmF1bHRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB7bnVtYmVyfSBtYXggICAgTWF4aW11bSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgcXVldWUsIEluZmluaXR5IGJ5IGRlZmF1bHRcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucXVldWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKG9wdGlvbnMucXVldWUgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIGRlbGV0ZSBxdWV1ZSBpZiBsb2FkZWRcbiAgICAgICAgaWYgKHRoaXMuX3F1ZXVlKSB7XG4gICAgICAgICAgdGhpcy5fcXVldWUuZGVzdHJveSgpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9xdWV1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3JlYXRlIHF1ZXVlIGFuZCB1cGRhdGUgaXRzIG9wdGlvbnNcbiAgICAgICAgaWYgKCF0aGlzLl9xdWV1ZSkge1xuICAgICAgICAgIHRoaXMuX3F1ZXVlID0gUXVldWUuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIHJlcGxhY2U6IFsnYWRkJywgJ3VwZGF0ZScsICdyZW1vdmUnXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90eXBlb2Yob3B0aW9ucy5xdWV1ZSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhpcy5fcXVldWUuc2V0T3B0aW9ucyhvcHRpb25zLnF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIGFuIGV2ZW50LCBhZGQgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50ICAgICAgICBFdmVudCBuYW1lLiBBdmFpbGFibGUgZXZlbnRzOiAncHV0JywgJ3VwZGF0ZScsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlbW92ZSdcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBDYWxsYmFjayBtZXRob2QuIENhbGxlZCB3aXRoIHRocmVlIHBhcmFtZXRlcnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IGV2ZW50XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3QgfCBudWxsfSBwYXJhbXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IE51bWJlcn0gc2VuZGVySWRcbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIHZhciBzdWJzY3JpYmVycyA9IHRoaXMuX3N1YnNjcmliZXJzW2V2ZW50XTtcbiAgICBpZiAoIXN1YnNjcmliZXJzKSB7XG4gICAgICBzdWJzY3JpYmVycyA9IFtdO1xuICAgICAgdGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdID0gc3Vic2NyaWJlcnM7XG4gICAgfVxuXG4gICAgc3Vic2NyaWJlcnMucHVzaCh7XG4gICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICB9KTtcbiAgfTtcblxuICAvLyBUT0RPOiByZW1vdmUgdGhpcyBkZXByZWNhdGVkIGZ1bmN0aW9uIHNvbWUgZGF5IChyZXBsYWNlZCB3aXRoIGBvbmAgc2luY2UgdmVyc2lvbiAwLjUsIGRlcHJlY2F0ZWQgc2luY2UgdjQuMClcbiAgRGF0YVNldC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGF0YVNldC5zdWJzY3JpYmUgaXMgZGVwcmVjYXRlZC4gVXNlIERhdGFTZXQub24gaW5zdGVhZC4nKTtcbiAgfTtcblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSBhbiBldmVudCwgcmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgRGF0YVNldC5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIHZhciBzdWJzY3JpYmVycyA9IHRoaXMuX3N1YnNjcmliZXJzW2V2ZW50XTtcbiAgICBpZiAoc3Vic2NyaWJlcnMpIHtcbiAgICAgIHRoaXMuX3N1YnNjcmliZXJzW2V2ZW50XSA9IHN1YnNjcmliZXJzLmZpbHRlcihmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyLmNhbGxiYWNrICE9IGNhbGxiYWNrO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRPRE86IHJlbW92ZSB0aGlzIGRlcHJlY2F0ZWQgZnVuY3Rpb24gc29tZSBkYXkgKHJlcGxhY2VkIHdpdGggYG9uYCBzaW5jZSB2ZXJzaW9uIDAuNSwgZGVwcmVjYXRlZCBzaW5jZSB2NC4wKVxuICBEYXRhU2V0LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFTZXQudW5zdWJzY3JpYmUgaXMgZGVwcmVjYXRlZC4gVXNlIERhdGFTZXQub2ZmIGluc3RlYWQuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgYW4gZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0IHwgbnVsbH0gcGFyYW1zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VuZGVySWRdICAgICAgIE9wdGlvbmFsIGlkIG9mIHRoZSBzZW5kZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBEYXRhU2V0LnByb3RvdHlwZS5fdHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgIGlmIChldmVudCA9PSAnKicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHRyaWdnZXIgZXZlbnQgKicpO1xuICAgIH1cblxuICAgIHZhciBzdWJzY3JpYmVycyA9IFtdO1xuICAgIGlmIChldmVudCBpbiB0aGlzLl9zdWJzY3JpYmVycykge1xuICAgICAgc3Vic2NyaWJlcnMgPSBzdWJzY3JpYmVycy5jb25jYXQodGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdKTtcbiAgICB9XG4gICAgaWYgKCcqJyBpbiB0aGlzLl9zdWJzY3JpYmVycykge1xuICAgICAgc3Vic2NyaWJlcnMgPSBzdWJzY3JpYmVycy5jb25jYXQodGhpcy5fc3Vic2NyaWJlcnNbJyonXSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN1YnNjcmliZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgc3Vic2NyaWJlciA9IHN1YnNjcmliZXJzW2ldO1xuICAgICAgaWYgKHN1YnNjcmliZXIuY2FsbGJhY2spIHtcbiAgICAgICAgc3Vic2NyaWJlci5jYWxsYmFjayhldmVudCwgcGFyYW1zLCBzZW5kZXJJZCB8fCBudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBkYXRhLlxuICAgKiBBZGRpbmcgYW4gaXRlbSB3aWxsIGZhaWwgd2hlbiB0aGVyZSBhbHJlYWR5IGlzIGFuIGl0ZW0gd2l0aCB0aGUgc2FtZSBpZC5cbiAgICogQHBhcmFtIHtPYmplY3QgfCBBcnJheX0gZGF0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlbmRlcklkXSBPcHRpb25hbCBzZW5kZXIgaWRcbiAgICogQHJldHVybiB7QXJyYXl9IGFkZGVkSWRzICAgICAgQXJyYXkgd2l0aCB0aGUgaWRzIG9mIHRoZSBhZGRlZCBpdGVtc1xuICAgKi9cbiAgRGF0YVNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGRhdGEsIHNlbmRlcklkKSB7XG4gICAgdmFyIGFkZGVkSWRzID0gW10sXG4gICAgICAgIGlkLFxuICAgICAgICBtZSA9IHRoaXM7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgLy8gQXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlkID0gbWUuX2FkZEl0ZW0oZGF0YVtpXSk7XG4gICAgICAgIGFkZGVkSWRzLnB1c2goaWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgLy8gU2luZ2xlIGl0ZW1cbiAgICAgIGlkID0gbWUuX2FkZEl0ZW0oZGF0YSk7XG4gICAgICBhZGRlZElkcy5wdXNoKGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGRhdGFUeXBlJyk7XG4gICAgfVxuXG4gICAgaWYgKGFkZGVkSWRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fdHJpZ2dlcignYWRkJywgeyBpdGVtczogYWRkZWRJZHMgfSwgc2VuZGVySWQpO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRlZElkcztcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGV4aXN0aW5nIGl0ZW1zLiBXaGVuIGFuIGl0ZW0gZG9lcyBub3QgZXhpc3QsIGl0IHdpbGwgYmUgY3JlYXRlZFxuICAgKiBAcGFyYW0ge09iamVjdCB8IEFycmF5fSBkYXRhXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VuZGVySWRdIE9wdGlvbmFsIHNlbmRlciBpZFxuICAgKiBAcmV0dXJuIHtBcnJheX0gdXBkYXRlZElkcyAgICAgVGhlIGlkcyBvZiB0aGUgYWRkZWQgb3IgdXBkYXRlZCBpdGVtc1xuICAgKi9cbiAgRGF0YVNldC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIHNlbmRlcklkKSB7XG4gICAgdmFyIGFkZGVkSWRzID0gW107XG4gICAgdmFyIHVwZGF0ZWRJZHMgPSBbXTtcbiAgICB2YXIgb2xkRGF0YSA9IFtdO1xuICAgIHZhciB1cGRhdGVkRGF0YSA9IFtdO1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIGZpZWxkSWQgPSBtZS5fZmllbGRJZDtcblxuICAgIHZhciBhZGRPclVwZGF0ZSA9IGZ1bmN0aW9uIGFkZE9yVXBkYXRlKGl0ZW0pIHtcbiAgICAgIHZhciBpZCA9IGl0ZW1bZmllbGRJZF07XG4gICAgICBpZiAobWUuX2RhdGFbaWRdKSB7XG4gICAgICAgIHZhciBvbGRJdGVtID0gdXRpbC5leHRlbmQoe30sIG1lLl9kYXRhW2lkXSk7XG4gICAgICAgIC8vIHVwZGF0ZSBpdGVtXG4gICAgICAgIGlkID0gbWUuX3VwZGF0ZUl0ZW0oaXRlbSk7XG4gICAgICAgIHVwZGF0ZWRJZHMucHVzaChpZCk7XG4gICAgICAgIHVwZGF0ZWREYXRhLnB1c2goaXRlbSk7XG4gICAgICAgIG9sZERhdGEucHVzaChvbGRJdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFkZCBuZXcgaXRlbVxuICAgICAgICBpZCA9IG1lLl9hZGRJdGVtKGl0ZW0pO1xuICAgICAgICBhZGRlZElkcy5wdXNoKGlkKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIC8vIEFycmF5XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoZGF0YVtpXSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgIGFkZE9yVXBkYXRlKGRhdGFbaV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybignSWdub3JpbmcgaW5wdXQgaXRlbSwgd2hpY2ggaXMgbm90IGFuIG9iamVjdCBhdCBpbmRleCAnICsgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIC8vIFNpbmdsZSBpdGVtXG4gICAgICBhZGRPclVwZGF0ZShkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGRhdGFUeXBlJyk7XG4gICAgfVxuXG4gICAgaWYgKGFkZGVkSWRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fdHJpZ2dlcignYWRkJywgeyBpdGVtczogYWRkZWRJZHMgfSwgc2VuZGVySWQpO1xuICAgIH1cbiAgICBpZiAodXBkYXRlZElkcy5sZW5ndGgpIHtcbiAgICAgIHZhciBwcm9wcyA9IHsgaXRlbXM6IHVwZGF0ZWRJZHMsIG9sZERhdGE6IG9sZERhdGEsIGRhdGE6IHVwZGF0ZWREYXRhIH07XG4gICAgICAvLyBUT0RPOiByZW1vdmUgZGVwcmVjYXRlZCBwcm9wZXJ0eSAnZGF0YScgc29tZSBkYXlcbiAgICAgIC8vT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAnZGF0YScsIHtcbiAgICAgIC8vICAnZ2V0JzogKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gICAgY29uc29sZS53YXJuKCdQcm9wZXJ0eSBkYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBEYXRhU2V0LmdldChpZHMpIHRvIHJldHJpZXZlIHRoZSBuZXcgZGF0YSwgdXNlIHRoZSBvbGREYXRhIHByb3BlcnR5IG9uIHRoaXMgb2JqZWN0IHRvIGdldCB0aGUgb2xkIGRhdGEnKTtcbiAgICAgIC8vICAgIHJldHVybiB1cGRhdGVkRGF0YTtcbiAgICAgIC8vICB9KS5iaW5kKHRoaXMpXG4gICAgICAvL30pO1xuICAgICAgdGhpcy5fdHJpZ2dlcigndXBkYXRlJywgcHJvcHMsIHNlbmRlcklkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRkZWRJZHMuY29uY2F0KHVwZGF0ZWRJZHMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBkYXRhIGl0ZW0gb3IgbXVsdGlwbGUgaXRlbXMuXG4gICAqXG4gICAqIFVzYWdlOlxuICAgKlxuICAgKiAgICAgZ2V0KClcbiAgICogICAgIGdldChvcHRpb25zOiBPYmplY3QpXG4gICAqXG4gICAqICAgICBnZXQoaWQ6IE51bWJlciB8IFN0cmluZylcbiAgICogICAgIGdldChpZDogTnVtYmVyIHwgU3RyaW5nLCBvcHRpb25zOiBPYmplY3QpXG4gICAqXG4gICAqICAgICBnZXQoaWRzOiBOdW1iZXJbXSB8IFN0cmluZ1tdKVxuICAgKiAgICAgZ2V0KGlkczogTnVtYmVyW10gfCBTdHJpbmdbXSwgb3B0aW9uczogT2JqZWN0KVxuICAgKlxuICAgKiBXaGVyZTpcbiAgICpcbiAgICoge051bWJlciB8IFN0cmluZ30gaWQgICAgICAgICBUaGUgaWQgb2YgYW4gaXRlbVxuICAgKiB7TnVtYmVyW10gfCBTdHJpbmd7fX0gaWRzICAgIEFuIGFycmF5IHdpdGggaWRzIG9mIGl0ZW1zXG4gICAqIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICAgICAgQW4gT2JqZWN0IHdpdGggb3B0aW9ucy4gQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqIHtTdHJpbmd9IFtyZXR1cm5UeXBlXSAgICAgICAgVHlwZSBvZiBkYXRhIHRvIGJlIHJldHVybmVkLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbiBiZSAnQXJyYXknIChkZWZhdWx0KSBvciAnT2JqZWN0Jy5cbiAgICoge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBbdHlwZV1cbiAgICoge1N0cmluZ1tdfSBbZmllbGRzXSAgICAgICAgICBmaWVsZCBuYW1lcyB0byBiZSByZXR1cm5lZFxuICAgKiB7ZnVuY3Rpb259IFtmaWx0ZXJdICAgICAgICAgIGZpbHRlciBpdGVtc1xuICAgKiB7U3RyaW5nIHwgZnVuY3Rpb259IFtvcmRlcl0gIE9yZGVyIHRoZSBpdGVtcyBieSBhIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXG4gICAqIEB0aHJvd3MgRXJyb3JcbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgdmFyIG1lID0gdGhpcztcblxuICAgIC8vIHBhcnNlIHRoZSBhcmd1bWVudHNcbiAgICB2YXIgaWQsIGlkcywgb3B0aW9ucztcbiAgICB2YXIgZmlyc3RUeXBlID0gdXRpbC5nZXRUeXBlKGFyZ3VtZW50c1swXSk7XG4gICAgaWYgKGZpcnN0VHlwZSA9PSAnU3RyaW5nJyB8fCBmaXJzdFR5cGUgPT0gJ051bWJlcicpIHtcbiAgICAgIC8vIGdldChpZCBbLCBvcHRpb25zXSlcbiAgICAgIGlkID0gYXJndW1lbnRzWzBdO1xuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXTtcbiAgICB9IGVsc2UgaWYgKGZpcnN0VHlwZSA9PSAnQXJyYXknKSB7XG4gICAgICAvLyBnZXQoaWRzIFssIG9wdGlvbnNdKVxuICAgICAgaWRzID0gYXJndW1lbnRzWzBdO1xuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZ2V0KFssIG9wdGlvbnNdKVxuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1swXTtcbiAgICB9XG5cbiAgICAvLyBkZXRlcm1pbmUgdGhlIHJldHVybiB0eXBlXG4gICAgdmFyIHJldHVyblR5cGU7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZXR1cm5UeXBlKSB7XG4gICAgICB2YXIgYWxsb3dlZFZhbHVlcyA9IFsnQXJyYXknLCAnT2JqZWN0J107XG4gICAgICByZXR1cm5UeXBlID0gYWxsb3dlZFZhbHVlcy5pbmRleE9mKG9wdGlvbnMucmV0dXJuVHlwZSkgPT0gLTEgPyAnQXJyYXknIDogb3B0aW9ucy5yZXR1cm5UeXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5UeXBlID0gJ0FycmF5JztcbiAgICB9XG5cbiAgICAvLyBidWlsZCBvcHRpb25zXG4gICAgdmFyIHR5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCB0aGlzLl9vcHRpb25zLnR5cGU7XG4gICAgdmFyIGZpbHRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXI7XG4gICAgdmFyIGl0ZW1zID0gW10sXG4gICAgICAgIGl0ZW0sXG4gICAgICAgIGl0ZW1JZHMsXG4gICAgICAgIGl0ZW1JZCxcbiAgICAgICAgaSxcbiAgICAgICAgbGVuO1xuXG4gICAgLy8gY29udmVydCBpdGVtc1xuICAgIGlmIChpZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJldHVybiBhIHNpbmdsZSBpdGVtXG4gICAgICBpdGVtID0gbWUuX2dldEl0ZW0oaWQsIHR5cGUpO1xuICAgICAgaWYgKGl0ZW0gJiYgZmlsdGVyICYmICFmaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgaXRlbSA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpZHMgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBzdWJzZXQgb2YgaXRlbXNcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpdGVtID0gbWUuX2dldEl0ZW0oaWRzW2ldLCB0eXBlKTtcbiAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXR1cm4gYWxsIGl0ZW1zXG4gICAgICBpdGVtSWRzID0gT2JqZWN0LmtleXModGhpcy5fZGF0YSk7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGl0ZW1JZCA9IGl0ZW1JZHNbaV07XG4gICAgICAgIGl0ZW0gPSBtZS5fZ2V0SXRlbShpdGVtSWQsIHR5cGUpO1xuICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gb3JkZXIgdGhlIHJlc3VsdHNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyICYmIGlkID09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fc29ydChpdGVtcywgb3B0aW9ucy5vcmRlcik7XG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIGZpZWxkcyBvZiB0aGUgaXRlbXNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZpZWxkcykge1xuICAgICAgdmFyIGZpZWxkcyA9IG9wdGlvbnMuZmllbGRzO1xuICAgICAgaWYgKGlkICE9IHVuZGVmaW5lZCkge1xuICAgICAgICBpdGVtID0gdGhpcy5fZmlsdGVyRmllbGRzKGl0ZW0sIGZpZWxkcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGl0ZW1zW2ldID0gdGhpcy5fZmlsdGVyRmllbGRzKGl0ZW1zW2ldLCBmaWVsZHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIHRoZSByZXN1bHRzXG4gICAgaWYgKHJldHVyblR5cGUgPT0gJ09iamVjdCcpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fSxcbiAgICAgICAgICByZXN1bHRhbnQ7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICByZXN1bHRhbnQgPSBpdGVtc1tpXTtcbiAgICAgICAgcmVzdWx0W3Jlc3VsdGFudC5pZF0gPSByZXN1bHRhbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGEgc2luZ2xlIGl0ZW1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBqdXN0IHJldHVybiBvdXIgYXJyYXlcbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IGlkcyBvZiBhbGwgaXRlbXMgb3IgZnJvbSBhIGZpbHRlcmVkIHNldCBvZiBpdGVtcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICBBbiBPYmplY3Qgd2l0aCBvcHRpb25zLiBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZnVuY3Rpb259IFtmaWx0ZXJdIGZpbHRlciBpdGVtc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBmdW5jdGlvbn0gW29yZGVyXSBPcmRlciB0aGUgaXRlbXMgYnlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gaWRzXG4gICAqL1xuICBEYXRhU2V0LnByb3RvdHlwZS5nZXRJZHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcixcbiAgICAgICAgb3JkZXIgPSBvcHRpb25zICYmIG9wdGlvbnMub3JkZXIsXG4gICAgICAgIHR5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCB0aGlzLl9vcHRpb25zLnR5cGUsXG4gICAgICAgIGl0ZW1JZHMgPSBPYmplY3Qua2V5cyhkYXRhKSxcbiAgICAgICAgaSxcbiAgICAgICAgbGVuLFxuICAgICAgICBpZCxcbiAgICAgICAgaXRlbSxcbiAgICAgICAgaXRlbXMsXG4gICAgICAgIGlkcyA9IFtdO1xuXG4gICAgaWYgKGZpbHRlcikge1xuICAgICAgLy8gZ2V0IGZpbHRlcmVkIGl0ZW1zXG4gICAgICBpZiAob3JkZXIpIHtcbiAgICAgICAgLy8gY3JlYXRlIG9yZGVyZWQgbGlzdFxuICAgICAgICBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWQgPSBpdGVtSWRzW2ldO1xuICAgICAgICAgIGl0ZW0gPSB0aGlzLl9nZXRJdGVtKGlkLCB0eXBlKTtcbiAgICAgICAgICBpZiAoZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NvcnQoaXRlbXMsIG9yZGVyKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlkcy5wdXNoKGl0ZW1zW2ldW3RoaXMuX2ZpZWxkSWRdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3JlYXRlIHVub3JkZXJlZCBsaXN0XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1JZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZCA9IGl0ZW1JZHNbaV07XG4gICAgICAgICAgaXRlbSA9IHRoaXMuX2dldEl0ZW0oaWQsIHR5cGUpO1xuICAgICAgICAgIGlmIChmaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgICAgIGlkcy5wdXNoKGl0ZW1bdGhpcy5fZmllbGRJZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBnZXQgYWxsIGl0ZW1zXG4gICAgICBpZiAob3JkZXIpIHtcbiAgICAgICAgLy8gY3JlYXRlIGFuIG9yZGVyZWQgbGlzdFxuICAgICAgICBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWQgPSBpdGVtSWRzW2ldO1xuICAgICAgICAgIGl0ZW1zLnB1c2goZGF0YVtpZF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc29ydChpdGVtcywgb3JkZXIpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWRzLnB1c2goaXRlbXNbaV1bdGhpcy5fZmllbGRJZF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjcmVhdGUgdW5vcmRlcmVkIGxpc3RcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gaXRlbUlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlkID0gaXRlbUlkc1tpXTtcbiAgICAgICAgICBpdGVtID0gZGF0YVtpZF07XG4gICAgICAgICAgaWRzLnB1c2goaXRlbVt0aGlzLl9maWVsZElkXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaWRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBEYXRhU2V0IGl0c2VsZi4gSXMgb3ZlcndyaXR0ZW4gZm9yIGV4YW1wbGUgYnkgdGhlIERhdGFWaWV3LFxuICAgKiB3aGljaCByZXR1cm5zIHRoZSBEYXRhU2V0IGl0IGlzIGNvbm5lY3RlZCB0byBpbnN0ZWFkLlxuICAgKi9cbiAgRGF0YVNldC5wcm90b3R5cGUuZ2V0RGF0YVNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogRXhlY3V0ZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBldmVyeSBpdGVtIGluIHRoZSBkYXRhc2V0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gW3R5cGVdXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ1tdfSBbZmllbGRzXSBmaWx0ZXIgZmllbGRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Z1bmN0aW9ufSBbZmlsdGVyXSBmaWx0ZXIgaXRlbXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgZnVuY3Rpb259IFtvcmRlcl0gT3JkZXIgdGhlIGl0ZW1zIGJ5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICB2YXIgZmlsdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcixcbiAgICAgICAgdHlwZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlIHx8IHRoaXMuX29wdGlvbnMudHlwZSxcbiAgICAgICAgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICAgIGl0ZW1JZHMgPSBPYmplY3Qua2V5cyhkYXRhKSxcbiAgICAgICAgaSxcbiAgICAgICAgbGVuLFxuICAgICAgICBpdGVtLFxuICAgICAgICBpZDtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMub3JkZXIpIHtcbiAgICAgIC8vIGV4ZWN1dGUgZm9yRWFjaCBvbiBvcmRlcmVkIGxpc3RcbiAgICAgIHZhciBpdGVtcyA9IHRoaXMuZ2V0KG9wdGlvbnMpO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlkID0gaXRlbVt0aGlzLl9maWVsZElkXTtcbiAgICAgICAgY2FsbGJhY2soaXRlbSwgaWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bm9yZGVyZWRcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1JZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWQgPSBpdGVtSWRzW2ldO1xuICAgICAgICBpdGVtID0gdGhpcy5fZ2V0SXRlbShpZCwgdHlwZSk7XG4gICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihpdGVtKSkge1xuICAgICAgICAgIGNhbGxiYWNrKGl0ZW0sIGlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTWFwIGV2ZXJ5IGl0ZW0gaW4gdGhlIGRhdGFzZXQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBbdHlwZV1cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nW119IFtmaWVsZHNdIGZpbHRlciBmaWVsZHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZnVuY3Rpb259IFtmaWx0ZXJdIGZpbHRlciBpdGVtc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBmdW5jdGlvbn0gW29yZGVyXSBPcmRlciB0aGUgaXRlbXMgYnlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gbWFwcGVkSXRlbXNcbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIHZhciBmaWx0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyLFxuICAgICAgICB0eXBlID0gb3B0aW9ucyAmJiBvcHRpb25zLnR5cGUgfHwgdGhpcy5fb3B0aW9ucy50eXBlLFxuICAgICAgICBtYXBwZWRJdGVtcyA9IFtdLFxuICAgICAgICBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgICAgaXRlbUlkcyA9IE9iamVjdC5rZXlzKGRhdGEpLFxuICAgICAgICBpLFxuICAgICAgICBsZW4sXG4gICAgICAgIGlkLFxuICAgICAgICBpdGVtO1xuXG4gICAgLy8gY29udmVydCBhbmQgZmlsdGVyIGl0ZW1zXG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbUlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWQgPSBpdGVtSWRzW2ldO1xuICAgICAgaXRlbSA9IHRoaXMuX2dldEl0ZW0oaWQsIHR5cGUpO1xuICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgIG1hcHBlZEl0ZW1zLnB1c2goY2FsbGJhY2soaXRlbSwgaWQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBvcmRlciBpdGVtc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMub3JkZXIpIHtcbiAgICAgIHRoaXMuX3NvcnQobWFwcGVkSXRlbXMsIG9wdGlvbnMub3JkZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXBwZWRJdGVtcztcbiAgfTtcblxuICAvKipcbiAgICogRmlsdGVyIHRoZSBmaWVsZHMgb2YgYW4gaXRlbVxuICAgKiBAcGFyYW0ge09iamVjdCB8IG51bGx9IGl0ZW1cbiAgICogQHBhcmFtIHtTdHJpbmdbXX0gZmllbGRzICAgICBGaWVsZCBuYW1lc1xuICAgKiBAcmV0dXJuIHtPYmplY3QgfCBudWxsfSBmaWx0ZXJlZEl0ZW0gb3IgbnVsbCBpZiBubyBpdGVtIGlzIHByb3ZpZGVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBEYXRhU2V0LnByb3RvdHlwZS5fZmlsdGVyRmllbGRzID0gZnVuY3Rpb24gKGl0ZW0sIGZpZWxkcykge1xuICAgIGlmICghaXRlbSkge1xuICAgICAgLy8gaXRlbSBpcyBudWxsXG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICB2YXIgZmlsdGVyZWRJdGVtID0ge30sXG4gICAgICAgIGl0ZW1GaWVsZHMgPSBPYmplY3Qua2V5cyhpdGVtKSxcbiAgICAgICAgbGVuID0gaXRlbUZpZWxkcy5sZW5ndGgsXG4gICAgICAgIGksXG4gICAgICAgIGZpZWxkO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRzKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGZpZWxkID0gaXRlbUZpZWxkc1tpXTtcbiAgICAgICAgaWYgKGZpZWxkcy5pbmRleE9mKGZpZWxkKSAhPSAtMSkge1xuICAgICAgICAgIGZpbHRlcmVkSXRlbVtmaWVsZF0gPSBpdGVtW2ZpZWxkXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZmllbGQgPSBpdGVtRmllbGRzW2ldO1xuICAgICAgICBpZiAoZmllbGRzLmhhc093blByb3BlcnR5KGZpZWxkKSkge1xuICAgICAgICAgIGZpbHRlcmVkSXRlbVtmaWVsZHNbZmllbGRdXSA9IGl0ZW1bZmllbGRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbHRlcmVkSXRlbTtcbiAgfTtcblxuICAvKipcbiAgICogU29ydCB0aGUgcHJvdmlkZWQgYXJyYXkgd2l0aCBpdGVtc1xuICAgKiBAcGFyYW0ge09iamVjdFtdfSBpdGVtc1xuICAgKiBAcGFyYW0ge1N0cmluZyB8IGZ1bmN0aW9ufSBvcmRlciAgICAgIEEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLl9zb3J0ID0gZnVuY3Rpb24gKGl0ZW1zLCBvcmRlcikge1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKG9yZGVyKSkge1xuICAgICAgLy8gb3JkZXIgYnkgcHJvdmlkZWQgZmllbGQgbmFtZVxuICAgICAgdmFyIG5hbWUgPSBvcmRlcjsgLy8gZmllbGQgbmFtZVxuICAgICAgaXRlbXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgYXYgPSBhW25hbWVdO1xuICAgICAgICB2YXIgYnYgPSBiW25hbWVdO1xuICAgICAgICByZXR1cm4gYXYgPiBidiA/IDEgOiBhdiA8IGJ2ID8gLTEgOiAwO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3JkZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIG9yZGVyIGJ5IHNvcnQgZnVuY3Rpb25cbiAgICAgIGl0ZW1zLnNvcnQob3JkZXIpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBleHRlbmQgb3JkZXIgYnkgYW4gT2JqZWN0IHtmaWVsZDpTdHJpbmcsIGRpcmVjdGlvbjpTdHJpbmd9XG4gICAgLy8gICAgICAgd2hlcmUgZGlyZWN0aW9uIGNhbiBiZSAnYXNjJyBvciAnZGVzYydcbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3JkZXIgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nJyk7XG4gICAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBvYmplY3QgYnkgcG9pbnRlciBvciBieSBpZFxuICAgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlciB8IE9iamVjdCB8IEFycmF5fSBpZCBPYmplY3Qgb3IgaWQsIG9yIGFuIGFycmF5IHdpdGhcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0cyBvciBpZHMgdG8gYmUgcmVtb3ZlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlbmRlcklkXSBPcHRpb25hbCBzZW5kZXIgaWRcbiAgICogQHJldHVybiB7QXJyYXl9IHJlbW92ZWRJZHNcbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChpZCwgc2VuZGVySWQpIHtcbiAgICB2YXIgcmVtb3ZlZElkcyA9IFtdLFxuICAgICAgICByZW1vdmVkSXRlbXMgPSBbXSxcbiAgICAgICAgaWRzID0gW10sXG4gICAgICAgIGksXG4gICAgICAgIGxlbixcbiAgICAgICAgaXRlbUlkLFxuICAgICAgICBpdGVtO1xuXG4gICAgLy8gZm9yY2UgZXZlcnl0aGluZyB0byBiZSBhbiBhcnJheSBmb3Igc2ltcGxpY2l0eVxuICAgIGlkcyA9IEFycmF5LmlzQXJyYXkoaWQpID8gaWQgOiBbaWRdO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpdGVtID0gdGhpcy5fcmVtb3ZlKGlkc1tpXSk7XG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICBpdGVtSWQgPSBpdGVtW3RoaXMuX2ZpZWxkSWRdO1xuICAgICAgICBpZiAoaXRlbUlkKSB7XG4gICAgICAgICAgcmVtb3ZlZElkcy5wdXNoKGl0ZW1JZCk7XG4gICAgICAgICAgcmVtb3ZlZEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVtb3ZlZElkcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3RyaWdnZXIoJ3JlbW92ZScsIHsgaXRlbXM6IHJlbW92ZWRJZHMsIG9sZERhdGE6IHJlbW92ZWRJdGVtcyB9LCBzZW5kZXJJZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbW92ZWRJZHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBpdGVtIGJ5IGl0cyBpZFxuICAgKiBAcGFyYW0ge051bWJlciB8IFN0cmluZyB8IE9iamVjdH0gaWQgICBpZCBvciBpdGVtXG4gICAqIEByZXR1cm5zIHtOdW1iZXIgfCBTdHJpbmcgfCBudWxsfSBpZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRGF0YVNldC5wcm90b3R5cGUuX3JlbW92ZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtLCBpZGVudDtcblxuICAgIC8vIGNvbmZpcm0gdGhlIGlkIHRvIHVzZSBiYXNlZCBvbiB0aGUgYXJncyB0eXBlXG4gICAgaWYgKHV0aWwuaXNOdW1iZXIoaWQpIHx8IHV0aWwuaXNTdHJpbmcoaWQpKSB7XG4gICAgICBpZGVudCA9IGlkO1xuICAgIH0gZWxzZSBpZiAoaWQgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIGlkZW50ID0gaWRbdGhpcy5fZmllbGRJZF07IC8vIGxvb2sgZm9yIHRoZSBpZGVudGlmaWVyIGZpZWxkIHVzaW5nIF9maWVsZElkXG4gICAgfVxuXG4gICAgLy8gZG8gdGhlIHJlbW92ZSBpZiB0aGUgaXRlbSBpcyBmb3VuZFxuICAgIGlmIChpZGVudCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX2RhdGFbaWRlbnRdKSB7XG4gICAgICBpdGVtID0gdGhpcy5fZGF0YVtpZGVudF07XG4gICAgICBkZWxldGUgdGhpcy5fZGF0YVtpZGVudF07XG4gICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhciB0aGUgZGF0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlbmRlcklkXSBPcHRpb25hbCBzZW5kZXIgaWRcbiAgICogQHJldHVybiB7QXJyYXl9IHJlbW92ZWRJZHMgICAgVGhlIGlkcyBvZiBhbGwgcmVtb3ZlZCBpdGVtc1xuICAgKi9cbiAgRGF0YVNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoc2VuZGVySWQpIHtcbiAgICB2YXIgaSwgbGVuO1xuICAgIHZhciBpZHMgPSBPYmplY3Qua2V5cyh0aGlzLl9kYXRhKTtcbiAgICB2YXIgaXRlbXMgPSBbXTtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaXRlbXMucHVzaCh0aGlzLl9kYXRhW2lkc1tpXV0pO1xuICAgIH1cblxuICAgIHRoaXMuX2RhdGEgPSB7fTtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICB0aGlzLl90cmlnZ2VyKCdyZW1vdmUnLCB7IGl0ZW1zOiBpZHMsIG9sZERhdGE6IGl0ZW1zIH0sIHNlbmRlcklkKTtcblxuICAgIHJldHVybiBpZHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIGl0ZW0gd2l0aCBtYXhpbXVtIHZhbHVlIG9mIGEgc3BlY2lmaWVkIGZpZWxkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICAgKiBAcmV0dXJuIHtPYmplY3QgfCBudWxsfSBpdGVtICBJdGVtIGNvbnRhaW5pbmcgbWF4IHZhbHVlLCBvciBudWxsIGlmIG5vIGl0ZW1zXG4gICAqL1xuICBEYXRhU2V0LnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICAgIGl0ZW1JZHMgPSBPYmplY3Qua2V5cyhkYXRhKSxcbiAgICAgICAgbWF4ID0gbnVsbCxcbiAgICAgICAgbWF4RmllbGQgPSBudWxsLFxuICAgICAgICBpLFxuICAgICAgICBsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgaWQgPSBpdGVtSWRzW2ldO1xuICAgICAgdmFyIGl0ZW0gPSBkYXRhW2lkXTtcbiAgICAgIHZhciBpdGVtRmllbGQgPSBpdGVtW2ZpZWxkXTtcbiAgICAgIGlmIChpdGVtRmllbGQgIT0gbnVsbCAmJiAoIW1heCB8fCBpdGVtRmllbGQgPiBtYXhGaWVsZCkpIHtcbiAgICAgICAgbWF4ID0gaXRlbTtcbiAgICAgICAgbWF4RmllbGQgPSBpdGVtRmllbGQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heDtcbiAgfTtcblxuICAvKipcbiAgICogRmluZCB0aGUgaXRlbSB3aXRoIG1pbmltdW0gdmFsdWUgb2YgYSBzcGVjaWZpZWQgZmllbGRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gICAqIEByZXR1cm4ge09iamVjdCB8IG51bGx9IGl0ZW0gIEl0ZW0gY29udGFpbmluZyBtYXggdmFsdWUsIG9yIG51bGwgaWYgbm8gaXRlbXNcbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgICAgaXRlbUlkcyA9IE9iamVjdC5rZXlzKGRhdGEpLFxuICAgICAgICBtaW4gPSBudWxsLFxuICAgICAgICBtaW5GaWVsZCA9IG51bGwsXG4gICAgICAgIGksXG4gICAgICAgIGxlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1JZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBpZCA9IGl0ZW1JZHNbaV07XG4gICAgICB2YXIgaXRlbSA9IGRhdGFbaWRdO1xuICAgICAgdmFyIGl0ZW1GaWVsZCA9IGl0ZW1bZmllbGRdO1xuICAgICAgaWYgKGl0ZW1GaWVsZCAhPSBudWxsICYmICghbWluIHx8IGl0ZW1GaWVsZCA8IG1pbkZpZWxkKSkge1xuICAgICAgICBtaW4gPSBpdGVtO1xuICAgICAgICBtaW5GaWVsZCA9IGl0ZW1GaWVsZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWluO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kIGFsbCBkaXN0aW5jdCB2YWx1ZXMgb2YgYSBzcGVjaWZpZWQgZmllbGRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gICAqIEByZXR1cm4ge0FycmF5fSB2YWx1ZXMgIEFycmF5IGNvbnRhaW5pbmcgYWxsIGRpc3RpbmN0IHZhbHVlcy4gSWYgZGF0YSBpdGVtc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBkbyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIGZpZWxkIGFyZSBpZ25vcmVkLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgcmV0dXJuZWQgYXJyYXkgaXMgdW5vcmRlcmVkLlxuICAgKi9cbiAgRGF0YVNldC5wcm90b3R5cGUuZGlzdGluY3QgPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgdmFyIGl0ZW1JZHMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgdmFyIGZpZWxkVHlwZSA9IHRoaXMuX29wdGlvbnMudHlwZSAmJiB0aGlzLl9vcHRpb25zLnR5cGVbZmllbGRdIHx8IG51bGw7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgaSwgaiwgbGVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbUlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGlkID0gaXRlbUlkc1tpXTtcbiAgICAgIHZhciBpdGVtID0gZGF0YVtpZF07XG4gICAgICB2YXIgdmFsdWUgPSBpdGVtW2ZpZWxkXTtcbiAgICAgIHZhciBleGlzdHMgPSBmYWxzZTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgIGlmICh2YWx1ZXNbal0gPT0gdmFsdWUpIHtcbiAgICAgICAgICBleGlzdHMgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWV4aXN0cyAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlc1tjb3VudF0gPSB2YWx1ZTtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmllbGRUeXBlKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFsdWVzW2ldID0gdXRpbC5jb252ZXJ0KHZhbHVlc1tpXSwgZmllbGRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBzaW5nbGUgaXRlbS4gV2lsbCBmYWlsIHdoZW4gYW4gaXRlbSB3aXRoIHRoZSBzYW1lIGlkIGFscmVhZHkgZXhpc3RzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGlkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBEYXRhU2V0LnByb3RvdHlwZS5fYWRkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdmFyIGlkID0gaXRlbVt0aGlzLl9maWVsZElkXTtcblxuICAgIGlmIChpZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhpcyBpZCBpcyBhbHJlYWR5IHRha2VuXG4gICAgICBpZiAodGhpcy5fZGF0YVtpZF0pIHtcbiAgICAgICAgLy8gaXRlbSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgaXRlbTogaXRlbSB3aXRoIGlkICcgKyBpZCArICcgYWxyZWFkeSBleGlzdHMnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZ2VuZXJhdGUgYW4gaWRcbiAgICAgIGlkID0gdXRpbC5yYW5kb21VVUlEKCk7XG4gICAgICBpdGVtW3RoaXMuX2ZpZWxkSWRdID0gaWQ7XG4gICAgfVxuXG4gICAgdmFyIGQgPSB7fSxcbiAgICAgICAgZmllbGRzID0gT2JqZWN0LmtleXMoaXRlbSksXG4gICAgICAgIGksXG4gICAgICAgIGxlbjtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBmaWVsZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgIHZhciBmaWVsZFR5cGUgPSB0aGlzLl90eXBlW2ZpZWxkXTsgLy8gdHlwZSBtYXkgYmUgdW5kZWZpbmVkXG4gICAgICBkW2ZpZWxkXSA9IHV0aWwuY29udmVydChpdGVtW2ZpZWxkXSwgZmllbGRUeXBlKTtcbiAgICB9XG4gICAgdGhpcy5fZGF0YVtpZF0gPSBkO1xuICAgIHRoaXMubGVuZ3RoKys7XG5cbiAgICByZXR1cm4gaWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiBpdGVtLiBGaWVsZHMgY2FuIGJlIGNvbnZlcnRlZCB0byBhIHNwZWNpZmljIHR5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IFt0eXBlc10gIGZpZWxkIHR5cGVzIHRvIGNvbnZlcnRcbiAgICogQHJldHVybiB7T2JqZWN0IHwgbnVsbH0gaXRlbVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRGF0YVNldC5wcm90b3R5cGUuX2dldEl0ZW0gPSBmdW5jdGlvbiAoaWQsIHR5cGVzKSB7XG4gICAgdmFyIGZpZWxkLCB2YWx1ZSwgaSwgbGVuO1xuXG4gICAgLy8gZ2V0IHRoZSBpdGVtIGZyb20gdGhlIGRhdGFzZXRcbiAgICB2YXIgcmF3ID0gdGhpcy5fZGF0YVtpZF07XG4gICAgaWYgKCFyYXcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgdGhlIGl0ZW1zIGZpZWxkIHR5cGVzXG4gICAgdmFyIGNvbnZlcnRlZCA9IHt9LFxuICAgICAgICBmaWVsZHMgPSBPYmplY3Qua2V5cyhyYXcpO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBmaWVsZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgIHZhbHVlID0gcmF3W2ZpZWxkXTtcbiAgICAgICAgY29udmVydGVkW2ZpZWxkXSA9IHV0aWwuY29udmVydCh2YWx1ZSwgdHlwZXNbZmllbGRdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm8gZmllbGQgdHlwZXMgc3BlY2lmaWVkLCBubyBjb252ZXJ0aW5nIG5lZWRlZFxuICAgICAgZm9yIChpID0gMCwgbGVuID0gZmllbGRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICB2YWx1ZSA9IHJhd1tmaWVsZF07XG4gICAgICAgIGNvbnZlcnRlZFtmaWVsZF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRlZDtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGEgc2luZ2xlIGl0ZW06IG1lcmdlIHdpdGggZXhpc3RpbmcgaXRlbS5cbiAgICogV2lsbCBmYWlsIHdoZW4gdGhlIGl0ZW0gaGFzIG5vIGlkLCBvciB3aGVuIHRoZXJlIGRvZXMgbm90IGV4aXN0IGFuIGl0ZW1cbiAgICogd2l0aCB0aGUgc2FtZSBpZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICogQHJldHVybiB7U3RyaW5nfSBpZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRGF0YVNldC5wcm90b3R5cGUuX3VwZGF0ZUl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhciBpZCA9IGl0ZW1bdGhpcy5fZmllbGRJZF07XG4gICAgaWYgKGlkID09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXBkYXRlIGl0ZW06IGl0ZW0gaGFzIG5vIGlkIChpdGVtOiAnICsgSlNPTi5zdHJpbmdpZnkoaXRlbSkgKyAnKScpO1xuICAgIH1cbiAgICB2YXIgZCA9IHRoaXMuX2RhdGFbaWRdO1xuICAgIGlmICghZCkge1xuICAgICAgLy8gaXRlbSBkb2Vzbid0IGV4aXN0XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1cGRhdGUgaXRlbTogbm8gaXRlbSB3aXRoIGlkICcgKyBpZCArICcgZm91bmQnKTtcbiAgICB9XG5cbiAgICAvLyBtZXJnZSB3aXRoIGN1cnJlbnQgaXRlbVxuICAgIHZhciBmaWVsZHMgPSBPYmplY3Qua2V5cyhpdGVtKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZmllbGRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICB2YXIgZmllbGRUeXBlID0gdGhpcy5fdHlwZVtmaWVsZF07IC8vIHR5cGUgbWF5IGJlIHVuZGVmaW5lZFxuICAgICAgZFtmaWVsZF0gPSB1dGlsLmNvbnZlcnQoaXRlbVtmaWVsZF0sIGZpZWxkVHlwZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlkO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gRGF0YVNldDtcblxuLyoqKi8gfSxcbi8qIDEwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIEEgcXVldWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgICAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAtIGRlbGF5OiBudW1iZXIgICAgV2hlbiBwcm92aWRlZCwgdGhlIHF1ZXVlIHdpbGwgYmUgZmx1c2hlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvbWF0aWNhbGx5IGFmdGVyIGFuIGluYWN0aXZpdHkgb2YgdGhpcyBkZWxheVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBtaWxsaXNlY29uZHMuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWUgaXMgbnVsbC5cbiAgICogICAgICAgICAgICAtIG1heDogbnVtYmVyICAgICAgV2hlbiB0aGUgcXVldWUgZXhjZWVkcyB0aGUgZ2l2ZW4gbWF4aW11bSBudW1iZXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgZW50cmllcywgdGhlIHF1ZXVlIGlzIGZsdXNoZWQgYXV0b21hdGljYWxseS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB2YWx1ZSBvZiBtYXggaXMgSW5maW5pdHkuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gUXVldWUob3B0aW9ucykge1xuICAgIC8vIG9wdGlvbnNcbiAgICB0aGlzLmRlbGF5ID0gbnVsbDtcbiAgICB0aGlzLm1heCA9IEluZmluaXR5O1xuXG4gICAgLy8gcHJvcGVydGllc1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgdGhpcy5fdGltZW91dCA9IG51bGw7XG4gICAgdGhpcy5fZXh0ZW5kZWQgPSBudWxsO1xuXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY29uZmlndXJhdGlvbiBvZiB0aGUgcXVldWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgICAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAtIGRlbGF5OiBudW1iZXIgICAgV2hlbiBwcm92aWRlZCwgdGhlIHF1ZXVlIHdpbGwgYmUgZmx1c2hlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvbWF0aWNhbGx5IGFmdGVyIGFuIGluYWN0aXZpdHkgb2YgdGhpcyBkZWxheVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBtaWxsaXNlY29uZHMuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWUgaXMgbnVsbC5cbiAgICogICAgICAgICAgICAtIG1heDogbnVtYmVyICAgICAgV2hlbiB0aGUgcXVldWUgZXhjZWVkcyB0aGUgZ2l2ZW4gbWF4aW11bSBudW1iZXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgZW50cmllcywgdGhlIHF1ZXVlIGlzIGZsdXNoZWQgYXV0b21hdGljYWxseS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB2YWx1ZSBvZiBtYXggaXMgSW5maW5pdHkuXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBRdWV1ZS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuZGVsYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmRlbGF5ID0gb3B0aW9ucy5kZWxheTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5tYXggPSBvcHRpb25zLm1heDtcbiAgICB9XG5cbiAgICB0aGlzLl9mbHVzaElmTmVlZGVkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4dGVuZCBhbiBvYmplY3Qgd2l0aCBxdWV1aW5nIGZ1bmN0aW9uYWxpdHkuXG4gICAqIFRoZSBvYmplY3Qgd2lsbCBiZSBleHRlbmRlZCB3aXRoIGEgZnVuY3Rpb24gZmx1c2gsIGFuZCB0aGUgbWV0aG9kcyBwcm92aWRlZFxuICAgKiBpbiBvcHRpb25zLnJlcGxhY2Ugd2lsbCBiZSByZXBsYWNlZCB3aXRoIHF1ZXVlZCBvbmVzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICAgICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgLSByZXBsYWNlOiBBcnJheS48c3RyaW5nPlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBIGxpc3Qgd2l0aCBtZXRob2QgbmFtZXMgb2YgdGhlIG1ldGhvZHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb24gdGhlIG9iamVjdCB0byBiZSByZXBsYWNlZCB3aXRoIHF1ZXVlZCBvbmVzLlxuICAgKiAgICAgICAgICAgIC0gZGVsYXk6IG51bWJlciAgICBXaGVuIHByb3ZpZGVkLCB0aGUgcXVldWUgd2lsbCBiZSBmbHVzaGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgYW4gaW5hY3Rpdml0eSBvZiB0aGlzIGRlbGF5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIG1pbGxpc2Vjb25kcy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB2YWx1ZSBpcyBudWxsLlxuICAgKiAgICAgICAgICAgIC0gbWF4OiBudW1iZXIgICAgICBXaGVuIHRoZSBxdWV1ZSBleGNlZWRzIHRoZSBnaXZlbiBtYXhpbXVtIG51bWJlclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiBlbnRyaWVzLCB0aGUgcXVldWUgaXMgZmx1c2hlZCBhdXRvbWF0aWNhbGx5LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHZhbHVlIG9mIG1heCBpcyBJbmZpbml0eS5cbiAgICogQHJldHVybiB7UXVldWV9IFJldHVybnMgdGhlIGNyZWF0ZWQgcXVldWVcbiAgICovXG4gIFF1ZXVlLmV4dGVuZCA9IGZ1bmN0aW9uIChvYmplY3QsIG9wdGlvbnMpIHtcbiAgICB2YXIgcXVldWUgPSBuZXcgUXVldWUob3B0aW9ucyk7XG5cbiAgICBpZiAob2JqZWN0LmZsdXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGFyZ2V0IG9iamVjdCBhbHJlYWR5IGhhcyBhIHByb3BlcnR5IGZsdXNoJyk7XG4gICAgfVxuICAgIG9iamVjdC5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHF1ZXVlLmZsdXNoKCk7XG4gICAgfTtcblxuICAgIHZhciBtZXRob2RzID0gW3tcbiAgICAgIG5hbWU6ICdmbHVzaCcsXG4gICAgICBvcmlnaW5hbDogdW5kZWZpbmVkXG4gICAgfV07XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcGxhY2UpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5yZXBsYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lID0gb3B0aW9ucy5yZXBsYWNlW2ldO1xuICAgICAgICBtZXRob2RzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgb3JpZ2luYWw6IG9iamVjdFtuYW1lXVxuICAgICAgICB9KTtcbiAgICAgICAgcXVldWUucmVwbGFjZShvYmplY3QsIG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHF1ZXVlLl9leHRlbmRlZCA9IHtcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgbWV0aG9kczogbWV0aG9kc1xuICAgIH07XG5cbiAgICByZXR1cm4gcXVldWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIHF1ZXVlLiBUaGUgcXVldWUgd2lsbCBmaXJzdCBmbHVzaCBhbGwgcXVldWVkIGFjdGlvbnMsIGFuZCBpblxuICAgKiBjYXNlIGl0IGhhcyBleHRlbmRlZCBhbiBvYmplY3QsIHdpbGwgcmVzdG9yZSB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgKi9cbiAgUXVldWUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mbHVzaCgpO1xuXG4gICAgaWYgKHRoaXMuX2V4dGVuZGVkKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gdGhpcy5fZXh0ZW5kZWQub2JqZWN0O1xuICAgICAgdmFyIG1ldGhvZHMgPSB0aGlzLl9leHRlbmRlZC5tZXRob2RzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBtZXRob2RzW2ldO1xuICAgICAgICBpZiAobWV0aG9kLm9yaWdpbmFsKSB7XG4gICAgICAgICAgb2JqZWN0W21ldGhvZC5uYW1lXSA9IG1ldGhvZC5vcmlnaW5hbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgb2JqZWN0W21ldGhvZC5uYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fZXh0ZW5kZWQgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVwbGFjZSBhIG1ldGhvZCBvbiBhbiBvYmplY3Qgd2l0aCBhIHF1ZXVlZCB2ZXJzaW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgICBPYmplY3QgaGF2aW5nIHRoZSBtZXRob2RcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCAgIFRoZSBtZXRob2QgbmFtZVxuICAgKi9cbiAgUXVldWUucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiAob2JqZWN0LCBtZXRob2QpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBvcmlnaW5hbCA9IG9iamVjdFttZXRob2RdO1xuICAgIGlmICghb3JpZ2luYWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kICcgKyBtZXRob2QgKyAnIHVuZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIG9iamVjdFttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gY3JlYXRlIGFuIEFycmF5IHdpdGggdGhlIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCB0aGlzIGNhbGwgdG8gdGhlIHF1ZXVlXG4gICAgICBtZS5xdWV1ZSh7XG4gICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgIGZuOiBvcmlnaW5hbCxcbiAgICAgICAgY29udGV4dDogdGhpc1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogUXVldWUgYSBjYWxsXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24gfCB7Zm46IGZ1bmN0aW9uLCBhcmdzOiBBcnJheX0gfCB7Zm46IGZ1bmN0aW9uLCBhcmdzOiBBcnJheSwgY29udGV4dDogT2JqZWN0fX0gZW50cnlcbiAgICovXG4gIFF1ZXVlLnByb3RvdHlwZS5xdWV1ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX3F1ZXVlLnB1c2goeyBmbjogZW50cnkgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3F1ZXVlLnB1c2goZW50cnkpO1xuICAgIH1cblxuICAgIHRoaXMuX2ZsdXNoSWZOZWVkZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgcXVldWUgbmVlZHMgdG8gYmUgZmx1c2hlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUXVldWUucHJvdG90eXBlLl9mbHVzaElmTmVlZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGZsdXNoIHdoZW4gdGhlIG1heGltdW0gaXMgZXhjZWVkZWQuXG4gICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA+IHRoaXMubWF4KSB7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuXG4gICAgLy8gZmx1c2ggYWZ0ZXIgYSBwZXJpb2Qgb2YgaW5hY3Rpdml0eSB3aGVuIGEgZGVsYXkgaXMgY29uZmlndXJlZFxuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPiAwICYmIHR5cGVvZiB0aGlzLmRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUuZmx1c2goKTtcbiAgICAgIH0sIHRoaXMuZGVsYXkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRmx1c2ggYWxsIHF1ZXVlZCBjYWxsc1xuICAgKi9cbiAgUXVldWUucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHdoaWxlICh0aGlzLl9xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgZW50cnkgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuICAgICAgZW50cnkuZm4uYXBwbHkoZW50cnkuY29udGV4dCB8fCBlbnRyeS5mbiwgZW50cnkuYXJncyB8fCBbXSk7XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gUXVldWU7XG5cbi8qKiovIH0sXG4vKiAxMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIERhdGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG4gIC8qKlxuICAgKiBEYXRhVmlld1xuICAgKlxuICAgKiBhIGRhdGF2aWV3IG9mZmVycyBhIGZpbHRlcmVkIHZpZXcgb24gYSBkYXRhc2V0IG9yIGFuIG90aGVyIGRhdGF2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0ge0RhdGFTZXQgfCBEYXRhVmlld30gZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgQXZhaWxhYmxlIG9wdGlvbnM6IHNlZSBtZXRob2QgZ2V0XG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvciBEYXRhVmlld1xuICAgKi9cbiAgZnVuY3Rpb24gRGF0YVZpZXcoZGF0YSwgb3B0aW9ucykge1xuICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgIHRoaXMuX2lkcyA9IHt9OyAvLyBpZHMgb2YgdGhlIGl0ZW1zIGN1cnJlbnRseSBpbiBtZW1vcnkgKGp1c3QgY29udGFpbnMgYSBib29sZWFuIHRydWUpXG4gICAgdGhpcy5sZW5ndGggPSAwOyAvLyBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIERhdGFWaWV3XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5fZmllbGRJZCA9ICdpZCc7IC8vIG5hbWUgb2YgdGhlIGZpZWxkIGNvbnRhaW5pbmcgaWRcbiAgICB0aGlzLl9zdWJzY3JpYmVycyA9IHt9OyAvLyBldmVudCBzdWJzY3JpYmVyc1xuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgbWUuX29uRXZlbnQuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0RGF0YShkYXRhKTtcbiAgfVxuXG4gIC8vIFRPRE86IGltcGxlbWVudCBhIGZ1bmN0aW9uIC5jb25maWcoKSB0byBkeW5hbWljYWxseSB1cGRhdGUgdGhpbmdzIGxpa2UgY29uZmlndXJlZCBmaWx0ZXJcbiAgLy8gYW5kIHRyaWdnZXIgY2hhbmdlcyBhY2NvcmRpbmdseVxuXG4gIC8qKlxuICAgKiBTZXQgYSBkYXRhIHNvdXJjZSBmb3IgdGhlIHZpZXdcbiAgICogQHBhcmFtIHtEYXRhU2V0IHwgRGF0YVZpZXd9IGRhdGFcbiAgICovXG4gIERhdGFWaWV3LnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgaWRzLCBpZCwgaSwgbGVuLCBpdGVtcztcblxuICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICAvLyB1bnN1YnNjcmliZSBmcm9tIGN1cnJlbnQgZGF0YXNldFxuICAgICAgaWYgKHRoaXMuX2RhdGEub2ZmKSB7XG4gICAgICAgIHRoaXMuX2RhdGEub2ZmKCcqJywgdGhpcy5saXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIC8vIHRyaWdnZXIgYSByZW1vdmUgb2YgYWxsIGl0ZW1zIGluIG1lbW9yeVxuICAgICAgaWRzID0gdGhpcy5fZGF0YS5nZXRJZHMoeyBmaWx0ZXI6IHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5maWx0ZXIgfSk7XG4gICAgICBpdGVtcyA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaXRlbXMucHVzaCh0aGlzLl9kYXRhLl9kYXRhW2lkc1tpXV0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pZHMgPSB7fTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuX3RyaWdnZXIoJ3JlbW92ZScsIHsgaXRlbXM6IGlkcywgb2xkRGF0YTogaXRlbXMgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG5cbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgLy8gdXBkYXRlIGZpZWxkSWRcbiAgICAgIHRoaXMuX2ZpZWxkSWQgPSB0aGlzLl9vcHRpb25zLmZpZWxkSWQgfHwgdGhpcy5fZGF0YSAmJiB0aGlzLl9kYXRhLm9wdGlvbnMgJiYgdGhpcy5fZGF0YS5vcHRpb25zLmZpZWxkSWQgfHwgJ2lkJztcblxuICAgICAgLy8gdHJpZ2dlciBhbiBhZGQgb2YgYWxsIGFkZGVkIGl0ZW1zXG4gICAgICBpZHMgPSB0aGlzLl9kYXRhLmdldElkcyh7IGZpbHRlcjogdGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLmZpbHRlciB9KTtcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZCA9IGlkc1tpXTtcbiAgICAgICAgdGhpcy5faWRzW2lkXSA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLmxlbmd0aCA9IGlkcy5sZW5ndGg7XG4gICAgICB0aGlzLl90cmlnZ2VyKCdhZGQnLCB7IGl0ZW1zOiBpZHMgfSk7XG5cbiAgICAgIC8vIHN1YnNjcmliZSB0byBuZXcgZGF0YXNldFxuICAgICAgaWYgKHRoaXMuX2RhdGEub24pIHtcbiAgICAgICAgdGhpcy5fZGF0YS5vbignKicsIHRoaXMubGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVmcmVzaCB0aGUgRGF0YVZpZXcuIFVzZWZ1bCB3aGVuIHRoZSBEYXRhVmlldyBoYXMgYSBmaWx0ZXIgZnVuY3Rpb25cbiAgICogY29udGFpbmluZyBhIHZhcmlhYmxlIHBhcmFtZXRlci5cbiAgICovXG4gIERhdGFWaWV3LnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZCwgaSwgbGVuO1xuICAgIHZhciBpZHMgPSB0aGlzLl9kYXRhLmdldElkcyh7IGZpbHRlcjogdGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLmZpbHRlciB9KSxcbiAgICAgICAgb2xkSWRzID0gT2JqZWN0LmtleXModGhpcy5faWRzKSxcbiAgICAgICAgbmV3SWRzID0ge30sXG4gICAgICAgIGFkZGVkSWRzID0gW10sXG4gICAgICAgIHJlbW92ZWRJZHMgPSBbXSxcbiAgICAgICAgcmVtb3ZlZEl0ZW1zID0gW107XG5cbiAgICAvLyBjaGVjayBmb3IgYWRkaXRpb25zXG4gICAgZm9yIChpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZCA9IGlkc1tpXTtcbiAgICAgIG5ld0lkc1tpZF0gPSB0cnVlO1xuICAgICAgaWYgKCF0aGlzLl9pZHNbaWRdKSB7XG4gICAgICAgIGFkZGVkSWRzLnB1c2goaWQpO1xuICAgICAgICB0aGlzLl9pZHNbaWRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgcmVtb3ZhbHNcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBvbGRJZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlkID0gb2xkSWRzW2ldO1xuICAgICAgaWYgKCFuZXdJZHNbaWRdKSB7XG4gICAgICAgIHJlbW92ZWRJZHMucHVzaChpZCk7XG4gICAgICAgIHJlbW92ZWRJdGVtcy5wdXNoKHRoaXMuX2RhdGFbaWRdKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2lkc1tpZF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggKz0gYWRkZWRJZHMubGVuZ3RoIC0gcmVtb3ZlZElkcy5sZW5ndGg7XG5cbiAgICAvLyB0cmlnZ2VyIGV2ZW50c1xuICAgIGlmIChhZGRlZElkcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3RyaWdnZXIoJ2FkZCcsIHsgaXRlbXM6IGFkZGVkSWRzIH0pO1xuICAgIH1cbiAgICBpZiAocmVtb3ZlZElkcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3RyaWdnZXIoJ3JlbW92ZScsIHsgaXRlbXM6IHJlbW92ZWRJZHMsIG9sZERhdGE6IHJlbW92ZWRJdGVtcyB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBkYXRhIGZyb20gdGhlIGRhdGEgdmlld1xuICAgKlxuICAgKiBVc2FnZTpcbiAgICpcbiAgICogICAgIGdldCgpXG4gICAqICAgICBnZXQob3B0aW9uczogT2JqZWN0KVxuICAgKiAgICAgZ2V0KG9wdGlvbnM6IE9iamVjdCwgZGF0YTogQXJyYXkgfCBEYXRhVGFibGUpXG4gICAqXG4gICAqICAgICBnZXQoaWQ6IE51bWJlcilcbiAgICogICAgIGdldChpZDogTnVtYmVyLCBvcHRpb25zOiBPYmplY3QpXG4gICAqICAgICBnZXQoaWQ6IE51bWJlciwgb3B0aW9uczogT2JqZWN0LCBkYXRhOiBBcnJheSB8IERhdGFUYWJsZSlcbiAgICpcbiAgICogICAgIGdldChpZHM6IE51bWJlcltdKVxuICAgKiAgICAgZ2V0KGlkczogTnVtYmVyW10sIG9wdGlvbnM6IE9iamVjdClcbiAgICogICAgIGdldChpZHM6IE51bWJlcltdLCBvcHRpb25zOiBPYmplY3QsIGRhdGE6IEFycmF5IHwgRGF0YVRhYmxlKVxuICAgKlxuICAgKiBXaGVyZTpcbiAgICpcbiAgICoge051bWJlciB8IFN0cmluZ30gaWQgICAgICAgICBUaGUgaWQgb2YgYW4gaXRlbVxuICAgKiB7TnVtYmVyW10gfCBTdHJpbmd7fX0gaWRzICAgIEFuIGFycmF5IHdpdGggaWRzIG9mIGl0ZW1zXG4gICAqIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICAgICAgQW4gT2JqZWN0IHdpdGggb3B0aW9ucy4gQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gW3R5cGVdIFR5cGUgb2YgZGF0YSB0byBiZSByZXR1cm5lZC4gQ2FuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlICdEYXRhVGFibGUnIG9yICdBcnJheScgKGRlZmF1bHQpXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBbY29udmVydF1cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nW119IFtmaWVsZHNdIGZpZWxkIG5hbWVzIHRvIGJlIHJldHVybmVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Z1bmN0aW9ufSBbZmlsdGVyXSBmaWx0ZXIgaXRlbXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgZnVuY3Rpb259IFtvcmRlcl0gT3JkZXIgdGhlIGl0ZW1zIGJ5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAgICoge0FycmF5IHwgRGF0YVRhYmxlfSBbZGF0YV0gICBJZiBwcm92aWRlZCwgaXRlbXMgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXkgb3IgdGFibGUuIFJlcXVpcmVkIGluIGNhc2Ugb2YgR29vZ2xlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGF0YVRhYmxlLlxuICAgKiBAcGFyYW0gYXJnc1xuICAgKi9cbiAgRGF0YVZpZXcucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgdmFyIG1lID0gdGhpcztcblxuICAgIC8vIHBhcnNlIHRoZSBhcmd1bWVudHNcbiAgICB2YXIgaWRzLCBvcHRpb25zLCBkYXRhO1xuICAgIHZhciBmaXJzdFR5cGUgPSB1dGlsLmdldFR5cGUoYXJndW1lbnRzWzBdKTtcbiAgICBpZiAoZmlyc3RUeXBlID09ICdTdHJpbmcnIHx8IGZpcnN0VHlwZSA9PSAnTnVtYmVyJyB8fCBmaXJzdFR5cGUgPT0gJ0FycmF5Jykge1xuICAgICAgLy8gZ2V0KGlkKHMpIFssIG9wdGlvbnNdIFssIGRhdGFdKVxuICAgICAgaWRzID0gYXJndW1lbnRzWzBdOyAvLyBjYW4gYmUgYSBzaW5nbGUgaWQgb3IgYW4gYXJyYXkgd2l0aCBpZHNcbiAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMV07XG4gICAgICBkYXRhID0gYXJndW1lbnRzWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBnZXQoWywgb3B0aW9uc10gWywgZGF0YV0pXG4gICAgICBvcHRpb25zID0gYXJndW1lbnRzWzBdO1xuICAgICAgZGF0YSA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG5cbiAgICAvLyBleHRlbmQgdGhlIG9wdGlvbnMgd2l0aCB0aGUgZGVmYXVsdCBvcHRpb25zIGFuZCBwcm92aWRlZCBvcHRpb25zXG4gICAgdmFyIHZpZXdPcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuX29wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgLy8gY3JlYXRlIGEgY29tYmluZWQgZmlsdGVyIG1ldGhvZCB3aGVuIG5lZWRlZFxuICAgIGlmICh0aGlzLl9vcHRpb25zLmZpbHRlciAmJiBvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyKSB7XG4gICAgICB2aWV3T3B0aW9ucy5maWx0ZXIgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gbWUuX29wdGlvbnMuZmlsdGVyKGl0ZW0pICYmIG9wdGlvbnMuZmlsdGVyKGl0ZW0pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBidWlsZCB1cCB0aGUgY2FsbCB0byB0aGUgbGlua2VkIGRhdGEgc2V0XG4gICAgdmFyIGdldEFyZ3VtZW50cyA9IFtdO1xuICAgIGlmIChpZHMgIT0gdW5kZWZpbmVkKSB7XG4gICAgICBnZXRBcmd1bWVudHMucHVzaChpZHMpO1xuICAgIH1cbiAgICBnZXRBcmd1bWVudHMucHVzaCh2aWV3T3B0aW9ucyk7XG4gICAgZ2V0QXJndW1lbnRzLnB1c2goZGF0YSk7XG5cbiAgICByZXR1cm4gdGhpcy5fZGF0YSAmJiB0aGlzLl9kYXRhLmdldC5hcHBseSh0aGlzLl9kYXRhLCBnZXRBcmd1bWVudHMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgaWRzIG9mIGFsbCBpdGVtcyBvciBmcm9tIGEgZmlsdGVyZWQgc2V0IG9mIGl0ZW1zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgIEFuIE9iamVjdCB3aXRoIG9wdGlvbnMuIEF2YWlsYWJsZSBvcHRpb25zOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtmdW5jdGlvbn0gW2ZpbHRlcl0gZmlsdGVyIGl0ZW1zXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IGZ1bmN0aW9ufSBbb3JkZXJdIE9yZGVyIHRoZSBpdGVtcyBieVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge0FycmF5fSBpZHNcbiAgICovXG4gIERhdGFWaWV3LnByb3RvdHlwZS5nZXRJZHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBpZHM7XG5cbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgdmFyIGRlZmF1bHRGaWx0ZXIgPSB0aGlzLl9vcHRpb25zLmZpbHRlcjtcbiAgICAgIHZhciBmaWx0ZXI7XG5cbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyKSB7XG4gICAgICAgIGlmIChkZWZhdWx0RmlsdGVyKSB7XG4gICAgICAgICAgZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0RmlsdGVyKGl0ZW0pICYmIG9wdGlvbnMuZmlsdGVyKGl0ZW0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXI7XG4gICAgICB9XG5cbiAgICAgIGlkcyA9IHRoaXMuX2RhdGEuZ2V0SWRzKHtcbiAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgIG9yZGVyOiBvcHRpb25zICYmIG9wdGlvbnMub3JkZXJcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZHMgPSBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaWRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYXAgZXZlcnkgaXRlbSBpbiB0aGUgZGF0YXNldC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IFt0eXBlXVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmdbXX0gW2ZpZWxkc10gZmlsdGVyIGZpZWxkc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtmdW5jdGlvbn0gW2ZpbHRlcl0gZmlsdGVyIGl0ZW1zXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IGZ1bmN0aW9ufSBbb3JkZXJdIE9yZGVyIHRoZSBpdGVtcyBieVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge09iamVjdFtdfSBtYXBwZWRJdGVtc1xuICAgKi9cbiAgRGF0YVZpZXcucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIHZhciBtYXBwZWRJdGVtcyA9IFtdO1xuICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICB2YXIgZGVmYXVsdEZpbHRlciA9IHRoaXMuX29wdGlvbnMuZmlsdGVyO1xuICAgICAgdmFyIGZpbHRlcjtcblxuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRGaWx0ZXIpIHtcbiAgICAgICAgICBmaWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRGaWx0ZXIoaXRlbSkgJiYgb3B0aW9ucy5maWx0ZXIoaXRlbSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlsdGVyID0gZGVmYXVsdEZpbHRlcjtcbiAgICAgIH1cblxuICAgICAgbWFwcGVkSXRlbXMgPSB0aGlzLl9kYXRhLm1hcChjYWxsYmFjaywge1xuICAgICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgICAgb3JkZXI6IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlclxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcHBlZEl0ZW1zID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcHBlZEl0ZW1zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIERhdGFTZXQgdG8gd2hpY2ggdGhpcyBEYXRhVmlldyBpcyBjb25uZWN0ZWQuIEluIGNhc2UgdGhlcmUgaXMgYSBjaGFpblxuICAgKiBvZiBtdWx0aXBsZSBEYXRhVmlld3MsIHRoZSByb290IERhdGFTZXQgb2YgdGhpcyBjaGFpbiBpcyByZXR1cm5lZC5cbiAgICogQHJldHVybiB7RGF0YVNldH0gZGF0YVNldFxuICAgKi9cbiAgRGF0YVZpZXcucHJvdG90eXBlLmdldERhdGFTZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGFTZXQgPSB0aGlzO1xuICAgIHdoaWxlIChkYXRhU2V0IGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICAgIGRhdGFTZXQgPSBkYXRhU2V0Ll9kYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YVNldCB8fCBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFdmVudCBsaXN0ZW5lci4gV2lsbCBwcm9wYWdhdGUgYWxsIGV2ZW50cyBmcm9tIHRoZSBjb25uZWN0ZWQgZGF0YSBzZXQgdG9cbiAgICogdGhlIHN1YnNjcmliZXJzIG9mIHRoZSBEYXRhVmlldywgYnV0IHdpbGwgZmlsdGVyIHRoZSBpdGVtcyBhbmQgb25seSB0cmlnZ2VyXG4gICAqIHdoZW4gdGhlcmUgYXJlIGNoYW5nZXMgaW4gdGhlIGZpbHRlcmVkIGRhdGEgc2V0LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3QgfCBudWxsfSBwYXJhbXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNlbmRlcklkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBEYXRhVmlldy5wcm90b3R5cGUuX29uRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICB2YXIgaSwgbGVuLCBpZCwgaXRlbTtcbiAgICB2YXIgaWRzID0gcGFyYW1zICYmIHBhcmFtcy5pdGVtcztcbiAgICB2YXIgYWRkZWRJZHMgPSBbXSxcbiAgICAgICAgdXBkYXRlZElkcyA9IFtdLFxuICAgICAgICByZW1vdmVkSWRzID0gW10sXG4gICAgICAgIG9sZEl0ZW1zID0gW10sXG4gICAgICAgIHVwZGF0ZWRJdGVtcyA9IFtdLFxuICAgICAgICByZW1vdmVkSXRlbXMgPSBbXTtcblxuICAgIGlmIChpZHMgJiYgdGhpcy5fZGF0YSkge1xuICAgICAgc3dpdGNoIChldmVudCkge1xuICAgICAgICBjYXNlICdhZGQnOlxuICAgICAgICAgIC8vIGZpbHRlciB0aGUgaWRzIG9mIHRoZSBhZGRlZCBpdGVtc1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICBpdGVtID0gdGhpcy5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgdGhpcy5faWRzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICAgIGFkZGVkSWRzLnB1c2goaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBldmVudCBmcm9tIHRoZSB2aWV3cyB2aWV3cG9pbnQ6IGFuIHVwZGF0ZWRcbiAgICAgICAgICAvLyBpdGVtIGNhbiBiZSBhZGRlZCwgdXBkYXRlZCwgb3IgcmVtb3ZlZCBmcm9tIHRoaXMgdmlldy5cbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgaXRlbSA9IHRoaXMuZ2V0KGlkKTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2lkc1tpZF0pIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVkSWRzLnB1c2goaWQpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRJdGVtcy5wdXNoKHBhcmFtcy5kYXRhW2ldKTtcbiAgICAgICAgICAgICAgICBvbGRJdGVtcy5wdXNoKHBhcmFtcy5vbGREYXRhW2ldKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pZHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhZGRlZElkcy5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2lkc1tpZF0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5faWRzW2lkXTtcbiAgICAgICAgICAgICAgICByZW1vdmVkSWRzLnB1c2goaWQpO1xuICAgICAgICAgICAgICAgIHJlbW92ZWRJdGVtcy5wdXNoKHBhcmFtcy5vbGREYXRhW2ldKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBub3RoaW5nIGludGVyZXN0aW5nIGZvciBtZSA6LShcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JlbW92ZSc6XG4gICAgICAgICAgLy8gZmlsdGVyIHRoZSBpZHMgb2YgdGhlIHJlbW92ZWQgaXRlbXNcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lkc1tpZF0pIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2lkc1tpZF07XG4gICAgICAgICAgICAgIHJlbW92ZWRJZHMucHVzaChpZCk7XG4gICAgICAgICAgICAgIHJlbW92ZWRJdGVtcy5wdXNoKHBhcmFtcy5vbGREYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggKz0gYWRkZWRJZHMubGVuZ3RoIC0gcmVtb3ZlZElkcy5sZW5ndGg7XG5cbiAgICAgIGlmIChhZGRlZElkcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlcignYWRkJywgeyBpdGVtczogYWRkZWRJZHMgfSwgc2VuZGVySWQpO1xuICAgICAgfVxuICAgICAgaWYgKHVwZGF0ZWRJZHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3RyaWdnZXIoJ3VwZGF0ZScsIHsgaXRlbXM6IHVwZGF0ZWRJZHMsIG9sZERhdGE6IG9sZEl0ZW1zLCBkYXRhOiB1cGRhdGVkSXRlbXMgfSwgc2VuZGVySWQpO1xuICAgICAgfVxuICAgICAgaWYgKHJlbW92ZWRJZHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3RyaWdnZXIoJ3JlbW92ZScsIHsgaXRlbXM6IHJlbW92ZWRJZHMsIG9sZERhdGE6IHJlbW92ZWRJdGVtcyB9LCBzZW5kZXJJZCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIGNvcHkgc3Vic2NyaXB0aW9uIGZ1bmN0aW9uYWxpdHkgZnJvbSBEYXRhU2V0XG4gIERhdGFWaWV3LnByb3RvdHlwZS5vbiA9IERhdGFTZXQucHJvdG90eXBlLm9uO1xuICBEYXRhVmlldy5wcm90b3R5cGUub2ZmID0gRGF0YVNldC5wcm90b3R5cGUub2ZmO1xuICBEYXRhVmlldy5wcm90b3R5cGUuX3RyaWdnZXIgPSBEYXRhU2V0LnByb3RvdHlwZS5fdHJpZ2dlcjtcblxuICAvLyBUT0RPOiBtYWtlIHRoZXNlIGZ1bmN0aW9ucyBkZXByZWNhdGVkIChyZXBsYWNlZCB3aXRoIGBvbmAgYW5kIGBvZmZgIHNpbmNlIHZlcnNpb24gMC41KVxuICBEYXRhVmlldy5wcm90b3R5cGUuc3Vic2NyaWJlID0gRGF0YVZpZXcucHJvdG90eXBlLm9uO1xuICBEYXRhVmlldy5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBEYXRhVmlldy5wcm90b3R5cGUub2ZmO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gRGF0YVZpZXc7XG5cbi8qKiovIH0sXG4vKiAxMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7dmFyIERhdGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuICB2YXIgRGF0YVZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuICB2YXIgUG9pbnQzZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuICB2YXIgUG9pbnQyZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuICB2YXIgQ2FtZXJhID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG4gIHZhciBGaWx0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcbiAgdmFyIFNsaWRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuICB2YXIgU3RlcE51bWJlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuICB2YXIgUmFuZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcbiAgdmFyIFNldHRpbmdzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5cbiAgLy8vIGVudW1lcmF0ZSB0aGUgYXZhaWxhYmxlIHN0eWxlc1xuICBHcmFwaDNkLlNUWUxFID0gU2V0dGluZ3MuU1RZTEU7XG5cbiAgLyoqXG4gICAqIEZvbGxvd2luZyBsYWJlbCBpcyB1c2VkIGluIHRoZSBzZXR0aW5ncyB0byBkZXNjcmliZSB2YWx1ZXMgd2hpY2ggc2hvdWxkIGJlXG4gICAqIGRldGVybWluZWQgYnkgdGhlIGNvZGUgd2hpbGUgcnVubmluZywgZnJvbSB0aGUgY3VycmVudCBkYXRhIGFuZCBncmFwaCBzdHlsZS5cbiAgICogXG4gICAqIFVzaW5nICd1bmRlZmluZWQnIGRpcmVjdGx5IGFjaGlldmVzIHRoZSBzYW1lIHRoaW5nLCBidXQgdGhpcyBpcyBtb3JlXG4gICAqIGRlc2NyaXB0aXZlIGJ5IGRlc2NyaWJpbmcgdGhlIGludGVudC5cbiAgICovXG4gIHZhciBhdXRvQnlEZWZhdWx0ID0gdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHZhbHVlcyBmb3Igb3B0aW9uIHNldHRpbmdzLlxuICAgKlxuICAgKiBUaGVzZSBhcmUgdGhlIHZhbHVlcyB1c2VkIHdoZW4gYSBHcmFwaDNkIGluc3RhbmNlIGlzIGluaXRpYWxpemVkIHdpdGhvdXRcbiAgICogY3VzdG9tIHNldHRpbmdzLlxuICAgKlxuICAgKiBJZiBhIGZpZWxkIGlzIG5vdCBpbiB0aGlzIGxpc3QsIGEgZGVmYXVsdCB2YWx1ZSBvZiAnYXV0b0J5RGVmYXVsdCcgaXMgYXNzdW1lZCxcbiAgICogd2hpY2ggaXMganVzdCBhbiBhbGlhcyBmb3IgJ3VuZGVmaW5lZCcuXG4gICAqL1xuICB2YXIgREVGQVVMVFMgPSB7XG4gICAgd2lkdGg6ICc0MDBweCcsXG4gICAgaGVpZ2h0OiAnNDAwcHgnLFxuICAgIGZpbHRlckxhYmVsOiAndGltZScsXG4gICAgbGVnZW5kTGFiZWw6ICd2YWx1ZScsXG4gICAgeExhYmVsOiAneCcsXG4gICAgeUxhYmVsOiAneScsXG4gICAgekxhYmVsOiAneicsXG4gICAgeFZhbHVlTGFiZWw6IGZ1bmN0aW9uIHhWYWx1ZUxhYmVsKHYpIHtcbiAgICAgIHJldHVybiB2O1xuICAgIH0sXG4gICAgeVZhbHVlTGFiZWw6IGZ1bmN0aW9uIHlWYWx1ZUxhYmVsKHYpIHtcbiAgICAgIHJldHVybiB2O1xuICAgIH0sXG4gICAgelZhbHVlTGFiZWw6IGZ1bmN0aW9uIHpWYWx1ZUxhYmVsKHYpIHtcbiAgICAgIHJldHVybiB2O1xuICAgIH0sXG4gICAgc2hvd0dyaWQ6IHRydWUsXG4gICAgc2hvd1BlcnNwZWN0aXZlOiB0cnVlLFxuICAgIHNob3dTaGFkb3c6IGZhbHNlLFxuICAgIGtlZXBBc3BlY3RSYXRpbzogdHJ1ZSxcbiAgICB2ZXJ0aWNhbFJhdGlvOiAwLjUsIC8vIDAuMSB0byAxLjAsIHdoZXJlIDEuMCByZXN1bHRzIGluIGEgJ2N1YmUnXG4gICAgZG90U2l6ZVJhdGlvOiAwLjAyLCAvLyBzaXplIG9mIHRoZSBkb3RzIGFzIGEgZnJhY3Rpb24gb2YgdGhlIGdyYXBoIHdpZHRoXG5cbiAgICBzaG93QW5pbWF0aW9uQ29udHJvbHM6IGF1dG9CeURlZmF1bHQsXG4gICAgYW5pbWF0aW9uSW50ZXJ2YWw6IDEwMDAsIC8vIG1pbGxpc2Vjb25kc1xuICAgIGFuaW1hdGlvblByZWxvYWQ6IGZhbHNlLFxuICAgIGFuaW1hdGlvbkF1dG9TdGFydDogYXV0b0J5RGVmYXVsdCxcblxuICAgIGF4aXNDb2xvcjogJyM0RDRENEQnLFxuICAgIGdyaWRDb2xvcjogJyNEM0QzRDMnLFxuICAgIHhDZW50ZXI6ICc1NSUnLFxuICAgIHlDZW50ZXI6ICc1MCUnLFxuXG4gICAgc3R5bGU6IEdyYXBoM2QuU1RZTEUuRE9ULFxuICAgIHRvb2x0aXA6IGZhbHNlLFxuICAgIHNob3dMZWdlbmQ6IGF1dG9CeURlZmF1bHQsIC8vIGRldGVybWluZWQgYnkgZ3JhcGggc3R5bGVcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGF1dG9CeURlZmF1bHQsXG5cbiAgICBkYXRhQ29sb3I6IHtcbiAgICAgIGZpbGw6ICcjN0RDMUZGJyxcbiAgICAgIHN0cm9rZTogJyMzMjY3RDInLFxuICAgICAgc3Ryb2tlV2lkdGg6IDEgLy8gcHhcbiAgICB9LFxuXG4gICAgY2FtZXJhUG9zaXRpb246IHtcbiAgICAgIGhvcml6b250YWw6IDEuMCxcbiAgICAgIHZlcnRpY2FsOiAwLjUsXG4gICAgICBkaXN0YW5jZTogMS43XG4gICAgfSxcblxuICAgIHhCYXJXaWR0aDogYXV0b0J5RGVmYXVsdCxcbiAgICB5QmFyV2lkdGg6IGF1dG9CeURlZmF1bHQsXG4gICAgdmFsdWVNaW46IGF1dG9CeURlZmF1bHQsXG4gICAgdmFsdWVNYXg6IGF1dG9CeURlZmF1bHQsXG4gICAgeE1pbjogYXV0b0J5RGVmYXVsdCxcbiAgICB4TWF4OiBhdXRvQnlEZWZhdWx0LFxuICAgIHhTdGVwOiBhdXRvQnlEZWZhdWx0LFxuICAgIHlNaW46IGF1dG9CeURlZmF1bHQsXG4gICAgeU1heDogYXV0b0J5RGVmYXVsdCxcbiAgICB5U3RlcDogYXV0b0J5RGVmYXVsdCxcbiAgICB6TWluOiBhdXRvQnlEZWZhdWx0LFxuICAgIHpNYXg6IGF1dG9CeURlZmF1bHQsXG4gICAgelN0ZXA6IGF1dG9CeURlZmF1bHRcbiAgfTtcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBDbGFzcyBHcmFwaDNkXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yIEdyYXBoM2RcbiAgICogR3JhcGgzZCBkaXNwbGF5cyBkYXRhIGluIDNkLlxuICAgKlxuICAgKiBHcmFwaDNkIGlzIGRldmVsb3BlZCBpbiBqYXZhc2NyaXB0IGFzIGEgR29vZ2xlIFZpc3VhbGl6YXRpb24gQ2hhcnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyICAgVGhlIERPTSBlbGVtZW50IGluIHdoaWNoIHRoZSBHcmFwaDNkIHdpbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBjcmVhdGVkLiBOb3JtYWxseSBhIGRpdiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0RhdGFTZXQgfCBEYXRhVmlldyB8IEFycmF5fSBbZGF0YV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKi9cbiAgZnVuY3Rpb24gR3JhcGgzZChjb250YWluZXIsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgR3JhcGgzZCkpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIHZhcmlhYmxlcyBhbmQgc2V0IGRlZmF1bHQgdmFsdWVzXG4gICAgdGhpcy5jb250YWluZXJFbGVtZW50ID0gY29udGFpbmVyO1xuXG4gICAgdGhpcy5kYXRhVGFibGUgPSBudWxsOyAvLyBUaGUgb3JpZ2luYWwgZGF0YSB0YWJsZVxuICAgIHRoaXMuZGF0YVBvaW50cyA9IG51bGw7IC8vIFRoZSB0YWJsZSB3aXRoIHBvaW50IG9iamVjdHNcblxuICAgIC8vIGNyZWF0ZSBhIGZyYW1lIGFuZCBjYW52YXNcbiAgICB0aGlzLmNyZWF0ZSgpO1xuXG4gICAgU2V0dGluZ3Muc2V0RGVmYXVsdHMoREVGQVVMVFMsIHRoaXMpO1xuXG4gICAgLy8gdGhlIGNvbHVtbiBpbmRleGVzXG4gICAgdGhpcy5jb2xYID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY29sWSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbFogPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb2xWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbEZpbHRlciA9IHVuZGVmaW5lZDtcblxuICAgIC8vIFRPRE86IGN1c3RvbWl6ZSBheGlzIHJhbmdlXG5cbiAgICAvLyBhcHBseSBvcHRpb25zIChhbHNvIHdoZW4gdW5kZWZpbmVkKVxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgIC8vIGFwcGx5IGRhdGFcbiAgICBpZiAoZGF0YSkge1xuICAgICAgdGhpcy5zZXREYXRhKGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEV4dGVuZCBHcmFwaDNkIHdpdGggYW4gRW1pdHRlciBtaXhpblxuICBFbWl0dGVyKEdyYXBoM2QucHJvdG90eXBlKTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBzY2FsaW5nIHZhbHVlcywgZGVwZW5kZW50IG9uIHRoZSByYW5nZSBpbiB4LCB5LCBhbmQgeiBkaXJlY3Rpb25cbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9zZXRTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNjYWxlID0gbmV3IFBvaW50M2QoMSAvIHRoaXMueFJhbmdlLnJhbmdlKCksIDEgLyB0aGlzLnlSYW5nZS5yYW5nZSgpLCAxIC8gdGhpcy56UmFuZ2UucmFuZ2UoKSk7XG5cbiAgICAvLyBrZWVwIGFzcGVjdCByYXRpb24gYmV0d2VlbiB4IGFuZCB5IHNjYWxlIGlmIGRlc2lyZWRcbiAgICBpZiAodGhpcy5rZWVwQXNwZWN0UmF0aW8pIHtcbiAgICAgIGlmICh0aGlzLnNjYWxlLnggPCB0aGlzLnNjYWxlLnkpIHtcbiAgICAgICAgLy9ub2luc3BlY3Rpb24gSlNTdXNwaWNpb3VzTmFtZUNvbWJpbmF0aW9uXG4gICAgICAgIHRoaXMuc2NhbGUueSA9IHRoaXMuc2NhbGUueDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vbm9pbnNwZWN0aW9uIEpTU3VzcGljaW91c05hbWVDb21iaW5hdGlvblxuICAgICAgICB0aGlzLnNjYWxlLnggPSB0aGlzLnNjYWxlLnk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2NhbGUgdGhlIHZlcnRpY2FsIGF4aXNcbiAgICB0aGlzLnNjYWxlLnogKj0gdGhpcy52ZXJ0aWNhbFJhdGlvO1xuICAgIC8vIFRPRE86IGNhbiB0aGlzIGJlIGF1dG9tYXRlZD8gdmVydGljYWxSYXRpbz9cblxuICAgIC8vIGRldGVybWluZSBzY2FsZSBmb3IgKG9wdGlvbmFsKSB2YWx1ZVxuICAgIGlmICh0aGlzLnZhbHVlUmFuZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zY2FsZS52YWx1ZSA9IDEgLyB0aGlzLnZhbHVlUmFuZ2UucmFuZ2UoKTtcbiAgICB9XG5cbiAgICAvLyBwb3NpdGlvbiB0aGUgY2FtZXJhIGFybVxuICAgIHZhciB4Q2VudGVyID0gdGhpcy54UmFuZ2UuY2VudGVyKCkgKiB0aGlzLnNjYWxlLng7XG4gICAgdmFyIHlDZW50ZXIgPSB0aGlzLnlSYW5nZS5jZW50ZXIoKSAqIHRoaXMuc2NhbGUueTtcbiAgICB2YXIgekNlbnRlciA9IHRoaXMuelJhbmdlLmNlbnRlcigpICogdGhpcy5zY2FsZS56O1xuICAgIHRoaXMuY2FtZXJhLnNldEFybUxvY2F0aW9uKHhDZW50ZXIsIHlDZW50ZXIsIHpDZW50ZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgM0QgbG9jYXRpb24gdG8gYSAyRCBsb2NhdGlvbiBvbiBzY3JlZW5cbiAgICogU291cmNlOiB0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvM0RfcHJvamVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gICB7UG9pbnQzZH0gcG9pbnQzZCAgQSAzRCBwb2ludCB3aXRoIHBhcmFtZXRlcnMgeCwgeSwgelxuICAgKiBAcmV0dXJucyB7UG9pbnQyZH0gcG9pbnQyZCAgQSAyRCBwb2ludCB3aXRoIHBhcmFtZXRlcnMgeCwgeVxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX2NvbnZlcnQzRHRvMkQgPSBmdW5jdGlvbiAocG9pbnQzZCkge1xuICAgIHZhciB0cmFuc2xhdGlvbiA9IHRoaXMuX2NvbnZlcnRQb2ludFRvVHJhbnNsYXRpb24ocG9pbnQzZCk7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRUcmFuc2xhdGlvblRvU2NyZWVuKHRyYW5zbGF0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBhIDNEIGxvY2F0aW9uIGl0cyB0cmFuc2xhdGlvbiBzZWVuIGZyb20gdGhlIGNhbWVyYVxuICAgKiBTb3VyY2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvM0RfcHJvamVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gICB7UG9pbnQzZH0gcG9pbnQzZCAgICAgQSAzRCBwb2ludCB3aXRoIHBhcmFtZXRlcnMgeCwgeSwgelxuICAgKiBAcmV0dXJucyB7UG9pbnQzZH0gdHJhbnNsYXRpb24gQSAzRCBwb2ludCB3aXRoIHBhcmFtZXRlcnMgeCwgeSwgeiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgdHJhbnNsYXRpb24gb2YgdGhlIHBvaW50LCBzZWVuIGZyb20gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW1lcmEuXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fY29udmVydFBvaW50VG9UcmFuc2xhdGlvbiA9IGZ1bmN0aW9uIChwb2ludDNkKSB7XG4gICAgdmFyIGNhbWVyYUxvY2F0aW9uID0gdGhpcy5jYW1lcmEuZ2V0Q2FtZXJhTG9jYXRpb24oKSxcbiAgICAgICAgY2FtZXJhUm90YXRpb24gPSB0aGlzLmNhbWVyYS5nZXRDYW1lcmFSb3RhdGlvbigpLFxuICAgICAgICBheCA9IHBvaW50M2QueCAqIHRoaXMuc2NhbGUueCxcbiAgICAgICAgYXkgPSBwb2ludDNkLnkgKiB0aGlzLnNjYWxlLnksXG4gICAgICAgIGF6ID0gcG9pbnQzZC56ICogdGhpcy5zY2FsZS56LFxuICAgICAgICBjeCA9IGNhbWVyYUxvY2F0aW9uLngsXG4gICAgICAgIGN5ID0gY2FtZXJhTG9jYXRpb24ueSxcbiAgICAgICAgY3ogPSBjYW1lcmFMb2NhdGlvbi56LFxuXG5cbiAgICAvLyBjYWxjdWxhdGUgYW5nbGVzXG4gICAgc2luVHggPSBNYXRoLnNpbihjYW1lcmFSb3RhdGlvbi54KSxcbiAgICAgICAgY29zVHggPSBNYXRoLmNvcyhjYW1lcmFSb3RhdGlvbi54KSxcbiAgICAgICAgc2luVHkgPSBNYXRoLnNpbihjYW1lcmFSb3RhdGlvbi55KSxcbiAgICAgICAgY29zVHkgPSBNYXRoLmNvcyhjYW1lcmFSb3RhdGlvbi55KSxcbiAgICAgICAgc2luVHogPSBNYXRoLnNpbihjYW1lcmFSb3RhdGlvbi56KSxcbiAgICAgICAgY29zVHogPSBNYXRoLmNvcyhjYW1lcmFSb3RhdGlvbi56KSxcblxuXG4gICAgLy8gY2FsY3VsYXRlIHRyYW5zbGF0aW9uXG4gICAgZHggPSBjb3NUeSAqIChzaW5UeiAqIChheSAtIGN5KSArIGNvc1R6ICogKGF4IC0gY3gpKSAtIHNpblR5ICogKGF6IC0gY3opLFxuICAgICAgICBkeSA9IHNpblR4ICogKGNvc1R5ICogKGF6IC0gY3opICsgc2luVHkgKiAoc2luVHogKiAoYXkgLSBjeSkgKyBjb3NUeiAqIChheCAtIGN4KSkpICsgY29zVHggKiAoY29zVHogKiAoYXkgLSBjeSkgLSBzaW5UeiAqIChheCAtIGN4KSksXG4gICAgICAgIGR6ID0gY29zVHggKiAoY29zVHkgKiAoYXogLSBjeikgKyBzaW5UeSAqIChzaW5UeiAqIChheSAtIGN5KSArIGNvc1R6ICogKGF4IC0gY3gpKSkgLSBzaW5UeCAqIChjb3NUeiAqIChheSAtIGN5KSAtIHNpblR6ICogKGF4IC0gY3gpKTtcblxuICAgIHJldHVybiBuZXcgUG9pbnQzZChkeCwgZHksIGR6KTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBhIHRyYW5zbGF0aW9uIHBvaW50IHRvIGEgcG9pbnQgb24gdGhlIHNjcmVlblxuICAgKlxuICAgKiBAcGFyYW0gICB7UG9pbnQzZH0gdHJhbnNsYXRpb24gQSAzRCBwb2ludCB3aXRoIHBhcmFtZXRlcnMgeCwgeSwgeiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgdHJhbnNsYXRpb24gb2YgdGhlIHBvaW50LCBzZWVuIGZyb20gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW1lcmEuXG4gICAqIEByZXR1cm5zIHtQb2ludDJkfSBwb2ludDJkICAgICBBIDJEIHBvaW50IHdpdGggcGFyYW1ldGVycyB4LCB5XG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fY29udmVydFRyYW5zbGF0aW9uVG9TY3JlZW4gPSBmdW5jdGlvbiAodHJhbnNsYXRpb24pIHtcbiAgICB2YXIgZXggPSB0aGlzLmV5ZS54LFxuICAgICAgICBleSA9IHRoaXMuZXllLnksXG4gICAgICAgIGV6ID0gdGhpcy5leWUueixcbiAgICAgICAgZHggPSB0cmFuc2xhdGlvbi54LFxuICAgICAgICBkeSA9IHRyYW5zbGF0aW9uLnksXG4gICAgICAgIGR6ID0gdHJhbnNsYXRpb24uejtcblxuICAgIC8vIGNhbGN1bGF0ZSBwb3NpdGlvbiBvbiBzY3JlZW4gZnJvbSB0cmFuc2xhdGlvblxuICAgIHZhciBieDtcbiAgICB2YXIgYnk7XG4gICAgaWYgKHRoaXMuc2hvd1BlcnNwZWN0aXZlKSB7XG4gICAgICBieCA9IChkeCAtIGV4KSAqIChleiAvIGR6KTtcbiAgICAgIGJ5ID0gKGR5IC0gZXkpICogKGV6IC8gZHopO1xuICAgIH0gZWxzZSB7XG4gICAgICBieCA9IGR4ICogLShleiAvIHRoaXMuY2FtZXJhLmdldEFybUxlbmd0aCgpKTtcbiAgICAgIGJ5ID0gZHkgKiAtKGV6IC8gdGhpcy5jYW1lcmEuZ2V0QXJtTGVuZ3RoKCkpO1xuICAgIH1cblxuICAgIC8vIHNoaWZ0IGFuZCBzY2FsZSB0aGUgcG9pbnQgdG8gdGhlIGNlbnRlciBvZiB0aGUgc2NyZWVuXG4gICAgLy8gdXNlIHRoZSB3aWR0aCBvZiB0aGUgZ3JhcGggdG8gc2NhbGUgYm90aCBob3Jpem9udGFsbHkgYW5kIHZlcnRpY2FsbHkuXG4gICAgcmV0dXJuIG5ldyBQb2ludDJkKHRoaXMuY3VycmVudFhDZW50ZXIgKyBieCAqIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoLCB0aGlzLmN1cnJlbnRZQ2VudGVyIC0gYnkgKiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgdHJhbnNsYXRpb25zIGFuZCBzY3JlZW4gcG9zaXRpb25zIG9mIGFsbCBwb2ludHNcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9jYWxjVHJhbnNsYXRpb25zID0gZnVuY3Rpb24gKHBvaW50cywgc29ydCkge1xuICAgIGlmIChzb3J0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNvcnQgPSB0cnVlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBwb2ludC50cmFucyA9IHRoaXMuX2NvbnZlcnRQb2ludFRvVHJhbnNsYXRpb24ocG9pbnQucG9pbnQpO1xuICAgICAgcG9pbnQuc2NyZWVuID0gdGhpcy5fY29udmVydFRyYW5zbGF0aW9uVG9TY3JlZW4ocG9pbnQudHJhbnMpO1xuXG4gICAgICAvLyBjYWxjdWxhdGUgdGhlIHRyYW5zbGF0aW9uIG9mIHRoZSBwb2ludCBhdCB0aGUgYm90dG9tIChuZWVkZWQgZm9yIHNvcnRpbmcpXG4gICAgICB2YXIgdHJhbnNCb3R0b20gPSB0aGlzLl9jb252ZXJ0UG9pbnRUb1RyYW5zbGF0aW9uKHBvaW50LmJvdHRvbSk7XG4gICAgICBwb2ludC5kaXN0ID0gdGhpcy5zaG93UGVyc3BlY3RpdmUgPyB0cmFuc0JvdHRvbS5sZW5ndGgoKSA6IC10cmFuc0JvdHRvbS56O1xuICAgIH1cblxuICAgIGlmICghc29ydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNvcnQgdGhlIHBvaW50cyBvbiBkZXB0aCBvZiB0aGVpciAoeCx5KSBwb3NpdGlvbiAobm90IG9uIHopXG4gICAgdmFyIHNvcnREZXB0aCA9IGZ1bmN0aW9uIHNvcnREZXB0aChhLCBiKSB7XG4gICAgICByZXR1cm4gYi5kaXN0IC0gYS5kaXN0O1xuICAgIH07XG4gICAgcG9pbnRzLnNvcnQoc29ydERlcHRoKTtcbiAgfTtcblxuICBHcmFwaDNkLnByb3RvdHlwZS5nZXROdW1iZXJPZlJvd3MgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBkYXRhLmxlbmd0aDtcbiAgfTtcblxuICBHcmFwaDNkLnByb3RvdHlwZS5nZXROdW1iZXJPZkNvbHVtbnMgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBjb3VudGVyID0gMDtcbiAgICBmb3IgKHZhciBjb2x1bW4gaW4gZGF0YVswXSkge1xuICAgICAgaWYgKGRhdGFbMF0uaGFzT3duUHJvcGVydHkoY29sdW1uKSkge1xuICAgICAgICBjb3VudGVyKys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuXG4gIEdyYXBoM2QucHJvdG90eXBlLmdldERpc3RpbmN0VmFsdWVzID0gZnVuY3Rpb24gKGRhdGEsIGNvbHVtbikge1xuICAgIHZhciBkaXN0aW5jdFZhbHVlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGRpc3RpbmN0VmFsdWVzLmluZGV4T2YoZGF0YVtpXVtjb2x1bW5dKSA9PSAtMSkge1xuICAgICAgICBkaXN0aW5jdFZhbHVlcy5wdXNoKGRhdGFbaV1bY29sdW1uXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaXN0aW5jdFZhbHVlcztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBhYnNvbHV0ZSBtaW4vbWF4IHZhbHVlcyBmb3IgdGhlIHBhc3NlZCBkYXRhIGNvbHVtbi5cbiAgICpcbiAgICogQHJldHVybnMge1JhbmdlfSBBIFJhbmdlIGluc3RhbmNlIHdpdGggbWluL21heCBtZW1iZXJzIHByb3Blcmx5IHNldC5cbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLmdldENvbHVtblJhbmdlID0gZnVuY3Rpb24gKGRhdGEsIGNvbHVtbikge1xuICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZSgpO1xuXG4gICAgLy8gQWRqdXN0IHRoZSByYW5nZSBzbyB0aGF0IGl0IGNvdmVycyBhbGwgdmFsdWVzIGluIHRoZSBwYXNzZWQgZGF0YSBlbGVtZW50cy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gZGF0YVtpXVtjb2x1bW5dO1xuICAgICAgcmFuZ2UuYWRqdXN0KGl0ZW0pO1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHN0YXRlIGlzIGNvbnNpc3RlbnQgZm9yIHRoZSB1c2Ugb2YgdGhlIHZhbHVlIGZpZWxkLlxuICAgKlxuICAgKiBUaHJvd3MgaWYgYSBwcm9ibGVtIGlzIGRldGVjdGVkLlxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX2NoZWNrVmFsdWVGaWVsZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cbiAgICB2YXIgaGFzVmFsdWVGaWVsZCA9IHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuQkFSQ09MT1IgfHwgdGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5CQVJTSVpFIHx8IHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuRE9UQ09MT1IgfHwgdGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5ET1RTSVpFO1xuXG4gICAgaWYgKCFoYXNWYWx1ZUZpZWxkKSB7XG4gICAgICByZXR1cm47IC8vIE5vIG5lZWQgdG8gY2hlY2sgZnVydGhlclxuICAgIH1cblxuICAgIC8vIEZvbGxvd2luZyBmaWVsZCBtdXN0IGJlIHByZXNlbnQgZm9yIHRoZSBjdXJyZW50IGdyYXBoIHN0eWxlXG4gICAgaWYgKHRoaXMuY29sVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBkYXRhIHRvIGhhdmUgJyArICcgZmllbGQgXFwnc3R5bGVcXCcgJyArICcgZm9yIGdyYXBoIHN0eWxlIFxcJycgKyB0aGlzLnN0eWxlICsgJ1xcJycpO1xuICAgIH1cblxuICAgIC8vIFRoZSBkYXRhIG11c3QgYWxzbyBjb250YWluIHRoaXMgZmllbGQuXG4gICAgLy8gTm90ZSB0aGF0IG9ubHkgZmlyc3QgZGF0YSBlbGVtZW50IGlzIGNoZWNrZWQuXG4gICAgaWYgKGRhdGFbMF1bdGhpcy5jb2xWYWx1ZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBkYXRhIHRvIGhhdmUgJyArICcgZmllbGQgXFwnJyArIHRoaXMuY29sVmFsdWUgKyAnXFwnICcgKyAnIGZvciBncmFwaCBzdHlsZSBcXCcnICsgdGhpcy5zdHlsZSArICdcXCcnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBkZWZhdWx0IHZhbHVlcyBmb3IgcmFuZ2VcbiAgICpcbiAgICogVGhlIGRlZmF1bHQgdmFsdWVzIG92ZXJyaWRlIHRoZSByYW5nZSB2YWx1ZXMsIGlmIGRlZmluZWQuXG4gICAqXG4gICAqIEJlY2F1c2UgaXQncyBwb3NzaWJsZSB0aGF0IG9ubHkgZGVmYXVsdE1pbiBvciBkZWZhdWx0TWF4IGlzIHNldCwgaXQncyBiZXR0ZXJcbiAgICogdG8gcGFzcyBpbiBhIHJhbmdlIGFscmVhZHkgc2V0IHdpdGggdGhlIG1pbi9tYXggc2V0IGZyb20gdGhlIGRhdGEuIE90aGVyd2lzZSxcbiAgICogaXQncyBxdWl0ZSBoYXJkIHRvIHByb2Nlc3MgdGhlIG1pbi9tYXggcHJvcGVybHkuXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fc2V0UmFuZ2VEZWZhdWx0cyA9IGZ1bmN0aW9uIChyYW5nZSwgZGVmYXVsdE1pbiwgZGVmYXVsdE1heCkge1xuICAgIGlmIChkZWZhdWx0TWluICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJhbmdlLm1pbiA9IGRlZmF1bHRNaW47XG4gICAgfVxuXG4gICAgaWYgKGRlZmF1bHRNYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmFuZ2UubWF4ID0gZGVmYXVsdE1heDtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIHRoZSBvcmlnaW5hbCB3YXkgdGhhdCB0aGUgZGVmYXVsdCBtaW4vbWF4IHZhbHVlcyB3ZXJlIGFkanVzdGVkLlxuICAgIC8vIFRPRE86IFBlcmhhcHMgaXQncyBiZXR0ZXIgaWYgYW4gZXJyb3IgaXMgdGhyb3duIGlmIHRoZSB2YWx1ZXMgZG8gbm90IGFncmVlLlxuICAgIC8vICAgICAgIEJ1dCB0aGlzIHdpbGwgY2hhbmdlIHRoZSBiZWhhdmlvdXIuXG4gICAgaWYgKHJhbmdlLm1heCA8PSByYW5nZS5taW4pIHJhbmdlLm1heCA9IHJhbmdlLm1pbiArIDE7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGRhdGEgZnJvbSB0aGUgZGF0YSB0YWJsZS4gQ2FsY3VsYXRlIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWVzXG4gICAqIGFuZCBjb2x1bW4gaW5kZXggdmFsdWVzXG4gICAqIEBwYXJhbSB7QXJyYXkgfCBEYXRhU2V0IHwgRGF0YVZpZXd9IHJhd0RhdGEgVGhlIGRhdGEgY29udGFpbmluZyB0aGUgaXRlbXMgZm9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIEdyYXBoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICBzdHlsZSAgIFN0eWxlIE51bWJlclxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX2RhdGFJbml0aWFsaXplID0gZnVuY3Rpb24gKHJhd0RhdGEsIHN0eWxlKSB7XG4gICAgdmFyIG1lID0gdGhpcztcblxuICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gdGhlIGRhdGFUYWJsZVxuICAgIGlmICh0aGlzLmRhdGFTZXQpIHtcbiAgICAgIHRoaXMuZGF0YVNldC5vZmYoJyonLCB0aGlzLl9vbkNoYW5nZSk7XG4gICAgfVxuXG4gICAgaWYgKHJhd0RhdGEgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmF3RGF0YSkpIHtcbiAgICAgIHJhd0RhdGEgPSBuZXcgRGF0YVNldChyYXdEYXRhKTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YTtcbiAgICBpZiAocmF3RGF0YSBpbnN0YW5jZW9mIERhdGFTZXQgfHwgcmF3RGF0YSBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgICBkYXRhID0gcmF3RGF0YS5nZXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheSwgRGF0YVNldCwgb3IgRGF0YVZpZXcgZXhwZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPT0gMCkgcmV0dXJuO1xuXG4gICAgdGhpcy5kYXRhU2V0ID0gcmF3RGF0YTtcbiAgICB0aGlzLmRhdGFUYWJsZSA9IGRhdGE7XG5cbiAgICAvLyBzdWJzY3JpYmUgdG8gY2hhbmdlcyBpbiB0aGUgZGF0YXNldFxuICAgIHRoaXMuX29uQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgbWUuc2V0RGF0YShtZS5kYXRhU2V0KTtcbiAgICB9O1xuICAgIHRoaXMuZGF0YVNldC5vbignKicsIHRoaXMuX29uQ2hhbmdlKTtcblxuICAgIC8vIGRldGVybWluZSB0aGUgbG9jYXRpb24gb2YgeCx5LHosdmFsdWUsZmlsdGVyIGNvbHVtbnNcbiAgICB0aGlzLmNvbFggPSAneCc7XG4gICAgdGhpcy5jb2xZID0gJ3knO1xuICAgIHRoaXMuY29sWiA9ICd6JztcblxuICAgIHZhciB3aXRoQmFycyA9IHRoaXMuc3R5bGUgPT0gR3JhcGgzZC5TVFlMRS5CQVIgfHwgdGhpcy5zdHlsZSA9PSBHcmFwaDNkLlNUWUxFLkJBUkNPTE9SIHx8IHRoaXMuc3R5bGUgPT0gR3JhcGgzZC5TVFlMRS5CQVJTSVpFO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGJhcldpZHRoIGZyb20gZGF0YVxuICAgIGlmICh3aXRoQmFycykge1xuICAgICAgaWYgKHRoaXMuZGVmYXVsdFhCYXJXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMueEJhcldpZHRoID0gdGhpcy5kZWZhdWx0WEJhcldpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRhdGFYID0gdGhpcy5nZXREaXN0aW5jdFZhbHVlcyhkYXRhLCB0aGlzLmNvbFgpO1xuICAgICAgICB0aGlzLnhCYXJXaWR0aCA9IGRhdGFYWzFdIC0gZGF0YVhbMF0gfHwgMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZGVmYXVsdFlCYXJXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMueUJhcldpZHRoID0gdGhpcy5kZWZhdWx0WUJhcldpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRhdGFZID0gdGhpcy5nZXREaXN0aW5jdFZhbHVlcyhkYXRhLCB0aGlzLmNvbFkpO1xuICAgICAgICB0aGlzLnlCYXJXaWR0aCA9IGRhdGFZWzFdIC0gZGF0YVlbMF0gfHwgMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgbWluaW11bXMgYW5kIG1heGltdW1zXG4gICAgdmFyIE5VTVNURVBTID0gNTtcblxuICAgIHZhciB4UmFuZ2UgPSB0aGlzLmdldENvbHVtblJhbmdlKGRhdGEsIHRoaXMuY29sWCk7XG4gICAgaWYgKHdpdGhCYXJzKSB7XG4gICAgICB4UmFuZ2UuZXhwYW5kKHRoaXMueEJhcldpZHRoIC8gMik7XG4gICAgfVxuICAgIHRoaXMuX3NldFJhbmdlRGVmYXVsdHMoeFJhbmdlLCB0aGlzLmRlZmF1bHRYTWluLCB0aGlzLmRlZmF1bHRYTWF4KTtcbiAgICB0aGlzLnhSYW5nZSA9IHhSYW5nZTtcbiAgICB0aGlzLnhTdGVwID0gdGhpcy5kZWZhdWx0WFN0ZXAgIT09IHVuZGVmaW5lZCA/IHRoaXMuZGVmYXVsdFhTdGVwIDogeFJhbmdlLnJhbmdlKCkgLyBOVU1TVEVQUztcblxuICAgIHZhciB5UmFuZ2UgPSB0aGlzLmdldENvbHVtblJhbmdlKGRhdGEsIHRoaXMuY29sWSk7XG4gICAgaWYgKHdpdGhCYXJzKSB7XG4gICAgICB5UmFuZ2UuZXhwYW5kKHRoaXMueUJhcldpZHRoIC8gMik7XG4gICAgfVxuICAgIHRoaXMuX3NldFJhbmdlRGVmYXVsdHMoeVJhbmdlLCB0aGlzLmRlZmF1bHRZTWluLCB0aGlzLmRlZmF1bHRZTWF4KTtcbiAgICB0aGlzLnlSYW5nZSA9IHlSYW5nZTtcbiAgICB0aGlzLnlTdGVwID0gdGhpcy5kZWZhdWx0WVN0ZXAgIT09IHVuZGVmaW5lZCA/IHRoaXMuZGVmYXVsdFlTdGVwIDogeVJhbmdlLnJhbmdlKCkgLyBOVU1TVEVQUztcblxuICAgIHZhciB6UmFuZ2UgPSB0aGlzLmdldENvbHVtblJhbmdlKGRhdGEsIHRoaXMuY29sWik7XG4gICAgdGhpcy5fc2V0UmFuZ2VEZWZhdWx0cyh6UmFuZ2UsIHRoaXMuZGVmYXVsdFpNaW4sIHRoaXMuZGVmYXVsdFpNYXgpO1xuICAgIHRoaXMuelJhbmdlID0gelJhbmdlO1xuICAgIHRoaXMuelN0ZXAgPSB0aGlzLmRlZmF1bHRaU3RlcCAhPT0gdW5kZWZpbmVkID8gdGhpcy5kZWZhdWx0WlN0ZXAgOiB6UmFuZ2UucmFuZ2UoKSAvIE5VTVNURVBTO1xuXG4gICAgaWYgKGRhdGFbMF0uaGFzT3duUHJvcGVydHkoJ3N0eWxlJykpIHtcbiAgICAgIHRoaXMuY29sVmFsdWUgPSAnc3R5bGUnO1xuICAgICAgdmFyIHZhbHVlUmFuZ2UgPSB0aGlzLmdldENvbHVtblJhbmdlKGRhdGEsIHRoaXMuY29sVmFsdWUpO1xuICAgICAgdGhpcy5fc2V0UmFuZ2VEZWZhdWx0cyh2YWx1ZVJhbmdlLCB0aGlzLmRlZmF1bHRWYWx1ZU1pbiwgdGhpcy5kZWZhdWx0VmFsdWVNYXgpO1xuICAgICAgdGhpcy52YWx1ZVJhbmdlID0gdmFsdWVSYW5nZTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBhIGZpbHRlciBjb2x1bW4gaXMgcHJvdmlkZWRcbiAgICAvLyBOZWVkcyB0byBiZSBzdGFydGVkIGFmdGVyIHpSYW5nZSBpcyBkZWZpbmVkXG4gICAgaWYgKGRhdGFbMF0uaGFzT3duUHJvcGVydHkoJ2ZpbHRlcicpKSB7XG4gICAgICAvLyBPbmx5IHNldCB0aGlzIGZpZWxkIGlmIGl0J3MgYWN0dWFsbHkgcHJlc2VudFxuICAgICAgdGhpcy5jb2xGaWx0ZXIgPSAnZmlsdGVyJztcblxuICAgICAgaWYgKHRoaXMuZGF0YUZpbHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZGF0YUZpbHRlciA9IG5ldyBGaWx0ZXIocmF3RGF0YSwgdGhpcy5jb2xGaWx0ZXIsIHRoaXMpO1xuICAgICAgICB0aGlzLmRhdGFGaWx0ZXIuc2V0T25Mb2FkQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1lLnJlZHJhdygpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzZXQgdGhlIHNjYWxlIGRlcGVuZGVudCBvbiB0aGUgcmFuZ2VzLlxuICAgIHRoaXMuX3NldFNjYWxlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbHRlciB0aGUgZGF0YSBiYXNlZCBvbiB0aGUgY3VycmVudCBmaWx0ZXJcbiAgICpcbiAgICogQHBhcmFtICAge0FycmF5fSBkYXRhXG4gICAqIEByZXR1cm5zIHtBcnJheX0gZGF0YVBvaW50cyBBcnJheSB3aXRoIHBvaW50IG9iamVjdHMgd2hpY2ggY2FuIGJlIGRyYXduIG9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JlZW5cbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9nZXREYXRhUG9pbnRzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAvLyBUT0RPOiBzdG9yZSB0aGUgY3JlYXRlZCBtYXRyaXggZGF0YVBvaW50cyBpbiB0aGUgZmlsdGVycyBpbnN0ZWFkIG9mXG4gICAgLy8gICAgICAgcmVsb2FkaW5nIGVhY2ggdGltZS5cbiAgICB2YXIgeCwgeSwgaSwgeiwgb2JqLCBwb2ludDtcblxuICAgIHZhciBkYXRhUG9pbnRzID0gW107XG5cbiAgICBpZiAodGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5HUklEIHx8IHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuU1VSRkFDRSkge1xuICAgICAgLy8gY29weSBhbGwgdmFsdWVzIGZyb20gdGhlIGdvb2dsZSBkYXRhIHRhYmxlIHRvIGEgbWF0cml4XG4gICAgICAvLyB0aGUgcHJvdmlkZWQgdmFsdWVzIGFyZSBzdXBwb3NlZCB0byBmb3JtIGEgZ3JpZCBvZiAoeCx5KSBwb3NpdGlvbnNcblxuICAgICAgLy8gY3JlYXRlIHR3byBsaXN0cyB3aXRoIGFsbCBwcmVzZW50IHggYW5kIHkgdmFsdWVzXG4gICAgICB2YXIgZGF0YVggPSBbXTtcbiAgICAgIHZhciBkYXRhWSA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZ2V0TnVtYmVyT2ZSb3dzKGRhdGEpOyBpKyspIHtcbiAgICAgICAgeCA9IGRhdGFbaV1bdGhpcy5jb2xYXSB8fCAwO1xuICAgICAgICB5ID0gZGF0YVtpXVt0aGlzLmNvbFldIHx8IDA7XG5cbiAgICAgICAgaWYgKGRhdGFYLmluZGV4T2YoeCkgPT09IC0xKSB7XG4gICAgICAgICAgZGF0YVgucHVzaCh4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YVkuaW5kZXhPZih5KSA9PT0gLTEpIHtcbiAgICAgICAgICBkYXRhWS5wdXNoKHkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3J0TnVtYmVyID0gZnVuY3Rpb24gc29ydE51bWJlcihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgIH07XG4gICAgICBkYXRhWC5zb3J0KHNvcnROdW1iZXIpO1xuICAgICAgZGF0YVkuc29ydChzb3J0TnVtYmVyKTtcblxuICAgICAgLy8gY3JlYXRlIGEgZ3JpZCwgYSAyZCBtYXRyaXgsIHdpdGggYWxsIHZhbHVlcy5cbiAgICAgIHZhciBkYXRhTWF0cml4ID0gW107IC8vIHRlbXBvcmFyeSBkYXRhIG1hdHJpeFxuICAgICAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeCA9IGRhdGFbaV1bdGhpcy5jb2xYXSB8fCAwO1xuICAgICAgICB5ID0gZGF0YVtpXVt0aGlzLmNvbFldIHx8IDA7XG4gICAgICAgIHogPSBkYXRhW2ldW3RoaXMuY29sWl0gfHwgMDtcblxuICAgICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgQXJyYXkoKS5pbmRleE9mKCkgZm9yIEludGVybmV0IEV4cGxvcmVyXG4gICAgICAgIHZhciB4SW5kZXggPSBkYXRhWC5pbmRleE9mKHgpO1xuICAgICAgICB2YXIgeUluZGV4ID0gZGF0YVkuaW5kZXhPZih5KTtcblxuICAgICAgICBpZiAoZGF0YU1hdHJpeFt4SW5kZXhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkYXRhTWF0cml4W3hJbmRleF0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb2ludDNkID0gbmV3IFBvaW50M2QoKTtcbiAgICAgICAgcG9pbnQzZC54ID0geDtcbiAgICAgICAgcG9pbnQzZC55ID0geTtcbiAgICAgICAgcG9pbnQzZC56ID0gejtcbiAgICAgICAgcG9pbnQzZC5kYXRhID0gZGF0YVtpXTtcblxuICAgICAgICBvYmogPSB7fTtcbiAgICAgICAgb2JqLnBvaW50ID0gcG9pbnQzZDtcbiAgICAgICAgb2JqLnRyYW5zID0gdW5kZWZpbmVkO1xuICAgICAgICBvYmouc2NyZWVuID0gdW5kZWZpbmVkO1xuICAgICAgICBvYmouYm90dG9tID0gbmV3IFBvaW50M2QoeCwgeSwgdGhpcy56UmFuZ2UubWluKTtcblxuICAgICAgICBkYXRhTWF0cml4W3hJbmRleF1beUluZGV4XSA9IG9iajtcblxuICAgICAgICBkYXRhUG9pbnRzLnB1c2gob2JqKTtcbiAgICAgIH1cblxuICAgICAgLy8gZmlsbCBpbiB0aGUgcG9pbnRlcnMgdG8gdGhlIG5laWdoYm9ycy5cbiAgICAgIGZvciAoeCA9IDA7IHggPCBkYXRhTWF0cml4Lmxlbmd0aDsgeCsrKSB7XG4gICAgICAgIGZvciAoeSA9IDA7IHkgPCBkYXRhTWF0cml4W3hdLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgaWYgKGRhdGFNYXRyaXhbeF1beV0pIHtcbiAgICAgICAgICAgIGRhdGFNYXRyaXhbeF1beV0ucG9pbnRSaWdodCA9IHggPCBkYXRhTWF0cml4Lmxlbmd0aCAtIDEgPyBkYXRhTWF0cml4W3ggKyAxXVt5XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGRhdGFNYXRyaXhbeF1beV0ucG9pbnRUb3AgPSB5IDwgZGF0YU1hdHJpeFt4XS5sZW5ndGggLSAxID8gZGF0YU1hdHJpeFt4XVt5ICsgMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBkYXRhTWF0cml4W3hdW3ldLnBvaW50Q3Jvc3MgPSB4IDwgZGF0YU1hdHJpeC5sZW5ndGggLSAxICYmIHkgPCBkYXRhTWF0cml4W3hdLmxlbmd0aCAtIDEgPyBkYXRhTWF0cml4W3ggKyAxXVt5ICsgMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICdkb3QnLCAnZG90LWxpbmUnLCBldGMuXG4gICAgICB0aGlzLl9jaGVja1ZhbHVlRmllbGQoZGF0YSk7XG5cbiAgICAgIC8vIGNvcHkgYWxsIHZhbHVlcyBmcm9tIHRoZSBnb29nbGUgZGF0YSB0YWJsZSB0byBhIGxpc3Qgd2l0aCBQb2ludDNkIG9iamVjdHNcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBvaW50ID0gbmV3IFBvaW50M2QoKTtcbiAgICAgICAgcG9pbnQueCA9IGRhdGFbaV1bdGhpcy5jb2xYXSB8fCAwO1xuICAgICAgICBwb2ludC55ID0gZGF0YVtpXVt0aGlzLmNvbFldIHx8IDA7XG4gICAgICAgIHBvaW50LnogPSBkYXRhW2ldW3RoaXMuY29sWl0gfHwgMDtcbiAgICAgICAgcG9pbnQuZGF0YSA9IGRhdGFbaV07XG5cbiAgICAgICAgaWYgKHRoaXMuY29sVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBvaW50LnZhbHVlID0gZGF0YVtpXVt0aGlzLmNvbFZhbHVlXSB8fCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0ge307XG4gICAgICAgIG9iai5wb2ludCA9IHBvaW50O1xuICAgICAgICBvYmouYm90dG9tID0gbmV3IFBvaW50M2QocG9pbnQueCwgcG9pbnQueSwgdGhpcy56UmFuZ2UubWluKTtcbiAgICAgICAgb2JqLnRyYW5zID0gdW5kZWZpbmVkO1xuICAgICAgICBvYmouc2NyZWVuID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmICh0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkxJTkUpIHtcbiAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIC8vIEFkZCBuZXh0IHBvaW50IGZvciBsaW5lIGRyYXdpbmdcbiAgICAgICAgICAgIGRhdGFQb2ludHNbaSAtIDFdLnBvaW50TmV4dCA9IG9iajtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhUG9pbnRzLnB1c2gob2JqKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YVBvaW50cztcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBtYWluIGZyYW1lIGZvciB0aGUgR3JhcGgzZC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBleGVjdXRlZCBvbmNlIHdoZW4gYSBHcmFwaDNkIG9iamVjdCBpcyBjcmVhdGVkLiBUaGUgZnJhbWVcbiAgICogY29udGFpbnMgYSBjYW52YXMsIGFuZCB0aGlzIGNhbnZhcyBjb250YWlucyBhbGwgb2JqZWN0cyBsaWtlIHRoZSBheGlzIGFuZFxuICAgKiBub2Rlcy5cbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyByZW1vdmUgYWxsIGVsZW1lbnRzIGZyb20gdGhlIGNvbnRhaW5lciBlbGVtZW50LlxuICAgIHdoaWxlICh0aGlzLmNvbnRhaW5lckVsZW1lbnQuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lckVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5jb250YWluZXJFbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHRoaXMuZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmZyYW1lLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICB0aGlzLmZyYW1lLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG5cbiAgICAvLyBjcmVhdGUgdGhlIGdyYXBoIGNhbnZhcyAoSFRNTCBjYW52YXMgZWxlbWVudClcbiAgICB0aGlzLmZyYW1lLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHRoaXMuZnJhbWUuY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuZnJhbWUuY2FudmFzKTtcbiAgICAvL2lmICghdGhpcy5mcmFtZS5jYW52YXMuZ2V0Q29udGV4dCkge1xuICAgIHtcbiAgICAgIHZhciBub0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgbm9DYW52YXMuc3R5bGUuY29sb3IgPSAncmVkJztcbiAgICAgIG5vQ2FudmFzLnN0eWxlLmZvbnRXZWlnaHQgPSAnYm9sZCc7XG4gICAgICBub0NhbnZhcy5zdHlsZS5wYWRkaW5nID0gJzEwcHgnO1xuICAgICAgbm9DYW52YXMuaW5uZXJIVE1MID0gJ0Vycm9yOiB5b3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBIVE1MIGNhbnZhcyc7XG4gICAgICB0aGlzLmZyYW1lLmNhbnZhcy5hcHBlbmRDaGlsZChub0NhbnZhcyk7XG4gICAgfVxuXG4gICAgdGhpcy5mcmFtZS5maWx0ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmZyYW1lLmZpbHRlci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgdGhpcy5mcmFtZS5maWx0ZXIuc3R5bGUuYm90dG9tID0gJzBweCc7XG4gICAgdGhpcy5mcmFtZS5maWx0ZXIuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgIHRoaXMuZnJhbWUuZmlsdGVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZS5maWx0ZXIpO1xuXG4gICAgLy8gYWRkIGV2ZW50IGxpc3RlbmVycyB0byBoYW5kbGUgbW92aW5nIGFuZCB6b29taW5nIHRoZSBjb250ZW50c1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIG9ubW91c2Vkb3duID0gZnVuY3Rpb24gb25tb3VzZWRvd24oZXZlbnQpIHtcbiAgICAgIG1lLl9vbk1vdXNlRG93bihldmVudCk7XG4gICAgfTtcbiAgICB2YXIgb250b3VjaHN0YXJ0ID0gZnVuY3Rpb24gb250b3VjaHN0YXJ0KGV2ZW50KSB7XG4gICAgICBtZS5fb25Ub3VjaFN0YXJ0KGV2ZW50KTtcbiAgICB9O1xuICAgIHZhciBvbm1vdXNld2hlZWwgPSBmdW5jdGlvbiBvbm1vdXNld2hlZWwoZXZlbnQpIHtcbiAgICAgIG1lLl9vbldoZWVsKGV2ZW50KTtcbiAgICB9O1xuICAgIHZhciBvbnRvb2x0aXAgPSBmdW5jdGlvbiBvbnRvb2x0aXAoZXZlbnQpIHtcbiAgICAgIG1lLl9vblRvb2x0aXAoZXZlbnQpO1xuICAgIH07XG4gICAgLy8gVE9ETzogdGhlc2UgZXZlbnRzIGFyZSBuZXZlciBjbGVhbmVkIHVwLi4uIGNhbiBnaXZlIGEgJ21lbW9yeSBsZWFrYWdlJ1xuXG4gICAgdXRpbC5hZGRFdmVudExpc3RlbmVyKHRoaXMuZnJhbWUuY2FudmFzLCAna2V5ZG93bicsIG9ua2V5ZG93bik7XG4gICAgdXRpbC5hZGRFdmVudExpc3RlbmVyKHRoaXMuZnJhbWUuY2FudmFzLCAnbW91c2Vkb3duJywgb25tb3VzZWRvd24pO1xuICAgIHV0aWwuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmZyYW1lLmNhbnZhcywgJ3RvdWNoc3RhcnQnLCBvbnRvdWNoc3RhcnQpO1xuICAgIHV0aWwuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmZyYW1lLmNhbnZhcywgJ21vdXNld2hlZWwnLCBvbm1vdXNld2hlZWwpO1xuICAgIHV0aWwuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmZyYW1lLmNhbnZhcywgJ21vdXNlbW92ZScsIG9udG9vbHRpcCk7XG5cbiAgICAvLyBhZGQgdGhlIG5ldyBncmFwaCB0byB0aGUgY29udGFpbmVyIGVsZW1lbnRcbiAgICB0aGlzLmNvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIG5ldyBzaXplIGZvciB0aGUgZ3JhcGhcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHdpZHRoICBXaWR0aCBpbiBwaXhlbHMgb3IgcGVyY2VudGFnZSAoZm9yIGV4YW1wbGUgJzgwMHB4J1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIG9yICc1MCUnKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGVpZ2h0IEhlaWdodCBpbiBwaXhlbHMgb3IgcGVyY2VudGFnZSAgKGZvciBleGFtcGxlICc0MDBweCdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBvciAnMzAlJylcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMuZnJhbWUuc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmZyYW1lLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcblxuICAgIHRoaXMuX3Jlc2l6ZUNhbnZhcygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNpemUgdGhlIGNhbnZhcyB0byB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBmcmFtZVxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX3Jlc2l6ZUNhbnZhcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZyYW1lLmNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICB0aGlzLmZyYW1lLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG5cbiAgICB0aGlzLmZyYW1lLmNhbnZhcy53aWR0aCA9IHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoO1xuICAgIHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCA9IHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodDtcblxuICAgIC8vIGFkanVzdCB3aXRoIGZvciBtYXJnaW5cbiAgICB0aGlzLmZyYW1lLmZpbHRlci5zdHlsZS53aWR0aCA9IHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoIC0gMiAqIDEwICsgJ3B4JztcbiAgfTtcblxuICAvKipcbiAgICogU3RhcnQgYW5pbWF0aW9uXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5hbmltYXRpb25TdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuZnJhbWUuZmlsdGVyIHx8ICF0aGlzLmZyYW1lLmZpbHRlci5zbGlkZXIpIHRocm93IG5ldyBFcnJvcignTm8gYW5pbWF0aW9uIGF2YWlsYWJsZScpO1xuXG4gICAgdGhpcy5mcmFtZS5maWx0ZXIuc2xpZGVyLnBsYXkoKTtcbiAgfTtcblxuICAvKipcbiAgICogU3RvcCBhbmltYXRpb25cbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLmFuaW1hdGlvblN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmZyYW1lLmZpbHRlciB8fCAhdGhpcy5mcmFtZS5maWx0ZXIuc2xpZGVyKSByZXR1cm47XG5cbiAgICB0aGlzLmZyYW1lLmZpbHRlci5zbGlkZXIuc3RvcCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNpemUgdGhlIGNlbnRlciBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgY3VycmVudCB2YWx1ZXMgaW4gdGhpcy54Q2VudGVyXG4gICAqIGFuZCB0aGlzLnlDZW50ZXIgKHdoaWNoIGFyZSBzdHJpbmdzIHdpdGggYSBwZXJjZW50YWdlIG9yIGEgdmFsdWVcbiAgICogaW4gcGl4ZWxzKS4gVGhlIGNlbnRlciBwb3NpdGlvbnMgYXJlIHRoZSB2YXJpYWJsZXMgdGhpcy5jdXJyZW50WENlbnRlclxuICAgKiBhbmQgdGhpcy5jdXJyZW50WUNlbnRlclxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX3Jlc2l6ZUNlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIGhvcml6b250YWwgY2VudGVyIHBvc2l0aW9uXG4gICAgaWYgKHRoaXMueENlbnRlci5jaGFyQXQodGhpcy54Q2VudGVyLmxlbmd0aCAtIDEpID09PSAnJScpIHtcbiAgICAgIHRoaXMuY3VycmVudFhDZW50ZXIgPSBwYXJzZUZsb2F0KHRoaXMueENlbnRlcikgLyAxMDAgKiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdXJyZW50WENlbnRlciA9IHBhcnNlRmxvYXQodGhpcy54Q2VudGVyKTsgLy8gc3VwcG9zZWQgdG8gYmUgaW4gcHhcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIHZlcnRpY2FsIGNlbnRlciBwb3NpdGlvblxuICAgIGlmICh0aGlzLnlDZW50ZXIuY2hhckF0KHRoaXMueUNlbnRlci5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgICB0aGlzLmN1cnJlbnRZQ2VudGVyID0gcGFyc2VGbG9hdCh0aGlzLnlDZW50ZXIpIC8gMTAwICogKHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCAtIHRoaXMuZnJhbWUuZmlsdGVyLmNsaWVudEhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3VycmVudFlDZW50ZXIgPSBwYXJzZUZsb2F0KHRoaXMueUNlbnRlcik7IC8vIHN1cHBvc2VkIHRvIGJlIGluIHB4XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBjYW1lcmEgcm90YXRpb25cbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH0gQW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBob3Jpem9udGFsLCB2ZXJ0aWNhbCwgYW5kXG4gICAqICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5nZXRDYW1lcmFQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcG9zID0gdGhpcy5jYW1lcmEuZ2V0QXJtUm90YXRpb24oKTtcbiAgICBwb3MuZGlzdGFuY2UgPSB0aGlzLmNhbWVyYS5nZXRBcm1MZW5ndGgoKTtcbiAgICByZXR1cm4gcG9zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2FkIGRhdGEgaW50byB0aGUgM0QgR3JhcGhcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9yZWFkRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgLy8gcmVhZCB0aGUgZGF0YVxuICAgIHRoaXMuX2RhdGFJbml0aWFsaXplKGRhdGEsIHRoaXMuc3R5bGUpO1xuXG4gICAgaWYgKHRoaXMuZGF0YUZpbHRlcikge1xuICAgICAgLy8gYXBwbHkgZmlsdGVyaW5nXG4gICAgICB0aGlzLmRhdGFQb2ludHMgPSB0aGlzLmRhdGFGaWx0ZXIuX2dldERhdGFQb2ludHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm8gZmlsdGVyaW5nLiBsb2FkIGFsbCBkYXRhXG4gICAgICB0aGlzLmRhdGFQb2ludHMgPSB0aGlzLl9nZXREYXRhUG9pbnRzKHRoaXMuZGF0YVRhYmxlKTtcbiAgICB9XG5cbiAgICAvLyBkcmF3IHRoZSBmaWx0ZXJcbiAgICB0aGlzLl9yZWRyYXdGaWx0ZXIoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVwbGFjZSB0aGUgZGF0YXNldCBvZiB0aGUgR3JhcGgzZFxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5IHwgRGF0YVNldCB8IERhdGFWaWV3fSBkYXRhXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB0aGlzLl9yZWFkRGF0YShkYXRhKTtcbiAgICB0aGlzLnJlZHJhdygpO1xuXG4gICAgLy8gc3RhcnQgYW5pbWF0aW9uIHdoZW4gb3B0aW9uIGlzIHRydWVcbiAgICBpZiAodGhpcy5hbmltYXRpb25BdXRvU3RhcnQgJiYgdGhpcy5kYXRhRmlsdGVyKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXJ0KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIG9wdGlvbnMuIE9wdGlvbnMgd2lsbCBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IG9wdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBjYW1lcmFQb3NpdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuYW5pbWF0aW9uU3RvcCgpO1xuXG4gICAgU2V0dGluZ3Muc2V0T3B0aW9ucyhvcHRpb25zLCB0aGlzKTtcblxuICAgIHRoaXMuc2V0UG9pbnREcmF3aW5nTWV0aG9kKCk7XG4gICAgdGhpcy5zZXRTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgIC8vIHJlLWxvYWQgdGhlIGRhdGFcbiAgICBpZiAodGhpcy5kYXRhVGFibGUpIHtcbiAgICAgIHRoaXMuc2V0RGF0YSh0aGlzLmRhdGFUYWJsZSk7XG4gICAgfVxuXG4gICAgLy8gc3RhcnQgYW5pbWF0aW9uIHdoZW4gb3B0aW9uIGlzIHRydWVcbiAgICBpZiAodGhpcy5hbmltYXRpb25BdXRvU3RhcnQgJiYgdGhpcy5kYXRhRmlsdGVyKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXJ0KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hpY2ggcG9pbnQgZHJhd2luZyBtZXRob2QgdG8gdXNlIGZvciB0aGUgY3VycmVudCBncmFwaCBzdHlsZS5cbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLnNldFBvaW50RHJhd2luZ01ldGhvZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWV0aG9kID0gdW5kZWZpbmVkO1xuXG4gICAgc3dpdGNoICh0aGlzLnN0eWxlKSB7XG4gICAgICBjYXNlIEdyYXBoM2QuU1RZTEUuQkFSOlxuICAgICAgICBtZXRob2QgPSBHcmFwaDNkLnByb3RvdHlwZS5fcmVkcmF3QmFyR3JhcGhQb2ludDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEdyYXBoM2QuU1RZTEUuQkFSQ09MT1I6XG4gICAgICAgIG1ldGhvZCA9IEdyYXBoM2QucHJvdG90eXBlLl9yZWRyYXdCYXJDb2xvckdyYXBoUG9pbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHcmFwaDNkLlNUWUxFLkJBUlNJWkU6XG4gICAgICAgIG1ldGhvZCA9IEdyYXBoM2QucHJvdG90eXBlLl9yZWRyYXdCYXJTaXplR3JhcGhQb2ludDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEdyYXBoM2QuU1RZTEUuRE9UOlxuICAgICAgICBtZXRob2QgPSBHcmFwaDNkLnByb3RvdHlwZS5fcmVkcmF3RG90R3JhcGhQb2ludDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEdyYXBoM2QuU1RZTEUuRE9UTElORTpcbiAgICAgICAgbWV0aG9kID0gR3JhcGgzZC5wcm90b3R5cGUuX3JlZHJhd0RvdExpbmVHcmFwaFBvaW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR3JhcGgzZC5TVFlMRS5ET1RDT0xPUjpcbiAgICAgICAgbWV0aG9kID0gR3JhcGgzZC5wcm90b3R5cGUuX3JlZHJhd0RvdENvbG9yR3JhcGhQb2ludDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEdyYXBoM2QuU1RZTEUuRE9UU0laRTpcbiAgICAgICAgbWV0aG9kID0gR3JhcGgzZC5wcm90b3R5cGUuX3JlZHJhd0RvdFNpemVHcmFwaFBvaW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR3JhcGgzZC5TVFlMRS5TVVJGQUNFOlxuICAgICAgICBtZXRob2QgPSBHcmFwaDNkLnByb3RvdHlwZS5fcmVkcmF3U3VyZmFjZUdyYXBoUG9pbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHcmFwaDNkLlNUWUxFLkdSSUQ6XG4gICAgICAgIG1ldGhvZCA9IEdyYXBoM2QucHJvdG90eXBlLl9yZWRyYXdHcmlkR3JhcGhQb2ludDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEdyYXBoM2QuU1RZTEUuTElORTpcbiAgICAgICAgbWV0aG9kID0gR3JhcGgzZC5wcm90b3R5cGUuX3JlZHJhd0xpbmVHcmFwaFBvaW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBkZXRlcm1pbmUgcG9pbnQgZHJhd2luZyBtZXRob2QgJyArICdmb3IgZ3JhcGggc3R5bGUgXFwnJyArIHRoaXMuc3R5bGUgKyAnXFwnJyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX3BvaW50RHJhd2luZ01ldGhvZCA9IG1ldGhvZDtcbiAgfTtcblxuICAvKipcbiAgICogUmVkcmF3IHRoZSBHcmFwaC5cbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kYXRhUG9pbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignR3JhcGggZGF0YSBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXNpemVDYW52YXMoKTtcbiAgICB0aGlzLl9yZXNpemVDZW50ZXIoKTtcbiAgICB0aGlzLl9yZWRyYXdTbGlkZXIoKTtcbiAgICB0aGlzLl9yZWRyYXdDbGVhcigpO1xuICAgIHRoaXMuX3JlZHJhd0F4aXMoKTtcblxuICAgIHRoaXMuX3JlZHJhd0RhdGFHcmFwaCgpO1xuXG4gICAgdGhpcy5fcmVkcmF3SW5mbygpO1xuICAgIHRoaXMuX3JlZHJhd0xlZ2VuZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgZHJhd2luZyBjb250ZXh0IHdpdGhvdXQgZXhwb3NpbmcgY2FudmFzXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fZ2V0Q29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5mcmFtZS5jYW52YXM7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgY3R4LmxpbmVKb2luID0gJ3JvdW5kJztcbiAgICBjdHgubGluZUNhcCA9ICdyb3VuZCc7XG5cbiAgICByZXR1cm4gY3R4O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhciB0aGUgY2FudmFzIGJlZm9yZSByZWRyYXdpbmdcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9yZWRyYXdDbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5mcmFtZS5jYW52YXM7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICB9O1xuXG4gIEdyYXBoM2QucHJvdG90eXBlLl9kb3RTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmZyYW1lLmNsaWVudFdpZHRoICogdGhpcy5kb3RTaXplUmF0aW87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBsZWdlbmQgd2lkdGggXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fZ2V0TGVnZW5kV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHdpZHRoO1xuXG4gICAgaWYgKHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuRE9UU0laRSkge1xuICAgICAgdmFyIGRvdFNpemUgPSB0aGlzLl9kb3RTaXplKCk7XG4gICAgICB3aWR0aCA9IGRvdFNpemUgLyAyICsgZG90U2l6ZSAqIDI7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkJBUlNJWkUpIHtcbiAgICAgIHdpZHRoID0gdGhpcy54QmFyV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gMjA7XG4gICAgfVxuICAgIHJldHVybiB3aWR0aDtcbiAgfTtcblxuICAvKipcbiAgICogUmVkcmF3IHRoZSBsZWdlbmQgYmFzZWQgb24gc2l6ZSwgZG90IGNvbG9yLCBvciBzdXJmYWNlIGhlaWdodCBcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9yZWRyYXdMZWdlbmQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvL1JldHVybiB3aXRob3V0IGRyYXdpbmcgYW55dGhpbmcsIGlmIG5vIGxlZ2VuZCBpcyBzcGVjaWZpZWQgXG4gICAgaWYgKHRoaXMuc2hvd0xlZ2VuZCAhPT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERvIG5vdCBkcmF3IGxlZ2VuZCB3aGVuIGdyYXBoIHN0eWxlIGRvZXMgbm90IHN1cHBvcnRcbiAgICBpZiAodGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5MSU5FIHx8IHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuQkFSU0laRSAvL1RPRE8gYWRkIGxlZ2VuZCBzdXBwb3J0IGZvciBCQVJTSVpFIFxuICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAvLyBMZWdlbmQgdHlwZXMgLSBzaXplIGFuZCBjb2xvci4gRGV0ZXJtaW5lIGlmIHNpemUgbGVnZW5kLiAgXG4gICAgdmFyIGlzU2l6ZUxlZ2VuZCA9IHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuQkFSU0laRSB8fCB0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkRPVFNJWkU7XG5cbiAgICAvLyBMZWdlbmQgaXMgZWl0aGVyIHRyYWNraW5nIHogdmFsdWVzIG9yIHN0eWxlIHZhbHVlcy4gVGhpcyBmbGFnIGlmIGZhbHNlIG1lYW5zIHVzZSB6IHZhbHVlcy4gXG4gICAgdmFyIGlzVmFsdWVMZWdlbmQgPSB0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkRPVFNJWkUgfHwgdGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5ET1RDT0xPUiB8fCB0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkJBUkNPTE9SO1xuXG4gICAgdmFyIGhlaWdodCA9IE1hdGgubWF4KHRoaXMuZnJhbWUuY2xpZW50SGVpZ2h0ICogMC4yNSwgMTAwKTtcbiAgICB2YXIgdG9wID0gdGhpcy5tYXJnaW47XG4gICAgdmFyIHdpZHRoID0gdGhpcy5fZ2V0TGVnZW5kV2lkdGgoKTsgLy8gcHggLSBvdmVyd3JpdHRlbiBieSBzaXplIGxlZ2VuZCAgXG4gICAgdmFyIHJpZ2h0ID0gdGhpcy5mcmFtZS5jbGllbnRXaWR0aCAtIHRoaXMubWFyZ2luO1xuICAgIHZhciBsZWZ0ID0gcmlnaHQgLSB3aWR0aDtcbiAgICB2YXIgYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuXG4gICAgdmFyIGN0eCA9IHRoaXMuX2dldENvbnRleHQoKTtcbiAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICBjdHguZm9udCA9ICcxNHB4IGFyaWFsJzsgLy8gVE9ETzogcHV0IGluIG9wdGlvbnNcblxuICAgIGlmIChpc1NpemVMZWdlbmQgPT09IGZhbHNlKSB7XG4gICAgICAvLyBkcmF3IHRoZSBjb2xvciBiYXJcbiAgICAgIHZhciB5bWluID0gMDtcbiAgICAgIHZhciB5bWF4ID0gaGVpZ2h0OyAvLyBUb2RvOiBtYWtlIGhlaWdodCBjdXN0b21pemFibGVcbiAgICAgIHZhciB5O1xuXG4gICAgICBmb3IgKHkgPSB5bWluOyB5IDwgeW1heDsgeSsrKSB7XG4gICAgICAgIHZhciBmID0gKHkgLSB5bWluKSAvICh5bWF4IC0geW1pbik7XG4gICAgICAgIHZhciBodWUgPSBmICogMjQwO1xuICAgICAgICB2YXIgY29sb3IgPSB0aGlzLl9oc3YycmdiKGh1ZSwgMSwgMSk7XG5cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhsZWZ0LCB0b3AgKyB5KTtcbiAgICAgICAgY3R4LmxpbmVUbyhyaWdodCwgdG9wICsgeSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYXhpc0NvbG9yO1xuICAgICAgY3R4LnN0cm9rZVJlY3QobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBkcmF3IHRoZSBzaXplIGxlZ2VuZCBib3ggXG4gICAgICB2YXIgd2lkdGhNaW47XG4gICAgICBpZiAodGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5ET1RTSVpFKSB7XG4gICAgICAgIHZhciBkb3RTaXplID0gdGhpcy5fZG90U2l6ZSgpO1xuICAgICAgICB3aWR0aE1pbiA9IGRvdFNpemUgLyAyOyAvLyBweFxuICAgICAgfSBlbHNlIGlmICh0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkJBUlNJWkUpIHtcbiAgICAgICAgLy93aWR0aE1pbiA9IHRoaXMueEJhcldpZHRoICogMC4yIHRoaXMgaXMgd3JvbmcgLSBiYXJ3aWR0aCBtZWFzdXJlcyBpbiB0ZXJtcyBvZiB4dmFsdWVzIFxuICAgICAgfVxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5heGlzQ29sb3I7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5kYXRhQ29sb3IuZmlsbDtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8obGVmdCwgdG9wKTtcbiAgICAgIGN0eC5saW5lVG8ocmlnaHQsIHRvcCk7XG4gICAgICBjdHgubGluZVRvKHJpZ2h0IC0gd2lkdGggKyB3aWR0aE1pbiwgYm90dG9tKTtcbiAgICAgIGN0eC5saW5lVG8obGVmdCwgYm90dG9tKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuXG4gICAgLy8gcHJpbnQgdmFsdWUgdGV4dCBhbG9uZyB0aGUgbGVnZW5kIGVkZ2UgXG4gICAgdmFyIGdyaWRMaW5lTGVuID0gNTsgLy8gcHhcblxuICAgIHZhciBsZWdlbmRNaW4gPSBpc1ZhbHVlTGVnZW5kID8gdGhpcy52YWx1ZVJhbmdlLm1pbiA6IHRoaXMuelJhbmdlLm1pbjtcbiAgICB2YXIgbGVnZW5kTWF4ID0gaXNWYWx1ZUxlZ2VuZCA/IHRoaXMudmFsdWVSYW5nZS5tYXggOiB0aGlzLnpSYW5nZS5tYXg7XG4gICAgdmFyIHN0ZXAgPSBuZXcgU3RlcE51bWJlcihsZWdlbmRNaW4sIGxlZ2VuZE1heCwgKGxlZ2VuZE1heCAtIGxlZ2VuZE1pbikgLyA1LCB0cnVlKTtcbiAgICBzdGVwLnN0YXJ0KHRydWUpO1xuXG4gICAgdmFyIHk7XG4gICAgdmFyIGZyb207XG4gICAgdmFyIHRvO1xuICAgIHdoaWxlICghc3RlcC5lbmQoKSkge1xuICAgICAgeSA9IGJvdHRvbSAtIChzdGVwLmdldEN1cnJlbnQoKSAtIGxlZ2VuZE1pbikgLyAobGVnZW5kTWF4IC0gbGVnZW5kTWluKSAqIGhlaWdodDtcbiAgICAgIGZyb20gPSBuZXcgUG9pbnQyZChsZWZ0IC0gZ3JpZExpbmVMZW4sIHkpO1xuICAgICAgdG8gPSBuZXcgUG9pbnQyZChsZWZ0LCB5KTtcbiAgICAgIHRoaXMuX2xpbmUoY3R4LCBmcm9tLCB0byk7XG5cbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYXhpc0NvbG9yO1xuICAgICAgY3R4LmZpbGxUZXh0KHN0ZXAuZ2V0Q3VycmVudCgpLCBsZWZ0IC0gMiAqIGdyaWRMaW5lTGVuLCB5KTtcblxuICAgICAgc3RlcC5uZXh0KCk7XG4gICAgfVxuXG4gICAgY3R4LnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgIHZhciBsYWJlbCA9IHRoaXMubGVnZW5kTGFiZWw7XG4gICAgY3R4LmZpbGxUZXh0KGxhYmVsLCByaWdodCwgYm90dG9tICsgdGhpcy5tYXJnaW4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWRyYXcgdGhlIGZpbHRlclxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX3JlZHJhd0ZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZyYW1lLmZpbHRlci5pbm5lckhUTUwgPSAnJztcblxuICAgIGlmICh0aGlzLmRhdGFGaWx0ZXIpIHtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAndmlzaWJsZSc6IHRoaXMuc2hvd0FuaW1hdGlvbkNvbnRyb2xzXG4gICAgICB9O1xuICAgICAgdmFyIHNsaWRlciA9IG5ldyBTbGlkZXIodGhpcy5mcmFtZS5maWx0ZXIsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5mcmFtZS5maWx0ZXIuc2xpZGVyID0gc2xpZGVyO1xuXG4gICAgICAvLyBUT0RPOiBjc3MgaGVyZSBpcyBub3QgbmljZSBoZXJlLi4uXG4gICAgICB0aGlzLmZyYW1lLmZpbHRlci5zdHlsZS5wYWRkaW5nID0gJzEwcHgnO1xuICAgICAgLy90aGlzLmZyYW1lLmZpbHRlci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI0VGRUZFRic7XG5cbiAgICAgIHNsaWRlci5zZXRWYWx1ZXModGhpcy5kYXRhRmlsdGVyLnZhbHVlcyk7XG4gICAgICBzbGlkZXIuc2V0UGxheUludGVydmFsKHRoaXMuYW5pbWF0aW9uSW50ZXJ2YWwpO1xuXG4gICAgICAvLyBjcmVhdGUgYW4gZXZlbnQgaGFuZGxlclxuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHZhciBvbmNoYW5nZSA9IGZ1bmN0aW9uIG9uY2hhbmdlKCkge1xuICAgICAgICB2YXIgaW5kZXggPSBzbGlkZXIuZ2V0SW5kZXgoKTtcblxuICAgICAgICBtZS5kYXRhRmlsdGVyLnNlbGVjdFZhbHVlKGluZGV4KTtcbiAgICAgICAgbWUuZGF0YVBvaW50cyA9IG1lLmRhdGFGaWx0ZXIuX2dldERhdGFQb2ludHMoKTtcblxuICAgICAgICBtZS5yZWRyYXcoKTtcbiAgICAgIH07XG4gICAgICBzbGlkZXIuc2V0T25DaGFuZ2VDYWxsYmFjayhvbmNoYW5nZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZnJhbWUuZmlsdGVyLnNsaWRlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZHJhdyB0aGUgc2xpZGVyXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fcmVkcmF3U2xpZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmZyYW1lLmZpbHRlci5zbGlkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5mcmFtZS5maWx0ZXIuc2xpZGVyLnJlZHJhdygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVkcmF3IGNvbW1vbiBpbmZvcm1hdGlvblxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX3JlZHJhd0luZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZGF0YUZpbHRlcikge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuX2dldENvbnRleHQoKTtcblxuICAgICAgY3R4LmZvbnQgPSAnMTRweCBhcmlhbCc7IC8vIFRPRE86IHB1dCBpbiBvcHRpb25zXG4gICAgICBjdHgubGluZVN0eWxlID0gJ2dyYXknO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICdncmF5JztcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG5cbiAgICAgIHZhciB4ID0gdGhpcy5tYXJnaW47XG4gICAgICB2YXIgeSA9IHRoaXMubWFyZ2luO1xuICAgICAgY3R4LmZpbGxUZXh0KHRoaXMuZGF0YUZpbHRlci5nZXRMYWJlbCgpICsgJzogJyArIHRoaXMuZGF0YUZpbHRlci5nZXRTZWxlY3RlZFZhbHVlKCksIHgsIHkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRHJhdyBhIGxpbmUgYmV0d2VlbiAyZCBwb2ludHMgJ2Zyb20nIGFuZCAndG8nLlxuICAgKlxuICAgKiBJZiBzdHJva2Ugc3R5bGUgc3BlY2lmaWVkLCBzZXQgdGhhdCBhcyB3ZWxsLlxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX2xpbmUgPSBmdW5jdGlvbiAoY3R4LCBmcm9tLCB0bywgc3Ryb2tlU3R5bGUpIHtcbiAgICBpZiAoc3Ryb2tlU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gICAgfVxuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oZnJvbS54LCBmcm9tLnkpO1xuICAgIGN0eC5saW5lVG8odG8ueCwgdG8ueSk7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9O1xuXG4gIEdyYXBoM2QucHJvdG90eXBlLmRyYXdBeGlzTGFiZWxYID0gZnVuY3Rpb24gKGN0eCwgcG9pbnQzZCwgdGV4dCwgYXJtQW5nbGUsIHlNYXJnaW4pIHtcbiAgICBpZiAoeU1hcmdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB5TWFyZ2luID0gMDtcbiAgICB9XG5cbiAgICB2YXIgcG9pbnQyZCA9IHRoaXMuX2NvbnZlcnQzRHRvMkQocG9pbnQzZCk7XG5cbiAgICBpZiAoTWF0aC5jb3MoYXJtQW5nbGUgKiAyKSA+IDApIHtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgIHBvaW50MmQueSArPSB5TWFyZ2luO1xuICAgIH0gZWxzZSBpZiAoTWF0aC5zaW4oYXJtQW5nbGUgKiAyKSA8IDApIHtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIH1cblxuICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmF4aXNDb2xvcjtcbiAgICBjdHguZmlsbFRleHQodGV4dCwgcG9pbnQyZC54LCBwb2ludDJkLnkpO1xuICB9O1xuXG4gIEdyYXBoM2QucHJvdG90eXBlLmRyYXdBeGlzTGFiZWxZID0gZnVuY3Rpb24gKGN0eCwgcG9pbnQzZCwgdGV4dCwgYXJtQW5nbGUsIHlNYXJnaW4pIHtcbiAgICBpZiAoeU1hcmdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB5TWFyZ2luID0gMDtcbiAgICB9XG5cbiAgICB2YXIgcG9pbnQyZCA9IHRoaXMuX2NvbnZlcnQzRHRvMkQocG9pbnQzZCk7XG5cbiAgICBpZiAoTWF0aC5jb3MoYXJtQW5nbGUgKiAyKSA8IDApIHtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgIHBvaW50MmQueSArPSB5TWFyZ2luO1xuICAgIH0gZWxzZSBpZiAoTWF0aC5zaW4oYXJtQW5nbGUgKiAyKSA+IDApIHtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIH1cblxuICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmF4aXNDb2xvcjtcbiAgICBjdHguZmlsbFRleHQodGV4dCwgcG9pbnQyZC54LCBwb2ludDJkLnkpO1xuICB9O1xuXG4gIEdyYXBoM2QucHJvdG90eXBlLmRyYXdBeGlzTGFiZWxaID0gZnVuY3Rpb24gKGN0eCwgcG9pbnQzZCwgdGV4dCwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIHZhciBwb2ludDJkID0gdGhpcy5fY29udmVydDNEdG8yRChwb2ludDNkKTtcbiAgICBjdHgudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYXhpc0NvbG9yO1xuICAgIGN0eC5maWxsVGV4dCh0ZXh0LCBwb2ludDJkLnggLSBvZmZzZXQsIHBvaW50MmQueSk7XG4gIH07XG5cbiAgLyoqXG5cblxuICAvKipcbiAgICogRHJhdyBhIGxpbmUgYmV0d2VlbiAyZCBwb2ludHMgJ2Zyb20nIGFuZCAndG8nLlxuICAgKlxuICAgKiBJZiBzdHJva2Ugc3R5bGUgc3BlY2lmaWVkLCBzZXQgdGhhdCBhcyB3ZWxsLlxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX2xpbmUzZCA9IGZ1bmN0aW9uIChjdHgsIGZyb20sIHRvLCBzdHJva2VTdHlsZSkge1xuICAgIHZhciBmcm9tMmQgPSB0aGlzLl9jb252ZXJ0M0R0bzJEKGZyb20pO1xuICAgIHZhciB0bzJkID0gdGhpcy5fY29udmVydDNEdG8yRCh0byk7XG5cbiAgICB0aGlzLl9saW5lKGN0eCwgZnJvbTJkLCB0bzJkLCBzdHJva2VTdHlsZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZHJhdyB0aGUgYXhpc1xuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX3JlZHJhd0F4aXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuX2dldENvbnRleHQoKSxcbiAgICAgICAgZnJvbSxcbiAgICAgICAgdG8sXG4gICAgICAgIHN0ZXAsXG4gICAgICAgIHByZXR0eVN0ZXAsXG4gICAgICAgIHRleHQsXG4gICAgICAgIHhUZXh0LFxuICAgICAgICB5VGV4dCxcbiAgICAgICAgelRleHQsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgeE9mZnNldCxcbiAgICAgICAgeU9mZnNldDtcblxuICAgIC8vIFRPRE86IGdldCB0aGUgYWN0dWFsIHJlbmRlcmVkIHN0eWxlIG9mIHRoZSBjb250YWluZXJFbGVtZW50XG4gICAgLy9jdHguZm9udCA9IHRoaXMuY29udGFpbmVyRWxlbWVudC5zdHlsZS5mb250O1xuICAgIGN0eC5mb250ID0gMjQgLyB0aGlzLmNhbWVyYS5nZXRBcm1MZW5ndGgoKSArICdweCBhcmlhbCc7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIGxlbmd0aCBmb3IgdGhlIHNob3J0IGdyaWQgbGluZXNcbiAgICB2YXIgZ3JpZExlblggPSAwLjAyNSAvIHRoaXMuc2NhbGUueDtcbiAgICB2YXIgZ3JpZExlblkgPSAwLjAyNSAvIHRoaXMuc2NhbGUueTtcbiAgICB2YXIgdGV4dE1hcmdpbiA9IDUgLyB0aGlzLmNhbWVyYS5nZXRBcm1MZW5ndGgoKTsgLy8gcHhcbiAgICB2YXIgYXJtQW5nbGUgPSB0aGlzLmNhbWVyYS5nZXRBcm1Sb3RhdGlvbigpLmhvcml6b250YWw7XG4gICAgdmFyIGFybVZlY3RvciA9IG5ldyBQb2ludDJkKE1hdGguY29zKGFybUFuZ2xlKSwgTWF0aC5zaW4oYXJtQW5nbGUpKTtcblxuICAgIHZhciB4UmFuZ2UgPSB0aGlzLnhSYW5nZTtcbiAgICB2YXIgeVJhbmdlID0gdGhpcy55UmFuZ2U7XG4gICAgdmFyIHpSYW5nZSA9IHRoaXMuelJhbmdlO1xuXG4gICAgLy8gZHJhdyB4LWdyaWQgbGluZXNcbiAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICBwcmV0dHlTdGVwID0gdGhpcy5kZWZhdWx0WFN0ZXAgPT09IHVuZGVmaW5lZDtcbiAgICBzdGVwID0gbmV3IFN0ZXBOdW1iZXIoeFJhbmdlLm1pbiwgeFJhbmdlLm1heCwgdGhpcy54U3RlcCwgcHJldHR5U3RlcCk7XG4gICAgc3RlcC5zdGFydCh0cnVlKTtcblxuICAgIHdoaWxlICghc3RlcC5lbmQoKSkge1xuICAgICAgdmFyIHggPSBzdGVwLmdldEN1cnJlbnQoKTtcblxuICAgICAgaWYgKHRoaXMuc2hvd0dyaWQpIHtcbiAgICAgICAgZnJvbSA9IG5ldyBQb2ludDNkKHgsIHlSYW5nZS5taW4sIHpSYW5nZS5taW4pO1xuICAgICAgICB0byA9IG5ldyBQb2ludDNkKHgsIHlSYW5nZS5tYXgsIHpSYW5nZS5taW4pO1xuICAgICAgICB0aGlzLl9saW5lM2QoY3R4LCBmcm9tLCB0bywgdGhpcy5ncmlkQ29sb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJvbSA9IG5ldyBQb2ludDNkKHgsIHlSYW5nZS5taW4sIHpSYW5nZS5taW4pO1xuICAgICAgICB0byA9IG5ldyBQb2ludDNkKHgsIHlSYW5nZS5taW4gKyBncmlkTGVuWCwgelJhbmdlLm1pbik7XG4gICAgICAgIHRoaXMuX2xpbmUzZChjdHgsIGZyb20sIHRvLCB0aGlzLmF4aXNDb2xvcik7XG5cbiAgICAgICAgZnJvbSA9IG5ldyBQb2ludDNkKHgsIHlSYW5nZS5tYXgsIHpSYW5nZS5taW4pO1xuICAgICAgICB0byA9IG5ldyBQb2ludDNkKHgsIHlSYW5nZS5tYXggLSBncmlkTGVuWCwgelJhbmdlLm1pbik7XG4gICAgICAgIHRoaXMuX2xpbmUzZChjdHgsIGZyb20sIHRvLCB0aGlzLmF4aXNDb2xvcik7XG4gICAgICB9XG5cbiAgICAgIHlUZXh0ID0gYXJtVmVjdG9yLnggPiAwID8geVJhbmdlLm1pbiA6IHlSYW5nZS5tYXg7XG4gICAgICB2YXIgcG9pbnQzZCA9IG5ldyBQb2ludDNkKHgsIHlUZXh0LCB6UmFuZ2UubWluKTtcbiAgICAgIHZhciBtc2cgPSAnICAnICsgdGhpcy54VmFsdWVMYWJlbCh4KSArICcgICc7XG4gICAgICB0aGlzLmRyYXdBeGlzTGFiZWxYKGN0eCwgcG9pbnQzZCwgbXNnLCBhcm1BbmdsZSwgdGV4dE1hcmdpbik7XG5cbiAgICAgIHN0ZXAubmV4dCgpO1xuICAgIH1cblxuICAgIC8vIGRyYXcgeS1ncmlkIGxpbmVzXG4gICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgcHJldHR5U3RlcCA9IHRoaXMuZGVmYXVsdFlTdGVwID09PSB1bmRlZmluZWQ7XG4gICAgc3RlcCA9IG5ldyBTdGVwTnVtYmVyKHlSYW5nZS5taW4sIHlSYW5nZS5tYXgsIHRoaXMueVN0ZXAsIHByZXR0eVN0ZXApO1xuICAgIHN0ZXAuc3RhcnQodHJ1ZSk7XG5cbiAgICB3aGlsZSAoIXN0ZXAuZW5kKCkpIHtcbiAgICAgIHZhciB5ID0gc3RlcC5nZXRDdXJyZW50KCk7XG5cbiAgICAgIGlmICh0aGlzLnNob3dHcmlkKSB7XG4gICAgICAgIGZyb20gPSBuZXcgUG9pbnQzZCh4UmFuZ2UubWluLCB5LCB6UmFuZ2UubWluKTtcbiAgICAgICAgdG8gPSBuZXcgUG9pbnQzZCh4UmFuZ2UubWF4LCB5LCB6UmFuZ2UubWluKTtcbiAgICAgICAgdGhpcy5fbGluZTNkKGN0eCwgZnJvbSwgdG8sIHRoaXMuZ3JpZENvbG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyb20gPSBuZXcgUG9pbnQzZCh4UmFuZ2UubWluLCB5LCB6UmFuZ2UubWluKTtcbiAgICAgICAgdG8gPSBuZXcgUG9pbnQzZCh4UmFuZ2UubWluICsgZ3JpZExlblksIHksIHpSYW5nZS5taW4pO1xuICAgICAgICB0aGlzLl9saW5lM2QoY3R4LCBmcm9tLCB0bywgdGhpcy5heGlzQ29sb3IpO1xuXG4gICAgICAgIGZyb20gPSBuZXcgUG9pbnQzZCh4UmFuZ2UubWF4LCB5LCB6UmFuZ2UubWluKTtcbiAgICAgICAgdG8gPSBuZXcgUG9pbnQzZCh4UmFuZ2UubWF4IC0gZ3JpZExlblksIHksIHpSYW5nZS5taW4pO1xuICAgICAgICB0aGlzLl9saW5lM2QoY3R4LCBmcm9tLCB0bywgdGhpcy5heGlzQ29sb3IpO1xuICAgICAgfVxuXG4gICAgICB4VGV4dCA9IGFybVZlY3Rvci55ID4gMCA/IHhSYW5nZS5taW4gOiB4UmFuZ2UubWF4O1xuICAgICAgcG9pbnQzZCA9IG5ldyBQb2ludDNkKHhUZXh0LCB5LCB6UmFuZ2UubWluKTtcbiAgICAgIHZhciBtc2cgPSAnICAnICsgdGhpcy55VmFsdWVMYWJlbCh5KSArICcgICc7XG4gICAgICB0aGlzLmRyYXdBeGlzTGFiZWxZKGN0eCwgcG9pbnQzZCwgbXNnLCBhcm1BbmdsZSwgdGV4dE1hcmdpbik7XG5cbiAgICAgIHN0ZXAubmV4dCgpO1xuICAgIH1cblxuICAgIC8vIGRyYXcgei1ncmlkIGxpbmVzIGFuZCBheGlzXG4gICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgcHJldHR5U3RlcCA9IHRoaXMuZGVmYXVsdFpTdGVwID09PSB1bmRlZmluZWQ7XG4gICAgc3RlcCA9IG5ldyBTdGVwTnVtYmVyKHpSYW5nZS5taW4sIHpSYW5nZS5tYXgsIHRoaXMuelN0ZXAsIHByZXR0eVN0ZXApO1xuICAgIHN0ZXAuc3RhcnQodHJ1ZSk7XG5cbiAgICB4VGV4dCA9IGFybVZlY3Rvci54ID4gMCA/IHhSYW5nZS5taW4gOiB4UmFuZ2UubWF4O1xuICAgIHlUZXh0ID0gYXJtVmVjdG9yLnkgPCAwID8geVJhbmdlLm1pbiA6IHlSYW5nZS5tYXg7XG5cbiAgICB3aGlsZSAoIXN0ZXAuZW5kKCkpIHtcbiAgICAgIHZhciB6ID0gc3RlcC5nZXRDdXJyZW50KCk7XG5cbiAgICAgIC8vIFRPRE86IG1ha2Ugei1ncmlkIGxpbmVzIHJlYWxseSAzZD9cbiAgICAgIHZhciBmcm9tM2QgPSBuZXcgUG9pbnQzZCh4VGV4dCwgeVRleHQsIHopO1xuICAgICAgdmFyIGZyb20yZCA9IHRoaXMuX2NvbnZlcnQzRHRvMkQoZnJvbTNkKTtcbiAgICAgIHRvID0gbmV3IFBvaW50MmQoZnJvbTJkLnggLSB0ZXh0TWFyZ2luLCBmcm9tMmQueSk7XG4gICAgICB0aGlzLl9saW5lKGN0eCwgZnJvbTJkLCB0bywgdGhpcy5heGlzQ29sb3IpO1xuXG4gICAgICB2YXIgbXNnID0gdGhpcy56VmFsdWVMYWJlbCh6KSArICcgJztcbiAgICAgIHRoaXMuZHJhd0F4aXNMYWJlbFooY3R4LCBmcm9tM2QsIG1zZywgNSk7XG5cbiAgICAgIHN0ZXAubmV4dCgpO1xuICAgIH1cblxuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIGZyb20gPSBuZXcgUG9pbnQzZCh4VGV4dCwgeVRleHQsIHpSYW5nZS5taW4pO1xuICAgIHRvID0gbmV3IFBvaW50M2QoeFRleHQsIHlUZXh0LCB6UmFuZ2UubWF4KTtcbiAgICB0aGlzLl9saW5lM2QoY3R4LCBmcm9tLCB0bywgdGhpcy5heGlzQ29sb3IpO1xuXG4gICAgLy8gZHJhdyB4LWF4aXNcbiAgICB2YXIgeE1pbjJkO1xuICAgIHZhciB4TWF4MmQ7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDE7XG5cbiAgICAvLyBsaW5lIGF0IHlNaW5cbiAgICB4TWluMmQgPSBuZXcgUG9pbnQzZCh4UmFuZ2UubWluLCB5UmFuZ2UubWluLCB6UmFuZ2UubWluKTtcbiAgICB4TWF4MmQgPSBuZXcgUG9pbnQzZCh4UmFuZ2UubWF4LCB5UmFuZ2UubWluLCB6UmFuZ2UubWluKTtcbiAgICB0aGlzLl9saW5lM2QoY3R4LCB4TWluMmQsIHhNYXgyZCwgdGhpcy5heGlzQ29sb3IpO1xuICAgIC8vIGxpbmUgYXQgeW1heFxuICAgIHhNaW4yZCA9IG5ldyBQb2ludDNkKHhSYW5nZS5taW4sIHlSYW5nZS5tYXgsIHpSYW5nZS5taW4pO1xuICAgIHhNYXgyZCA9IG5ldyBQb2ludDNkKHhSYW5nZS5tYXgsIHlSYW5nZS5tYXgsIHpSYW5nZS5taW4pO1xuICAgIHRoaXMuX2xpbmUzZChjdHgsIHhNaW4yZCwgeE1heDJkLCB0aGlzLmF4aXNDb2xvcik7XG5cbiAgICAvLyBkcmF3IHktYXhpc1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIC8vIGxpbmUgYXQgeE1pblxuICAgIGZyb20gPSBuZXcgUG9pbnQzZCh4UmFuZ2UubWluLCB5UmFuZ2UubWluLCB6UmFuZ2UubWluKTtcbiAgICB0byA9IG5ldyBQb2ludDNkKHhSYW5nZS5taW4sIHlSYW5nZS5tYXgsIHpSYW5nZS5taW4pO1xuICAgIHRoaXMuX2xpbmUzZChjdHgsIGZyb20sIHRvLCB0aGlzLmF4aXNDb2xvcik7XG4gICAgLy8gbGluZSBhdCB4TWF4XG4gICAgZnJvbSA9IG5ldyBQb2ludDNkKHhSYW5nZS5tYXgsIHlSYW5nZS5taW4sIHpSYW5nZS5taW4pO1xuICAgIHRvID0gbmV3IFBvaW50M2QoeFJhbmdlLm1heCwgeVJhbmdlLm1heCwgelJhbmdlLm1pbik7XG4gICAgdGhpcy5fbGluZTNkKGN0eCwgZnJvbSwgdG8sIHRoaXMuYXhpc0NvbG9yKTtcblxuICAgIC8vIGRyYXcgeC1sYWJlbFxuICAgIHZhciB4TGFiZWwgPSB0aGlzLnhMYWJlbDtcbiAgICBpZiAoeExhYmVsLmxlbmd0aCA+IDApIHtcbiAgICAgIHlPZmZzZXQgPSAwLjEgLyB0aGlzLnNjYWxlLnk7XG4gICAgICB4VGV4dCA9IHhSYW5nZS5jZW50ZXIoKSAvIDI7XG4gICAgICB5VGV4dCA9IGFybVZlY3Rvci54ID4gMCA/IHlSYW5nZS5taW4gLSB5T2Zmc2V0IDogeVJhbmdlLm1heCArIHlPZmZzZXQ7XG4gICAgICB0ZXh0ID0gbmV3IFBvaW50M2QoeFRleHQsIHlUZXh0LCB6UmFuZ2UubWluKTtcbiAgICAgIHRoaXMuZHJhd0F4aXNMYWJlbFgoY3R4LCB0ZXh0LCB4TGFiZWwsIGFybUFuZ2xlKTtcbiAgICB9XG5cbiAgICAvLyBkcmF3IHktbGFiZWxcbiAgICB2YXIgeUxhYmVsID0gdGhpcy55TGFiZWw7XG4gICAgaWYgKHlMYWJlbC5sZW5ndGggPiAwKSB7XG4gICAgICB4T2Zmc2V0ID0gMC4xIC8gdGhpcy5zY2FsZS54O1xuICAgICAgeFRleHQgPSBhcm1WZWN0b3IueSA+IDAgPyB4UmFuZ2UubWluIC0geE9mZnNldCA6IHhSYW5nZS5tYXggKyB4T2Zmc2V0O1xuICAgICAgeVRleHQgPSB5UmFuZ2UuY2VudGVyKCkgLyAyO1xuICAgICAgdGV4dCA9IG5ldyBQb2ludDNkKHhUZXh0LCB5VGV4dCwgelJhbmdlLm1pbik7XG5cbiAgICAgIHRoaXMuZHJhd0F4aXNMYWJlbFkoY3R4LCB0ZXh0LCB5TGFiZWwsIGFybUFuZ2xlKTtcbiAgICB9XG5cbiAgICAvLyBkcmF3IHotbGFiZWxcbiAgICB2YXIgekxhYmVsID0gdGhpcy56TGFiZWw7XG4gICAgaWYgKHpMYWJlbC5sZW5ndGggPiAwKSB7XG4gICAgICBvZmZzZXQgPSAzMDsgLy8gcGl4ZWxzLiAgLy8gVE9ETzogcmVsYXRlIHRvIHRoZSBtYXggd2lkdGggb2YgdGhlIHZhbHVlcyBvbiB0aGUgeiBheGlzP1xuICAgICAgeFRleHQgPSBhcm1WZWN0b3IueCA+IDAgPyB4UmFuZ2UubWluIDogeFJhbmdlLm1heDtcbiAgICAgIHlUZXh0ID0gYXJtVmVjdG9yLnkgPCAwID8geVJhbmdlLm1pbiA6IHlSYW5nZS5tYXg7XG4gICAgICB6VGV4dCA9IHpSYW5nZS5jZW50ZXIoKSAvIDI7XG4gICAgICB0ZXh0ID0gbmV3IFBvaW50M2QoeFRleHQsIHlUZXh0LCB6VGV4dCk7XG5cbiAgICAgIHRoaXMuZHJhd0F4aXNMYWJlbFooY3R4LCB0ZXh0LCB6TGFiZWwsIG9mZnNldCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNvbG9yIGJhc2VkIG9uIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IEggICBIdWUsIGEgdmFsdWUgYmUgYmV0d2VlbiAwIGFuZCAzNjBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFMgICBTYXR1cmF0aW9uLCBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMVxuICAgKiBAcGFyYW0ge051bWJlcn0gViAgIFZhbHVlLCBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMVxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX2hzdjJyZ2IgPSBmdW5jdGlvbiAoSCwgUywgVikge1xuICAgIHZhciBSLCBHLCBCLCBDLCBIaSwgWDtcblxuICAgIEMgPSBWICogUztcbiAgICBIaSA9IE1hdGguZmxvb3IoSCAvIDYwKTsgLy8gaGkgPSAwLDEsMiwzLDQsNVxuICAgIFggPSBDICogKDEgLSBNYXRoLmFicyhIIC8gNjAgJSAyIC0gMSkpO1xuXG4gICAgc3dpdGNoIChIaSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBSID0gQztHID0gWDtCID0gMDticmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgUiA9IFg7RyA9IEM7QiA9IDA7YnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIFIgPSAwO0cgPSBDO0IgPSBYO2JyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBSID0gMDtHID0gWDtCID0gQzticmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgUiA9IFg7RyA9IDA7QiA9IEM7YnJlYWs7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIFIgPSBDO0cgPSAwO0IgPSBYO2JyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBSID0gMDtHID0gMDtCID0gMDticmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gJ1JHQignICsgcGFyc2VJbnQoUiAqIDI1NSkgKyAnLCcgKyBwYXJzZUludChHICogMjU1KSArICcsJyArIHBhcnNlSW50KEIgKiAyNTUpICsgJyknO1xuICB9O1xuXG4gIEdyYXBoM2QucHJvdG90eXBlLl9nZXRTdHJva2VXaWR0aCA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIGlmIChwb2ludCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy5zaG93UGVyc3BlY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIDEgLyAtcG9pbnQudHJhbnMueiAqIHRoaXMuZGF0YUNvbG9yLnN0cm9rZVdpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0odGhpcy5leWUueiAvIHRoaXMuY2FtZXJhLmdldEFybUxlbmd0aCgpKSAqIHRoaXMuZGF0YUNvbG9yLnN0cm9rZVdpZHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRhdGFDb2xvci5zdHJva2VXaWR0aDtcbiAgfTtcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBEcmF3aW5nIHByaW1pdGl2ZXMgZm9yIHRoZSBncmFwaHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gIC8qKlxuICAgKiBEcmF3IGEgYmFyIGVsZW1lbnQgaW4gdGhlIHZpZXcgd2l0aCB0aGUgZ2l2ZW4gcHJvcGVydGllcy5cbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9yZWRyYXdCYXIgPSBmdW5jdGlvbiAoY3R4LCBwb2ludCwgeFdpZHRoLCB5V2lkdGgsIGNvbG9yLCBib3JkZXJDb2xvcikge1xuICAgIHZhciBpLCBqLCBzdXJmYWNlO1xuXG4gICAgLy8gY2FsY3VsYXRlIGFsbCBjb3JuZXIgcG9pbnRzXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgcG9pbnQzZCA9IHBvaW50LnBvaW50O1xuICAgIHZhciB6TWluID0gdGhpcy56UmFuZ2UubWluO1xuICAgIHZhciB0b3AgPSBbeyBwb2ludDogbmV3IFBvaW50M2QocG9pbnQzZC54IC0geFdpZHRoLCBwb2ludDNkLnkgLSB5V2lkdGgsIHBvaW50M2QueikgfSwgeyBwb2ludDogbmV3IFBvaW50M2QocG9pbnQzZC54ICsgeFdpZHRoLCBwb2ludDNkLnkgLSB5V2lkdGgsIHBvaW50M2QueikgfSwgeyBwb2ludDogbmV3IFBvaW50M2QocG9pbnQzZC54ICsgeFdpZHRoLCBwb2ludDNkLnkgKyB5V2lkdGgsIHBvaW50M2QueikgfSwgeyBwb2ludDogbmV3IFBvaW50M2QocG9pbnQzZC54IC0geFdpZHRoLCBwb2ludDNkLnkgKyB5V2lkdGgsIHBvaW50M2QueikgfV07XG4gICAgdmFyIGJvdHRvbSA9IFt7IHBvaW50OiBuZXcgUG9pbnQzZChwb2ludDNkLnggLSB4V2lkdGgsIHBvaW50M2QueSAtIHlXaWR0aCwgek1pbikgfSwgeyBwb2ludDogbmV3IFBvaW50M2QocG9pbnQzZC54ICsgeFdpZHRoLCBwb2ludDNkLnkgLSB5V2lkdGgsIHpNaW4pIH0sIHsgcG9pbnQ6IG5ldyBQb2ludDNkKHBvaW50M2QueCArIHhXaWR0aCwgcG9pbnQzZC55ICsgeVdpZHRoLCB6TWluKSB9LCB7IHBvaW50OiBuZXcgUG9pbnQzZChwb2ludDNkLnggLSB4V2lkdGgsIHBvaW50M2QueSArIHlXaWR0aCwgek1pbikgfV07XG5cbiAgICAvLyBjYWxjdWxhdGUgc2NyZWVuIGxvY2F0aW9uIG9mIHRoZSBwb2ludHNcbiAgICB0b3AuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICBvYmouc2NyZWVuID0gbWUuX2NvbnZlcnQzRHRvMkQob2JqLnBvaW50KTtcbiAgICB9KTtcbiAgICBib3R0b20uZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICBvYmouc2NyZWVuID0gbWUuX2NvbnZlcnQzRHRvMkQob2JqLnBvaW50KTtcbiAgICB9KTtcblxuICAgIC8vIGNyZWF0ZSBmaXZlIHNpZGVzLCBjYWxjdWxhdGUgYm90aCBjb3JuZXIgcG9pbnRzIGFuZCBjZW50ZXIgcG9pbnRzXG4gICAgdmFyIHN1cmZhY2VzID0gW3sgY29ybmVyczogdG9wLCBjZW50ZXI6IFBvaW50M2QuYXZnKGJvdHRvbVswXS5wb2ludCwgYm90dG9tWzJdLnBvaW50KSB9LCB7IGNvcm5lcnM6IFt0b3BbMF0sIHRvcFsxXSwgYm90dG9tWzFdLCBib3R0b21bMF1dLCBjZW50ZXI6IFBvaW50M2QuYXZnKGJvdHRvbVsxXS5wb2ludCwgYm90dG9tWzBdLnBvaW50KSB9LCB7IGNvcm5lcnM6IFt0b3BbMV0sIHRvcFsyXSwgYm90dG9tWzJdLCBib3R0b21bMV1dLCBjZW50ZXI6IFBvaW50M2QuYXZnKGJvdHRvbVsyXS5wb2ludCwgYm90dG9tWzFdLnBvaW50KSB9LCB7IGNvcm5lcnM6IFt0b3BbMl0sIHRvcFszXSwgYm90dG9tWzNdLCBib3R0b21bMl1dLCBjZW50ZXI6IFBvaW50M2QuYXZnKGJvdHRvbVszXS5wb2ludCwgYm90dG9tWzJdLnBvaW50KSB9LCB7IGNvcm5lcnM6IFt0b3BbM10sIHRvcFswXSwgYm90dG9tWzBdLCBib3R0b21bM11dLCBjZW50ZXI6IFBvaW50M2QuYXZnKGJvdHRvbVswXS5wb2ludCwgYm90dG9tWzNdLnBvaW50KSB9XTtcbiAgICBwb2ludC5zdXJmYWNlcyA9IHN1cmZhY2VzO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBvZiBlYWNoIG9mIHRoZSBzdXJmYWNlIGNlbnRlcnMgdG8gdGhlIGNhbWVyYVxuICAgIGZvciAoaiA9IDA7IGogPCBzdXJmYWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgc3VyZmFjZSA9IHN1cmZhY2VzW2pdO1xuICAgICAgdmFyIHRyYW5zQ2VudGVyID0gdGhpcy5fY29udmVydFBvaW50VG9UcmFuc2xhdGlvbihzdXJmYWNlLmNlbnRlcik7XG4gICAgICBzdXJmYWNlLmRpc3QgPSB0aGlzLnNob3dQZXJzcGVjdGl2ZSA/IHRyYW5zQ2VudGVyLmxlbmd0aCgpIDogLXRyYW5zQ2VudGVyLno7XG4gICAgICAvLyBUT0RPOiB0aGlzIGRlcHQgY2FsY3VsYXRpb24gZG9lc24ndCB3b3JrIDEwMCUgb2YgdGhlIGNhc2VzIGR1ZSB0byBwZXJzcGVjdGl2ZSxcbiAgICAgIC8vICAgICBidXQgdGhlIGN1cnJlbnQgc29sdXRpb24gaXMgZmFzdC9zaW1wbGUgYW5kIHdvcmtzIGluIDk5LjklIG9mIGFsbCBjYXNlc1xuICAgICAgLy8gICAgIHRoZSBpc3N1ZSBpcyB2aXNpYmxlIGluIGV4YW1wbGUgMTQsIHdpdGggZ3JhcGguc2V0Q2FtZXJhUG9zaXRpb24oe2hvcml6b250YWw6IDIuOTcsIHZlcnRpY2FsOiAwLjUsIGRpc3RhbmNlOiAwLjl9KVxuICAgIH1cblxuICAgIC8vIG9yZGVyIHRoZSBzdXJmYWNlcyBieSB0aGVpciAodHJhbnNsYXRlZCkgZGVwdGhcbiAgICBzdXJmYWNlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgZGlmZiA9IGIuZGlzdCAtIGEuZGlzdDtcbiAgICAgIGlmIChkaWZmKSByZXR1cm4gZGlmZjtcblxuICAgICAgLy8gaWYgZXF1YWwgZGVwdGgsIHNvcnQgdGhlIHRvcCBzdXJmYWNlIGxhc3RcbiAgICAgIGlmIChhLmNvcm5lcnMgPT09IHRvcCkgcmV0dXJuIDE7XG4gICAgICBpZiAoYi5jb3JuZXJzID09PSB0b3ApIHJldHVybiAtMTtcblxuICAgICAgLy8gYm90aCBhcmUgZXF1YWxcbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuXG4gICAgLy8gZHJhdyB0aGUgb3JkZXJlZCBzdXJmYWNlc1xuICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLl9nZXRTdHJva2VXaWR0aChwb2ludCk7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyQ29sb3I7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIC8vIE5PVEU6IHdlIHN0YXJ0IGF0IGo9MiBpbnN0ZWFkIG9mIGo9MCBhcyB3ZSBkb24ndCBuZWVkIHRvIGRyYXcgdGhlIHR3byBzdXJmYWNlcyBhdCB0aGUgYmFja3NpZGVcbiAgICBmb3IgKGogPSAyOyBqIDwgc3VyZmFjZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHN1cmZhY2UgPSBzdXJmYWNlc1tqXTtcbiAgICAgIHRoaXMuX3BvbHlnb24oY3R4LCBzdXJmYWNlLmNvcm5lcnMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRHJhdyBhIHBvbHlnb24gdXNpbmcgdGhlIHBhc3NlZCBwb2ludHMgYW5kIGZpbGwgaXQgd2l0aCB0aGUgcGFzc2VkIHN0eWxlIGFuZCBzdHJva2UuXG4gICAqXG4gICAqIEBwYXJhbSBwb2ludHMgICAgICBhbiBhcnJheSBvZiBwb2ludHMuIFxuICAgKiBAcGFyYW0gZmlsbFN0eWxlICAgb3B0aW9uYWw7IHRoZSBmaWxsIHN0eWxlIHRvIHNldFxuICAgKiBAcGFyYW0gc3Ryb2tlU3R5bGUgb3B0aW9uYWw7IHRoZSBzdHJva2Ugc3R5bGUgdG8gc2V0XG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fcG9seWdvbiA9IGZ1bmN0aW9uIChjdHgsIHBvaW50cywgZmlsbFN0eWxlLCBzdHJva2VTdHlsZSkge1xuICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChmaWxsU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICB9XG4gICAgaWYgKHN0cm9rZVN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgIH1cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyhwb2ludHNbMF0uc2NyZWVuLngsIHBvaW50c1swXS5zY3JlZW4ueSk7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY3R4LmxpbmVUbyhwb2ludC5zY3JlZW4ueCwgcG9pbnQuc2NyZWVuLnkpO1xuICAgIH1cblxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbCgpO1xuICAgIGN0eC5zdHJva2UoKTsgLy8gVE9ETzogb25seSBkcmF3IHN0cm9rZSB3aGVuIHN0cm9rZVdpZHRoID4gMFxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gc2l6ZSBvcHRpb25hbDsgaWYgbm90IHNwZWNpZmllZCB1c2UgdmFsdWUgZnJvbSAndGhpcy5fZG90U2l6ZSgpYFxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX2RyYXdDaXJjbGUgPSBmdW5jdGlvbiAoY3R4LCBwb2ludCwgY29sb3IsIGJvcmRlckNvbG9yLCBzaXplKSB7XG4gICAgdmFyIHJhZGl1cyA9IHRoaXMuX2NhbGNSYWRpdXMocG9pbnQsIHNpemUpO1xuXG4gICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuX2dldFN0cm9rZVdpZHRoKHBvaW50KTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMocG9pbnQuc2NyZWVuLngsIHBvaW50LnNjcmVlbi55LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICBjdHguZmlsbCgpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSBjb2xvcnMgZm9yIHRoZSAncmVndWxhcicgZ3JhcGggc3R5bGVzLlxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX2dldENvbG9yc1JlZ3VsYXIgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAvLyBjYWxjdWxhdGUgSHVlIGZyb20gdGhlIGN1cnJlbnQgdmFsdWUuIEF0IHpNaW4gdGhlIGh1ZSBpcyAyNDAsIGF0IHpNYXggdGhlIGh1ZSBpcyAwXG4gICAgdmFyIGh1ZSA9ICgxIC0gKHBvaW50LnBvaW50LnogLSB0aGlzLnpSYW5nZS5taW4pICogdGhpcy5zY2FsZS56IC8gdGhpcy52ZXJ0aWNhbFJhdGlvKSAqIDI0MDtcbiAgICB2YXIgY29sb3IgPSB0aGlzLl9oc3YycmdiKGh1ZSwgMSwgMSk7XG4gICAgdmFyIGJvcmRlckNvbG9yID0gdGhpcy5faHN2MnJnYihodWUsIDEsIDAuOCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZmlsbDogY29sb3IsXG4gICAgICBib3JkZXI6IGJvcmRlckNvbG9yXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjb2xvcnMgZm9yIHRoZSAnY29sb3InIGdyYXBoIHN0eWxlcy5cbiAgICogVGhlc2Ugc3R5bGVzIGFyZSBjdXJyZW50bHk6ICdiYXItY29sb3InIGFuZCAnZG90LWNvbG9yJ1xuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX2dldENvbG9yc0NvbG9yID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSBjb2xvciBiYXNlZCBvbiB0aGUgdmFsdWVcbiAgICB2YXIgaHVlID0gKDEgLSAocG9pbnQucG9pbnQudmFsdWUgLSB0aGlzLnZhbHVlUmFuZ2UubWluKSAqIHRoaXMuc2NhbGUudmFsdWUpICogMjQwO1xuICAgIHZhciBjb2xvciA9IHRoaXMuX2hzdjJyZ2IoaHVlLCAxLCAxKTtcbiAgICB2YXIgYm9yZGVyQ29sb3IgPSB0aGlzLl9oc3YycmdiKGh1ZSwgMSwgMC44KTtcblxuICAgIHJldHVybiB7XG4gICAgICBmaWxsOiBjb2xvcixcbiAgICAgIGJvcmRlcjogYm9yZGVyQ29sb3JcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbG9ycyBmb3IgdGhlICdzaXplJyBncmFwaCBzdHlsZXMuXG4gICAqIFRoZXNlIHN0eWxlcyBhcmUgY3VycmVudGx5OiAnYmFyLXNpemUnIGFuZCAnZG90LXNpemUnXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fZ2V0Q29sb3JzU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbDogdGhpcy5kYXRhQ29sb3IuZmlsbCxcbiAgICAgIGJvcmRlcjogdGhpcy5kYXRhQ29sb3Iuc3Ryb2tlXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSBzaXplIG9mIGEgcG9pbnQgb24tc2NyZWVuLCBhcyBkZXRlcm1pbmVkIGJ5IHRoZVxuICAgKiBkaXN0YW5jZSB0byB0aGUgY2FtZXJhLlxuICAgKlxuICAgKiBAcGFyYW0gc2l6ZSB0aGUgc2l6ZSB0aGF0IG5lZWRzIHRvIGJlIHRyYW5zbGF0ZWQgdG8gc2NyZWVuIGNvb3JkaW5hdGVzLlxuICAgKiAgICAgICAgICAgICBvcHRpb25hbDsgaWYgbm90IHBhc3NlZCwgdXNlIHRoZSBkZWZhdWx0IHBvaW50IHNpemUuXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fY2FsY1JhZGl1cyA9IGZ1bmN0aW9uIChwb2ludCwgc2l6ZSkge1xuICAgIGlmIChzaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNpemUgPSB0aGlzLl9kb3RTaXplKCk7XG4gICAgfVxuXG4gICAgdmFyIHJhZGl1cztcbiAgICBpZiAodGhpcy5zaG93UGVyc3BlY3RpdmUpIHtcbiAgICAgIHJhZGl1cyA9IHNpemUgLyAtcG9pbnQudHJhbnMuejtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFkaXVzID0gc2l6ZSAqIC0odGhpcy5leWUueiAvIHRoaXMuY2FtZXJhLmdldEFybUxlbmd0aCgpKTtcbiAgICB9XG4gICAgaWYgKHJhZGl1cyA8IDApIHtcbiAgICAgIHJhZGl1cyA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhZGl1cztcbiAgfTtcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBNZXRob2RzIGZvciBkcmF3aW5nIHBvaW50cyBwZXIgZ3JhcGggc3R5bGUuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAvKipcbiAgICogRHJhdyBzaW5nbGUgZGF0YXBvaW50IGZvciBncmFwaCBzdHlsZSAnYmFyJy5cbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9yZWRyYXdCYXJHcmFwaFBvaW50ID0gZnVuY3Rpb24gKGN0eCwgcG9pbnQpIHtcbiAgICB2YXIgeFdpZHRoID0gdGhpcy54QmFyV2lkdGggLyAyO1xuICAgIHZhciB5V2lkdGggPSB0aGlzLnlCYXJXaWR0aCAvIDI7XG4gICAgdmFyIGNvbG9ycyA9IHRoaXMuX2dldENvbG9yc1JlZ3VsYXIocG9pbnQpO1xuXG4gICAgdGhpcy5fcmVkcmF3QmFyKGN0eCwgcG9pbnQsIHhXaWR0aCwgeVdpZHRoLCBjb2xvcnMuZmlsbCwgY29sb3JzLmJvcmRlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIERyYXcgc2luZ2xlIGRhdGFwb2ludCBmb3IgZ3JhcGggc3R5bGUgJ2Jhci1jb2xvcicuXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fcmVkcmF3QmFyQ29sb3JHcmFwaFBvaW50ID0gZnVuY3Rpb24gKGN0eCwgcG9pbnQpIHtcbiAgICB2YXIgeFdpZHRoID0gdGhpcy54QmFyV2lkdGggLyAyO1xuICAgIHZhciB5V2lkdGggPSB0aGlzLnlCYXJXaWR0aCAvIDI7XG4gICAgdmFyIGNvbG9ycyA9IHRoaXMuX2dldENvbG9yc0NvbG9yKHBvaW50KTtcblxuICAgIHRoaXMuX3JlZHJhd0JhcihjdHgsIHBvaW50LCB4V2lkdGgsIHlXaWR0aCwgY29sb3JzLmZpbGwsIGNvbG9ycy5ib3JkZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEcmF3IHNpbmdsZSBkYXRhcG9pbnQgZm9yIGdyYXBoIHN0eWxlICdiYXItc2l6ZScuXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fcmVkcmF3QmFyU2l6ZUdyYXBoUG9pbnQgPSBmdW5jdGlvbiAoY3R4LCBwb2ludCkge1xuICAgIC8vIGNhbGN1bGF0ZSBzaXplIGZvciB0aGUgYmFyXG4gICAgdmFyIGZyYWN0aW9uID0gKHBvaW50LnBvaW50LnZhbHVlIC0gdGhpcy52YWx1ZVJhbmdlLm1pbikgLyB0aGlzLnZhbHVlUmFuZ2UucmFuZ2UoKTtcbiAgICB2YXIgeFdpZHRoID0gdGhpcy54QmFyV2lkdGggLyAyICogKGZyYWN0aW9uICogMC44ICsgMC4yKTtcbiAgICB2YXIgeVdpZHRoID0gdGhpcy55QmFyV2lkdGggLyAyICogKGZyYWN0aW9uICogMC44ICsgMC4yKTtcblxuICAgIHZhciBjb2xvcnMgPSB0aGlzLl9nZXRDb2xvcnNTaXplKCk7XG5cbiAgICB0aGlzLl9yZWRyYXdCYXIoY3R4LCBwb2ludCwgeFdpZHRoLCB5V2lkdGgsIGNvbG9ycy5maWxsLCBjb2xvcnMuYm9yZGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogRHJhdyBzaW5nbGUgZGF0YXBvaW50IGZvciBncmFwaCBzdHlsZSAnZG90Jy5cbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9yZWRyYXdEb3RHcmFwaFBvaW50ID0gZnVuY3Rpb24gKGN0eCwgcG9pbnQpIHtcbiAgICB2YXIgY29sb3JzID0gdGhpcy5fZ2V0Q29sb3JzUmVndWxhcihwb2ludCk7XG5cbiAgICB0aGlzLl9kcmF3Q2lyY2xlKGN0eCwgcG9pbnQsIGNvbG9ycy5maWxsLCBjb2xvcnMuYm9yZGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogRHJhdyBzaW5nbGUgZGF0YXBvaW50IGZvciBncmFwaCBzdHlsZSAnZG90LWxpbmUnLlxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX3JlZHJhd0RvdExpbmVHcmFwaFBvaW50ID0gZnVuY3Rpb24gKGN0eCwgcG9pbnQpIHtcbiAgICAvLyBkcmF3IGEgdmVydGljYWwgbGluZSBmcm9tIHRoZSBYWS1wbGFuZSB0byB0aGUgZ3JhcGggdmFsdWVcbiAgICB2YXIgZnJvbSA9IHRoaXMuX2NvbnZlcnQzRHRvMkQocG9pbnQuYm90dG9tKTtcbiAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICB0aGlzLl9saW5lKGN0eCwgZnJvbSwgcG9pbnQuc2NyZWVuLCB0aGlzLmdyaWRDb2xvcik7XG5cbiAgICB0aGlzLl9yZWRyYXdEb3RHcmFwaFBvaW50KGN0eCwgcG9pbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEcmF3IHNpbmdsZSBkYXRhcG9pbnQgZm9yIGdyYXBoIHN0eWxlICdkb3QtY29sb3InLlxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX3JlZHJhd0RvdENvbG9yR3JhcGhQb2ludCA9IGZ1bmN0aW9uIChjdHgsIHBvaW50KSB7XG4gICAgdmFyIGNvbG9ycyA9IHRoaXMuX2dldENvbG9yc0NvbG9yKHBvaW50KTtcblxuICAgIHRoaXMuX2RyYXdDaXJjbGUoY3R4LCBwb2ludCwgY29sb3JzLmZpbGwsIGNvbG9ycy5ib3JkZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEcmF3IHNpbmdsZSBkYXRhcG9pbnQgZm9yIGdyYXBoIHN0eWxlICdkb3Qtc2l6ZScuXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fcmVkcmF3RG90U2l6ZUdyYXBoUG9pbnQgPSBmdW5jdGlvbiAoY3R4LCBwb2ludCkge1xuICAgIHZhciBkb3RTaXplID0gdGhpcy5fZG90U2l6ZSgpO1xuICAgIHZhciBmcmFjdGlvbiA9IChwb2ludC5wb2ludC52YWx1ZSAtIHRoaXMudmFsdWVSYW5nZS5taW4pIC8gdGhpcy52YWx1ZVJhbmdlLnJhbmdlKCk7XG4gICAgdmFyIHNpemUgPSBkb3RTaXplIC8gMiArIDIgKiBkb3RTaXplICogZnJhY3Rpb247XG4gICAgdmFyIGNvbG9ycyA9IHRoaXMuX2dldENvbG9yc1NpemUoKTtcblxuICAgIHRoaXMuX2RyYXdDaXJjbGUoY3R4LCBwb2ludCwgY29sb3JzLmZpbGwsIGNvbG9ycy5ib3JkZXIsIHNpemUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEcmF3IHNpbmdsZSBkYXRhcG9pbnQgZm9yIGdyYXBoIHN0eWxlICdzdXJmYWNlJy5cbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9yZWRyYXdTdXJmYWNlR3JhcGhQb2ludCA9IGZ1bmN0aW9uIChjdHgsIHBvaW50KSB7XG4gICAgdmFyIHJpZ2h0ID0gcG9pbnQucG9pbnRSaWdodDtcbiAgICB2YXIgdG9wID0gcG9pbnQucG9pbnRUb3A7XG4gICAgdmFyIGNyb3NzID0gcG9pbnQucG9pbnRDcm9zcztcblxuICAgIGlmIChwb2ludCA9PT0gdW5kZWZpbmVkIHx8IHJpZ2h0ID09PSB1bmRlZmluZWQgfHwgdG9wID09PSB1bmRlZmluZWQgfHwgY3Jvc3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0b3BTaWRlVmlzaWJsZSA9IHRydWU7XG4gICAgdmFyIGZpbGxTdHlsZTtcbiAgICB2YXIgc3Ryb2tlU3R5bGU7XG4gICAgdmFyIGxpbmVXaWR0aDtcblxuICAgIGlmICh0aGlzLnNob3dHcmF5Qm90dG9tIHx8IHRoaXMuc2hvd1NoYWRvdykge1xuICAgICAgLy8gY2FsY3VsYXRlIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHRoZSB0d28gdmVjdG9ycyBmcm9tIGNlbnRlclxuICAgICAgLy8gdG8gbGVmdCBhbmQgcmlnaHQsIGluIG9yZGVyIHRvIGtub3cgd2hldGhlciB3ZSBhcmUgbG9va2luZyBhdCB0aGVcbiAgICAgIC8vIGJvdHRvbSBvciBhdCB0aGUgdG9wIHNpZGUuIFdlIGNhbiBhbHNvIHVzZSB0aGUgY3Jvc3MgcHJvZHVjdFxuICAgICAgLy8gZm9yIGNhbGN1bGF0aW5nIGxpZ2h0IGludGVuc2l0eVxuICAgICAgdmFyIGFEaWZmID0gUG9pbnQzZC5zdWJ0cmFjdChjcm9zcy50cmFucywgcG9pbnQudHJhbnMpO1xuICAgICAgdmFyIGJEaWZmID0gUG9pbnQzZC5zdWJ0cmFjdCh0b3AudHJhbnMsIHJpZ2h0LnRyYW5zKTtcbiAgICAgIHZhciBjcm9zc3Byb2R1Y3QgPSBQb2ludDNkLmNyb3NzUHJvZHVjdChhRGlmZiwgYkRpZmYpO1xuICAgICAgdmFyIGxlbiA9IGNyb3NzcHJvZHVjdC5sZW5ndGgoKTtcbiAgICAgIC8vIEZJWE1FOiB0aGVyZSBpcyBhIGJ1ZyB3aXRoIGRldGVybWluaW5nIHRoZSBzdXJmYWNlIHNpZGUgKHNoYWRvdyBvciBjb2xvcmVkKVxuXG4gICAgICB0b3BTaWRlVmlzaWJsZSA9IGNyb3NzcHJvZHVjdC56ID4gMDtcbiAgICB9XG5cbiAgICBpZiAodG9wU2lkZVZpc2libGUpIHtcblxuICAgICAgLy8gY2FsY3VsYXRlIEh1ZSBmcm9tIHRoZSBjdXJyZW50IHZhbHVlLiBBdCB6TWluIHRoZSBodWUgaXMgMjQwLCBhdCB6TWF4IHRoZSBodWUgaXMgMFxuICAgICAgdmFyIHpBdmcgPSAocG9pbnQucG9pbnQueiArIHJpZ2h0LnBvaW50LnogKyB0b3AucG9pbnQueiArIGNyb3NzLnBvaW50LnopIC8gNDtcbiAgICAgIHZhciBoID0gKDEgLSAoekF2ZyAtIHRoaXMuelJhbmdlLm1pbikgKiB0aGlzLnNjYWxlLnogLyB0aGlzLnZlcnRpY2FsUmF0aW8pICogMjQwO1xuICAgICAgdmFyIHMgPSAxOyAvLyBzYXR1cmF0aW9uXG4gICAgICB2YXIgdjtcblxuICAgICAgaWYgKHRoaXMuc2hvd1NoYWRvdykge1xuICAgICAgICB2ID0gTWF0aC5taW4oMSArIGNyb3NzcHJvZHVjdC54IC8gbGVuIC8gMiwgMSk7IC8vIHZhbHVlLiBUT0RPOiBzY2FsZVxuICAgICAgICBmaWxsU3R5bGUgPSB0aGlzLl9oc3YycmdiKGgsIHMsIHYpO1xuICAgICAgICBzdHJva2VTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYgPSAxO1xuICAgICAgICBmaWxsU3R5bGUgPSB0aGlzLl9oc3YycmdiKGgsIHMsIHYpO1xuICAgICAgICBzdHJva2VTdHlsZSA9IHRoaXMuYXhpc0NvbG9yOyAvLyBUT0RPOiBzaG91bGQgYmUgY3VzdG9taXphYmxlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbGxTdHlsZSA9ICdncmF5JztcbiAgICAgIHN0cm9rZVN0eWxlID0gdGhpcy5heGlzQ29sb3I7XG4gICAgfVxuXG4gICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuX2dldFN0cm9rZVdpZHRoKHBvaW50KTtcbiAgICAvLyBUT0RPOiBvbmx5IGRyYXcgc3Ryb2tlIHdoZW4gc3Ryb2tlV2lkdGggPiAwXG5cbiAgICB2YXIgcG9pbnRzID0gW3BvaW50LCByaWdodCwgY3Jvc3MsIHRvcF07XG4gICAgdGhpcy5fcG9seWdvbihjdHgsIHBvaW50cywgZmlsbFN0eWxlLCBzdHJva2VTdHlsZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhlbHBlciBtZXRob2QgZm9yIF9yZWRyYXdHcmlkR3JhcGhQb2ludCgpXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fZHJhd0dyaWRMaW5lID0gZnVuY3Rpb24gKGN0eCwgZnJvbSwgdG8pIHtcbiAgICBpZiAoZnJvbSA9PT0gdW5kZWZpbmVkIHx8IHRvID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgSHVlIGZyb20gdGhlIGN1cnJlbnQgdmFsdWUuIEF0IHpNaW4gdGhlIGh1ZSBpcyAyNDAsIGF0IHpNYXggdGhlIGh1ZSBpcyAwXG4gICAgdmFyIHpBdmcgPSAoZnJvbS5wb2ludC56ICsgdG8ucG9pbnQueikgLyAyO1xuICAgIHZhciBoID0gKDEgLSAoekF2ZyAtIHRoaXMuelJhbmdlLm1pbikgKiB0aGlzLnNjYWxlLnogLyB0aGlzLnZlcnRpY2FsUmF0aW8pICogMjQwO1xuXG4gICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuX2dldFN0cm9rZVdpZHRoKGZyb20pICogMjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLl9oc3YycmdiKGgsIDEsIDEpO1xuICAgIHRoaXMuX2xpbmUoY3R4LCBmcm9tLnNjcmVlbiwgdG8uc2NyZWVuKTtcbiAgfTtcblxuICAvKipcbiAgICogRHJhdyBzaW5nbGUgZGF0YXBvaW50IGZvciBncmFwaCBzdHlsZSAnR3JpZCcuXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fcmVkcmF3R3JpZEdyYXBoUG9pbnQgPSBmdW5jdGlvbiAoY3R4LCBwb2ludCkge1xuICAgIHRoaXMuX2RyYXdHcmlkTGluZShjdHgsIHBvaW50LCBwb2ludC5wb2ludFJpZ2h0KTtcbiAgICB0aGlzLl9kcmF3R3JpZExpbmUoY3R4LCBwb2ludCwgcG9pbnQucG9pbnRUb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEcmF3IHNpbmdsZSBkYXRhcG9pbnQgZm9yIGdyYXBoIHN0eWxlICdsaW5lJy5cbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9yZWRyYXdMaW5lR3JhcGhQb2ludCA9IGZ1bmN0aW9uIChjdHgsIHBvaW50KSB7XG4gICAgaWYgKHBvaW50LnBvaW50TmV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuX2dldFN0cm9rZVdpZHRoKHBvaW50KTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmRhdGFDb2xvci5zdHJva2U7XG5cbiAgICB0aGlzLl9saW5lKGN0eCwgcG9pbnQuc2NyZWVuLCBwb2ludC5wb2ludE5leHQuc2NyZWVuKTtcbiAgfTtcblxuICAvKipcbiAgICogRHJhdyBhbGwgZGF0YXBvaW50cyBmb3IgY3VycmVudGx5IHNlbGVjdGVkIGdyYXBoIHN0eWxlLlxuICAgKlxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX3JlZHJhd0RhdGFHcmFwaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5fZ2V0Q29udGV4dCgpO1xuICAgIHZhciBpO1xuXG4gICAgaWYgKHRoaXMuZGF0YVBvaW50cyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuZGF0YVBvaW50cy5sZW5ndGggPD0gMCkgcmV0dXJuOyAvLyBUT0RPOiB0aHJvdyBleGNlcHRpb24/XG5cbiAgICB0aGlzLl9jYWxjVHJhbnNsYXRpb25zKHRoaXMuZGF0YVBvaW50cyk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5kYXRhUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcG9pbnQgPSB0aGlzLmRhdGFQb2ludHNbaV07XG5cbiAgICAgIC8vIFVzaW5nIGNhbGwoKSBlbnN1cmVzIHRoYXQgdGhlIGNvcnJlY3QgY29udGV4dCBpcyB1c2VkXG4gICAgICB0aGlzLl9wb2ludERyYXdpbmdNZXRob2QuY2FsbCh0aGlzLCBjdHgsIHBvaW50KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gRW5kIG1ldGhvZHMgZm9yIGRyYXdpbmcgcG9pbnRzIHBlciBncmFwaCBzdHlsZS5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gIC8qKlxuICAgKiBTdGFydCBhIG1vdmluZyBvcGVyYXRpb24gaW5zaWRlIHRoZSBwcm92aWRlZCBwYXJlbnQgZWxlbWVudFxuICAgKiBAcGFyYW0ge0V2ZW50fSAgICAgZXZlbnQgICAgIFRoZSBldmVudCB0aGF0IG9jY3VycmVkIChyZXF1aXJlZCBmb3JcbiAgICogICAgICAgICAgICAgICAgICByZXRyaWV2aW5nIHRoZSAgbW91c2UgcG9zaXRpb24pXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fb25Nb3VzZURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcblxuICAgIC8vIGNoZWNrIGlmIG1vdXNlIGlzIHN0aWxsIGRvd24gKG1heSBiZSB1cCB3aGVuIGZvY3VzIGlzIGxvc3QgZm9yIGV4YW1wbGVcbiAgICAvLyBpbiBhbiBpZnJhbWUpXG4gICAgaWYgKHRoaXMubGVmdEJ1dHRvbkRvd24pIHtcbiAgICAgIHRoaXMuX29uTW91c2VVcChldmVudCk7XG4gICAgfVxuXG4gICAgLy8gb25seSByZWFjdCBvbiBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXG4gICAgdGhpcy5sZWZ0QnV0dG9uRG93biA9IGV2ZW50LndoaWNoID8gZXZlbnQud2hpY2ggPT09IDEgOiBldmVudC5idXR0b24gPT09IDE7XG4gICAgaWYgKCF0aGlzLmxlZnRCdXR0b25Eb3duICYmICF0aGlzLnRvdWNoRG93bikgcmV0dXJuO1xuXG4gICAgLy8gZ2V0IG1vdXNlIHBvc2l0aW9uIChkaWZmZXJlbnQgY29kZSBmb3IgSUUgYW5kIGFsbCBvdGhlciBicm93c2VycylcbiAgICB0aGlzLnN0YXJ0TW91c2VYID0gZ2V0TW91c2VYKGV2ZW50KTtcbiAgICB0aGlzLnN0YXJ0TW91c2VZID0gZ2V0TW91c2VZKGV2ZW50KTtcblxuICAgIHRoaXMuc3RhcnRTdGFydCA9IG5ldyBEYXRlKHRoaXMuc3RhcnQpO1xuICAgIHRoaXMuc3RhcnRFbmQgPSBuZXcgRGF0ZSh0aGlzLmVuZCk7XG4gICAgdGhpcy5zdGFydEFybVJvdGF0aW9uID0gdGhpcy5jYW1lcmEuZ2V0QXJtUm90YXRpb24oKTtcblxuICAgIHRoaXMuZnJhbWUuc3R5bGUuY3Vyc29yID0gJ21vdmUnO1xuXG4gICAgLy8gYWRkIGV2ZW50IGxpc3RlbmVycyB0byBoYW5kbGUgbW92aW5nIHRoZSBjb250ZW50c1xuICAgIC8vIHdlIHN0b3JlIHRoZSBmdW5jdGlvbiBvbm1vdXNlbW92ZSBhbmQgb25tb3VzZXVwIGluIHRoZSBncmFwaCwgc28gd2UgY2FuXG4gICAgLy8gcmVtb3ZlIHRoZSBldmVudGxpc3RlbmVycyBsYXRlcm9uIGluIHRoZSBmdW5jdGlvbiBtb3VzZVVwKClcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHRoaXMub25tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIG1lLl9vbk1vdXNlTW92ZShldmVudCk7XG4gICAgfTtcbiAgICB0aGlzLm9ubW91c2V1cCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgbWUuX29uTW91c2VVcChldmVudCk7XG4gICAgfTtcbiAgICB1dGlsLmFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCBtZS5vbm1vdXNlbW92ZSk7XG4gICAgdXRpbC5hZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LCAnbW91c2V1cCcsIG1lLm9ubW91c2V1cCk7XG4gICAgdXRpbC5wcmV2ZW50RGVmYXVsdChldmVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gbW92aW5nIG9wZXJhdGluZy5cbiAgICogVGhpcyBmdW5jdGlvbiBhY3RpdmF0ZWQgZnJvbSB3aXRoaW4gdGhlIGZ1bmNpb24gR3JhcGgubW91c2VEb3duKCkuXG4gICAqIEBwYXJhbSB7RXZlbnR9ICAgZXZlbnQgIFdlbGwsIGVlaGgsIHRoZSBldmVudFxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX29uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQgPSBldmVudCB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgICAvLyBjYWxjdWxhdGUgY2hhbmdlIGluIG1vdXNlIHBvc2l0aW9uXG4gICAgdmFyIGRpZmZYID0gcGFyc2VGbG9hdChnZXRNb3VzZVgoZXZlbnQpKSAtIHRoaXMuc3RhcnRNb3VzZVg7XG4gICAgdmFyIGRpZmZZID0gcGFyc2VGbG9hdChnZXRNb3VzZVkoZXZlbnQpKSAtIHRoaXMuc3RhcnRNb3VzZVk7XG5cbiAgICB2YXIgaG9yaXpvbnRhbE5ldyA9IHRoaXMuc3RhcnRBcm1Sb3RhdGlvbi5ob3Jpem9udGFsICsgZGlmZlggLyAyMDA7XG4gICAgdmFyIHZlcnRpY2FsTmV3ID0gdGhpcy5zdGFydEFybVJvdGF0aW9uLnZlcnRpY2FsICsgZGlmZlkgLyAyMDA7XG5cbiAgICB2YXIgc25hcEFuZ2xlID0gNDsgLy8gZGVncmVlc1xuICAgIHZhciBzbmFwVmFsdWUgPSBNYXRoLnNpbihzbmFwQW5nbGUgLyAzNjAgKiAyICogTWF0aC5QSSk7XG5cbiAgICAvLyBzbmFwIGhvcml6b250YWxseSB0byBuaWNlIGFuZ2xlcyBhdCAwcGksIDAuNXBpLCAxcGksIDEuNXBpLCBldGMuLi5cbiAgICAvLyB0aGUgLTAuMDAxIGlzIHRvIHRha2UgY2FyZSB0aGF0IHRoZSB2ZXJ0aWNhbCBheGlzIGlzIGFsd2F5cyBkcmF3biBhdCB0aGUgbGVmdCBmcm9udCBjb3JuZXJcbiAgICBpZiAoTWF0aC5hYnMoTWF0aC5zaW4oaG9yaXpvbnRhbE5ldykpIDwgc25hcFZhbHVlKSB7XG4gICAgICBob3Jpem9udGFsTmV3ID0gTWF0aC5yb3VuZChob3Jpem9udGFsTmV3IC8gTWF0aC5QSSkgKiBNYXRoLlBJIC0gMC4wMDE7XG4gICAgfVxuICAgIGlmIChNYXRoLmFicyhNYXRoLmNvcyhob3Jpem9udGFsTmV3KSkgPCBzbmFwVmFsdWUpIHtcbiAgICAgIGhvcml6b250YWxOZXcgPSAoTWF0aC5yb3VuZChob3Jpem9udGFsTmV3IC8gTWF0aC5QSSAtIDAuNSkgKyAwLjUpICogTWF0aC5QSSAtIDAuMDAxO1xuICAgIH1cblxuICAgIC8vIHNuYXAgdmVydGljYWxseSB0byBuaWNlIGFuZ2xlc1xuICAgIGlmIChNYXRoLmFicyhNYXRoLnNpbih2ZXJ0aWNhbE5ldykpIDwgc25hcFZhbHVlKSB7XG4gICAgICB2ZXJ0aWNhbE5ldyA9IE1hdGgucm91bmQodmVydGljYWxOZXcgLyBNYXRoLlBJKSAqIE1hdGguUEk7XG4gICAgfVxuICAgIGlmIChNYXRoLmFicyhNYXRoLmNvcyh2ZXJ0aWNhbE5ldykpIDwgc25hcFZhbHVlKSB7XG4gICAgICB2ZXJ0aWNhbE5ldyA9IChNYXRoLnJvdW5kKHZlcnRpY2FsTmV3IC8gTWF0aC5QSSAtIDAuNSkgKyAwLjUpICogTWF0aC5QSTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbWVyYS5zZXRBcm1Sb3RhdGlvbihob3Jpem9udGFsTmV3LCB2ZXJ0aWNhbE5ldyk7XG4gICAgdGhpcy5yZWRyYXcoKTtcblxuICAgIC8vIGZpcmUgYSBjYW1lcmFQb3NpdGlvbkNoYW5nZSBldmVudFxuICAgIHZhciBwYXJhbWV0ZXJzID0gdGhpcy5nZXRDYW1lcmFQb3NpdGlvbigpO1xuICAgIHRoaXMuZW1pdCgnY2FtZXJhUG9zaXRpb25DaGFuZ2UnLCBwYXJhbWV0ZXJzKTtcblxuICAgIHV0aWwucHJldmVudERlZmF1bHQoZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9wIG1vdmluZyBvcGVyYXRpbmcuXG4gICAqIFRoaXMgZnVuY3Rpb24gYWN0aXZhdGVkIGZyb20gd2l0aGluIHRoZSBmdW5jaW9uIEdyYXBoLm1vdXNlRG93bigpLlxuICAgKiBAcGFyYW0ge2V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9vbk1vdXNlVXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLmZyYW1lLnN0eWxlLmN1cnNvciA9ICdhdXRvJztcbiAgICB0aGlzLmxlZnRCdXR0b25Eb3duID0gZmFsc2U7XG5cbiAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGhlcmVcbiAgICB1dGlsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLm9ubW91c2Vtb3ZlKTtcbiAgICB1dGlsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5vbm1vdXNldXApO1xuICAgIHV0aWwucHJldmVudERlZmF1bHQoZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZnRlciBoYXZpbmcgbW92ZWQgdGhlIG1vdXNlLCBhIHRvb2x0aXAgc2hvdWxkIHBvcCB1cCB3aGVuIHRoZSBtb3VzZSBpcyByZXN0aW5nIG9uIGEgZGF0YSBwb2ludFxuICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBBIG1vdXNlIG1vdmUgZXZlbnRcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9vblRvb2x0aXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGVsYXkgPSAzMDA7IC8vIG1zXG4gICAgdmFyIGJvdW5kaW5nUmVjdCA9IHRoaXMuZnJhbWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIG1vdXNlWCA9IGdldE1vdXNlWChldmVudCkgLSBib3VuZGluZ1JlY3QubGVmdDtcbiAgICB2YXIgbW91c2VZID0gZ2V0TW91c2VZKGV2ZW50KSAtIGJvdW5kaW5nUmVjdC50b3A7XG5cbiAgICBpZiAoIXRoaXMuc2hvd1Rvb2x0aXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50b29sdGlwVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudG9vbHRpcFRpbWVvdXQpO1xuICAgIH1cblxuICAgIC8vIChkZWxheWVkKSBkaXNwbGF5IG9mIGEgdG9vbHRpcCBvbmx5IGlmIG5vIG1vdXNlIGJ1dHRvbiBpcyBkb3duXG4gICAgaWYgKHRoaXMubGVmdEJ1dHRvbkRvd24pIHtcbiAgICAgIHRoaXMuX2hpZGVUb29sdGlwKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudG9vbHRpcCAmJiB0aGlzLnRvb2x0aXAuZGF0YVBvaW50KSB7XG4gICAgICAvLyB0b29sdGlwIGlzIGN1cnJlbnRseSB2aXNpYmxlXG4gICAgICB2YXIgZGF0YVBvaW50ID0gdGhpcy5fZGF0YVBvaW50RnJvbVhZKG1vdXNlWCwgbW91c2VZKTtcbiAgICAgIGlmIChkYXRhUG9pbnQgIT09IHRoaXMudG9vbHRpcC5kYXRhUG9pbnQpIHtcbiAgICAgICAgLy8gZGF0YXBvaW50IGNoYW5nZWRcbiAgICAgICAgaWYgKGRhdGFQb2ludCkge1xuICAgICAgICAgIHRoaXMuX3Nob3dUb29sdGlwKGRhdGFQb2ludCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5faGlkZVRvb2x0aXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0b29sdGlwIGlzIGN1cnJlbnRseSBub3QgdmlzaWJsZVxuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHRoaXMudG9vbHRpcFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUudG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuXG4gICAgICAgIC8vIHNob3cgYSB0b29sdGlwIGlmIHdlIGhhdmUgYSBkYXRhIHBvaW50XG4gICAgICAgIHZhciBkYXRhUG9pbnQgPSBtZS5fZGF0YVBvaW50RnJvbVhZKG1vdXNlWCwgbW91c2VZKTtcbiAgICAgICAgaWYgKGRhdGFQb2ludCkge1xuICAgICAgICAgIG1lLl9zaG93VG9vbHRpcChkYXRhUG9pbnQpO1xuICAgICAgICB9XG4gICAgICB9LCBkZWxheSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciB0b3VjaHN0YXJ0IGV2ZW50IG9uIG1vYmlsZSBkZXZpY2VzXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fb25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy50b3VjaERvd24gPSB0cnVlO1xuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB0aGlzLm9udG91Y2htb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBtZS5fb25Ub3VjaE1vdmUoZXZlbnQpO1xuICAgIH07XG4gICAgdGhpcy5vbnRvdWNoZW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBtZS5fb25Ub3VjaEVuZChldmVudCk7XG4gICAgfTtcbiAgICB1dGlsLmFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCBtZS5vbnRvdWNobW92ZSk7XG4gICAgdXRpbC5hZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LCAndG91Y2hlbmQnLCBtZS5vbnRvdWNoZW5kKTtcblxuICAgIHRoaXMuX29uTW91c2VEb3duKGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgdG91Y2htb3ZlIGV2ZW50IG9uIG1vYmlsZSBkZXZpY2VzXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fb25Ub3VjaE1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLl9vbk1vdXNlTW92ZShldmVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIHRvdWNoZW5kIGV2ZW50IG9uIG1vYmlsZSBkZXZpY2VzXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fb25Ub3VjaEVuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMudG91Y2hEb3duID0gZmFsc2U7XG5cbiAgICB1dGlsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLm9udG91Y2htb3ZlKTtcbiAgICB1dGlsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMub250b3VjaGVuZCk7XG5cbiAgICB0aGlzLl9vbk1vdXNlVXAoZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBtb3VzZSB3aGVlbCBldmVudCwgdXNlZCB0byB6b29tIHRoZSBncmFwaFxuICAgKiBDb2RlIGZyb20gaHR0cDovL2Fkb21hcy5vcmcvamF2YXNjcmlwdC1tb3VzZS13aGVlbC9cbiAgICogQHBhcmFtIHtldmVudH0gIGV2ZW50ICAgVGhlIGV2ZW50XG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fb25XaGVlbCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICghZXZlbnQpIC8qIEZvciBJRS4gKi9cbiAgICAgIGV2ZW50ID0gd2luZG93LmV2ZW50O1xuXG4gICAgLy8gcmV0cmlldmUgZGVsdGFcbiAgICB2YXIgZGVsdGEgPSAwO1xuICAgIGlmIChldmVudC53aGVlbERlbHRhKSB7XG4gICAgICAvKiBJRS9PcGVyYS4gKi9cbiAgICAgIGRlbHRhID0gZXZlbnQud2hlZWxEZWx0YSAvIDEyMDtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LmRldGFpbCkge1xuICAgICAgLyogTW96aWxsYSBjYXNlLiAqL1xuICAgICAgLy8gSW4gTW96aWxsYSwgc2lnbiBvZiBkZWx0YSBpcyBkaWZmZXJlbnQgdGhhbiBpbiBJRS5cbiAgICAgIC8vIEFsc28sIGRlbHRhIGlzIG11bHRpcGxlIG9mIDMuXG4gICAgICBkZWx0YSA9IC1ldmVudC5kZXRhaWwgLyAzO1xuICAgIH1cblxuICAgIC8vIElmIGRlbHRhIGlzIG5vbnplcm8sIGhhbmRsZSBpdC5cbiAgICAvLyBCYXNpY2FsbHksIGRlbHRhIGlzIG5vdyBwb3NpdGl2ZSBpZiB3aGVlbCB3YXMgc2Nyb2xsZWQgdXAsXG4gICAgLy8gYW5kIG5lZ2F0aXZlLCBpZiB3aGVlbCB3YXMgc2Nyb2xsZWQgZG93bi5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIHZhciBvbGRMZW5ndGggPSB0aGlzLmNhbWVyYS5nZXRBcm1MZW5ndGgoKTtcbiAgICAgIHZhciBuZXdMZW5ndGggPSBvbGRMZW5ndGggKiAoMSAtIGRlbHRhIC8gMTApO1xuXG4gICAgICB0aGlzLmNhbWVyYS5zZXRBcm1MZW5ndGgobmV3TGVuZ3RoKTtcbiAgICAgIHRoaXMucmVkcmF3KCk7XG5cbiAgICAgIHRoaXMuX2hpZGVUb29sdGlwKCk7XG4gICAgfVxuXG4gICAgLy8gZmlyZSBhIGNhbWVyYVBvc2l0aW9uQ2hhbmdlIGV2ZW50XG4gICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLmdldENhbWVyYVBvc2l0aW9uKCk7XG4gICAgdGhpcy5lbWl0KCdjYW1lcmFQb3NpdGlvbkNoYW5nZScsIHBhcmFtZXRlcnMpO1xuXG4gICAgLy8gUHJldmVudCBkZWZhdWx0IGFjdGlvbnMgY2F1c2VkIGJ5IG1vdXNlIHdoZWVsLlxuICAgIC8vIFRoYXQgbWlnaHQgYmUgdWdseSwgYnV0IHdlIGhhbmRsZSBzY3JvbGxzIHNvbWVob3dcbiAgICAvLyBhbnl3YXksIHNvIGRvbid0IGJvdGhlciBoZXJlLi5cbiAgICB1dGlsLnByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIGEgcG9pbnQgbGllcyBpbnNpZGUgZ2l2ZW4gMkQgdHJpYW5nbGVcbiAgICpcbiAgICogQHBhcmFtICAge1BvaW50MmR9ICAgcG9pbnRcbiAgICogQHBhcmFtICAge1BvaW50MmRbXX0gdHJpYW5nbGVcbiAgICogQHJldHVybnMge2Jvb2xlYW59ICAgdHJ1ZSBpZiBnaXZlbiBwb2ludCBsaWVzIGluc2lkZSBvciBvbiB0aGUgZWRnZSBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGUsIGZhbHNlIG90aGVyd2lzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX2luc2lkZVRyaWFuZ2xlID0gZnVuY3Rpb24gKHBvaW50LCB0cmlhbmdsZSkge1xuICAgIHZhciBhID0gdHJpYW5nbGVbMF0sXG4gICAgICAgIGIgPSB0cmlhbmdsZVsxXSxcbiAgICAgICAgYyA9IHRyaWFuZ2xlWzJdO1xuXG4gICAgZnVuY3Rpb24gc2lnbih4KSB7XG4gICAgICByZXR1cm4geCA+IDAgPyAxIDogeCA8IDAgPyAtMSA6IDA7XG4gICAgfVxuXG4gICAgdmFyIGFzID0gc2lnbigoYi54IC0gYS54KSAqIChwb2ludC55IC0gYS55KSAtIChiLnkgLSBhLnkpICogKHBvaW50LnggLSBhLngpKTtcbiAgICB2YXIgYnMgPSBzaWduKChjLnggLSBiLngpICogKHBvaW50LnkgLSBiLnkpIC0gKGMueSAtIGIueSkgKiAocG9pbnQueCAtIGIueCkpO1xuICAgIHZhciBjcyA9IHNpZ24oKGEueCAtIGMueCkgKiAocG9pbnQueSAtIGMueSkgLSAoYS55IC0gYy55KSAqIChwb2ludC54IC0gYy54KSk7XG5cbiAgICAvLyBlYWNoIG9mIHRoZSB0aHJlZSBzaWducyBtdXN0IGJlIGVpdGhlciBlcXVhbCB0byBlYWNoIG90aGVyIG9yIHplcm9cbiAgICByZXR1cm4gKGFzID09IDAgfHwgYnMgPT0gMCB8fCBhcyA9PSBicykgJiYgKGJzID09IDAgfHwgY3MgPT0gMCB8fCBicyA9PSBjcykgJiYgKGFzID09IDAgfHwgY3MgPT0gMCB8fCBhcyA9PSBjcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbmQgYSBkYXRhIHBvaW50IGNsb3NlIHRvIGdpdmVuIHNjcmVlbiBwb3NpdGlvbiAoeCwgeSlcbiAgICpcbiAgICogQHBhcmFtICAge051bWJlcn0geFxuICAgKiBAcGFyYW0gICB7TnVtYmVyfSB5XG4gICAqIEByZXR1cm5zIHtPYmplY3QgfCBudWxsfSBUaGUgY2xvc2VzdCBkYXRhIHBvaW50IG9yIG51bGwgaWYgbm90IGNsb3NlIHRvIGFueVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSBwb2ludFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX2RhdGFQb2ludEZyb21YWSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIGksXG4gICAgICAgIGRpc3RNYXggPSAxMDAsXG4gICAgICAgIC8vIHB4XG4gICAgZGF0YVBvaW50ID0gbnVsbCxcbiAgICAgICAgY2xvc2VzdERhdGFQb2ludCA9IG51bGwsXG4gICAgICAgIGNsb3Nlc3REaXN0ID0gbnVsbCxcbiAgICAgICAgY2VudGVyID0gbmV3IFBvaW50MmQoeCwgeSk7XG5cbiAgICBpZiAodGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5CQVIgfHwgdGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5CQVJDT0xPUiB8fCB0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkJBUlNJWkUpIHtcbiAgICAgIC8vIHRoZSBkYXRhIHBvaW50cyBhcmUgb3JkZXJlZCBmcm9tIGZhciBhd2F5IHRvIGNsb3Nlc3RcbiAgICAgIGZvciAoaSA9IHRoaXMuZGF0YVBvaW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBkYXRhUG9pbnQgPSB0aGlzLmRhdGFQb2ludHNbaV07XG4gICAgICAgIHZhciBzdXJmYWNlcyA9IGRhdGFQb2ludC5zdXJmYWNlcztcbiAgICAgICAgaWYgKHN1cmZhY2VzKSB7XG4gICAgICAgICAgZm9yICh2YXIgcyA9IHN1cmZhY2VzLmxlbmd0aCAtIDE7IHMgPj0gMDsgcy0tKSB7XG4gICAgICAgICAgICAvLyBzcGxpdCBlYWNoIHN1cmZhY2UgaW4gdHdvIHRyaWFuZ2xlcywgYW5kIHNlZSBpZiB0aGUgY2VudGVyIHBvaW50IGlzIGluc2lkZSBvbmUgb2YgdGhlc2VcbiAgICAgICAgICAgIHZhciBzdXJmYWNlID0gc3VyZmFjZXNbc107XG4gICAgICAgICAgICB2YXIgY29ybmVycyA9IHN1cmZhY2UuY29ybmVycztcbiAgICAgICAgICAgIHZhciB0cmlhbmdsZTEgPSBbY29ybmVyc1swXS5zY3JlZW4sIGNvcm5lcnNbMV0uc2NyZWVuLCBjb3JuZXJzWzJdLnNjcmVlbl07XG4gICAgICAgICAgICB2YXIgdHJpYW5nbGUyID0gW2Nvcm5lcnNbMl0uc2NyZWVuLCBjb3JuZXJzWzNdLnNjcmVlbiwgY29ybmVyc1swXS5zY3JlZW5dO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luc2lkZVRyaWFuZ2xlKGNlbnRlciwgdHJpYW5nbGUxKSB8fCB0aGlzLl9pbnNpZGVUcmlhbmdsZShjZW50ZXIsIHRyaWFuZ2xlMikpIHtcbiAgICAgICAgICAgICAgLy8gcmV0dXJuIGltbWVkaWF0ZWx5IGF0IHRoZSBmaXJzdCBoaXRcbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGFQb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmluZCB0aGUgY2xvc2VzdCBkYXRhIHBvaW50LCB1c2luZyBkaXN0YW5jZSB0byB0aGUgY2VudGVyIG9mIHRoZSBwb2ludCBvbiAyZCBzY3JlZW5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmRhdGFQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YVBvaW50ID0gdGhpcy5kYXRhUG9pbnRzW2ldO1xuICAgICAgICB2YXIgcG9pbnQgPSBkYXRhUG9pbnQuc2NyZWVuO1xuICAgICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgICB2YXIgZGlzdFggPSBNYXRoLmFicyh4IC0gcG9pbnQueCk7XG4gICAgICAgICAgdmFyIGRpc3RZID0gTWF0aC5hYnMoeSAtIHBvaW50LnkpO1xuICAgICAgICAgIHZhciBkaXN0ID0gTWF0aC5zcXJ0KGRpc3RYICogZGlzdFggKyBkaXN0WSAqIGRpc3RZKTtcblxuICAgICAgICAgIGlmICgoY2xvc2VzdERpc3QgPT09IG51bGwgfHwgZGlzdCA8IGNsb3Nlc3REaXN0KSAmJiBkaXN0IDwgZGlzdE1heCkge1xuICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBkaXN0O1xuICAgICAgICAgICAgY2xvc2VzdERhdGFQb2ludCA9IGRhdGFQb2ludDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xvc2VzdERhdGFQb2ludDtcbiAgfTtcblxuICAvKipcbiAgICogRGlzcGxheSBhIHRvb2x0aXAgZm9yIGdpdmVuIGRhdGEgcG9pbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFQb2ludFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX3Nob3dUb29sdGlwID0gZnVuY3Rpb24gKGRhdGFQb2ludCkge1xuICAgIHZhciBjb250ZW50LCBsaW5lLCBkb3Q7XG5cbiAgICBpZiAoIXRoaXMudG9vbHRpcCkge1xuICAgICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29udGVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBjb250ZW50LnN0eWxlLnBhZGRpbmcgPSAnMTBweCc7XG4gICAgICBjb250ZW50LnN0eWxlLmJvcmRlciA9ICcxcHggc29saWQgIzRkNGQ0ZCc7XG4gICAgICBjb250ZW50LnN0eWxlLmNvbG9yID0gJyMxYTFhMWEnO1xuICAgICAgY29udGVudC5zdHlsZS5iYWNrZ3JvdW5kID0gJ3JnYmEoMjU1LDI1NSwyNTUsMC43KSc7XG4gICAgICBjb250ZW50LnN0eWxlLmJvcmRlclJhZGl1cyA9ICcycHgnO1xuICAgICAgY29udGVudC5zdHlsZS5ib3hTaGFkb3cgPSAnNXB4IDVweCAxMHB4IHJnYmEoMTI4LDEyOCwxMjgsMC41KSc7XG5cbiAgICAgIGxpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGxpbmUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgbGluZS5zdHlsZS5oZWlnaHQgPSAnNDBweCc7XG4gICAgICBsaW5lLnN0eWxlLndpZHRoID0gJzAnO1xuICAgICAgbGluZS5zdHlsZS5ib3JkZXJMZWZ0ID0gJzFweCBzb2xpZCAjNGQ0ZDRkJztcblxuICAgICAgZG90ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkb3Quc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgZG90LnN0eWxlLmhlaWdodCA9ICcwJztcbiAgICAgIGRvdC5zdHlsZS53aWR0aCA9ICcwJztcbiAgICAgIGRvdC5zdHlsZS5ib3JkZXIgPSAnNXB4IHNvbGlkICM0ZDRkNGQnO1xuICAgICAgZG90LnN0eWxlLmJvcmRlclJhZGl1cyA9ICc1cHgnO1xuXG4gICAgICB0aGlzLnRvb2x0aXAgPSB7XG4gICAgICAgIGRhdGFQb2ludDogbnVsbCxcbiAgICAgICAgZG9tOiB7XG4gICAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICAgIGRvdDogZG90XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnQgPSB0aGlzLnRvb2x0aXAuZG9tLmNvbnRlbnQ7XG4gICAgICBsaW5lID0gdGhpcy50b29sdGlwLmRvbS5saW5lO1xuICAgICAgZG90ID0gdGhpcy50b29sdGlwLmRvbS5kb3Q7XG4gICAgfVxuXG4gICAgdGhpcy5faGlkZVRvb2x0aXAoKTtcblxuICAgIHRoaXMudG9vbHRpcC5kYXRhUG9pbnQgPSBkYXRhUG9pbnQ7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnNob3dUb29sdGlwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb250ZW50LmlubmVySFRNTCA9IHRoaXMuc2hvd1Rvb2x0aXAoZGF0YVBvaW50LnBvaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudC5pbm5lckhUTUwgPSAnPHRhYmxlPicgKyAnPHRyPjx0ZD4nICsgdGhpcy54TGFiZWwgKyAnOjwvdGQ+PHRkPicgKyBkYXRhUG9pbnQucG9pbnQueCArICc8L3RkPjwvdHI+JyArICc8dHI+PHRkPicgKyB0aGlzLnlMYWJlbCArICc6PC90ZD48dGQ+JyArIGRhdGFQb2ludC5wb2ludC55ICsgJzwvdGQ+PC90cj4nICsgJzx0cj48dGQ+JyArIHRoaXMuekxhYmVsICsgJzo8L3RkPjx0ZD4nICsgZGF0YVBvaW50LnBvaW50LnogKyAnPC90ZD48L3RyPicgKyAnPC90YWJsZT4nO1xuICAgIH1cblxuICAgIGNvbnRlbnQuc3R5bGUubGVmdCA9ICcwJztcbiAgICBjb250ZW50LnN0eWxlLnRvcCA9ICcwJztcbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQobGluZSk7XG4gICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZChkb3QpO1xuXG4gICAgLy8gY2FsY3VsYXRlIHNpemVzXG4gICAgdmFyIGNvbnRlbnRXaWR0aCA9IGNvbnRlbnQub2Zmc2V0V2lkdGg7XG4gICAgdmFyIGNvbnRlbnRIZWlnaHQgPSBjb250ZW50Lm9mZnNldEhlaWdodDtcbiAgICB2YXIgbGluZUhlaWdodCA9IGxpbmUub2Zmc2V0SGVpZ2h0O1xuICAgIHZhciBkb3RXaWR0aCA9IGRvdC5vZmZzZXRXaWR0aDtcbiAgICB2YXIgZG90SGVpZ2h0ID0gZG90Lm9mZnNldEhlaWdodDtcblxuICAgIHZhciBsZWZ0ID0gZGF0YVBvaW50LnNjcmVlbi54IC0gY29udGVudFdpZHRoIC8gMjtcbiAgICBsZWZ0ID0gTWF0aC5taW4oTWF0aC5tYXgobGVmdCwgMTApLCB0aGlzLmZyYW1lLmNsaWVudFdpZHRoIC0gMTAgLSBjb250ZW50V2lkdGgpO1xuXG4gICAgbGluZS5zdHlsZS5sZWZ0ID0gZGF0YVBvaW50LnNjcmVlbi54ICsgJ3B4JztcbiAgICBsaW5lLnN0eWxlLnRvcCA9IGRhdGFQb2ludC5zY3JlZW4ueSAtIGxpbmVIZWlnaHQgKyAncHgnO1xuICAgIGNvbnRlbnQuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xuICAgIGNvbnRlbnQuc3R5bGUudG9wID0gZGF0YVBvaW50LnNjcmVlbi55IC0gbGluZUhlaWdodCAtIGNvbnRlbnRIZWlnaHQgKyAncHgnO1xuICAgIGRvdC5zdHlsZS5sZWZ0ID0gZGF0YVBvaW50LnNjcmVlbi54IC0gZG90V2lkdGggLyAyICsgJ3B4JztcbiAgICBkb3Quc3R5bGUudG9wID0gZGF0YVBvaW50LnNjcmVlbi55IC0gZG90SGVpZ2h0IC8gMiArICdweCc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIHRvb2x0aXAgd2hlbiBkaXNwbGF5ZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9oaWRlVG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50b29sdGlwKSB7XG4gICAgICB0aGlzLnRvb2x0aXAuZGF0YVBvaW50ID0gbnVsbDtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzLnRvb2x0aXAuZG9tKSB7XG4gICAgICAgIGlmICh0aGlzLnRvb2x0aXAuZG9tLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgdmFyIGVsZW0gPSB0aGlzLnRvb2x0aXAuZG9tW3Byb3BdO1xuICAgICAgICAgIGlmIChlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgZWxlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSoqL1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhvcml6b250YWwgbW91c2UgcG9zaXRpb24gZnJvbSBhIG1vdXNlIGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSAgIHtFdmVudH0gIGV2ZW50XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IG1vdXNlIHhcbiAgICovXG4gIGZ1bmN0aW9uIGdldE1vdXNlWChldmVudCkge1xuICAgIGlmICgnY2xpZW50WCcgaW4gZXZlbnQpIHJldHVybiBldmVudC5jbGllbnRYO1xuICAgIHJldHVybiBldmVudC50YXJnZXRUb3VjaGVzWzBdICYmIGV2ZW50LnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WCB8fCAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmVydGljYWwgbW91c2UgcG9zaXRpb24gZnJvbSBhIG1vdXNlIGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSAgIHtFdmVudH0gIGV2ZW50XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IG1vdXNlIHlcbiAgICovXG4gIGZ1bmN0aW9uIGdldE1vdXNlWShldmVudCkge1xuICAgIGlmICgnY2xpZW50WScgaW4gZXZlbnQpIHJldHVybiBldmVudC5jbGllbnRZO1xuICAgIHJldHVybiBldmVudC50YXJnZXRUb3VjaGVzWzBdICYmIGV2ZW50LnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WSB8fCAwO1xuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gIFB1YmxpYyBtZXRob2RzIGZvciBzcGVjaWZpYyBzZXR0aW5nc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJvdGF0aW9uIGFuZCBkaXN0YW5jZSBvZiB0aGUgY2FtZXJhXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgcG9zICAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggdGhlIGNhbWVyYSBwb3NpdGlvblxuICAgKiBAcGFyYW0gez9OdW1iZXJ9IHBvcy5ob3Jpem9udGFsIFRoZSBob3Jpem9udGFsIHJvdGF0aW9uLCBiZXR3ZWVuIDAgYW5kIDIqUEkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3B0aW9uYWwsIGNhbiBiZSBsZWZ0IHVuZGVmaW5lZC5cbiAgICogQHBhcmFtIHs/TnVtYmVyfSBwb3MudmVydGljYWwgICBUaGUgdmVydGljYWwgcm90YXRpb24sIGJldHdlZW4gMCBhbmQgMC41KlBJLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHZlcnRpY2FsPTAuNSpQSSwgdGhlIGdyYXBoIGlzIHNob3duIGZyb21cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgdG9wLiBPcHRpb25hbCwgY2FuIGJlIGxlZnQgdW5kZWZpbmVkLlxuICAgKiBAcGFyYW0gez9OdW1iZXJ9IHBvcy5kaXN0YW5jZSAgIFRoZSAobm9ybWFsaXplZCkgZGlzdGFuY2Ugb2YgdGhlIGNhbWVyYSB0byB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXIgb2YgdGhlIGdyYXBoLCBhIHZhbHVlIGJldHdlZW4gMC43MSBhbmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA1LjAuIE9wdGlvbmFsLCBjYW4gYmUgbGVmdCB1bmRlZmluZWQuXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5zZXRDYW1lcmFQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICBTZXR0aW5ncy5zZXRDYW1lcmFQb3NpdGlvbihwb3MsIHRoaXMpO1xuICAgIHRoaXMucmVkcmF3KCk7XG4gIH07XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gIEVuZCBwdWJsaWMgbWV0aG9kcyBmb3Igc3BlY2lmaWMgc2V0dGluZ3NcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gIG1vZHVsZS5leHBvcnRzID0gR3JhcGgzZDtcblxuLyoqKi8gfSxcbi8qIDEzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICBcbiAgLyoqXG4gICAqIEV4cG9zZSBgRW1pdHRlcmAuXG4gICAqL1xuXG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG4gICAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gICAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICAvKipcbiAgICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEVtaXR0ZXIucHJvdG90eXBlLm9uID1cbiAgRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAgICh0aGlzLl9jYWxsYmFja3NbZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXSlcbiAgICAgIC5wdXNoKGZuKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gICAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcmV0dXJuIHtFbWl0dGVyfVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gICAgZnVuY3Rpb24gb24oKSB7XG4gICAgICBzZWxmLm9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBvbi5mbiA9IGZuO1xuICAgIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAgICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcmV0dXJuIHtFbWl0dGVyfVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBFbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuICBFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gIEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gIEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICAgIC8vIGFsbFxuICAgIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gICAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICAgIHZhciBjYjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtNaXhlZH0gLi4uXG4gICAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gICAqL1xuXG4gIEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG5cbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAgIHJldHVybiB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBFbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gICAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG4gIH07XG5cblxuLyoqKi8gfSxcbi8qIDE0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICBcInVzZSBzdHJpY3RcIjtcblxuICAvKipcbiAgICogQHByb3RvdHlwZSBQb2ludDNkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeF1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5XVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3pdXG4gICAqL1xuICBmdW5jdGlvbiBQb2ludDNkKHgsIHksIHopIHtcbiAgICB0aGlzLnggPSB4ICE9PSB1bmRlZmluZWQgPyB4IDogMDtcbiAgICB0aGlzLnkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogMDtcbiAgICB0aGlzLnogPSB6ICE9PSB1bmRlZmluZWQgPyB6IDogMDtcbiAgfTtcblxuICAvKipcbiAgICogU3VidHJhY3QgdGhlIHR3byBwcm92aWRlZCBwb2ludHMsIHJldHVybnMgYS1iXG4gICAqIEBwYXJhbSB7UG9pbnQzZH0gYVxuICAgKiBAcGFyYW0ge1BvaW50M2R9IGJcbiAgICogQHJldHVybiB7UG9pbnQzZH0gYS1iXG4gICAqL1xuICBQb2ludDNkLnN1YnRyYWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgc3ViID0gbmV3IFBvaW50M2QoKTtcbiAgICBzdWIueCA9IGEueCAtIGIueDtcbiAgICBzdWIueSA9IGEueSAtIGIueTtcbiAgICBzdWIueiA9IGEueiAtIGIuejtcbiAgICByZXR1cm4gc3ViO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdGhlIHR3byBwcm92aWRlZCBwb2ludHMsIHJldHVybnMgYStiXG4gICAqIEBwYXJhbSB7UG9pbnQzZH0gYVxuICAgKiBAcGFyYW0ge1BvaW50M2R9IGJcbiAgICogQHJldHVybiB7UG9pbnQzZH0gYStiXG4gICAqL1xuICBQb2ludDNkLmFkZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIHN1bSA9IG5ldyBQb2ludDNkKCk7XG4gICAgc3VtLnggPSBhLnggKyBiLng7XG4gICAgc3VtLnkgPSBhLnkgKyBiLnk7XG4gICAgc3VtLnogPSBhLnogKyBiLno7XG4gICAgcmV0dXJuIHN1bTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBhdmVyYWdlIG9mIHR3byAzZCBwb2ludHNcbiAgICogQHBhcmFtIHtQb2ludDNkfSBhXG4gICAqIEBwYXJhbSB7UG9pbnQzZH0gYlxuICAgKiBAcmV0dXJuIHtQb2ludDNkfSBUaGUgYXZlcmFnZSwgKGErYikvMlxuICAgKi9cbiAgUG9pbnQzZC5hdmcgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBuZXcgUG9pbnQzZCgoYS54ICsgYi54KSAvIDIsIChhLnkgKyBiLnkpIC8gMiwgKGEueiArIGIueikgLyAyKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHRoZSB0d28gcHJvdmlkZWQgcG9pbnRzLCByZXR1cm5zIGF4YlxuICAgKiBEb2N1bWVudGF0aW9uOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Nyb3NzX3Byb2R1Y3RcbiAgICogQHBhcmFtIHtQb2ludDNkfSBhXG4gICAqIEBwYXJhbSB7UG9pbnQzZH0gYlxuICAgKiBAcmV0dXJuIHtQb2ludDNkfSBjcm9zcyBwcm9kdWN0IGF4YlxuICAgKi9cbiAgUG9pbnQzZC5jcm9zc1Byb2R1Y3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBjcm9zc3Byb2R1Y3QgPSBuZXcgUG9pbnQzZCgpO1xuXG4gICAgY3Jvc3Nwcm9kdWN0LnggPSBhLnkgKiBiLnogLSBhLnogKiBiLnk7XG4gICAgY3Jvc3Nwcm9kdWN0LnkgPSBhLnogKiBiLnggLSBhLnggKiBiLno7XG4gICAgY3Jvc3Nwcm9kdWN0LnogPSBhLnggKiBiLnkgLSBhLnkgKiBiLng7XG5cbiAgICByZXR1cm4gY3Jvc3Nwcm9kdWN0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSdHJpZXZlIHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvciAob3IgdGhlIGRpc3RhbmNlIGZyb20gdGhpcyBwb2ludCB0byB0aGUgb3JpZ2luXG4gICAqIEByZXR1cm4ge051bWJlcn0gIGxlbmd0aFxuICAgKi9cbiAgUG9pbnQzZC5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56KTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFBvaW50M2Q7XG5cbi8qKiovIH0sXG4vKiAxNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLyoqXG4gICAqIEBwcm90b3R5cGUgUG9pbnQyZFxuICAgKiBAcGFyYW0ge051bWJlcn0gW3hdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeV1cbiAgICovXG4gIGZ1bmN0aW9uIFBvaW50MmQoeCwgeSkge1xuICAgIHRoaXMueCA9IHggIT09IHVuZGVmaW5lZCA/IHggOiAwO1xuICAgIHRoaXMueSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBQb2ludDJkO1xuXG4vKioqLyB9LFxuLyogMTYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgUG9pbnQzZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgQ2FtZXJhXG4gICAqIFRoZSBjYW1lcmEgaXMgbW91bnRlZCBvbiBhICh2aXJ0dWFsKSBjYW1lcmEgYXJtLiBUaGUgY2FtZXJhIGFybSBjYW4gcm90YXRlXG4gICAqIFRoZSBjYW1lcmEgaXMgYWx3YXlzIGxvb2tpbmcgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgb3JpZ2luIG9mIHRoZSBhcm0uXG4gICAqIFRoaXMgd2F5LCB0aGUgY2FtZXJhIGFsd2F5cyByb3RhdGVzIGFyb3VuZCBvbmUgZml4ZWQgcG9pbnQsIHRoZSBsb2NhdGlvblxuICAgKiBvZiB0aGUgY2FtZXJhIGFybS5cbiAgICpcbiAgICogRG9jdW1lbnRhdGlvbjpcbiAgICogICBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpLzNEX3Byb2plY3Rpb25cbiAgICovXG4gIGZ1bmN0aW9uIENhbWVyYSgpIHtcbiAgICB0aGlzLmFybUxvY2F0aW9uID0gbmV3IFBvaW50M2QoKTtcbiAgICB0aGlzLmFybVJvdGF0aW9uID0ge307XG4gICAgdGhpcy5hcm1Sb3RhdGlvbi5ob3Jpem9udGFsID0gMDtcbiAgICB0aGlzLmFybVJvdGF0aW9uLnZlcnRpY2FsID0gMDtcbiAgICB0aGlzLmFybUxlbmd0aCA9IDEuNztcblxuICAgIHRoaXMuY2FtZXJhTG9jYXRpb24gPSBuZXcgUG9pbnQzZCgpO1xuICAgIHRoaXMuY2FtZXJhUm90YXRpb24gPSBuZXcgUG9pbnQzZCgwLjUgKiBNYXRoLlBJLCAwLCAwKTtcblxuICAgIHRoaXMuY2FsY3VsYXRlQ2FtZXJhT3JpZW50YXRpb24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGxvY2F0aW9uIChvcmlnaW4pIG9mIHRoZSBhcm1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHggIE5vcm1hbGl6ZWQgdmFsdWUgb2YgeFxuICAgKiBAcGFyYW0ge051bWJlcn0geSAgTm9ybWFsaXplZCB2YWx1ZSBvZiB5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB6ICBOb3JtYWxpemVkIHZhbHVlIG9mIHpcbiAgICovXG4gIENhbWVyYS5wcm90b3R5cGUuc2V0QXJtTG9jYXRpb24gPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuICAgIHRoaXMuYXJtTG9jYXRpb24ueCA9IHg7XG4gICAgdGhpcy5hcm1Mb2NhdGlvbi55ID0geTtcbiAgICB0aGlzLmFybUxvY2F0aW9uLnogPSB6O1xuXG4gICAgdGhpcy5jYWxjdWxhdGVDYW1lcmFPcmllbnRhdGlvbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJvdGF0aW9uIG9mIHRoZSBjYW1lcmEgYXJtXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBob3Jpem9udGFsICAgVGhlIGhvcml6b250YWwgcm90YXRpb24sIGJldHdlZW4gMCBhbmQgMipQSS5cbiAgICogICAgICAgICAgICAgICAgT3B0aW9uYWwsIGNhbiBiZSBsZWZ0IHVuZGVmaW5lZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZlcnRpY2FsICAgVGhlIHZlcnRpY2FsIHJvdGF0aW9uLCBiZXR3ZWVuIDAgYW5kIDAuNSpQSVxuICAgKiAgICAgICAgICAgICAgICBpZiB2ZXJ0aWNhbD0wLjUqUEksIHRoZSBncmFwaCBpcyBzaG93biBmcm9tIHRoZVxuICAgKiAgICAgICAgICAgICAgICB0b3AuIE9wdGlvbmFsLCBjYW4gYmUgbGVmdCB1bmRlZmluZWQuXG4gICAqL1xuICBDYW1lcmEucHJvdG90eXBlLnNldEFybVJvdGF0aW9uID0gZnVuY3Rpb24gKGhvcml6b250YWwsIHZlcnRpY2FsKSB7XG4gICAgaWYgKGhvcml6b250YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5hcm1Sb3RhdGlvbi5ob3Jpem9udGFsID0gaG9yaXpvbnRhbDtcbiAgICB9XG5cbiAgICBpZiAodmVydGljYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5hcm1Sb3RhdGlvbi52ZXJ0aWNhbCA9IHZlcnRpY2FsO1xuICAgICAgaWYgKHRoaXMuYXJtUm90YXRpb24udmVydGljYWwgPCAwKSB0aGlzLmFybVJvdGF0aW9uLnZlcnRpY2FsID0gMDtcbiAgICAgIGlmICh0aGlzLmFybVJvdGF0aW9uLnZlcnRpY2FsID4gMC41ICogTWF0aC5QSSkgdGhpcy5hcm1Sb3RhdGlvbi52ZXJ0aWNhbCA9IDAuNSAqIE1hdGguUEk7XG4gICAgfVxuXG4gICAgaWYgKGhvcml6b250YWwgIT09IHVuZGVmaW5lZCB8fCB2ZXJ0aWNhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmNhbGN1bGF0ZUNhbWVyYU9yaWVudGF0aW9uKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBhcm0gcm90YXRpb25cbiAgICogQHJldHVybiB7b2JqZWN0fSAgIEFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgaG9yaXpvbnRhbCBhbmQgdmVydGljYWxcbiAgICovXG4gIENhbWVyYS5wcm90b3R5cGUuZ2V0QXJtUm90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJvdCA9IHt9O1xuICAgIHJvdC5ob3Jpem9udGFsID0gdGhpcy5hcm1Sb3RhdGlvbi5ob3Jpem9udGFsO1xuICAgIHJvdC52ZXJ0aWNhbCA9IHRoaXMuYXJtUm90YXRpb24udmVydGljYWw7XG5cbiAgICByZXR1cm4gcm90O1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIChub3JtYWxpemVkKSBsZW5ndGggb2YgdGhlIGNhbWVyYSBhcm0uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggQSBsZW5ndGggYmV0d2VlbiAwLjcxIGFuZCA1LjBcbiAgICovXG4gIENhbWVyYS5wcm90b3R5cGUuc2V0QXJtTGVuZ3RoID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgdGhpcy5hcm1MZW5ndGggPSBsZW5ndGg7XG5cbiAgICAvLyBSYWRpdXMgbXVzdCBiZSBsYXJnZXIgdGhhbiB0aGUgY29ybmVyIG9mIHRoZSBncmFwaCxcbiAgICAvLyB3aGljaCBoYXMgYSBkaXN0YW5jZSBvZiBzcXJ0KDAuNV4yKzAuNV4yKSA9IDAuNzEgZnJvbSB0aGUgY2VudGVyIG9mIHRoZVxuICAgIC8vIGdyYXBoXG4gICAgaWYgKHRoaXMuYXJtTGVuZ3RoIDwgMC43MSkgdGhpcy5hcm1MZW5ndGggPSAwLjcxO1xuICAgIGlmICh0aGlzLmFybUxlbmd0aCA+IDUuMCkgdGhpcy5hcm1MZW5ndGggPSA1LjA7XG5cbiAgICB0aGlzLmNhbGN1bGF0ZUNhbWVyYU9yaWVudGF0aW9uKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBhcm0gbGVuZ3RoXG4gICAqIEByZXR1cm4ge051bWJlcn0gbGVuZ3RoXG4gICAqL1xuICBDYW1lcmEucHJvdG90eXBlLmdldEFybUxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5hcm1MZW5ndGg7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBjYW1lcmEgbG9jYXRpb25cbiAgICogQHJldHVybiB7UG9pbnQzZH0gY2FtZXJhTG9jYXRpb25cbiAgICovXG4gIENhbWVyYS5wcm90b3R5cGUuZ2V0Q2FtZXJhTG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FtZXJhTG9jYXRpb247XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBjYW1lcmEgcm90YXRpb25cbiAgICogQHJldHVybiB7UG9pbnQzZH0gY2FtZXJhUm90YXRpb25cbiAgICovXG4gIENhbWVyYS5wcm90b3R5cGUuZ2V0Q2FtZXJhUm90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FtZXJhUm90YXRpb247XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgbG9jYXRpb24gYW5kIHJvdGF0aW9uIG9mIHRoZSBjYW1lcmEgYmFzZWQgb24gdGhlXG4gICAqIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiBvZiB0aGUgY2FtZXJhIGFybVxuICAgKi9cbiAgQ2FtZXJhLnByb3RvdHlwZS5jYWxjdWxhdGVDYW1lcmFPcmllbnRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjYWxjdWxhdGUgbG9jYXRpb24gb2YgdGhlIGNhbWVyYVxuICAgIHRoaXMuY2FtZXJhTG9jYXRpb24ueCA9IHRoaXMuYXJtTG9jYXRpb24ueCAtIHRoaXMuYXJtTGVuZ3RoICogTWF0aC5zaW4odGhpcy5hcm1Sb3RhdGlvbi5ob3Jpem9udGFsKSAqIE1hdGguY29zKHRoaXMuYXJtUm90YXRpb24udmVydGljYWwpO1xuICAgIHRoaXMuY2FtZXJhTG9jYXRpb24ueSA9IHRoaXMuYXJtTG9jYXRpb24ueSAtIHRoaXMuYXJtTGVuZ3RoICogTWF0aC5jb3ModGhpcy5hcm1Sb3RhdGlvbi5ob3Jpem9udGFsKSAqIE1hdGguY29zKHRoaXMuYXJtUm90YXRpb24udmVydGljYWwpO1xuICAgIHRoaXMuY2FtZXJhTG9jYXRpb24ueiA9IHRoaXMuYXJtTG9jYXRpb24ueiArIHRoaXMuYXJtTGVuZ3RoICogTWF0aC5zaW4odGhpcy5hcm1Sb3RhdGlvbi52ZXJ0aWNhbCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgcm90YXRpb24gb2YgdGhlIGNhbWVyYVxuICAgIHRoaXMuY2FtZXJhUm90YXRpb24ueCA9IE1hdGguUEkgLyAyIC0gdGhpcy5hcm1Sb3RhdGlvbi52ZXJ0aWNhbDtcbiAgICB0aGlzLmNhbWVyYVJvdGF0aW9uLnkgPSAwO1xuICAgIHRoaXMuY2FtZXJhUm90YXRpb24ueiA9IC10aGlzLmFybVJvdGF0aW9uLmhvcml6b250YWw7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBDYW1lcmE7XG5cbi8qKiovIH0sXG4vKiAxNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBEYXRhVmlldyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgRmlsdGVyXG4gICAqXG4gICAqIEBwYXJhbSB7RGF0YVNldH0gZGF0YSBUaGUgZ29vZ2xlIGRhdGEgdGFibGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9ICBjb2x1bW4gICAgICAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBjb2x1bW4gdG8gYmUgZmlsdGVyZWRcbiAgICogQHBhcmFtIHtHcmFwaH0gZ3JhcGggICAgICAgICAgIFRoZSBncmFwaFxuICAgKi9cbiAgZnVuY3Rpb24gRmlsdGVyKGRhdGEsIGNvbHVtbiwgZ3JhcGgpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgIHRoaXMuZ3JhcGggPSBncmFwaDsgLy8gdGhlIHBhcmVudCBncmFwaFxuXG4gICAgdGhpcy5pbmRleCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gcmVhZCBhbGwgZGlzdGluY3QgdmFsdWVzIGFuZCBzZWxlY3QgdGhlIGZpcnN0IG9uZVxuICAgIHRoaXMudmFsdWVzID0gZ3JhcGguZ2V0RGlzdGluY3RWYWx1ZXMoZGF0YS5nZXQoKSwgdGhpcy5jb2x1bW4pO1xuXG4gICAgLy8gc29ydCBib3RoIG51bWVyaWMgYW5kIHN0cmluZyB2YWx1ZXMgY29ycmVjdGx5XG4gICAgdGhpcy52YWx1ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMudmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc2VsZWN0VmFsdWUoMCk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGFuIGFycmF5IHdpdGggdGhlIGZpbHRlcmVkIGRhdGFwb2ludHMuIHRoaXMgd2lsbCBiZSBsb2FkZWQgYWZ0ZXJ3YXJkc1xuICAgIHRoaXMuZGF0YVBvaW50cyA9IFtdO1xuXG4gICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICB0aGlzLm9uTG9hZENhbGxiYWNrID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGdyYXBoLmFuaW1hdGlvblByZWxvYWQpIHtcbiAgICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmxvYWRJbkJhY2tncm91bmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsYWJlbFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGxhYmVsXG4gICAqL1xuICBGaWx0ZXIucHJvdG90eXBlLmlzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmxvYWRlZDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsb2FkZWQgcHJvZ3Jlc3NcbiAgICogQHJldHVybiB7TnVtYmVyfSBwZXJjZW50YWdlIGJldHdlZW4gMCBhbmQgMTAwXG4gICAqL1xuICBGaWx0ZXIucHJvdG90eXBlLmdldExvYWRlZFByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSB0aGlzLnZhbHVlcy5sZW5ndGg7XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHRoaXMuZGF0YVBvaW50c1tpXSkge1xuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLnJvdW5kKGkgLyBsZW4gKiAxMDApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxhYmVsXG4gICAqIEByZXR1cm4ge3N0cmluZ30gbGFiZWxcbiAgICovXG4gIEZpbHRlci5wcm90b3R5cGUuZ2V0TGFiZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JhcGguZmlsdGVyTGFiZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29sdW1uSW5kZXggb2YgdGhlIGZpbHRlclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbHVtbkluZGV4XG4gICAqL1xuICBGaWx0ZXIucHJvdG90eXBlLmdldENvbHVtbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2x1bW47XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHZhbHVlLiBSZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBzZWxlY3Rpb25cbiAgICogQHJldHVybiB7Kn0gdmFsdWVcbiAgICovXG4gIEZpbHRlci5wcm90b3R5cGUuZ2V0U2VsZWN0ZWRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pbmRleCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIHRoaXMudmFsdWVzW3RoaXMuaW5kZXhdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBhbGwgdmFsdWVzIG9mIHRoZSBmaWx0ZXJcbiAgICogQHJldHVybiB7QXJyYXl9IHZhbHVlc1xuICAgKi9cbiAgRmlsdGVyLnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBvbmUgdmFsdWUgb2YgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0ge051bWJlcn0gIGluZGV4XG4gICAqIEByZXR1cm4geyp9IHZhbHVlXG4gICAqL1xuICBGaWx0ZXIucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID49IHRoaXMudmFsdWVzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKTtcblxuICAgIHJldHVybiB0aGlzLnZhbHVlc1tpbmRleF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSAoZmlsdGVyZWQpIGRhdGFQb2ludHMgZm9yIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZmlsdGVyIGluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXhdIChvcHRpb25hbClcbiAgICogQHJldHVybiB7QXJyYXl9IGRhdGFQb2ludHNcbiAgICovXG4gIEZpbHRlci5wcm90b3R5cGUuX2dldERhdGFQb2ludHMgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkgaW5kZXggPSB0aGlzLmluZGV4O1xuXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHJldHVybiBbXTtcblxuICAgIHZhciBkYXRhUG9pbnRzO1xuICAgIGlmICh0aGlzLmRhdGFQb2ludHNbaW5kZXhdKSB7XG4gICAgICBkYXRhUG9pbnRzID0gdGhpcy5kYXRhUG9pbnRzW2luZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGYgPSB7fTtcbiAgICAgIGYuY29sdW1uID0gdGhpcy5jb2x1bW47XG4gICAgICBmLnZhbHVlID0gdGhpcy52YWx1ZXNbaW5kZXhdO1xuXG4gICAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcodGhpcy5kYXRhLCB7IGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gaXRlbVtmLmNvbHVtbl0gPT0gZi52YWx1ZTtcbiAgICAgICAgfSB9KS5nZXQoKTtcbiAgICAgIGRhdGFQb2ludHMgPSB0aGlzLmdyYXBoLl9nZXREYXRhUG9pbnRzKGRhdGFWaWV3KTtcblxuICAgICAgdGhpcy5kYXRhUG9pbnRzW2luZGV4XSA9IGRhdGFQb2ludHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFQb2ludHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhlIGZpbHRlciBpcyBmdWxseSBsb2FkZWQuXG4gICAqL1xuICBGaWx0ZXIucHJvdG90eXBlLnNldE9uTG9hZENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5vbkxvYWRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSB2YWx1ZSB0byB0aGUgbGlzdCB3aXRoIGF2YWlsYWJsZSB2YWx1ZXMgZm9yIHRoaXMgZmlsdGVyXG4gICAqIE5vIGRvdWJsZSBlbnRyaWVzIHdpbGwgYmUgY3JlYXRlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqL1xuICBGaWx0ZXIucHJvdG90eXBlLnNlbGVjdFZhbHVlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID49IHRoaXMudmFsdWVzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKTtcblxuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZXNbaW5kZXhdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2FkIGFsbCBmaWx0ZXJlZCByb3dzIGluIHRoZSBiYWNrZ3JvdW5kIG9uZSBieSBvbmVcbiAgICogU3RhcnQgdGhpcyBtZXRob2Qgd2l0aG91dCBwcm92aWRpbmcgYW4gaW5kZXghXG4gICAqL1xuICBGaWx0ZXIucHJvdG90eXBlLmxvYWRJbkJhY2tncm91bmQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkgaW5kZXggPSAwO1xuXG4gICAgdmFyIGZyYW1lID0gdGhpcy5ncmFwaC5mcmFtZTtcblxuICAgIGlmIChpbmRleCA8IHRoaXMudmFsdWVzLmxlbmd0aCkge1xuICAgICAgdmFyIGRhdGFQb2ludHNUZW1wID0gdGhpcy5fZ2V0RGF0YVBvaW50cyhpbmRleCk7XG4gICAgICAvL3RoaXMuZ3JhcGgucmVkcmF3SW5mbygpOyAvLyBUT0RPOiBub3QgbmVhdFxuXG4gICAgICAvLyBjcmVhdGUgYSBwcm9ncmVzcyBib3hcbiAgICAgIGlmIChmcmFtZS5wcm9ncmVzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZyYW1lLnByb2dyZXNzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgICAgIGZyYW1lLnByb2dyZXNzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgZnJhbWUucHJvZ3Jlc3Muc3R5bGUuY29sb3IgPSAnZ3JheSc7XG4gICAgICAgIGZyYW1lLmFwcGVuZENoaWxkKGZyYW1lLnByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9ncmVzcyA9IHRoaXMuZ2V0TG9hZGVkUHJvZ3Jlc3MoKTtcbiAgICAgIGZyYW1lLnByb2dyZXNzLmlubmVySFRNTCA9ICdMb2FkaW5nIGFuaW1hdGlvbi4uLiAnICsgcHJvZ3Jlc3MgKyAnJSc7XG4gICAgICAvLyBUT0RPOiB0aGlzIGlzIG5vIG5pY2Ugc29sdXRpb24uLi5cbiAgICAgIGZyYW1lLnByb2dyZXNzLnN0eWxlLmJvdHRvbSA9IDYwICsgJ3B4JzsgLy8gVE9ETzogdXNlIGhlaWdodCBvZiBzbGlkZXJcbiAgICAgIGZyYW1lLnByb2dyZXNzLnN0eWxlLmxlZnQgPSAxMCArICdweCc7XG5cbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUubG9hZEluQmFja2dyb3VuZChpbmRleCArIDEpO1xuICAgICAgfSwgMTApO1xuICAgICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuXG4gICAgICAvLyByZW1vdmUgdGhlIHByb2dyZXNzIGJveFxuICAgICAgaWYgKGZyYW1lLnByb2dyZXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZnJhbWUucmVtb3ZlQ2hpbGQoZnJhbWUucHJvZ3Jlc3MpO1xuICAgICAgICBmcmFtZS5wcm9ncmVzcyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub25Mb2FkQ2FsbGJhY2spIHRoaXMub25Mb2FkQ2FsbGJhY2soKTtcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBGaWx0ZXI7XG5cbi8qKiovIH0sXG4vKiAxOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yIFNsaWRlclxuICAgKlxuICAgKiBBbiBodG1sIHNsaWRlciBjb250cm9sIHdpdGggc3RhcnQvc3RvcC9wcmV2L25leHQgYnV0dG9uc1xuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lciAgVGhlIGVsZW1lbnQgd2hlcmUgdGhlIHNsaWRlciB3aWxsIGJlIGNyZWF0ZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgIHtib29sZWFufSB2aXNpYmxlICAgSWYgdHJ1ZSAoZGVmYXVsdCkgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGVyIGlzIHZpc2libGUuXG4gICAqL1xuICBmdW5jdGlvbiBTbGlkZXIoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gICAgaWYgKGNvbnRhaW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbnRhaW5lciBlbGVtZW50IGRlZmluZWQnKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy52aXNpYmxlID0gb3B0aW9ucyAmJiBvcHRpb25zLnZpc2libGUgIT0gdW5kZWZpbmVkID8gb3B0aW9ucy52aXNpYmxlIDogdHJ1ZTtcblxuICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgIHRoaXMuZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgIC8vdGhpcy5mcmFtZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI0U1RTVFNSc7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgdGhpcy5mcmFtZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lKTtcblxuICAgICAgdGhpcy5mcmFtZS5wcmV2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSU5QVVQnKTtcbiAgICAgIHRoaXMuZnJhbWUucHJldi50eXBlID0gJ0JVVFRPTic7XG4gICAgICB0aGlzLmZyYW1lLnByZXYudmFsdWUgPSAnUHJldic7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuZnJhbWUucHJldik7XG5cbiAgICAgIHRoaXMuZnJhbWUucGxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0lOUFVUJyk7XG4gICAgICB0aGlzLmZyYW1lLnBsYXkudHlwZSA9ICdCVVRUT04nO1xuICAgICAgdGhpcy5mcmFtZS5wbGF5LnZhbHVlID0gJ1BsYXknO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lLnBsYXkpO1xuXG4gICAgICB0aGlzLmZyYW1lLm5leHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdJTlBVVCcpO1xuICAgICAgdGhpcy5mcmFtZS5uZXh0LnR5cGUgPSAnQlVUVE9OJztcbiAgICAgIHRoaXMuZnJhbWUubmV4dC52YWx1ZSA9ICdOZXh0JztcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZS5uZXh0KTtcblxuICAgICAgdGhpcy5mcmFtZS5iYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdJTlBVVCcpO1xuICAgICAgdGhpcy5mcmFtZS5iYXIudHlwZSA9ICdCVVRUT04nO1xuICAgICAgdGhpcy5mcmFtZS5iYXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgdGhpcy5mcmFtZS5iYXIuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCByZWQnO1xuICAgICAgdGhpcy5mcmFtZS5iYXIuc3R5bGUud2lkdGggPSAnMTAwcHgnO1xuICAgICAgdGhpcy5mcmFtZS5iYXIuc3R5bGUuaGVpZ2h0ID0gJzZweCc7XG4gICAgICB0aGlzLmZyYW1lLmJhci5zdHlsZS5ib3JkZXJSYWRpdXMgPSAnMnB4JztcbiAgICAgIHRoaXMuZnJhbWUuYmFyLnN0eWxlLk1vekJvcmRlclJhZGl1cyA9ICcycHgnO1xuICAgICAgdGhpcy5mcmFtZS5iYXIuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCAjN0Y3RjdGJztcbiAgICAgIHRoaXMuZnJhbWUuYmFyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjRTVFNUU1JztcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZS5iYXIpO1xuXG4gICAgICB0aGlzLmZyYW1lLnNsaWRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSU5QVVQnKTtcbiAgICAgIHRoaXMuZnJhbWUuc2xpZGUudHlwZSA9ICdCVVRUT04nO1xuICAgICAgdGhpcy5mcmFtZS5zbGlkZS5zdHlsZS5tYXJnaW4gPSAnMHB4JztcbiAgICAgIHRoaXMuZnJhbWUuc2xpZGUudmFsdWUgPSAnICc7XG4gICAgICB0aGlzLmZyYW1lLnNsaWRlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgIHRoaXMuZnJhbWUuc2xpZGUuc3R5bGUubGVmdCA9ICctMTAwcHgnO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lLnNsaWRlKTtcblxuICAgICAgLy8gY3JlYXRlIGV2ZW50c1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHRoaXMuZnJhbWUuc2xpZGUub25tb3VzZWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgbWUuX29uTW91c2VEb3duKGV2ZW50KTtcbiAgICAgIH07XG4gICAgICB0aGlzLmZyYW1lLnByZXYub25jbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBtZS5wcmV2KGV2ZW50KTtcbiAgICAgIH07XG4gICAgICB0aGlzLmZyYW1lLnBsYXkub25jbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBtZS50b2dnbGVQbGF5KGV2ZW50KTtcbiAgICAgIH07XG4gICAgICB0aGlzLmZyYW1lLm5leHQub25jbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBtZS5uZXh0KGV2ZW50KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgICB0aGlzLmluZGV4ID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5wbGF5VGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBsYXlJbnRlcnZhbCA9IDEwMDA7IC8vIG1pbGxpc2Vjb25kc1xuICAgIHRoaXMucGxheUxvb3AgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCB0aGUgcHJldmlvdXMgaW5kZXhcbiAgICovXG4gIFNsaWRlci5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmdldEluZGV4KCk7XG4gICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgaW5kZXgtLTtcbiAgICAgIHRoaXMuc2V0SW5kZXgoaW5kZXgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2VsZWN0IHRoZSBuZXh0IGluZGV4XG4gICAqL1xuICBTbGlkZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuICAgIGlmIChpbmRleCA8IHRoaXMudmFsdWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgIGluZGV4Kys7XG4gICAgICB0aGlzLnNldEluZGV4KGluZGV4KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNlbGVjdCB0aGUgbmV4dCBpbmRleFxuICAgKi9cbiAgU2xpZGVyLnByb3RvdHlwZS5wbGF5TmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZSgpO1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuICAgIGlmIChpbmRleCA8IHRoaXMudmFsdWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgIGluZGV4Kys7XG4gICAgICB0aGlzLnNldEluZGV4KGluZGV4KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucGxheUxvb3ApIHtcbiAgICAgIC8vIGp1bXAgdG8gdGhlIHN0YXJ0XG4gICAgICBpbmRleCA9IDA7XG4gICAgICB0aGlzLnNldEluZGV4KGluZGV4KTtcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gbmV3IERhdGUoKTtcbiAgICB2YXIgZGlmZiA9IGVuZCAtIHN0YXJ0O1xuXG4gICAgLy8gY2FsY3VsYXRlIGhvdyBtdWNoIHRpbWUgaXQgdG8gdG8gc2V0IHRoZSBpbmRleCBhbmQgdG8gZXhlY3V0ZSB0aGUgY2FsbGJhY2tcbiAgICAvLyBmdW5jdGlvbi5cbiAgICB2YXIgaW50ZXJ2YWwgPSBNYXRoLm1heCh0aGlzLnBsYXlJbnRlcnZhbCAtIGRpZmYsIDApO1xuICAgIC8vIGRvY3VtZW50LnRpdGxlID0gZGlmZiAvLyBUT0RPOiBjbGVhbnVwXG5cbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHRoaXMucGxheVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIG1lLnBsYXlOZXh0KCk7XG4gICAgfSwgaW50ZXJ2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUb2dnbGUgc3RhcnQgb3Igc3RvcCBwbGF5aW5nXG4gICAqL1xuICBTbGlkZXIucHJvdG90eXBlLnRvZ2dsZVBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucGxheVRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3RhcnQgcGxheWluZ1xuICAgKi9cbiAgU2xpZGVyLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRlc3Qgd2hldGhlciBhbHJlYWR5IHBsYXlpbmdcbiAgICBpZiAodGhpcy5wbGF5VGltZW91dCkgcmV0dXJuO1xuXG4gICAgdGhpcy5wbGF5TmV4dCgpO1xuXG4gICAgaWYgKHRoaXMuZnJhbWUpIHtcbiAgICAgIHRoaXMuZnJhbWUucGxheS52YWx1ZSA9ICdTdG9wJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3AgcGxheWluZ1xuICAgKi9cbiAgU2xpZGVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5wbGF5VGltZW91dCk7XG4gICAgdGhpcy5wbGF5VGltZW91dCA9IHVuZGVmaW5lZDtcblxuICAgIGlmICh0aGlzLmZyYW1lKSB7XG4gICAgICB0aGlzLmZyYW1lLnBsYXkudmFsdWUgPSAnUGxheSc7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSB2YWx1ZSBvZiB0aGVcbiAgICogc2xpZGVyIGJhciBoYXMgY2hhbmdlZC5cbiAgICovXG4gIFNsaWRlci5wcm90b3R5cGUuc2V0T25DaGFuZ2VDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGludGVydmFsIGZvciBwbGF5aW5nIHRoZSBsaXN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnZhbCAgIFRoZSBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHNcbiAgICovXG4gIFNsaWRlci5wcm90b3R5cGUuc2V0UGxheUludGVydmFsID0gZnVuY3Rpb24gKGludGVydmFsKSB7XG4gICAgdGhpcy5wbGF5SW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIGN1cnJlbnQgcGxheSBpbnRlcnZhbFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGludGVydmFsICAgVGhlIGludGVydmFsIGluIG1pbGxpc2Vjb25kc1xuICAgKi9cbiAgU2xpZGVyLnByb3RvdHlwZS5nZXRQbGF5SW50ZXJ2YWwgPSBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5SW50ZXJ2YWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBsb29waW5nIG9uIG9yIG9mZlxuICAgKiBAcGFyYXJtIHtib29sZWFufSBkb0xvb3AgIElmIHRydWUsIHRoZSBzbGlkZXIgd2lsbCBqdW1wIHRvIHRoZSBzdGFydCB3aGVuXG4gICAqICAgICAgICAgICAgICAgdGhlIGVuZCBpcyBwYXNzZWQsIGFuZCB3aWxsIGp1bXAgdG8gdGhlIGVuZFxuICAgKiAgICAgICAgICAgICAgIHdoZW4gdGhlIHN0YXJ0IGlzIHBhc3NlZC5cbiAgICovXG4gIFNsaWRlci5wcm90b3R5cGUuc2V0UGxheUxvb3AgPSBmdW5jdGlvbiAoZG9Mb29wKSB7XG4gICAgdGhpcy5wbGF5TG9vcCA9IGRvTG9vcDtcbiAgfTtcblxuICAvKipcbiAgICogRXhlY3V0ZSB0aGUgb25jaGFuZ2UgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICovXG4gIFNsaWRlci5wcm90b3R5cGUub25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub25DaGFuZ2VDYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIHJlZHJhdyB0aGUgc2xpZGVyIG9uIHRoZSBjb3JyZWN0IHBsYWNlXG4gICAqL1xuICBTbGlkZXIucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5mcmFtZSkge1xuICAgICAgLy8gcmVzaXplIHRoZSBiYXJcbiAgICAgIHRoaXMuZnJhbWUuYmFyLnN0eWxlLnRvcCA9IHRoaXMuZnJhbWUuY2xpZW50SGVpZ2h0IC8gMiAtIHRoaXMuZnJhbWUuYmFyLm9mZnNldEhlaWdodCAvIDIgKyAncHgnO1xuICAgICAgdGhpcy5mcmFtZS5iYXIuc3R5bGUud2lkdGggPSB0aGlzLmZyYW1lLmNsaWVudFdpZHRoIC0gdGhpcy5mcmFtZS5wcmV2LmNsaWVudFdpZHRoIC0gdGhpcy5mcmFtZS5wbGF5LmNsaWVudFdpZHRoIC0gdGhpcy5mcmFtZS5uZXh0LmNsaWVudFdpZHRoIC0gMzAgKyAncHgnO1xuXG4gICAgICAvLyBwb3NpdGlvbiB0aGUgc2xpZGVyIGJ1dHRvblxuICAgICAgdmFyIGxlZnQgPSB0aGlzLmluZGV4VG9MZWZ0KHRoaXMuaW5kZXgpO1xuICAgICAgdGhpcy5mcmFtZS5zbGlkZS5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGxpc3Qgd2l0aCB2YWx1ZXMgZm9yIHRoZSBzbGlkZXJcbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzICAgQSBqYXZhc2NyaXB0IGFycmF5IHdpdGggdmFsdWVzIChhbnkgdHlwZSlcbiAgICovXG4gIFNsaWRlci5wcm90b3R5cGUuc2V0VmFsdWVzID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuXG4gICAgaWYgKHRoaXMudmFsdWVzLmxlbmd0aCA+IDApIHRoaXMuc2V0SW5kZXgoMCk7ZWxzZSB0aGlzLmluZGV4ID0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZWxlY3QgYSB2YWx1ZSBieSBpdHMgaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqL1xuICBTbGlkZXIucHJvdG90eXBlLnNldEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgdGhpcy52YWx1ZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG5cbiAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiByZXRyaWV2ZSB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB2YXVlXG4gICAqIEByZXR1cm4ge051bWJlcn0gaW5kZXhcbiAgICovXG4gIFNsaWRlci5wcm90b3R5cGUuZ2V0SW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXg7XG4gIH07XG5cbiAgLyoqXG4gICAqIHJldHJpZXZlIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdmFsdWVcbiAgICogQHJldHVybiB7Kn0gdmFsdWVcbiAgICovXG4gIFNsaWRlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1t0aGlzLmluZGV4XTtcbiAgfTtcblxuICBTbGlkZXIucHJvdG90eXBlLl9vbk1vdXNlRG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIG9ubHkgcmVhY3Qgb24gbGVmdCBtb3VzZSBidXR0b24gZG93blxuICAgIHZhciBsZWZ0QnV0dG9uRG93biA9IGV2ZW50LndoaWNoID8gZXZlbnQud2hpY2ggPT09IDEgOiBldmVudC5idXR0b24gPT09IDE7XG4gICAgaWYgKCFsZWZ0QnV0dG9uRG93bikgcmV0dXJuO1xuXG4gICAgdGhpcy5zdGFydENsaWVudFggPSBldmVudC5jbGllbnRYO1xuICAgIHRoaXMuc3RhcnRTbGlkZVggPSBwYXJzZUZsb2F0KHRoaXMuZnJhbWUuc2xpZGUuc3R5bGUubGVmdCk7XG5cbiAgICB0aGlzLmZyYW1lLnN0eWxlLmN1cnNvciA9ICdtb3ZlJztcblxuICAgIC8vIGFkZCBldmVudCBsaXN0ZW5lcnMgdG8gaGFuZGxlIG1vdmluZyB0aGUgY29udGVudHNcbiAgICAvLyB3ZSBzdG9yZSB0aGUgZnVuY3Rpb24gb25tb3VzZW1vdmUgYW5kIG9ubW91c2V1cCBpbiB0aGUgZ3JhcGgsIHNvIHdlIGNhblxuICAgIC8vIHJlbW92ZSB0aGUgZXZlbnRsaXN0ZW5lcnMgbGF0ZXJvbiBpbiB0aGUgZnVuY3Rpb24gbW91c2VVcCgpXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB0aGlzLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBtZS5fb25Nb3VzZU1vdmUoZXZlbnQpO1xuICAgIH07XG4gICAgdGhpcy5vbm1vdXNldXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIG1lLl9vbk1vdXNlVXAoZXZlbnQpO1xuICAgIH07XG4gICAgdXRpbC5hZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5vbm1vdXNlbW92ZSk7XG4gICAgdXRpbC5hZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMub25tb3VzZXVwKTtcbiAgICB1dGlsLnByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgfTtcblxuICBTbGlkZXIucHJvdG90eXBlLmxlZnRUb0luZGV4ID0gZnVuY3Rpb24gKGxlZnQpIHtcbiAgICB2YXIgd2lkdGggPSBwYXJzZUZsb2F0KHRoaXMuZnJhbWUuYmFyLnN0eWxlLndpZHRoKSAtIHRoaXMuZnJhbWUuc2xpZGUuY2xpZW50V2lkdGggLSAxMDtcbiAgICB2YXIgeCA9IGxlZnQgLSAzO1xuXG4gICAgdmFyIGluZGV4ID0gTWF0aC5yb3VuZCh4IC8gd2lkdGggKiAodGhpcy52YWx1ZXMubGVuZ3RoIC0gMSkpO1xuICAgIGlmIChpbmRleCA8IDApIGluZGV4ID0gMDtcbiAgICBpZiAoaW5kZXggPiB0aGlzLnZhbHVlcy5sZW5ndGggLSAxKSBpbmRleCA9IHRoaXMudmFsdWVzLmxlbmd0aCAtIDE7XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH07XG5cbiAgU2xpZGVyLnByb3RvdHlwZS5pbmRleFRvTGVmdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciB3aWR0aCA9IHBhcnNlRmxvYXQodGhpcy5mcmFtZS5iYXIuc3R5bGUud2lkdGgpIC0gdGhpcy5mcmFtZS5zbGlkZS5jbGllbnRXaWR0aCAtIDEwO1xuXG4gICAgdmFyIHggPSBpbmRleCAvICh0aGlzLnZhbHVlcy5sZW5ndGggLSAxKSAqIHdpZHRoO1xuICAgIHZhciBsZWZ0ID0geCArIDM7XG5cbiAgICByZXR1cm4gbGVmdDtcbiAgfTtcblxuICBTbGlkZXIucHJvdG90eXBlLl9vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBkaWZmID0gZXZlbnQuY2xpZW50WCAtIHRoaXMuc3RhcnRDbGllbnRYO1xuICAgIHZhciB4ID0gdGhpcy5zdGFydFNsaWRlWCArIGRpZmY7XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLmxlZnRUb0luZGV4KHgpO1xuXG4gICAgdGhpcy5zZXRJbmRleChpbmRleCk7XG5cbiAgICB1dGlsLnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG5cbiAgU2xpZGVyLnByb3RvdHlwZS5fb25Nb3VzZVVwID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy5mcmFtZS5zdHlsZS5jdXJzb3IgPSAnYXV0byc7XG5cbiAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAgdXRpbC5yZW1vdmVFdmVudExpc3RlbmVyKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5vbm1vdXNlbW92ZSk7XG4gICAgdXRpbC5yZW1vdmVFdmVudExpc3RlbmVyKGRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMub25tb3VzZXVwKTtcblxuICAgIHV0aWwucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFNsaWRlcjtcblxuLyoqKi8gfSxcbi8qIDE5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIEBwcm90b3R5cGUgU3RlcE51bWJlclxuICAgKiBUaGUgY2xhc3MgU3RlcE51bWJlciBpcyBhbiBpdGVyYXRvciBmb3IgTnVtYmVycy4gWW91IHByb3ZpZGUgYSBzdGFydCBhbmQgZW5kXG4gICAqIHZhbHVlLCBhbmQgYSBiZXN0IHN0ZXAgc2l6ZS4gU3RlcE51bWJlciBpdHNlbGYgcm91bmRzIHRvIGZpeGVkIHZhbHVlcyBhbmRcbiAgICogYSBmaW5kcyB0aGUgc3RlcCB0aGF0IGJlc3QgZml0cyB0aGUgcHJvdmlkZWQgc3RlcC5cbiAgICpcbiAgICogSWYgcHJldHR5U3RlcCBpcyB0cnVlLCB0aGUgc3RlcCBzaXplIGlzIGNob3NlbiBhcyBjbG9zZSBhcyBwb3NzaWJsZSB0byB0aGVcbiAgICogcHJvdmlkZWQgc3RlcCwgYnV0IGJlaW5nIGEgcm91bmQgdmFsdWUgbGlrZSAxLCAyLCA1LCAxMCwgMjAsIDUwLCAuLi4uXG4gICAqXG4gICAqIEV4YW1wbGUgdXNhZ2U6XG4gICAqICAgdmFyIHN0ZXAgPSBuZXcgU3RlcE51bWJlcigwLCAxMCwgMi41LCB0cnVlKTtcbiAgICogICBzdGVwLnN0YXJ0KCk7XG4gICAqICAgd2hpbGUgKCFzdGVwLmVuZCgpKSB7XG4gICAqICAgYWxlcnQoc3RlcC5nZXRDdXJyZW50KCkpO1xuICAgKiAgIHN0ZXAubmV4dCgpO1xuICAgKiAgIH1cbiAgICpcbiAgICogVmVyc2lvbjogMS4wXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCAgICAgVGhlIHN0YXJ0IHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgICAgIFRoZSBlbmQgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXAgICAgT3B0aW9uYWwuIFN0ZXAgc2l6ZS4gTXVzdCBiZSBhIHBvc2l0aXZlIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByZXR0eVN0ZXAgT3B0aW9uYWwuIElmIHRydWUsIHRoZSBzdGVwIHNpemUgaXMgcm91bmRlZFxuICAgKiAgICAgICAgICAgICAgIFRvIGEgcHJldHR5IHN0ZXAgc2l6ZSAobGlrZSAxLCAyLCA1LCAxMCwgMjAsIDUwLCAuLi4pXG4gICAqL1xuICBmdW5jdGlvbiBTdGVwTnVtYmVyKHN0YXJ0LCBlbmQsIHN0ZXAsIHByZXR0eVN0ZXApIHtcbiAgICAvLyBzZXQgZGVmYXVsdCB2YWx1ZXNcbiAgICB0aGlzLl9zdGFydCA9IDA7XG4gICAgdGhpcy5fZW5kID0gMDtcbiAgICB0aGlzLl9zdGVwID0gMTtcbiAgICB0aGlzLnByZXR0eVN0ZXAgPSB0cnVlO1xuICAgIHRoaXMucHJlY2lzaW9uID0gNTtcblxuICAgIHRoaXMuX2N1cnJlbnQgPSAwO1xuICAgIHRoaXMuc2V0UmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgcHJldHR5U3RlcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGZvciBpbnB1dCB2YWx1ZXMsIHRvIHByZXZlbnQgZGlzYXN0ZXJzIGZyb20gaGFwcGVuaW5nXG4gICAqXG4gICAqIFNvdXJjZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTgzMDg0NFxuICAgKi9cbiAgU3RlcE51bWJlci5wcm90b3R5cGUuaXNOdW1lcmljID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYSBuZXcgcmFuZ2U6IHN0YXJ0LCBlbmQgYW5kIHN0ZXAuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCAgICAgVGhlIHN0YXJ0IHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgICAgIFRoZSBlbmQgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXAgICAgT3B0aW9uYWwuIFN0ZXAgc2l6ZS4gTXVzdCBiZSBhIHBvc2l0aXZlIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByZXR0eVN0ZXAgT3B0aW9uYWwuIElmIHRydWUsIHRoZSBzdGVwIHNpemUgaXMgcm91bmRlZFxuICAgKiAgICAgICAgICAgICAgIFRvIGEgcHJldHR5IHN0ZXAgc2l6ZSAobGlrZSAxLCAyLCA1LCAxMCwgMjAsIDUwLCAuLi4pXG4gICAqL1xuICBTdGVwTnVtYmVyLnByb3RvdHlwZS5zZXRSYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBzdGVwLCBwcmV0dHlTdGVwKSB7XG4gICAgaWYgKCF0aGlzLmlzTnVtZXJpYyhzdGFydCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGFyYW1ldGVyIFxcJ3N0YXJ0XFwnIGlzIG5vdCBudW1lcmljOyB2YWx1ZTogJyArIHN0YXJ0KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzTnVtZXJpYyhlbmQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlciBcXCdlbmRcXCcgaXMgbm90IG51bWVyaWM7IHZhbHVlOiAnICsgc3RhcnQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNOdW1lcmljKHN0ZXApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlciBcXCdzdGVwXFwnIGlzIG5vdCBudW1lcmljOyB2YWx1ZTogJyArIHN0YXJ0KTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdGFydCA9IHN0YXJ0ID8gc3RhcnQgOiAwO1xuICAgIHRoaXMuX2VuZCA9IGVuZCA/IGVuZCA6IDA7XG5cbiAgICB0aGlzLnNldFN0ZXAoc3RlcCwgcHJldHR5U3RlcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIG5ldyBzdGVwIHNpemVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXAgICAgTmV3IHN0ZXAgc2l6ZS4gTXVzdCBiZSBhIHBvc2l0aXZlIHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJldHR5U3RlcCBPcHRpb25hbC4gSWYgdHJ1ZSwgdGhlIHByb3ZpZGVkIHN0ZXAgaXMgcm91bmRlZFxuICAgKiAgICAgICAgICAgICAgIHRvIGEgcHJldHR5IHN0ZXAgc2l6ZSAobGlrZSAxLCAyLCA1LCAxMCwgMjAsIDUwLCAuLi4pXG4gICAqL1xuICBTdGVwTnVtYmVyLnByb3RvdHlwZS5zZXRTdGVwID0gZnVuY3Rpb24gKHN0ZXAsIHByZXR0eVN0ZXApIHtcbiAgICBpZiAoc3RlcCA9PT0gdW5kZWZpbmVkIHx8IHN0ZXAgPD0gMCkgcmV0dXJuO1xuXG4gICAgaWYgKHByZXR0eVN0ZXAgIT09IHVuZGVmaW5lZCkgdGhpcy5wcmV0dHlTdGVwID0gcHJldHR5U3RlcDtcblxuICAgIGlmICh0aGlzLnByZXR0eVN0ZXAgPT09IHRydWUpIHRoaXMuX3N0ZXAgPSBTdGVwTnVtYmVyLmNhbGN1bGF0ZVByZXR0eVN0ZXAoc3RlcCk7ZWxzZSB0aGlzLl9zdGVwID0gc3RlcDtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGEgbmljZSBzdGVwIHNpemUsIGNsb3Nlc3QgdG8gdGhlIGRlc2lyZWQgc3RlcCBzaXplLlxuICAgKiBSZXR1cm5zIGEgdmFsdWUgaW4gb25lIG9mIHRoZSByYW5nZXMgMSoxMF5uLCAyKjEwXm4sIG9yIDUqMTBebiwgd2hlcmUgbiBpcyBhblxuICAgKiBpbnRlZ2VyIE51bWJlci4gRm9yIGV4YW1wbGUgMSwgMiwgNSwgMTAsIDIwLCA1MCwgZXRjLi4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgc3RlcCAgRGVzaXJlZCBzdGVwIHNpemVcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgTmljZSBzdGVwIHNpemVcbiAgICovXG4gIFN0ZXBOdW1iZXIuY2FsY3VsYXRlUHJldHR5U3RlcCA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgdmFyIGxvZzEwID0gZnVuY3Rpb24gbG9nMTAoeCkge1xuICAgICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjEwO1xuICAgIH07XG5cbiAgICAvLyB0cnkgdGhyZWUgc3RlcHMgKG11bHRpcGxlIG9mIDEsIDIsIG9yIDVcbiAgICB2YXIgc3RlcDEgPSBNYXRoLnBvdygxMCwgTWF0aC5yb3VuZChsb2cxMChzdGVwKSkpLFxuICAgICAgICBzdGVwMiA9IDIgKiBNYXRoLnBvdygxMCwgTWF0aC5yb3VuZChsb2cxMChzdGVwIC8gMikpKSxcbiAgICAgICAgc3RlcDUgPSA1ICogTWF0aC5wb3coMTAsIE1hdGgucm91bmQobG9nMTAoc3RlcCAvIDUpKSk7XG5cbiAgICAvLyBjaG9vc2UgdGhlIGJlc3Qgc3RlcCAoY2xvc2VzdCB0byBtaW5pbXVtIHN0ZXApXG4gICAgdmFyIHByZXR0eVN0ZXAgPSBzdGVwMTtcbiAgICBpZiAoTWF0aC5hYnMoc3RlcDIgLSBzdGVwKSA8PSBNYXRoLmFicyhwcmV0dHlTdGVwIC0gc3RlcCkpIHByZXR0eVN0ZXAgPSBzdGVwMjtcbiAgICBpZiAoTWF0aC5hYnMoc3RlcDUgLSBzdGVwKSA8PSBNYXRoLmFicyhwcmV0dHlTdGVwIC0gc3RlcCkpIHByZXR0eVN0ZXAgPSBzdGVwNTtcblxuICAgIC8vIGZvciBzYWZldHlcbiAgICBpZiAocHJldHR5U3RlcCA8PSAwKSB7XG4gICAgICBwcmV0dHlTdGVwID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJldHR5U3RlcDtcbiAgfTtcblxuICAvKipcbiAgICogcmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgc3RlcFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGN1cnJlbnQgdmFsdWVcbiAgICovXG4gIFN0ZXBOdW1iZXIucHJvdG90eXBlLmdldEN1cnJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy5fY3VycmVudC50b1ByZWNpc2lvbih0aGlzLnByZWNpc2lvbikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiByZXR1cm5zIHRoZSBjdXJyZW50IHN0ZXAgc2l6ZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGN1cnJlbnQgc3RlcCBzaXplXG4gICAqL1xuICBTdGVwTnVtYmVyLnByb3RvdHlwZS5nZXRTdGVwID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGVwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGN1cnJlbnQgdG8gaXRzIHN0YXJ0aW5nIHZhbHVlLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIHdpbGwgYmUgdGhlIGxhcmdlc3QgdmFsdWUgc21hbGxlciB0aGFuIHN0YXJ0LCB3aGljaFxuICAgKiBpcyBhIG11bHRpcGxlIG9mIHRoZSBzdGVwIHNpemUuXG4gICAqXG4gICAqIFBhcmFtZXRlcnMgY2hlY2tGaXJzdCBpcyBvcHRpb25hbCwgZGVmYXVsdCBmYWxzZS5cbiAgICogSWYgc2V0IHRvIHRydWUsIG1vdmUgdGhlIGN1cnJlbnQgdmFsdWUgb25lIHN0ZXAgaWYgc21hbGxlciB0aGFuIHN0YXJ0LlxuICAgKi9cbiAgU3RlcE51bWJlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoY2hlY2tGaXJzdCkge1xuICAgIGlmIChjaGVja0ZpcnN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNoZWNrRmlyc3QgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fc3RhcnQgLSB0aGlzLl9zdGFydCAlIHRoaXMuX3N0ZXA7XG5cbiAgICBpZiAoY2hlY2tGaXJzdCkge1xuICAgICAgaWYgKHRoaXMuZ2V0Q3VycmVudCgpIDwgdGhpcy5fc3RhcnQpIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEbyBhIHN0ZXAsIGFkZCB0aGUgc3RlcCBzaXplIHRvIHRoZSBjdXJyZW50IHZhbHVlXG4gICAqL1xuICBTdGVwTnVtYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2N1cnJlbnQgKz0gdGhpcy5fc3RlcDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIHdoZXRoZXIgdGhlIGVuZCBpcyByZWFjaGVkXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59ICBUcnVlIGlmIHRoZSBjdXJyZW50IHZhbHVlIGhhcyBwYXNzZWQgdGhlIGVuZCB2YWx1ZS5cbiAgICovXG4gIFN0ZXBOdW1iZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudCA+IHRoaXMuX2VuZDtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFN0ZXBOdW1iZXI7XG5cbi8qKiovIH0sXG4vKiAyMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBAcHJvdG90eXBlIFJhbmdlXG4gICAqXG4gICAqIEhlbHBlciBjbGFzcyB0byBtYWtlIHdvcmtpbmcgd2l0aCByZWxhdGVkIG1pbiBhbmQgbWF4IHZhbHVlcyBlYXNpZXIuXG4gICAqXG4gICAqIFRoZSByYW5nZSBpcyBpbmNsdXNpdmU7IGEgZ2l2ZW4gdmFsdWUgaXMgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSByYW5nZSBpZjpcbiAgICpcbiAgICogICAgdGhpcy5taW4gPD0gdmFsdWUgPD0gdGhpcy5tYXhcbiAgICovXG4gIGZ1bmN0aW9uIFJhbmdlKCkge1xuICAgIHRoaXMubWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkanVzdCB0aGUgcmFuZ2Ugc28gdGhhdCB0aGUgcGFzc2VkIHZhbHVlIGZpdHMgaW4gaXQuXG4gICAqXG4gICAqIElmIHRoZSB2YWx1ZSBpcyBvdXRzaWRlIG9mIHRoZSBjdXJyZW50IGV4dHJlbWVzLCBhZGp1c3RcbiAgICogdGhlIG1pbiBvciBtYXggc28gdGhhdCB0aGUgdmFsdWUgaXMgd2l0aGluIHRoZSByYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIE51bWVyaWMgdmFsdWUgdG8gZml0IGluIHJhbmdlXG4gICAqL1xuICBSYW5nZS5wcm90b3R5cGUuYWRqdXN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgIGlmICh0aGlzLm1pbiA9PT0gdW5kZWZpbmVkIHx8IHRoaXMubWluID4gdmFsdWUpIHtcbiAgICAgIHRoaXMubWluID0gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWF4ID09PSB1bmRlZmluZWQgfHwgdGhpcy5tYXggPCB2YWx1ZSkge1xuICAgICAgdGhpcy5tYXggPSB2YWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkanVzdCB0aGUgY3VycmVudCByYW5nZSBzbyB0aGF0IHRoZSBwYXNzZWQgcmFuZ2UgZml0cyBpbiBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtSYW5nZX0gcmFuZ2UgUmFuZ2UgaW5zdGFuY2UgdG8gZml0IGluIGN1cnJlbnQgaW5zdGFuY2VcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5jb21iaW5lID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgdGhpcy5hZGQocmFuZ2UubWluKTtcbiAgICB0aGlzLmFkZChyYW5nZS5tYXgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeHBhbmQgdGhlIHJhbmdlIGJ5IHRoZSBnaXZlbiB2YWx1ZVxuICAgKlxuICAgKiBtaW4gd2lsbCBiZSBsb3dlcmVkIGJ5IGdpdmVuIHZhbHVlO1xuICAgKiBtYXggd2lsbCBiZSByYWlzZWQgYnkgZ2l2ZW4gdmFsdWVcbiAgICpcbiAgICogU2hyaW5raW5nIGJ5IHBhc3NpbmcgYSBuZWdhdGl2ZSB2YWx1ZSBpcyBhbGxvd2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIEFtb3VudCBieSB3aGljaCB0byBleHBhbmQgb3Igc2hyaW5rIGN1cnJlbnQgcmFuZ2Ugd2l0aFxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV3TWluID0gdGhpcy5taW4gLSB2YWw7XG4gICAgdmFyIG5ld01heCA9IHRoaXMubWF4ICsgdmFsO1xuXG4gICAgLy8gTm90ZSB0aGF0IGZvbGxvd2luZyBhbGxvd3MgbmV3TWluID09PSBuZXdNYXguXG4gICAgLy8gVGhpcyBzaG91bGQgYmUgT0ssIHNpbmNlIG1ldGhvZCBleHBhbmQoKSBhbGxvd3MgdGhpcyBhbHNvLlxuICAgIGlmIChuZXdNaW4gPiBuZXdNYXgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGFzc2VkIGV4cGFuc2lvbiB2YWx1ZSBtYWtlcyByYW5nZSBpbnZhbGlkJyk7XG4gICAgfVxuXG4gICAgdGhpcy5taW4gPSBuZXdNaW47XG4gICAgdGhpcy5tYXggPSBuZXdNYXg7XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgZnVsbCByYW5nZSB3aWR0aCBvZiBjdXJyZW50IGluc3RhbmNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtfSBUaGUgY2FsY3VsYXRlZCB3aWR0aCBvZiB0aGlzIHJhbmdlXG4gICAqL1xuICBSYW5nZS5wcm90b3R5cGUucmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4IC0gdGhpcy5taW47XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgY2VudHJhbCBwb2ludCBvZiBjdXJyZW50IGluc3RhbmNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgdmFsdWUgaW4gdGhlIG1pZGRsZSBvZiBtaW4gYW5kIG1heFxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLmNlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMubWluICsgdGhpcy5tYXgpIC8gMjtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFJhbmdlO1xuXG4vKioqLyB9LFxuLyogMjEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gVGhpcyBtb2R1bGVzIGhhbmRsZXMgdGhlIG9wdGlvbnMgZm9yIEdyYXBoM2QuXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIHZhciBDYW1lcmEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcbiAgdmFyIFBvaW50M2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxuICAvLyBlbnVtZXJhdGUgdGhlIGF2YWlsYWJsZSBzdHlsZXNcbiAgdmFyIFNUWUxFID0ge1xuICAgIEJBUjogMCxcbiAgICBCQVJDT0xPUjogMSxcbiAgICBCQVJTSVpFOiAyLFxuICAgIERPVDogMyxcbiAgICBET1RMSU5FOiA0LFxuICAgIERPVENPTE9SOiA1LFxuICAgIERPVFNJWkU6IDYsXG4gICAgR1JJRDogNyxcbiAgICBMSU5FOiA4LFxuICAgIFNVUkZBQ0U6IDlcbiAgfTtcblxuICAvLyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9ucyBvZiB0aGUgc3R5bGVzXG4gIHZhciBTVFlMRU5BTUUgPSB7XG4gICAgJ2RvdCc6IFNUWUxFLkRPVCxcbiAgICAnZG90LWxpbmUnOiBTVFlMRS5ET1RMSU5FLFxuICAgICdkb3QtY29sb3InOiBTVFlMRS5ET1RDT0xPUixcbiAgICAnZG90LXNpemUnOiBTVFlMRS5ET1RTSVpFLFxuICAgICdsaW5lJzogU1RZTEUuTElORSxcbiAgICAnZ3JpZCc6IFNUWUxFLkdSSUQsXG4gICAgJ3N1cmZhY2UnOiBTVFlMRS5TVVJGQUNFLFxuICAgICdiYXInOiBTVFlMRS5CQVIsXG4gICAgJ2Jhci1jb2xvcic6IFNUWUxFLkJBUkNPTE9SLFxuICAgICdiYXItc2l6ZSc6IFNUWUxFLkJBUlNJWkVcbiAgfTtcblxuICAvKipcbiAgICogRmllbGQgbmFtZXMgaW4gdGhlIG9wdGlvbnMgaGFzaCB3aGljaCBhcmUgb2YgcmVsZXZhbmNlIHRvIHRoZSB1c2VyLlxuICAgKlxuICAgKiBTcGVjaWZpY2FsbHksIHRoZXNlIGFyZSB0aGUgZmllbGRzIHdoaWNoIHJlcXVpcmUgbm8gc3BlY2lhbCBoYW5kbGluZyxcbiAgICogYW5kIGNhbiBiZSBkaXJlY3RseSBjb3BpZWQgb3Zlci5cbiAgICovXG4gIHZhciBPUFRJT05LRVlTID0gWyd3aWR0aCcsICdoZWlnaHQnLCAnZmlsdGVyTGFiZWwnLCAnbGVnZW5kTGFiZWwnLCAneExhYmVsJywgJ3lMYWJlbCcsICd6TGFiZWwnLCAneFZhbHVlTGFiZWwnLCAneVZhbHVlTGFiZWwnLCAnelZhbHVlTGFiZWwnLCAnc2hvd0dyaWQnLCAnc2hvd1BlcnNwZWN0aXZlJywgJ3Nob3dTaGFkb3cnLCAna2VlcEFzcGVjdFJhdGlvJywgJ3ZlcnRpY2FsUmF0aW8nLCAnZG90U2l6ZVJhdGlvJywgJ3Nob3dBbmltYXRpb25Db250cm9scycsICdhbmltYXRpb25JbnRlcnZhbCcsICdhbmltYXRpb25QcmVsb2FkJywgJ2FuaW1hdGlvbkF1dG9TdGFydCcsICdheGlzQ29sb3InLCAnZ3JpZENvbG9yJywgJ3hDZW50ZXInLCAneUNlbnRlciddO1xuXG4gIC8qKlxuICAgKiBGaWVsZCBuYW1lcyBpbiB0aGUgb3B0aW9ucyBoYXNoIHdoaWNoIGFyZSBvZiByZWxldmFuY2UgdG8gdGhlIHVzZXIuXG4gICAqXG4gICAqIFNhbWUgYXMgT1BUSU9OS0VZUywgYnV0IGludGVybmFsbHkgdGhlc2UgZmllbGRzIGFyZSBzdG9yZWQgd2l0aCBcbiAgICogcHJlZml4ICdkZWZhdWx0JyBpbiB0aGUgbmFtZS5cbiAgICovXG4gIHZhciBQUkVGSVhFRE9QVElPTktFWVMgPSBbJ3hCYXJXaWR0aCcsICd5QmFyV2lkdGgnLCAndmFsdWVNaW4nLCAndmFsdWVNYXgnLCAneE1pbicsICd4TWF4JywgJ3hTdGVwJywgJ3lNaW4nLCAneU1heCcsICd5U3RlcCcsICd6TWluJywgJ3pNYXgnLCAnelN0ZXAnXTtcblxuICAvLyBQbGFjZWhvbGRlciBmb3IgREVGQVVMVFMgcmVmZXJlbmNlXG4gIHZhciBERUZBVUxUUyA9IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgZ2l2ZW4gaGFzaCBpcyBlbXB0eS5cbiAgICpcbiAgICogU291cmNlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS82Nzk5MzdcbiAgICovXG4gIGZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGZpcnN0IGxldHRlciBvZiBwYXJhbWV0ZXIgdXBwZXIgY2FzZS5cbiAgICpcbiAgICogU291cmNlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMDI2MDg3XG4gICAqL1xuICBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cikge1xuICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCB8fCBzdHIgPT09IFwiXCIpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBwcmVmaXggdG8gYSBmaWVsZCBuYW1lLCB0YWtpbmcgc3R5bGUgZ3VpZGUgaW50byBhY2NvdW50XG4gICAqL1xuICBmdW5jdGlvbiBwcmVmaXhGaWVsZE5hbWUocHJlZml4LCBmaWVsZE5hbWUpIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQgfHwgcHJlZml4ID09PSBcIlwiKSB7XG4gICAgICByZXR1cm4gZmllbGROYW1lO1xuICAgIH1cblxuICAgIHJldHVybiBwcmVmaXggKyBjYXBpdGFsaXplKGZpZWxkTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2libHkgY29weSBmaWVsZHMgZnJvbSBzcmMgdG8gZHN0IGluIGEgY29udHJvbGxlZCBtYW5uZXIuXG4gICAqXG4gICAqIEEgZ2l2ZW4gZmllbGQgaW4gZHN0IHdpbGwgYWx3YXlzIGJlIG92ZXJ3aXR0ZW4uIElmIHRoaXMgZmllbGRcbiAgICogaXMgdW5kZWZpbmVkIG9yIG5vdCBwcmVzZW50IGluIHNyYywgdGhlIGZpZWxkIGluIGRzdCB3aWxsIFxuICAgKiBiZSBleHBsaWNpdGx5IHNldCB0byB1bmRlZmluZWQuXG4gICAqIFxuICAgKiBUaGUgaW50ZW50aW9uIGhlcmUgaXMgdG8gYmUgYWJsZSB0byByZXNldCBhbGwgb3B0aW9uIGZpZWxkcy5cbiAgICogXG4gICAqIE9ubHkgdGhlIGZpZWxkcyBtZW50aW9uZWQgaW4gYXJyYXkgJ2ZpZWxkcycgd2lsbCBiZSBoYW5kbGVkLlxuICAgKlxuICAgKiBAcGFyYW0gZmllbGRzIGFycmF5IHdpdGggbmFtZXMgb2YgZmllbGRzIHRvIGNvcHlcbiAgICogQHBhcmFtIHByZWZpeCBvcHRpb25hbDsgcHJlZml4IHRvIHVzZSBmb3IgdGhlIHRhcmdldCBmaWVsZHMuXG4gICAqL1xuICBmdW5jdGlvbiBmb3JjZUNvcHkoc3JjLCBkc3QsIGZpZWxkcywgcHJlZml4KSB7XG4gICAgdmFyIHNyY0tleTtcbiAgICB2YXIgZHN0S2V5O1xuXG4gICAgZm9yICh2YXIgaSBpbiBmaWVsZHMpIHtcbiAgICAgIHNyY0tleSA9IGZpZWxkc1tpXTtcbiAgICAgIGRzdEtleSA9IHByZWZpeEZpZWxkTmFtZShwcmVmaXgsIHNyY0tleSk7XG5cbiAgICAgIGRzdFtkc3RLZXldID0gc3JjW3NyY0tleV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvcHkgZmllbGRzIGZyb20gc3JjIHRvIGRzdCBpbiBhIHNhZmUgYW5kIGNvbnRyb2xsZWQgbWFubmVyLlxuICAgKlxuICAgKiBPbmx5IHRoZSBmaWVsZHMgbWVudGlvbmVkIGluIGFycmF5ICdmaWVsZHMnIHdpbGwgYmUgY29waWVkIG92ZXIsXG4gICAqIGFuZCBvbmx5IGlmIHRoZXNlIGFyZSBhY3R1YWxseSBkZWZpbmVkLlxuICAgKlxuICAgKiBAcGFyYW0gZmllbGRzIGFycmF5IHdpdGggbmFtZXMgb2YgZmllbGRzIHRvIGNvcHlcbiAgICogQHBhcmFtIHByZWZpeCBvcHRpb25hbDsgcHJlZml4IHRvIHVzZSBmb3IgdGhlIHRhcmdldCBmaWVsZHMuXG4gICAqL1xuICBmdW5jdGlvbiBzYWZlQ29weShzcmMsIGRzdCwgZmllbGRzLCBwcmVmaXgpIHtcbiAgICB2YXIgc3JjS2V5O1xuICAgIHZhciBkc3RLZXk7XG5cbiAgICBmb3IgKHZhciBpIGluIGZpZWxkcykge1xuICAgICAgc3JjS2V5ID0gZmllbGRzW2ldO1xuICAgICAgaWYgKHNyY1tzcmNLZXldID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuXG4gICAgICBkc3RLZXkgPSBwcmVmaXhGaWVsZE5hbWUocHJlZml4LCBzcmNLZXkpO1xuXG4gICAgICBkc3RbZHN0S2V5XSA9IHNyY1tzcmNLZXldO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGRzdCB3aXRoIHRoZSB2YWx1ZXMgaW4gc3JjLlxuICAgKlxuICAgKiBzcmMgaXMgdGhlIGhhc2ggd2l0aCB0aGUgZGVmYXVsdCB2YWx1ZXMuIFxuICAgKiBBIHJlZmVyZW5jZSBERUZBVUxUUyB0byB0aGlzIGhhc2ggaXMgc3RvcmVkIGxvY2FsbHkgZm9yIFxuICAgKiBmdXJ0aGVyIGhhbmRsaW5nLlxuICAgKlxuICAgKiBGb3Igbm93LCBkc3QgaXMgYXNzdW1lZCB0byBiZSBhIEdyYXBoM2QgaW5zdGFuY2UuXG4gICAqL1xuICBmdW5jdGlvbiBzZXREZWZhdWx0cyhzcmMsIGRzdCkge1xuICAgIGlmIChzcmMgPT09IHVuZGVmaW5lZCB8fCBpc0VtcHR5KHNyYykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gREVGQVVMVFMgcGFzc2VkJyk7XG4gICAgfVxuICAgIGlmIChkc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkc3QgcGFzc2VkJyk7XG4gICAgfVxuXG4gICAgLy8gUmVtZW1iZXIgZGVmYXVsdHMgZm9yIGZ1dHVyZSByZWZlcmVuY2VcbiAgICBERUZBVUxUUyA9IHNyYztcblxuICAgIC8vIEhhbmRsZSB0aGUgZGVmYXVsdHMgd2hpY2ggY2FuIGJlIHNpbXBseSBjb3BpZWQgb3ZlclxuICAgIGZvcmNlQ29weShzcmMsIGRzdCwgT1BUSU9OS0VZUyk7XG4gICAgZm9yY2VDb3B5KHNyYywgZHN0LCBQUkVGSVhFRE9QVElPTktFWVMsICdkZWZhdWx0Jyk7XG5cbiAgICAvLyBIYW5kbGUgdGhlIG1vcmUgY29tcGxleCAoJ3NwZWNpYWwnKSBmaWVsZHNcbiAgICBzZXRTcGVjaWFsU2V0dGluZ3Moc3JjLCBkc3QpO1xuXG4gICAgLy8gRm9sbG93aW5nIGFyZSBpbnRlcm5hbCBmaWVsZHMsIG5vdCBwYXJ0IG9mIHRoZSB1c2VyIHNldHRpbmdzXG4gICAgZHN0Lm1hcmdpbiA9IDEwOyAvLyBweFxuICAgIGRzdC5zaG93R3JheUJvdHRvbSA9IGZhbHNlOyAvLyBUT0RPOiB0aGlzIGRvZXMgbm90IHdvcmsgY29ycmVjdGx5XG4gICAgZHN0LnNob3dUb29sdGlwID0gZmFsc2U7XG4gICAgZHN0LmV5ZSA9IG5ldyBQb2ludDNkKDAsIDAsIC0xKTsgLy8gVE9ETzogc2V0IGV5ZS56IGFib3V0IDMvNCBvZiB0aGUgd2lkdGggb2YgdGhlIHdpbmRvdz9cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucywgZHN0KSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZHN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZHN0IHBhc3NlZCcpO1xuICAgIH1cblxuICAgIGlmIChERUZBVUxUUyA9PT0gdW5kZWZpbmVkIHx8IGlzRW1wdHkoREVGQVVMVFMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RFRkFVTFRTIG5vdCBzZXQgZm9yIG1vZHVsZSBTZXR0aW5ncycpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSB0aGUgcGFyYW1ldGVycyB3aGljaCBjYW4gYmUgc2ltcGx5IGNvcGllZCBvdmVyXG4gICAgc2FmZUNvcHkob3B0aW9ucywgZHN0LCBPUFRJT05LRVlTKTtcbiAgICBzYWZlQ29weShvcHRpb25zLCBkc3QsIFBSRUZJWEVET1BUSU9OS0VZUywgJ2RlZmF1bHQnKTtcblxuICAgIC8vIEhhbmRsZSB0aGUgbW9yZSBjb21wbGV4ICgnc3BlY2lhbCcpIGZpZWxkc1xuICAgIHNldFNwZWNpYWxTZXR0aW5ncyhvcHRpb25zLCBkc3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwZWNpYWwgaGFuZGxpbmcgZm9yIGNlcnRhaW4gcGFyYW1ldGVyc1xuICAgKlxuICAgKiAnU3BlY2lhbCcgaGVyZSBtZWFuczogc2V0dGluZyByZXF1aXJlcyBtb3JlIHRoYW4gYSBzaW1wbGUgY29weVxuICAgKi9cbiAgZnVuY3Rpb24gc2V0U3BlY2lhbFNldHRpbmdzKHNyYywgZHN0KSB7XG4gICAgaWYgKHNyYy5iYWNrZ3JvdW5kQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2V0QmFja2dyb3VuZENvbG9yKHNyYy5iYWNrZ3JvdW5kQ29sb3IsIGRzdCk7XG4gICAgfVxuXG4gICAgc2V0RGF0YUNvbG9yKHNyYy5kYXRhQ29sb3IsIGRzdCk7XG4gICAgc2V0U3R5bGUoc3JjLnN0eWxlLCBkc3QpO1xuICAgIHNldFNob3dMZWdlbmQoc3JjLnNob3dMZWdlbmQsIGRzdCk7XG4gICAgc2V0Q2FtZXJhUG9zaXRpb24oc3JjLmNhbWVyYVBvc2l0aW9uLCBkc3QpO1xuXG4gICAgLy8gQXMgc3BlY2lhbCBmaWVsZHMgZ28sIHRoaXMgaXMgYW4gZWFzeSBvbmU7IGp1c3QgYSB0cmFuc2xhdGlvbiBvZiB0aGUgbmFtZS5cbiAgICAvLyBDYW4ndCB1c2UgdGhpcy50b29sdGlwIGRpcmVjdGx5LCBiZWNhdXNlIHRoYXQgZmllbGQgZXhpc3RzIGludGVybmFsbHlcbiAgICBpZiAoc3JjLnRvb2x0aXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZHN0LnNob3dUb29sdGlwID0gc3JjLnRvb2x0aXA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmFsdWUgb2Ygc2V0dGluZyAnc2hvd0xlZ2VuZCdcbiAgICpcbiAgICogVGhpcyBkZXBlbmRzIG9uIHRoZSB2YWx1ZSBvZiB0aGUgc3R5bGUgZmllbGRzLCBzbyBpdCBtdXN0IGJlIGNhbGxlZFxuICAgKiBhZnRlciB0aGUgc3R5bGUgZmllbGQgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXG4gICAqL1xuICBmdW5jdGlvbiBzZXRTaG93TGVnZW5kKHNob3dMZWdlbmQsIGRzdCkge1xuICAgIGlmIChzaG93TGVnZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIElmIHRoZSBkZWZhdWx0IHdhcyBhdXRvLCBtYWtlIGEgY2hvaWNlIGZvciB0aGlzIGZpZWxkXG4gICAgICB2YXIgaXNBdXRvQnlEZWZhdWx0ID0gREVGQVVMVFMuc2hvd0xlZ2VuZCA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoaXNBdXRvQnlEZWZhdWx0KSB7XG4gICAgICAgIC8vIHRoZXNlIHN0eWxlcyBkZWZhdWx0IHRvIGhhdmluZyBsZWdlbmRzXG4gICAgICAgIHZhciBpc0xlZ2VuZEdyYXBoU3R5bGUgPSBkc3Quc3R5bGUgPT09IFNUWUxFLkRPVENPTE9SIHx8IGRzdC5zdHlsZSA9PT0gU1RZTEUuRE9UU0laRTtcblxuICAgICAgICBkc3Quc2hvd0xlZ2VuZCA9IGlzTGVnZW5kR3JhcGhTdHlsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIExlYXZlIGN1cnJlbnQgdmFsdWUgYXMgaXNcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZHN0LnNob3dMZWdlbmQgPSBzaG93TGVnZW5kO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgc3R5bGUgaW5kZXggZnJvbSBnaXZlbiBzdHlsZU5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlTmFtZSAgU3R5bGUgbmFtZSBzdWNoIGFzICdkb3QnLCAnZ3JpZCcsICdkb3QtbGluZSdcbiAgICogQHJldHVybiB7TnVtYmVyfSBzdHlsZU51bWJlciBFbnVtZXJhdGlvbiB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHN0eWxlLCBvciAtMVxuICAgKiAgICAgICAgICAgICAgICB3aGVuIG5vdCBmb3VuZFxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U3R5bGVOdW1iZXJCeU5hbWUoc3R5bGVOYW1lKSB7XG4gICAgdmFyIG51bWJlciA9IFNUWUxFTkFNRVtzdHlsZU5hbWVdO1xuXG4gICAgaWYgKG51bWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bWJlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBnaXZlbiBudW1iZXIgaXMgYSB2YWxpZCBzdHlsZSBudW1iZXIuXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICBmdW5jdGlvbiBjaGVja1N0eWxlTnVtYmVyKHN0eWxlKSB7XG4gICAgdmFyIHZhbGlkID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBuIGluIFNUWUxFKSB7XG4gICAgICBpZiAoU1RZTEVbbl0gPT09IHN0eWxlKSB7XG4gICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0U3R5bGUoc3R5bGUsIGRzdCkge1xuICAgIGlmIChzdHlsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG9cbiAgICB9XG5cbiAgICB2YXIgc3R5bGVOdW1iZXI7XG5cbiAgICBpZiAodHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJykge1xuICAgICAgc3R5bGVOdW1iZXIgPSBnZXRTdHlsZU51bWJlckJ5TmFtZShzdHlsZSk7XG5cbiAgICAgIGlmIChzdHlsZU51bWJlciA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHlsZSBcXCcnICsgc3R5bGUgKyAnXFwnIGlzIGludmFsaWQnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRG8gYSBwZWRhbnRpYyBjaGVjayBvbiBzdHlsZSBudW1iZXIgdmFsdWVcbiAgICAgIGlmICghY2hlY2tTdHlsZU51bWJlcihzdHlsZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHlsZSBcXCcnICsgc3R5bGUgKyAnXFwnIGlzIGludmFsaWQnKTtcbiAgICAgIH1cblxuICAgICAgc3R5bGVOdW1iZXIgPSBzdHlsZTtcbiAgICB9XG5cbiAgICBkc3Quc3R5bGUgPSBzdHlsZU51bWJlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGJhY2tncm91bmQgc3R5bGluZyBmb3IgdGhlIGdyYXBoXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwge2ZpbGw6IHN0cmluZywgc3Ryb2tlOiBzdHJpbmcsIHN0cm9rZVdpZHRoOiBzdHJpbmd9fSBiYWNrZ3JvdW5kQ29sb3JcbiAgICovXG4gIGZ1bmN0aW9uIHNldEJhY2tncm91bmRDb2xvcihiYWNrZ3JvdW5kQ29sb3IsIGRzdCkge1xuICAgIHZhciBmaWxsID0gJ3doaXRlJztcbiAgICB2YXIgc3Ryb2tlID0gJ2dyYXknO1xuICAgIHZhciBzdHJva2VXaWR0aCA9IDE7XG5cbiAgICBpZiAodHlwZW9mIGJhY2tncm91bmRDb2xvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZpbGwgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBzdHJva2UgPSAnbm9uZSc7XG4gICAgICBzdHJva2VXaWR0aCA9IDA7XG4gICAgfSBlbHNlIGlmICgodHlwZW9mIGJhY2tncm91bmRDb2xvciA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYmFja2dyb3VuZENvbG9yKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoYmFja2dyb3VuZENvbG9yLmZpbGwgIT09IHVuZGVmaW5lZCkgZmlsbCA9IGJhY2tncm91bmRDb2xvci5maWxsO1xuICAgICAgaWYgKGJhY2tncm91bmRDb2xvci5zdHJva2UgIT09IHVuZGVmaW5lZCkgc3Ryb2tlID0gYmFja2dyb3VuZENvbG9yLnN0cm9rZTtcbiAgICAgIGlmIChiYWNrZ3JvdW5kQ29sb3Iuc3Ryb2tlV2lkdGggIT09IHVuZGVmaW5lZCkgc3Ryb2tlV2lkdGggPSBiYWNrZ3JvdW5kQ29sb3Iuc3Ryb2tlV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdHlwZSBvZiBiYWNrZ3JvdW5kQ29sb3InKTtcbiAgICB9XG5cbiAgICBkc3QuZnJhbWUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gZmlsbDtcbiAgICBkc3QuZnJhbWUuc3R5bGUuYm9yZGVyQ29sb3IgPSBzdHJva2U7XG4gICAgZHN0LmZyYW1lLnN0eWxlLmJvcmRlcldpZHRoID0gc3Ryb2tlV2lkdGggKyAncHgnO1xuICAgIGRzdC5mcmFtZS5zdHlsZS5ib3JkZXJTdHlsZSA9ICdzb2xpZCc7XG4gIH1cblxuICBmdW5jdGlvbiBzZXREYXRhQ29sb3IoZGF0YUNvbG9yLCBkc3QpIHtcbiAgICBpZiAoZGF0YUNvbG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjsgLy8gTm90aGluZyB0byBkb1xuICAgIH1cblxuICAgIGlmIChkc3QuZGF0YUNvbG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRzdC5kYXRhQ29sb3IgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGFDb2xvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRzdC5kYXRhQ29sb3IuZmlsbCA9IGRhdGFDb2xvcjtcbiAgICAgIGRzdC5kYXRhQ29sb3Iuc3Ryb2tlID0gZGF0YUNvbG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGF0YUNvbG9yLmZpbGwpIHtcbiAgICAgICAgZHN0LmRhdGFDb2xvci5maWxsID0gZGF0YUNvbG9yLmZpbGw7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YUNvbG9yLnN0cm9rZSkge1xuICAgICAgICBkc3QuZGF0YUNvbG9yLnN0cm9rZSA9IGRhdGFDb2xvci5zdHJva2U7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YUNvbG9yLnN0cm9rZVdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZHN0LmRhdGFDb2xvci5zdHJva2VXaWR0aCA9IGRhdGFDb2xvci5zdHJva2VXaWR0aDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRDYW1lcmFQb3NpdGlvbihjYW1lcmFQb3NpdGlvbiwgZHN0KSB7XG4gICAgdmFyIGNhbVBvcyA9IGNhbWVyYVBvc2l0aW9uO1xuICAgIGlmIChjYW1Qb3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkc3QuY2FtZXJhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRzdC5jYW1lcmEgPSBuZXcgQ2FtZXJhKCk7XG4gICAgfVxuXG4gICAgZHN0LmNhbWVyYS5zZXRBcm1Sb3RhdGlvbihjYW1Qb3MuaG9yaXpvbnRhbCwgY2FtUG9zLnZlcnRpY2FsKTtcbiAgICBkc3QuY2FtZXJhLnNldEFybUxlbmd0aChjYW1Qb3MuZGlzdGFuY2UpO1xuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMuU1RZTEUgPSBTVFlMRTtcbiAgbW9kdWxlLmV4cG9ydHMuc2V0RGVmYXVsdHMgPSBzZXREZWZhdWx0cztcbiAgbW9kdWxlLmV4cG9ydHMuc2V0T3B0aW9ucyA9IHNldE9wdGlvbnM7XG4gIG1vZHVsZS5leHBvcnRzLnNldENhbWVyYVBvc2l0aW9uID0gc2V0Q2FtZXJhUG9zaXRpb247XG5cbi8qKiovIH0sXG4vKiAyMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIE9ubHkgbG9hZCBoYW1tZXIuanMgd2hlbiBpbiBhIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAgLy8gKGxvYWRpbmcgaGFtbWVyLmpzIGluIGEgbm9kZS5qcyBlbnZpcm9ubWVudCBnaXZlcyBlcnJvcnMpXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBwcm9wYWdhdGluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuICAgIHZhciBIYW1tZXIgPSB3aW5kb3dbJ0hhbW1lciddIHx8IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xuICAgIG1vZHVsZS5leHBvcnRzID0gcHJvcGFnYXRpbmcoSGFtbWVyLCB7XG4gICAgICBwcmV2ZW50RGVmYXVsdDogJ21vdXNlJ1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ2hhbW1lci5qcyBpcyBvbmx5IGF2YWlsYWJsZSBpbiBhIGJyb3dzZXIsIG5vdCBpbiBub2RlLmpzLicpO1xuICAgIH07XG4gIH1cblxuLyoqKi8gfSxcbi8qIDIzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICB2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsndXNlIHN0cmljdCc7XG5cbiAgKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgaWYgKHRydWUpIHtcbiAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgPyAoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcbiAgICAgIC8vIGxpa2UgTm9kZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuICAgICAgd2luZG93LnByb3BhZ2F0aW5nID0gZmFjdG9yeSgpO1xuICAgIH1cbiAgfShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9maXJzdFRhcmdldCA9IG51bGw7IC8vIHNpbmdsZXRvbiwgd2lsbCBjb250YWluIHRoZSB0YXJnZXQgZWxlbWVudCB3aGVyZSB0aGUgdG91Y2ggZXZlbnQgc3RhcnRlZFxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIGFuIEhhbW1lci5qcyBpbnN0YW5jZSB3aXRoIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgICAqXG4gICAgICogRmVhdHVyZXM6XG4gICAgICogLSBFdmVudHMgZW1pdHRlZCBieSBoYW1tZXIgd2lsbCBwcm9wYWdhdGUgaW4gb3JkZXIgZnJvbSBjaGlsZCB0byBwYXJlbnRcbiAgICAgKiAgIGVsZW1lbnRzLlxuICAgICAqIC0gRXZlbnRzIGFyZSBleHRlbmRlZCB3aXRoIGEgZnVuY3Rpb24gYGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpYCB0byBzdG9wXG4gICAgICogICBwcm9wYWdhdGlvbiB0byBwYXJlbnQgZWxlbWVudHMuXG4gICAgICogLSBBbiBvcHRpb24gYHByZXZlbnREZWZhdWx0YCB0byBzdG9wIGFsbCBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3IuXG4gICAgICpcbiAgICAgKiBVc2FnZTpcbiAgICAgKiAgIHZhciBoYW1tZXIgPSBwcm9wYWdhdGluZ0hhbW1lcihuZXcgSGFtbWVyKGVsZW1lbnQpKTtcbiAgICAgKiAgIHZhciBoYW1tZXIgPSBwcm9wYWdhdGluZ0hhbW1lcihuZXcgSGFtbWVyKGVsZW1lbnQpLCB7cHJldmVudERlZmF1bHQ6IHRydWV9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SGFtbWVyLk1hbmFnZXJ9IGhhbW1lciAgIEFuIGhhbW1lciBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB8IGZhbHNlIHwgJ21vdXNlJyB8ICd0b3VjaCcgfCAncGVuJ2AuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbmZvcmNlIHByZXZlbnRpbmcgdGhlIGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvci5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbm5vdCBiZSBzZXQgdG8gYGZhbHNlYC5cbiAgICAgKiBAcmV0dXJuIHtIYW1tZXIuTWFuYWdlcn0gUmV0dXJucyB0aGUgc2FtZSBoYW1tZXIgaW5zdGFuY2Ugd2l0aCBleHRlbmRlZFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbmFsaXR5XG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHByb3BhZ2F0aW5nKGhhbW1lciwgb3B0aW9ucykge1xuICAgICAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyB8fCB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBmYWxzZVxuICAgICAgfTtcblxuICAgICAgaWYgKGhhbW1lci5NYW5hZ2VyKSB7XG4gICAgICAgIC8vIFRoaXMgbG9va3MgbGlrZSB0aGUgSGFtbWVyIGNvbnN0cnVjdG9yLlxuICAgICAgICAvLyBPdmVybG9hZCB0aGUgY29uc3RydWN0b3JzIHdpdGggb3VyIG93bi5cbiAgICAgICAgdmFyIEhhbW1lciA9IGhhbW1lcjtcblxuICAgICAgICB2YXIgUHJvcGFnYXRpbmdIYW1tZXIgPSBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIG8gPSBPYmplY3QuY3JlYXRlKF9vcHRpb25zKTtcbiAgICAgICAgICBpZiAob3B0aW9ucykgSGFtbWVyLmFzc2lnbihvLCBvcHRpb25zKTtcbiAgICAgICAgICByZXR1cm4gcHJvcGFnYXRpbmcobmV3IEhhbW1lcihlbGVtZW50LCBvKSwgbyk7XG4gICAgICAgIH07XG4gICAgICAgIEhhbW1lci5hc3NpZ24oUHJvcGFnYXRpbmdIYW1tZXIsIEhhbW1lcik7XG5cbiAgICAgICAgUHJvcGFnYXRpbmdIYW1tZXIuTWFuYWdlciA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIG8gPSBPYmplY3QuY3JlYXRlKF9vcHRpb25zKTtcbiAgICAgICAgICBpZiAob3B0aW9ucykgSGFtbWVyLmFzc2lnbihvLCBvcHRpb25zKTtcbiAgICAgICAgICByZXR1cm4gcHJvcGFnYXRpbmcobmV3IEhhbW1lci5NYW5hZ2VyKGVsZW1lbnQsIG8pLCBvKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gUHJvcGFnYXRpbmdIYW1tZXI7XG4gICAgICB9XG5cbiAgICAgIC8vIGNyZWF0ZSBhIHdyYXBwZXIgb2JqZWN0IHdoaWNoIHdpbGwgb3ZlcnJpZGUgdGhlIGZ1bmN0aW9uc1xuICAgICAgLy8gYG9uYCwgYG9mZmAsIGBkZXN0cm95YCwgYW5kIGBlbWl0YCBvZiB0aGUgaGFtbWVyIGluc3RhbmNlXG4gICAgICB2YXIgd3JhcHBlciA9IE9iamVjdC5jcmVhdGUoaGFtbWVyKTtcblxuICAgICAgLy8gYXR0YWNoIHRvIERPTSBlbGVtZW50XG4gICAgICB2YXIgZWxlbWVudCA9IGhhbW1lci5lbGVtZW50O1xuXG4gICAgICBpZighZWxlbWVudC5oYW1tZXIpIGVsZW1lbnQuaGFtbWVyID0gW107XG4gICAgICBlbGVtZW50LmhhbW1lci5wdXNoKHdyYXBwZXIpO1xuXG4gICAgICAvLyByZWdpc3RlciBhbiBldmVudCB0byBjYXRjaCB0aGUgc3RhcnQgb2YgYSBnZXN0dXJlIGFuZCBzdG9yZSB0aGVcbiAgICAgIC8vIHRhcmdldCBpbiBhIHNpbmdsZXRvblxuICAgICAgaGFtbWVyLm9uKCdoYW1tZXIuaW5wdXQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKF9vcHRpb25zLnByZXZlbnREZWZhdWx0ID09PSB0cnVlIHx8IChfb3B0aW9ucy5wcmV2ZW50RGVmYXVsdCA9PT0gZXZlbnQucG9pbnRlclR5cGUpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQuaXNGaXJzdCkge1xuICAgICAgICAgIF9maXJzdFRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0LjxTdHJpbmcsIEFycmF5LjxmdW5jdGlvbj4+fSAqL1xuICAgICAgd3JhcHBlci5faGFuZGxlcnMgPSB7fTtcblxuICAgICAgLyoqXG4gICAgICAgKiBSZWdpc3RlciBhIGhhbmRsZXIgZm9yIG9uZSBvciBtdWx0aXBsZSBldmVudHNcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHMgICAgQSBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIHdpdGggZXZlbnRzXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIEEgY2FsbGJhY2sgZnVuY3Rpb24sIGNhbGxlZCBhcyBoYW5kbGVyKGV2ZW50KVxuICAgICAgICogQHJldHVybnMge0hhbW1lci5NYW5hZ2VyfSBSZXR1cm5zIHRoZSBoYW1tZXIgaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgd3JhcHBlci5vbiA9IGZ1bmN0aW9uIChldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgLy8gcmVnaXN0ZXIgdGhlIGhhbmRsZXJcbiAgICAgICAgc3BsaXQoZXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHZhciBfaGFuZGxlcnMgPSB3cmFwcGVyLl9oYW5kbGVyc1tldmVudF07XG4gICAgICAgICAgaWYgKCFfaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHdyYXBwZXIuX2hhbmRsZXJzW2V2ZW50XSA9IF9oYW5kbGVycyA9IFtdO1xuXG4gICAgICAgICAgICAvLyByZWdpc3RlciB0aGUgc3RhdGljLCBwcm9wYWdhdGVkIGhhbmRsZXJcbiAgICAgICAgICAgIGhhbW1lci5vbihldmVudCwgcHJvcGFnYXRlZEhhbmRsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIFVucmVnaXN0ZXIgYSBoYW5kbGVyIGZvciBvbmUgb3IgbXVsdGlwbGUgZXZlbnRzXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzICAgICAgQSBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIHdpdGggZXZlbnRzXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbaGFuZGxlcl0gT3B0aW9uYWwuIFRoZSByZWdpc3RlcmVkIGhhbmRsZXIuIElmIG5vdFxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkLCBhbGwgaGFuZGxlcnMgZm9yIGdpdmVuIGV2ZW50c1xuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSByZW1vdmVkLlxuICAgICAgICogQHJldHVybnMge0hhbW1lci5NYW5hZ2VyfSAgIFJldHVybnMgdGhlIGhhbW1lciBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICB3cmFwcGVyLm9mZiA9IGZ1bmN0aW9uIChldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgLy8gdW5yZWdpc3RlciB0aGUgaGFuZGxlclxuICAgICAgICBzcGxpdChldmVudHMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgdmFyIF9oYW5kbGVycyA9IHdyYXBwZXIuX2hhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgICBpZiAoX2hhbmRsZXJzKSB7XG4gICAgICAgICAgICBfaGFuZGxlcnMgPSBoYW5kbGVyID8gX2hhbmRsZXJzLmZpbHRlcihmdW5jdGlvbiAoaCkge1xuICAgICAgICAgICAgICByZXR1cm4gaCAhPT0gaGFuZGxlcjtcbiAgICAgICAgICAgIH0pIDogW107XG5cbiAgICAgICAgICAgIGlmIChfaGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB3cmFwcGVyLl9oYW5kbGVyc1tldmVudF0gPSBfaGFuZGxlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcmVtb3ZlIHN0YXRpYywgcHJvcGFnYXRlZCBoYW5kbGVyXG4gICAgICAgICAgICAgIGhhbW1lci5vZmYoZXZlbnQsIHByb3BhZ2F0ZWRIYW5kbGVyKTtcbiAgICAgICAgICAgICAgZGVsZXRlIHdyYXBwZXIuX2hhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBFbWl0IHRvIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICAgKi9cbiAgICAgIHdyYXBwZXIuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgZXZlbnQpIHtcbiAgICAgICAgX2ZpcnN0VGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICBoYW1tZXIuZW1pdChldmVudFR5cGUsIGV2ZW50KTtcbiAgICAgIH07XG5cbiAgICAgIHdyYXBwZXIuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRGV0YWNoIGZyb20gRE9NIGVsZW1lbnRcbiAgICAgICAgdmFyIGhhbW1lcnMgPSBoYW1tZXIuZWxlbWVudC5oYW1tZXI7XG4gICAgICAgIHZhciBpZHggPSBoYW1tZXJzLmluZGV4T2Yod3JhcHBlcik7XG4gICAgICAgIGlmKGlkeCAhPT0gLTEpIGhhbW1lcnMuc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgaWYoIWhhbW1lcnMubGVuZ3RoKSBkZWxldGUgaGFtbWVyLmVsZW1lbnQuaGFtbWVyO1xuXG4gICAgICAgIC8vIGNsZWFyIGFsbCBoYW5kbGVyc1xuICAgICAgICB3cmFwcGVyLl9oYW5kbGVycyA9IHt9O1xuXG4gICAgICAgIC8vIGNhbGwgb3JpZ2luYWwgaGFtbWVyIGRlc3Ryb3lcbiAgICAgICAgaGFtbWVyLmRlc3Ryb3koKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIHNwbGl0IGEgc3RyaW5nIHdpdGggc3BhY2Ugc2VwYXJhdGVkIHdvcmRzXG4gICAgICBmdW5jdGlvbiBzcGxpdChldmVudHMpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50cy5tYXRjaCgvW14gXSsvZyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQSBzdGF0aWMgZXZlbnQgaGFuZGxlciwgYXBwbHlpbmcgZXZlbnQgcHJvcGFnYXRpb24uXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gcHJvcGFnYXRlZEhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgLy8gbGV0IG9ubHkgYSBzaW5nbGUgaGFtbWVyIGluc3RhbmNlIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICAgIGlmIChldmVudC50eXBlICE9PSAnaGFtbWVyLmlucHV0Jykge1xuICAgICAgICAgIC8vIGl0IGlzIHBvc3NpYmxlIHRoYXQgdGhlIHNhbWUgc3JjRXZlbnQgaXMgdXNlZCB3aXRoIG11bHRpcGxlIGhhbW1lciBldmVudHMsXG4gICAgICAgICAgLy8gd2Uga2VlcCB0cmFjayBvbiB3aGljaCBldmVudHMgYXJlIGhhbmRsZWQgaW4gYW4gb2JqZWN0IF9oYW5kbGVkXG4gICAgICAgICAgaWYgKCFldmVudC5zcmNFdmVudC5faGFuZGxlZCkge1xuICAgICAgICAgICAgZXZlbnQuc3JjRXZlbnQuX2hhbmRsZWQgPSB7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZXZlbnQuc3JjRXZlbnQuX2hhbmRsZWRbZXZlbnQudHlwZV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBldmVudC5zcmNFdmVudC5faGFuZGxlZFtldmVudC50eXBlXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXR0YWNoIGEgc3RvcFByb3BhZ2F0aW9uIGZ1bmN0aW9uIHRvIHRoZSBldmVudFxuICAgICAgICB2YXIgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy93cmFwIHRoZSBzcmNFdmVudCdzIHN0b3BQcm9wYWdhdGlvbiB0byBhbHNvIHN0b3AgaGFtbWVyIHByb3BhZ2F0aW9uOlxuICAgICAgICB2YXIgc3JjU3RvcCA9IGV2ZW50LnNyY0V2ZW50LnN0b3BQcm9wYWdhdGlvbi5iaW5kKGV2ZW50LnNyY0V2ZW50KTtcbiAgICAgICAgaWYodHlwZW9mIHNyY1N0b3AgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgZXZlbnQuc3JjRXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNyY1N0b3AoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGF0dGFjaCBmaXJzdFRhcmdldCBwcm9wZXJ0eSB0byB0aGUgZXZlbnRcbiAgICAgICAgZXZlbnQuZmlyc3RUYXJnZXQgPSBfZmlyc3RUYXJnZXQ7XG5cbiAgICAgICAgLy8gcHJvcGFnYXRlIG92ZXIgYWxsIGVsZW1lbnRzICh1bnRpbCBzdG9wcGVkKVxuICAgICAgICB2YXIgZWxlbSA9IF9maXJzdFRhcmdldDtcbiAgICAgICAgd2hpbGUgKGVsZW0gJiYgIXN0b3BwZWQpIHtcbiAgICAgICAgICB2YXIgZWxlbUhhbW1lciA9IGVsZW0uaGFtbWVyO1xuICAgICAgICAgIGlmKGVsZW1IYW1tZXIpe1xuICAgICAgICAgICAgdmFyIF9oYW5kbGVycztcbiAgICAgICAgICAgIGZvcih2YXIgayA9IDA7IGsgPCBlbGVtSGFtbWVyLmxlbmd0aDsgaysrKXtcbiAgICAgICAgICAgICAgX2hhbmRsZXJzID0gZWxlbUhhbW1lcltrXS5faGFuZGxlcnNbZXZlbnQudHlwZV07XG4gICAgICAgICAgICAgIGlmKF9oYW5kbGVycykgZm9yICh2YXIgaSA9IDA7IGkgPCBfaGFuZGxlcnMubGVuZ3RoICYmICFzdG9wcGVkOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfaGFuZGxlcnNbaV0oZXZlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW0gPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfTtcbiAgfSkpO1xuXG5cbi8qKiovIH0sXG4vKiAyNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgdmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qISBIYW1tZXIuSlMgLSB2Mi4wLjcgLSAyMDE2LTA0LTIyXG4gICAqIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vXG4gICAqXG4gICAqIENvcHlyaWdodCAoYykgMjAxNiBKb3JpayBUYW5nZWxkZXI7XG4gICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSAqL1xuICAoZnVuY3Rpb24od2luZG93LCBkb2N1bWVudCwgZXhwb3J0TmFtZSwgdW5kZWZpbmVkKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBWRU5ET1JfUFJFRklYRVMgPSBbJycsICd3ZWJraXQnLCAnTW96JywgJ01TJywgJ21zJywgJ28nXTtcbiAgdmFyIFRFU1RfRUxFTUVOVCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gIHZhciBUWVBFX0ZVTkNUSU9OID0gJ2Z1bmN0aW9uJztcblxuICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuICB2YXIgYWJzID0gTWF0aC5hYnM7XG4gIHZhciBub3cgPSBEYXRlLm5vdztcblxuICAvKipcbiAgICogc2V0IGEgdGltZW91dCB3aXRoIGEgZ2l2ZW4gc2NvcGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGZ1bmN0aW9uIHNldFRpbWVvdXRDb250ZXh0KGZuLCB0aW1lb3V0LCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChiaW5kRm4oZm4sIGNvbnRleHQpLCB0aW1lb3V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXksIHdlIHdhbnQgdG8gZXhlY3V0ZSB0aGUgZm4gb24gZWFjaCBlbnRyeVxuICAgKiBpZiBpdCBhaW50IGFuIGFycmF5IHdlIGRvbid0IHdhbnQgdG8gZG8gYSB0aGluZy5cbiAgICogdGhpcyBpcyB1c2VkIGJ5IGFsbCB0aGUgbWV0aG9kcyB0aGF0IGFjY2VwdCBhIHNpbmdsZSBhbmQgYXJyYXkgYXJndW1lbnQuXG4gICAqIEBwYXJhbSB7KnxBcnJheX0gYXJnXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmblxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gaW52b2tlQXJyYXlBcmcoYXJnLCBmbiwgY29udGV4dCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgIGVhY2goYXJnLCBjb250ZXh0W2ZuXSwgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogd2FsayBvYmplY3RzIGFuZCBhcnJheXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgKi9cbiAgZnVuY3Rpb24gZWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmouZm9yRWFjaCkge1xuICAgICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgd2hpbGUgKGkgPCBvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICAvKipcbiAgICogd3JhcCBhIG1ldGhvZCB3aXRoIGEgZGVwcmVjYXRpb24gd2FybmluZyBhbmQgc3RhY2sgdHJhY2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gd3JhcHBpbmcgdGhlIHN1cHBsaWVkIG1ldGhvZC5cbiAgICovXG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZShtZXRob2QsIG5hbWUsIG1lc3NhZ2UpIHtcbiAgICAgIHZhciBkZXByZWNhdGlvbk1lc3NhZ2UgPSAnREVQUkVDQVRFRCBNRVRIT0Q6ICcgKyBuYW1lICsgJ1xcbicgKyBtZXNzYWdlICsgJyBBVCBcXG4nO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBlID0gbmV3IEVycm9yKCdnZXQtc3RhY2stdHJhY2UnKTtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBlICYmIGUuc3RhY2sgPyBlLnN0YWNrLnJlcGxhY2UoL15bXlxcKF0rP1tcXG4kXS9nbSwgJycpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9eXFxzK2F0XFxzKy9nbSwgJycpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9eT2JqZWN0Ljxhbm9ueW1vdXM+XFxzKlxcKC9nbSwgJ3thbm9ueW1vdXN9KClAJykgOiAnVW5rbm93biBTdGFjayBUcmFjZSc7XG5cbiAgICAgICAgICB2YXIgbG9nID0gd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLndhcm4gfHwgd2luZG93LmNvbnNvbGUubG9nKTtcbiAgICAgICAgICBpZiAobG9nKSB7XG4gICAgICAgICAgICAgIGxvZy5jYWxsKHdpbmRvdy5jb25zb2xlLCBkZXByZWNhdGlvbk1lc3NhZ2UsIHN0YWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBleHRlbmQgb2JqZWN0LlxuICAgKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgKiBAcGFyYW0gey4uLk9iamVjdH0gb2JqZWN0c190b19hc3NpZ25cbiAgICogQHJldHVybnMge09iamVjdH0gdGFyZ2V0XG4gICAqL1xuICB2YXIgYXNzaWduO1xuICBpZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQpIHtcbiAgICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBvdXRwdXQgPSBPYmplY3QodGFyZ2V0KTtcbiAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgICAgICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KG5leHRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtuZXh0S2V5XSA9IHNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIH07XG4gIH0gZWxzZSB7XG4gICAgICBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuICB9XG5cbiAgLyoqXG4gICAqIGV4dGVuZCBvYmplY3QuXG4gICAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyBpbiBkZXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIG9uZXMgaW4gc3JjLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21lcmdlPWZhbHNlXVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gICAqL1xuICB2YXIgZXh0ZW5kID0gZGVwcmVjYXRlKGZ1bmN0aW9uIGV4dGVuZChkZXN0LCBzcmMsIG1lcmdlKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyk7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCFtZXJnZSB8fCAobWVyZ2UgJiYgZGVzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICBkZXN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzdDtcbiAgfSwgJ2V4dGVuZCcsICdVc2UgYGFzc2lnbmAuJyk7XG5cbiAgLyoqXG4gICAqIG1lcmdlIHRoZSB2YWx1ZXMgZnJvbSBzcmMgaW4gdGhlIGRlc3QuXG4gICAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyB0aGF0IGV4aXN0IGluIGRlc3Qgd2lsbCBub3QgYmUgb3ZlcndyaXR0ZW4gYnkgc3JjXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAgICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICAgKi9cbiAgdmFyIG1lcmdlID0gZGVwcmVjYXRlKGZ1bmN0aW9uIG1lcmdlKGRlc3QsIHNyYykge1xuICAgICAgcmV0dXJuIGV4dGVuZChkZXN0LCBzcmMsIHRydWUpO1xuICB9LCAnbWVyZ2UnLCAnVXNlIGBhc3NpZ25gLicpO1xuXG4gIC8qKlxuICAgKiBzaW1wbGUgY2xhc3MgaW5oZXJpdGFuY2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2hpbGRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdXG4gICAqL1xuICBmdW5jdGlvbiBpbmhlcml0KGNoaWxkLCBiYXNlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgYmFzZVAgPSBiYXNlLnByb3RvdHlwZSxcbiAgICAgICAgICBjaGlsZFA7XG5cbiAgICAgIGNoaWxkUCA9IGNoaWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYmFzZVApO1xuICAgICAgY2hpbGRQLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgICBjaGlsZFAuX3N1cGVyID0gYmFzZVA7XG5cbiAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgYXNzaWduKGNoaWxkUCwgcHJvcGVydGllcyk7XG4gICAgICB9XG4gIH1cblxuICAvKipcbiAgICogc2ltcGxlIGZ1bmN0aW9uIGJpbmRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gYmluZEZuKGZuLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gYm91bmRGbigpIHtcbiAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gIH1cblxuICAvKipcbiAgICogbGV0IGEgYm9vbGVhbiB2YWx1ZSBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdCBtdXN0IHJldHVybiBhIGJvb2xlYW5cbiAgICogdGhpcyBmaXJzdCBpdGVtIGluIGFyZ3Mgd2lsbCBiZSB1c2VkIGFzIHRoZSBjb250ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gdmFsXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIGJvb2xPckZuKHZhbCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT0gVFlQRV9GVU5DVElPTikge1xuICAgICAgICAgIHJldHVybiB2YWwuYXBwbHkoYXJncyA/IGFyZ3NbMF0gfHwgdW5kZWZpbmVkIDogdW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gIH1cblxuICAvKipcbiAgICogdXNlIHRoZSB2YWwyIHdoZW4gdmFsMSBpcyB1bmRlZmluZWRcbiAgICogQHBhcmFtIHsqfSB2YWwxXG4gICAqIEBwYXJhbSB7Kn0gdmFsMlxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGZ1bmN0aW9uIGlmVW5kZWZpbmVkKHZhbDEsIHZhbDIpIHtcbiAgICAgIHJldHVybiAodmFsMSA9PT0gdW5kZWZpbmVkKSA/IHZhbDIgOiB2YWwxO1xuICB9XG5cbiAgLyoqXG4gICAqIGFkZEV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgICAgIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogcmVtb3ZlRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICAgICAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmaW5kIGlmIGEgbm9kZSBpcyBpbiB0aGUgZ2l2ZW4gcGFyZW50XG4gICAqIEBtZXRob2QgaGFzUGFyZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gICAqL1xuICBmdW5jdGlvbiBoYXNQYXJlbnQobm9kZSwgcGFyZW50KSB7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgIGlmIChub2RlID09IHBhcmVudCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzbWFsbCBpbmRleE9mIHdyYXBwZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gZm91bmRcbiAgICovXG4gIGZ1bmN0aW9uIGluU3RyKHN0ciwgZmluZCkge1xuICAgICAgcmV0dXJuIHN0ci5pbmRleE9mKGZpbmQpID4gLTE7XG4gIH1cblxuICAvKipcbiAgICogc3BsaXQgc3RyaW5nIG9uIHdoaXRlc3BhY2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHdvcmRzXG4gICAqL1xuICBmdW5jdGlvbiBzcGxpdFN0cihzdHIpIHtcbiAgICAgIHJldHVybiBzdHIudHJpbSgpLnNwbGl0KC9cXHMrL2cpO1xuICB9XG5cbiAgLyoqXG4gICAqIGZpbmQgaWYgYSBhcnJheSBjb250YWlucyB0aGUgb2JqZWN0IHVzaW5nIGluZGV4T2Ygb3IgYSBzaW1wbGUgcG9seUZpbGxcbiAgICogQHBhcmFtIHtBcnJheX0gc3JjXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbZmluZEJ5S2V5XVxuICAgKiBAcmV0dXJuIHtCb29sZWFufE51bWJlcn0gZmFsc2Ugd2hlbiBub3QgZm91bmQsIG9yIHRoZSBpbmRleFxuICAgKi9cbiAgZnVuY3Rpb24gaW5BcnJheShzcmMsIGZpbmQsIGZpbmRCeUtleSkge1xuICAgICAgaWYgKHNyYy5pbmRleE9mICYmICFmaW5kQnlLZXkpIHtcbiAgICAgICAgICByZXR1cm4gc3JjLmluZGV4T2YoZmluZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKChmaW5kQnlLZXkgJiYgc3JjW2ldW2ZpbmRCeUtleV0gPT0gZmluZCkgfHwgKCFmaW5kQnlLZXkgJiYgc3JjW2ldID09PSBmaW5kKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gIH1cblxuICAvKipcbiAgICogY29udmVydCBhcnJheS1saWtlIG9iamVjdHMgdG8gcmVhbCBhcnJheXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICBmdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCk7XG4gIH1cblxuICAvKipcbiAgICogdW5pcXVlIGFycmF5IHdpdGggb2JqZWN0cyBiYXNlZCBvbiBhIGtleSAobGlrZSAnaWQnKSBvciBqdXN0IGJ5IHRoZSBhcnJheSdzIHZhbHVlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNyYyBbe2lkOjF9LHtpZDoyfSx7aWQ6MX1dXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBba2V5XVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzb3J0PUZhbHNlXVxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFt7aWQ6MX0se2lkOjJ9XVxuICAgKi9cbiAgZnVuY3Rpb24gdW5pcXVlQXJyYXkoc3JjLCBrZXksIHNvcnQpIHtcbiAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xuICAgICAgICAgIHZhciB2YWwgPSBrZXkgPyBzcmNbaV1ba2V5XSA6IHNyY1tpXTtcbiAgICAgICAgICBpZiAoaW5BcnJheSh2YWx1ZXMsIHZhbCkgPCAwKSB7XG4gICAgICAgICAgICAgIHJlc3VsdHMucHVzaChzcmNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZXNbaV0gPSB2YWw7XG4gICAgICAgICAgaSsrO1xuICAgICAgfVxuXG4gICAgICBpZiAoc29ydCkge1xuICAgICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KGZ1bmN0aW9uIHNvcnRVbmlxdWVBcnJheShhLCBiKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYVtrZXldID4gYltrZXldO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgcHJlZml4ZWQgcHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHJldHVybnMge1N0cmluZ3xVbmRlZmluZWR9IHByZWZpeGVkXG4gICAqL1xuICBmdW5jdGlvbiBwcmVmaXhlZChvYmosIHByb3BlcnR5KSB7XG4gICAgICB2YXIgcHJlZml4LCBwcm9wO1xuICAgICAgdmFyIGNhbWVsUHJvcCA9IHByb3BlcnR5WzBdLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUgKGkgPCBWRU5ET1JfUFJFRklYRVMubGVuZ3RoKSB7XG4gICAgICAgICAgcHJlZml4ID0gVkVORE9SX1BSRUZJWEVTW2ldO1xuICAgICAgICAgIHByb3AgPSAocHJlZml4KSA/IHByZWZpeCArIGNhbWVsUHJvcCA6IHByb3BlcnR5O1xuXG4gICAgICAgICAgaWYgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBhIHVuaXF1ZSBpZFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSB1bmlxdWVJZFxuICAgKi9cbiAgdmFyIF91bmlxdWVJZCA9IDE7XG4gIGZ1bmN0aW9uIHVuaXF1ZUlkKCkge1xuICAgICAgcmV0dXJuIF91bmlxdWVJZCsrO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgd2luZG93IG9iamVjdCBvZiBhbiBlbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHJldHVybnMge0RvY3VtZW50Vmlld3xXaW5kb3d9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRXaW5kb3dGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgZWxlbWVudDtcbiAgICAgIHJldHVybiAoZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3cgfHwgd2luZG93KTtcbiAgfVxuXG4gIHZhciBNT0JJTEVfUkVHRVggPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkL2k7XG5cbiAgdmFyIFNVUFBPUlRfVE9VQ0ggPSAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KTtcbiAgdmFyIFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMgPSBwcmVmaXhlZCh3aW5kb3csICdQb2ludGVyRXZlbnQnKSAhPT0gdW5kZWZpbmVkO1xuICB2YXIgU1VQUE9SVF9PTkxZX1RPVUNIID0gU1VQUE9SVF9UT1VDSCAmJiBNT0JJTEVfUkVHRVgudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuICB2YXIgSU5QVVRfVFlQRV9UT1VDSCA9ICd0b3VjaCc7XG4gIHZhciBJTlBVVF9UWVBFX1BFTiA9ICdwZW4nO1xuICB2YXIgSU5QVVRfVFlQRV9NT1VTRSA9ICdtb3VzZSc7XG4gIHZhciBJTlBVVF9UWVBFX0tJTkVDVCA9ICdraW5lY3QnO1xuXG4gIHZhciBDT01QVVRFX0lOVEVSVkFMID0gMjU7XG5cbiAgdmFyIElOUFVUX1NUQVJUID0gMTtcbiAgdmFyIElOUFVUX01PVkUgPSAyO1xuICB2YXIgSU5QVVRfRU5EID0gNDtcbiAgdmFyIElOUFVUX0NBTkNFTCA9IDg7XG5cbiAgdmFyIERJUkVDVElPTl9OT05FID0gMTtcbiAgdmFyIERJUkVDVElPTl9MRUZUID0gMjtcbiAgdmFyIERJUkVDVElPTl9SSUdIVCA9IDQ7XG4gIHZhciBESVJFQ1RJT05fVVAgPSA4O1xuICB2YXIgRElSRUNUSU9OX0RPV04gPSAxNjtcblxuICB2YXIgRElSRUNUSU9OX0hPUklaT05UQUwgPSBESVJFQ1RJT05fTEVGVCB8IERJUkVDVElPTl9SSUdIVDtcbiAgdmFyIERJUkVDVElPTl9WRVJUSUNBTCA9IERJUkVDVElPTl9VUCB8IERJUkVDVElPTl9ET1dOO1xuICB2YXIgRElSRUNUSU9OX0FMTCA9IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMO1xuXG4gIHZhciBQUk9QU19YWSA9IFsneCcsICd5J107XG4gIHZhciBQUk9QU19DTElFTlRfWFkgPSBbJ2NsaWVudFgnLCAnY2xpZW50WSddO1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICAgKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge0lucHV0fVxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIElucHV0KG1hbmFnZXIsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgdGhpcy5lbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuICAgICAgdGhpcy50YXJnZXQgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRUYXJnZXQ7XG5cbiAgICAgIC8vIHNtYWxsZXIgd3JhcHBlciBhcm91bmQgdGhlIGhhbmRsZXIsIGZvciB0aGUgc2NvcGUgYW5kIHRoZSBlbmFibGVkIHN0YXRlIG9mIHRoZSBtYW5hZ2VyLFxuICAgICAgLy8gc28gd2hlbiBkaXNhYmxlZCB0aGUgaW5wdXQgZXZlbnRzIGFyZSBjb21wbGV0ZWx5IGJ5cGFzc2VkLlxuICAgICAgdGhpcy5kb21IYW5kbGVyID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICBpZiAoYm9vbE9yRm4obWFuYWdlci5vcHRpb25zLmVuYWJsZSwgW21hbmFnZXJdKSkge1xuICAgICAgICAgICAgICBzZWxmLmhhbmRsZXIoZXYpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuaW5pdCgpO1xuXG4gIH1cblxuICBJbnB1dC5wcm90b3R5cGUgPSB7XG4gICAgICAvKipcbiAgICAgICAqIHNob3VsZCBoYW5kbGUgdGhlIGlucHV0RXZlbnQgZGF0YSBhbmQgdHJpZ2dlciB0aGUgY2FsbGJhY2tcbiAgICAgICAqIEB2aXJ0dWFsXG4gICAgICAgKi9cbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkgeyB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIGJpbmQgdGhlIGV2ZW50c1xuICAgICAgICovXG4gICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmV2RWwgJiYgYWRkRXZlbnRMaXN0ZW5lcnModGhpcy5lbGVtZW50LCB0aGlzLmV2RWwsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICAgICAgdGhpcy5ldlRhcmdldCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgICB0aGlzLmV2V2luICYmIGFkZEV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogdW5iaW5kIHRoZSBldmVudHNcbiAgICAgICAqL1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5ldkVsICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICAgIHRoaXMuZXZUYXJnZXQgJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy50YXJnZXQsIHRoaXMuZXZUYXJnZXQsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICAgICAgdGhpcy5ldldpbiAmJiByZW1vdmVFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXG4gICAqIGNhbGxlZCBieSB0aGUgTWFuYWdlciBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxuICAgKiBAcmV0dXJucyB7SW5wdXR9XG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVJbnB1dEluc3RhbmNlKG1hbmFnZXIpIHtcbiAgICAgIHZhciBUeXBlO1xuICAgICAgdmFyIGlucHV0Q2xhc3MgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRDbGFzcztcblxuICAgICAgaWYgKGlucHV0Q2xhc3MpIHtcbiAgICAgICAgICBUeXBlID0gaW5wdXRDbGFzcztcbiAgICAgIH0gZWxzZSBpZiAoU1VQUE9SVF9QT0lOVEVSX0VWRU5UUykge1xuICAgICAgICAgIFR5cGUgPSBQb2ludGVyRXZlbnRJbnB1dDtcbiAgICAgIH0gZWxzZSBpZiAoU1VQUE9SVF9PTkxZX1RPVUNIKSB7XG4gICAgICAgICAgVHlwZSA9IFRvdWNoSW5wdXQ7XG4gICAgICB9IGVsc2UgaWYgKCFTVVBQT1JUX1RPVUNIKSB7XG4gICAgICAgICAgVHlwZSA9IE1vdXNlSW5wdXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIFR5cGUgPSBUb3VjaE1vdXNlSW5wdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IChUeXBlKShtYW5hZ2VyLCBpbnB1dEhhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIGhhbmRsZSBpbnB1dCBldmVudHNcbiAgICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqL1xuICBmdW5jdGlvbiBpbnB1dEhhbmRsZXIobWFuYWdlciwgZXZlbnRUeXBlLCBpbnB1dCkge1xuICAgICAgdmFyIHBvaW50ZXJzTGVuID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoO1xuICAgICAgdmFyIGNoYW5nZWRQb2ludGVyc0xlbiA9IGlucHV0LmNoYW5nZWRQb2ludGVycy5sZW5ndGg7XG4gICAgICB2YXIgaXNGaXJzdCA9IChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcbiAgICAgIHZhciBpc0ZpbmFsID0gKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIChwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMCkpO1xuXG4gICAgICBpbnB1dC5pc0ZpcnN0ID0gISFpc0ZpcnN0O1xuICAgICAgaW5wdXQuaXNGaW5hbCA9ICEhaXNGaW5hbDtcblxuICAgICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgICBtYW5hZ2VyLnNlc3Npb24gPSB7fTtcbiAgICAgIH1cblxuICAgICAgLy8gc291cmNlIGV2ZW50IGlzIHRoZSBub3JtYWxpemVkIHZhbHVlIG9mIHRoZSBkb21FdmVudHNcbiAgICAgIC8vIGxpa2UgJ3RvdWNoc3RhcnQsIG1vdXNldXAsIHBvaW50ZXJkb3duJ1xuICAgICAgaW5wdXQuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xuXG4gICAgICAvLyBjb21wdXRlIHNjYWxlLCByb3RhdGlvbiBldGNcbiAgICAgIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpO1xuXG4gICAgICAvLyBlbWl0IHNlY3JldCBldmVudFxuICAgICAgbWFuYWdlci5lbWl0KCdoYW1tZXIuaW5wdXQnLCBpbnB1dCk7XG5cbiAgICAgIG1hbmFnZXIucmVjb2duaXplKGlucHV0KTtcbiAgICAgIG1hbmFnZXIuc2Vzc2lvbi5wcmV2SW5wdXQgPSBpbnB1dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBleHRlbmQgdGhlIGRhdGEgd2l0aCBzb21lIHVzYWJsZSBwcm9wZXJ0aWVzIGxpa2Ugc2NhbGUsIHJvdGF0ZSwgdmVsb2NpdHkgZXRjXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKi9cbiAgZnVuY3Rpb24gY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCkge1xuICAgICAgdmFyIHNlc3Npb24gPSBtYW5hZ2VyLnNlc3Npb247XG4gICAgICB2YXIgcG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycztcbiAgICAgIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDtcblxuICAgICAgLy8gc3RvcmUgdGhlIGZpcnN0IGlucHV0IHRvIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYW5kIGRpcmVjdGlvblxuICAgICAgaWYgKCFzZXNzaW9uLmZpcnN0SW5wdXQpIHtcbiAgICAgICAgICBzZXNzaW9uLmZpcnN0SW5wdXQgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRvIGNvbXB1dGUgc2NhbGUgYW5kIHJvdGF0aW9uIHdlIG5lZWQgdG8gc3RvcmUgdGhlIG11bHRpcGxlIHRvdWNoZXNcbiAgICAgIGlmIChwb2ludGVyc0xlbmd0aCA+IDEgJiYgIXNlc3Npb24uZmlyc3RNdWx0aXBsZSkge1xuICAgICAgICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgICAgIH0gZWxzZSBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpcnN0SW5wdXQgPSBzZXNzaW9uLmZpcnN0SW5wdXQ7XG4gICAgICB2YXIgZmlyc3RNdWx0aXBsZSA9IHNlc3Npb24uZmlyc3RNdWx0aXBsZTtcbiAgICAgIHZhciBvZmZzZXRDZW50ZXIgPSBmaXJzdE11bHRpcGxlID8gZmlyc3RNdWx0aXBsZS5jZW50ZXIgOiBmaXJzdElucHV0LmNlbnRlcjtcblxuICAgICAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlciA9IGdldENlbnRlcihwb2ludGVycyk7XG4gICAgICBpbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICAgIGlucHV0LmRlbHRhVGltZSA9IGlucHV0LnRpbWVTdGFtcCAtIGZpcnN0SW5wdXQudGltZVN0YW1wO1xuXG4gICAgICBpbnB1dC5hbmdsZSA9IGdldEFuZ2xlKG9mZnNldENlbnRlciwgY2VudGVyKTtcbiAgICAgIGlucHV0LmRpc3RhbmNlID0gZ2V0RGlzdGFuY2Uob2Zmc2V0Q2VudGVyLCBjZW50ZXIpO1xuXG4gICAgICBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCk7XG4gICAgICBpbnB1dC5vZmZzZXREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuXG4gICAgICB2YXIgb3ZlcmFsbFZlbG9jaXR5ID0gZ2V0VmVsb2NpdHkoaW5wdXQuZGVsdGFUaW1lLCBpbnB1dC5kZWx0YVgsIGlucHV0LmRlbHRhWSk7XG4gICAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYID0gb3ZlcmFsbFZlbG9jaXR5Lng7XG4gICAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZID0gb3ZlcmFsbFZlbG9jaXR5Lnk7XG4gICAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHkgPSAoYWJzKG92ZXJhbGxWZWxvY2l0eS54KSA+IGFicyhvdmVyYWxsVmVsb2NpdHkueSkpID8gb3ZlcmFsbFZlbG9jaXR5LnggOiBvdmVyYWxsVmVsb2NpdHkueTtcblxuICAgICAgaW5wdXQuc2NhbGUgPSBmaXJzdE11bHRpcGxlID8gZ2V0U2NhbGUoZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMTtcbiAgICAgIGlucHV0LnJvdGF0aW9uID0gZmlyc3RNdWx0aXBsZSA/IGdldFJvdGF0aW9uKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDA7XG5cbiAgICAgIGlucHV0Lm1heFBvaW50ZXJzID0gIXNlc3Npb24ucHJldklucHV0ID8gaW5wdXQucG9pbnRlcnMubGVuZ3RoIDogKChpbnB1dC5wb2ludGVycy5sZW5ndGggPlxuICAgICAgICAgIHNlc3Npb24ucHJldklucHV0Lm1heFBvaW50ZXJzKSA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6IHNlc3Npb24ucHJldklucHV0Lm1heFBvaW50ZXJzKTtcblxuICAgICAgY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KTtcblxuICAgICAgLy8gZmluZCB0aGUgY29ycmVjdCB0YXJnZXRcbiAgICAgIHZhciB0YXJnZXQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgICBpZiAoaGFzUGFyZW50KGlucHV0LnNyY0V2ZW50LnRhcmdldCwgdGFyZ2V0KSkge1xuICAgICAgICAgIHRhcmdldCA9IGlucHV0LnNyY0V2ZW50LnRhcmdldDtcbiAgICAgIH1cbiAgICAgIGlucHV0LnRhcmdldCA9IHRhcmdldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KSB7XG4gICAgICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyO1xuICAgICAgdmFyIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgfHwge307XG4gICAgICB2YXIgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgfHwge307XG4gICAgICB2YXIgcHJldklucHV0ID0gc2Vzc2lvbi5wcmV2SW5wdXQgfHwge307XG5cbiAgICAgIGlmIChpbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX1NUQVJUIHx8IHByZXZJbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX0VORCkge1xuICAgICAgICAgIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhID0ge1xuICAgICAgICAgICAgICB4OiBwcmV2SW5wdXQuZGVsdGFYIHx8IDAsXG4gICAgICAgICAgICAgIHk6IHByZXZJbnB1dC5kZWx0YVkgfHwgMFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhID0ge1xuICAgICAgICAgICAgICB4OiBjZW50ZXIueCxcbiAgICAgICAgICAgICAgeTogY2VudGVyLnlcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpbnB1dC5kZWx0YVggPSBwcmV2RGVsdGEueCArIChjZW50ZXIueCAtIG9mZnNldC54KTtcbiAgICAgIGlucHV0LmRlbHRhWSA9IHByZXZEZWx0YS55ICsgKGNlbnRlci55IC0gb2Zmc2V0LnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIHZlbG9jaXR5IGlzIGNhbGN1bGF0ZWQgZXZlcnkgeCBtc1xuICAgKiBAcGFyYW0ge09iamVjdH0gc2Vzc2lvblxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICovXG4gIGZ1bmN0aW9uIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCkge1xuICAgICAgdmFyIGxhc3QgPSBzZXNzaW9uLmxhc3RJbnRlcnZhbCB8fCBpbnB1dCxcbiAgICAgICAgICBkZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBsYXN0LnRpbWVTdGFtcCxcbiAgICAgICAgICB2ZWxvY2l0eSwgdmVsb2NpdHlYLCB2ZWxvY2l0eVksIGRpcmVjdGlvbjtcblxuICAgICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9DQU5DRUwgJiYgKGRlbHRhVGltZSA+IENPTVBVVEVfSU5URVJWQUwgfHwgbGFzdC52ZWxvY2l0eSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgIHZhciBkZWx0YVggPSBpbnB1dC5kZWx0YVggLSBsYXN0LmRlbHRhWDtcbiAgICAgICAgICB2YXIgZGVsdGFZID0gaW5wdXQuZGVsdGFZIC0gbGFzdC5kZWx0YVk7XG5cbiAgICAgICAgICB2YXIgdiA9IGdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICAgIHZlbG9jaXR5WCA9IHYueDtcbiAgICAgICAgICB2ZWxvY2l0eVkgPSB2Lnk7XG4gICAgICAgICAgdmVsb2NpdHkgPSAoYWJzKHYueCkgPiBhYnModi55KSkgPyB2LnggOiB2Lnk7XG4gICAgICAgICAgZGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGRlbHRhWCwgZGVsdGFZKTtcblxuICAgICAgICAgIHNlc3Npb24ubGFzdEludGVydmFsID0gaW5wdXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVzZSBsYXRlc3QgdmVsb2NpdHkgaW5mbyBpZiBpdCBkb2Vzbid0IG92ZXJ0YWtlIGEgbWluaW11bSBwZXJpb2RcbiAgICAgICAgICB2ZWxvY2l0eSA9IGxhc3QudmVsb2NpdHk7XG4gICAgICAgICAgdmVsb2NpdHlYID0gbGFzdC52ZWxvY2l0eVg7XG4gICAgICAgICAgdmVsb2NpdHlZID0gbGFzdC52ZWxvY2l0eVk7XG4gICAgICAgICAgZGlyZWN0aW9uID0gbGFzdC5kaXJlY3Rpb247XG4gICAgICB9XG5cbiAgICAgIGlucHV0LnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgICBpbnB1dC52ZWxvY2l0eVggPSB2ZWxvY2l0eVg7XG4gICAgICBpbnB1dC52ZWxvY2l0eVkgPSB2ZWxvY2l0eVk7XG4gICAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogY3JlYXRlIGEgc2ltcGxlIGNsb25lIGZyb20gdGhlIGlucHV0IHVzZWQgZm9yIHN0b3JhZ2Ugb2YgZmlyc3RJbnB1dCBhbmQgZmlyc3RNdWx0aXBsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICogQHJldHVybnMge09iamVjdH0gY2xvbmVkSW5wdXREYXRhXG4gICAqL1xuICBmdW5jdGlvbiBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCkge1xuICAgICAgLy8gbWFrZSBhIHNpbXBsZSBjb3B5IG9mIHRoZSBwb2ludGVycyBiZWNhdXNlIHdlIHdpbGwgZ2V0IGEgcmVmZXJlbmNlIGlmIHdlIGRvbid0XG4gICAgICAvLyB3ZSBvbmx5IG5lZWQgY2xpZW50WFkgZm9yIHRoZSBjYWxjdWxhdGlvbnNcbiAgICAgIHZhciBwb2ludGVycyA9IFtdO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUgKGkgPCBpbnB1dC5wb2ludGVycy5sZW5ndGgpIHtcbiAgICAgICAgICBwb2ludGVyc1tpXSA9IHtcbiAgICAgICAgICAgICAgY2xpZW50WDogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WCksXG4gICAgICAgICAgICAgIGNsaWVudFk6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFkpXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpKys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGltZVN0YW1wOiBub3coKSxcbiAgICAgICAgICBwb2ludGVyczogcG9pbnRlcnMsXG4gICAgICAgICAgY2VudGVyOiBnZXRDZW50ZXIocG9pbnRlcnMpLFxuICAgICAgICAgIGRlbHRhWDogaW5wdXQuZGVsdGFYLFxuICAgICAgICAgIGRlbHRhWTogaW5wdXQuZGVsdGFZXG4gICAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgY2VudGVyIG9mIGFsbCB0aGUgcG9pbnRlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRlcnNcbiAgICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgY29udGFpbnMgYHhgIGFuZCBgeWAgcHJvcGVydGllc1xuICAgKi9cbiAgZnVuY3Rpb24gZ2V0Q2VudGVyKHBvaW50ZXJzKSB7XG4gICAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XG5cbiAgICAgIC8vIG5vIG5lZWQgdG8gbG9vcCB3aGVuIG9ubHkgb25lIHRvdWNoXG4gICAgICBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB4OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRYKSxcbiAgICAgICAgICAgICAgeTogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WSlcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgeCA9IDAsIHkgPSAwLCBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgcG9pbnRlcnNMZW5ndGgpIHtcbiAgICAgICAgICB4ICs9IHBvaW50ZXJzW2ldLmNsaWVudFg7XG4gICAgICAgICAgeSArPSBwb2ludGVyc1tpXS5jbGllbnRZO1xuICAgICAgICAgIGkrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiByb3VuZCh4IC8gcG9pbnRlcnNMZW5ndGgpLFxuICAgICAgICAgIHk6IHJvdW5kKHkgLyBwb2ludGVyc0xlbmd0aClcbiAgICAgIH07XG4gIH1cblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSB2ZWxvY2l0eSBiZXR3ZWVuIHR3byBwb2ludHMuIHVuaXQgaXMgaW4gcHggcGVyIG1zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge09iamVjdH0gdmVsb2NpdHkgYHhgIGFuZCBgeWBcbiAgICovXG4gIGZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgeCwgeSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB4IC8gZGVsdGFUaW1lIHx8IDAsXG4gICAgICAgICAgeTogeSAvIGRlbHRhVGltZSB8fCAwXG4gICAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgZGlyZWN0aW9uIGJldHdlZW4gdHdvIHBvaW50c1xuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGRpcmVjdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHgsIHkpIHtcbiAgICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgICAgcmV0dXJuIERJUkVDVElPTl9OT05FO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWJzKHgpID49IGFicyh5KSkge1xuICAgICAgICAgIHJldHVybiB4IDwgMCA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHkgPCAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gIH1cblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBhYnNvbHV0ZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAgICogQHBhcmFtIHtPYmplY3R9IHAxIHt4LCB5fVxuICAgKiBAcGFyYW0ge09iamVjdH0gcDIge3gsIHl9XG4gICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAgICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyLCBwcm9wcykge1xuICAgICAgaWYgKCFwcm9wcykge1xuICAgICAgICAgIHByb3BzID0gUFJPUFNfWFk7XG4gICAgICB9XG4gICAgICB2YXIgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXSxcbiAgICAgICAgICB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuXG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KCh4ICogeCkgKyAoeSAqIHkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwMVxuICAgKiBAcGFyYW0ge09iamVjdH0gcDJcbiAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGFuZ2xlXG4gICAqL1xuICBmdW5jdGlvbiBnZXRBbmdsZShwMSwgcDIsIHByb3BzKSB7XG4gICAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgICAgIH1cbiAgICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dLFxuICAgICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG4gICAgICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIDE4MCAvIE1hdGguUEk7XG4gIH1cblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHJvdGF0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gZ2V0QW5nbGUoZW5kWzFdLCBlbmRbMF0sIFBST1BTX0NMSUVOVF9YWSkgKyBnZXRBbmdsZShzdGFydFsxXSwgc3RhcnRbMF0sIFBST1BTX0NMSUVOVF9YWSk7XG4gIH1cblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAgICogbm8gc2NhbGUgaXMgMSwgYW5kIGdvZXMgZG93biB0byAwIHdoZW4gcGluY2hlZCB0b2dldGhlciwgYW5kIGJpZ2dlciB3aGVuIHBpbmNoZWQgb3V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTY2FsZShzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gZ2V0RGlzdGFuY2UoZW5kWzBdLCBlbmRbMV0sIFBST1BTX0NMSUVOVF9YWSkgLyBnZXREaXN0YW5jZShzdGFydFswXSwgc3RhcnRbMV0sIFBST1BTX0NMSUVOVF9YWSk7XG4gIH1cblxuICB2YXIgTU9VU0VfSU5QVVRfTUFQID0ge1xuICAgICAgbW91c2Vkb3duOiBJTlBVVF9TVEFSVCxcbiAgICAgIG1vdXNlbW92ZTogSU5QVVRfTU9WRSxcbiAgICAgIG1vdXNldXA6IElOUFVUX0VORFxuICB9O1xuXG4gIHZhciBNT1VTRV9FTEVNRU5UX0VWRU5UUyA9ICdtb3VzZWRvd24nO1xuICB2YXIgTU9VU0VfV0lORE9XX0VWRU5UUyA9ICdtb3VzZW1vdmUgbW91c2V1cCc7XG5cbiAgLyoqXG4gICAqIE1vdXNlIGV2ZW50cyBpbnB1dFxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgSW5wdXRcbiAgICovXG4gIGZ1bmN0aW9uIE1vdXNlSW5wdXQoKSB7XG4gICAgICB0aGlzLmV2RWwgPSBNT1VTRV9FTEVNRU5UX0VWRU5UUztcbiAgICAgIHRoaXMuZXZXaW4gPSBNT1VTRV9XSU5ET1dfRVZFTlRTO1xuXG4gICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTsgLy8gbW91c2Vkb3duIHN0YXRlXG5cbiAgICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpbmhlcml0KE1vdXNlSW5wdXQsIElucHV0LCB7XG4gICAgICAvKipcbiAgICAgICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAgICovXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBNRWhhbmRsZXIoZXYpIHtcbiAgICAgICAgICB2YXIgZXZlbnRUeXBlID0gTU9VU0VfSU5QVVRfTUFQW2V2LnR5cGVdO1xuXG4gICAgICAgICAgLy8gb24gc3RhcnQgd2Ugd2FudCB0byBoYXZlIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXG4gICAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIGV2LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAgICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9NT1ZFICYmIGV2LndoaWNoICE9PSAxKSB7XG4gICAgICAgICAgICAgIGV2ZW50VHlwZSA9IElOUFVUX0VORDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBtb3VzZSBtdXN0IGJlIGRvd25cbiAgICAgICAgICBpZiAoIXRoaXMucHJlc3NlZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICAgICAgICAgIHBvaW50ZXJzOiBbZXZdLFxuICAgICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX01PVVNFLFxuICAgICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgfSk7XG5cbiAgdmFyIFBPSU5URVJfSU5QVVRfTUFQID0ge1xuICAgICAgcG9pbnRlcmRvd246IElOUFVUX1NUQVJULFxuICAgICAgcG9pbnRlcm1vdmU6IElOUFVUX01PVkUsXG4gICAgICBwb2ludGVydXA6IElOUFVUX0VORCxcbiAgICAgIHBvaW50ZXJjYW5jZWw6IElOUFVUX0NBTkNFTCxcbiAgICAgIHBvaW50ZXJvdXQ6IElOUFVUX0NBTkNFTFxuICB9O1xuXG4gIC8vIGluIElFMTAgdGhlIHBvaW50ZXIgdHlwZXMgaXMgZGVmaW5lZCBhcyBhbiBlbnVtXG4gIHZhciBJRTEwX1BPSU5URVJfVFlQRV9FTlVNID0ge1xuICAgICAgMjogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgIDM6IElOUFVUX1RZUEVfUEVOLFxuICAgICAgNDogSU5QVVRfVFlQRV9NT1VTRSxcbiAgICAgIDU6IElOUFVUX1RZUEVfS0lORUNUIC8vIHNlZSBodHRwczovL3R3aXR0ZXIuY29tL2phY29icm9zc2kvc3RhdHVzLzQ4MDU5NjQzODQ4OTg5MDgxNlxuICB9O1xuXG4gIHZhciBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ3BvaW50ZXJkb3duJztcbiAgdmFyIFBPSU5URVJfV0lORE9XX0VWRU5UUyA9ICdwb2ludGVybW92ZSBwb2ludGVydXAgcG9pbnRlcmNhbmNlbCc7XG5cbiAgLy8gSUUxMCBoYXMgcHJlZml4ZWQgc3VwcG9ydCwgYW5kIGNhc2Utc2Vuc2l0aXZlXG4gIGlmICh3aW5kb3cuTVNQb2ludGVyRXZlbnQgJiYgIXdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcbiAgICAgIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAnTVNQb2ludGVyRG93bic7XG4gICAgICBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAnTVNQb2ludGVyTW92ZSBNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWwnO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvaW50ZXIgZXZlbnRzIGlucHV0XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBJbnB1dFxuICAgKi9cbiAgZnVuY3Rpb24gUG9pbnRlckV2ZW50SW5wdXQoKSB7XG4gICAgICB0aGlzLmV2RWwgPSBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTO1xuICAgICAgdGhpcy5ldldpbiA9IFBPSU5URVJfV0lORE9XX0VWRU5UUztcblxuICAgICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgdGhpcy5zdG9yZSA9ICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wb2ludGVyRXZlbnRzID0gW10pO1xuICB9XG5cbiAgaW5oZXJpdChQb2ludGVyRXZlbnRJbnB1dCwgSW5wdXQsIHtcbiAgICAgIC8qKlxuICAgICAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICAgKi9cbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFBFaGFuZGxlcihldikge1xuICAgICAgICAgIHZhciBzdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgICAgICAgdmFyIHJlbW92ZVBvaW50ZXIgPSBmYWxzZTtcblxuICAgICAgICAgIHZhciBldmVudFR5cGVOb3JtYWxpemVkID0gZXYudHlwZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ21zJywgJycpO1xuICAgICAgICAgIHZhciBldmVudFR5cGUgPSBQT0lOVEVSX0lOUFVUX01BUFtldmVudFR5cGVOb3JtYWxpemVkXTtcbiAgICAgICAgICB2YXIgcG9pbnRlclR5cGUgPSBJRTEwX1BPSU5URVJfVFlQRV9FTlVNW2V2LnBvaW50ZXJUeXBlXSB8fCBldi5wb2ludGVyVHlwZTtcblxuICAgICAgICAgIHZhciBpc1RvdWNoID0gKHBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0gpO1xuXG4gICAgICAgICAgLy8gZ2V0IGluZGV4IG9mIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcbiAgICAgICAgICB2YXIgc3RvcmVJbmRleCA9IGluQXJyYXkoc3RvcmUsIGV2LnBvaW50ZXJJZCwgJ3BvaW50ZXJJZCcpO1xuXG4gICAgICAgICAgLy8gc3RhcnQgYW5kIG1vdXNlIG11c3QgYmUgZG93blxuICAgICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAoZXYuYnV0dG9uID09PSAwIHx8IGlzVG91Y2gpKSB7XG4gICAgICAgICAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgc3RvcmUucHVzaChldik7XG4gICAgICAgICAgICAgICAgICBzdG9yZUluZGV4ID0gc3RvcmUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlUG9pbnRlciA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaXQgbm90IGZvdW5kLCBzbyB0aGUgcG9pbnRlciBoYXNuJ3QgYmVlbiBkb3duIChzbyBpdCdzIHByb2JhYmx5IGEgaG92ZXIpXG4gICAgICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB1cGRhdGUgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuICAgICAgICAgIHN0b3JlW3N0b3JlSW5kZXhdID0gZXY7XG5cbiAgICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICAgICAgICAgIHBvaW50ZXJzOiBzdG9yZSxcbiAgICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgICAgICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXG4gICAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHJlbW92ZVBvaW50ZXIpIHtcbiAgICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gdGhlIHN0b3JlXG4gICAgICAgICAgICAgIHN0b3JlLnNwbGljZShzdG9yZUluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH0pO1xuXG4gIHZhciBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQID0ge1xuICAgICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXG4gICAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICAgICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxuICB9O1xuXG4gIHZhciBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0JztcbiAgdmFyIFNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcblxuICAvKipcbiAgICogVG91Y2ggZXZlbnRzIGlucHV0XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBJbnB1dFxuICAgKi9cbiAgZnVuY3Rpb24gU2luZ2xlVG91Y2hJbnB1dCgpIHtcbiAgICAgIHRoaXMuZXZUYXJnZXQgPSBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICAgIHRoaXMuZXZXaW4gPSBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUztcbiAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaW5oZXJpdChTaW5nbGVUb3VjaElucHV0LCBJbnB1dCwge1xuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gVEVoYW5kbGVyKGV2KSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdO1xuXG4gICAgICAgICAgLy8gc2hvdWxkIHdlIGhhbmRsZSB0aGUgdG91Y2ggZXZlbnRzP1xuICAgICAgICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdG91Y2hlcyA9IG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG5cbiAgICAgICAgICAvLyB3aGVuIGRvbmUsIHJlc2V0IHRoZSBzdGFydGVkIHN0YXRlXG4gICAgICAgICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiB0b3VjaGVzWzBdLmxlbmd0aCAtIHRvdWNoZXNbMV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtUb3VjaElucHV0fVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxuICAgKi9cbiAgZnVuY3Rpb24gbm9ybWFsaXplU2luZ2xlVG91Y2hlcyhldiwgdHlwZSkge1xuICAgICAgdmFyIGFsbCA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XG4gICAgICB2YXIgY2hhbmdlZCA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpO1xuXG4gICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgICAgYWxsID0gdW5pcXVlQXJyYXkoYWxsLmNvbmNhdChjaGFuZ2VkKSwgJ2lkZW50aWZpZXInLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFthbGwsIGNoYW5nZWRdO1xuICB9XG5cbiAgdmFyIFRPVUNIX0lOUFVUX01BUCA9IHtcbiAgICAgIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICAgICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgICAgdG91Y2hlbmQ6IElOUFVUX0VORCxcbiAgICAgIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbiAgfTtcblxuICB2YXIgVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cbiAgLyoqXG4gICAqIE11bHRpLXVzZXIgdG91Y2ggZXZlbnRzIGlucHV0XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBJbnB1dFxuICAgKi9cbiAgZnVuY3Rpb24gVG91Y2hJbnB1dCgpIHtcbiAgICAgIHRoaXMuZXZUYXJnZXQgPSBUT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgICAgdGhpcy50YXJnZXRJZHMgPSB7fTtcblxuICAgICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGluaGVyaXQoVG91Y2hJbnB1dCwgSW5wdXQsIHtcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIE1URWhhbmRsZXIoZXYpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IFRPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcbiAgICAgICAgICB2YXIgdG91Y2hlcyA9IGdldFRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG4gICAgICAgICAgaWYgKCF0b3VjaGVzKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgICAgICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGhpcyB7VG91Y2hJbnB1dH1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIGZsYWdcbiAgICogQHJldHVybnMge3VuZGVmaW5lZHxBcnJheX0gW2FsbCwgY2hhbmdlZF1cbiAgICovXG4gIGZ1bmN0aW9uIGdldFRvdWNoZXMoZXYsIHR5cGUpIHtcbiAgICAgIHZhciBhbGxUb3VjaGVzID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgICAgIHZhciB0YXJnZXRJZHMgPSB0aGlzLnRhcmdldElkcztcblxuICAgICAgLy8gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZSB0b3VjaCwgdGhlIHByb2Nlc3MgY2FuIGJlIHNpbXBsaWZpZWRcbiAgICAgIGlmICh0eXBlICYgKElOUFVUX1NUQVJUIHwgSU5QVVRfTU9WRSkgJiYgYWxsVG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB0YXJnZXRJZHNbYWxsVG91Y2hlc1swXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIFthbGxUb3VjaGVzLCBhbGxUb3VjaGVzXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGksXG4gICAgICAgICAgdGFyZ2V0VG91Y2hlcyxcbiAgICAgICAgICBjaGFuZ2VkVG91Y2hlcyA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpLFxuICAgICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzID0gW10sXG4gICAgICAgICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG5cbiAgICAgIC8vIGdldCB0YXJnZXQgdG91Y2hlcyBmcm9tIHRvdWNoZXNcbiAgICAgIHRhcmdldFRvdWNoZXMgPSBhbGxUb3VjaGVzLmZpbHRlcihmdW5jdGlvbih0b3VjaCkge1xuICAgICAgICAgIHJldHVybiBoYXNQYXJlbnQodG91Y2gudGFyZ2V0LCB0YXJnZXQpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGNvbGxlY3QgdG91Y2hlc1xuICAgICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgd2hpbGUgKGkgPCB0YXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0YXJnZXRJZHNbdGFyZ2V0VG91Y2hlc1tpXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGZpbHRlciBjaGFuZ2VkIHRvdWNoZXMgdG8gb25seSBjb250YWluIHRvdWNoZXMgdGhhdCBleGlzdCBpbiB0aGUgY29sbGVjdGVkIHRhcmdldCBpZHNcbiAgICAgIGkgPSAwO1xuICAgICAgd2hpbGUgKGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAodGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICAgICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzLnB1c2goY2hhbmdlZFRvdWNoZXNbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGNsZWFudXAgcmVtb3ZlZCB0b3VjaGVzXG4gICAgICAgICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpKys7XG4gICAgICB9XG5cbiAgICAgIGlmICghY2hhbmdlZFRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICAgIC8vIG1lcmdlIHRhcmdldFRvdWNoZXMgd2l0aCBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyBzbyBpdCBjb250YWlucyBBTEwgdG91Y2hlcywgaW5jbHVkaW5nICdlbmQnIGFuZCAnY2FuY2VsJ1xuICAgICAgICAgIHVuaXF1ZUFycmF5KHRhcmdldFRvdWNoZXMuY29uY2F0KGNoYW5nZWRUYXJnZXRUb3VjaGVzKSwgJ2lkZW50aWZpZXInLCB0cnVlKSxcbiAgICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlc1xuICAgICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21iaW5lZCB0b3VjaCBhbmQgbW91c2UgaW5wdXRcbiAgICpcbiAgICogVG91Y2ggaGFzIGEgaGlnaGVyIHByaW9yaXR5IHRoZW4gbW91c2UsIGFuZCB3aGlsZSB0b3VjaGluZyBubyBtb3VzZSBldmVudHMgYXJlIGFsbG93ZWQuXG4gICAqIFRoaXMgYmVjYXVzZSB0b3VjaCBkZXZpY2VzIGFsc28gZW1pdCBtb3VzZSBldmVudHMgd2hpbGUgZG9pbmcgYSB0b3VjaC5cbiAgICpcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIElucHV0XG4gICAqL1xuXG4gIHZhciBERURVUF9USU1FT1VUID0gMjUwMDtcbiAgdmFyIERFRFVQX0RJU1RBTkNFID0gMjU7XG5cbiAgZnVuY3Rpb24gVG91Y2hNb3VzZUlucHV0KCkge1xuICAgICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgdmFyIGhhbmRsZXIgPSBiaW5kRm4odGhpcy5oYW5kbGVyLCB0aGlzKTtcbiAgICAgIHRoaXMudG91Y2ggPSBuZXcgVG91Y2hJbnB1dCh0aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xuICAgICAgdGhpcy5tb3VzZSA9IG5ldyBNb3VzZUlucHV0KHRoaXMubWFuYWdlciwgaGFuZGxlcik7XG5cbiAgICAgIHRoaXMucHJpbWFyeVRvdWNoID0gbnVsbDtcbiAgICAgIHRoaXMubGFzdFRvdWNoZXMgPSBbXTtcbiAgfVxuXG4gIGluaGVyaXQoVG91Y2hNb3VzZUlucHV0LCBJbnB1dCwge1xuICAgICAgLyoqXG4gICAgICAgKiBoYW5kbGUgbW91c2UgYW5kIHRvdWNoIGV2ZW50c1xuICAgICAgICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dEV2ZW50XG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICAgKi9cbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFRNRWhhbmRsZXIobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKSB7XG4gICAgICAgICAgdmFyIGlzVG91Y2ggPSAoaW5wdXREYXRhLnBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0gpLFxuICAgICAgICAgICAgICBpc01vdXNlID0gKGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX01PVVNFKTtcblxuICAgICAgICAgIGlmIChpc01vdXNlICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMgJiYgaW5wdXREYXRhLnNvdXJjZUNhcGFiaWxpdGllcy5maXJlc1RvdWNoRXZlbnRzKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB3aGVuIHdlJ3JlIGluIGEgdG91Y2ggZXZlbnQsIHJlY29yZCB0b3VjaGVzIHRvICBkZS1kdXBlIHN5bnRoZXRpYyBtb3VzZSBldmVudFxuICAgICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgICAgIHJlY29yZFRvdWNoZXMuY2FsbCh0aGlzLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNb3VzZSAmJiBpc1N5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgaW5wdXREYXRhKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5jYWxsYmFjayhtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICovXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgIHRoaXMudG91Y2guZGVzdHJveSgpO1xuICAgICAgICAgIHRoaXMubW91c2UuZGVzdHJveSgpO1xuICAgICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiByZWNvcmRUb3VjaGVzKGV2ZW50VHlwZSwgZXZlbnREYXRhKSB7XG4gICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgICB0aGlzLnByaW1hcnlUb3VjaCA9IGV2ZW50RGF0YS5jaGFuZ2VkUG9pbnRlcnNbMF0uaWRlbnRpZmllcjtcbiAgICAgICAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICAgICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICAgIHNldExhc3RUb3VjaC5jYWxsKHRoaXMsIGV2ZW50RGF0YSk7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMYXN0VG91Y2goZXZlbnREYXRhKSB7XG4gICAgICB2YXIgdG91Y2ggPSBldmVudERhdGEuY2hhbmdlZFBvaW50ZXJzWzBdO1xuXG4gICAgICBpZiAodG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5wcmltYXJ5VG91Y2gpIHtcbiAgICAgICAgICB2YXIgbGFzdFRvdWNoID0ge3g6IHRvdWNoLmNsaWVudFgsIHk6IHRvdWNoLmNsaWVudFl9O1xuICAgICAgICAgIHRoaXMubGFzdFRvdWNoZXMucHVzaChsYXN0VG91Y2gpO1xuICAgICAgICAgIHZhciBsdHMgPSB0aGlzLmxhc3RUb3VjaGVzO1xuICAgICAgICAgIHZhciByZW1vdmVMYXN0VG91Y2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGkgPSBsdHMuaW5kZXhPZihsYXN0VG91Y2gpO1xuICAgICAgICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICBsdHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBzZXRUaW1lb3V0KHJlbW92ZUxhc3RUb3VjaCwgREVEVVBfVElNRU9VVCk7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bnRoZXRpY0V2ZW50KGV2ZW50RGF0YSkge1xuICAgICAgdmFyIHggPSBldmVudERhdGEuc3JjRXZlbnQuY2xpZW50WCwgeSA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRZO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxhc3RUb3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHQgPSB0aGlzLmxhc3RUb3VjaGVzW2ldO1xuICAgICAgICAgIHZhciBkeCA9IE1hdGguYWJzKHggLSB0LngpLCBkeSA9IE1hdGguYWJzKHkgLSB0LnkpO1xuICAgICAgICAgIGlmIChkeCA8PSBERURVUF9ESVNUQU5DRSAmJiBkeSA8PSBERURVUF9ESVNUQU5DRSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgUFJFRklYRURfVE9VQ0hfQUNUSU9OID0gcHJlZml4ZWQoVEVTVF9FTEVNRU5ULnN0eWxlLCAndG91Y2hBY3Rpb24nKTtcbiAgdmFyIE5BVElWRV9UT1VDSF9BQ1RJT04gPSBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gIT09IHVuZGVmaW5lZDtcblxuICAvLyBtYWdpY2FsIHRvdWNoQWN0aW9uIHZhbHVlXG4gIHZhciBUT1VDSF9BQ1RJT05fQ09NUFVURSA9ICdjb21wdXRlJztcbiAgdmFyIFRPVUNIX0FDVElPTl9BVVRPID0gJ2F1dG8nO1xuICB2YXIgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTiA9ICdtYW5pcHVsYXRpb24nOyAvLyBub3QgaW1wbGVtZW50ZWRcbiAgdmFyIFRPVUNIX0FDVElPTl9OT05FID0gJ25vbmUnO1xuICB2YXIgVE9VQ0hfQUNUSU9OX1BBTl9YID0gJ3Bhbi14JztcbiAgdmFyIFRPVUNIX0FDVElPTl9QQU5fWSA9ICdwYW4teSc7XG4gIHZhciBUT1VDSF9BQ1RJT05fTUFQID0gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpO1xuXG4gIC8qKlxuICAgKiBUb3VjaCBBY3Rpb25cbiAgICogc2V0cyB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgb3IgdXNlcyB0aGUganMgYWx0ZXJuYXRpdmVcbiAgICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFRvdWNoQWN0aW9uKG1hbmFnZXIsIHZhbHVlKSB7XG4gICAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgICAgdGhpcy5zZXQodmFsdWUpO1xuICB9XG5cbiAgVG91Y2hBY3Rpb24ucHJvdG90eXBlID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBzZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlIG9uIHRoZSBlbGVtZW50IG9yIGVuYWJsZSB0aGUgcG9seWZpbGxcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAgICovXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgLy8gZmluZCBvdXQgdGhlIHRvdWNoLWFjdGlvbiBieSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgICBpZiAodmFsdWUgPT0gVE9VQ0hfQUNUSU9OX0NPTVBVVEUpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmNvbXB1dGUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoTkFUSVZFX1RPVUNIX0FDVElPTiAmJiB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZSAmJiBUT1VDSF9BQ1RJT05fTUFQW3ZhbHVlXSkge1xuICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZVtQUkVGSVhFRF9UT1VDSF9BQ1RJT05dID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYWN0aW9ucyA9IHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBqdXN0IHJlLXNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWVcbiAgICAgICAqL1xuICAgICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLnNldCh0aGlzLm1hbmFnZXIub3B0aW9ucy50b3VjaEFjdGlvbik7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIGNvbXB1dGUgdGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgYmFzZWQgb24gdGhlIHJlY29nbml6ZXIncyBzZXR0aW5nc1xuICAgICAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcbiAgICAgICAqL1xuICAgICAgY29tcHV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICAgICAgICBlYWNoKHRoaXMubWFuYWdlci5yZWNvZ25pemVycywgZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICAgICAgICBpZiAoYm9vbE9yRm4ocmVjb2duaXplci5vcHRpb25zLmVuYWJsZSwgW3JlY29nbml6ZXJdKSkge1xuICAgICAgICAgICAgICAgICAgYWN0aW9ucyA9IGFjdGlvbnMuY29uY2F0KHJlY29nbml6ZXIuZ2V0VG91Y2hBY3Rpb24oKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucy5qb2luKCcgJykpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgb24gZWFjaCBpbnB1dCBjeWNsZSBhbmQgcHJvdmlkZXMgdGhlIHByZXZlbnRpbmcgb2YgdGhlIGJyb3dzZXIgYmVoYXZpb3JcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAgICovXG4gICAgICBwcmV2ZW50RGVmYXVsdHM6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgdmFyIHNyY0V2ZW50ID0gaW5wdXQuc3JjRXZlbnQ7XG4gICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0Lm9mZnNldERpcmVjdGlvbjtcblxuICAgICAgICAgIC8vIGlmIHRoZSB0b3VjaCBhY3Rpb24gZGlkIHByZXZlbnRlZCBvbmNlIHRoaXMgc2Vzc2lvblxuICAgICAgICAgIGlmICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuICAgICAgICAgIHZhciBoYXNOb25lID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICAgICAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9ZXTtcbiAgICAgICAgICB2YXIgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9YXTtcblxuICAgICAgICAgIGlmIChoYXNOb25lKSB7XG4gICAgICAgICAgICAgIC8vZG8gbm90IHByZXZlbnQgZGVmYXVsdHMgaWYgdGhpcyBpcyBhIHRhcCBnZXN0dXJlXG5cbiAgICAgICAgICAgICAgdmFyIGlzVGFwUG9pbnRlciA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgICAgdmFyIGlzVGFwTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IDI7XG4gICAgICAgICAgICAgIHZhciBpc1RhcFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IDI1MDtcblxuICAgICAgICAgICAgICBpZiAoaXNUYXBQb2ludGVyICYmIGlzVGFwTW92ZW1lbnQgJiYgaXNUYXBUb3VjaFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICAgICAgICAgICAgLy8gYHBhbi14IHBhbi15YCBtZWFucyBicm93c2VyIGhhbmRsZXMgYWxsIHNjcm9sbGluZy9wYW5uaW5nLCBkbyBub3QgcHJldmVudFxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhc05vbmUgfHxcbiAgICAgICAgICAgICAgKGhhc1BhblkgJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHx8XG4gICAgICAgICAgICAgIChoYXNQYW5YICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmVudFNyYyhzcmNFdmVudCk7XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBjYWxsIHByZXZlbnREZWZhdWx0IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIncyBkZWZhdWx0IGJlaGF2aW9yIChzY3JvbGxpbmcgaW4gbW9zdCBjYXNlcylcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNFdmVudFxuICAgICAgICovXG4gICAgICBwcmV2ZW50U3JjOiBmdW5jdGlvbihzcmNFdmVudCkge1xuICAgICAgICAgIHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogd2hlbiB0aGUgdG91Y2hBY3Rpb25zIGFyZSBjb2xsZWN0ZWQgdGhleSBhcmUgbm90IGEgdmFsaWQgdmFsdWUsIHNvIHdlIG5lZWQgdG8gY2xlYW4gdGhpbmdzIHVwLiAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25zXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgZnVuY3Rpb24gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucykge1xuICAgICAgLy8gbm9uZVxuICAgICAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSkge1xuICAgICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpO1xuICAgICAgdmFyIGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpO1xuXG4gICAgICAvLyBpZiBib3RoIHBhbi14IGFuZCBwYW4teSBhcmUgc2V0IChkaWZmZXJlbnQgcmVjb2duaXplcnNcbiAgICAgIC8vIGZvciBkaWZmZXJlbnQgZGlyZWN0aW9ucywgZS5nLiBob3Jpem9udGFsIHBhbiBidXQgdmVydGljYWwgc3dpcGU/KVxuICAgICAgLy8gd2UgbmVlZCBub25lIChhcyBvdGhlcndpc2Ugd2l0aCBwYW4teCBwYW4teSBjb21iaW5lZCBub25lIG9mIHRoZXNlXG4gICAgICAvLyByZWNvZ25pemVycyB3aWxsIHdvcmssIHNpbmNlIHRoZSBicm93c2VyIHdvdWxkIGhhbmRsZSBhbGwgcGFubmluZ1xuICAgICAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcbiAgICAgIH1cblxuICAgICAgLy8gcGFuLXggT1IgcGFuLXlcbiAgICAgIGlmIChoYXNQYW5YIHx8IGhhc1BhblkpIHtcbiAgICAgICAgICByZXR1cm4gaGFzUGFuWCA/IFRPVUNIX0FDVElPTl9QQU5fWCA6IFRPVUNIX0FDVElPTl9QQU5fWTtcbiAgICAgIH1cblxuICAgICAgLy8gbWFuaXB1bGF0aW9uXG4gICAgICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTikpIHtcbiAgICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9BVVRPO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpIHtcbiAgICAgIGlmICghTkFUSVZFX1RPVUNIX0FDVElPTikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0b3VjaE1hcCA9IHt9O1xuICAgICAgdmFyIGNzc1N1cHBvcnRzID0gd2luZG93LkNTUyAmJiB3aW5kb3cuQ1NTLnN1cHBvcnRzO1xuICAgICAgWydhdXRvJywgJ21hbmlwdWxhdGlvbicsICdwYW4teScsICdwYW4teCcsICdwYW4teCBwYW4teScsICdub25lJ10uZm9yRWFjaChmdW5jdGlvbih2YWwpIHtcblxuICAgICAgICAgIC8vIElmIGNzcy5zdXBwb3J0cyBpcyBub3Qgc3VwcG9ydGVkIGJ1dCB0aGVyZSBpcyBuYXRpdmUgdG91Y2gtYWN0aW9uIGFzc3VtZSBpdCBzdXBwb3J0c1xuICAgICAgICAgIC8vIGFsbCB2YWx1ZXMuIFRoaXMgaXMgdGhlIGNhc2UgZm9yIElFIDEwIGFuZCAxMS5cbiAgICAgICAgICB0b3VjaE1hcFt2YWxdID0gY3NzU3VwcG9ydHMgPyB3aW5kb3cuQ1NTLnN1cHBvcnRzKCd0b3VjaC1hY3Rpb24nLCB2YWwpIDogdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRvdWNoTWFwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY29nbml6ZXIgZmxvdyBleHBsYWluZWQ7ICpcbiAgICogQWxsIHJlY29nbml6ZXJzIGhhdmUgdGhlIGluaXRpYWwgc3RhdGUgb2YgUE9TU0lCTEUgd2hlbiBhIGlucHV0IHNlc3Npb24gc3RhcnRzLlxuICAgKiBUaGUgZGVmaW5pdGlvbiBvZiBhIGlucHV0IHNlc3Npb24gaXMgZnJvbSB0aGUgZmlyc3QgaW5wdXQgdW50aWwgdGhlIGxhc3QgaW5wdXQsIHdpdGggYWxsIGl0J3MgbW92ZW1lbnQgaW4gaXQuICpcbiAgICogRXhhbXBsZSBzZXNzaW9uIGZvciBtb3VzZS1pbnB1dDogbW91c2Vkb3duIC0+IG1vdXNlbW92ZSAtPiBtb3VzZXVwXG4gICAqXG4gICAqIE9uIGVhY2ggcmVjb2duaXppbmcgY3ljbGUgKHNlZSBNYW5hZ2VyLnJlY29nbml6ZSkgdGhlIC5yZWNvZ25pemUoKSBtZXRob2QgaXMgZXhlY3V0ZWRcbiAgICogd2hpY2ggZGV0ZXJtaW5lcyB3aXRoIHN0YXRlIGl0IHNob3VsZCBiZS5cbiAgICpcbiAgICogSWYgdGhlIHJlY29nbml6ZXIgaGFzIHRoZSBzdGF0ZSBGQUlMRUQsIENBTkNFTExFRCBvciBSRUNPR05JWkVEIChlcXVhbHMgRU5ERUQpLCBpdCBpcyByZXNldCB0b1xuICAgKiBQT1NTSUJMRSB0byBnaXZlIGl0IGFub3RoZXIgY2hhbmdlIG9uIHRoZSBuZXh0IGN5Y2xlLlxuICAgKlxuICAgKiAgICAgICAgICAgICAgIFBvc3NpYmxlXG4gICAqICAgICAgICAgICAgICAgICAgfFxuICAgKiAgICAgICAgICAgICstLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gICAqICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogICAgICArLS0tLS0rLS0tLS0rICAgICAgICAgICAgICAgfFxuICAgKiAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICB8XG4gICAqICAgRmFpbGVkICAgICAgQ2FuY2VsbGVkICAgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tKy0tLS0tLStcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgICAgICAgUmVjb2duaXplZCAgICAgICBCZWdhblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hhbmdlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbmRlZC9SZWNvZ25pemVkXG4gICAqL1xuICB2YXIgU1RBVEVfUE9TU0lCTEUgPSAxO1xuICB2YXIgU1RBVEVfQkVHQU4gPSAyO1xuICB2YXIgU1RBVEVfQ0hBTkdFRCA9IDQ7XG4gIHZhciBTVEFURV9FTkRFRCA9IDg7XG4gIHZhciBTVEFURV9SRUNPR05JWkVEID0gU1RBVEVfRU5ERUQ7XG4gIHZhciBTVEFURV9DQU5DRUxMRUQgPSAxNjtcbiAgdmFyIFNUQVRFX0ZBSUxFRCA9IDMyO1xuXG4gIC8qKlxuICAgKiBSZWNvZ25pemVyXG4gICAqIEV2ZXJ5IHJlY29nbml6ZXIgbmVlZHMgdG8gZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBSZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgdGhpcy5kZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICAgIHRoaXMuaWQgPSB1bmlxdWVJZCgpO1xuXG4gICAgICB0aGlzLm1hbmFnZXIgPSBudWxsO1xuXG4gICAgICAvLyBkZWZhdWx0IGlzIGVuYWJsZSB0cnVlXG4gICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlID0gaWZVbmRlZmluZWQodGhpcy5vcHRpb25zLmVuYWJsZSwgdHJ1ZSk7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QT1NTSUJMRTtcblxuICAgICAgdGhpcy5zaW11bHRhbmVvdXMgPSB7fTtcbiAgICAgIHRoaXMucmVxdWlyZUZhaWwgPSBbXTtcbiAgfVxuXG4gIFJlY29nbml6ZXIucHJvdG90eXBlID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBAdmlydHVhbFxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgZGVmYXVsdHM6IHt9LFxuXG4gICAgICAvKipcbiAgICAgICAqIHNldCBvcHRpb25zXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgICogQHJldHVybiB7UmVjb2duaXplcn1cbiAgICAgICAqL1xuICAgICAgc2V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAvLyBhbHNvIHVwZGF0ZSB0aGUgdG91Y2hBY3Rpb24sIGluIGNhc2Ugc29tZXRoaW5nIGNoYW5nZWQgYWJvdXQgdGhlIGRpcmVjdGlvbnMvZW5hYmxlZCBzdGF0ZVxuICAgICAgICAgIHRoaXMubWFuYWdlciAmJiB0aGlzLm1hbmFnZXIudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyLlxuICAgICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICAgKi9cbiAgICAgIHJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZWNvZ25pemVXaXRoJywgdGhpcykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHNpbXVsdGFuZW91cyA9IHRoaXMuc2ltdWx0YW5lb3VzO1xuICAgICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgICBpZiAoIXNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdKSB7XG4gICAgICAgICAgICAgIHNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdID0gb3RoZXJSZWNvZ25pemVyO1xuICAgICAgICAgICAgICBvdGhlclJlY29nbml6ZXIucmVjb2duaXplV2l0aCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIGRyb3AgdGhlIHNpbXVsdGFuZW91cyBsaW5rLiBpdCBkb2VzbnQgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICAgKi9cbiAgICAgIGRyb3BSZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIHJlY29nbml6ZXIgY2FuIG9ubHkgcnVuIHdoZW4gYW4gb3RoZXIgaXMgZmFpbGluZ1xuICAgICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICAgKi9cbiAgICAgIHJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVxdWlyZUZhaWwgPSB0aGlzLnJlcXVpcmVGYWlsO1xuICAgICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgICBpZiAoaW5BcnJheShyZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgcmVxdWlyZUZhaWwucHVzaChvdGhlclJlY29nbml6ZXIpO1xuICAgICAgICAgICAgICBvdGhlclJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBkcm9wIHRoZSByZXF1aXJlRmFpbHVyZSBsaW5rLiBpdCBkb2VzIG5vdCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgICAqL1xuICAgICAgZHJvcFJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICAgIHZhciBpbmRleCA9IGluQXJyYXkodGhpcy5yZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKTtcbiAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICB0aGlzLnJlcXVpcmVGYWlsLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBoYXMgcmVxdWlyZSBmYWlsdXJlcyBib29sZWFuXG4gICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgaGFzUmVxdWlyZUZhaWx1cmVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGggPiAwO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBpZiB0aGUgcmVjb2duaXplciBjYW4gcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXJcbiAgICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgY2FuUmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgICAgcmV0dXJuICEhdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogWW91IHNob3VsZCB1c2UgYHRyeUVtaXRgIGluc3RlYWQgb2YgYGVtaXRgIGRpcmVjdGx5IHRvIGNoZWNrXG4gICAgICAgKiB0aGF0IGFsbCB0aGUgbmVlZGVkIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQgYmVmb3JlIGVtaXR0aW5nLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICAgKi9cbiAgICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgICBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgICAgICAgICAgIHNlbGYubWFuYWdlci5lbWl0KGV2ZW50LCBpbnB1dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gJ3BhbnN0YXJ0JyBhbmQgJ3Bhbm1vdmUnXG4gICAgICAgICAgaWYgKHN0YXRlIDwgU1RBVEVfRU5ERUQpIHtcbiAgICAgICAgICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyBzdGF0ZVN0cihzdGF0ZSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50KTsgLy8gc2ltcGxlICdldmVudE5hbWUnIGV2ZW50c1xuXG4gICAgICAgICAgaWYgKGlucHV0LmFkZGl0aW9uYWxFdmVudCkgeyAvLyBhZGRpdGlvbmFsIGV2ZW50KHBhbmxlZnQsIHBhbnJpZ2h0LCBwaW5jaGluLCBwaW5jaG91dC4uLilcbiAgICAgICAgICAgICAgZW1pdChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHBhbmVuZCBhbmQgcGFuY2FuY2VsXG4gICAgICAgICAgaWYgKHN0YXRlID49IFNUQVRFX0VOREVEKSB7XG4gICAgICAgICAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgc3RhdGVTdHIoc3RhdGUpKTtcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIENoZWNrIHRoYXQgYWxsIHRoZSByZXF1aXJlIGZhaWx1cmUgcmVjb2duaXplcnMgaGFzIGZhaWxlZCxcbiAgICAgICAqIGlmIHRydWUsIGl0IGVtaXRzIGEgZ2VzdHVyZSBldmVudCxcbiAgICAgICAqIG90aGVyd2lzZSwgc2V0dXAgdGhlIHN0YXRlIHRvIEZBSUxFRC5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAgICovXG4gICAgICB0cnlFbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgIGlmICh0aGlzLmNhbkVtaXQoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KGlucHV0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaXQncyBmYWlsaW5nIGFueXdheVxuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIGNhbiB3ZSBlbWl0P1xuICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIGNhbkVtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICB3aGlsZSAoaSA8IHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmICghKHRoaXMucmVxdWlyZUZhaWxbaV0uc3RhdGUgJiAoU1RBVEVfRkFJTEVEIHwgU1RBVEVfUE9TU0lCTEUpKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIHVwZGF0ZSB0aGUgcmVjb2duaXplclxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAgICovXG4gICAgICByZWNvZ25pemU6IGZ1bmN0aW9uKGlucHV0RGF0YSkge1xuICAgICAgICAgIC8vIG1ha2UgYSBuZXcgY29weSBvZiB0aGUgaW5wdXREYXRhXG4gICAgICAgICAgLy8gc28gd2UgY2FuIGNoYW5nZSB0aGUgaW5wdXREYXRhIHdpdGhvdXQgbWVzc2luZyB1cCB0aGUgb3RoZXIgcmVjb2duaXplcnNcbiAgICAgICAgICB2YXIgaW5wdXREYXRhQ2xvbmUgPSBhc3NpZ24oe30sIGlucHV0RGF0YSk7XG5cbiAgICAgICAgICAvLyBpcyBpcyBlbmFibGVkIGFuZCBhbGxvdyByZWNvZ25pemluZz9cbiAgICAgICAgICBpZiAoIWJvb2xPckZuKHRoaXMub3B0aW9ucy5lbmFibGUsIFt0aGlzLCBpbnB1dERhdGFDbG9uZV0pKSB7XG4gICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHJlc2V0IHdoZW4gd2UndmUgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfUkVDT0dOSVpFRCB8IFNUQVRFX0NBTkNFTExFRCB8IFNUQVRFX0ZBSUxFRCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnByb2Nlc3MoaW5wdXREYXRhQ2xvbmUpO1xuXG4gICAgICAgICAgLy8gdGhlIHJlY29nbml6ZXIgaGFzIHJlY29nbml6ZWQgYSBnZXN0dXJlXG4gICAgICAgICAgLy8gc28gdHJpZ2dlciBhbiBldmVudFxuICAgICAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEIHwgU1RBVEVfQ0FOQ0VMTEVEKSkge1xuICAgICAgICAgICAgICB0aGlzLnRyeUVtaXQoaW5wdXREYXRhQ2xvbmUpO1xuICAgICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogcmV0dXJuIHRoZSBzdGF0ZSBvZiB0aGUgcmVjb2duaXplclxuICAgICAgICogdGhlIGFjdHVhbCByZWNvZ25pemluZyBoYXBwZW5zIGluIHRoaXMgbWV0aG9kXG4gICAgICAgKiBAdmlydHVhbFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAgICogQHJldHVybnMge0NvbnN0fSBTVEFURVxuICAgICAgICovXG4gICAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dERhdGEpIHsgfSwgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICAgIC8qKlxuICAgICAgICogcmV0dXJuIHRoZSBwcmVmZXJyZWQgdG91Y2gtYWN0aW9uXG4gICAgICAgKiBAdmlydHVhbFxuICAgICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAgICovXG4gICAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7IH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogY2FsbGVkIHdoZW4gdGhlIGdlc3R1cmUgaXNuJ3QgYWxsb3dlZCB0byByZWNvZ25pemVcbiAgICAgICAqIGxpa2Ugd2hlbiBhbm90aGVyIGlzIGJlaW5nIHJlY29nbml6ZWQgb3IgaXQgaXMgZGlzYWJsZWRcbiAgICAgICAqIEB2aXJ0dWFsXG4gICAgICAgKi9cbiAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHsgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBnZXQgYSB1c2FibGUgc3RyaW5nLCB1c2VkIGFzIGV2ZW50IHBvc3RmaXhcbiAgICogQHBhcmFtIHtDb25zdH0gc3RhdGVcbiAgICogQHJldHVybnMge1N0cmluZ30gc3RhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHN0YXRlU3RyKHN0YXRlKSB7XG4gICAgICBpZiAoc3RhdGUgJiBTVEFURV9DQU5DRUxMRUQpIHtcbiAgICAgICAgICByZXR1cm4gJ2NhbmNlbCc7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfRU5ERUQpIHtcbiAgICAgICAgICByZXR1cm4gJ2VuZCc7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQ0hBTkdFRCkge1xuICAgICAgICAgIHJldHVybiAnbW92ZSc7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQkVHQU4pIHtcbiAgICAgICAgICByZXR1cm4gJ3N0YXJ0JztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8qKlxuICAgKiBkaXJlY3Rpb24gY29ucyB0byBzdHJpbmdcbiAgICogQHBhcmFtIHtDb25zdH0gZGlyZWN0aW9uXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiBkaXJlY3Rpb25TdHIoZGlyZWN0aW9uKSB7XG4gICAgICBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9ET1dOKSB7XG4gICAgICAgICAgcmV0dXJuICdkb3duJztcbiAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9VUCkge1xuICAgICAgICAgIHJldHVybiAndXAnO1xuICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0xFRlQpIHtcbiAgICAgICAgICByZXR1cm4gJ2xlZnQnO1xuICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX1JJR0hUKSB7XG4gICAgICAgICAgcmV0dXJuICdyaWdodCc7XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IGEgcmVjb2duaXplciBieSBuYW1lIGlmIGl0IGlzIGJvdW5kIHRvIGEgbWFuYWdlclxuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSBvdGhlclJlY29nbml6ZXJcbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHJlY29nbml6ZXIpIHtcbiAgICAgIHZhciBtYW5hZ2VyID0gcmVjb2duaXplci5tYW5hZ2VyO1xuICAgICAgaWYgKG1hbmFnZXIpIHtcbiAgICAgICAgICByZXR1cm4gbWFuYWdlci5nZXQob3RoZXJSZWNvZ25pemVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdGhlclJlY29nbml6ZXI7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyByZWNvZ25pemVyIGlzIGp1c3QgdXNlZCBhcyBhIGJhc2UgZm9yIHRoZSBzaW1wbGUgYXR0cmlidXRlIHJlY29nbml6ZXJzLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgUmVjb2duaXplclxuICAgKi9cbiAgZnVuY3Rpb24gQXR0clJlY29nbml6ZXIoKSB7XG4gICAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpbmhlcml0KEF0dHJSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgICAvKipcbiAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAgICovXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHBvaW50ZXJzOiAxXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gY2hlY2sgaWYgaXQgdGhlIHJlY29nbml6ZXIgcmVjZWl2ZXMgdmFsaWQgaW5wdXQsIGxpa2UgaW5wdXQuZGlzdGFuY2UgPiAxMC5cbiAgICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gcmVjb2duaXplZFxuICAgICAgICovXG4gICAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICB2YXIgb3B0aW9uUG9pbnRlcnMgPSB0aGlzLm9wdGlvbnMucG9pbnRlcnM7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvblBvaW50ZXJzID09PSAwIHx8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9uUG9pbnRlcnM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFByb2Nlc3MgdGhlIGlucHV0IGFuZCByZXR1cm4gdGhlIHN0YXRlIGZvciB0aGUgcmVjb2duaXplclxuICAgICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgICAqIEByZXR1cm5zIHsqfSBTdGF0ZVxuICAgICAgICovXG4gICAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGlucHV0LmV2ZW50VHlwZTtcblxuICAgICAgICAgIHZhciBpc1JlY29nbml6ZWQgPSBzdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQpO1xuICAgICAgICAgIHZhciBpc1ZhbGlkID0gdGhpcy5hdHRyVGVzdChpbnB1dCk7XG5cbiAgICAgICAgICAvLyBvbiBjYW5jZWwgaW5wdXQgYW5kIHdlJ3ZlIHJlY29nbml6ZWQgYmVmb3JlLCByZXR1cm4gU1RBVEVfQ0FOQ0VMTEVEXG4gICAgICAgICAgaWYgKGlzUmVjb2duaXplZCAmJiAoZXZlbnRUeXBlICYgSU5QVVRfQ0FOQ0VMIHx8ICFpc1ZhbGlkKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DQU5DRUxMRUQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1JlY29nbml6ZWQgfHwgaXNWYWxpZCkge1xuICAgICAgICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9FTkRFRDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghKHN0YXRlICYgU1RBVEVfQkVHQU4pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0hBTkdFRDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFBhblxuICAgKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBhbmQgbW92ZWQgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAgICovXG4gIGZ1bmN0aW9uIFBhblJlY29nbml6ZXIoKSB7XG4gICAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICB0aGlzLnBYID0gbnVsbDtcbiAgICAgIHRoaXMucFkgPSBudWxsO1xuICB9XG5cbiAgaW5oZXJpdChQYW5SZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgICAgLyoqXG4gICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgKiBAbWVtYmVyb2YgUGFuUmVjb2duaXplclxuICAgICAgICovXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAgIGV2ZW50OiAncGFuJyxcbiAgICAgICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0FMTFxuICAgICAgfSxcblxuICAgICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuICAgICAgICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1kpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICAgICAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1gpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYWN0aW9ucztcbiAgICAgIH0sXG5cbiAgICAgIGRpcmVjdGlvblRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgdmFyIGhhc01vdmVkID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBpbnB1dC5kaXN0YW5jZTtcbiAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gaW5wdXQuZGlyZWN0aW9uO1xuICAgICAgICAgIHZhciB4ID0gaW5wdXQuZGVsdGFYO1xuICAgICAgICAgIHZhciB5ID0gaW5wdXQuZGVsdGFZO1xuXG4gICAgICAgICAgLy8gbG9jayB0byBheGlzP1xuICAgICAgICAgIGlmICghKGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gKHggPT09IDApID8gRElSRUNUSU9OX05PTkUgOiAoeCA8IDApID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgICAgICAgICAgICAgICBoYXNNb3ZlZCA9IHggIT0gdGhpcy5wWDtcbiAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFYKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICh5ID09PSAwKSA/IERJUkVDVElPTl9OT05FIDogKHkgPCAwKSA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xuICAgICAgICAgICAgICAgICAgaGFzTW92ZWQgPSB5ICE9IHRoaXMucFk7XG4gICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICAgIHJldHVybiBoYXNNb3ZlZCAmJiBkaXN0YW5jZSA+IG9wdGlvbnMudGhyZXNob2xkICYmIGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uO1xuICAgICAgfSxcblxuICAgICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgcmV0dXJuIEF0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgICAodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOIHx8ICghKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTikgJiYgdGhpcy5kaXJlY3Rpb25UZXN0KGlucHV0KSkpO1xuICAgICAgfSxcblxuICAgICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcblxuICAgICAgICAgIHRoaXMucFggPSBpbnB1dC5kZWx0YVg7XG4gICAgICAgICAgdGhpcy5wWSA9IGlucHV0LmRlbHRhWTtcblxuICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQuZGlyZWN0aW9uKTtcblxuICAgICAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICAgICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUGluY2hcbiAgICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXJzIGFyZSBtb3ZpbmcgdG93YXJkICh6b29tLWluKSBvciBhd2F5IGZyb20gZWFjaCBvdGhlciAoem9vbS1vdXQpLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAgICovXG4gIGZ1bmN0aW9uIFBpbmNoUmVjb2duaXplcigpIHtcbiAgICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpbmhlcml0KFBpbmNoUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAgIC8qKlxuICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxuICAgICAgICovXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAgIGV2ZW50OiAncGluY2gnLFxuICAgICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgICBwb2ludGVyczogMlxuICAgICAgfSxcblxuICAgICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgICAgfSxcblxuICAgICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICAgIChNYXRoLmFicyhpbnB1dC5zY2FsZSAtIDEpID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICAgICAgfSxcblxuICAgICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgICAgdmFyIGluT3V0ID0gaW5wdXQuc2NhbGUgPCAxID8gJ2luJyA6ICdvdXQnO1xuICAgICAgICAgICAgICBpbnB1dC5hZGRpdGlvbmFsRXZlbnQgPSB0aGlzLm9wdGlvbnMuZXZlbnQgKyBpbk91dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fc3VwZXIuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbiAgICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFByZXNzXG4gICAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGZvciB4IG1zIHdpdGhvdXQgYW55IG1vdmVtZW50LlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgUmVjb2duaXplclxuICAgKi9cbiAgZnVuY3Rpb24gUHJlc3NSZWNvZ25pemVyKCkge1xuICAgICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG4gIH1cblxuICBpbmhlcml0KFByZXNzUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgICAgLyoqXG4gICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgKiBAbWVtYmVyb2YgUHJlc3NSZWNvZ25pemVyXG4gICAgICAgKi9cbiAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgICAgZXZlbnQ6ICdwcmVzcycsXG4gICAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgICAgdGltZTogMjUxLCAvLyBtaW5pbWFsIHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgcHJlc3NlZFxuICAgICAgICAgIHRocmVzaG9sZDogOSAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xuICAgICAgfSxcblxuICAgICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX0FVVE9dO1xuICAgICAgfSxcblxuICAgICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgICAgICAgdmFyIHZhbGlkVGltZSA9IGlucHV0LmRlbHRhVGltZSA+IG9wdGlvbnMudGltZTtcblxuICAgICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cbiAgICAgICAgICAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxuICAgICAgICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcbiAgICAgICAgICBpZiAoIXZhbGlkTW92ZW1lbnQgfHwgIXZhbGlkUG9pbnRlcnMgfHwgKGlucHV0LmV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmICF2YWxpZFRpbWUpKSB7XG4gICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSB7XG4gICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XG4gICAgICAgICAgICAgIH0sIG9wdGlvbnMudGltZSwgdGhpcyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgICB9LFxuXG4gICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICAgIH0sXG5cbiAgICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbnB1dCAmJiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSkge1xuICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyAndXAnLCBpbnB1dCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5faW5wdXQudGltZVN0YW1wID0gbm93KCk7XG4gICAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJvdGF0ZVxuICAgKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlciBhcmUgbW92aW5nIGluIGEgY2lyY3VsYXIgbW90aW9uLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAgICovXG4gIGZ1bmN0aW9uIFJvdGF0ZVJlY29nbml6ZXIoKSB7XG4gICAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaW5oZXJpdChSb3RhdGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgICAgLyoqXG4gICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgKiBAbWVtYmVyb2YgUm90YXRlUmVjb2duaXplclxuICAgICAgICovXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAgIGV2ZW50OiAncm90YXRlJyxcbiAgICAgICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICAgICAgcG9pbnRlcnM6IDJcbiAgICAgIH0sXG5cbiAgICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICAgIH0sXG5cbiAgICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgICAoTWF0aC5hYnMoaW5wdXQucm90YXRpb24pID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICAgICAgfVxuICB9KTtcblxuICAvKipcbiAgICogU3dpcGVcbiAgICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIG1vdmluZyBmYXN0ICh2ZWxvY2l0eSksIHdpdGggZW5vdWdoIGRpc3RhbmNlIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gICAqL1xuICBmdW5jdGlvbiBTd2lwZVJlY29nbml6ZXIoKSB7XG4gICAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaW5oZXJpdChTd2lwZVJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgICAvKipcbiAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAqIEBtZW1iZXJvZiBTd2lwZVJlY29nbml6ZXJcbiAgICAgICAqL1xuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICBldmVudDogJ3N3aXBlJyxcbiAgICAgICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgICAgIHZlbG9jaXR5OiAwLjMsXG4gICAgICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCxcbiAgICAgICAgICBwb2ludGVyczogMVxuICAgICAgfSxcblxuICAgICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBQYW5SZWNvZ25pemVyLnByb3RvdHlwZS5nZXRUb3VjaEFjdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgfSxcblxuICAgICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICAgICAgdmFyIHZlbG9jaXR5O1xuXG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiAmIChESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCkpIHtcbiAgICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVg7XG4gICAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcbiAgICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgICBkaXJlY3Rpb24gJiBpbnB1dC5vZmZzZXREaXJlY3Rpb24gJiZcbiAgICAgICAgICAgICAgaW5wdXQuZGlzdGFuY2UgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkICYmXG4gICAgICAgICAgICAgIGlucHV0Lm1heFBvaW50ZXJzID09IHRoaXMub3B0aW9ucy5wb2ludGVycyAmJlxuICAgICAgICAgICAgICBhYnModmVsb2NpdHkpID4gdGhpcy5vcHRpb25zLnZlbG9jaXR5ICYmIGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORDtcbiAgICAgIH0sXG5cbiAgICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5vZmZzZXREaXJlY3Rpb24pO1xuICAgICAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uLCBpbnB1dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCBpbnB1dCk7XG4gICAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBIHRhcCBpcyBlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb2luZyBhIHNtYWxsIHRhcC9jbGljay4gTXVsdGlwbGUgdGFwcyBhcmUgcmVjb2duaXplZCBpZiB0aGV5IG9jY3VyXG4gICAqIGJldHdlZW4gdGhlIGdpdmVuIGludGVydmFsIGFuZCBwb3NpdGlvbi4gVGhlIGRlbGF5IG9wdGlvbiBjYW4gYmUgdXNlZCB0byByZWNvZ25pemUgbXVsdGktdGFwcyB3aXRob3V0IGZpcmluZ1xuICAgKiBhIHNpbmdsZSB0YXAuXG4gICAqXG4gICAqIFRoZSBldmVudERhdGEgZnJvbSB0aGUgZW1pdHRlZCBldmVudCBjb250YWlucyB0aGUgcHJvcGVydHkgYHRhcENvdW50YCwgd2hpY2ggY29udGFpbnMgdGhlIGFtb3VudCBvZlxuICAgKiBtdWx0aS10YXBzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gICAqL1xuICBmdW5jdGlvbiBUYXBSZWNvZ25pemVyKCkge1xuICAgICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAvLyBwcmV2aW91cyB0aW1lIGFuZCBjZW50ZXIsXG4gICAgICAvLyB1c2VkIGZvciB0YXAgY291bnRpbmdcbiAgICAgIHRoaXMucFRpbWUgPSBmYWxzZTtcbiAgICAgIHRoaXMucENlbnRlciA9IGZhbHNlO1xuXG4gICAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG4gICAgICB0aGlzLmNvdW50ID0gMDtcbiAgfVxuXG4gIGluaGVyaXQoVGFwUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgICAgLyoqXG4gICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgKiBAbWVtYmVyb2YgUGluY2hSZWNvZ25pemVyXG4gICAgICAgKi9cbiAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgICAgZXZlbnQ6ICd0YXAnLFxuICAgICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICAgIHRhcHM6IDEsXG4gICAgICAgICAgaW50ZXJ2YWw6IDMwMCwgLy8gbWF4IHRpbWUgYmV0d2VlbiB0aGUgbXVsdGktdGFwIHRhcHNcbiAgICAgICAgICB0aW1lOiAyNTAsIC8vIG1heCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIGRvd24gKGxpa2UgZmluZ2VyIG9uIHRoZSBzY3JlZW4pXG4gICAgICAgICAgdGhyZXNob2xkOiA5LCAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xuICAgICAgICAgIHBvc1RocmVzaG9sZDogMTAgLy8gYSBtdWx0aS10YXAgY2FuIGJlIGEgYml0IG9mZiB0aGUgaW5pdGlhbCBwb3NpdGlvblxuICAgICAgfSxcblxuICAgICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTl07XG4gICAgICB9LFxuXG4gICAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgICAgICAgIHZhciB2YWxpZFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IG9wdGlvbnMudGltZTtcblxuICAgICAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgICAgIGlmICgoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpICYmICh0aGlzLmNvdW50ID09PSAwKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuICAgICAgICAgIGlmICh2YWxpZE1vdmVtZW50ICYmIHZhbGlkVG91Y2hUaW1lICYmIHZhbGlkUG9pbnRlcnMpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgdmFsaWRJbnRlcnZhbCA9IHRoaXMucFRpbWUgPyAoaW5wdXQudGltZVN0YW1wIC0gdGhpcy5wVGltZSA8IG9wdGlvbnMuaW50ZXJ2YWwpIDogdHJ1ZTtcbiAgICAgICAgICAgICAgdmFyIHZhbGlkTXVsdGlUYXAgPSAhdGhpcy5wQ2VudGVyIHx8IGdldERpc3RhbmNlKHRoaXMucENlbnRlciwgaW5wdXQuY2VudGVyKSA8IG9wdGlvbnMucG9zVGhyZXNob2xkO1xuXG4gICAgICAgICAgICAgIHRoaXMucFRpbWUgPSBpbnB1dC50aW1lU3RhbXA7XG4gICAgICAgICAgICAgIHRoaXMucENlbnRlciA9IGlucHV0LmNlbnRlcjtcblxuICAgICAgICAgICAgICBpZiAoIXZhbGlkTXVsdGlUYXAgfHwgIXZhbGlkSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuY291bnQgPSAxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudCArPSAxO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcblxuICAgICAgICAgICAgICAvLyBpZiB0YXAgY291bnQgbWF0Y2hlcyB3ZSBoYXZlIHJlY29nbml6ZWQgaXQsXG4gICAgICAgICAgICAgIC8vIGVsc2UgaXQgaGFzIGJlZ2FuIHJlY29nbml6aW5nLi4uXG4gICAgICAgICAgICAgIHZhciB0YXBDb3VudCA9IHRoaXMuY291bnQgJSBvcHRpb25zLnRhcHM7XG4gICAgICAgICAgICAgIGlmICh0YXBDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgLy8gbm8gZmFpbGluZyByZXF1aXJlbWVudHMsIGltbWVkaWF0ZWx5IHRyaWdnZXIgdGhlIHRhcCBldmVudFxuICAgICAgICAgICAgICAgICAgLy8gb3Igd2FpdCBhcyBsb25nIGFzIHRoZSBtdWx0aXRhcCBpbnRlcnZhbCB0byB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzUmVxdWlyZUZhaWx1cmVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJ5RW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMuaW50ZXJ2YWwsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgICAgfSxcblxuICAgICAgZmFpbFRpbWVvdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICAgICAgfSwgdGhpcy5vcHRpb25zLmludGVydmFsLCB0aGlzKTtcbiAgICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgICAgfSxcblxuICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgICB9LFxuXG4gICAgICBlbWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2lucHV0LnRhcENvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9KTtcblxuICAvKipcbiAgICogU2ltcGxlIHdheSB0byBjcmVhdGUgYSBtYW5hZ2VyIHdpdGggYSBkZWZhdWx0IHNldCBvZiByZWNvZ25pemVycy5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gSGFtbWVyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgb3B0aW9ucy5yZWNvZ25pemVycyA9IGlmVW5kZWZpbmVkKG9wdGlvbnMucmVjb2duaXplcnMsIEhhbW1lci5kZWZhdWx0cy5wcmVzZXQpO1xuICAgICAgcmV0dXJuIG5ldyBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBjb25zdCB7c3RyaW5nfVxuICAgKi9cbiAgSGFtbWVyLlZFUlNJT04gPSAnMi4wLjcnO1xuXG4gIC8qKlxuICAgKiBkZWZhdWx0IHNldHRpbmdzXG4gICAqIEBuYW1lc3BhY2VcbiAgICovXG4gIEhhbW1lci5kZWZhdWx0cyA9IHtcbiAgICAgIC8qKlxuICAgICAgICogc2V0IGlmIERPTSBldmVudHMgYXJlIGJlaW5nIHRyaWdnZXJlZC5cbiAgICAgICAqIEJ1dCB0aGlzIGlzIHNsb3dlciBhbmQgdW51c2VkIGJ5IHNpbXBsZSBpbXBsZW1lbnRhdGlvbnMsIHNvIGRpc2FibGVkIGJ5IGRlZmF1bHQuXG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgKi9cbiAgICAgIGRvbUV2ZW50czogZmFsc2UsXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkvZmFsbGJhY2suXG4gICAgICAgKiBXaGVuIHNldCB0byBgY29tcHV0ZWAgaXQgd2lsbCBtYWdpY2FsbHkgc2V0IHRoZSBjb3JyZWN0IHZhbHVlIGJhc2VkIG9uIHRoZSBhZGRlZCByZWNvZ25pemVycy5cbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKiBAZGVmYXVsdCBjb21wdXRlXG4gICAgICAgKi9cbiAgICAgIHRvdWNoQWN0aW9uOiBUT1VDSF9BQ1RJT05fQ09NUFVURSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAqL1xuICAgICAgZW5hYmxlOiB0cnVlLFxuXG4gICAgICAvKipcbiAgICAgICAqIEVYUEVSSU1FTlRBTCBGRUFUVVJFIC0tIGNhbiBiZSByZW1vdmVkL2NoYW5nZWRcbiAgICAgICAqIENoYW5nZSB0aGUgcGFyZW50IGlucHV0IHRhcmdldCBlbGVtZW50LlxuICAgICAgICogSWYgTnVsbCwgdGhlbiBpdCBpcyBiZWluZyBzZXQgdGhlIHRvIG1haW4gZWxlbWVudC5cbiAgICAgICAqIEB0eXBlIHtOdWxsfEV2ZW50VGFyZ2V0fVxuICAgICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAgICovXG4gICAgICBpbnB1dFRhcmdldDogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiBmb3JjZSBhbiBpbnB1dCBjbGFzc1xuICAgICAgICogQHR5cGUge051bGx8RnVuY3Rpb259XG4gICAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICAgKi9cbiAgICAgIGlucHV0Q2xhc3M6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICogRGVmYXVsdCByZWNvZ25pemVyIHNldHVwIHdoZW4gY2FsbGluZyBgSGFtbWVyKClgXG4gICAgICAgKiBXaGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIgdGhlc2Ugd2lsbCBiZSBza2lwcGVkLlxuICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICovXG4gICAgICBwcmVzZXQ6IFtcbiAgICAgICAgICAvLyBSZWNvZ25pemVyQ2xhc3MsIG9wdGlvbnMsIFtyZWNvZ25pemVXaXRoLCAuLi5dLCBbcmVxdWlyZUZhaWx1cmUsIC4uLl1cbiAgICAgICAgICBbUm90YXRlUmVjb2duaXplciwge2VuYWJsZTogZmFsc2V9XSxcbiAgICAgICAgICBbUGluY2hSZWNvZ25pemVyLCB7ZW5hYmxlOiBmYWxzZX0sIFsncm90YXRlJ11dLFxuICAgICAgICAgIFtTd2lwZVJlY29nbml6ZXIsIHtkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMfV0sXG4gICAgICAgICAgW1BhblJlY29nbml6ZXIsIHtkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMfSwgWydzd2lwZSddXSxcbiAgICAgICAgICBbVGFwUmVjb2duaXplcl0sXG4gICAgICAgICAgW1RhcFJlY29nbml6ZXIsIHtldmVudDogJ2RvdWJsZXRhcCcsIHRhcHM6IDJ9LCBbJ3RhcCddXSxcbiAgICAgICAgICBbUHJlc3NSZWNvZ25pemVyXVxuICAgICAgXSxcblxuICAgICAgLyoqXG4gICAgICAgKiBTb21lIENTUyBwcm9wZXJ0aWVzIGNhbiBiZSB1c2VkIHRvIGltcHJvdmUgdGhlIHdvcmtpbmcgb2YgSGFtbWVyLlxuICAgICAgICogQWRkIHRoZW0gdG8gdGhpcyBtZXRob2QgYW5kIHRoZXkgd2lsbCBiZSBzZXQgd2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyLlxuICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICovXG4gICAgICBjc3NQcm9wczoge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIERpc2FibGVzIHRleHQgc2VsZWN0aW9uIHRvIGltcHJvdmUgdGhlIGRyYWdnaW5nIGdlc3R1cmUuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgICAqL1xuICAgICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIERpc2FibGUgdGhlIFdpbmRvd3MgUGhvbmUgZ3JpcHBlcnMgd2hlbiBwcmVzc2luZyBhbiBlbGVtZW50LlxuICAgICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAgICovXG4gICAgICAgICAgdG91Y2hTZWxlY3Q6ICdub25lJyxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIERpc2FibGVzIHRoZSBkZWZhdWx0IGNhbGxvdXQgc2hvd24gd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQuXG4gICAgICAgICAgICogT24gaU9TLCB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldCBzdWNoIGFzIGEgbGluaywgU2FmYXJpIGRpc3BsYXlzXG4gICAgICAgICAgICogYSBjYWxsb3V0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxpbmsuIFRoaXMgcHJvcGVydHkgYWxsb3dzIHlvdSB0byBkaXNhYmxlIHRoYXQgY2FsbG91dC5cbiAgICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgICAqL1xuICAgICAgICAgIHRvdWNoQ2FsbG91dDogJ25vbmUnLFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogU3BlY2lmaWVzIHdoZXRoZXIgem9vbWluZyBpcyBlbmFibGVkLiBVc2VkIGJ5IElFMTA+XG4gICAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBjb250ZW50Wm9vbWluZzogJ25vbmUnLFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogU3BlY2lmaWVzIHRoYXQgYW4gZW50aXJlIGVsZW1lbnQgc2hvdWxkIGJlIGRyYWdnYWJsZSBpbnN0ZWFkIG9mIGl0cyBjb250ZW50cy4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAgICovXG4gICAgICAgICAgdXNlckRyYWc6ICdub25lJyxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIE92ZXJyaWRlcyB0aGUgaGlnaGxpZ2h0IGNvbG9yIHNob3duIHdoZW4gdGhlIHVzZXIgdGFwcyBhIGxpbmsgb3IgYSBKYXZhU2NyaXB0XG4gICAgICAgICAgICogY2xpY2thYmxlIGVsZW1lbnQgaW4gaU9TLiBUaGlzIHByb3BlcnR5IG9iZXlzIHRoZSBhbHBoYSB2YWx1ZSwgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAgICogQGRlZmF1bHQgJ3JnYmEoMCwwLDAsMCknXG4gICAgICAgICAgICovXG4gICAgICAgICAgdGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsMCwwLDApJ1xuICAgICAgfVxuICB9O1xuXG4gIHZhciBTVE9QID0gMTtcbiAgdmFyIEZPUkNFRF9TVE9QID0gMjtcblxuICAvKipcbiAgICogTWFuYWdlclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgSGFtbWVyLmRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcblxuICAgICAgdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0ID0gdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0IHx8IGVsZW1lbnQ7XG5cbiAgICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgICAgdGhpcy5yZWNvZ25pemVycyA9IFtdO1xuICAgICAgdGhpcy5vbGRDc3NQcm9wcyA9IHt9O1xuXG4gICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5pbnB1dCA9IGNyZWF0ZUlucHV0SW5zdGFuY2UodGhpcyk7XG4gICAgICB0aGlzLnRvdWNoQWN0aW9uID0gbmV3IFRvdWNoQWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucy50b3VjaEFjdGlvbik7XG5cbiAgICAgIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIHRydWUpO1xuXG4gICAgICBlYWNoKHRoaXMub3B0aW9ucy5yZWNvZ25pemVycywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgIHZhciByZWNvZ25pemVyID0gdGhpcy5hZGQobmV3IChpdGVtWzBdKShpdGVtWzFdKSk7XG4gICAgICAgICAgaXRlbVsyXSAmJiByZWNvZ25pemVyLnJlY29nbml6ZVdpdGgoaXRlbVsyXSk7XG4gICAgICAgICAgaXRlbVszXSAmJiByZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKGl0ZW1bM10pO1xuICAgICAgfSwgdGhpcyk7XG4gIH1cblxuICBNYW5hZ2VyLnByb3RvdHlwZSA9IHtcbiAgICAgIC8qKlxuICAgICAgICogc2V0IG9wdGlvbnNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cbiAgICAgICAqL1xuICAgICAgc2V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAvLyBPcHRpb25zIHRoYXQgbmVlZCBhIGxpdHRsZSBtb3JlIHNldHVwXG4gICAgICAgICAgaWYgKG9wdGlvbnMudG91Y2hBY3Rpb24pIHtcbiAgICAgICAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMuaW5wdXRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgZXhpc3RpbmcgZXZlbnQgbGlzdGVuZXJzIGFuZCByZWluaXRpYWxpemVcbiAgICAgICAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgIHRoaXMuaW5wdXQudGFyZ2V0ID0gb3B0aW9ucy5pbnB1dFRhcmdldDtcbiAgICAgICAgICAgICAgdGhpcy5pbnB1dC5pbml0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBzdG9wIHJlY29nbml6aW5nIGZvciB0aGlzIHNlc3Npb24uXG4gICAgICAgKiBUaGlzIHNlc3Npb24gd2lsbCBiZSBkaXNjYXJkZWQsIHdoZW4gYSBuZXcgW2lucHV0XXN0YXJ0IGV2ZW50IGlzIGZpcmVkLlxuICAgICAgICogV2hlbiBmb3JjZWQsIHRoZSByZWNvZ25pemVyIGN5Y2xlIGlzIHN0b3BwZWQgaW1tZWRpYXRlbHkuXG4gICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZV1cbiAgICAgICAqL1xuICAgICAgc3RvcDogZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgICAgICB0aGlzLnNlc3Npb24uc3RvcHBlZCA9IGZvcmNlID8gRk9SQ0VEX1NUT1AgOiBTVE9QO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBydW4gdGhlIHJlY29nbml6ZXJzIVxuICAgICAgICogY2FsbGVkIGJ5IHRoZSBpbnB1dEhhbmRsZXIgZnVuY3Rpb24gb24gZXZlcnkgbW92ZW1lbnQgb2YgdGhlIHBvaW50ZXJzICh0b3VjaGVzKVxuICAgICAgICogaXQgd2Fsa3MgdGhyb3VnaCBhbGwgdGhlIHJlY29nbml6ZXJzIGFuZCB0cmllcyB0byBkZXRlY3QgdGhlIGdlc3R1cmUgdGhhdCBpcyBiZWluZyBtYWRlXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICAgKi9cbiAgICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XG4gICAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcnVuIHRoZSB0b3VjaC1hY3Rpb24gcG9seWZpbGxcbiAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnByZXZlbnREZWZhdWx0cyhpbnB1dERhdGEpO1xuXG4gICAgICAgICAgdmFyIHJlY29nbml6ZXI7XG4gICAgICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcblxuICAgICAgICAgIC8vIHRoaXMgaG9sZHMgdGhlIHJlY29nbml6ZXIgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgICAgIC8vIHNvIHRoZSByZWNvZ25pemVyJ3Mgc3RhdGUgbmVlZHMgdG8gYmUgQkVHQU4sIENIQU5HRUQsIEVOREVEIG9yIFJFQ09HTklaRURcbiAgICAgICAgICAvLyBpZiBubyByZWNvZ25pemVyIGlzIGRldGVjdGluZyBhIHRoaW5nLCBpdCBpcyBzZXQgdG8gYG51bGxgXG4gICAgICAgICAgdmFyIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXI7XG5cbiAgICAgICAgICAvLyByZXNldCB3aGVuIHRoZSBsYXN0IHJlY29nbml6ZXIgaXMgcmVjb2duaXplZFxuICAgICAgICAgIC8vIG9yIHdoZW4gd2UncmUgaW4gYSBuZXcgc2Vzc2lvblxuICAgICAgICAgIGlmICghY3VyUmVjb2duaXplciB8fCAoY3VyUmVjb2duaXplciAmJiBjdXJSZWNvZ25pemVyLnN0YXRlICYgU1RBVEVfUkVDT0dOSVpFRCkpIHtcbiAgICAgICAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgIHdoaWxlIChpIDwgcmVjb2duaXplcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlY29nbml6ZXIgPSByZWNvZ25pemVyc1tpXTtcblxuICAgICAgICAgICAgICAvLyBmaW5kIG91dCBpZiB3ZSBhcmUgYWxsb3dlZCB0cnkgdG8gcmVjb2duaXplIHRoZSBpbnB1dCBmb3IgdGhpcyBvbmUuXG4gICAgICAgICAgICAgIC8vIDEuICAgYWxsb3cgaWYgdGhlIHNlc3Npb24gaXMgTk9UIGZvcmNlZCBzdG9wcGVkIChzZWUgdGhlIC5zdG9wKCkgbWV0aG9kKVxuICAgICAgICAgICAgICAvLyAyLiAgIGFsbG93IGlmIHdlIHN0aWxsIGhhdmVuJ3QgcmVjb2duaXplZCBhIGdlc3R1cmUgaW4gdGhpcyBzZXNzaW9uLCBvciB0aGUgdGhpcyByZWNvZ25pemVyIGlzIHRoZSBvbmVcbiAgICAgICAgICAgICAgLy8gICAgICB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAgICAgICAgICAgIC8vIDMuICAgYWxsb3cgaWYgdGhlIHJlY29nbml6ZXIgaXMgYWxsb3dlZCB0byBydW4gc2ltdWx0YW5lb3VzIHdpdGggdGhlIGN1cnJlbnQgcmVjb2duaXplZCByZWNvZ25pemVyLlxuICAgICAgICAgICAgICAvLyAgICAgIHRoaXMgY2FuIGJlIHNldHVwIHdpdGggdGhlIGByZWNvZ25pemVXaXRoKClgIG1ldGhvZCBvbiB0aGUgcmVjb2duaXplci5cbiAgICAgICAgICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCAhPT0gRk9SQ0VEX1NUT1AgJiYgKCAvLyAxXG4gICAgICAgICAgICAgICAgICAgICAgIWN1clJlY29nbml6ZXIgfHwgcmVjb2duaXplciA9PSBjdXJSZWNvZ25pemVyIHx8IC8vIDJcbiAgICAgICAgICAgICAgICAgICAgICByZWNvZ25pemVyLmNhblJlY29nbml6ZVdpdGgoY3VyUmVjb2duaXplcikpKSB7IC8vIDNcbiAgICAgICAgICAgICAgICAgIHJlY29nbml6ZXIucmVjb2duaXplKGlucHV0RGF0YSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZWNvZ25pemVyLnJlc2V0KCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBpZiB0aGUgcmVjb2duaXplciBoYXMgYmVlbiByZWNvZ25pemluZyB0aGUgaW5wdXQgYXMgYSB2YWxpZCBnZXN0dXJlLCB3ZSB3YW50IHRvIHN0b3JlIHRoaXMgb25lIGFzIHRoZVxuICAgICAgICAgICAgICAvLyBjdXJyZW50IGFjdGl2ZSByZWNvZ25pemVyLiBidXQgb25seSBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYW4gYWN0aXZlIHJlY29nbml6ZXJcbiAgICAgICAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyICYmIHJlY29nbml6ZXIuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQpKSB7XG4gICAgICAgICAgICAgICAgICBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gcmVjb2duaXplcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBnZXQgYSByZWNvZ25pemVyIGJ5IGl0cyBldmVudCBuYW1lLlxuICAgICAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TnVsbH1cbiAgICAgICAqL1xuICAgICAgZ2V0OiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgICAgaWYgKHJlY29nbml6ZXIgaW5zdGFuY2VvZiBSZWNvZ25pemVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWNvZ25pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAocmVjb2duaXplcnNbaV0ub3B0aW9ucy5ldmVudCA9PSByZWNvZ25pemVyKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVjb2duaXplcnNbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIGFkZCBhIHJlY29nbml6ZXIgdG8gdGhlIG1hbmFnZXJcbiAgICAgICAqIGV4aXN0aW5nIHJlY29nbml6ZXJzIHdpdGggdGhlIHNhbWUgZXZlbnQgbmFtZSB3aWxsIGJlIHJlbW92ZWRcbiAgICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICAgICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TWFuYWdlcn1cbiAgICAgICAqL1xuICAgICAgYWRkOiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdhZGQnLCB0aGlzKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyByZW1vdmUgZXhpc3RpbmdcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB0aGlzLmdldChyZWNvZ25pemVyLm9wdGlvbnMuZXZlbnQpO1xuICAgICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgICB0aGlzLnJlbW92ZShleGlzdGluZyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5yZWNvZ25pemVycy5wdXNoKHJlY29nbml6ZXIpO1xuICAgICAgICAgIHJlY29nbml6ZXIubWFuYWdlciA9IHRoaXM7XG5cbiAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiByZW1vdmUgYSByZWNvZ25pemVyIGJ5IG5hbWUgb3IgaW5zdGFuY2VcbiAgICAgICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcbiAgICAgICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgICAgICovXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgJ3JlbW92ZScsIHRoaXMpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlY29nbml6ZXIgPSB0aGlzLmdldChyZWNvZ25pemVyKTtcblxuICAgICAgICAgIC8vIGxldCdzIG1ha2Ugc3VyZSB0aGlzIHJlY29nbml6ZXIgZXhpc3RzXG4gICAgICAgICAgaWYgKHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gaW5BcnJheShyZWNvZ25pemVycywgcmVjb2duaXplcik7XG5cbiAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgcmVjb2duaXplcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogYmluZCBldmVudFxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgICAgICovXG4gICAgICBvbjogZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICAgICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XSA9IGhhbmRsZXJzW2V2ZW50XSB8fCBbXTtcbiAgICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdLnB1c2goaGFuZGxlcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIHVuYmluZCBldmVudCwgbGVhdmUgZW1pdCBibGFuayB0byByZW1vdmUgYWxsIGhhbmRsZXJzXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl1cbiAgICAgICAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcbiAgICAgICAqL1xuICAgICAgb2ZmOiBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICAgICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBoYW5kbGVyc1tldmVudF07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gJiYgaGFuZGxlcnNbZXZlbnRdLnNwbGljZShpbkFycmF5KGhhbmRsZXJzW2V2ZW50XSwgaGFuZGxlciksIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIGVtaXQgZXZlbnQgdG8gdGhlIGxpc3RlbmVyc1xuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAgICovXG4gICAgICBlbWl0OiBmdW5jdGlvbihldmVudCwgZGF0YSkge1xuICAgICAgICAgIC8vIHdlIGFsc28gd2FudCB0byB0cmlnZ2VyIGRvbSBldmVudHNcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRvbUV2ZW50cykge1xuICAgICAgICAgICAgICB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIG5vIGhhbmRsZXJzLCBzbyBza2lwIGl0IGFsbFxuICAgICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbZXZlbnRdICYmIHRoaXMuaGFuZGxlcnNbZXZlbnRdLnNsaWNlKCk7XG4gICAgICAgICAgaWYgKCFoYW5kbGVycyB8fCAhaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXRhLnR5cGUgPSBldmVudDtcbiAgICAgICAgICBkYXRhLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGRhdGEuc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgIHdoaWxlIChpIDwgaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGhhbmRsZXJzW2ldKGRhdGEpO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBkZXN0cm95IHRoZSBtYW5hZ2VyIGFuZCB1bmJpbmRzIGFsbCBldmVudHNcbiAgICAgICAqIGl0IGRvZXNuJ3QgdW5iaW5kIGRvbSBldmVudHMsIHRoYXQgaXMgdGhlIHVzZXIgb3duIHJlc3BvbnNpYmlsaXR5XG4gICAgICAgKi9cbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuZWxlbWVudCAmJiB0b2dnbGVDc3NQcm9wcyh0aGlzLCBmYWxzZSk7XG5cbiAgICAgICAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgICAgICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogYWRkL3JlbW92ZSB0aGUgY3NzIHByb3BlcnRpZXMgYXMgZGVmaW5lZCBpbiBtYW5hZ2VyLm9wdGlvbnMuY3NzUHJvcHNcbiAgICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWRkXG4gICAqL1xuICBmdW5jdGlvbiB0b2dnbGVDc3NQcm9wcyhtYW5hZ2VyLCBhZGQpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuICAgICAgaWYgKCFlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHByb3A7XG4gICAgICBlYWNoKG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wcywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICBwcm9wID0gcHJlZml4ZWQoZWxlbWVudC5zdHlsZSwgbmFtZSk7XG4gICAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgICBtYW5hZ2VyLm9sZENzc1Byb3BzW3Byb3BdID0gZWxlbWVudC5zdHlsZVtwcm9wXTtcbiAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBtYW5hZ2VyLm9sZENzc1Byb3BzW3Byb3BdIHx8ICcnO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFhZGQpIHtcbiAgICAgICAgICBtYW5hZ2VyLm9sZENzc1Byb3BzID0ge307XG4gICAgICB9XG4gIH1cblxuICAvKipcbiAgICogdHJpZ2dlciBkb20gZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqL1xuICBmdW5jdGlvbiB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBnZXN0dXJlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGdlc3R1cmVFdmVudC5pbml0RXZlbnQoZXZlbnQsIHRydWUsIHRydWUpO1xuICAgICAgZ2VzdHVyZUV2ZW50Lmdlc3R1cmUgPSBkYXRhO1xuICAgICAgZGF0YS50YXJnZXQuZGlzcGF0Y2hFdmVudChnZXN0dXJlRXZlbnQpO1xuICB9XG5cbiAgYXNzaWduKEhhbW1lciwge1xuICAgICAgSU5QVVRfU1RBUlQ6IElOUFVUX1NUQVJULFxuICAgICAgSU5QVVRfTU9WRTogSU5QVVRfTU9WRSxcbiAgICAgIElOUFVUX0VORDogSU5QVVRfRU5ELFxuICAgICAgSU5QVVRfQ0FOQ0VMOiBJTlBVVF9DQU5DRUwsXG5cbiAgICAgIFNUQVRFX1BPU1NJQkxFOiBTVEFURV9QT1NTSUJMRSxcbiAgICAgIFNUQVRFX0JFR0FOOiBTVEFURV9CRUdBTixcbiAgICAgIFNUQVRFX0NIQU5HRUQ6IFNUQVRFX0NIQU5HRUQsXG4gICAgICBTVEFURV9FTkRFRDogU1RBVEVfRU5ERUQsXG4gICAgICBTVEFURV9SRUNPR05JWkVEOiBTVEFURV9SRUNPR05JWkVELFxuICAgICAgU1RBVEVfQ0FOQ0VMTEVEOiBTVEFURV9DQU5DRUxMRUQsXG4gICAgICBTVEFURV9GQUlMRUQ6IFNUQVRFX0ZBSUxFRCxcblxuICAgICAgRElSRUNUSU9OX05PTkU6IERJUkVDVElPTl9OT05FLFxuICAgICAgRElSRUNUSU9OX0xFRlQ6IERJUkVDVElPTl9MRUZULFxuICAgICAgRElSRUNUSU9OX1JJR0hUOiBESVJFQ1RJT05fUklHSFQsXG4gICAgICBESVJFQ1RJT05fVVA6IERJUkVDVElPTl9VUCxcbiAgICAgIERJUkVDVElPTl9ET1dOOiBESVJFQ1RJT05fRE9XTixcbiAgICAgIERJUkVDVElPTl9IT1JJWk9OVEFMOiBESVJFQ1RJT05fSE9SSVpPTlRBTCxcbiAgICAgIERJUkVDVElPTl9WRVJUSUNBTDogRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgICAgRElSRUNUSU9OX0FMTDogRElSRUNUSU9OX0FMTCxcblxuICAgICAgTWFuYWdlcjogTWFuYWdlcixcbiAgICAgIElucHV0OiBJbnB1dCxcbiAgICAgIFRvdWNoQWN0aW9uOiBUb3VjaEFjdGlvbixcblxuICAgICAgVG91Y2hJbnB1dDogVG91Y2hJbnB1dCxcbiAgICAgIE1vdXNlSW5wdXQ6IE1vdXNlSW5wdXQsXG4gICAgICBQb2ludGVyRXZlbnRJbnB1dDogUG9pbnRlckV2ZW50SW5wdXQsXG4gICAgICBUb3VjaE1vdXNlSW5wdXQ6IFRvdWNoTW91c2VJbnB1dCxcbiAgICAgIFNpbmdsZVRvdWNoSW5wdXQ6IFNpbmdsZVRvdWNoSW5wdXQsXG5cbiAgICAgIFJlY29nbml6ZXI6IFJlY29nbml6ZXIsXG4gICAgICBBdHRyUmVjb2duaXplcjogQXR0clJlY29nbml6ZXIsXG4gICAgICBUYXA6IFRhcFJlY29nbml6ZXIsXG4gICAgICBQYW46IFBhblJlY29nbml6ZXIsXG4gICAgICBTd2lwZTogU3dpcGVSZWNvZ25pemVyLFxuICAgICAgUGluY2g6IFBpbmNoUmVjb2duaXplcixcbiAgICAgIFJvdGF0ZTogUm90YXRlUmVjb2duaXplcixcbiAgICAgIFByZXNzOiBQcmVzc1JlY29nbml6ZXIsXG5cbiAgICAgIG9uOiBhZGRFdmVudExpc3RlbmVycyxcbiAgICAgIG9mZjogcmVtb3ZlRXZlbnRMaXN0ZW5lcnMsXG4gICAgICBlYWNoOiBlYWNoLFxuICAgICAgbWVyZ2U6IG1lcmdlLFxuICAgICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgICBhc3NpZ246IGFzc2lnbixcbiAgICAgIGluaGVyaXQ6IGluaGVyaXQsXG4gICAgICBiaW5kRm46IGJpbmRGbixcbiAgICAgIHByZWZpeGVkOiBwcmVmaXhlZFxuICB9KTtcblxuICAvLyB0aGlzIHByZXZlbnRzIGVycm9ycyB3aGVuIEhhbW1lciBpcyBsb2FkZWQgaW4gdGhlIHByZXNlbmNlIG9mIGFuIEFNRFxuICAvLyAgc3R5bGUgbG9hZGVyIGJ1dCBieSBzY3JpcHQgdGFnLCBub3QgYnkgdGhlIGxvYWRlci5cbiAgdmFyIGZyZWVHbG9iYWwgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9KSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICBmcmVlR2xvYmFsLkhhbW1lciA9IEhhbW1lcjtcblxuICBpZiAodHJ1ZSkge1xuICAgICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBIYW1tZXI7XG4gICAgICB9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gSGFtbWVyO1xuICB9IGVsc2Uge1xuICAgICAgd2luZG93W2V4cG9ydE5hbWVdID0gSGFtbWVyO1xuICB9XG5cbiAgfSkod2luZG93LCBkb2N1bWVudCwgJ0hhbW1lcicpO1xuXG5cbi8qKiovIH0sXG4vKiAyNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgdmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XCJ1c2Ugc3RyaWN0XCI7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlZCBieSBBbGV4IG9uIDExLzYvMjAxNC5cclxuICAgKi9cclxuXHJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3VtZGpzL3VtZC9ibG9iL21hc3Rlci9yZXR1cm5FeHBvcnRzLmpzI0w0MC1MNjBcclxuICAvLyBpZiB0aGUgbW9kdWxlIGhhcyBubyBkZXBlbmRlbmNpZXMsIHRoZSBhYm92ZSBwYXR0ZXJuIGNhbiBiZSBzaW1wbGlmaWVkIHRvXHJcbiAgKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XHJcbiAgICBpZiAodHJ1ZSkge1xyXG4gICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXHJcbiAgICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgPyAoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxyXG4gICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcclxuICAgICAgLy8gbGlrZSBOb2RlLlxyXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXHJcbiAgICAgIHJvb3Qua2V5Y2hhcm0gPSBmYWN0b3J5KCk7XHJcbiAgICB9XHJcbiAgfSh0aGlzLCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgZnVuY3Rpb24ga2V5Y2hhcm0ob3B0aW9ucykge1xyXG4gICAgICB2YXIgcHJldmVudERlZmF1bHQgPSBvcHRpb25zICYmIG9wdGlvbnMucHJldmVudERlZmF1bHQgfHwgZmFsc2U7XHJcblxyXG4gICAgICB2YXIgY29udGFpbmVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbnRhaW5lciB8fCB3aW5kb3c7XHJcblxyXG4gICAgICB2YXIgX2V4cG9ydEZ1bmN0aW9ucyA9IHt9O1xyXG4gICAgICB2YXIgX2JvdW5kID0ge2tleWRvd246e30sIGtleXVwOnt9fTtcclxuICAgICAgdmFyIF9rZXlzID0ge307XHJcbiAgICAgIHZhciBpO1xyXG5cclxuICAgICAgLy8gYSAtIHpcclxuICAgICAgZm9yIChpID0gOTc7IGkgPD0gMTIyOyBpKyspIHtfa2V5c1tTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IHtjb2RlOjY1ICsgKGkgLSA5NyksIHNoaWZ0OiBmYWxzZX07fVxyXG4gICAgICAvLyBBIC0gWlxyXG4gICAgICBmb3IgKGkgPSA2NTsgaSA8PSA5MDsgaSsrKSB7X2tleXNbU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSB7Y29kZTppLCBzaGlmdDogdHJ1ZX07fVxyXG4gICAgICAvLyAwIC0gOVxyXG4gICAgICBmb3IgKGkgPSAwOyAgaSA8PSA5OyAgIGkrKykge19rZXlzWycnICsgaV0gPSB7Y29kZTo0OCArIGksIHNoaWZ0OiBmYWxzZX07fVxyXG4gICAgICAvLyBGMSAtIEYxMlxyXG4gICAgICBmb3IgKGkgPSAxOyAgaSA8PSAxMjsgICBpKyspIHtfa2V5c1snRicgKyBpXSA9IHtjb2RlOjExMSArIGksIHNoaWZ0OiBmYWxzZX07fVxyXG4gICAgICAvLyBudW0wIC0gbnVtOVxyXG4gICAgICBmb3IgKGkgPSAwOyAgaSA8PSA5OyAgIGkrKykge19rZXlzWydudW0nICsgaV0gPSB7Y29kZTo5NiArIGksIHNoaWZ0OiBmYWxzZX07fVxyXG5cclxuICAgICAgLy8gbnVtcGFkIG1pc2NcclxuICAgICAgX2tleXNbJ251bSonXSA9IHtjb2RlOjEwNiwgc2hpZnQ6IGZhbHNlfTtcclxuICAgICAgX2tleXNbJ251bSsnXSA9IHtjb2RlOjEwNywgc2hpZnQ6IGZhbHNlfTtcclxuICAgICAgX2tleXNbJ251bS0nXSA9IHtjb2RlOjEwOSwgc2hpZnQ6IGZhbHNlfTtcclxuICAgICAgX2tleXNbJ251bS8nXSA9IHtjb2RlOjExMSwgc2hpZnQ6IGZhbHNlfTtcclxuICAgICAgX2tleXNbJ251bS4nXSA9IHtjb2RlOjExMCwgc2hpZnQ6IGZhbHNlfTtcclxuICAgICAgLy8gYXJyb3dzXHJcbiAgICAgIF9rZXlzWydsZWZ0J10gID0ge2NvZGU6MzcsIHNoaWZ0OiBmYWxzZX07XHJcbiAgICAgIF9rZXlzWyd1cCddICAgID0ge2NvZGU6MzgsIHNoaWZ0OiBmYWxzZX07XHJcbiAgICAgIF9rZXlzWydyaWdodCddID0ge2NvZGU6MzksIHNoaWZ0OiBmYWxzZX07XHJcbiAgICAgIF9rZXlzWydkb3duJ10gID0ge2NvZGU6NDAsIHNoaWZ0OiBmYWxzZX07XHJcbiAgICAgIC8vIGV4dHJhIGtleXNcclxuICAgICAgX2tleXNbJ3NwYWNlJ10gPSB7Y29kZTozMiwgc2hpZnQ6IGZhbHNlfTtcclxuICAgICAgX2tleXNbJ2VudGVyJ10gPSB7Y29kZToxMywgc2hpZnQ6IGZhbHNlfTtcclxuICAgICAgX2tleXNbJ3NoaWZ0J10gPSB7Y29kZToxNiwgc2hpZnQ6IHVuZGVmaW5lZH07XHJcbiAgICAgIF9rZXlzWydlc2MnXSAgID0ge2NvZGU6MjcsIHNoaWZ0OiBmYWxzZX07XHJcbiAgICAgIF9rZXlzWydiYWNrc3BhY2UnXSA9IHtjb2RlOjgsIHNoaWZ0OiBmYWxzZX07XHJcbiAgICAgIF9rZXlzWyd0YWInXSAgICAgICA9IHtjb2RlOjksIHNoaWZ0OiBmYWxzZX07XHJcbiAgICAgIF9rZXlzWydjdHJsJ10gICAgICA9IHtjb2RlOjE3LCBzaGlmdDogZmFsc2V9O1xyXG4gICAgICBfa2V5c1snYWx0J10gICAgICAgPSB7Y29kZToxOCwgc2hpZnQ6IGZhbHNlfTtcclxuICAgICAgX2tleXNbJ2RlbGV0ZSddICAgID0ge2NvZGU6NDYsIHNoaWZ0OiBmYWxzZX07XHJcbiAgICAgIF9rZXlzWydwYWdldXAnXSAgICA9IHtjb2RlOjMzLCBzaGlmdDogZmFsc2V9O1xyXG4gICAgICBfa2V5c1sncGFnZWRvd24nXSAgPSB7Y29kZTozNCwgc2hpZnQ6IGZhbHNlfTtcclxuICAgICAgLy8gc3ltYm9sc1xyXG4gICAgICBfa2V5c1snPSddICAgICA9IHtjb2RlOjE4Nywgc2hpZnQ6IGZhbHNlfTtcclxuICAgICAgX2tleXNbJy0nXSAgICAgPSB7Y29kZToxODksIHNoaWZ0OiBmYWxzZX07XHJcbiAgICAgIF9rZXlzWyddJ10gICAgID0ge2NvZGU6MjIxLCBzaGlmdDogZmFsc2V9O1xyXG4gICAgICBfa2V5c1snWyddICAgICA9IHtjb2RlOjIxOSwgc2hpZnQ6IGZhbHNlfTtcclxuXHJcblxyXG5cclxuICAgICAgdmFyIGRvd24gPSBmdW5jdGlvbihldmVudCkge2hhbmRsZUV2ZW50KGV2ZW50LCdrZXlkb3duJyk7fTtcclxuICAgICAgdmFyIHVwID0gZnVuY3Rpb24oZXZlbnQpIHtoYW5kbGVFdmVudChldmVudCwna2V5dXAnKTt9O1xyXG5cclxuICAgICAgLy8gaGFuZGxlIHRoZSBhY3R1YWx5IGJvdW5kIGtleSB3aXRoIHRoZSBldmVudFxyXG4gICAgICB2YXIgaGFuZGxlRXZlbnQgPSBmdW5jdGlvbihldmVudCx0eXBlKSB7XHJcbiAgICAgICAgaWYgKF9ib3VuZFt0eXBlXVtldmVudC5rZXlDb2RlXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICB2YXIgYm91bmQgPSBfYm91bmRbdHlwZV1bZXZlbnQua2V5Q29kZV07XHJcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChib3VuZFtpXS5zaGlmdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgYm91bmRbaV0uZm4oZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGJvdW5kW2ldLnNoaWZ0ID09IHRydWUgJiYgZXZlbnQuc2hpZnRLZXkgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgIGJvdW5kW2ldLmZuKGV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChib3VuZFtpXS5zaGlmdCA9PSBmYWxzZSAmJiBldmVudC5zaGlmdEtleSA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgIGJvdW5kW2ldLmZuKGV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gYmluZCBhIGtleSB0byBhIGNhbGxiYWNrXHJcbiAgICAgIF9leHBvcnRGdW5jdGlvbnMuYmluZCA9IGZ1bmN0aW9uKGtleSwgY2FsbGJhY2ssIHR5cGUpIHtcclxuICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICB0eXBlID0gJ2tleWRvd24nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX2tleXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBrZXk6IFwiICsga2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdLnB1c2goe2ZuOmNhbGxiYWNrLCBzaGlmdDpfa2V5c1trZXldLnNoaWZ0fSk7XHJcbiAgICAgIH07XHJcblxyXG5cclxuICAgICAgLy8gYmluZCBhbGwga2V5cyB0byBhIGNhbGwgYmFjayAoZGVtbyBwdXJwb3NlcylcclxuICAgICAgX2V4cG9ydEZ1bmN0aW9ucy5iaW5kQWxsID0gZnVuY3Rpb24oY2FsbGJhY2ssIHR5cGUpIHtcclxuICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICB0eXBlID0gJ2tleWRvd24nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gX2tleXMpIHtcclxuICAgICAgICAgIGlmIChfa2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgIF9leHBvcnRGdW5jdGlvbnMuYmluZChrZXksY2FsbGJhY2ssdHlwZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gZ2V0IHRoZSBrZXkgbGFiZWwgZnJvbSBhbiBldmVudFxyXG4gICAgICBfZXhwb3J0RnVuY3Rpb25zLmdldEtleSA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIF9rZXlzKSB7XHJcbiAgICAgICAgICBpZiAoX2tleXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkgPT0gdHJ1ZSAmJiBfa2V5c1trZXldLnNoaWZ0ID09IHRydWUgJiYgZXZlbnQua2V5Q29kZSA9PSBfa2V5c1trZXldLmNvZGUpIHtcclxuICAgICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LnNoaWZ0S2V5ID09IGZhbHNlICYmIF9rZXlzW2tleV0uc2hpZnQgPT0gZmFsc2UgJiYgZXZlbnQua2V5Q29kZSA9PSBfa2V5c1trZXldLmNvZGUpIHtcclxuICAgICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gX2tleXNba2V5XS5jb2RlICYmIGtleSA9PSAnc2hpZnQnKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCJ1bmtub3duIGtleSwgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcIjtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIHVuYmluZCBlaXRoZXIgYSBzcGVjaWZpYyBjYWxsYmFjayBmcm9tIGEga2V5IG9yIGFsbCBvZiB0aGVtIChieSBsZWF2aW5nIGNhbGxiYWNrIHVuZGVmaW5lZClcclxuICAgICAgX2V4cG9ydEZ1bmN0aW9ucy51bmJpbmQgPSBmdW5jdGlvbihrZXksIGNhbGxiYWNrLCB0eXBlKSB7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgdHlwZSA9ICdrZXlkb3duJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF9rZXlzW2tleV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQga2V5OiBcIiArIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICB2YXIgbmV3QmluZGluZ3MgPSBbXTtcclxuICAgICAgICAgIHZhciBib3VuZCA9IF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdO1xyXG4gICAgICAgICAgaWYgKGJvdW5kICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIGlmICghKGJvdW5kW2ldLmZuID09IGNhbGxiYWNrICYmIGJvdW5kW2ldLnNoaWZ0ID09IF9rZXlzW2tleV0uc2hpZnQpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdCaW5kaW5ncy5wdXNoKF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdW2ldKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdID0gbmV3QmluZGluZ3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyByZXNldCBhbGwgYm91bmQgdmFyaWFibGVzLlxyXG4gICAgICBfZXhwb3J0RnVuY3Rpb25zLnJlc2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgX2JvdW5kID0ge2tleWRvd246e30sIGtleXVwOnt9fTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIHVuYmluZCBhbGwgbGlzdGVuZXJzIGFuZCByZXNldCBhbGwgdmFyaWFibGVzLlxyXG4gICAgICBfZXhwb3J0RnVuY3Rpb25zLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBfYm91bmQgPSB7a2V5ZG93bjp7fSwga2V5dXA6e319O1xyXG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZG93biwgdHJ1ZSk7XHJcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdXAsIHRydWUpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gY3JlYXRlIGxpc3RlbmVycy5cclxuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLGRvd24sdHJ1ZSk7XHJcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsdXAsdHJ1ZSk7XHJcblxyXG4gICAgICAvLyByZXR1cm4gdGhlIHB1YmxpYyBmdW5jdGlvbnMuXHJcbiAgICAgIHJldHVybiBfZXhwb3J0RnVuY3Rpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBrZXljaGFybTtcclxuICB9KSk7XHJcblxyXG5cclxuXG5cbi8qKiovIH0sXG4vKiAyNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIHV0aWxzXG4gIGV4cG9ydHMudXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIGV4cG9ydHMuRE9NdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbiAgLy8gZGF0YVxuICBleHBvcnRzLkRhdGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuICBleHBvcnRzLkRhdGFWaWV3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG4gIGV4cG9ydHMuUXVldWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxuICAvLyBUaW1lbGluZVxuICBleHBvcnRzLlRpbWVsaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG4gIGV4cG9ydHMuR3JhcGgyZCA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpO1xuICBleHBvcnRzLnRpbWVsaW5lID0ge1xuICAgIENvcmU6IF9fd2VicGFja19yZXF1aXJlX18oMzUpLFxuICAgIERhdGVVdGlsOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KSxcbiAgICBSYW5nZTogX193ZWJwYWNrX3JlcXVpcmVfXygzMiksXG4gICAgc3RhY2s6IF9fd2VicGFja19yZXF1aXJlX18oMzkpLFxuICAgIFRpbWVTdGVwOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KSxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIEl0ZW06IF9fd2VicGFja19yZXF1aXJlX18oNDEpLFxuICAgICAgICBCYWNrZ3JvdW5kSXRlbTogX193ZWJwYWNrX3JlcXVpcmVfXyg0NSksXG4gICAgICAgIEJveEl0ZW06IF9fd2VicGFja19yZXF1aXJlX18oNDMpLFxuICAgICAgICBQb2ludEl0ZW06IF9fd2VicGFja19yZXF1aXJlX18oNDQpLFxuICAgICAgICBSYW5nZUl0ZW06IF9fd2VicGFja19yZXF1aXJlX18oNDApXG4gICAgICB9LFxuXG4gICAgICBCYWNrZ3JvdW5kR3JvdXA6IF9fd2VicGFja19yZXF1aXJlX18oNDIpLFxuICAgICAgQ29tcG9uZW50OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKSxcbiAgICAgIEN1cnJlbnRUaW1lOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKSxcbiAgICAgIEN1c3RvbVRpbWU6IF9fd2VicGFja19yZXF1aXJlX18oNDgpLFxuICAgICAgRGF0YUF4aXM6IF9fd2VicGFja19yZXF1aXJlX18oNTQpLFxuICAgICAgRGF0YVNjYWxlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1KSxcbiAgICAgIEdyYXBoR3JvdXA6IF9fd2VicGFja19yZXF1aXJlX18oNTYpLFxuICAgICAgR3JvdXA6IF9fd2VicGFja19yZXF1aXJlX18oMzgpLFxuICAgICAgSXRlbVNldDogX193ZWJwYWNrX3JlcXVpcmVfXygzNiksXG4gICAgICBMZWdlbmQ6IF9fd2VicGFja19yZXF1aXJlX18oNjApLFxuICAgICAgTGluZUdyYXBoOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKSxcbiAgICAgIFRpbWVBeGlzOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KVxuICAgIH1cbiAgfTtcblxuICAvLyBidW5kbGVkIGV4dGVybmFsIGxpYnJhcmllc1xuICBleHBvcnRzLm1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4gIGV4cG9ydHMuSGFtbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG4gIGV4cG9ydHMua2V5Y2hhcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcblxuLyoqKi8gfSxcbi8qIDI3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9Db25maWd1cmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcblxuICB2YXIgX0NvbmZpZ3VyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db25maWd1cmF0b3IpO1xuXG4gIHZhciBfVmFsaWRhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG5cbiAgdmFyIF9WYWxpZGF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVmFsaWRhdG9yKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIHZhciBFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG4gIHZhciBIYW1tZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcbiAgdmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIERhdGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuICB2YXIgRGF0YVZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbiAgdmFyIFJhbmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG4gIHZhciBDb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG4gIHZhciBUaW1lQXhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpO1xuICB2YXIgQ3VycmVudFRpbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKTtcbiAgdmFyIEN1c3RvbVRpbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KTtcbiAgdmFyIEl0ZW1TZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcblxuICB2YXIgcHJpbnRTdHlsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpLnByaW50U3R5bGU7XG4gIHZhciBhbGxPcHRpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MSkuYWxsT3B0aW9ucztcbiAgdmFyIGNvbmZpZ3VyZU9wdGlvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKS5jb25maWd1cmVPcHRpb25zO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB0aW1lbGluZSB2aXN1YWxpemF0aW9uXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxuICAgKiBAcGFyYW0ge3Zpcy5EYXRhU2V0IHwgdmlzLkRhdGFWaWV3IHwgQXJyYXl9IFtpdGVtc11cbiAgICogQHBhcmFtIHt2aXMuRGF0YVNldCB8IHZpcy5EYXRhVmlldyB8IEFycmF5fSBbZ3JvdXBzXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICBTZWUgVGltZWxpbmUuc2V0T3B0aW9ucyBmb3IgdGhlIGF2YWlsYWJsZSBvcHRpb25zLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgQ29yZVxuICAgKi9cbiAgZnVuY3Rpb24gVGltZWxpbmUoY29udGFpbmVyLCBpdGVtcywgZ3JvdXBzLCBvcHRpb25zKSB7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGltZWxpbmUpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSB0aGlyZCBlbGVtZW50IGlzIG9wdGlvbnMsIHRoZSBmb3J0aCBpcyBncm91cHMgKG9wdGlvbmFsbHkpO1xuICAgIGlmICghKEFycmF5LmlzQXJyYXkoZ3JvdXBzKSB8fCBncm91cHMgaW5zdGFuY2VvZiBEYXRhU2V0IHx8IGdyb3VwcyBpbnN0YW5jZW9mIERhdGFWaWV3KSAmJiBncm91cHMgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIHZhciBmb3J0aEFyZ3VtZW50ID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSBncm91cHM7XG4gICAgICBncm91cHMgPSBmb3J0aEFyZ3VtZW50O1xuICAgIH1cblxuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgZW5kOiBudWxsLFxuICAgICAgYXV0b1Jlc2l6ZTogdHJ1ZSxcbiAgICAgIG9yaWVudGF0aW9uOiB7XG4gICAgICAgIGF4aXM6ICdib3R0b20nLCAvLyBheGlzIG9yaWVudGF0aW9uOiAnYm90dG9tJywgJ3RvcCcsIG9yICdib3RoJ1xuICAgICAgICBpdGVtOiAnYm90dG9tJyAvLyBub3QgcmVsZXZhbnRcbiAgICAgIH0sXG4gICAgICBtb21lbnQ6IG1vbWVudCxcbiAgICAgIHdpZHRoOiBudWxsLFxuICAgICAgaGVpZ2h0OiBudWxsLFxuICAgICAgbWF4SGVpZ2h0OiBudWxsLFxuICAgICAgbWluSGVpZ2h0OiBudWxsXG4gICAgfTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmRlZXBFeHRlbmQoe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBET00sIHByb3BzLCBhbmQgZW1pdHRlclxuICAgIHRoaXMuX2NyZWF0ZShjb250YWluZXIpO1xuXG4gICAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMucnRsID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHZhciBkaXJlY3Rpb25Gcm9tRG9tLFxuICAgICAgICAgIGRvbU5vZGUgPSB0aGlzLmRvbS5yb290O1xuICAgICAgd2hpbGUgKCFkaXJlY3Rpb25Gcm9tRG9tICYmIGRvbU5vZGUpIHtcbiAgICAgICAgZGlyZWN0aW9uRnJvbURvbSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbU5vZGUsIG51bGwpLmRpcmVjdGlvbjtcbiAgICAgICAgZG9tTm9kZSA9IGRvbU5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICAgIHRoaXMub3B0aW9ucy5ydGwgPSBkaXJlY3Rpb25Gcm9tRG9tICYmIGRpcmVjdGlvbkZyb21Eb20udG9Mb3dlckNhc2UoKSA9PSBcInJ0bFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wdGlvbnMucnRsID0gb3B0aW9ucy5ydGw7XG4gICAgfVxuXG4gICAgLy8gYWxsIGNvbXBvbmVudHMgbGlzdGVkIGhlcmUgd2lsbCBiZSByZXBhaW50ZWQgYXV0b21hdGljYWxseVxuICAgIHRoaXMuY29tcG9uZW50cyA9IFtdO1xuXG4gICAgdGhpcy5ib2R5ID0ge1xuICAgICAgZG9tOiB0aGlzLmRvbSxcbiAgICAgIGRvbVByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgZW1pdHRlcjoge1xuICAgICAgICBvbjogdGhpcy5vbi5iaW5kKHRoaXMpLFxuICAgICAgICBvZmY6IHRoaXMub2ZmLmJpbmQodGhpcyksXG4gICAgICAgIGVtaXQ6IHRoaXMuZW1pdC5iaW5kKHRoaXMpXG4gICAgICB9LFxuICAgICAgaGlkZGVuRGF0ZXM6IFtdLFxuICAgICAgdXRpbDoge1xuICAgICAgICBnZXRTY2FsZTogZnVuY3Rpb24gZ2V0U2NhbGUoKSB7XG4gICAgICAgICAgcmV0dXJuIG1lLnRpbWVBeGlzLnN0ZXAuc2NhbGU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFN0ZXA6IGZ1bmN0aW9uIGdldFN0ZXAoKSB7XG4gICAgICAgICAgcmV0dXJuIG1lLnRpbWVBeGlzLnN0ZXAuc3RlcDtcbiAgICAgICAgfSxcblxuICAgICAgICB0b1NjcmVlbjogbWUuX3RvU2NyZWVuLmJpbmQobWUpLFxuICAgICAgICB0b0dsb2JhbFNjcmVlbjogbWUuX3RvR2xvYmFsU2NyZWVuLmJpbmQobWUpLCAvLyB0aGlzIHJlZmVycyB0byB0aGUgcm9vdC53aWR0aFxuICAgICAgICB0b1RpbWU6IG1lLl90b1RpbWUuYmluZChtZSksXG4gICAgICAgIHRvR2xvYmFsVGltZTogbWUuX3RvR2xvYmFsVGltZS5iaW5kKG1lKVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyByYW5nZVxuICAgIHRoaXMucmFuZ2UgPSBuZXcgUmFuZ2UodGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMuY29tcG9uZW50cy5wdXNoKHRoaXMucmFuZ2UpO1xuICAgIHRoaXMuYm9keS5yYW5nZSA9IHRoaXMucmFuZ2U7XG5cbiAgICAvLyB0aW1lIGF4aXNcbiAgICB0aGlzLnRpbWVBeGlzID0gbmV3IFRpbWVBeGlzKHRoaXMuYm9keSwgdGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLnRpbWVBeGlzMiA9IG51bGw7IC8vIHVzZWQgaW4gY2FzZSBvZiBvcmllbnRhdGlvbiBvcHRpb24gJ2JvdGgnXG4gICAgdGhpcy5jb21wb25lbnRzLnB1c2godGhpcy50aW1lQXhpcyk7XG5cbiAgICAvLyBjdXJyZW50IHRpbWUgYmFyXG4gICAgdGhpcy5jdXJyZW50VGltZSA9IG5ldyBDdXJyZW50VGltZSh0aGlzLmJvZHksIHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy5jb21wb25lbnRzLnB1c2godGhpcy5jdXJyZW50VGltZSk7XG5cbiAgICAvLyBpdGVtIHNldFxuICAgIHRoaXMuaXRlbVNldCA9IG5ldyBJdGVtU2V0KHRoaXMuYm9keSwgdGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLmNvbXBvbmVudHMucHVzaCh0aGlzLml0ZW1TZXQpO1xuXG4gICAgdGhpcy5pdGVtc0RhdGEgPSBudWxsOyAvLyBEYXRhU2V0XG4gICAgdGhpcy5ncm91cHNEYXRhID0gbnVsbDsgLy8gRGF0YVNldFxuXG4gICAgdGhpcy5vbigndGFwJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBtZS5lbWl0KCdjbGljaycsIG1lLmdldEV2ZW50UHJvcGVydGllcyhldmVudCkpO1xuICAgIH0pO1xuICAgIHRoaXMub24oJ2RvdWJsZXRhcCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgbWUuZW1pdCgnZG91YmxlQ2xpY2snLCBtZS5nZXRFdmVudFByb3BlcnRpZXMoZXZlbnQpKTtcbiAgICB9KTtcbiAgICB0aGlzLmRvbS5yb290Lm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIG1lLmVtaXQoJ2NvbnRleHRtZW51JywgbWUuZ2V0RXZlbnRQcm9wZXJ0aWVzKGV2ZW50KSk7XG4gICAgfTtcblxuICAgIC8vU2luZ2xlIHRpbWUgYXV0b3NjYWxlL2ZpdFxuICAgIHRoaXMuZml0RG9uZSA9IGZhbHNlO1xuICAgIHRoaXMub24oJ2NoYW5nZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5pdGVtc0RhdGEgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgaWYgKCFtZS5maXREb25lKSB7XG4gICAgICAgIG1lLmZpdERvbmUgPSB0cnVlO1xuICAgICAgICBpZiAobWUub3B0aW9ucy5zdGFydCAhPSB1bmRlZmluZWQgfHwgbWUub3B0aW9ucy5lbmQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG1lLm9wdGlvbnMuc3RhcnQgPT0gdW5kZWZpbmVkIHx8IG1lLm9wdGlvbnMuZW5kID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gbWUuZ2V0SXRlbVJhbmdlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHN0YXJ0ID0gbWUub3B0aW9ucy5zdGFydCAhPSB1bmRlZmluZWQgPyBtZS5vcHRpb25zLnN0YXJ0IDogcmFuZ2UubWluO1xuICAgICAgICAgIHZhciBlbmQgPSBtZS5vcHRpb25zLmVuZCAhPSB1bmRlZmluZWQgPyBtZS5vcHRpb25zLmVuZCA6IHJhbmdlLm1heDtcblxuICAgICAgICAgIG1lLnNldFdpbmRvdyhzdGFydCwgZW5kLCB7IGFuaW1hdGlvbjogZmFsc2UgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWUuZml0KHsgYW5pbWF0aW9uOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgb3B0aW9uc1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gSU1QT1JUQU5UOiBUSElTIEhBUFBFTlMgQkVGT1JFIFNFVCBJVEVNUyFcbiAgICBpZiAoZ3JvdXBzKSB7XG4gICAgICB0aGlzLnNldEdyb3Vwcyhncm91cHMpO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBpdGVtc2V0XG4gICAgaWYgKGl0ZW1zKSB7XG4gICAgICB0aGlzLnNldEl0ZW1zKGl0ZW1zKTtcbiAgICB9XG5cbiAgICAvLyBkcmF3IGZvciB0aGUgZmlyc3QgdGltZVxuICAgIHRoaXMuX3JlZHJhdygpO1xuICB9XG5cbiAgLy8gRXh0ZW5kIHRoZSBmdW5jdGlvbmFsaXR5IGZyb20gQ29yZVxuICBUaW1lbGluZS5wcm90b3R5cGUgPSBuZXcgQ29yZSgpO1xuXG4gIC8qKlxuICAgKiBMb2FkIGEgY29uZmlndXJhdG9yXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRpbWVsaW5lLnByb3RvdHlwZS5fY3JlYXRlQ29uZmlndXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgX0NvbmZpZ3VyYXRvcjIuZGVmYXVsdCh0aGlzLCB0aGlzLmRvbS5jb250YWluZXIsIGNvbmZpZ3VyZU9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGb3JjZSBhIHJlZHJhdy4gVGhlIHNpemUgb2YgYWxsIGl0ZW1zIHdpbGwgYmUgcmVjYWxjdWxhdGVkLlxuICAgKiBDYW4gYmUgdXNlZnVsIHRvIG1hbnVhbGx5IHJlZHJhdyB3aGVuIG9wdGlvbiBhdXRvUmVzaXplPWZhbHNlIGFuZCB0aGUgd2luZG93XG4gICAqIGhhcyBiZWVuIHJlc2l6ZWQsIG9yIHdoZW4gdGhlIGl0ZW1zIENTUyBoYXMgYmVlbiBjaGFuZ2VkLlxuICAgKlxuICAgKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgb3ZlcnJpZGRlbiBvbiBjb25zdHJ1Y3Rpb24gd2l0aCBhIHRyb3R0bGVkIHZlcnNpb25cbiAgICovXG4gIFRpbWVsaW5lLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pdGVtU2V0ICYmIHRoaXMuaXRlbVNldC5tYXJrRGlydHkoeyByZWZyZXNoSXRlbXM6IHRydWUgfSk7XG4gICAgdGhpcy5fcmVkcmF3KCk7XG4gIH07XG5cbiAgVGltZWxpbmUucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8vIHZhbGlkYXRlIG9wdGlvbnNcbiAgICB2YXIgZXJyb3JGb3VuZCA9IF9WYWxpZGF0b3IyLmRlZmF1bHQudmFsaWRhdGUob3B0aW9ucywgYWxsT3B0aW9ucyk7XG5cbiAgICBpZiAoZXJyb3JGb3VuZCA9PT0gdHJ1ZSkge1xuICAgICAgY29uc29sZS5sb2coJyVjRXJyb3JzIGhhdmUgYmVlbiBmb3VuZCBpbiB0aGUgc3VwcGxpZWQgb3B0aW9ucyBvYmplY3QuJywgcHJpbnRTdHlsZSk7XG4gICAgfVxuICAgIENvcmUucHJvdG90eXBlLnNldE9wdGlvbnMuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgIGlmICgndHlwZScgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMudHlwZSAhPT0gdGhpcy5vcHRpb25zLnR5cGUpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnR5cGUgPSBvcHRpb25zLnR5cGU7XG5cbiAgICAgICAgLy8gZm9yY2UgcmVjcmVhdGlvbiBvZiBhbGwgaXRlbXNcbiAgICAgICAgdmFyIGl0ZW1zRGF0YSA9IHRoaXMuaXRlbXNEYXRhO1xuICAgICAgICBpZiAoaXRlbXNEYXRhKSB7XG4gICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgdGhpcy5zZXRJdGVtcyhudWxsKTsgLy8gcmVtb3ZlIGFsbFxuICAgICAgICAgIHRoaXMuc2V0SXRlbXMoaXRlbXNEYXRhKTsgLy8gYWRkIGFsbFxuICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7IC8vIHJlc3RvcmUgc2VsZWN0aW9uXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBpdGVtc1xuICAgKiBAcGFyYW0ge3Zpcy5EYXRhU2V0IHwgQXJyYXkgfCBudWxsfSBpdGVtc1xuICAgKi9cbiAgVGltZWxpbmUucHJvdG90eXBlLnNldEl0ZW1zID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgLy8gY29udmVydCB0byB0eXBlIERhdGFTZXQgd2hlbiBuZWVkZWRcbiAgICB2YXIgbmV3RGF0YVNldDtcbiAgICBpZiAoIWl0ZW1zKSB7XG4gICAgICBuZXdEYXRhU2V0ID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGl0ZW1zIGluc3RhbmNlb2YgRGF0YVNldCB8fCBpdGVtcyBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgICBuZXdEYXRhU2V0ID0gaXRlbXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHR1cm4gYW4gYXJyYXkgaW50byBhIGRhdGFzZXRcbiAgICAgIG5ld0RhdGFTZXQgPSBuZXcgRGF0YVNldChpdGVtcywge1xuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgc3RhcnQ6ICdEYXRlJyxcbiAgICAgICAgICBlbmQ6ICdEYXRlJ1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBzZXQgaXRlbXNcbiAgICB0aGlzLml0ZW1zRGF0YSA9IG5ld0RhdGFTZXQ7XG4gICAgdGhpcy5pdGVtU2V0ICYmIHRoaXMuaXRlbVNldC5zZXRJdGVtcyhuZXdEYXRhU2V0KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGdyb3Vwc1xuICAgKiBAcGFyYW0ge3Zpcy5EYXRhU2V0IHwgQXJyYXl9IGdyb3Vwc1xuICAgKi9cbiAgVGltZWxpbmUucHJvdG90eXBlLnNldEdyb3VwcyA9IGZ1bmN0aW9uIChncm91cHMpIHtcbiAgICAvLyBjb252ZXJ0IHRvIHR5cGUgRGF0YVNldCB3aGVuIG5lZWRlZFxuICAgIHZhciBuZXdEYXRhU2V0O1xuICAgIGlmICghZ3JvdXBzKSB7XG4gICAgICBuZXdEYXRhU2V0ID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGdyb3VwcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgZ3JvdXBzIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICAgIG5ld0RhdGFTZXQgPSBncm91cHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHR1cm4gYW4gYXJyYXkgaW50byBhIGRhdGFzZXRcbiAgICAgIG5ld0RhdGFTZXQgPSBuZXcgRGF0YVNldChncm91cHMpO1xuICAgIH1cblxuICAgIHRoaXMuZ3JvdXBzRGF0YSA9IG5ld0RhdGFTZXQ7XG4gICAgdGhpcy5pdGVtU2V0LnNldEdyb3VwcyhuZXdEYXRhU2V0KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGJvdGggaXRlbXMgYW5kIGdyb3VwcyBpbiBvbmUgZ29cbiAgICogQHBhcmFtIHt7aXRlbXM6IEFycmF5IHwgdmlzLkRhdGFTZXQsIGdyb3VwczogQXJyYXkgfCB2aXMuRGF0YVNldH19IGRhdGFcbiAgICovXG4gIFRpbWVsaW5lLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmdyb3Vwcykge1xuICAgICAgdGhpcy5zZXRHcm91cHMoZGF0YS5ncm91cHMpO1xuICAgIH1cblxuICAgIGlmIChkYXRhICYmIGRhdGEuaXRlbXMpIHtcbiAgICAgIHRoaXMuc2V0SXRlbXMoZGF0YS5pdGVtcyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgc2VsZWN0ZWQgaXRlbXMgYnkgdGhlaXIgaWQuIFJlcGxhY2VzIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgKiBVbmtub3duIGlkJ3MgYXJlIHNpbGVudGx5IGlnbm9yZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nW10gfCBzdHJpbmd9IFtpZHNdICBBbiBhcnJheSB3aXRoIHplcm8gb3IgbW9yZSBpZCdzIG9mIHRoZSBpdGVtcyB0byBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQuIElmIGlkcyBpcyBhbiBlbXB0eSBhcnJheSwgYWxsIGl0ZW1zIHdpbGwgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuc2VsZWN0ZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBmb2N1czogYm9vbGVhbmBcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlLCBmb2N1cyB3aWxsIGJlIHNldCB0byB0aGUgc2VsZWN0ZWQgaXRlbShzKVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGFuaW1hdGlvbjogYm9vbGVhbiB8IHtkdXJhdGlvbjogbnVtYmVyLCBlYXNpbmdGdW5jdGlvbjogc3RyaW5nfWBcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlIChkZWZhdWx0KSwgdGhlIHJhbmdlIGlzIGFuaW1hdGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21vb3RobHkgdG8gdGhlIG5ldyB3aW5kb3cuIEFuIG9iamVjdCBjYW4gYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZCB0byBzcGVjaWZ5IGR1cmF0aW9uIGFuZCBlYXNpbmcgZnVuY3Rpb24uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBkdXJhdGlvbiBpcyA1MDAgbXMsIGFuZCBkZWZhdWx0IGVhc2luZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzICdlYXNlSW5PdXRRdWFkJy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IGFwcGxpY2FibGUgd2hlbiBvcHRpb24gZm9jdXMgaXMgdHJ1ZS5cbiAgICovXG4gIFRpbWVsaW5lLnByb3RvdHlwZS5zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoaWRzLCBvcHRpb25zKSB7XG4gICAgdGhpcy5pdGVtU2V0ICYmIHRoaXMuaXRlbVNldC5zZXRTZWxlY3Rpb24oaWRzKTtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZm9jdXMpIHtcbiAgICAgIHRoaXMuZm9jdXMoaWRzLCBvcHRpb25zKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2VsZWN0ZWQgaXRlbXMgYnkgdGhlaXIgaWRcbiAgICogQHJldHVybiB7QXJyYXl9IGlkcyAgVGhlIGlkcyBvZiB0aGUgc2VsZWN0ZWQgaXRlbXNcbiAgICovXG4gIFRpbWVsaW5lLnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbVNldCAmJiB0aGlzLml0ZW1TZXQuZ2V0U2VsZWN0aW9uKCkgfHwgW107XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkanVzdCB0aGUgdmlzaWJsZSB3aW5kb3cgc3VjaCB0aGF0IHRoZSBzZWxlY3RlZCBpdGVtIChvciBtdWx0aXBsZSBpdGVtcylcbiAgICogYXJlIGNlbnRlcmVkIG9uIHNjcmVlbi5cbiAgICogQHBhcmFtIHtTdHJpbmcgfCBTdHJpbmdbXX0gaWQgICAgIEFuIGl0ZW0gaWQgb3IgYXJyYXkgd2l0aCBpdGVtIGlkc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYW5pbWF0aW9uOiBib29sZWFuIHwge2R1cmF0aW9uOiBudW1iZXIsIGVhc2luZ0Z1bmN0aW9uOiBzdHJpbmd9YFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCB0aGUgcmFuZ2UgaXMgYW5pbWF0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhseSB0byB0aGUgbmV3IHdpbmRvdy4gQW4gb2JqZWN0IGNhbiBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkIHRvIHNwZWNpZnkgZHVyYXRpb24gYW5kIGVhc2luZyBmdW5jdGlvbi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGR1cmF0aW9uIGlzIDUwMCBtcywgYW5kIGRlZmF1bHQgZWFzaW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaXMgJ2Vhc2VJbk91dFF1YWQnLlxuICAgKi9cbiAgVGltZWxpbmUucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLml0ZW1zRGF0YSB8fCBpZCA9PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgIHZhciBpZHMgPSBBcnJheS5pc0FycmF5KGlkKSA/IGlkIDogW2lkXTtcblxuICAgIC8vIGdldCB0aGUgc3BlY2lmaWVkIGl0ZW0ocylcbiAgICB2YXIgaXRlbXNEYXRhID0gdGhpcy5pdGVtc0RhdGEuZ2V0RGF0YVNldCgpLmdldChpZHMsIHtcbiAgICAgIHR5cGU6IHtcbiAgICAgICAgc3RhcnQ6ICdEYXRlJyxcbiAgICAgICAgZW5kOiAnRGF0ZSdcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGNhbGN1bGF0ZSBtaW5pbXVtIHN0YXJ0IGFuZCBtYXhpbXVtIGVuZCBvZiBzcGVjaWZpZWQgaXRlbXNcbiAgICB2YXIgc3RhcnQgPSBudWxsO1xuICAgIHZhciBlbmQgPSBudWxsO1xuICAgIGl0ZW1zRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtRGF0YSkge1xuICAgICAgdmFyIHMgPSBpdGVtRGF0YS5zdGFydC52YWx1ZU9mKCk7XG4gICAgICB2YXIgZSA9ICdlbmQnIGluIGl0ZW1EYXRhID8gaXRlbURhdGEuZW5kLnZhbHVlT2YoKSA6IGl0ZW1EYXRhLnN0YXJ0LnZhbHVlT2YoKTtcblxuICAgICAgaWYgKHN0YXJ0ID09PSBudWxsIHx8IHMgPCBzdGFydCkge1xuICAgICAgICBzdGFydCA9IHM7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQgPT09IG51bGwgfHwgZSA+IGVuZCkge1xuICAgICAgICBlbmQgPSBlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHN0YXJ0ICE9PSBudWxsICYmIGVuZCAhPT0gbnVsbCkge1xuICAgICAgLy8gY2FsY3VsYXRlIHRoZSBuZXcgbWlkZGxlIGFuZCBpbnRlcnZhbCBmb3IgdGhlIHdpbmRvd1xuICAgICAgdmFyIG1pZGRsZSA9IChzdGFydCArIGVuZCkgLyAyO1xuICAgICAgdmFyIGludGVydmFsID0gTWF0aC5tYXgodGhpcy5yYW5nZS5lbmQgLSB0aGlzLnJhbmdlLnN0YXJ0LCAoZW5kIC0gc3RhcnQpICogMS4xKTtcblxuICAgICAgdmFyIGFuaW1hdGlvbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW5pbWF0aW9uIDogdHJ1ZTtcbiAgICAgIHRoaXMucmFuZ2Uuc2V0UmFuZ2UobWlkZGxlIC0gaW50ZXJ2YWwgLyAyLCBtaWRkbGUgKyBpbnRlcnZhbCAvIDIsIGFuaW1hdGlvbik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgVGltZWxpbmUgd2luZG93IHN1Y2ggdGhhdCBpdCBmaXRzIGFsbCBpdGVtc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBhbmltYXRpb246IGJvb2xlYW4gfCB7ZHVyYXRpb246IG51bWJlciwgZWFzaW5nRnVuY3Rpb246IHN0cmluZ31gXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSAoZGVmYXVsdCksIHRoZSByYW5nZSBpcyBhbmltYXRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aGx5IHRvIHRoZSBuZXcgd2luZG93LiBBbiBvYmplY3QgY2FuIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWQgdG8gc3BlY2lmeSBkdXJhdGlvbiBhbmQgZWFzaW5nIGZ1bmN0aW9uLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgZHVyYXRpb24gaXMgNTAwIG1zLCBhbmQgZGVmYXVsdCBlYXNpbmdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBpcyAnZWFzZUluT3V0UXVhZCcuXG4gICAqL1xuICBUaW1lbGluZS5wcm90b3R5cGUuZml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgYW5pbWF0aW9uID0gb3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbmltYXRpb24gOiB0cnVlO1xuICAgIHZhciByYW5nZTtcblxuICAgIHZhciBkYXRhc2V0ID0gdGhpcy5pdGVtc0RhdGEgJiYgdGhpcy5pdGVtc0RhdGEuZ2V0RGF0YVNldCgpO1xuICAgIGlmIChkYXRhc2V0Lmxlbmd0aCA9PT0gMSAmJiBkYXRhc2V0LmdldCgpWzBdLmVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhIHNpbmdsZSBpdGVtIC0+IGRvbid0IGZpdCwganVzdCBzaG93IGEgcmFuZ2UgYXJvdW5kIHRoZSBpdGVtIGZyb20gLTQgdG8gKzMgZGF5c1xuICAgICAgcmFuZ2UgPSB0aGlzLmdldERhdGFSYW5nZSgpO1xuICAgICAgdGhpcy5tb3ZlVG8ocmFuZ2UubWluLnZhbHVlT2YoKSwgeyBhbmltYXRpb246IGFuaW1hdGlvbiB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhhY3RseSBmaXQgdGhlIGl0ZW1zIChwbHVzIGEgc21hbGwgbWFyZ2luKVxuICAgICAgcmFuZ2UgPSB0aGlzLmdldEl0ZW1SYW5nZSgpO1xuICAgICAgdGhpcy5yYW5nZS5zZXRSYW5nZShyYW5nZS5taW4sIHJhbmdlLm1heCwgYW5pbWF0aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgcmFuZ2Ugb2YgdGhlIGl0ZW1zLCB0YWtpbmcgaW50byBhY2NvdW50IHRoZWlyIGFjdHVhbCB3aWR0aFxuICAgKiBhbmQgYSBtYXJnaW4gb2YgMTAgcGl4ZWxzIG9uIGJvdGggc2lkZXMuXG4gICAqIEByZXR1cm4ge3ttaW46IERhdGUgfCBudWxsLCBtYXg6IERhdGUgfCBudWxsfX1cbiAgICovXG4gIFRpbWVsaW5lLnByb3RvdHlwZS5nZXRJdGVtUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIGdldCBhIHJvdWdoIGFwcHJveGltYXRpb24gZm9yIHRoZSByYW5nZSBiYXNlZCBvbiB0aGUgaXRlbXMgc3RhcnQgYW5kIGVuZCBkYXRlc1xuICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0RGF0YVJhbmdlKCk7XG4gICAgdmFyIG1pbiA9IHJhbmdlLm1pbiAhPT0gbnVsbCA/IHJhbmdlLm1pbi52YWx1ZU9mKCkgOiBudWxsO1xuICAgIHZhciBtYXggPSByYW5nZS5tYXggIT09IG51bGwgPyByYW5nZS5tYXgudmFsdWVPZigpIDogbnVsbDtcbiAgICB2YXIgbWluSXRlbSA9IG51bGw7XG4gICAgdmFyIG1heEl0ZW0gPSBudWxsO1xuXG4gICAgaWYgKG1pbiAhPSBudWxsICYmIG1heCAhPSBudWxsKSB7XG4gICAgICB2YXIgaW50ZXJ2YWw7XG4gICAgICB2YXIgZmFjdG9yO1xuICAgICAgdmFyIGxocztcbiAgICAgIHZhciByaHM7XG4gICAgICB2YXIgZGVsdGE7XG5cbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBnZXRTdGFydCA9IGZ1bmN0aW9uIGdldFN0YXJ0KGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gdXRpbC5jb252ZXJ0KGl0ZW0uZGF0YS5zdGFydCwgJ0RhdGUnKS52YWx1ZU9mKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldEVuZCA9IGZ1bmN0aW9uIGdldEVuZChpdGVtKSB7XG4gICAgICAgICAgdmFyIGVuZCA9IGl0ZW0uZGF0YS5lbmQgIT0gdW5kZWZpbmVkID8gaXRlbS5kYXRhLmVuZCA6IGl0ZW0uZGF0YS5zdGFydDtcbiAgICAgICAgICByZXR1cm4gdXRpbC5jb252ZXJ0KGVuZCwgJ0RhdGUnKS52YWx1ZU9mKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBkYXRlIG9mIHRoZSBsZWZ0IHNpZGUgYW5kIHJpZ2h0IHNpZGUgb2YgdGhlIGl0ZW1zIGdpdmVuXG5cblxuICAgICAgICBpbnRlcnZhbCA9IG1heCAtIG1pbjsgLy8gbXNcblxuICAgICAgICBpZiAoaW50ZXJ2YWwgPD0gMCkge1xuICAgICAgICAgIGludGVydmFsID0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgZmFjdG9yID0gaW50ZXJ2YWwgLyBfdGhpcy5wcm9wcy5jZW50ZXIud2lkdGg7XG4gICAgICAgIHV0aWwuZm9yRWFjaChfdGhpcy5pdGVtU2V0Lml0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIGl0ZW0uc2hvdygpO1xuICAgICAgICAgIGl0ZW0ucmVwb3NpdGlvblgoKTtcblxuICAgICAgICAgIHZhciBzdGFydCA9IGdldFN0YXJ0KGl0ZW0pO1xuICAgICAgICAgIHZhciBlbmQgPSBnZXRFbmQoaXRlbSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0U2lkZSA9IHN0YXJ0IC0gKGl0ZW0uZ2V0V2lkdGhSaWdodCgpICsgMTApICogZmFjdG9yO1xuICAgICAgICAgICAgdmFyIGVuZFNpZGUgPSBlbmQgKyAoaXRlbS5nZXRXaWR0aExlZnQoKSArIDEwKSAqIGZhY3RvcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHN0YXJ0U2lkZSA9IHN0YXJ0IC0gKGl0ZW0uZ2V0V2lkdGhMZWZ0KCkgKyAxMCkgKiBmYWN0b3I7XG4gICAgICAgICAgICB2YXIgZW5kU2lkZSA9IGVuZCArIChpdGVtLmdldFdpZHRoUmlnaHQoKSArIDEwKSAqIGZhY3RvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhcnRTaWRlIDwgbWluKSB7XG4gICAgICAgICAgICBtaW4gPSBzdGFydFNpZGU7XG4gICAgICAgICAgICBtaW5JdGVtID0gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVuZFNpZGUgPiBtYXgpIHtcbiAgICAgICAgICAgIG1heCA9IGVuZFNpZGU7XG4gICAgICAgICAgICBtYXhJdGVtID0gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgIH0uYmluZChfdGhpcykpO1xuXG4gICAgICAgIGlmIChtaW5JdGVtICYmIG1heEl0ZW0pIHtcbiAgICAgICAgICBsaHMgPSBtaW5JdGVtLmdldFdpZHRoTGVmdCgpICsgMTA7XG4gICAgICAgICAgcmhzID0gbWF4SXRlbS5nZXRXaWR0aFJpZ2h0KCkgKyAxMDtcbiAgICAgICAgICBkZWx0YSA9IF90aGlzLnByb3BzLmNlbnRlci53aWR0aCAtIGxocyAtIHJoczsgLy8gcHhcblxuICAgICAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICAgICAgICBtaW4gPSBnZXRTdGFydChtaW5JdGVtKSAtIHJocyAqIGludGVydmFsIC8gZGVsdGE7IC8vIG1zXG4gICAgICAgICAgICAgIG1heCA9IGdldEVuZChtYXhJdGVtKSArIGxocyAqIGludGVydmFsIC8gZGVsdGE7IC8vIG1zXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtaW4gPSBnZXRTdGFydChtaW5JdGVtKSAtIGxocyAqIGludGVydmFsIC8gZGVsdGE7IC8vIG1zXG4gICAgICAgICAgICAgIG1heCA9IGdldEVuZChtYXhJdGVtKSArIHJocyAqIGludGVydmFsIC8gZGVsdGE7IC8vIG1zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBtaW46IG1pbiAhPSBudWxsID8gbmV3IERhdGUobWluKSA6IG51bGwsXG4gICAgICBtYXg6IG1heCAhPSBudWxsID8gbmV3IERhdGUobWF4KSA6IG51bGxcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGRhdGEgcmFuZ2Ugb2YgdGhlIGl0ZW1zIHN0YXJ0IGFuZCBlbmQgZGF0ZXNcbiAgICogQHJldHVybnMge3ttaW46IERhdGUgfCBudWxsLCBtYXg6IERhdGUgfCBudWxsfX1cbiAgICovXG4gIFRpbWVsaW5lLnByb3RvdHlwZS5nZXREYXRhUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1pbiA9IG51bGw7XG4gICAgdmFyIG1heCA9IG51bGw7XG5cbiAgICB2YXIgZGF0YXNldCA9IHRoaXMuaXRlbXNEYXRhICYmIHRoaXMuaXRlbXNEYXRhLmdldERhdGFTZXQoKTtcbiAgICBpZiAoZGF0YXNldCkge1xuICAgICAgZGF0YXNldC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHV0aWwuY29udmVydChpdGVtLnN0YXJ0LCAnRGF0ZScpLnZhbHVlT2YoKTtcbiAgICAgICAgdmFyIGVuZCA9IHV0aWwuY29udmVydChpdGVtLmVuZCAhPSB1bmRlZmluZWQgPyBpdGVtLmVuZCA6IGl0ZW0uc3RhcnQsICdEYXRlJykudmFsdWVPZigpO1xuICAgICAgICBpZiAobWluID09PSBudWxsIHx8IHN0YXJ0IDwgbWluKSB7XG4gICAgICAgICAgbWluID0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBlbmQgPiBtYXgpIHtcbiAgICAgICAgICBtYXggPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBtaW46IG1pbiAhPSBudWxsID8gbmV3IERhdGUobWluKSA6IG51bGwsXG4gICAgICBtYXg6IG1heCAhPSBudWxsID8gbmV3IERhdGUobWF4KSA6IG51bGxcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBUaW1lbGluZSByZWxhdGVkIGluZm9ybWF0aW9uIGZyb20gYW4gZXZlbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCByZWxhdGVkIGluZm9ybWF0aW9uLCBsaWtlIG9uIHdoaWNoIGFyZWFcbiAgICogICAgICAgICAgICAgICAgICBUaGUgZXZlbnQgaGFwcGVuZWQsIHdoZXRoZXIgY2xpY2tlZCBvbiBhbiBpdGVtLCBldGMuXG4gICAqL1xuICBUaW1lbGluZS5wcm90b3R5cGUuZ2V0RXZlbnRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGNsaWVudFggPSBldmVudC5jZW50ZXIgPyBldmVudC5jZW50ZXIueCA6IGV2ZW50LmNsaWVudFg7XG4gICAgdmFyIGNsaWVudFkgPSBldmVudC5jZW50ZXIgPyBldmVudC5jZW50ZXIueSA6IGV2ZW50LmNsaWVudFk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgIHZhciB4ID0gdXRpbC5nZXRBYnNvbHV0ZVJpZ2h0KHRoaXMuZG9tLmNlbnRlckNvbnRhaW5lcikgLSBjbGllbnRYO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeCA9IGNsaWVudFggLSB1dGlsLmdldEFic29sdXRlTGVmdCh0aGlzLmRvbS5jZW50ZXJDb250YWluZXIpO1xuICAgIH1cbiAgICB2YXIgeSA9IGNsaWVudFkgLSB1dGlsLmdldEFic29sdXRlVG9wKHRoaXMuZG9tLmNlbnRlckNvbnRhaW5lcik7XG5cbiAgICB2YXIgaXRlbSA9IHRoaXMuaXRlbVNldC5pdGVtRnJvbVRhcmdldChldmVudCk7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5pdGVtU2V0Lmdyb3VwRnJvbVRhcmdldChldmVudCk7XG4gICAgdmFyIGN1c3RvbVRpbWUgPSBDdXN0b21UaW1lLmN1c3RvbVRpbWVGcm9tVGFyZ2V0KGV2ZW50KTtcblxuICAgIHZhciBzbmFwID0gdGhpcy5pdGVtU2V0Lm9wdGlvbnMuc25hcCB8fCBudWxsO1xuICAgIHZhciBzY2FsZSA9IHRoaXMuYm9keS51dGlsLmdldFNjYWxlKCk7XG4gICAgdmFyIHN0ZXAgPSB0aGlzLmJvZHkudXRpbC5nZXRTdGVwKCk7XG4gICAgdmFyIHRpbWUgPSB0aGlzLl90b1RpbWUoeCk7XG4gICAgdmFyIHNuYXBwZWRUaW1lID0gc25hcCA/IHNuYXAodGltZSwgc2NhbGUsIHN0ZXApIDogdGltZTtcblxuICAgIHZhciBlbGVtZW50ID0gdXRpbC5nZXRUYXJnZXQoZXZlbnQpO1xuICAgIHZhciB3aGF0ID0gbnVsbDtcbiAgICBpZiAoaXRlbSAhPSBudWxsKSB7XG4gICAgICB3aGF0ID0gJ2l0ZW0nO1xuICAgIH0gZWxzZSBpZiAoY3VzdG9tVGltZSAhPSBudWxsKSB7XG4gICAgICB3aGF0ID0gJ2N1c3RvbS10aW1lJztcbiAgICB9IGVsc2UgaWYgKHV0aWwuaGFzUGFyZW50KGVsZW1lbnQsIHRoaXMudGltZUF4aXMuZG9tLmZvcmVncm91bmQpKSB7XG4gICAgICB3aGF0ID0gJ2F4aXMnO1xuICAgIH0gZWxzZSBpZiAodGhpcy50aW1lQXhpczIgJiYgdXRpbC5oYXNQYXJlbnQoZWxlbWVudCwgdGhpcy50aW1lQXhpczIuZG9tLmZvcmVncm91bmQpKSB7XG4gICAgICB3aGF0ID0gJ2F4aXMnO1xuICAgIH0gZWxzZSBpZiAodXRpbC5oYXNQYXJlbnQoZWxlbWVudCwgdGhpcy5pdGVtU2V0LmRvbS5sYWJlbFNldCkpIHtcbiAgICAgIHdoYXQgPSAnZ3JvdXAtbGFiZWwnO1xuICAgIH0gZWxzZSBpZiAodXRpbC5oYXNQYXJlbnQoZWxlbWVudCwgdGhpcy5jdXJyZW50VGltZS5iYXIpKSB7XG4gICAgICB3aGF0ID0gJ2N1cnJlbnQtdGltZSc7XG4gICAgfSBlbHNlIGlmICh1dGlsLmhhc1BhcmVudChlbGVtZW50LCB0aGlzLmRvbS5jZW50ZXIpKSB7XG4gICAgICB3aGF0ID0gJ2JhY2tncm91bmQnO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBldmVudDogZXZlbnQsXG4gICAgICBpdGVtOiBpdGVtID8gaXRlbS5pZCA6IG51bGwsXG4gICAgICBncm91cDogZ3JvdXAgPyBncm91cC5ncm91cElkIDogbnVsbCxcbiAgICAgIHdoYXQ6IHdoYXQsXG4gICAgICBwYWdlWDogZXZlbnQuc3JjRXZlbnQgPyBldmVudC5zcmNFdmVudC5wYWdlWCA6IGV2ZW50LnBhZ2VYLFxuICAgICAgcGFnZVk6IGV2ZW50LnNyY0V2ZW50ID8gZXZlbnQuc3JjRXZlbnQucGFnZVkgOiBldmVudC5wYWdlWSxcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgdGltZTogdGltZSxcbiAgICAgIHNuYXBwZWRUaW1lOiBzbmFwcGVkVGltZVxuICAgIH07XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBUaW1lbGluZTtcblxuLyoqKi8gfSxcbi8qIDI4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9Db2xvclBpY2tlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuXG4gIHZhciBfQ29sb3JQaWNrZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29sb3JQaWNrZXIpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgLyoqXG4gICAqIFRoZSB3YXkgdGhpcyB3b3JrcyBpcyBmb3IgYWxsIHByb3BlcnRpZXMgb2YgdGhpcy5wb3NzaWJsZSBvcHRpb25zLCB5b3UgY2FuIHN1cHBseSB0aGUgcHJvcGVydHkgbmFtZSBpbiBhbnkgZm9ybSB0byBsaXN0IHRoZSBvcHRpb25zLlxuICAgKiBCb29sZWFuIG9wdGlvbnMgYXJlIHJlY29nbmlzZWQgYXMgQm9vbGVhblxuICAgKiBOdW1iZXIgb3B0aW9ucyBzaG91bGQgYmUgd3JpdHRlbiBhcyBhcnJheTogW2RlZmF1bHQgdmFsdWUsIG1pbiB2YWx1ZSwgbWF4IHZhbHVlLCBzdGVwc2l6ZV1cbiAgICogQ29sb3JzIHNob3VsZCBiZSB3cml0dGVuIGFzIGFycmF5OiBbJ2NvbG9yJywgJyNmZmZmZmYnXVxuICAgKiBTdHJpbmdzIHdpdGggc2hvdWxkIGJlIHdyaXR0ZW4gYXMgYXJyYXk6IFtvcHRpb24xLCBvcHRpb24yLCBvcHRpb24zLCAuLl1cbiAgICpcbiAgICogVGhlIG9wdGlvbnMgYXJlIG1hdGNoZWQgd2l0aCB0aGVpciBjb3VudGVycGFydHMgaW4gZWFjaCBvZiB0aGUgbW9kdWxlcyBhbmQgdGhlIHZhbHVlcyB1c2VkIGluIHRoZSBjb25maWd1cmF0aW9uIGFyZVxuICAgKlxuICAgKiBAcGFyYW0gcGFyZW50TW9kdWxlICAgICAgICB8IHRoZSBsb2NhdGlvbiB3aGVyZSBwYXJlbnRNb2R1bGUuc2V0T3B0aW9ucygpIGNhbiBiZSBjYWxsZWRcbiAgICogQHBhcmFtIGRlZmF1bHRDb250YWluZXIgICAgfCB0aGUgZGVmYXVsdCBjb250YWluZXIgb2YgdGhlIG1vZHVsZVxuICAgKiBAcGFyYW0gY29uZmlndXJlT3B0aW9ucyAgICB8IHRoZSBmdWxseSBjb25maWd1cmVkIGFuZCBwcmVkZWZpbmVkIG9wdGlvbnMgc2V0IGZvdW5kIGluIGFsbE9wdGlvbnMuanNcbiAgICogQHBhcmFtIHBpeGVsUmF0aW8gICAgICAgICAgfCBjYW52YXMgcGl4ZWwgcmF0aW9cbiAgICovXG4gIHZhciBDb25maWd1cmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29uZmlndXJhdG9yKHBhcmVudE1vZHVsZSwgZGVmYXVsdENvbnRhaW5lciwgY29uZmlndXJlT3B0aW9ucykge1xuICAgICAgdmFyIHBpeGVsUmF0aW8gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDE7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25maWd1cmF0b3IpO1xuXG4gICAgICB0aGlzLnBhcmVudCA9IHBhcmVudE1vZHVsZTtcbiAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMgPSBbXTtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gZGVmYXVsdENvbnRhaW5lcjtcbiAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IGZhbHNlO1xuXG4gICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMucG9wdXBDb3VudGVyID0gMDtcbiAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBmaWx0ZXI6IHRydWUsXG4gICAgICAgIGNvbnRhaW5lcjogdW5kZWZpbmVkLFxuICAgICAgICBzaG93QnV0dG9uOiB0cnVlXG4gICAgICB9O1xuICAgICAgdXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgICAgdGhpcy5jb25maWd1cmVPcHRpb25zID0gY29uZmlndXJlT3B0aW9ucztcbiAgICAgIHRoaXMubW9kdWxlT3B0aW9ucyA9IHt9O1xuICAgICAgdGhpcy5kb21FbGVtZW50cyA9IFtdO1xuICAgICAgdGhpcy5wb3B1cERpdiA9IHt9O1xuICAgICAgdGhpcy5wb3B1cExpbWl0ID0gNTtcbiAgICAgIHRoaXMucG9wdXBIaXN0b3J5ID0ge307XG4gICAgICB0aGlzLmNvbG9yUGlja2VyID0gbmV3IF9Db2xvclBpY2tlcjIuZGVmYXVsdChwaXhlbFJhdGlvKTtcbiAgICAgIHRoaXMud3JhcHBlciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZWZyZXNoIGFsbCBvcHRpb25zLlxuICAgICAqIEJlY2F1c2UgYWxsIG1vZHVsZXMgcGFyc2UgdGhlaXIgb3B0aW9ucyBieSB0aGVtc2VsdmVzLCB3ZSBqdXN0IHVzZSB0aGVpciBvcHRpb25zLiBXZSBjb3B5IHRoZW0gaGVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhDb25maWd1cmF0b3IsIFt7XG4gICAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHJlc2V0IHRoZSBwb3B1cCBoaXN0b3J5IGJlY2F1c2UgdGhlIGluZGljZXMgbWF5IGhhdmUgYmVlbiBjaGFuZ2VkLlxuICAgICAgICAgIHRoaXMucG9wdXBIaXN0b3J5ID0ge307XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlUG9wdXAoKTtcblxuICAgICAgICAgIHZhciBlbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gb3B0aW9ucztcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlciA9IG9wdGlvbnMuam9pbigpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvcHRpb25zKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5maWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG93QnV0dG9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNob3dCdXR0b24gPSBvcHRpb25zLnNob3dCdXR0b247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5lbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZW5hYmxlZCA9IG9wdGlvbnMuZW5hYmxlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgZW5hYmxlZCA9IG9wdGlvbnM7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlciA9IG9wdGlvbnM7XG4gICAgICAgICAgICBlbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5maWx0ZXIgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBlbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NsZWFuKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0TW9kdWxlT3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TW9kdWxlT3B0aW9ucyhtb2R1bGVPcHRpb25zKSB7XG4gICAgICAgIHRoaXMubW9kdWxlT3B0aW9ucyA9IG1vZHVsZU9wdGlvbnM7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuX2NsZWFuKCk7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jcmVhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSBhbGwgRE9NIGVsZW1lbnRzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY3JlYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX2NsZWFuKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMgPSBbXTtcblxuICAgICAgICB2YXIgZmlsdGVyID0gdGhpcy5vcHRpb25zLmZpbHRlcjtcbiAgICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgICB2YXIgc2hvdyA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBvcHRpb24gaW4gdGhpcy5jb25maWd1cmVPcHRpb25zKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJlT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSB7XG4gICAgICAgICAgICB0aGlzLmFsbG93Q3JlYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIHNob3cgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHNob3cgPSBmaWx0ZXIob3B0aW9uLCBbXSk7XG4gICAgICAgICAgICAgIHNob3cgPSBzaG93IHx8IHRoaXMuX2hhbmRsZU9iamVjdCh0aGlzLmNvbmZpZ3VyZU9wdGlvbnNbb3B0aW9uXSwgW29wdGlvbl0sIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWx0ZXIgPT09IHRydWUgfHwgZmlsdGVyLmluZGV4T2Yob3B0aW9uKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgc2hvdyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaG93ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICB0aGlzLmFsbG93Q3JlYXRpb24gPSB0cnVlO1xuXG4gICAgICAgICAgICAgIC8vIGxpbmVicmVhayBiZXR3ZWVuIGNhdGVnb3JpZXNcbiAgICAgICAgICAgICAgaWYgKGNvdW50ZXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFrZUl0ZW0oW10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGEgaGVhZGVyIGZvciB0aGUgY2F0ZWdvcnlcbiAgICAgICAgICAgICAgdGhpcy5fbWFrZUhlYWRlcihvcHRpb24pO1xuXG4gICAgICAgICAgICAgIC8vIGdldCB0aGUgc3ViIG9wdGlvbnNcbiAgICAgICAgICAgICAgdGhpcy5faGFuZGxlT2JqZWN0KHRoaXMuY29uZmlndXJlT3B0aW9uc1tvcHRpb25dLCBbb3B0aW9uXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93QnV0dG9uID09PSB0cnVlKSB7XG4gICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBnZW5lcmF0ZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZ2VuZXJhdGVCdXR0b24uY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctYnV0dG9uJztcbiAgICAgICAgICAgIGdlbmVyYXRlQnV0dG9uLmlubmVySFRNTCA9ICdnZW5lcmF0ZSBvcHRpb25zJztcbiAgICAgICAgICAgIGdlbmVyYXRlQnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzLl9wcmludE9wdGlvbnMoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5vbm1vdXNlb3ZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZ2VuZXJhdGVCdXR0b24uY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctYnV0dG9uIGhvdmVyJztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5vbm1vdXNlb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1idXR0b24nO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgX3RoaXMub3B0aW9uc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgX3RoaXMub3B0aW9uc0NvbnRhaW5lci5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1vcHRpb24tY29udGFpbmVyJztcblxuICAgICAgICAgICAgX3RoaXMuZG9tRWxlbWVudHMucHVzaChfdGhpcy5vcHRpb25zQ29udGFpbmVyKTtcbiAgICAgICAgICAgIF90aGlzLmRvbUVsZW1lbnRzLnB1c2goZ2VuZXJhdGVCdXR0b24pO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wdXNoKCk7XG4gICAgICAgIC8vfiB0aGlzLmNvbG9yUGlja2VyLmluc2VydFRvKHRoaXMuY29udGFpbmVyKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBkcmF3IGFsbCBET00gZWxlbWVudHMgb24gdGhlIHNjcmVlblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3B1c2gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wdXNoKCkge1xuICAgICAgICB0aGlzLndyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy53cmFwcGVyLmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbi13cmFwcGVyJztcbiAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy53cmFwcGVyKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRvbUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuZG9tRWxlbWVudHNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2hvd1BvcHVwSWZOZWVkZWQoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBkZWxldGUgYWxsIERPTSBlbGVtZW50c1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NsZWFuJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xlYW4oKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kb21FbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMud3JhcHBlci5yZW1vdmVDaGlsZCh0aGlzLmRvbUVsZW1lbnRzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLndyYXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMud3JhcHBlcik7XG4gICAgICAgICAgdGhpcy53cmFwcGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHMgPSBbXTtcblxuICAgICAgICB0aGlzLl9yZW1vdmVQb3B1cCgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgYWN0dWFsT3B0aW9ucyBpZiBpdCBleGlzdHNcbiAgICAgICAqIEBwYXJhbSB7YXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0VmFsdWUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRWYWx1ZShwYXRoKSB7XG4gICAgICAgIHZhciBiYXNlID0gdGhpcy5tb2R1bGVPcHRpb25zO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoYmFzZVtwYXRoW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBiYXNlID0gYmFzZVtwYXRoW2ldXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBhbGwgb3B0aW9uIGVsZW1lbnRzIGFyZSB3cmFwcGVkIGluIGFuIGl0ZW1cbiAgICAgICAqIEBwYXJhbSBwYXRoXG4gICAgICAgKiBAcGFyYW0gZG9tRWxlbWVudHNcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19tYWtlSXRlbScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VJdGVtKHBhdGgpIHtcbiAgICAgICAgdmFyIF9hcmd1bWVudHMgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLmFsbG93Q3JlYXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgX2xlbiwgZG9tRWxlbWVudHMsIF9rZXk7XG5cbiAgICAgICAgICB2YXIgX3JldDIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgaXRlbS5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1pdGVtIHZpcy1jb25maWctcycgKyBwYXRoLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yIChfbGVuID0gX2FyZ3VtZW50cy5sZW5ndGgsIGRvbUVsZW1lbnRzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgICBkb21FbGVtZW50c1tfa2V5IC0gMV0gPSBfYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkb21FbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgIGl0ZW0uYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzMi5kb21FbGVtZW50cy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdjogX3RoaXMyLmRvbUVsZW1lbnRzLmxlbmd0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBpZiAoKHR5cGVvZiBfcmV0MiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoX3JldDIpKSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQyLnY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogaGVhZGVyIGZvciBtYWpvciBzdWJqZWN0c1xuICAgICAgICogQHBhcmFtIG5hbWVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19tYWtlSGVhZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZUhlYWRlcihuYW1lKSB7XG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZGl2LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWhlYWRlcic7XG4gICAgICAgIGRpdi5pbm5lckhUTUwgPSBuYW1lO1xuICAgICAgICB0aGlzLl9tYWtlSXRlbShbXSwgZGl2KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBtYWtlIGEgbGFiZWwsIGlmIGl0IGlzIGFuIG9iamVjdCBsYWJlbCwgaXQgZ2V0cyBkaWZmZXJlbnQgc3R5bGluZy5cbiAgICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICAgKiBAcGFyYW0gcGF0aFxuICAgICAgICogQHBhcmFtIG9iamVjdExhYmVsXG4gICAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbWFrZUxhYmVsJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZUxhYmVsKG5hbWUsIHBhdGgpIHtcbiAgICAgICAgdmFyIG9iamVjdExhYmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRpdi5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1sYWJlbCB2aXMtY29uZmlnLXMnICsgcGF0aC5sZW5ndGg7XG4gICAgICAgIGlmIChvYmplY3RMYWJlbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSAnPGk+PGI+JyArIG5hbWUgKyAnOjwvYj48L2k+JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gbmFtZSArICc6JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGl2O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIG1ha2UgYSBkcm9wZG93biBsaXN0IGZvciBtdWx0aXBsZSBwb3NzaWJsZSBzdHJpbmcgb3B0b2luc1xuICAgICAgICogQHBhcmFtIGFyclxuICAgICAgICogQHBhcmFtIHZhbHVlXG4gICAgICAgKiBAcGFyYW0gcGF0aFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX21ha2VEcm9wZG93bicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VEcm9wZG93bihhcnIsIHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHZhciBzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICAgICAgc2VsZWN0LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXNlbGVjdCc7XG4gICAgICAgIHZhciBzZWxlY3RlZFZhbHVlID0gMDtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoYXJyLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZSA9IGFyci5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgICAgICBvcHRpb24udmFsdWUgPSBhcnJbaV07XG4gICAgICAgICAgaWYgKGkgPT09IHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9ICdzZWxlY3RlZCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wdGlvbi5pbm5lckhUTUwgPSBhcnJbaV07XG4gICAgICAgICAgc2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBzZWxlY3Qub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWUuX3VwZGF0ZSh0aGlzLnZhbHVlLCBwYXRoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBwYXRoKTtcbiAgICAgICAgdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIHNlbGVjdCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogbWFrZSBhIHJhbmdlIG9iamVjdCBmb3IgbnVtZXJpYyBvcHRpb25zXG4gICAgICAgKiBAcGFyYW0gYXJyXG4gICAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgICAqIEBwYXJhbSBwYXRoXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbWFrZVJhbmdlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZVJhbmdlKGFyciwgdmFsdWUsIHBhdGgpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGFyclswXTtcbiAgICAgICAgdmFyIG1pbiA9IGFyclsxXTtcbiAgICAgICAgdmFyIG1heCA9IGFyclsyXTtcbiAgICAgICAgdmFyIHN0ZXAgPSBhcnJbM107XG4gICAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIHJhbmdlLmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXJhbmdlJztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByYW5nZS50eXBlID0gJ3JhbmdlJzsgLy8gbm90IHN1cHBvcnRlZCBvbiBJRTlcbiAgICAgICAgICByYW5nZS5taW4gPSBtaW47XG4gICAgICAgICAgcmFuZ2UubWF4ID0gbWF4O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIHJhbmdlLnN0ZXAgPSBzdGVwO1xuXG4gICAgICAgIC8vIHNldCB1cCB0aGUgcG9wdXAgc2V0dGluZ3MgaW4gY2FzZSB0aGV5IGFyZSBuZWVkZWQuXG4gICAgICAgIHZhciBwb3B1cFN0cmluZyA9ICcnO1xuICAgICAgICB2YXIgcG9wdXBWYWx1ZSA9IDA7XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZmFjdG9yID0gMS4yMDtcbiAgICAgICAgICBpZiAodmFsdWUgPCAwICYmIHZhbHVlICogZmFjdG9yIDwgbWluKSB7XG4gICAgICAgICAgICByYW5nZS5taW4gPSBNYXRoLmNlaWwodmFsdWUgKiBmYWN0b3IpO1xuICAgICAgICAgICAgcG9wdXBWYWx1ZSA9IHJhbmdlLm1pbjtcbiAgICAgICAgICAgIHBvcHVwU3RyaW5nID0gJ3JhbmdlIGluY3JlYXNlZCc7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAvIGZhY3RvciA8IG1pbikge1xuICAgICAgICAgICAgcmFuZ2UubWluID0gTWF0aC5jZWlsKHZhbHVlIC8gZmFjdG9yKTtcbiAgICAgICAgICAgIHBvcHVwVmFsdWUgPSByYW5nZS5taW47XG4gICAgICAgICAgICBwb3B1cFN0cmluZyA9ICdyYW5nZSBpbmNyZWFzZWQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgKiBmYWN0b3IgPiBtYXggJiYgbWF4ICE9PSAxKSB7XG4gICAgICAgICAgICByYW5nZS5tYXggPSBNYXRoLmNlaWwodmFsdWUgKiBmYWN0b3IpO1xuICAgICAgICAgICAgcG9wdXBWYWx1ZSA9IHJhbmdlLm1heDtcbiAgICAgICAgICAgIHBvcHVwU3RyaW5nID0gJ3JhbmdlIGluY3JlYXNlZCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJhbmdlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmFuZ2UudmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBpbnB1dC5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1yYW5nZWlucHV0JztcbiAgICAgICAgaW5wdXQudmFsdWUgPSByYW5nZS52YWx1ZTtcblxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICByYW5nZS5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpbnB1dC52YWx1ZSA9IHRoaXMudmFsdWU7bWUuX3VwZGF0ZShOdW1iZXIodGhpcy52YWx1ZSksIHBhdGgpO1xuICAgICAgICB9O1xuICAgICAgICByYW5nZS5vbmlucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlucHV0LnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBwYXRoKTtcbiAgICAgICAgdmFyIGl0ZW1JbmRleCA9IHRoaXMuX21ha2VJdGVtKHBhdGgsIGxhYmVsLCByYW5nZSwgaW5wdXQpO1xuXG4gICAgICAgIC8vIGlmIGEgcG9wdXAgaXMgbmVlZGVkIEFORCBpdCBoYXMgbm90IGJlZW4gc2hvd24gZm9yIHRoaXMgdmFsdWUsIHNob3cgaXQuXG4gICAgICAgIGlmIChwb3B1cFN0cmluZyAhPT0gJycgJiYgdGhpcy5wb3B1cEhpc3RvcnlbaXRlbUluZGV4XSAhPT0gcG9wdXBWYWx1ZSkge1xuICAgICAgICAgIHRoaXMucG9wdXBIaXN0b3J5W2l0ZW1JbmRleF0gPSBwb3B1cFZhbHVlO1xuICAgICAgICAgIHRoaXMuX3NldHVwUG9wdXAocG9wdXBTdHJpbmcsIGl0ZW1JbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBwcmVwYXJlIHRoZSBwb3B1cFxuICAgICAgICogQHBhcmFtIHN0cmluZ1xuICAgICAgICogQHBhcmFtIGluZGV4XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0dXBQb3B1cCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwUG9wdXAoc3RyaW5nLCBpbmRleCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5pbml0aWFsaXplZCA9PT0gdHJ1ZSAmJiB0aGlzLmFsbG93Q3JlYXRpb24gPT09IHRydWUgJiYgdGhpcy5wb3B1cENvdW50ZXIgPCB0aGlzLnBvcHVwTGltaXQpIHtcbiAgICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICBkaXYuaWQgPSBcInZpcy1jb25maWd1cmF0aW9uLXBvcHVwXCI7XG4gICAgICAgICAgZGl2LmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24tcG9wdXBcIjtcbiAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gc3RyaW5nO1xuICAgICAgICAgIGRpdi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLl9yZW1vdmVQb3B1cCgpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5wb3B1cENvdW50ZXIgKz0gMTtcbiAgICAgICAgICB0aGlzLnBvcHVwRGl2ID0geyBodG1sOiBkaXYsIGluZGV4OiBpbmRleCB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogcmVtb3ZlIHRoZSBwb3B1cCBmcm9tIHRoZSBkb21cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19yZW1vdmVQb3B1cCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZVBvcHVwKCkge1xuICAgICAgICBpZiAodGhpcy5wb3B1cERpdi5odG1sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnBvcHVwRGl2Lmh0bWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHVwRGl2Lmh0bWwpO1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBvcHVwRGl2LmhpZGVUaW1lb3V0KTtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wb3B1cERpdi5kZWxldGVUaW1lb3V0KTtcbiAgICAgICAgICB0aGlzLnBvcHVwRGl2ID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTaG93IHRoZSBwb3B1cCBpZiBpdCBpcyBuZWVkZWQuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2hvd1BvcHVwSWZOZWVkZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG93UG9wdXBJZk5lZWRlZCgpIHtcbiAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMucG9wdXBEaXYuaHRtbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGNvcnJlc3BvbmRpbmdFbGVtZW50ID0gdGhpcy5kb21FbGVtZW50c1t0aGlzLnBvcHVwRGl2LmluZGV4XTtcbiAgICAgICAgICB2YXIgcmVjdCA9IGNvcnJlc3BvbmRpbmdFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIHRoaXMucG9wdXBEaXYuaHRtbC5zdHlsZS5sZWZ0ID0gcmVjdC5sZWZ0ICsgXCJweFwiO1xuICAgICAgICAgIHRoaXMucG9wdXBEaXYuaHRtbC5zdHlsZS50b3AgPSByZWN0LnRvcCAtIDMwICsgXCJweFwiOyAvLyAzMCBpcyB0aGUgaGVpZ2h0O1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5wb3B1cERpdi5odG1sKTtcbiAgICAgICAgICB0aGlzLnBvcHVwRGl2LmhpZGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczQucG9wdXBEaXYuaHRtbC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgICB9LCAxNTAwKTtcbiAgICAgICAgICB0aGlzLnBvcHVwRGl2LmRlbGV0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzNC5fcmVtb3ZlUG9wdXAoKTtcbiAgICAgICAgICB9LCAxODAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIG1ha2UgYSBjaGVja2JveCBmb3IgYm9vbGVhbiBvcHRpb25zLlxuICAgICAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZVxuICAgICAgICogQHBhcmFtIHZhbHVlXG4gICAgICAgKiBAcGFyYW0gcGF0aFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX21ha2VDaGVja2JveCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VDaGVja2JveChkZWZhdWx0VmFsdWUsIHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHZhciBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGNoZWNrYm94LnR5cGUgPSAnY2hlY2tib3gnO1xuICAgICAgICBjaGVja2JveC5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1jaGVja2JveCc7XG4gICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IHZhbHVlO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGRlZmF1bHRWYWx1ZSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IGRlZmF1bHRWYWx1ZS5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHsgcGF0aDogcGF0aCwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goeyBwYXRoOiBwYXRoLCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgY2hlY2tib3gub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWUuX3VwZGF0ZSh0aGlzLmNoZWNrZWQsIHBhdGgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuICAgICAgICB0aGlzLl9tYWtlSXRlbShwYXRoLCBsYWJlbCwgY2hlY2tib3gpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIG1ha2UgYSB0ZXh0IGlucHV0IGZpZWxkIGZvciBzdHJpbmcgb3B0aW9ucy5cbiAgICAgICAqIEBwYXJhbSBkZWZhdWx0VmFsdWVcbiAgICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAgICogQHBhcmFtIHBhdGhcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19tYWtlVGV4dElucHV0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZVRleHRJbnB1dChkZWZhdWx0VmFsdWUsIHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHZhciBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGNoZWNrYm94LnR5cGUgPSAndGV4dCc7XG4gICAgICAgIGNoZWNrYm94LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXRleHQnO1xuICAgICAgICBjaGVja2JveC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgIT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7IHBhdGg6IHBhdGgsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGNoZWNrYm94Lm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1lLl91cGRhdGUodGhpcy52YWx1ZSwgcGF0aCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHBhdGhbcGF0aC5sZW5ndGggLSAxXSwgcGF0aCk7XG4gICAgICAgIHRoaXMuX21ha2VJdGVtKHBhdGgsIGxhYmVsLCBjaGVja2JveCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogbWFrZSBhIGNvbG9yIGZpZWxkIHdpdGggYSBjb2xvciBwaWNrZXIgZm9yIGNvbG9yIGZpZWxkc1xuICAgICAgICogQHBhcmFtIGFyclxuICAgICAgICogQHBhcmFtIHZhbHVlXG4gICAgICAgKiBAcGFyYW0gcGF0aFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX21ha2VDb2xvckZpZWxkJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZUNvbG9yRmllbGQoYXJyLCB2YWx1ZSwgcGF0aCkge1xuICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgICB2YXIgZGVmYXVsdENvbG9yID0gYXJyWzFdO1xuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb2xvciA6IHZhbHVlO1xuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgZGl2LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWNvbG9yQmxvY2snO1xuICAgICAgICAgIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaXYuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctY29sb3JCbG9jayBub25lJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb2xvciA6IHZhbHVlO1xuICAgICAgICBkaXYub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczUuX3Nob3dDb2xvclBpY2tlcih2YWx1ZSwgZGl2LCBwYXRoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBwYXRoKTtcbiAgICAgICAgdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIGRpdik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdXNlZCBieSB0aGUgY29sb3IgYnV0dG9ucyB0byBjYWxsIHRoZSBjb2xvciBwaWNrZXIuXG4gICAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAgICogQHBhcmFtIGRpdlxuICAgICAgICogQHBhcmFtIHBhdGhcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zaG93Q29sb3JQaWNrZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG93Q29sb3JQaWNrZXIodmFsdWUsIGRpdiwgcGF0aCkge1xuICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgICAvLyBjbGVhciB0aGUgY2FsbGJhY2sgZnJvbSB0aGlzIGRpdlxuICAgICAgICBkaXYub25jbGljayA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXIuaW5zZXJ0VG8oZGl2KTtcbiAgICAgICAgdGhpcy5jb2xvclBpY2tlci5zaG93KCk7XG5cbiAgICAgICAgdGhpcy5jb2xvclBpY2tlci5zZXRDb2xvcih2YWx1ZSk7XG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXIuc2V0VXBkYXRlQ2FsbGJhY2soZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgICAgdmFyIGNvbG9yU3RyaW5nID0gJ3JnYmEoJyArIGNvbG9yLnIgKyAnLCcgKyBjb2xvci5nICsgJywnICsgY29sb3IuYiArICcsJyArIGNvbG9yLmEgKyAnKSc7XG4gICAgICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yU3RyaW5nO1xuICAgICAgICAgIF90aGlzNi5fdXBkYXRlKGNvbG9yU3RyaW5nLCBwYXRoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gb24gY2xvc2Ugb2YgdGhlIGNvbG9ycGlja2VyLCByZXN0b3JlIHRoZSBjYWxsYmFjay5cbiAgICAgICAgdGhpcy5jb2xvclBpY2tlci5zZXRDbG9zZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkaXYub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzNi5fc2hvd0NvbG9yUGlja2VyKHZhbHVlLCBkaXYsIHBhdGgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHBhcnNlIGFuIG9iamVjdCBhbmQgZHJhdyB0aGUgY29ycmVjdCBpdGVtc1xuICAgICAgICogQHBhcmFtIG9ialxuICAgICAgICogQHBhcmFtIHBhdGhcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19oYW5kbGVPYmplY3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVPYmplY3Qob2JqKSB7XG4gICAgICAgIHZhciBwYXRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgICAgICAgdmFyIGNoZWNrT25seSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgICAgdmFyIHNob3cgPSBmYWxzZTtcbiAgICAgICAgdmFyIGZpbHRlciA9IHRoaXMub3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIHZhciB2aXNpYmxlSW5TZXQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgc3ViT2JqIGluIG9iaikge1xuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoc3ViT2JqKSkge1xuICAgICAgICAgICAgc2hvdyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IG9ialtzdWJPYmpdO1xuICAgICAgICAgICAgdmFyIG5ld1BhdGggPSB1dGlsLmNvcHlBbmRFeHRlbmRBcnJheShwYXRoLCBzdWJPYmopO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgc2hvdyA9IGZpbHRlcihzdWJPYmosIHBhdGgpO1xuXG4gICAgICAgICAgICAgIC8vIGlmIG5lZWRlZCB3ZSBtdXN0IGdvIGRlZXBlciBpbnRvIHRoZSBvYmplY3QuXG4gICAgICAgICAgICAgIGlmIChzaG93ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBBcnJheSkgJiYgdHlwZW9mIGl0ZW0gIT09ICdzdHJpbmcnICYmIHR5cGVvZiBpdGVtICE9PSAnYm9vbGVhbicgJiYgaXRlbSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBzaG93ID0gdGhpcy5faGFuZGxlT2JqZWN0KGl0ZW0sIG5ld1BhdGgsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gY2hlY2tPbmx5ID09PSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNob3cgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHZpc2libGVJblNldCA9IHRydWU7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldFZhbHVlKG5ld1BhdGgpO1xuXG4gICAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVBcnJheShpdGVtLCB2YWx1ZSwgbmV3UGF0aCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFrZVRleHRJbnB1dChpdGVtLCB2YWx1ZSwgbmV3UGF0aCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX21ha2VDaGVja2JveChpdGVtLCB2YWx1ZSwgbmV3UGF0aCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbGxhcHNlIHRoZSBwaHlzaWNzIG9wdGlvbnMgdGhhdCBhcmUgbm90IGVuYWJsZWRcbiAgICAgICAgICAgICAgICB2YXIgZHJhdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGguaW5kZXhPZigncGh5c2ljcycpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubW9kdWxlT3B0aW9ucy5waHlzaWNzLnNvbHZlciAhPT0gc3ViT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYXcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZHJhdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhbGx5IGNvbGxhcHNlIG9wdGlvbnMgd2l0aCBhbiBkaXNhYmxlZCBlbmFibGVkIG9wdGlvbi5cbiAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmVuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5hYmxlZFBhdGggPSB1dGlsLmNvcHlBbmRFeHRlbmRBcnJheShuZXdQYXRoLCAnZW5hYmxlZCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5hYmxlZFZhbHVlID0gdGhpcy5fZ2V0VmFsdWUoZW5hYmxlZFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5hYmxlZFZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHN1Yk9iaiwgbmV3UGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFrZUl0ZW0obmV3UGF0aCwgbGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICAgIHZpc2libGVJblNldCA9IHRoaXMuX2hhbmRsZU9iamVjdChpdGVtLCBuZXdQYXRoKSB8fCB2aXNpYmxlSW5TZXQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFrZUNoZWNrYm94KGl0ZW0sIGVuYWJsZWRWYWx1ZSwgbmV3UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwoc3ViT2JqLCBuZXdQYXRoLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFrZUl0ZW0obmV3UGF0aCwgX2xhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZUluU2V0ID0gdGhpcy5faGFuZGxlT2JqZWN0KGl0ZW0sIG5ld1BhdGgpIHx8IHZpc2libGVJblNldDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignZG9udCBrbm93IGhvdyB0byBoYW5kbGUnLCBpdGVtLCBzdWJPYmosIG5ld1BhdGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aXNpYmxlSW5TZXQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogaGFuZGxlIHRoZSBhcnJheSB0eXBlIG9mIG9wdGlvblxuICAgICAgICogQHBhcmFtIG9wdGlvbk5hbWVcbiAgICAgICAqIEBwYXJhbSBhcnJcbiAgICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAgICogQHBhcmFtIHBhdGhcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19oYW5kbGVBcnJheScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUFycmF5KGFyciwgdmFsdWUsIHBhdGgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcnJbMF0gPT09ICdzdHJpbmcnICYmIGFyclswXSA9PT0gJ2NvbG9yJykge1xuICAgICAgICAgIHRoaXMuX21ha2VDb2xvckZpZWxkKGFyciwgdmFsdWUsIHBhdGgpO1xuICAgICAgICAgIGlmIChhcnJbMV0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goeyBwYXRoOiBwYXRoLCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcnJbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5fbWFrZURyb3Bkb3duKGFyciwgdmFsdWUsIHBhdGgpO1xuICAgICAgICAgIGlmIChhcnJbMF0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goeyBwYXRoOiBwYXRoLCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcnJbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy5fbWFrZVJhbmdlKGFyciwgdmFsdWUsIHBhdGgpO1xuICAgICAgICAgIGlmIChhcnJbMF0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goeyBwYXRoOiBwYXRoLCB2YWx1ZTogTnVtYmVyKHZhbHVlKSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBjYWxsZWQgdG8gdXBkYXRlIHRoZSBuZXR3b3JrIHdpdGggdGhlIG5ldyBzZXR0aW5ncy5cbiAgICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAgICogQHBhcmFtIHBhdGhcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ191cGRhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUodmFsdWUsIHBhdGgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9jb25zdHJ1Y3RPcHRpb25zKHZhbHVlLCBwYXRoKTtcblxuICAgICAgICBpZiAodGhpcy5wYXJlbnQuYm9keSAmJiB0aGlzLnBhcmVudC5ib2R5LmVtaXR0ZXIgJiYgdGhpcy5wYXJlbnQuYm9keS5lbWl0dGVyLmVtaXQpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5ib2R5LmVtaXR0ZXIuZW1pdChcImNvbmZpZ0NoYW5nZVwiLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYXJlbnQuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY29uc3RydWN0T3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbnN0cnVjdE9wdGlvbnModmFsdWUsIHBhdGgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnNPYmogPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICAgIHZhciBwb2ludGVyID0gb3B0aW9uc09iajtcblxuICAgICAgICAvLyB3aGVuIGRyb3Bkb3duIGJveGVzIGNhbiBiZSBzdHJpbmcgb3IgYm9vbGVhbiwgd2UgdHlwZWNhc3QgaXQgaW50byBjb3JyZWN0IHR5cGVzXG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09ICd0cnVlJyA/IHRydWUgOiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogdmFsdWU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHBhdGhbaV0gIT09ICdnbG9iYWwnKSB7XG4gICAgICAgICAgICBpZiAocG9pbnRlcltwYXRoW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHBvaW50ZXJbcGF0aFtpXV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpICE9PSBwYXRoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXJbcGF0aFtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwb2ludGVyW3BhdGhbaV1dID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zT2JqO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19wcmludE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wcmludE9wdGlvbnMoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgICAgIHRoaXMub3B0aW9uc0NvbnRhaW5lci5pbm5lckhUTUwgPSAnPHByZT52YXIgb3B0aW9ucyA9ICcgKyBKU09OLnN0cmluZ2lmeShvcHRpb25zLCBudWxsLCAyKSArICc8L3ByZT4nO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGFuZ2VkT3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuX2NvbnN0cnVjdE9wdGlvbnModGhpcy5jaGFuZ2VkT3B0aW9uc1tpXS52YWx1ZSwgdGhpcy5jaGFuZ2VkT3B0aW9uc1tpXS5wYXRoLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ29uZmlndXJhdG9yO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gQ29uZmlndXJhdG9yO1xuXG4vKioqLyB9LFxuLyogMjkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIEhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuICB2YXIgaGFtbWVyVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIENvbG9yUGlja2VyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbG9yUGlja2VyKCkge1xuICAgICAgdmFyIHBpeGVsUmF0aW8gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDE7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb2xvclBpY2tlcik7XG5cbiAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgICB0aGlzLmdlbmVyYXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5jZW50ZXJDb29yZGluYXRlcyA9IHsgeDogMjg5IC8gMiwgeTogMjg5IC8gMiB9O1xuICAgICAgdGhpcy5yID0gMjg5ICogMC40OTtcbiAgICAgIHRoaXMuY29sb3IgPSB7IHI6IDI1NSwgZzogMjU1LCBiOiAyNTUsIGE6IDEuMCB9O1xuICAgICAgdGhpcy5odWVDaXJjbGUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmluaXRpYWxDb2xvciA9IHsgcjogMjU1LCBnOiAyNTUsIGI6IDI1NSwgYTogMS4wIH07XG4gICAgICB0aGlzLnByZXZpb3VzQ29sb3IgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmFwcGxpZWQgPSBmYWxzZTtcblxuICAgICAgLy8gYm91bmQgYnlcbiAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIHRoaXMuY2xvc2VDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAvLyBjcmVhdGUgYWxsIERPTSBlbGVtZW50c1xuICAgICAgdGhpcy5fY3JlYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhpcyBpbnNlcnRzIHRoZSBjb2xvclBpY2tlciBpbnRvIGEgZGl2IGZyb20gdGhlIERPTVxuICAgICAqIEBwYXJhbSBjb250YWluZXJcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKENvbG9yUGlja2VyLCBbe1xuICAgICAga2V5OiAnaW5zZXJ0VG8nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydFRvKGNvbnRhaW5lcikge1xuICAgICAgICBpZiAodGhpcy5oYW1tZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuaGFtbWVyLmRlc3Ryb3koKTtcbiAgICAgICAgICB0aGlzLmhhbW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZSk7XG4gICAgICAgIHRoaXMuX2JpbmRIYW1tZXIoKTtcblxuICAgICAgICB0aGlzLl9zZXRTaXplKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdGhlIGNhbGxiYWNrIGlzIGV4ZWN1dGVkIG9uIGFwcGx5IGFuZCBzYXZlLiBCaW5kIGl0IHRvIHRoZSBhcHBsaWNhdGlvblxuICAgICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldFVwZGF0ZUNhbGxiYWNrJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVcGRhdGVDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGF0dGVtcHRlZCB0byBzZXQgYXMgY29sb3JQaWNrZXIgdXBkYXRlIGNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHRoZSBjYWxsYmFjayBpcyBleGVjdXRlZCBvbiBhcHBseSBhbmQgc2F2ZS4gQmluZCBpdCB0byB0aGUgYXBwbGljYXRpb25cbiAgICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRDbG9zZUNhbGxiYWNrJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDbG9zZUNhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBhdHRlbXB0ZWQgdG8gc2V0IGFzIGNvbG9yUGlja2VyIGNsb3NpbmcgY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb24uXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2lzQ29sb3JTdHJpbmcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pc0NvbG9yU3RyaW5nKGNvbG9yKSB7XG4gICAgICAgIHZhciBodG1sQ29sb3JzID0geyBibGFjazogJyMwMDAwMDAnLCBuYXZ5OiAnIzAwMDA4MCcsIGRhcmtibHVlOiAnIzAwMDA4QicsIG1lZGl1bWJsdWU6ICcjMDAwMENEJywgYmx1ZTogJyMwMDAwRkYnLCBkYXJrZ3JlZW46ICcjMDA2NDAwJywgZ3JlZW46ICcjMDA4MDAwJywgdGVhbDogJyMwMDgwODAnLCBkYXJrY3lhbjogJyMwMDhCOEInLCBkZWVwc2t5Ymx1ZTogJyMwMEJGRkYnLCBkYXJrdHVycXVvaXNlOiAnIzAwQ0VEMScsIG1lZGl1bXNwcmluZ2dyZWVuOiAnIzAwRkE5QScsIGxpbWU6ICcjMDBGRjAwJywgc3ByaW5nZ3JlZW46ICcjMDBGRjdGJywgYXF1YTogJyMwMEZGRkYnLCBjeWFuOiAnIzAwRkZGRicsIG1pZG5pZ2h0Ymx1ZTogJyMxOTE5NzAnLCBkb2RnZXJibHVlOiAnIzFFOTBGRicsIGxpZ2h0c2VhZ3JlZW46ICcjMjBCMkFBJywgZm9yZXN0Z3JlZW46ICcjMjI4QjIyJywgc2VhZ3JlZW46ICcjMkU4QjU3JywgZGFya3NsYXRlZ3JheTogJyMyRjRGNEYnLCBsaW1lZ3JlZW46ICcjMzJDRDMyJywgbWVkaXVtc2VhZ3JlZW46ICcjM0NCMzcxJywgdHVycXVvaXNlOiAnIzQwRTBEMCcsIHJveWFsYmx1ZTogJyM0MTY5RTEnLCBzdGVlbGJsdWU6ICcjNDY4MkI0JywgZGFya3NsYXRlYmx1ZTogJyM0ODNEOEInLCBtZWRpdW10dXJxdW9pc2U6ICcjNDhEMUNDJywgaW5kaWdvOiAnIzRCMDA4MicsIGRhcmtvbGl2ZWdyZWVuOiAnIzU1NkIyRicsIGNhZGV0Ymx1ZTogJyM1RjlFQTAnLCBjb3JuZmxvd2VyYmx1ZTogJyM2NDk1RUQnLCBtZWRpdW1hcXVhbWFyaW5lOiAnIzY2Q0RBQScsIGRpbWdyYXk6ICcjNjk2OTY5Jywgc2xhdGVibHVlOiAnIzZBNUFDRCcsIG9saXZlZHJhYjogJyM2QjhFMjMnLCBzbGF0ZWdyYXk6ICcjNzA4MDkwJywgbGlnaHRzbGF0ZWdyYXk6ICcjNzc4ODk5JywgbWVkaXVtc2xhdGVibHVlOiAnIzdCNjhFRScsIGxhd25ncmVlbjogJyM3Q0ZDMDAnLCBjaGFydHJldXNlOiAnIzdGRkYwMCcsIGFxdWFtYXJpbmU6ICcjN0ZGRkQ0JywgbWFyb29uOiAnIzgwMDAwMCcsIHB1cnBsZTogJyM4MDAwODAnLCBvbGl2ZTogJyM4MDgwMDAnLCBncmF5OiAnIzgwODA4MCcsIHNreWJsdWU6ICcjODdDRUVCJywgbGlnaHRza3libHVlOiAnIzg3Q0VGQScsIGJsdWV2aW9sZXQ6ICcjOEEyQkUyJywgZGFya3JlZDogJyM4QjAwMDAnLCBkYXJrbWFnZW50YTogJyM4QjAwOEInLCBzYWRkbGVicm93bjogJyM4QjQ1MTMnLCBkYXJrc2VhZ3JlZW46ICcjOEZCQzhGJywgbGlnaHRncmVlbjogJyM5MEVFOTAnLCBtZWRpdW1wdXJwbGU6ICcjOTM3MEQ4JywgZGFya3Zpb2xldDogJyM5NDAwRDMnLCBwYWxlZ3JlZW46ICcjOThGQjk4JywgZGFya29yY2hpZDogJyM5OTMyQ0MnLCB5ZWxsb3dncmVlbjogJyM5QUNEMzInLCBzaWVubmE6ICcjQTA1MjJEJywgYnJvd246ICcjQTUyQTJBJywgZGFya2dyYXk6ICcjQTlBOUE5JywgbGlnaHRibHVlOiAnI0FERDhFNicsIGdyZWVueWVsbG93OiAnI0FERkYyRicsIHBhbGV0dXJxdW9pc2U6ICcjQUZFRUVFJywgbGlnaHRzdGVlbGJsdWU6ICcjQjBDNERFJywgcG93ZGVyYmx1ZTogJyNCMEUwRTYnLCBmaXJlYnJpY2s6ICcjQjIyMjIyJywgZGFya2dvbGRlbnJvZDogJyNCODg2MEInLCBtZWRpdW1vcmNoaWQ6ICcjQkE1NUQzJywgcm9zeWJyb3duOiAnI0JDOEY4RicsIGRhcmtraGFraTogJyNCREI3NkInLCBzaWx2ZXI6ICcjQzBDMEMwJywgbWVkaXVtdmlvbGV0cmVkOiAnI0M3MTU4NScsIGluZGlhbnJlZDogJyNDRDVDNUMnLCBwZXJ1OiAnI0NEODUzRicsIGNob2NvbGF0ZTogJyNEMjY5MUUnLCB0YW46ICcjRDJCNDhDJywgbGlnaHRncmV5OiAnI0QzRDNEMycsIHBhbGV2aW9sZXRyZWQ6ICcjRDg3MDkzJywgdGhpc3RsZTogJyNEOEJGRDgnLCBvcmNoaWQ6ICcjREE3MEQ2JywgZ29sZGVucm9kOiAnI0RBQTUyMCcsIGNyaW1zb246ICcjREMxNDNDJywgZ2FpbnNib3JvOiAnI0RDRENEQycsIHBsdW06ICcjRERBMEREJywgYnVybHl3b29kOiAnI0RFQjg4NycsIGxpZ2h0Y3lhbjogJyNFMEZGRkYnLCBsYXZlbmRlcjogJyNFNkU2RkEnLCBkYXJrc2FsbW9uOiAnI0U5OTY3QScsIHZpb2xldDogJyNFRTgyRUUnLCBwYWxlZ29sZGVucm9kOiAnI0VFRThBQScsIGxpZ2h0Y29yYWw6ICcjRjA4MDgwJywga2hha2k6ICcjRjBFNjhDJywgYWxpY2VibHVlOiAnI0YwRjhGRicsIGhvbmV5ZGV3OiAnI0YwRkZGMCcsIGF6dXJlOiAnI0YwRkZGRicsIHNhbmR5YnJvd246ICcjRjRBNDYwJywgd2hlYXQ6ICcjRjVERUIzJywgYmVpZ2U6ICcjRjVGNURDJywgd2hpdGVzbW9rZTogJyNGNUY1RjUnLCBtaW50Y3JlYW06ICcjRjVGRkZBJywgZ2hvc3R3aGl0ZTogJyNGOEY4RkYnLCBzYWxtb246ICcjRkE4MDcyJywgYW50aXF1ZXdoaXRlOiAnI0ZBRUJENycsIGxpbmVuOiAnI0ZBRjBFNicsIGxpZ2h0Z29sZGVucm9keWVsbG93OiAnI0ZBRkFEMicsIG9sZGxhY2U6ICcjRkRGNUU2JywgcmVkOiAnI0ZGMDAwMCcsIGZ1Y2hzaWE6ICcjRkYwMEZGJywgbWFnZW50YTogJyNGRjAwRkYnLCBkZWVwcGluazogJyNGRjE0OTMnLCBvcmFuZ2VyZWQ6ICcjRkY0NTAwJywgdG9tYXRvOiAnI0ZGNjM0NycsIGhvdHBpbms6ICcjRkY2OUI0JywgY29yYWw6ICcjRkY3RjUwJywgZGFya29yYW5nZTogJyNGRjhDMDAnLCBsaWdodHNhbG1vbjogJyNGRkEwN0EnLCBvcmFuZ2U6ICcjRkZBNTAwJywgbGlnaHRwaW5rOiAnI0ZGQjZDMScsIHBpbms6ICcjRkZDMENCJywgZ29sZDogJyNGRkQ3MDAnLCBwZWFjaHB1ZmY6ICcjRkZEQUI5JywgbmF2YWpvd2hpdGU6ICcjRkZERUFEJywgbW9jY2FzaW46ICcjRkZFNEI1JywgYmlzcXVlOiAnI0ZGRTRDNCcsIG1pc3R5cm9zZTogJyNGRkU0RTEnLCBibGFuY2hlZGFsbW9uZDogJyNGRkVCQ0QnLCBwYXBheWF3aGlwOiAnI0ZGRUZENScsIGxhdmVuZGVyYmx1c2g6ICcjRkZGMEY1Jywgc2Vhc2hlbGw6ICcjRkZGNUVFJywgY29ybnNpbGs6ICcjRkZGOERDJywgbGVtb25jaGlmZm9uOiAnI0ZGRkFDRCcsIGZsb3JhbHdoaXRlOiAnI0ZGRkFGMCcsIHNub3c6ICcjRkZGQUZBJywgeWVsbG93OiAnI0ZGRkYwMCcsIGxpZ2h0eWVsbG93OiAnI0ZGRkZFMCcsIGl2b3J5OiAnI0ZGRkZGMCcsIHdoaXRlOiAnI0ZGRkZGRicgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gaHRtbENvbG9yc1tjb2xvcl07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgdGhlIGNvbG9yIG9mIHRoZSBjb2xvclBpY2tlclxuICAgICAgICogU3VwcG9ydGVkIGZvcm1hdHM6XG4gICAgICAgKiAncmVkJyAgICAgICAgICAgICAgICAgICAtLT4gSFRNTCBjb2xvciBzdHJpbmdcbiAgICAgICAqICcjZmZmZmZmJyAgICAgICAgICAgICAgIC0tPiBoZXggc3RyaW5nXG4gICAgICAgKiAncmJnKDI1NSwyNTUsMjU1KScgICAgICAtLT4gcmdiIHN0cmluZ1xuICAgICAgICogJ3JnYmEoMjU1LDI1NSwyNTUsMS4wKScgLS0+IHJnYmEgc3RyaW5nXG4gICAgICAgKiB7cjoyNTUsZzoyNTUsYjoyNTV9ICAgICAtLT4gcmdiIG9iamVjdFxuICAgICAgICoge3I6MjU1LGc6MjU1LGI6MjU1LGE6MS4wfSAtLT4gcmdiYSBvYmplY3RcbiAgICAgICAqIEBwYXJhbSBjb2xvclxuICAgICAgICogQHBhcmFtIHNldEluaXRpYWxcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0Q29sb3InLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldENvbG9yKGNvbG9yKSB7XG4gICAgICAgIHZhciBzZXRJbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICAgIGlmIChjb2xvciA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJnYmEgPSB2b2lkIDA7XG5cbiAgICAgICAgLy8gaWYgYSBodG1sIGNvbG9yIHNob3J0aGFuZCBpcyB1c2VkLCBjb252ZXJ0IHRvIGhleFxuICAgICAgICB2YXIgaHRtbENvbG9yID0gdGhpcy5faXNDb2xvclN0cmluZyhjb2xvcik7XG4gICAgICAgIGlmIChodG1sQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbG9yID0gaHRtbENvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgZm9ybWF0XG4gICAgICAgIGlmICh1dGlsLmlzU3RyaW5nKGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmICh1dGlsLmlzVmFsaWRSR0IoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgcmdiYUFycmF5ID0gY29sb3Iuc3Vic3RyKDQpLnN1YnN0cigwLCBjb2xvci5sZW5ndGggLSA1KS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgcmdiYSA9IHsgcjogcmdiYUFycmF5WzBdLCBnOiByZ2JhQXJyYXlbMV0sIGI6IHJnYmFBcnJheVsyXSwgYTogMS4wIH07XG4gICAgICAgICAgfSBlbHNlIGlmICh1dGlsLmlzVmFsaWRSR0JBKGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIF9yZ2JhQXJyYXkgPSBjb2xvci5zdWJzdHIoNSkuc3Vic3RyKDAsIGNvbG9yLmxlbmd0aCAtIDYpLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICByZ2JhID0geyByOiBfcmdiYUFycmF5WzBdLCBnOiBfcmdiYUFycmF5WzFdLCBiOiBfcmdiYUFycmF5WzJdLCBhOiBfcmdiYUFycmF5WzNdIH07XG4gICAgICAgICAgfSBlbHNlIGlmICh1dGlsLmlzVmFsaWRIZXgoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgcmdiT2JqID0gdXRpbC5oZXhUb1JHQihjb2xvcik7XG4gICAgICAgICAgICByZ2JhID0geyByOiByZ2JPYmouciwgZzogcmdiT2JqLmcsIGI6IHJnYk9iai5iLCBhOiAxLjAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNvbG9yIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoY29sb3IuciAhPT0gdW5kZWZpbmVkICYmIGNvbG9yLmcgIT09IHVuZGVmaW5lZCAmJiBjb2xvci5iICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIGFscGhhID0gY29sb3IuYSAhPT0gdW5kZWZpbmVkID8gY29sb3IuYSA6ICcxLjAnO1xuICAgICAgICAgICAgICByZ2JhID0geyByOiBjb2xvci5yLCBnOiBjb2xvci5nLCBiOiBjb2xvci5iLCBhOiBhbHBoYSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCBjb2xvclxuICAgICAgICBpZiAocmdiYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjb2xvciBwYXNzZWQgdG8gdGhlIGNvbG9yUGlja2VyLiBTdXBwb3J0ZWQgYXJlIHN0cmluZ3M6IHJnYiwgaGV4LCByZ2JhLiBPYmplY3Q6IHJnYiAoe3I6cixnOmcsYjpiLFthOmFdfSkuIFN1cHBsaWVkOiBcIiArIEpTT04uc3RyaW5naWZ5KGNvbG9yKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2V0Q29sb3IocmdiYSwgc2V0SW5pdGlhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB0aGlzIHNob3dzIHRoZSBjb2xvciBwaWNrZXIuXG4gICAgICAgKiBUaGUgaHVlIGNpcmNsZSBpcyBjb25zdHJ1Y3RlZCBvbmNlIGFuZCBzdG9yZWQuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3Nob3cnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlQ2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuY2xvc2VDYWxsYmFjaygpO1xuICAgICAgICAgIHRoaXMuY2xvc2VDYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYXBwbGllZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB0aGlzLl9nZW5lcmF0ZUh1ZUNpcmNsZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUFJJVkFURSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4gICAgICAvKipcbiAgICAgICAqIEhpZGUgdGhlIHBpY2tlci4gSXMgY2FsbGVkIGJ5IHRoZSBjYW5jZWwgYnV0dG9uLlxuICAgICAgICogT3B0aW9uYWwgYm9vbGVhbiB0byBzdG9yZSB0aGUgcHJldmlvdXMgY29sb3IgZm9yIGVhc3kgYWNjZXNzIGxhdGVyIG9uLlxuICAgICAgICogQHBhcmFtIHN0b3JlUHJldmlvdXNcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19oaWRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGlkZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgc3RvcmVQcmV2aW91cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgcHJldmlvdXMgY29sb3IgZm9yIG5leHQgdGltZTtcbiAgICAgICAgaWYgKHN0b3JlUHJldmlvdXMgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnByZXZpb3VzQ29sb3IgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5jb2xvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hcHBsaWVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVDYWxsYmFjayh0aGlzLmluaXRpYWxDb2xvcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgLy8gY2FsbCB0aGUgY2xvc2luZyBjYWxsYmFjaywgcmVzdG9yaW5nIHRoZSBvbmNsaWNrIG1ldGhvZC5cbiAgICAgICAgLy8gdGhpcyBpcyBpbiBhIHNldFRpbWVvdXQgYmVjYXVzZSBpdCB3aWxsIHRyaWdnZXIgdGhlIHNob3cgYWdhaW4gYmVmb3JlIHRoZSBjbGljayBpcyBkb25lLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMuY2xvc2VDYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfdGhpcy5jbG9zZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICBfdGhpcy5jbG9zZUNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogYm91bmQgdG8gdGhlIHNhdmUgYnV0dG9uLiBTYXZlcyBhbmQgaGlkZXMuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2F2ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NhdmUoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sodGhpcy5jb2xvcik7XG4gICAgICAgIHRoaXMuYXBwbGllZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9oaWRlKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQm91bmQgdG8gYXBwbHkgYnV0dG9uLiBTYXZlcyBidXQgZG9lcyBub3QgY2xvc2UuIElzIHVuZG9uZSBieSB0aGUgY2FuY2VsIGJ1dHRvbi5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19hcHBseScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FwcGx5KCkge1xuICAgICAgICB0aGlzLmFwcGxpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrKHRoaXMuY29sb3IpO1xuICAgICAgICB0aGlzLl91cGRhdGVQaWNrZXIodGhpcy5jb2xvcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogbG9hZCB0aGUgY29sb3IgZnJvbSB0aGUgcHJldmlvdXMgc2Vzc2lvbi5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19sb2FkTGFzdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2xvYWRMYXN0KCkge1xuICAgICAgICBpZiAodGhpcy5wcmV2aW91c0NvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnNldENvbG9yKHRoaXMucHJldmlvdXNDb2xvciwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFsZXJ0KFwiVGhlcmUgaXMgbm8gbGFzdCBjb2xvciB0byBsb2FkLi4uXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogc2V0IHRoZSBjb2xvciwgcGxhY2UgdGhlIHBpY2tlclxuICAgICAgICogQHBhcmFtIHJnYmFcbiAgICAgICAqIEBwYXJhbSBzZXRJbml0aWFsXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0Q29sb3InLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRDb2xvcihyZ2JhKSB7XG4gICAgICAgIHZhciBzZXRJbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBpbml0aWFsIGNvbG9yXG4gICAgICAgIGlmIChzZXRJbml0aWFsID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5pbml0aWFsQ29sb3IgPSB1dGlsLmV4dGVuZCh7fSwgcmdiYSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbG9yID0gcmdiYTtcbiAgICAgICAgdmFyIGhzdiA9IHV0aWwuUkdCVG9IU1YocmdiYS5yLCByZ2JhLmcsIHJnYmEuYik7XG5cbiAgICAgICAgdmFyIGFuZ2xlQ29udmVydCA9IDIgKiBNYXRoLlBJO1xuICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5yICogaHN2LnM7XG4gICAgICAgIHZhciB4ID0gdGhpcy5jZW50ZXJDb29yZGluYXRlcy54ICsgcmFkaXVzICogTWF0aC5zaW4oYW5nbGVDb252ZXJ0ICogaHN2LmgpO1xuICAgICAgICB2YXIgeSA9IHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSArIHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlQ29udmVydCAqIGhzdi5oKTtcblxuICAgICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUubGVmdCA9IHggLSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xpZW50V2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUudG9wID0geSAtIDAuNSAqIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRIZWlnaHQgKyAncHgnO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVBpY2tlcihyZ2JhKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBib3VuZCB0byBvcGFjaXR5IGNvbnRyb2xcbiAgICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3NldE9wYWNpdHknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRPcGFjaXR5KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29sb3IuYSA9IHZhbHVlIC8gMTAwO1xuICAgICAgICB0aGlzLl91cGRhdGVQaWNrZXIodGhpcy5jb2xvcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogYm91bmQgdG8gYnJpZ2h0bmVzcyBjb250cm9sXG4gICAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zZXRCcmlnaHRuZXNzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0QnJpZ2h0bmVzcyh2YWx1ZSkge1xuICAgICAgICB2YXIgaHN2ID0gdXRpbC5SR0JUb0hTVih0aGlzLmNvbG9yLnIsIHRoaXMuY29sb3IuZywgdGhpcy5jb2xvci5iKTtcbiAgICAgICAgaHN2LnYgPSB2YWx1ZSAvIDEwMDtcbiAgICAgICAgdmFyIHJnYmEgPSB1dGlsLkhTVlRvUkdCKGhzdi5oLCBoc3YucywgaHN2LnYpO1xuICAgICAgICByZ2JhWydhJ10gPSB0aGlzLmNvbG9yLmE7XG4gICAgICAgIHRoaXMuY29sb3IgPSByZ2JhO1xuICAgICAgICB0aGlzLl91cGRhdGVQaWNrZXIoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB1cGRhdGUgdGhlIGNvbG9yIHBpY2tlci4gQSBibGFjayBjaXJjbGUgb3ZlcmxheXMgdGhlIGh1ZSBjaXJjbGUgdG8gbWltaWMgdGhlIGJyaWdodG5lc3MgZGVjcmVhc2luZy5cbiAgICAgICAqIEBwYXJhbSByZ2JhXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdXBkYXRlUGlja2VyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlUGlja2VyKCkge1xuICAgICAgICB2YXIgcmdiYSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5jb2xvcjtcblxuICAgICAgICB2YXIgaHN2ID0gdXRpbC5SR0JUb0hTVihyZ2JhLnIsIHJnYmEuZywgcmdiYS5iKTtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgaWYgKHRoaXMucGl4ZWxSYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMucGl4ZWxSYXRpbyA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIChjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKHRoaXMucGl4ZWxSYXRpbywgMCwgMCwgdGhpcy5waXhlbFJhdGlvLCAwLCAwKTtcblxuICAgICAgICAvLyBjbGVhciB0aGUgY2FudmFzXG4gICAgICAgIHZhciB3ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgICAgdmFyIGggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmNsaWVudEhlaWdodDtcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3LCBoKTtcblxuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKHRoaXMuaHVlQ2lyY2xlLCAwLCAwKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLCcgKyAoMSAtIGhzdi52KSArICcpJztcbiAgICAgICAgY3R4LmNpcmNsZSh0aGlzLmNlbnRlckNvb3JkaW5hdGVzLngsIHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSwgdGhpcy5yKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS52YWx1ZSA9IDEwMCAqIGhzdi52O1xuICAgICAgICB0aGlzLm9wYWNpdHlSYW5nZS52YWx1ZSA9IDEwMCAqIHJnYmEuYTtcblxuICAgICAgICB0aGlzLmluaXRpYWxDb2xvckRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgnICsgdGhpcy5pbml0aWFsQ29sb3IuciArICcsJyArIHRoaXMuaW5pdGlhbENvbG9yLmcgKyAnLCcgKyB0aGlzLmluaXRpYWxDb2xvci5iICsgJywnICsgdGhpcy5pbml0aWFsQ29sb3IuYSArICcpJztcbiAgICAgICAgdGhpcy5uZXdDb2xvckRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgnICsgdGhpcy5jb2xvci5yICsgJywnICsgdGhpcy5jb2xvci5nICsgJywnICsgdGhpcy5jb2xvci5iICsgJywnICsgdGhpcy5jb2xvci5hICsgJyknO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHVzZWQgYnkgY3JlYXRlIHRvIHNldCB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3NldFNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRTaXplKCkge1xuICAgICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcblxuICAgICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLndpZHRoID0gMjg5ICogdGhpcy5waXhlbFJhdGlvO1xuICAgICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmhlaWdodCA9IDI4OSAqIHRoaXMucGl4ZWxSYXRpbztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBjcmVhdGUgYWxsIGRvbSBlbGVtZW50c1xuICAgICAgICogVE9ETzogY2xlYW51cCwgbG90cyBvZiBzaW1pbGFyIGRvbSBlbGVtZW50c1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NyZWF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcbiAgICAgICAgdGhpcy5mcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtY29sb3ItcGlja2VyJztcblxuICAgICAgICB0aGlzLmNvbG9yUGlja2VyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3RvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xhc3NOYW1lID0gJ3Zpcy1zZWxlY3Rvcic7XG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXJEaXYuYXBwZW5kQ2hpbGQodGhpcy5jb2xvclBpY2tlclNlbGVjdG9yKTtcblxuICAgICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXJEaXYuYXBwZW5kQ2hpbGQodGhpcy5jb2xvclBpY2tlckNhbnZhcyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQpIHtcbiAgICAgICAgICB2YXIgbm9DYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgICAgICBub0NhbnZhcy5zdHlsZS5jb2xvciA9ICdyZWQnO1xuICAgICAgICAgIG5vQ2FudmFzLnN0eWxlLmZvbnRXZWlnaHQgPSAnYm9sZCc7XG4gICAgICAgICAgbm9DYW52YXMuc3R5bGUucGFkZGluZyA9ICcxMHB4JztcbiAgICAgICAgICBub0NhbnZhcy5pbm5lckhUTUwgPSAnRXJyb3I6IHlvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IEhUTUwgY2FudmFzJztcbiAgICAgICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmFwcGVuZENoaWxkKG5vQ2FudmFzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgdGhpcy5waXhlbFJhdGlvID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gKGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDEpO1xuXG4gICAgICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikuc2V0VHJhbnNmb3JtKHRoaXMucGl4ZWxSYXRpbywgMCwgMCwgdGhpcy5waXhlbFJhdGlvLCAwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXJEaXYuY2xhc3NOYW1lID0gJ3Zpcy1jb2xvcic7XG5cbiAgICAgICAgdGhpcy5vcGFjaXR5RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMub3BhY2l0eURpdi5jbGFzc05hbWUgPSAndmlzLW9wYWNpdHknO1xuXG4gICAgICAgIHRoaXMuYnJpZ2h0bmVzc0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmJyaWdodG5lc3NEaXYuY2xhc3NOYW1lID0gJ3Zpcy1icmlnaHRuZXNzJztcblxuICAgICAgICB0aGlzLmFycm93RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuYXJyb3dEaXYuY2xhc3NOYW1lID0gJ3Zpcy1hcnJvdyc7XG5cbiAgICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMub3BhY2l0eVJhbmdlLnR5cGUgPSAncmFuZ2UnOyAvLyBOb3Qgc3VwcG9ydGVkIG9uIElFOVxuICAgICAgICAgIHRoaXMub3BhY2l0eVJhbmdlLm1pbiA9ICcwJztcbiAgICAgICAgICB0aGlzLm9wYWNpdHlSYW5nZS5tYXggPSAnMTAwJztcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB0aGlzLm9wYWNpdHlSYW5nZS52YWx1ZSA9ICcxMDAnO1xuICAgICAgICB0aGlzLm9wYWNpdHlSYW5nZS5jbGFzc05hbWUgPSAndmlzLXJhbmdlJztcblxuICAgICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UudHlwZSA9ICdyYW5nZSc7IC8vIE5vdCBzdXBwb3J0ZWQgb24gSUU5XG4gICAgICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UubWluID0gJzAnO1xuICAgICAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm1heCA9ICcxMDAnO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLnZhbHVlID0gJzEwMCc7XG4gICAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLmNsYXNzTmFtZSA9ICd2aXMtcmFuZ2UnO1xuXG4gICAgICAgIHRoaXMub3BhY2l0eURpdi5hcHBlbmRDaGlsZCh0aGlzLm9wYWNpdHlSYW5nZSk7XG4gICAgICAgIHRoaXMuYnJpZ2h0bmVzc0Rpdi5hcHBlbmRDaGlsZCh0aGlzLmJyaWdodG5lc3NSYW5nZSk7XG5cbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdGhpcy5vcGFjaXR5UmFuZ2Uub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWUuX3NldE9wYWNpdHkodGhpcy52YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub3BhY2l0eVJhbmdlLm9uaW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWUuX3NldE9wYWNpdHkodGhpcy52YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1lLl9zZXRCcmlnaHRuZXNzKHRoaXMudmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5vbmlucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1lLl9zZXRCcmlnaHRuZXNzKHRoaXMudmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYnJpZ2h0bmVzc0xhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5icmlnaHRuZXNzTGFiZWwuY2xhc3NOYW1lID0gXCJ2aXMtbGFiZWwgdmlzLWJyaWdodG5lc3NcIjtcbiAgICAgICAgdGhpcy5icmlnaHRuZXNzTGFiZWwuaW5uZXJIVE1MID0gJ2JyaWdodG5lc3M6JztcblxuICAgICAgICB0aGlzLm9wYWNpdHlMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMub3BhY2l0eUxhYmVsLmNsYXNzTmFtZSA9IFwidmlzLWxhYmVsIHZpcy1vcGFjaXR5XCI7XG4gICAgICAgIHRoaXMub3BhY2l0eUxhYmVsLmlubmVySFRNTCA9ICdvcGFjaXR5Oic7XG5cbiAgICAgICAgdGhpcy5uZXdDb2xvckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMubmV3Q29sb3JEaXYuY2xhc3NOYW1lID0gXCJ2aXMtbmV3LWNvbG9yXCI7XG4gICAgICAgIHRoaXMubmV3Q29sb3JEaXYuaW5uZXJIVE1MID0gJ25ldyc7XG5cbiAgICAgICAgdGhpcy5pbml0aWFsQ29sb3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmluaXRpYWxDb2xvckRpdi5jbGFzc05hbWUgPSBcInZpcy1pbml0aWFsLWNvbG9yXCI7XG4gICAgICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2LmlubmVySFRNTCA9ICdpbml0aWFsJztcblxuICAgICAgICB0aGlzLmNhbmNlbEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWJ1dHRvbiB2aXMtY2FuY2VsXCI7XG4gICAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLmlubmVySFRNTCA9ICdjYW5jZWwnO1xuICAgICAgICB0aGlzLmNhbmNlbEJ1dHRvbi5vbmNsaWNrID0gdGhpcy5faGlkZS5iaW5kKHRoaXMsIGZhbHNlKTtcblxuICAgICAgICB0aGlzLmFwcGx5QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5hcHBseUJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1idXR0b24gdmlzLWFwcGx5XCI7XG4gICAgICAgIHRoaXMuYXBwbHlCdXR0b24uaW5uZXJIVE1MID0gJ2FwcGx5JztcbiAgICAgICAgdGhpcy5hcHBseUJ1dHRvbi5vbmNsaWNrID0gdGhpcy5fYXBwbHkuYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLnNhdmVCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLnNhdmVCdXR0b24uY2xhc3NOYW1lID0gXCJ2aXMtYnV0dG9uIHZpcy1zYXZlXCI7XG4gICAgICAgIHRoaXMuc2F2ZUJ1dHRvbi5pbm5lckhUTUwgPSAnc2F2ZSc7XG4gICAgICAgIHRoaXMuc2F2ZUJ1dHRvbi5vbmNsaWNrID0gdGhpcy5fc2F2ZS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMubG9hZEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMubG9hZEJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1idXR0b24gdmlzLWxvYWRcIjtcbiAgICAgICAgdGhpcy5sb2FkQnV0dG9uLmlubmVySFRNTCA9ICdsb2FkIGxhc3QnO1xuICAgICAgICB0aGlzLmxvYWRCdXR0b24ub25jbGljayA9IHRoaXMuX2xvYWRMYXN0LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmNvbG9yUGlja2VyRGl2KTtcbiAgICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmFycm93RGl2KTtcbiAgICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmJyaWdodG5lc3NMYWJlbCk7XG4gICAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5icmlnaHRuZXNzRGl2KTtcbiAgICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm9wYWNpdHlMYWJlbCk7XG4gICAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5vcGFjaXR5RGl2KTtcbiAgICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm5ld0NvbG9yRGl2KTtcbiAgICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmluaXRpYWxDb2xvckRpdik7XG5cbiAgICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmNhbmNlbEJ1dHRvbik7XG4gICAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5hcHBseUJ1dHRvbik7XG4gICAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5zYXZlQnV0dG9uKTtcbiAgICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmxvYWRCdXR0b24pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGJpbmQgaGFtbWVyIHRvIHRoZSBjb2xvciBwaWNrZXJcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19iaW5kSGFtbWVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluZEhhbW1lcigpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5kcmFnID0ge307XG4gICAgICAgIHRoaXMucGluY2ggPSB7fTtcbiAgICAgICAgdGhpcy5oYW1tZXIgPSBuZXcgSGFtbWVyKHRoaXMuY29sb3JQaWNrZXJDYW52YXMpO1xuICAgICAgICB0aGlzLmhhbW1lci5nZXQoJ3BpbmNoJykuc2V0KHsgZW5hYmxlOiB0cnVlIH0pO1xuXG4gICAgICAgIGhhbW1lclV0aWwub25Ub3VjaCh0aGlzLmhhbW1lciwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgX3RoaXMyLl9tb3ZlU2VsZWN0b3IoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW1tZXIub24oJ3RhcCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzMi5fbW92ZVNlbGVjdG9yKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCdwYW5zdGFydCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzMi5fbW92ZVNlbGVjdG9yKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCdwYW5tb3ZlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgX3RoaXMyLl9tb3ZlU2VsZWN0b3IoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW1tZXIub24oJ3BhbmVuZCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzMi5fbW92ZVNlbGVjdG9yKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogZ2VuZXJhdGUgdGhlIGh1ZSBjaXJjbGUuIFRoaXMgaXMgcmVsYXRpdmVseSBoZWF2eSAoMjAwbXMpIGFuZCBpcyBkb25lIG9ubHkgb25jZSBvbiB0aGUgZmlyc3QgdGltZSBpdCBpcyBzaG93bi5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZW5lcmF0ZUh1ZUNpcmNsZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dlbmVyYXRlSHVlQ2lyY2xlKCkge1xuICAgICAgICBpZiAodGhpcy5nZW5lcmF0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICBpZiAodGhpcy5waXhlbFJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyAoY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0odGhpcy5waXhlbFJhdGlvLCAwLCAwLCB0aGlzLnBpeGVsUmF0aW8sIDAsIDApO1xuXG4gICAgICAgICAgLy8gY2xlYXIgdGhlIGNhbnZhc1xuICAgICAgICAgIHZhciB3ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgICAgICB2YXIgaCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG5cbiAgICAgICAgICAvLyBkcmF3IGh1ZSBjaXJjbGVcbiAgICAgICAgICB2YXIgeCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgeSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgaHVlID0gdm9pZCAwLFxuICAgICAgICAgICAgICBzYXQgPSB2b2lkIDA7XG4gICAgICAgICAgdGhpcy5jZW50ZXJDb29yZGluYXRlcyA9IHsgeDogdyAqIDAuNSwgeTogaCAqIDAuNSB9O1xuICAgICAgICAgIHRoaXMuciA9IDAuNDkgKiB3O1xuICAgICAgICAgIHZhciBhbmdsZUNvbnZlcnQgPSAyICogTWF0aC5QSSAvIDM2MDtcbiAgICAgICAgICB2YXIgaGZhYyA9IDEgLyAzNjA7XG4gICAgICAgICAgdmFyIHNmYWMgPSAxIC8gdGhpcy5yO1xuICAgICAgICAgIHZhciByZ2IgPSB2b2lkIDA7XG4gICAgICAgICAgZm9yIChodWUgPSAwOyBodWUgPCAzNjA7IGh1ZSsrKSB7XG4gICAgICAgICAgICBmb3IgKHNhdCA9IDA7IHNhdCA8IHRoaXMucjsgc2F0KyspIHtcbiAgICAgICAgICAgICAgeCA9IHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueCArIHNhdCAqIE1hdGguc2luKGFuZ2xlQ29udmVydCAqIGh1ZSk7XG4gICAgICAgICAgICAgIHkgPSB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnkgKyBzYXQgKiBNYXRoLmNvcyhhbmdsZUNvbnZlcnQgKiBodWUpO1xuICAgICAgICAgICAgICByZ2IgPSB1dGlsLkhTVlRvUkdCKGh1ZSAqIGhmYWMsIHNhdCAqIHNmYWMsIDEpO1xuICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYignICsgcmdiLnIgKyAnLCcgKyByZ2IuZyArICcsJyArIHJnYi5iICsgJyknO1xuICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoeCAtIDAuNSwgeSAtIDAuNSwgMiwgMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsMCwwLDEpJztcbiAgICAgICAgICBjdHguY2lyY2xlKHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueCwgdGhpcy5jZW50ZXJDb29yZGluYXRlcy55LCB0aGlzLnIpO1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICAgIHRoaXMuaHVlQ2lyY2xlID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3LCBoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdlbmVyYXRlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogbW92ZSB0aGUgc2VsZWN0b3IuIFRoaXMgaXMgY2FsbGVkIGJ5IGhhbW1lciBmdW5jdGlvbnMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIGV2ZW50XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbW92ZVNlbGVjdG9yJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZVNlbGVjdG9yKGV2ZW50KSB7XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5jb2xvclBpY2tlckRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIGxlZnQgPSBldmVudC5jZW50ZXIueCAtIHJlY3QubGVmdDtcbiAgICAgICAgdmFyIHRvcCA9IGV2ZW50LmNlbnRlci55IC0gcmVjdC50b3A7XG5cbiAgICAgICAgdmFyIGNlbnRlclkgPSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyRGl2LmNsaWVudEhlaWdodDtcbiAgICAgICAgdmFyIGNlbnRlclggPSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyRGl2LmNsaWVudFdpZHRoO1xuXG4gICAgICAgIHZhciB4ID0gbGVmdCAtIGNlbnRlclg7XG4gICAgICAgIHZhciB5ID0gdG9wIC0gY2VudGVyWTtcblxuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHgsIHkpO1xuICAgICAgICB2YXIgcmFkaXVzID0gMC45OCAqIE1hdGgubWluKE1hdGguc3FydCh4ICogeCArIHkgKiB5KSwgY2VudGVyWCk7XG5cbiAgICAgICAgdmFyIG5ld1RvcCA9IE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cyArIGNlbnRlclk7XG4gICAgICAgIHZhciBuZXdMZWZ0ID0gTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzICsgY2VudGVyWDtcblxuICAgICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUudG9wID0gbmV3VG9wIC0gMC41ICogdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsaWVudEhlaWdodCArICdweCc7XG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5zdHlsZS5sZWZ0ID0gbmV3TGVmdCAtIDAuNSAqIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRXaWR0aCArICdweCc7XG5cbiAgICAgICAgLy8gc2V0IGNvbG9yXG4gICAgICAgIHZhciBoID0gYW5nbGUgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICBoID0gaCA8IDAgPyBoICsgMSA6IGg7XG4gICAgICAgIHZhciBzID0gcmFkaXVzIC8gdGhpcy5yO1xuICAgICAgICB2YXIgaHN2ID0gdXRpbC5SR0JUb0hTVih0aGlzLmNvbG9yLnIsIHRoaXMuY29sb3IuZywgdGhpcy5jb2xvci5iKTtcbiAgICAgICAgaHN2LmggPSBoO1xuICAgICAgICBoc3YucyA9IHM7XG4gICAgICAgIHZhciByZ2JhID0gdXRpbC5IU1ZUb1JHQihoc3YuaCwgaHN2LnMsIGhzdi52KTtcbiAgICAgICAgcmdiYVsnYSddID0gdGhpcy5jb2xvci5hO1xuICAgICAgICB0aGlzLmNvbG9yID0gcmdiYTtcblxuICAgICAgICAvLyB1cGRhdGUgcHJldmlld3NcbiAgICAgICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoJyArIHRoaXMuaW5pdGlhbENvbG9yLnIgKyAnLCcgKyB0aGlzLmluaXRpYWxDb2xvci5nICsgJywnICsgdGhpcy5pbml0aWFsQ29sb3IuYiArICcsJyArIHRoaXMuaW5pdGlhbENvbG9yLmEgKyAnKSc7XG4gICAgICAgIHRoaXMubmV3Q29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoJyArIHRoaXMuY29sb3IuciArICcsJyArIHRoaXMuY29sb3IuZyArICcsJyArIHRoaXMuY29sb3IuYiArICcsJyArIHRoaXMuY29sb3IuYSArICcpJztcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ29sb3JQaWNrZXI7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBDb2xvclBpY2tlcjtcblxuLyoqKi8gfSxcbi8qIDMwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIEhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHRvdWNoIGV2ZW50LCB0YWtpbmcgcGxhY2UgYmVmb3JlIGEgZ2VzdHVyZVxuICAgKiBAcGFyYW0ge0hhbW1lcn0gaGFtbWVyICAgICAgIEEgaGFtbWVyIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrICAgQ2FsbGJhY2ssIGNhbGxlZCBhcyBjYWxsYmFjayhldmVudClcbiAgICovXG4gIGV4cG9ydHMub25Ub3VjaCA9IGZ1bmN0aW9uIChoYW1tZXIsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2suaW5wdXRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuaXNGaXJzdCkge1xuICAgICAgICBjYWxsYmFjayhldmVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGhhbW1lci5vbignaGFtbWVyLmlucHV0JywgY2FsbGJhY2suaW5wdXRIYW5kbGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSByZWxlYXNlIGV2ZW50LCB0YWtpbmcgcGxhY2UgYWZ0ZXIgYSBnZXN0dXJlXG4gICAqIEBwYXJhbSB7SGFtbWVyfSBoYW1tZXIgICAgICAgQSBoYW1tZXIgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBDYWxsYmFjaywgY2FsbGVkIGFzIGNhbGxiYWNrKGV2ZW50KVxuICAgKi9cbiAgZXhwb3J0cy5vblJlbGVhc2UgPSBmdW5jdGlvbiAoaGFtbWVyLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrLmlucHV0SGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmlzRmluYWwpIHtcbiAgICAgICAgY2FsbGJhY2soZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gaGFtbWVyLm9uKCdoYW1tZXIuaW5wdXQnLCBjYWxsYmFjay5pbnB1dEhhbmRsZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyIGEgdG91Y2ggZXZlbnQsIHRha2luZyBwbGFjZSBiZWZvcmUgYSBnZXN0dXJlXG4gICAqIEBwYXJhbSB7SGFtbWVyfSBoYW1tZXIgICAgICAgQSBoYW1tZXIgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBDYWxsYmFjaywgY2FsbGVkIGFzIGNhbGxiYWNrKGV2ZW50KVxuICAgKi9cbiAgZXhwb3J0cy5vZmZUb3VjaCA9IGZ1bmN0aW9uIChoYW1tZXIsIGNhbGxiYWNrKSB7XG4gICAgaGFtbWVyLm9mZignaGFtbWVyLmlucHV0JywgY2FsbGJhY2suaW5wdXRIYW5kbGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogVW5yZWdpc3RlciBhIHJlbGVhc2UgZXZlbnQsIHRha2luZyBwbGFjZSBiZWZvcmUgYSBnZXN0dXJlXG4gICAqIEBwYXJhbSB7SGFtbWVyfSBoYW1tZXIgICAgICAgQSBoYW1tZXIgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBDYWxsYmFjaywgY2FsbGVkIGFzIGNhbGxiYWNrKGV2ZW50KVxuICAgKi9cbiAgZXhwb3J0cy5vZmZSZWxlYXNlID0gZXhwb3J0cy5vZmZUb3VjaDtcblxuICAvKipcbiAgICogSGFjayB0aGUgUGluY2hSZWNvZ25pemVyIHN1Y2ggdGhhdCBpdCBkb2Vzbid0IHByZXZlbnQgZGVmYXVsdCBiZWhhdmlvclxuICAgKiBmb3IgdmVydGljYWwgcGFubmluZy5cbiAgICpcbiAgICogWWVhaCAuLi4gdGhpcyBpcyBxdWl0ZSBhIGhhY2sgLi4uIHNlZSBodHRwczovL2dpdGh1Yi5jb20vaGFtbWVyanMvaGFtbWVyLmpzL2lzc3Vlcy85MzJcbiAgICpcbiAgICogQHBhcmFtIHtIYW1tZXIuUGluY2h9IHBpbmNoUmVjb2duaXplclxuICAgKiBAcmV0dXJuIHtIYW1tZXIuUGluY2h9IHJldHVybnMgdGhlIHBpbmNoUmVjb2duaXplclxuICAgKi9cbiAgZXhwb3J0cy5kaXNhYmxlUHJldmVudERlZmF1bHRWZXJ0aWNhbGx5ID0gZnVuY3Rpb24gKHBpbmNoUmVjb2duaXplcikge1xuICAgIHZhciBUT1VDSF9BQ1RJT05fUEFOX1kgPSAncGFuLXknO1xuXG4gICAgcGluY2hSZWNvZ25pemVyLmdldFRvdWNoQWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZGVmYXVsdCBtZXRob2QgcmV0dXJucyBbVE9VQ0hfQUNUSU9OX05PTkVdXG4gICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9QQU5fWV07XG4gICAgfTtcblxuICAgIHJldHVybiBwaW5jaFJlY29nbml6ZXI7XG4gIH07XG5cbi8qKiovIH0sXG4vKiAzMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIHZhciBlcnJvckZvdW5kID0gZmFsc2U7XG4gIHZhciBhbGxPcHRpb25zID0gdm9pZCAwO1xuICB2YXIgcHJpbnRTdHlsZSA9ICdiYWNrZ3JvdW5kOiAjRkZlZWVlOyBjb2xvcjogI2RkMDAwMCc7XG4gIC8qKlxuICAgKiAgVXNlZCB0byB2YWxpZGF0ZSBvcHRpb25zLlxuICAgKi9cblxuICB2YXIgVmFsaWRhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZhbGlkYXRvcigpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWYWxpZGF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1haW4gZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gc3ViT2JqZWN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhWYWxpZGF0b3IsIG51bGwsIFt7XG4gICAgICBrZXk6ICd2YWxpZGF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGUob3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgc3ViT2JqZWN0KSB7XG4gICAgICAgIGVycm9yRm91bmQgPSBmYWxzZTtcbiAgICAgICAgYWxsT3B0aW9ucyA9IHJlZmVyZW5jZU9wdGlvbnM7XG4gICAgICAgIHZhciB1c2VkT3B0aW9ucyA9IHJlZmVyZW5jZU9wdGlvbnM7XG4gICAgICAgIGlmIChzdWJPYmplY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHVzZWRPcHRpb25zID0gcmVmZXJlbmNlT3B0aW9uc1tzdWJPYmplY3RdO1xuICAgICAgICB9XG4gICAgICAgIFZhbGlkYXRvci5wYXJzZShvcHRpb25zLCB1c2VkT3B0aW9ucywgW10pO1xuICAgICAgICByZXR1cm4gZXJyb3JGb3VuZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBXaWxsIHRyYXZlcnNlIGFuIG9iamVjdCByZWN1cnNpdmVseSBhbmQgY2hlY2sgZXZlcnkgdmFsdWVcbiAgICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICAgKiBAcGFyYW0gcmVmZXJlbmNlT3B0aW9uc1xuICAgICAgICogQHBhcmFtIHBhdGhcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncGFyc2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHBhdGgpIHtcbiAgICAgICAgZm9yICh2YXIgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSB7XG4gICAgICAgICAgICBWYWxpZGF0b3IuY2hlY2sob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCBwYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDaGVjayBldmVyeSB2YWx1ZS4gSWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCwgY2FsbCB0aGUgcGFyc2UgZnVuY3Rpb24gb24gdGhhdCBvYmplY3QuXG4gICAgICAgKiBAcGFyYW0gb3B0aW9uXG4gICAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAgICogQHBhcmFtIHJlZmVyZW5jZU9wdGlvbnNcbiAgICAgICAqIEBwYXJhbSBwYXRoXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NoZWNrJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVjayhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHBhdGgpIHtcbiAgICAgICAgaWYgKHJlZmVyZW5jZU9wdGlvbnNbb3B0aW9uXSA9PT0gdW5kZWZpbmVkICYmIHJlZmVyZW5jZU9wdGlvbnMuX19hbnlfXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgVmFsaWRhdG9yLmdldFN1Z2dlc3Rpb24ob3B0aW9uLCByZWZlcmVuY2VPcHRpb25zLCBwYXRoKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWZlcmVuY2VPcHRpb25zW29wdGlvbl0gPT09IHVuZGVmaW5lZCAmJiByZWZlcmVuY2VPcHRpb25zLl9fYW55X18gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIF9fYW55X18gaXMgYSB3aWxkY2FyZC4gQW55IHZhbHVlIGlzIGFjY2VwdGVkIGFuZCB3aWxsIGJlIGZ1cnRoZXIgYW5hbHlzZWQgYnkgcmVmZXJlbmNlLlxuICAgICAgICAgIGlmIChWYWxpZGF0b3IuZ2V0VHlwZShvcHRpb25zW29wdGlvbl0pID09PSAnb2JqZWN0JyAmJiByZWZlcmVuY2VPcHRpb25zWydfX2FueV9fJ10uX190eXBlX18gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGFueSBzdWJncm91cCBpcyBub3QgYSBwcmVkZWZpbmVkIG9iamVjdCBpbnQgaGUgY29uZmlndXJhdG9yIHdlIGRvIG5vdCBsb29rIGRlZXBlciBpbnRvIHRoZSBvYmplY3QuXG4gICAgICAgICAgICBWYWxpZGF0b3IuY2hlY2tGaWVsZHMob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCAnX19hbnlfXycsIHJlZmVyZW5jZU9wdGlvbnNbJ19fYW55X18nXS5fX3R5cGVfXywgcGF0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFZhbGlkYXRvci5jaGVja0ZpZWxkcyhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsICdfX2FueV9fJywgcmVmZXJlbmNlT3B0aW9uc1snX19hbnlfXyddLCBwYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2luY2UgYWxsIG9wdGlvbnMgaW4gdGhlIHJlZmVyZW5jZSBhcmUgb2JqZWN0cywgd2UgY2FuIGNoZWNrIHdoZXRoZXIgdGhleSBhcmUgc3VwcG9zZWQgdG8gYmUgb2JqZWN0IHRvIGxvb2sgZm9yIHRoZSBfX3R5cGVfXyBmaWVsZC5cbiAgICAgICAgICBpZiAocmVmZXJlbmNlT3B0aW9uc1tvcHRpb25dLl9fdHlwZV9fICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgc2hvdWxkIGJlIGFuIG9iamVjdCwgd2UgY2hlY2sgaWYgdGhlIGNvcnJlY3QgdHlwZSBoYXMgYmVlbiBzdXBwbGllZCB0byBhY2NvdW50IGZvciBzaG9ydGhhbmQgb3B0aW9ucy5cbiAgICAgICAgICAgIFZhbGlkYXRvci5jaGVja0ZpZWxkcyhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIG9wdGlvbiwgcmVmZXJlbmNlT3B0aW9uc1tvcHRpb25dLl9fdHlwZV9fLCBwYXRoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgVmFsaWRhdG9yLmNoZWNrRmllbGRzKG9wdGlvbiwgb3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgb3B0aW9uLCByZWZlcmVuY2VPcHRpb25zW29wdGlvbl0sIHBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gIG9wdGlvbiAgICAgfCB0aGUgb3B0aW9uIHByb3BlcnR5XG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gIG9wdGlvbnMgICAgfCBUaGUgc3VwcGxpZWQgb3B0aW9ucyBvYmplY3RcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgcmVmZXJlbmNlT3B0aW9ucyAgICB8IFRoZSByZWZlcmVuY2Ugb3B0aW9ucyBjb250YWluaW5nIGFsbCBvcHRpb25zIGFuZCB0aGVpciBhbGxvd2VkIGZvcm1hdHNcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgcmVmZXJlbmNlT3B0aW9uICAgICB8IFVzdWFsbHkgdGhpcyBpcyB0aGUgc2FtZSBhcyBvcHRpb24sIGV4Y2VwdCB3aGVuIGhhbmRsaW5nIGFuIF9fYW55X18gdGFnLlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9ICByZWZPcHRpb25UeXBlICAgICAgIHwgVGhpcyBpcyB0aGUgdHlwZSBvYmplY3QgZnJvbSB0aGUgcmVmZXJlbmNlIG9wdGlvbnNcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9ICAgcGF0aCAgICAgIHwgd2hlcmUgaW4gdGhlIG9iamVjdCBpcyB0aGUgb3B0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NoZWNrRmllbGRzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0ZpZWxkcyhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbiwgcmVmT3B0aW9uT2JqLCBwYXRoKSB7XG4gICAgICAgIHZhciBvcHRpb25UeXBlID0gVmFsaWRhdG9yLmdldFR5cGUob3B0aW9uc1tvcHRpb25dKTtcbiAgICAgICAgdmFyIHJlZk9wdGlvblR5cGUgPSByZWZPcHRpb25PYmpbb3B0aW9uVHlwZV07XG4gICAgICAgIGlmIChyZWZPcHRpb25UeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgdHlwZSBpcyBjb3JyZWN0LCB3ZSBjaGVjayBpZiBpdCBpcyBzdXBwb3NlZCB0byBiZSBvbmUgb2YgYSBmZXcgc2VsZWN0IHZhbHVlc1xuICAgICAgICAgIGlmIChWYWxpZGF0b3IuZ2V0VHlwZShyZWZPcHRpb25UeXBlKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgaWYgKHJlZk9wdGlvblR5cGUuaW5kZXhPZihvcHRpb25zW29wdGlvbl0pID09PSAtMSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnJWNJbnZhbGlkIG9wdGlvbiBkZXRlY3RlZCBpbiBcIicgKyBvcHRpb24gKyAnXCIuJyArICcgQWxsb3dlZCB2YWx1ZXMgYXJlOicgKyBWYWxpZGF0b3IucHJpbnQocmVmT3B0aW9uVHlwZSkgKyAnIG5vdCBcIicgKyBvcHRpb25zW29wdGlvbl0gKyAnXCIuICcgKyBWYWxpZGF0b3IucHJpbnRMb2NhdGlvbihwYXRoLCBvcHRpb24pLCBwcmludFN0eWxlKTtcbiAgICAgICAgICAgICAgZXJyb3JGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvblR5cGUgPT09ICdvYmplY3QnICYmIHJlZmVyZW5jZU9wdGlvbiAhPT0gXCJfX2FueV9fXCIpIHtcbiAgICAgICAgICAgICAgcGF0aCA9IHV0aWwuY29weUFuZEV4dGVuZEFycmF5KHBhdGgsIG9wdGlvbik7XG4gICAgICAgICAgICAgIFZhbGlkYXRvci5wYXJzZShvcHRpb25zW29wdGlvbl0sIHJlZmVyZW5jZU9wdGlvbnNbcmVmZXJlbmNlT3B0aW9uXSwgcGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25UeXBlID09PSAnb2JqZWN0JyAmJiByZWZlcmVuY2VPcHRpb24gIT09IFwiX19hbnlfX1wiKSB7XG4gICAgICAgICAgICBwYXRoID0gdXRpbC5jb3B5QW5kRXh0ZW5kQXJyYXkocGF0aCwgb3B0aW9uKTtcbiAgICAgICAgICAgIFZhbGlkYXRvci5wYXJzZShvcHRpb25zW29wdGlvbl0sIHJlZmVyZW5jZU9wdGlvbnNbcmVmZXJlbmNlT3B0aW9uXSwgcGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJlZk9wdGlvbk9ialsnYW55J10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHR5cGUgb2YgdGhlIGZpZWxkIGlzIGluY29ycmVjdCBhbmQgdGhlIGZpZWxkIGNhbm5vdCBiZSBhbnlcbiAgICAgICAgICBjb25zb2xlLmxvZygnJWNJbnZhbGlkIHR5cGUgcmVjZWl2ZWQgZm9yIFwiJyArIG9wdGlvbiArICdcIi4gRXhwZWN0ZWQ6ICcgKyBWYWxpZGF0b3IucHJpbnQoT2JqZWN0LmtleXMocmVmT3B0aW9uT2JqKSkgKyAnLiBSZWNlaXZlZCBbJyArIG9wdGlvblR5cGUgKyAnXSBcIicgKyBvcHRpb25zW29wdGlvbl0gKyAnXCInICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24ocGF0aCwgb3B0aW9uKSwgcHJpbnRTdHlsZSk7XG4gICAgICAgICAgZXJyb3JGb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRUeXBlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUeXBlKG9iamVjdCkge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iamVjdCk7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICAgICAgICAgIHJldHVybiAnYm9vbGVhbic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2FycmF5JztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3Qubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuICdkb20nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0Ll9pc0FNb21lbnRPYmplY3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiAnbW9tZW50JztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuICdudW1iZXInO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHJldHVybiAnYm9vbGVhbic7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldFN1Z2dlc3Rpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN1Z2dlc3Rpb24ob3B0aW9uLCBvcHRpb25zLCBwYXRoKSB7XG4gICAgICAgIHZhciBsb2NhbFNlYXJjaCA9IFZhbGlkYXRvci5maW5kSW5PcHRpb25zKG9wdGlvbiwgb3B0aW9ucywgcGF0aCwgZmFsc2UpO1xuICAgICAgICB2YXIgZ2xvYmFsU2VhcmNoID0gVmFsaWRhdG9yLmZpbmRJbk9wdGlvbnMob3B0aW9uLCBhbGxPcHRpb25zLCBbXSwgdHJ1ZSk7XG5cbiAgICAgICAgdmFyIGxvY2FsU2VhcmNoVGhyZXNob2xkID0gODtcbiAgICAgICAgdmFyIGdsb2JhbFNlYXJjaFRocmVzaG9sZCA9IDQ7XG5cbiAgICAgICAgaWYgKGxvY2FsU2VhcmNoLmluZGV4TWF0Y2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCclY1Vua25vd24gb3B0aW9uIGRldGVjdGVkOiBcIicgKyBvcHRpb24gKyAnXCIgaW4gJyArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKGxvY2FsU2VhcmNoLnBhdGgsIG9wdGlvbiwgJycpICsgJ1BlcmhhcHMgaXQgd2FzIGluY29tcGxldGU/IERpZCB5b3UgbWVhbjogXCInICsgbG9jYWxTZWFyY2guaW5kZXhNYXRjaCArICdcIj9cXG5cXG4nLCBwcmludFN0eWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChnbG9iYWxTZWFyY2guZGlzdGFuY2UgPD0gZ2xvYmFsU2VhcmNoVGhyZXNob2xkICYmIGxvY2FsU2VhcmNoLmRpc3RhbmNlID4gZ2xvYmFsU2VhcmNoLmRpc3RhbmNlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJyVjVW5rbm93biBvcHRpb24gZGV0ZWN0ZWQ6IFwiJyArIG9wdGlvbiArICdcIiBpbiAnICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24obG9jYWxTZWFyY2gucGF0aCwgb3B0aW9uLCAnJykgKyAnUGVyaGFwcyBpdCB3YXMgbWlzcGxhY2VkPyBNYXRjaGluZyBvcHRpb24gZm91bmQgYXQ6ICcgKyBWYWxpZGF0b3IucHJpbnRMb2NhdGlvbihnbG9iYWxTZWFyY2gucGF0aCwgZ2xvYmFsU2VhcmNoLmNsb3Nlc3RNYXRjaCwgJycpLCBwcmludFN0eWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbFNlYXJjaC5kaXN0YW5jZSA8PSBsb2NhbFNlYXJjaFRocmVzaG9sZCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCclY1Vua25vd24gb3B0aW9uIGRldGVjdGVkOiBcIicgKyBvcHRpb24gKyAnXCIuIERpZCB5b3UgbWVhbiBcIicgKyBsb2NhbFNlYXJjaC5jbG9zZXN0TWF0Y2ggKyAnXCI/JyArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKGxvY2FsU2VhcmNoLnBhdGgsIG9wdGlvbiksIHByaW50U3R5bGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCclY1Vua25vd24gb3B0aW9uIGRldGVjdGVkOiBcIicgKyBvcHRpb24gKyAnXCIuIERpZCB5b3UgbWVhbiBvbmUgb2YgdGhlc2U6ICcgKyBWYWxpZGF0b3IucHJpbnQoT2JqZWN0LmtleXMob3B0aW9ucykpICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24ocGF0aCwgb3B0aW9uKSwgcHJpbnRTdHlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBlcnJvckZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB0cmF2ZXJzZSB0aGUgb3B0aW9ucyBpbiBzZWFyY2ggZm9yIGEgbWF0Y2guXG4gICAgICAgKiBAcGFyYW0gb3B0aW9uXG4gICAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAgICogQHBhcmFtIHBhdGhcbiAgICAgICAqIEBwYXJhbSByZWN1cnNpdmVcbiAgICAgICAqIEByZXR1cm5zIHt7Y2xvc2VzdE1hdGNoOiBzdHJpbmcsIHBhdGg6IEFycmF5LCBkaXN0YW5jZTogbnVtYmVyfX1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZmluZEluT3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEluT3B0aW9ucyhvcHRpb24sIG9wdGlvbnMsIHBhdGgpIHtcbiAgICAgICAgdmFyIHJlY3Vyc2l2ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG5cbiAgICAgICAgdmFyIG1pbiA9IDFlOTtcbiAgICAgICAgdmFyIGNsb3Nlc3RNYXRjaCA9ICcnO1xuICAgICAgICB2YXIgY2xvc2VzdE1hdGNoUGF0aCA9IFtdO1xuICAgICAgICB2YXIgbG93ZXJDYXNlT3B0aW9uID0gb3B0aW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBpbmRleE1hdGNoID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKHZhciBvcCBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIGRpc3RhbmNlID0gdm9pZCAwO1xuICAgICAgICAgIGlmIChvcHRpb25zW29wXS5fX3R5cGVfXyAhPT0gdW5kZWZpbmVkICYmIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFZhbGlkYXRvci5maW5kSW5PcHRpb25zKG9wdGlvbiwgb3B0aW9uc1tvcF0sIHV0aWwuY29weUFuZEV4dGVuZEFycmF5KHBhdGgsIG9wKSk7XG4gICAgICAgICAgICBpZiAobWluID4gcmVzdWx0LmRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgIGNsb3Nlc3RNYXRjaCA9IHJlc3VsdC5jbG9zZXN0TWF0Y2g7XG4gICAgICAgICAgICAgIGNsb3Nlc3RNYXRjaFBhdGggPSByZXN1bHQucGF0aDtcbiAgICAgICAgICAgICAgbWluID0gcmVzdWx0LmRpc3RhbmNlO1xuICAgICAgICAgICAgICBpbmRleE1hdGNoID0gcmVzdWx0LmluZGV4TWF0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvcC50b0xvd2VyQ2FzZSgpLmluZGV4T2YobG93ZXJDYXNlT3B0aW9uKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgaW5kZXhNYXRjaCA9IG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzdGFuY2UgPSBWYWxpZGF0b3IubGV2ZW5zaHRlaW5EaXN0YW5jZShvcHRpb24sIG9wKTtcbiAgICAgICAgICAgIGlmIChtaW4gPiBkaXN0YW5jZSkge1xuICAgICAgICAgICAgICBjbG9zZXN0TWF0Y2ggPSBvcDtcbiAgICAgICAgICAgICAgY2xvc2VzdE1hdGNoUGF0aCA9IHV0aWwuY29weUFycmF5KHBhdGgpO1xuICAgICAgICAgICAgICBtaW4gPSBkaXN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2xvc2VzdE1hdGNoOiBjbG9zZXN0TWF0Y2gsIHBhdGg6IGNsb3Nlc3RNYXRjaFBhdGgsIGRpc3RhbmNlOiBtaW4sIGluZGV4TWF0Y2g6IGluZGV4TWF0Y2ggfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdwcmludExvY2F0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcmludExvY2F0aW9uKHBhdGgsIG9wdGlvbikge1xuICAgICAgICB2YXIgcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnUHJvYmxlbSB2YWx1ZSBmb3VuZCBhdDogXFxuJztcblxuICAgICAgICB2YXIgc3RyID0gJ1xcblxcbicgKyBwcmVmaXggKyAnb3B0aW9ucyA9IHtcXG4nO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGkgKyAxOyBqKyspIHtcbiAgICAgICAgICAgIHN0ciArPSAnICAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHIgKz0gcGF0aFtpXSArICc6IHtcXG4nO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBwYXRoLmxlbmd0aCArIDE7IF9qKyspIHtcbiAgICAgICAgICBzdHIgKz0gJyAgJztcbiAgICAgICAgfVxuICAgICAgICBzdHIgKz0gb3B0aW9uICsgJ1xcbic7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBwYXRoLmxlbmd0aCArIDE7IF9pKyspIHtcbiAgICAgICAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCBwYXRoLmxlbmd0aCAtIF9pOyBfajIrKykge1xuICAgICAgICAgICAgc3RyICs9ICcgICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0ciArPSAnfVxcbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0ciArICdcXG5cXG4nO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3ByaW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcmludChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvcHRpb25zKS5yZXBsYWNlKC8oXFxcIil8KFxcWyl8KFxcXSl8KCxcIl9fdHlwZV9fXCIpL2csIFwiXCIpLnJlcGxhY2UoLyhcXCwpL2csICcsICcpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb21wdXRlIHRoZSBlZGl0IGRpc3RhbmNlIGJldHdlZW4gdGhlIHR3byBnaXZlbiBzdHJpbmdzXG4gICAgICAvLyBodHRwOi8vZW4ud2lraWJvb2tzLm9yZy93aWtpL0FsZ29yaXRobV9JbXBsZW1lbnRhdGlvbi9TdHJpbmdzL0xldmVuc2h0ZWluX2Rpc3RhbmNlI0phdmFTY3JpcHRcbiAgICAgIC8qXG4gICAgICAgQ29weXJpZ2h0IChjKSAyMDExIEFuZHJlaSBNYWNrZW56aWVcbiAgICAgICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdsZXZlbnNodGVpbkRpc3RhbmNlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBsZXZlbnNodGVpbkRpc3RhbmNlKGEsIGIpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoID09PSAwKSByZXR1cm4gYi5sZW5ndGg7XG4gICAgICAgIGlmIChiLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGEubGVuZ3RoO1xuXG4gICAgICAgIHZhciBtYXRyaXggPSBbXTtcblxuICAgICAgICAvLyBpbmNyZW1lbnQgYWxvbmcgdGhlIGZpcnN0IGNvbHVtbiBvZiBlYWNoIHJvd1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8PSBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbWF0cml4W2ldID0gW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5jcmVtZW50IGVhY2ggY29sdW1uIGluIHRoZSBmaXJzdCByb3dcbiAgICAgICAgdmFyIGo7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPD0gYS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIG1hdHJpeFswXVtqXSA9IGo7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaWxsIGluIHRoZSByZXN0IG9mIHRoZSBtYXRyaXhcbiAgICAgICAgZm9yIChpID0gMTsgaSA8PSBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZm9yIChqID0gMTsgaiA8PSBhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoYi5jaGFyQXQoaSAtIDEpID09IGEuY2hhckF0KGogLSAxKSkge1xuICAgICAgICAgICAgICBtYXRyaXhbaV1bal0gPSBtYXRyaXhbaSAtIDFdW2ogLSAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdHJpeFtpXVtqXSA9IE1hdGgubWluKG1hdHJpeFtpIC0gMV1baiAtIDFdICsgMSwgLy8gc3Vic3RpdHV0aW9uXG4gICAgICAgICAgICAgIE1hdGgubWluKG1hdHJpeFtpXVtqIC0gMV0gKyAxLCAvLyBpbnNlcnRpb25cbiAgICAgICAgICAgICAgbWF0cml4W2kgLSAxXVtqXSArIDEpKTsgLy8gZGVsZXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0cml4W2IubGVuZ3RoXVthLmxlbmd0aF07XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFZhbGlkYXRvcjtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IFZhbGlkYXRvcjtcbiAgZXhwb3J0cy5wcmludFN0eWxlID0gcHJpbnRTdHlsZTtcblxuLyoqKi8gfSxcbi8qIDMyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIGhhbW1lclV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcbiAgdmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4gIHZhciBDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbiAgdmFyIERhdGVVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBSYW5nZVxuICAgKiBBIFJhbmdlIGNvbnRyb2xzIGEgbnVtZXJpYyByYW5nZSB3aXRoIGEgc3RhcnQgYW5kIGVuZCB2YWx1ZS5cbiAgICogVGhlIFJhbmdlIGFkanVzdHMgdGhlIHJhbmdlIGJhc2VkIG9uIG1vdXNlIGV2ZW50cyBvciBwcm9ncmFtbWF0aWMgY2hhbmdlcyxcbiAgICogYW5kIHRyaWdnZXJzIGV2ZW50cyB3aGVuIHRoZSByYW5nZSBpcyBjaGFuZ2luZyBvciBoYXMgYmVlbiBjaGFuZ2VkLlxuICAgKiBAcGFyYW0ge3tkb206IE9iamVjdCwgZG9tUHJvcHM6IE9iamVjdCwgZW1pdHRlcjogRW1pdHRlcn19IGJvZHlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICBTZWUgZGVzY3JpcHRpb24gYXQgUmFuZ2Uuc2V0T3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gUmFuZ2UoYm9keSwgb3B0aW9ucykge1xuICAgIHZhciBub3cgPSBtb21lbnQoKS5ob3VycygwKS5taW51dGVzKDApLnNlY29uZHMoMCkubWlsbGlzZWNvbmRzKDApO1xuICAgIHRoaXMuc3RhcnQgPSBub3cuY2xvbmUoKS5hZGQoLTMsICdkYXlzJykudmFsdWVPZigpOyAvLyBOdW1iZXJcbiAgICB0aGlzLmVuZCA9IG5vdy5jbG9uZSgpLmFkZCg0LCAnZGF5cycpLnZhbHVlT2YoKTsgLy8gTnVtYmVyXG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuZGVsdGFEaWZmZXJlbmNlID0gMDtcbiAgICB0aGlzLnNjYWxlT2Zmc2V0ID0gMDtcbiAgICB0aGlzLnN0YXJ0VG9Gcm9udCA9IGZhbHNlO1xuICAgIHRoaXMuZW5kVG9Gcm9udCA9IHRydWU7XG5cbiAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgcnRsOiBmYWxzZSxcbiAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgZW5kOiBudWxsLFxuICAgICAgbW9tZW50OiBtb21lbnQsXG4gICAgICBkaXJlY3Rpb246ICdob3Jpem9udGFsJywgLy8gJ2hvcml6b250YWwnIG9yICd2ZXJ0aWNhbCdcbiAgICAgIG1vdmVhYmxlOiB0cnVlLFxuICAgICAgem9vbWFibGU6IHRydWUsXG4gICAgICBtaW46IG51bGwsXG4gICAgICBtYXg6IG51bGwsXG4gICAgICB6b29tTWluOiAxMCwgLy8gbWlsbGlzZWNvbmRzXG4gICAgICB6b29tTWF4OiAxMDAwICogNjAgKiA2MCAqIDI0ICogMzY1ICogMTAwMDAgLy8gbWlsbGlzZWNvbmRzXG4gICAgfTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgdGhpcy5wcm9wcyA9IHtcbiAgICAgIHRvdWNoOiB7fVxuICAgIH07XG4gICAgdGhpcy5hbmltYXRpb25UaW1lciA9IG51bGw7XG5cbiAgICAvLyBkcmFnIGxpc3RlbmVycyBmb3IgZHJhZ2dpbmdcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbigncGFuc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbigncGFubW92ZScsIHRoaXMuX29uRHJhZy5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbigncGFuZW5kJywgdGhpcy5fb25EcmFnRW5kLmJpbmQodGhpcykpO1xuXG4gICAgLy8gbW91c2Ugd2hlZWwgZm9yIHpvb21pbmdcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignbW91c2V3aGVlbCcsIHRoaXMuX29uTW91c2VXaGVlbC5iaW5kKHRoaXMpKTtcblxuICAgIC8vIHBpbmNoIHRvIHpvb21cbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbigndG91Y2gnLCB0aGlzLl9vblRvdWNoLmJpbmQodGhpcykpO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdwaW5jaCcsIHRoaXMuX29uUGluY2guYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICBSYW5nZS5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cbiAgLyoqXG4gICAqIFNldCBvcHRpb25zIGZvciB0aGUgcmFuZ2UgY29udHJvbGxlclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXIgfCBEYXRlIHwgU3RyaW5nfSBzdGFydCAgU3RhcnQgZGF0ZSBmb3IgdGhlIHJhbmdlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlciB8IERhdGUgfCBTdHJpbmd9IGVuZCAgICBFbmQgZGF0ZSBmb3IgdGhlIHJhbmdlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gbWluICAgIE1pbmltdW0gdmFsdWUgZm9yIHN0YXJ0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gbWF4ICAgIE1heGltdW0gdmFsdWUgZm9yIGVuZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IHpvb21NaW4gICAgU2V0IGEgbWluaW11bSB2YWx1ZSBmb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlbmQgLSBzdGFydCkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gem9vbU1heCAgICBTZXQgYSBtYXhpbXVtIHZhbHVlIGZvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVuZCAtIHN0YXJ0KS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gbW92ZWFibGUgRW5hYmxlIG1vdmluZyBvZiB0aGUgcmFuZ2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgZHJhZ2dpbmcuIFRydWUgYnkgZGVmYXVsdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSB6b29tYWJsZSBFbmFibGUgem9vbWluZyBvZiB0aGUgcmFuZ2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgcGluY2hpbmcvc2Nyb2xsaW5nLiBUcnVlIGJ5IGRlZmF1bHRcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgLy8gY29weSB0aGUgb3B0aW9ucyB0aGF0IHdlIGtub3dcbiAgICAgIHZhciBmaWVsZHMgPSBbJ2RpcmVjdGlvbicsICdtaW4nLCAnbWF4JywgJ3pvb21NaW4nLCAnem9vbU1heCcsICdtb3ZlYWJsZScsICd6b29tYWJsZScsICdtb21lbnQnLCAnYWN0aXZhdGUnLCAnaGlkZGVuRGF0ZXMnLCAnem9vbUtleScsICdydGwnLCAnaG9yaXpvbnRhbFNjcm9sbCddO1xuICAgICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoJ3N0YXJ0JyBpbiBvcHRpb25zIHx8ICdlbmQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gYXBwbHkgYSBuZXcgcmFuZ2UuIGJvdGggc3RhcnQgYW5kIGVuZCBhcmUgb3B0aW9uYWxcbiAgICAgICAgdGhpcy5zZXRSYW5nZShvcHRpb25zLnN0YXJ0LCBvcHRpb25zLmVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgZGlyZWN0aW9uIGhhcyBhIHZhbGlkIHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gICAgJ2hvcml6b250YWwnIG9yICd2ZXJ0aWNhbCdcbiAgICovXG4gIGZ1bmN0aW9uIHZhbGlkYXRlRGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gIT0gJ2hvcml6b250YWwnICYmIGRpcmVjdGlvbiAhPSAndmVydGljYWwnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGRpcmVjdGlvbiBcIicgKyBkaXJlY3Rpb24gKyAnXCIuICcgKyAnQ2hvb3NlIFwiaG9yaXpvbnRhbFwiIG9yIFwidmVydGljYWxcIi4nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgbmV3IHN0YXJ0IGFuZCBlbmQgcmFuZ2VcbiAgICogQHBhcmFtIHtEYXRlIHwgTnVtYmVyIHwgU3RyaW5nfSBbc3RhcnRdXG4gICAqIEBwYXJhbSB7RGF0ZSB8IE51bWJlciB8IFN0cmluZ30gW2VuZF1cbiAgICogQHBhcmFtIHtib29sZWFuIHwge2R1cmF0aW9uOiBudW1iZXIsIGVhc2luZ0Z1bmN0aW9uOiBzdHJpbmd9fSBbYW5pbWF0aW9uPWZhbHNlXVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCB0aGUgcmFuZ2UgaXMgYW5pbWF0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhseSB0byB0aGUgbmV3IHdpbmRvdy4gQW4gb2JqZWN0IGNhbiBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkIHRvIHNwZWNpZnkgZHVyYXRpb24gYW5kIGVhc2luZyBmdW5jdGlvbi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGR1cmF0aW9uIGlzIDUwMCBtcywgYW5kIGRlZmF1bHQgZWFzaW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaXMgJ2Vhc2VJbk91dFF1YWQnLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtieVVzZXI9ZmFsc2VdXG4gICAqXG4gICAqL1xuICBSYW5nZS5wcm90b3R5cGUuc2V0UmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgYW5pbWF0aW9uLCBieVVzZXIpIHtcbiAgICBpZiAoYnlVc2VyICE9PSB0cnVlKSB7XG4gICAgICBieVVzZXIgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGZpbmFsU3RhcnQgPSBzdGFydCAhPSB1bmRlZmluZWQgPyB1dGlsLmNvbnZlcnQoc3RhcnQsICdEYXRlJykudmFsdWVPZigpIDogbnVsbDtcbiAgICB2YXIgZmluYWxFbmQgPSBlbmQgIT0gdW5kZWZpbmVkID8gdXRpbC5jb252ZXJ0KGVuZCwgJ0RhdGUnKS52YWx1ZU9mKCkgOiBudWxsO1xuICAgIHRoaXMuX2NhbmNlbEFuaW1hdGlvbigpO1xuXG4gICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgLy8gdHJ1ZSBvciBhbiBPYmplY3RcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB2YXIgaW5pdFN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgIHZhciBpbml0RW5kID0gdGhpcy5lbmQ7XG4gICAgICB2YXIgZHVyYXRpb24gPSAodHlwZW9mIGFuaW1hdGlvbiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYW5pbWF0aW9uKSkgPT09ICdvYmplY3QnICYmICdkdXJhdGlvbicgaW4gYW5pbWF0aW9uID8gYW5pbWF0aW9uLmR1cmF0aW9uIDogNTAwO1xuICAgICAgdmFyIGVhc2luZ05hbWUgPSAodHlwZW9mIGFuaW1hdGlvbiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYW5pbWF0aW9uKSkgPT09ICdvYmplY3QnICYmICdlYXNpbmdGdW5jdGlvbicgaW4gYW5pbWF0aW9uID8gYW5pbWF0aW9uLmVhc2luZ0Z1bmN0aW9uIDogJ2Vhc2VJbk91dFF1YWQnO1xuICAgICAgdmFyIGVhc2luZ0Z1bmN0aW9uID0gdXRpbC5lYXNpbmdGdW5jdGlvbnNbZWFzaW5nTmFtZV07XG4gICAgICBpZiAoIWVhc2luZ0Z1bmN0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlYXNpbmcgZnVuY3Rpb24gJyArIEpTT04uc3RyaW5naWZ5KGVhc2luZ05hbWUpICsgJy4gJyArICdDaG9vc2UgZnJvbTogJyArIE9iamVjdC5rZXlzKHV0aWwuZWFzaW5nRnVuY3Rpb25zKS5qb2luKCcsICcpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluaXRUaW1lID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICB2YXIgYW55Q2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIGlmICghbWUucHJvcHMudG91Y2guZHJhZ2dpbmcpIHtcbiAgICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICAgICAgdmFyIHRpbWUgPSBub3cgLSBpbml0VGltZTtcbiAgICAgICAgICB2YXIgZWFzZSA9IGVhc2luZ0Z1bmN0aW9uKHRpbWUgLyBkdXJhdGlvbik7XG4gICAgICAgICAgdmFyIGRvbmUgPSB0aW1lID4gZHVyYXRpb247XG4gICAgICAgICAgdmFyIHMgPSBkb25lIHx8IGZpbmFsU3RhcnQgPT09IG51bGwgPyBmaW5hbFN0YXJ0IDogaW5pdFN0YXJ0ICsgKGZpbmFsU3RhcnQgLSBpbml0U3RhcnQpICogZWFzZTtcbiAgICAgICAgICB2YXIgZSA9IGRvbmUgfHwgZmluYWxFbmQgPT09IG51bGwgPyBmaW5hbEVuZCA6IGluaXRFbmQgKyAoZmluYWxFbmQgLSBpbml0RW5kKSAqIGVhc2U7XG5cbiAgICAgICAgICBjaGFuZ2VkID0gbWUuX2FwcGx5UmFuZ2UocywgZSk7XG4gICAgICAgICAgRGF0ZVV0aWwudXBkYXRlSGlkZGVuRGF0ZXMobWUub3B0aW9ucy5tb21lbnQsIG1lLmJvZHksIG1lLm9wdGlvbnMuaGlkZGVuRGF0ZXMpO1xuICAgICAgICAgIGFueUNoYW5nZWQgPSBhbnlDaGFuZ2VkIHx8IGNoYW5nZWQ7XG4gICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIG1lLmJvZHkuZW1pdHRlci5lbWl0KCdyYW5nZWNoYW5nZScsIHsgc3RhcnQ6IG5ldyBEYXRlKG1lLnN0YXJ0KSwgZW5kOiBuZXcgRGF0ZShtZS5lbmQpLCBieVVzZXI6IGJ5VXNlciB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgaWYgKGFueUNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgbWUuYm9keS5lbWl0dGVyLmVtaXQoJ3JhbmdlY2hhbmdlZCcsIHsgc3RhcnQ6IG5ldyBEYXRlKG1lLnN0YXJ0KSwgZW5kOiBuZXcgRGF0ZShtZS5lbmQpLCBieVVzZXI6IGJ5VXNlciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gYW5pbWF0ZSB3aXRoIGFzIGhpZ2ggYXMgcG9zc2libGUgZnJhbWUgcmF0ZSwgbGVhdmUgMjAgbXMgaW4gYmV0d2VlblxuICAgICAgICAgICAgLy8gZWFjaCB0byBwcmV2ZW50IHRoZSBicm93c2VyIGZyb20gYmxvY2tpbmdcbiAgICAgICAgICAgIG1lLmFuaW1hdGlvblRpbWVyID0gc2V0VGltZW91dChuZXh0LCAyMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2hhbmdlZCA9IHRoaXMuX2FwcGx5UmFuZ2UoZmluYWxTdGFydCwgZmluYWxFbmQpO1xuICAgICAgRGF0ZVV0aWwudXBkYXRlSGlkZGVuRGF0ZXModGhpcy5vcHRpb25zLm1vbWVudCwgdGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMuaGlkZGVuRGF0ZXMpO1xuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHsgc3RhcnQ6IG5ldyBEYXRlKHRoaXMuc3RhcnQpLCBlbmQ6IG5ldyBEYXRlKHRoaXMuZW5kKSwgYnlVc2VyOiBieVVzZXIgfTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgncmFuZ2VjaGFuZ2UnLCBwYXJhbXMpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdyYW5nZWNoYW5nZWQnLCBwYXJhbXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3RvcCBhbiBhbmltYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5fY2FuY2VsQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmFuaW1hdGlvblRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5hbmltYXRpb25UaW1lcik7XG4gICAgICB0aGlzLmFuaW1hdGlvblRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIG5ldyBzdGFydCBhbmQgZW5kIHJhbmdlLiBUaGlzIG1ldGhvZCBpcyB0aGUgc2FtZSBhcyBzZXRSYW5nZSwgYnV0XG4gICAqIGRvZXMgbm90IHRyaWdnZXIgYSByYW5nZSBjaGFuZ2UgYW5kIHJhbmdlIGNoYW5nZWQgZXZlbnQsIGFuZCBpdCByZXR1cm5zXG4gICAqIHRydWUgd2hlbiB0aGUgcmFuZ2UgaXMgY2hhbmdlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0XVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZF1cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gY2hhbmdlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLl9hcHBseVJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgbmV3U3RhcnQgPSBzdGFydCAhPSBudWxsID8gdXRpbC5jb252ZXJ0KHN0YXJ0LCAnRGF0ZScpLnZhbHVlT2YoKSA6IHRoaXMuc3RhcnQsXG4gICAgICAgIG5ld0VuZCA9IGVuZCAhPSBudWxsID8gdXRpbC5jb252ZXJ0KGVuZCwgJ0RhdGUnKS52YWx1ZU9mKCkgOiB0aGlzLmVuZCxcbiAgICAgICAgbWF4ID0gdGhpcy5vcHRpb25zLm1heCAhPSBudWxsID8gdXRpbC5jb252ZXJ0KHRoaXMub3B0aW9ucy5tYXgsICdEYXRlJykudmFsdWVPZigpIDogbnVsbCxcbiAgICAgICAgbWluID0gdGhpcy5vcHRpb25zLm1pbiAhPSBudWxsID8gdXRpbC5jb252ZXJ0KHRoaXMub3B0aW9ucy5taW4sICdEYXRlJykudmFsdWVPZigpIDogbnVsbCxcbiAgICAgICAgZGlmZjtcblxuICAgIC8vIGNoZWNrIGZvciB2YWxpZCBudW1iZXJcbiAgICBpZiAoaXNOYU4obmV3U3RhcnQpIHx8IG5ld1N0YXJ0ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhcnQgXCInICsgc3RhcnQgKyAnXCInKTtcbiAgICB9XG4gICAgaWYgKGlzTmFOKG5ld0VuZCkgfHwgbmV3RW5kID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5kIFwiJyArIGVuZCArICdcIicpO1xuICAgIH1cblxuICAgIC8vIHByZXZlbnQgc3RhcnQgPCBlbmRcbiAgICBpZiAobmV3RW5kIDwgbmV3U3RhcnQpIHtcbiAgICAgIG5ld0VuZCA9IG5ld1N0YXJ0O1xuICAgIH1cblxuICAgIC8vIHByZXZlbnQgc3RhcnQgPCBtaW5cbiAgICBpZiAobWluICE9PSBudWxsKSB7XG4gICAgICBpZiAobmV3U3RhcnQgPCBtaW4pIHtcbiAgICAgICAgZGlmZiA9IG1pbiAtIG5ld1N0YXJ0O1xuICAgICAgICBuZXdTdGFydCArPSBkaWZmO1xuICAgICAgICBuZXdFbmQgKz0gZGlmZjtcblxuICAgICAgICAvLyBwcmV2ZW50IGVuZCA+IG1heFxuICAgICAgICBpZiAobWF4ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAobmV3RW5kID4gbWF4KSB7XG4gICAgICAgICAgICBuZXdFbmQgPSBtYXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcHJldmVudCBlbmQgPiBtYXhcbiAgICBpZiAobWF4ICE9PSBudWxsKSB7XG4gICAgICBpZiAobmV3RW5kID4gbWF4KSB7XG4gICAgICAgIGRpZmYgPSBuZXdFbmQgLSBtYXg7XG4gICAgICAgIG5ld1N0YXJ0IC09IGRpZmY7XG4gICAgICAgIG5ld0VuZCAtPSBkaWZmO1xuXG4gICAgICAgIC8vIHByZXZlbnQgc3RhcnQgPCBtaW5cbiAgICAgICAgaWYgKG1pbiAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKG5ld1N0YXJ0IDwgbWluKSB7XG4gICAgICAgICAgICBuZXdTdGFydCA9IG1pbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwcmV2ZW50IChlbmQtc3RhcnQpIDwgem9vbU1pblxuICAgIGlmICh0aGlzLm9wdGlvbnMuem9vbU1pbiAhPT0gbnVsbCkge1xuICAgICAgdmFyIHpvb21NaW4gPSBwYXJzZUZsb2F0KHRoaXMub3B0aW9ucy56b29tTWluKTtcbiAgICAgIGlmICh6b29tTWluIDwgMCkge1xuICAgICAgICB6b29tTWluID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdFbmQgLSBuZXdTdGFydCA8IHpvb21NaW4pIHtcbiAgICAgICAgaWYgKHRoaXMuZW5kIC0gdGhpcy5zdGFydCA9PT0gem9vbU1pbiAmJiBuZXdTdGFydCA+IHRoaXMuc3RhcnQgJiYgbmV3RW5kIDwgdGhpcy5lbmQpIHtcbiAgICAgICAgICAvLyBpZ25vcmUgdGhpcyBhY3Rpb24sIHdlIGFyZSBhbHJlYWR5IHpvb21lZCB0byB0aGUgbWluaW11bVxuICAgICAgICAgIG5ld1N0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgICBuZXdFbmQgPSB0aGlzLmVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB6b29tIHRvIHRoZSBtaW5pbXVtXG4gICAgICAgICAgZGlmZiA9IHpvb21NaW4gLSAobmV3RW5kIC0gbmV3U3RhcnQpO1xuICAgICAgICAgIG5ld1N0YXJ0IC09IGRpZmYgLyAyO1xuICAgICAgICAgIG5ld0VuZCArPSBkaWZmIC8gMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHByZXZlbnQgKGVuZC1zdGFydCkgPiB6b29tTWF4XG4gICAgaWYgKHRoaXMub3B0aW9ucy56b29tTWF4ICE9PSBudWxsKSB7XG4gICAgICB2YXIgem9vbU1heCA9IHBhcnNlRmxvYXQodGhpcy5vcHRpb25zLnpvb21NYXgpO1xuICAgICAgaWYgKHpvb21NYXggPCAwKSB7XG4gICAgICAgIHpvb21NYXggPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3RW5kIC0gbmV3U3RhcnQgPiB6b29tTWF4KSB7XG4gICAgICAgIGlmICh0aGlzLmVuZCAtIHRoaXMuc3RhcnQgPT09IHpvb21NYXggJiYgbmV3U3RhcnQgPCB0aGlzLnN0YXJ0ICYmIG5ld0VuZCA+IHRoaXMuZW5kKSB7XG4gICAgICAgICAgLy8gaWdub3JlIHRoaXMgYWN0aW9uLCB3ZSBhcmUgYWxyZWFkeSB6b29tZWQgdG8gdGhlIG1heGltdW1cbiAgICAgICAgICBuZXdTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgICAgbmV3RW5kID0gdGhpcy5lbmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gem9vbSB0byB0aGUgbWF4aW11bVxuICAgICAgICAgIGRpZmYgPSBuZXdFbmQgLSBuZXdTdGFydCAtIHpvb21NYXg7XG4gICAgICAgICAgbmV3U3RhcnQgKz0gZGlmZiAvIDI7XG4gICAgICAgICAgbmV3RW5kIC09IGRpZmYgLyAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYW5nZWQgPSB0aGlzLnN0YXJ0ICE9IG5ld1N0YXJ0IHx8IHRoaXMuZW5kICE9IG5ld0VuZDtcblxuICAgIC8vIGlmIHRoZSBuZXcgcmFuZ2UgZG9lcyBOT1Qgb3ZlcmxhcCB3aXRoIHRoZSBvbGQgcmFuZ2UsIGVtaXQgY2hlY2tSYW5nZWRJdGVtcyB0byBhdm9pZCBub3Qgc2hvd2luZyByYW5nZWQgaXRlbXMgKHJhbmdlZCBtZWFuaW5nIGhhcyBlbmQgdGltZSwgbm90IG5lY2Vzc2FyaWx5IG9mIHR5cGUgUmFuZ2UpXG4gICAgaWYgKCEobmV3U3RhcnQgPj0gdGhpcy5zdGFydCAmJiBuZXdTdGFydCA8PSB0aGlzLmVuZCB8fCBuZXdFbmQgPj0gdGhpcy5zdGFydCAmJiBuZXdFbmQgPD0gdGhpcy5lbmQpICYmICEodGhpcy5zdGFydCA+PSBuZXdTdGFydCAmJiB0aGlzLnN0YXJ0IDw9IG5ld0VuZCB8fCB0aGlzLmVuZCA+PSBuZXdTdGFydCAmJiB0aGlzLmVuZCA8PSBuZXdFbmQpKSB7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdjaGVja1JhbmdlZEl0ZW1zJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGFydCA9IG5ld1N0YXJ0O1xuICAgIHRoaXMuZW5kID0gbmV3RW5kO1xuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudCByYW5nZS5cbiAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBzdGFydCBhbmQgZW5kIHByb3BlcnRpZXNcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5nZXRSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQsXG4gICAgICBlbmQ6IHRoaXMuZW5kXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjb252ZXJzaW9uIG9mZnNldCBhbmQgc2NhbGUgZm9yIGN1cnJlbnQgcmFuZ2UsIGJhc2VkIG9uXG4gICAqIHRoZSBwcm92aWRlZCB3aWR0aFxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICogQHJldHVybnMge3tvZmZzZXQ6IG51bWJlciwgc2NhbGU6IG51bWJlcn19IGNvbnZlcnNpb25cbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5jb252ZXJzaW9uID0gZnVuY3Rpb24gKHdpZHRoLCB0b3RhbEhpZGRlbikge1xuICAgIHJldHVybiBSYW5nZS5jb252ZXJzaW9uKHRoaXMuc3RhcnQsIHRoaXMuZW5kLCB3aWR0aCwgdG90YWxIaWRkZW4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdGF0aWMgbWV0aG9kIHRvIGNhbGN1bGF0ZSB0aGUgY29udmVyc2lvbiBvZmZzZXQgYW5kIHNjYWxlIGZvciBhIHJhbmdlLFxuICAgKiBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgc3RhcnQsIGVuZCwgYW5kIHdpZHRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgKiBAcmV0dXJucyB7e29mZnNldDogbnVtYmVyLCBzY2FsZTogbnVtYmVyfX0gY29udmVyc2lvblxuICAgKi9cbiAgUmFuZ2UuY29udmVyc2lvbiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCB3aWR0aCwgdG90YWxIaWRkZW4pIHtcbiAgICBpZiAodG90YWxIaWRkZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdG90YWxIaWRkZW4gPSAwO1xuICAgIH1cbiAgICBpZiAod2lkdGggIT0gMCAmJiBlbmQgLSBzdGFydCAhPSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvZmZzZXQ6IHN0YXJ0LFxuICAgICAgICBzY2FsZTogd2lkdGggLyAoZW5kIC0gc3RhcnQgLSB0b3RhbEhpZGRlbilcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgc2NhbGU6IDFcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydCBkcmFnZ2luZyBob3Jpem9udGFsbHkgb3IgdmVydGljYWxseVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuZGVsdGFEaWZmZXJlbmNlID0gMDtcbiAgICB0aGlzLnByZXZpb3VzRGVsdGEgPSAwO1xuXG4gICAgLy8gb25seSBhbGxvdyBkcmFnZ2luZyB3aGVuIGNvbmZpZ3VyZWQgYXMgbW92YWJsZVxuICAgIGlmICghdGhpcy5vcHRpb25zLm1vdmVhYmxlKSByZXR1cm47XG5cbiAgICAvLyBvbmx5IHN0YXJ0IGRyYWdnaW5nIHdoZW4gdGhlIG1vdXNlIGlzIGluc2lkZSB0aGUgY3VycmVudCByYW5nZVxuICAgIGlmICghdGhpcy5faXNJbnNpZGVSYW5nZShldmVudCkpIHJldHVybjtcblxuICAgIC8vIHJlZnVzZSB0byBkcmFnIHdoZW4gd2Ugd2hlcmUgcGluY2hpbmcgdG8gcHJldmVudCB0aGUgdGltZWxpbmUgbWFrZSBhIGp1bXBcbiAgICAvLyB3aGVuIHJlbGVhc2luZyB0aGUgZmluZ2VycyBpbiBvcHBvc2l0ZSBvcmRlciBmcm9tIHRoZSB0b3VjaCBzY3JlZW5cbiAgICBpZiAoIXRoaXMucHJvcHMudG91Y2guYWxsb3dEcmFnZ2luZykgcmV0dXJuO1xuXG4gICAgdGhpcy5wcm9wcy50b3VjaC5zdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgdGhpcy5wcm9wcy50b3VjaC5lbmQgPSB0aGlzLmVuZDtcbiAgICB0aGlzLnByb3BzLnRvdWNoLmRyYWdnaW5nID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLmJvZHkuZG9tLnJvb3QpIHtcbiAgICAgIHRoaXMuYm9keS5kb20ucm9vdC5zdHlsZS5jdXJzb3IgPSAnbW92ZSc7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGRyYWdnaW5nIG9wZXJhdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLl9vbkRyYWcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50KSByZXR1cm47XG5cbiAgICBpZiAoIXRoaXMucHJvcHMudG91Y2guZHJhZ2dpbmcpIHJldHVybjtcblxuICAgIC8vIG9ubHkgYWxsb3cgZHJhZ2dpbmcgd2hlbiBjb25maWd1cmVkIGFzIG1vdmFibGVcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5tb3ZlYWJsZSkgcmV0dXJuO1xuXG4gICAgLy8gVE9ETzogdGhpcyBtYXkgYmUgcmVkdW5kYW50IGluIGhhbW1lcmpzMlxuICAgIC8vIHJlZnVzZSB0byBkcmFnIHdoZW4gd2Ugd2hlcmUgcGluY2hpbmcgdG8gcHJldmVudCB0aGUgdGltZWxpbmUgbWFrZSBhIGp1bXBcbiAgICAvLyB3aGVuIHJlbGVhc2luZyB0aGUgZmluZ2VycyBpbiBvcHBvc2l0ZSBvcmRlciBmcm9tIHRoZSB0b3VjaCBzY3JlZW5cbiAgICBpZiAoIXRoaXMucHJvcHMudG91Y2guYWxsb3dEcmFnZ2luZykgcmV0dXJuO1xuXG4gICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgdmFsaWRhdGVEaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICB2YXIgZGVsdGEgPSBkaXJlY3Rpb24gPT0gJ2hvcml6b250YWwnID8gZXZlbnQuZGVsdGFYIDogZXZlbnQuZGVsdGFZO1xuICAgIGRlbHRhIC09IHRoaXMuZGVsdGFEaWZmZXJlbmNlO1xuICAgIHZhciBpbnRlcnZhbCA9IHRoaXMucHJvcHMudG91Y2guZW5kIC0gdGhpcy5wcm9wcy50b3VjaC5zdGFydDtcblxuICAgIC8vIG5vcm1hbGl6ZSBkcmFnZ2luZyBzcGVlZCBpZiBjdXRvdXQgaXMgaW4gYmV0d2Vlbi5cbiAgICB2YXIgZHVyYXRpb24gPSBEYXRlVXRpbC5nZXRIaWRkZW5EdXJhdGlvbkJldHdlZW4odGhpcy5ib2R5LmhpZGRlbkRhdGVzLCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgaW50ZXJ2YWwgLT0gZHVyYXRpb247XG5cbiAgICB2YXIgd2lkdGggPSBkaXJlY3Rpb24gPT0gJ2hvcml6b250YWwnID8gdGhpcy5ib2R5LmRvbVByb3BzLmNlbnRlci53aWR0aCA6IHRoaXMuYm9keS5kb21Qcm9wcy5jZW50ZXIuaGVpZ2h0O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgIHZhciBkaWZmUmFuZ2UgPSBkZWx0YSAvIHdpZHRoICogaW50ZXJ2YWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaWZmUmFuZ2UgPSAtZGVsdGEgLyB3aWR0aCAqIGludGVydmFsO1xuICAgIH1cblxuICAgIHZhciBuZXdTdGFydCA9IHRoaXMucHJvcHMudG91Y2guc3RhcnQgKyBkaWZmUmFuZ2U7XG4gICAgdmFyIG5ld0VuZCA9IHRoaXMucHJvcHMudG91Y2guZW5kICsgZGlmZlJhbmdlO1xuXG4gICAgLy8gc25hcHBpbmcgdGltZXMgYXdheSBmcm9tIGhpZGRlbiB6b25lc1xuICAgIHZhciBzYWZlU3RhcnQgPSBEYXRlVXRpbC5zbmFwQXdheUZyb21IaWRkZW4odGhpcy5ib2R5LmhpZGRlbkRhdGVzLCBuZXdTdGFydCwgdGhpcy5wcmV2aW91c0RlbHRhIC0gZGVsdGEsIHRydWUpO1xuICAgIHZhciBzYWZlRW5kID0gRGF0ZVV0aWwuc25hcEF3YXlGcm9tSGlkZGVuKHRoaXMuYm9keS5oaWRkZW5EYXRlcywgbmV3RW5kLCB0aGlzLnByZXZpb3VzRGVsdGEgLSBkZWx0YSwgdHJ1ZSk7XG4gICAgaWYgKHNhZmVTdGFydCAhPSBuZXdTdGFydCB8fCBzYWZlRW5kICE9IG5ld0VuZCkge1xuICAgICAgdGhpcy5kZWx0YURpZmZlcmVuY2UgKz0gZGVsdGE7XG4gICAgICB0aGlzLnByb3BzLnRvdWNoLnN0YXJ0ID0gc2FmZVN0YXJ0O1xuICAgICAgdGhpcy5wcm9wcy50b3VjaC5lbmQgPSBzYWZlRW5kO1xuICAgICAgdGhpcy5fb25EcmFnKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnByZXZpb3VzRGVsdGEgPSBkZWx0YTtcbiAgICB0aGlzLl9hcHBseVJhbmdlKG5ld1N0YXJ0LCBuZXdFbmQpO1xuXG4gICAgdmFyIHN0YXJ0RGF0ZSA9IG5ldyBEYXRlKHRoaXMuc3RhcnQpO1xuICAgIHZhciBlbmREYXRlID0gbmV3IERhdGUodGhpcy5lbmQpO1xuXG4gICAgLy8gZmlyZSBhIHJhbmdlY2hhbmdlIGV2ZW50XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgncmFuZ2VjaGFuZ2UnLCB7XG4gICAgICBzdGFydDogc3RhcnREYXRlLFxuICAgICAgZW5kOiBlbmREYXRlLFxuICAgICAgYnlVc2VyOiB0cnVlXG4gICAgfSk7XG5cbiAgICAvLyBmaXJlIGEgcGFubW92ZSBldmVudFxuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3Bhbm1vdmUnKTtcbiAgfTtcblxuICAvKipcbiAgICogU3RvcCBkcmFnZ2luZyBvcGVyYXRpb25cbiAgICogQHBhcmFtIHtldmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5fb25EcmFnRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnByb3BzLnRvdWNoLmRyYWdnaW5nKSByZXR1cm47XG5cbiAgICAvLyBvbmx5IGFsbG93IGRyYWdnaW5nIHdoZW4gY29uZmlndXJlZCBhcyBtb3ZhYmxlXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMubW92ZWFibGUpIHJldHVybjtcblxuICAgIC8vIFRPRE86IHRoaXMgbWF5IGJlIHJlZHVuZGFudCBpbiBoYW1tZXJqczJcbiAgICAvLyByZWZ1c2UgdG8gZHJhZyB3aGVuIHdlIHdoZXJlIHBpbmNoaW5nIHRvIHByZXZlbnQgdGhlIHRpbWVsaW5lIG1ha2UgYSBqdW1wXG4gICAgLy8gd2hlbiByZWxlYXNpbmcgdGhlIGZpbmdlcnMgaW4gb3Bwb3NpdGUgb3JkZXIgZnJvbSB0aGUgdG91Y2ggc2NyZWVuXG4gICAgaWYgKCF0aGlzLnByb3BzLnRvdWNoLmFsbG93RHJhZ2dpbmcpIHJldHVybjtcblxuICAgIHRoaXMucHJvcHMudG91Y2guZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5ib2R5LmRvbS5yb290KSB7XG4gICAgICB0aGlzLmJvZHkuZG9tLnJvb3Quc3R5bGUuY3Vyc29yID0gJ2F1dG8nO1xuICAgIH1cblxuICAgIC8vIGZpcmUgYSByYW5nZWNoYW5nZWQgZXZlbnRcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdyYW5nZWNoYW5nZWQnLCB7XG4gICAgICBzdGFydDogbmV3IERhdGUodGhpcy5zdGFydCksXG4gICAgICBlbmQ6IG5ldyBEYXRlKHRoaXMuZW5kKSxcbiAgICAgIGJ5VXNlcjogdHJ1ZVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBtb3VzZSB3aGVlbCBldmVudCwgdXNlZCB0byB6b29tXG4gICAqIENvZGUgZnJvbSBodHRwOi8vYWRvbWFzLm9yZy9qYXZhc2NyaXB0LW1vdXNlLXdoZWVsL1xuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLl9vbk1vdXNlV2hlZWwgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBQcmV2ZW50IGRlZmF1bHQgYWN0aW9ucyBjYXVzZWQgYnkgbW91c2Ugd2hlZWxcbiAgICAvLyAoZWxzZSB0aGUgcGFnZSBhbmQgdGltZWxpbmUgYm90aCB6b29tIGFuZCBzY3JvbGwpXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIC8vIHJldHJpZXZlIGRlbHRhXG4gICAgdmFyIGRlbHRhID0gMDtcbiAgICBpZiAoZXZlbnQud2hlZWxEZWx0YSkge1xuICAgICAgLyogSUUvT3BlcmEuICovXG4gICAgICBkZWx0YSA9IGV2ZW50LndoZWVsRGVsdGEgLyAxMjA7XG4gICAgfSBlbHNlIGlmIChldmVudC5kZXRhaWwpIHtcbiAgICAgIC8qIE1vemlsbGEgY2FzZS4gKi9cbiAgICAgIC8vIEluIE1vemlsbGEsIHNpZ24gb2YgZGVsdGEgaXMgZGlmZmVyZW50IHRoYW4gaW4gSUUuXG4gICAgICAvLyBBbHNvLCBkZWx0YSBpcyBtdWx0aXBsZSBvZiAzLlxuICAgICAgZGVsdGEgPSAtZXZlbnQuZGV0YWlsIC8gMztcbiAgICB9XG5cbiAgICAvLyBkb24ndCBhbGxvdyB6b29tIHdoZW4gdGhlIGFjY29yZGluZyBrZXkgaXMgcHJlc3NlZCBhbmQgdGhlIHpvb21LZXkgb3B0aW9uIG9yIG5vdCB6b29tYWJsZSBidXQgbW92YWJsZVxuICAgIGlmICh0aGlzLm9wdGlvbnMuem9vbUtleSAmJiAhZXZlbnRbdGhpcy5vcHRpb25zLnpvb21LZXldICYmIHRoaXMub3B0aW9ucy56b29tYWJsZSB8fCAhdGhpcy5vcHRpb25zLnpvb21hYmxlICYmIHRoaXMub3B0aW9ucy5tb3ZlYWJsZSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ob3Jpem9udGFsU2Nyb2xsKSB7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBhIHNpbmdsZSBzY3JvbGwganVtcCByZWxhdGl2ZSB0byB0aGUgcmFuZ2Ugc2NhbGVcbiAgICAgICAgdmFyIGRpZmYgPSBkZWx0YSAqICh0aGlzLmVuZCAtIHRoaXMuc3RhcnQpIC8gMjA7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgYW5kIGVuZFxuICAgICAgICB2YXIgbmV3U3RhcnQgPSB0aGlzLnN0YXJ0IC0gZGlmZjtcbiAgICAgICAgdmFyIG5ld0VuZCA9IHRoaXMuZW5kIC0gZGlmZjtcblxuICAgICAgICB0aGlzLnNldFJhbmdlKG5ld1N0YXJ0LCBuZXdFbmQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIG9ubHkgYWxsb3cgem9vbWluZyB3aGVuIGNvbmZpZ3VyZWQgYXMgem9vbWFibGUgYW5kIG1vdmVhYmxlXG4gICAgaWYgKCEodGhpcy5vcHRpb25zLnpvb21hYmxlICYmIHRoaXMub3B0aW9ucy5tb3ZlYWJsZSkpIHJldHVybjtcblxuICAgIC8vIG9ubHkgem9vbSB3aGVuIHRoZSBtb3VzZSBpcyBpbnNpZGUgdGhlIGN1cnJlbnQgcmFuZ2VcbiAgICBpZiAoIXRoaXMuX2lzSW5zaWRlUmFuZ2UoZXZlbnQpKSByZXR1cm47XG5cbiAgICAvLyBJZiBkZWx0YSBpcyBub256ZXJvLCBoYW5kbGUgaXQuXG4gICAgLy8gQmFzaWNhbGx5LCBkZWx0YSBpcyBub3cgcG9zaXRpdmUgaWYgd2hlZWwgd2FzIHNjcm9sbGVkIHVwLFxuICAgIC8vIGFuZCBuZWdhdGl2ZSwgaWYgd2hlZWwgd2FzIHNjcm9sbGVkIGRvd24uXG4gICAgaWYgKGRlbHRhKSB7XG4gICAgICAvLyBwZXJmb3JtIHRoZSB6b29tIGFjdGlvbi4gRGVsdGEgaXMgbm9ybWFsbHkgMSBvciAtMVxuXG4gICAgICAvLyBhZGp1c3QgYSBuZWdhdGl2ZSBkZWx0YSBzdWNoIHRoYXQgem9vbWluZyBpbiB3aXRoIGRlbHRhIDAuMVxuICAgICAgLy8gZXF1YWxzIHpvb21pbmcgb3V0IHdpdGggYSBkZWx0YSAtMC4xXG4gICAgICB2YXIgc2NhbGU7XG4gICAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgIHNjYWxlID0gMSAtIGRlbHRhIC8gNTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjYWxlID0gMSAvICgxICsgZGVsdGEgLyA1KTtcbiAgICAgIH1cblxuICAgICAgLy8gY2FsY3VsYXRlIGNlbnRlciwgdGhlIGRhdGUgdG8gem9vbSBhcm91bmRcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9LCB0aGlzLmJvZHkuZG9tLmNlbnRlcik7XG4gICAgICB2YXIgcG9pbnRlckRhdGUgPSB0aGlzLl9wb2ludGVyVG9EYXRlKHBvaW50ZXIpO1xuXG4gICAgICB0aGlzLnpvb20oc2NhbGUsIHBvaW50ZXJEYXRlLCBkZWx0YSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydCBvZiBhIHRvdWNoIGdlc3R1cmVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5fb25Ub3VjaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMucHJvcHMudG91Y2guc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgIHRoaXMucHJvcHMudG91Y2guZW5kID0gdGhpcy5lbmQ7XG4gICAgdGhpcy5wcm9wcy50b3VjaC5hbGxvd0RyYWdnaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnByb3BzLnRvdWNoLmNlbnRlciA9IG51bGw7XG4gICAgdGhpcy5zY2FsZU9mZnNldCA9IDA7XG4gICAgdGhpcy5kZWx0YURpZmZlcmVuY2UgPSAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgcGluY2ggZXZlbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5fb25QaW5jaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIG9ubHkgYWxsb3cgem9vbWluZyB3aGVuIGNvbmZpZ3VyZWQgYXMgem9vbWFibGUgYW5kIG1vdmVhYmxlXG4gICAgaWYgKCEodGhpcy5vcHRpb25zLnpvb21hYmxlICYmIHRoaXMub3B0aW9ucy5tb3ZlYWJsZSkpIHJldHVybjtcblxuICAgIHRoaXMucHJvcHMudG91Y2guYWxsb3dEcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgaWYgKCF0aGlzLnByb3BzLnRvdWNoLmNlbnRlcikge1xuICAgICAgdGhpcy5wcm9wcy50b3VjaC5jZW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyLCB0aGlzLmJvZHkuZG9tLmNlbnRlcik7XG4gICAgfVxuXG4gICAgdmFyIHNjYWxlID0gMSAvIChldmVudC5zY2FsZSArIHRoaXMuc2NhbGVPZmZzZXQpO1xuICAgIHZhciBjZW50ZXJEYXRlID0gdGhpcy5fcG9pbnRlclRvRGF0ZSh0aGlzLnByb3BzLnRvdWNoLmNlbnRlcik7XG5cbiAgICB2YXIgaGlkZGVuRHVyYXRpb24gPSBEYXRlVXRpbC5nZXRIaWRkZW5EdXJhdGlvbkJldHdlZW4odGhpcy5ib2R5LmhpZGRlbkRhdGVzLCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgdmFyIGhpZGRlbkR1cmF0aW9uQmVmb3JlID0gRGF0ZVV0aWwuZ2V0SGlkZGVuRHVyYXRpb25CZWZvcmUodGhpcy5vcHRpb25zLm1vbWVudCwgdGhpcy5ib2R5LmhpZGRlbkRhdGVzLCB0aGlzLCBjZW50ZXJEYXRlKTtcbiAgICB2YXIgaGlkZGVuRHVyYXRpb25BZnRlciA9IGhpZGRlbkR1cmF0aW9uIC0gaGlkZGVuRHVyYXRpb25CZWZvcmU7XG5cbiAgICAvLyBjYWxjdWxhdGUgbmV3IHN0YXJ0IGFuZCBlbmRcbiAgICB2YXIgbmV3U3RhcnQgPSBjZW50ZXJEYXRlIC0gaGlkZGVuRHVyYXRpb25CZWZvcmUgKyAodGhpcy5wcm9wcy50b3VjaC5zdGFydCAtIChjZW50ZXJEYXRlIC0gaGlkZGVuRHVyYXRpb25CZWZvcmUpKSAqIHNjYWxlO1xuICAgIHZhciBuZXdFbmQgPSBjZW50ZXJEYXRlICsgaGlkZGVuRHVyYXRpb25BZnRlciArICh0aGlzLnByb3BzLnRvdWNoLmVuZCAtIChjZW50ZXJEYXRlICsgaGlkZGVuRHVyYXRpb25BZnRlcikpICogc2NhbGU7XG5cbiAgICAvLyBzbmFwcGluZyB0aW1lcyBhd2F5IGZyb20gaGlkZGVuIHpvbmVzXG4gICAgdGhpcy5zdGFydFRvRnJvbnQgPSAxIC0gc2NhbGUgPD0gMDsgLy8gdXNlZCB0byBkbyB0aGUgcmlnaHQgYXV0byBjb3JyZWN0aW9uIHdpdGggcGVyaW9kaWMgaGlkZGVuIHRpbWVzXG4gICAgdGhpcy5lbmRUb0Zyb250ID0gc2NhbGUgLSAxIDw9IDA7IC8vIHVzZWQgdG8gZG8gdGhlIHJpZ2h0IGF1dG8gY29ycmVjdGlvbiB3aXRoIHBlcmlvZGljIGhpZGRlbiB0aW1lc1xuXG4gICAgdmFyIHNhZmVTdGFydCA9IERhdGVVdGlsLnNuYXBBd2F5RnJvbUhpZGRlbih0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIG5ld1N0YXJ0LCAxIC0gc2NhbGUsIHRydWUpO1xuICAgIHZhciBzYWZlRW5kID0gRGF0ZVV0aWwuc25hcEF3YXlGcm9tSGlkZGVuKHRoaXMuYm9keS5oaWRkZW5EYXRlcywgbmV3RW5kLCBzY2FsZSAtIDEsIHRydWUpO1xuICAgIGlmIChzYWZlU3RhcnQgIT0gbmV3U3RhcnQgfHwgc2FmZUVuZCAhPSBuZXdFbmQpIHtcbiAgICAgIHRoaXMucHJvcHMudG91Y2guc3RhcnQgPSBzYWZlU3RhcnQ7XG4gICAgICB0aGlzLnByb3BzLnRvdWNoLmVuZCA9IHNhZmVFbmQ7XG4gICAgICB0aGlzLnNjYWxlT2Zmc2V0ID0gMSAtIGV2ZW50LnNjYWxlO1xuICAgICAgbmV3U3RhcnQgPSBzYWZlU3RhcnQ7XG4gICAgICBuZXdFbmQgPSBzYWZlRW5kO1xuICAgIH1cblxuICAgIHRoaXMuc2V0UmFuZ2UobmV3U3RhcnQsIG5ld0VuZCwgZmFsc2UsIHRydWUpO1xuXG4gICAgdGhpcy5zdGFydFRvRnJvbnQgPSBmYWxzZTsgLy8gcmV2ZXJ0IHRvIGRlZmF1bHRcbiAgICB0aGlzLmVuZFRvRnJvbnQgPSB0cnVlOyAvLyByZXZlcnQgdG8gZGVmYXVsdFxuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgdGhlIG1vdXNlIGZyb20gYSBtb3VzZSBldmVudCBpcyBpbnNpZGUgdGhlIHZpc2libGUgd2luZG93LFxuICAgKiBiZXR3ZWVuIHRoZSBjdXJyZW50IHN0YXJ0IGFuZCBlbmQgZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIHdoZW4gaW5zaWRlIHRoZSB2aXNpYmxlIHdpbmRvd1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLl9pc0luc2lkZVJhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSB0aW1lIHdoZXJlIHRoZSBtb3VzZSBpcywgY2hlY2sgd2hldGhlciBpbnNpZGVcbiAgICAvLyBhbmQgbm8gc2Nyb2xsIGFjdGlvbiBzaG91bGQgaGFwcGVuLlxuICAgIHZhciBjbGllbnRYID0gZXZlbnQuY2VudGVyID8gZXZlbnQuY2VudGVyLnggOiBldmVudC5jbGllbnRYO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICB2YXIgeCA9IGNsaWVudFggLSB1dGlsLmdldEFic29sdXRlTGVmdCh0aGlzLmJvZHkuZG9tLmNlbnRlckNvbnRhaW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB4ID0gdXRpbC5nZXRBYnNvbHV0ZVJpZ2h0KHRoaXMuYm9keS5kb20uY2VudGVyQ29udGFpbmVyKSAtIGNsaWVudFg7XG4gICAgfVxuICAgIHZhciB0aW1lID0gdGhpcy5ib2R5LnV0aWwudG9UaW1lKHgpO1xuXG4gICAgcmV0dXJuIHRpbWUgPj0gdGhpcy5zdGFydCAmJiB0aW1lIDw9IHRoaXMuZW5kO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIHRoZSBjZW50ZXIgZGF0ZSBmb3Igem9vbWluZ1xuICAgKiBAcGFyYW0ge3t4OiBOdW1iZXIsIHk6IE51bWJlcn19IHBvaW50ZXJcbiAgICogQHJldHVybiB7bnVtYmVyfSBkYXRlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBSYW5nZS5wcm90b3R5cGUuX3BvaW50ZXJUb0RhdGUgPSBmdW5jdGlvbiAocG9pbnRlcikge1xuICAgIHZhciBjb252ZXJzaW9uO1xuICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuXG4gICAgdmFsaWRhdGVEaXJlY3Rpb24oZGlyZWN0aW9uKTtcblxuICAgIGlmIChkaXJlY3Rpb24gPT0gJ2hvcml6b250YWwnKSB7XG4gICAgICByZXR1cm4gdGhpcy5ib2R5LnV0aWwudG9UaW1lKHBvaW50ZXIueCkudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5ib2R5LmRvbVByb3BzLmNlbnRlci5oZWlnaHQ7XG4gICAgICBjb252ZXJzaW9uID0gdGhpcy5jb252ZXJzaW9uKGhlaWdodCk7XG4gICAgICByZXR1cm4gcG9pbnRlci55IC8gY29udmVyc2lvbi5zY2FsZSArIGNvbnZlcnNpb24ub2Zmc2V0O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBwb2ludGVyIGxvY2F0aW9uIHJlbGF0aXZlIHRvIHRoZSBsb2NhdGlvbiBvZiB0aGUgZG9tIGVsZW1lbnRcbiAgICogQHBhcmFtIHt7eDogTnVtYmVyLCB5OiBOdW1iZXJ9fSB0b3VjaFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgICBIVE1MIERPTSBlbGVtZW50XG4gICAqIEByZXR1cm4ge3t4OiBOdW1iZXIsIHk6IE51bWJlcn19IHBvaW50ZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5nZXRQb2ludGVyID0gZnVuY3Rpb24gKHRvdWNoLCBlbGVtZW50KSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHV0aWwuZ2V0QWJzb2x1dGVSaWdodChlbGVtZW50KSAtIHRvdWNoLngsXG4gICAgICAgIHk6IHRvdWNoLnkgLSB1dGlsLmdldEFic29sdXRlVG9wKGVsZW1lbnQpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB0b3VjaC54IC0gdXRpbC5nZXRBYnNvbHV0ZUxlZnQoZWxlbWVudCksXG4gICAgICAgIHk6IHRvdWNoLnkgLSB1dGlsLmdldEFic29sdXRlVG9wKGVsZW1lbnQpXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogWm9vbSB0aGUgcmFuZ2UgdGhlIGdpdmVuIHNjYWxlIGluIG9yIG91dC4gU3RhcnQgYW5kIGVuZCBkYXRlIHdpbGxcbiAgICogYmUgYWRqdXN0ZWQsIGFuZCB0aGUgdGltZWxpbmUgd2lsbCBiZSByZWRyYXduLiBZb3UgY2FuIG9wdGlvbmFsbHkgZ2l2ZSBhXG4gICAqIGRhdGUgYXJvdW5kIHdoaWNoIHRvIHpvb20uXG4gICAqIEZvciBleGFtcGxlLCB0cnkgc2NhbGUgPSAwLjkgb3IgMS4xXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSAgICAgIFNjYWxpbmcgZmFjdG9yLiBWYWx1ZXMgYWJvdmUgMSB3aWxsIHpvb20gb3V0LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgYmVsb3cgMSB3aWxsIHpvb20gaW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY2VudGVyXSAgIFZhbHVlIHJlcHJlc2VudGluZyBhIGRhdGUgYXJvdW5kIHdoaWNoIHdpbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgem9vbWVkLlxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLnpvb20gPSBmdW5jdGlvbiAoc2NhbGUsIGNlbnRlciwgZGVsdGEpIHtcbiAgICAvLyBpZiBjZW50ZXJEYXRlIGlzIG5vdCBwcm92aWRlZCwgdGFrZSBpdCBoYWxmIGJldHdlZW4gc3RhcnQgRGF0ZSBhbmQgZW5kIERhdGVcbiAgICBpZiAoY2VudGVyID09IG51bGwpIHtcbiAgICAgIGNlbnRlciA9ICh0aGlzLnN0YXJ0ICsgdGhpcy5lbmQpIC8gMjtcbiAgICB9XG5cbiAgICB2YXIgaGlkZGVuRHVyYXRpb24gPSBEYXRlVXRpbC5nZXRIaWRkZW5EdXJhdGlvbkJldHdlZW4odGhpcy5ib2R5LmhpZGRlbkRhdGVzLCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgdmFyIGhpZGRlbkR1cmF0aW9uQmVmb3JlID0gRGF0ZVV0aWwuZ2V0SGlkZGVuRHVyYXRpb25CZWZvcmUodGhpcy5vcHRpb25zLm1vbWVudCwgdGhpcy5ib2R5LmhpZGRlbkRhdGVzLCB0aGlzLCBjZW50ZXIpO1xuICAgIHZhciBoaWRkZW5EdXJhdGlvbkFmdGVyID0gaGlkZGVuRHVyYXRpb24gLSBoaWRkZW5EdXJhdGlvbkJlZm9yZTtcblxuICAgIC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgYW5kIGVuZFxuICAgIHZhciBuZXdTdGFydCA9IGNlbnRlciAtIGhpZGRlbkR1cmF0aW9uQmVmb3JlICsgKHRoaXMuc3RhcnQgLSAoY2VudGVyIC0gaGlkZGVuRHVyYXRpb25CZWZvcmUpKSAqIHNjYWxlO1xuICAgIHZhciBuZXdFbmQgPSBjZW50ZXIgKyBoaWRkZW5EdXJhdGlvbkFmdGVyICsgKHRoaXMuZW5kIC0gKGNlbnRlciArIGhpZGRlbkR1cmF0aW9uQWZ0ZXIpKSAqIHNjYWxlO1xuXG4gICAgLy8gc25hcHBpbmcgdGltZXMgYXdheSBmcm9tIGhpZGRlbiB6b25lc1xuICAgIHRoaXMuc3RhcnRUb0Zyb250ID0gZGVsdGEgPiAwID8gZmFsc2UgOiB0cnVlOyAvLyB1c2VkIHRvIGRvIHRoZSByaWdodCBhdXRvY29ycmVjdGlvbiB3aXRoIHBlcmlvZGljIGhpZGRlbiB0aW1lc1xuICAgIHRoaXMuZW5kVG9Gcm9udCA9IC1kZWx0YSA+IDAgPyBmYWxzZSA6IHRydWU7IC8vIHVzZWQgdG8gZG8gdGhlIHJpZ2h0IGF1dG9jb3JyZWN0aW9uIHdpdGggcGVyaW9kaWMgaGlkZGVuIHRpbWVzXG4gICAgdmFyIHNhZmVTdGFydCA9IERhdGVVdGlsLnNuYXBBd2F5RnJvbUhpZGRlbih0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIG5ld1N0YXJ0LCBkZWx0YSwgdHJ1ZSk7XG4gICAgdmFyIHNhZmVFbmQgPSBEYXRlVXRpbC5zbmFwQXdheUZyb21IaWRkZW4odGhpcy5ib2R5LmhpZGRlbkRhdGVzLCBuZXdFbmQsIC1kZWx0YSwgdHJ1ZSk7XG4gICAgaWYgKHNhZmVTdGFydCAhPSBuZXdTdGFydCB8fCBzYWZlRW5kICE9IG5ld0VuZCkge1xuICAgICAgbmV3U3RhcnQgPSBzYWZlU3RhcnQ7XG4gICAgICBuZXdFbmQgPSBzYWZlRW5kO1xuICAgIH1cblxuICAgIHRoaXMuc2V0UmFuZ2UobmV3U3RhcnQsIG5ld0VuZCwgZmFsc2UsIHRydWUpO1xuXG4gICAgdGhpcy5zdGFydFRvRnJvbnQgPSBmYWxzZTsgLy8gcmV2ZXJ0IHRvIGRlZmF1bHRcbiAgICB0aGlzLmVuZFRvRnJvbnQgPSB0cnVlOyAvLyByZXZlcnQgdG8gZGVmYXVsdFxuICB9O1xuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSByYW5nZSB3aXRoIGEgZ2l2ZW4gZGVsdGEgdG8gdGhlIGxlZnQgb3IgcmlnaHQuIFN0YXJ0IGFuZCBlbmRcbiAgICogdmFsdWUgd2lsbCBiZSBhZGp1c3RlZC4gRm9yIGV4YW1wbGUsIHRyeSBkZWx0YSA9IDAuMSBvciAtMC4xXG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgZGVsdGEgICAgIE1vdmluZyBhbW91bnQuIFBvc2l0aXZlIHZhbHVlIHdpbGwgbW92ZSByaWdodCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVnYXRpdmUgdmFsdWUgd2lsbCBtb3ZlIGxlZnRcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgLy8gem9vbSBzdGFydCBEYXRlIGFuZCBlbmQgRGF0ZSByZWxhdGl2ZSB0byB0aGUgY2VudGVyRGF0ZVxuICAgIHZhciBkaWZmID0gdGhpcy5lbmQgLSB0aGlzLnN0YXJ0O1xuXG4gICAgLy8gYXBwbHkgbmV3IHZhbHVlc1xuICAgIHZhciBuZXdTdGFydCA9IHRoaXMuc3RhcnQgKyBkaWZmICogZGVsdGE7XG4gICAgdmFyIG5ld0VuZCA9IHRoaXMuZW5kICsgZGlmZiAqIGRlbHRhO1xuXG4gICAgLy8gVE9ETzogcmVja29uIHdpdGggbWluIGFuZCBtYXggcmFuZ2VcblxuICAgIHRoaXMuc3RhcnQgPSBuZXdTdGFydDtcbiAgICB0aGlzLmVuZCA9IG5ld0VuZDtcbiAgfTtcblxuICAvKipcbiAgICogTW92ZSB0aGUgcmFuZ2UgdG8gYSBuZXcgY2VudGVyIHBvaW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtb3ZlVG8gICAgICBOZXcgY2VudGVyIHBvaW50IG9mIHRoZSByYW5nZVxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uIChtb3ZlVG8pIHtcbiAgICB2YXIgY2VudGVyID0gKHRoaXMuc3RhcnQgKyB0aGlzLmVuZCkgLyAyO1xuXG4gICAgdmFyIGRpZmYgPSBjZW50ZXIgLSBtb3ZlVG87XG5cbiAgICAvLyBjYWxjdWxhdGUgbmV3IHN0YXJ0IGFuZCBlbmRcbiAgICB2YXIgbmV3U3RhcnQgPSB0aGlzLnN0YXJ0IC0gZGlmZjtcbiAgICB2YXIgbmV3RW5kID0gdGhpcy5lbmQgLSBkaWZmO1xuXG4gICAgdGhpcy5zZXRSYW5nZShuZXdTdGFydCwgbmV3RW5kKTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFJhbmdlO1xuXG4vKioqLyB9LFxuLyogMzMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgLyoqXG4gICAqIFByb3RvdHlwZSBmb3IgdmlzdWFsIGNvbXBvbmVudHNcbiAgICogQHBhcmFtIHt7ZG9tOiBPYmplY3QsIGRvbVByb3BzOiBPYmplY3QsIGVtaXR0ZXI6IEVtaXR0ZXIsIHJhbmdlOiBSYW5nZX19IFtib2R5XVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqL1xuICBmdW5jdGlvbiBDb21wb25lbnQoYm9keSwgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG51bGw7XG4gICAgdGhpcy5wcm9wcyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IG9wdGlvbnMgZm9yIHRoZSBjb21wb25lbnQuIFRoZSBuZXcgb3B0aW9ucyB3aWxsIGJlIG1lcmdlZCBpbnRvIHRoZVxuICAgKiBjdXJyZW50IG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBDb21wb25lbnQucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVwYWludCB0aGUgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY29tcG9uZW50IGlzIHJlc2l6ZWRcbiAgICovXG4gIENvbXBvbmVudC5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgY29tcG9uZW50XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBjb21wb25lbnQuIENsZWFudXAgRE9NIGFuZCBldmVudCBsaXN0ZW5lcnNcbiAgICovXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYnkgdGhlIGNvbXBvbmVudFxuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyByZXNpemVkIHNpbmNlIHRoZSBsYXN0IHRpbWUgX2lzUmVzaXplZCgpIHdhc1xuICAgKiBjYWxsZWQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY29tcG9uZW50IGlzIHJlc2l6ZWRcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5faXNSZXNpemVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXNpemVkID0gdGhpcy5wcm9wcy5fcHJldmlvdXNXaWR0aCAhPT0gdGhpcy5wcm9wcy53aWR0aCB8fCB0aGlzLnByb3BzLl9wcmV2aW91c0hlaWdodCAhPT0gdGhpcy5wcm9wcy5oZWlnaHQ7XG5cbiAgICB0aGlzLnByb3BzLl9wcmV2aW91c1dpZHRoID0gdGhpcy5wcm9wcy53aWR0aDtcbiAgICB0aGlzLnByb3BzLl9wcmV2aW91c0hlaWdodCA9IHRoaXMucHJvcHMuaGVpZ2h0O1xuXG4gICAgcmV0dXJuIHJlc2l6ZWQ7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQ7XG5cbi8qKiovIH0sXG4vKiAzNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLyoqXG4gICAqIHVzZWQgaW4gQ29yZSB0byBjb252ZXJ0IHRoZSBvcHRpb25zIGludG8gYSB2b2xhdGlsZSB2YXJpYWJsZVxuICAgKiBcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbW9tZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7QXJyYXkgfCBPYmplY3R9IGhpZGRlbkRhdGVzXG4gICAqL1xuICBleHBvcnRzLmNvbnZlcnRIaWRkZW5PcHRpb25zID0gZnVuY3Rpb24gKG1vbWVudCwgYm9keSwgaGlkZGVuRGF0ZXMpIHtcbiAgICBpZiAoaGlkZGVuRGF0ZXMgJiYgIUFycmF5LmlzQXJyYXkoaGlkZGVuRGF0ZXMpKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5jb252ZXJ0SGlkZGVuT3B0aW9ucyhtb21lbnQsIGJvZHksIFtoaWRkZW5EYXRlc10pO1xuICAgIH1cblxuICAgIGJvZHkuaGlkZGVuRGF0ZXMgPSBbXTtcbiAgICBpZiAoaGlkZGVuRGF0ZXMpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGhpZGRlbkRhdGVzKSA9PSB0cnVlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoaGlkZGVuRGF0ZXNbaV0ucmVwZWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBkYXRlSXRlbSA9IHt9O1xuICAgICAgICAgICAgZGF0ZUl0ZW0uc3RhcnQgPSBtb21lbnQoaGlkZGVuRGF0ZXNbaV0uc3RhcnQpLnRvRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIGRhdGVJdGVtLmVuZCA9IG1vbWVudChoaWRkZW5EYXRlc1tpXS5lbmQpLnRvRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIGJvZHkuaGlkZGVuRGF0ZXMucHVzaChkYXRlSXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJvZHkuaGlkZGVuRGF0ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBhLnN0YXJ0IC0gYi5zdGFydDtcbiAgICAgICAgfSk7IC8vIHNvcnQgYnkgc3RhcnQgdGltZVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogY3JlYXRlIG5ldyBlbnRyZWVzIGZvciB0aGUgcmVwZWF0aW5nIGhpZGRlbiBkYXRlc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtb21lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtBcnJheSB8IE9iamVjdH0gaGlkZGVuRGF0ZXNcbiAgICovXG4gIGV4cG9ydHMudXBkYXRlSGlkZGVuRGF0ZXMgPSBmdW5jdGlvbiAobW9tZW50LCBib2R5LCBoaWRkZW5EYXRlcykge1xuICAgIGlmIChoaWRkZW5EYXRlcyAmJiAhQXJyYXkuaXNBcnJheShoaWRkZW5EYXRlcykpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLnVwZGF0ZUhpZGRlbkRhdGVzKG1vbWVudCwgYm9keSwgW2hpZGRlbkRhdGVzXSk7XG4gICAgfVxuXG4gICAgaWYgKGhpZGRlbkRhdGVzICYmIGJvZHkuZG9tUHJvcHMuY2VudGVyQ29udGFpbmVyLndpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGV4cG9ydHMuY29udmVydEhpZGRlbk9wdGlvbnMobW9tZW50LCBib2R5LCBoaWRkZW5EYXRlcyk7XG5cbiAgICAgIHZhciBzdGFydCA9IG1vbWVudChib2R5LnJhbmdlLnN0YXJ0KTtcbiAgICAgIHZhciBlbmQgPSBtb21lbnQoYm9keS5yYW5nZS5lbmQpO1xuXG4gICAgICB2YXIgdG90YWxSYW5nZSA9IGJvZHkucmFuZ2UuZW5kIC0gYm9keS5yYW5nZS5zdGFydDtcbiAgICAgIHZhciBwaXhlbFRpbWUgPSB0b3RhbFJhbmdlIC8gYm9keS5kb21Qcm9wcy5jZW50ZXJDb250YWluZXIud2lkdGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGhpZGRlbkRhdGVzW2ldLnJlcGVhdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0RGF0ZSA9IG1vbWVudChoaWRkZW5EYXRlc1tpXS5zdGFydCk7XG4gICAgICAgICAgdmFyIGVuZERhdGUgPSBtb21lbnQoaGlkZGVuRGF0ZXNbaV0uZW5kKTtcblxuICAgICAgICAgIGlmIChzdGFydERhdGUuX2QgPT0gXCJJbnZhbGlkIERhdGVcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3VwcGxpZWQgc3RhcnQgZGF0ZSBpcyBub3QgdmFsaWQ6IFwiICsgaGlkZGVuRGF0ZXNbaV0uc3RhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZW5kRGF0ZS5fZCA9PSBcIkludmFsaWQgRGF0ZVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdXBwbGllZCBlbmQgZGF0ZSBpcyBub3QgdmFsaWQ6IFwiICsgaGlkZGVuRGF0ZXNbaV0uZW5kKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZHVyYXRpb24gPSBlbmREYXRlIC0gc3RhcnREYXRlO1xuICAgICAgICAgIGlmIChkdXJhdGlvbiA+PSA0ICogcGl4ZWxUaW1lKSB7XG5cbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgdmFyIHJ1blVudGlsID0gZW5kLmNsb25lKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGhpZGRlbkRhdGVzW2ldLnJlcGVhdCkge1xuICAgICAgICAgICAgICBjYXNlIFwiZGFpbHlcIjpcbiAgICAgICAgICAgICAgICAvLyBjYXNlIG9mIHRpbWVcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnREYXRlLmRheSgpICE9IGVuZERhdGUuZGF5KCkpIHtcbiAgICAgICAgICAgICAgICAgIG9mZnNldCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5kYXlPZlllYXIoc3RhcnQuZGF5T2ZZZWFyKCkpO1xuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS55ZWFyKHN0YXJ0LnllYXIoKSk7XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLnN1YnRyYWN0KDcsICdkYXlzJyk7XG5cbiAgICAgICAgICAgICAgICBlbmREYXRlLmRheU9mWWVhcihzdGFydC5kYXlPZlllYXIoKSk7XG4gICAgICAgICAgICAgICAgZW5kRGF0ZS55ZWFyKHN0YXJ0LnllYXIoKSk7XG4gICAgICAgICAgICAgICAgZW5kRGF0ZS5zdWJ0cmFjdCg3IC0gb2Zmc2V0LCAnZGF5cycpO1xuXG4gICAgICAgICAgICAgICAgcnVuVW50aWwuYWRkKDEsICd3ZWVrcycpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwid2Vla2x5XCI6XG4gICAgICAgICAgICAgICAgdmFyIGRheU9mZnNldCA9IGVuZERhdGUuZGlmZihzdGFydERhdGUsICdkYXlzJyk7XG4gICAgICAgICAgICAgICAgdmFyIGRheSA9IHN0YXJ0RGF0ZS5kYXkoKTtcblxuICAgICAgICAgICAgICAgIC8vIHNldCB0aGUgc3RhcnQgZGF0ZSB0byB0aGUgcmFuZ2Uuc3RhcnRcbiAgICAgICAgICAgICAgICBzdGFydERhdGUuZGF0ZShzdGFydC5kYXRlKCkpO1xuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5tb250aChzdGFydC5tb250aCgpKTtcbiAgICAgICAgICAgICAgICBzdGFydERhdGUueWVhcihzdGFydC55ZWFyKCkpO1xuICAgICAgICAgICAgICAgIGVuZERhdGUgPSBzdGFydERhdGUuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIC8vIGZvcmNlXG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLmRheShkYXkpO1xuICAgICAgICAgICAgICAgIGVuZERhdGUuZGF5KGRheSk7XG4gICAgICAgICAgICAgICAgZW5kRGF0ZS5hZGQoZGF5T2Zmc2V0LCAnZGF5cycpO1xuXG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLnN1YnRyYWN0KDEsICd3ZWVrcycpO1xuICAgICAgICAgICAgICAgIGVuZERhdGUuc3VidHJhY3QoMSwgJ3dlZWtzJyk7XG5cbiAgICAgICAgICAgICAgICBydW5VbnRpbC5hZGQoMSwgJ3dlZWtzJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJtb250aGx5XCI6XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0RGF0ZS5tb250aCgpICE9IGVuZERhdGUubW9udGgoKSkge1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLm1vbnRoKHN0YXJ0Lm1vbnRoKCkpO1xuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS55ZWFyKHN0YXJ0LnllYXIoKSk7XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLnN1YnRyYWN0KDEsICdtb250aHMnKTtcblxuICAgICAgICAgICAgICAgIGVuZERhdGUubW9udGgoc3RhcnQubW9udGgoKSk7XG4gICAgICAgICAgICAgICAgZW5kRGF0ZS55ZWFyKHN0YXJ0LnllYXIoKSk7XG4gICAgICAgICAgICAgICAgZW5kRGF0ZS5zdWJ0cmFjdCgxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAgICAgZW5kRGF0ZS5hZGQob2Zmc2V0LCAnbW9udGhzJyk7XG5cbiAgICAgICAgICAgICAgICBydW5VbnRpbC5hZGQoMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwieWVhcmx5XCI6XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0RGF0ZS55ZWFyKCkgIT0gZW5kRGF0ZS55ZWFyKCkpIHtcbiAgICAgICAgICAgICAgICAgIG9mZnNldCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS55ZWFyKHN0YXJ0LnllYXIoKSk7XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLnN1YnRyYWN0KDEsICd5ZWFycycpO1xuICAgICAgICAgICAgICAgIGVuZERhdGUueWVhcihzdGFydC55ZWFyKCkpO1xuICAgICAgICAgICAgICAgIGVuZERhdGUuc3VidHJhY3QoMSwgJ3llYXJzJyk7XG4gICAgICAgICAgICAgICAgZW5kRGF0ZS5hZGQob2Zmc2V0LCAneWVhcnMnKTtcblxuICAgICAgICAgICAgICAgIHJ1blVudGlsLmFkZCgxLCAneWVhcnMnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIldyb25nIHJlcGVhdCBmb3JtYXQsIGFsbG93ZWQgYXJlOiBkYWlseSwgd2Vla2x5LCBtb250aGx5LCB5ZWFybHkuIEdpdmVuOlwiLCBoaWRkZW5EYXRlc1tpXS5yZXBlYXQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChzdGFydERhdGUgPCBydW5VbnRpbCkge1xuICAgICAgICAgICAgICBib2R5LmhpZGRlbkRhdGVzLnB1c2goeyBzdGFydDogc3RhcnREYXRlLnZhbHVlT2YoKSwgZW5kOiBlbmREYXRlLnZhbHVlT2YoKSB9KTtcbiAgICAgICAgICAgICAgc3dpdGNoIChoaWRkZW5EYXRlc1tpXS5yZXBlYXQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGFpbHlcIjpcbiAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5hZGQoMSwgJ2RheXMnKTtcbiAgICAgICAgICAgICAgICAgIGVuZERhdGUuYWRkKDEsICdkYXlzJyk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwid2Vla2x5XCI6XG4gICAgICAgICAgICAgICAgICBzdGFydERhdGUuYWRkKDEsICd3ZWVrcycpO1xuICAgICAgICAgICAgICAgICAgZW5kRGF0ZS5hZGQoMSwgJ3dlZWtzJyk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibW9udGhseVwiOlxuICAgICAgICAgICAgICAgICAgc3RhcnREYXRlLmFkZCgxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAgICAgICBlbmREYXRlLmFkZCgxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwieWVhcmx5XCI6XG4gICAgICAgICAgICAgICAgICBzdGFydERhdGUuYWRkKDEsICd5Jyk7XG4gICAgICAgICAgICAgICAgICBlbmREYXRlLmFkZCgxLCAneScpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV3JvbmcgcmVwZWF0IGZvcm1hdCwgYWxsb3dlZCBhcmU6IGRhaWx5LCB3ZWVrbHksIG1vbnRobHksIHllYXJseS4gR2l2ZW46XCIsIGhpZGRlbkRhdGVzW2ldLnJlcGVhdCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvZHkuaGlkZGVuRGF0ZXMucHVzaCh7IHN0YXJ0OiBzdGFydERhdGUudmFsdWVPZigpLCBlbmQ6IGVuZERhdGUudmFsdWVPZigpIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gcmVtb3ZlIGR1cGxpY2F0ZXMsIG1lcmdlIHdoZXJlIHBvc3NpYmxlXG4gICAgICBleHBvcnRzLnJlbW92ZUR1cGxpY2F0ZXMoYm9keSk7XG4gICAgICAvLyBlbnN1cmUgdGhlIG5ldyBwb3NpdGlvbnMgYXJlIG5vdCBvbiBoaWRkZW4gZGF0ZXNcbiAgICAgIHZhciBzdGFydEhpZGRlbiA9IGV4cG9ydHMuaXNIaWRkZW4oYm9keS5yYW5nZS5zdGFydCwgYm9keS5oaWRkZW5EYXRlcyk7XG4gICAgICB2YXIgZW5kSGlkZGVuID0gZXhwb3J0cy5pc0hpZGRlbihib2R5LnJhbmdlLmVuZCwgYm9keS5oaWRkZW5EYXRlcyk7XG4gICAgICB2YXIgcmFuZ2VTdGFydCA9IGJvZHkucmFuZ2Uuc3RhcnQ7XG4gICAgICB2YXIgcmFuZ2VFbmQgPSBib2R5LnJhbmdlLmVuZDtcbiAgICAgIGlmIChzdGFydEhpZGRlbi5oaWRkZW4gPT0gdHJ1ZSkge1xuICAgICAgICByYW5nZVN0YXJ0ID0gYm9keS5yYW5nZS5zdGFydFRvRnJvbnQgPT0gdHJ1ZSA/IHN0YXJ0SGlkZGVuLnN0YXJ0RGF0ZSAtIDEgOiBzdGFydEhpZGRlbi5lbmREYXRlICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmRIaWRkZW4uaGlkZGVuID09IHRydWUpIHtcbiAgICAgICAgcmFuZ2VFbmQgPSBib2R5LnJhbmdlLmVuZFRvRnJvbnQgPT0gdHJ1ZSA/IGVuZEhpZGRlbi5zdGFydERhdGUgLSAxIDogZW5kSGlkZGVuLmVuZERhdGUgKyAxO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0SGlkZGVuLmhpZGRlbiA9PSB0cnVlIHx8IGVuZEhpZGRlbi5oaWRkZW4gPT0gdHJ1ZSkge1xuICAgICAgICBib2R5LnJhbmdlLl9hcHBseVJhbmdlKHJhbmdlU3RhcnQsIHJhbmdlRW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIHJlbW92ZSBkdXBsaWNhdGVzIGZyb20gdGhlIGhpZGRlbiBkYXRlcyBsaXN0LiBEdXBsaWNhdGVzIGFyZSBldmlsLiBUaGV5IG1lc3MgZXZlcnl0aGluZyB1cC5cbiAgICogU2NhbGVzIHdpdGggTl4yXG4gICAqIEBwYXJhbSBib2R5XG4gICAqL1xuICBleHBvcnRzLnJlbW92ZUR1cGxpY2F0ZXMgPSBmdW5jdGlvbiAoYm9keSkge1xuICAgIHZhciBoaWRkZW5EYXRlcyA9IGJvZHkuaGlkZGVuRGF0ZXM7XG4gICAgdmFyIHNhZmVEYXRlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaGlkZGVuRGF0ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKGkgIT0gaiAmJiBoaWRkZW5EYXRlc1tqXS5yZW1vdmUgIT0gdHJ1ZSAmJiBoaWRkZW5EYXRlc1tpXS5yZW1vdmUgIT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIGogaW5zaWRlIGlcbiAgICAgICAgICBpZiAoaGlkZGVuRGF0ZXNbal0uc3RhcnQgPj0gaGlkZGVuRGF0ZXNbaV0uc3RhcnQgJiYgaGlkZGVuRGF0ZXNbal0uZW5kIDw9IGhpZGRlbkRhdGVzW2ldLmVuZCkge1xuICAgICAgICAgICAgaGlkZGVuRGF0ZXNbal0ucmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaiBzdGFydCBpbnNpZGUgaVxuICAgICAgICAgIGVsc2UgaWYgKGhpZGRlbkRhdGVzW2pdLnN0YXJ0ID49IGhpZGRlbkRhdGVzW2ldLnN0YXJ0ICYmIGhpZGRlbkRhdGVzW2pdLnN0YXJ0IDw9IGhpZGRlbkRhdGVzW2ldLmVuZCkge1xuICAgICAgICAgICAgICBoaWRkZW5EYXRlc1tpXS5lbmQgPSBoaWRkZW5EYXRlc1tqXS5lbmQ7XG4gICAgICAgICAgICAgIGhpZGRlbkRhdGVzW2pdLnJlbW92ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBqIGVuZCBpbnNpZGUgaVxuICAgICAgICAgICAgZWxzZSBpZiAoaGlkZGVuRGF0ZXNbal0uZW5kID49IGhpZGRlbkRhdGVzW2ldLnN0YXJ0ICYmIGhpZGRlbkRhdGVzW2pdLmVuZCA8PSBoaWRkZW5EYXRlc1tpXS5lbmQpIHtcbiAgICAgICAgICAgICAgICBoaWRkZW5EYXRlc1tpXS5zdGFydCA9IGhpZGRlbkRhdGVzW2pdLnN0YXJ0O1xuICAgICAgICAgICAgICAgIGhpZGRlbkRhdGVzW2pdLnJlbW92ZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChoaWRkZW5EYXRlc1tpXS5yZW1vdmUgIT09IHRydWUpIHtcbiAgICAgICAgc2FmZURhdGVzLnB1c2goaGlkZGVuRGF0ZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJvZHkuaGlkZGVuRGF0ZXMgPSBzYWZlRGF0ZXM7XG4gICAgYm9keS5oaWRkZW5EYXRlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5zdGFydCAtIGIuc3RhcnQ7XG4gICAgfSk7IC8vIHNvcnQgYnkgc3RhcnQgdGltZVxuICB9O1xuXG4gIGV4cG9ydHMucHJpbnREYXRlcyA9IGZ1bmN0aW9uIChkYXRlcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnNvbGUubG9nKGksIG5ldyBEYXRlKGRhdGVzW2ldLnN0YXJ0KSwgbmV3IERhdGUoZGF0ZXNbaV0uZW5kKSwgZGF0ZXNbaV0uc3RhcnQsIGRhdGVzW2ldLmVuZCwgZGF0ZXNbaV0ucmVtb3ZlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVzZWQgaW4gVGltZVN0ZXAgdG8gYXZvaWQgdGhlIGhpZGRlbiB0aW1lcy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbW9tZW50XG4gICAqIEBwYXJhbSB7VGltZVN0ZXB9IHRpbWVTdGVwXG4gICAqIEBwYXJhbSBwcmV2aW91c1RpbWVcbiAgICovXG4gIGV4cG9ydHMuc3RlcE92ZXJIaWRkZW5EYXRlcyA9IGZ1bmN0aW9uIChtb21lbnQsIHRpbWVTdGVwLCBwcmV2aW91c1RpbWUpIHtcbiAgICB2YXIgc3RlcEluSGlkZGVuID0gZmFsc2U7XG4gICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHRpbWVTdGVwLmN1cnJlbnQudmFsdWVPZigpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZVN0ZXAuaGlkZGVuRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdGFydERhdGUgPSB0aW1lU3RlcC5oaWRkZW5EYXRlc1tpXS5zdGFydDtcbiAgICAgIHZhciBlbmREYXRlID0gdGltZVN0ZXAuaGlkZGVuRGF0ZXNbaV0uZW5kO1xuICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA+PSBzdGFydERhdGUgJiYgY3VycmVudFZhbHVlIDwgZW5kRGF0ZSkge1xuICAgICAgICBzdGVwSW5IaWRkZW4gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RlcEluSGlkZGVuID09IHRydWUgJiYgY3VycmVudFZhbHVlIDwgdGltZVN0ZXAuX2VuZC52YWx1ZU9mKCkgJiYgY3VycmVudFZhbHVlICE9IHByZXZpb3VzVGltZSkge1xuICAgICAgdmFyIHByZXZWYWx1ZSA9IG1vbWVudChwcmV2aW91c1RpbWUpO1xuICAgICAgdmFyIG5ld1ZhbHVlID0gbW9tZW50KGVuZERhdGUpO1xuICAgICAgLy9jaGVjayBpZiB0aGUgbmV4dCBzdGVwIHNob3VsZCBiZSBtYWpvclxuICAgICAgaWYgKHByZXZWYWx1ZS55ZWFyKCkgIT0gbmV3VmFsdWUueWVhcigpKSB7XG4gICAgICAgIHRpbWVTdGVwLnN3aXRjaGVkWWVhciA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHByZXZWYWx1ZS5tb250aCgpICE9IG5ld1ZhbHVlLm1vbnRoKCkpIHtcbiAgICAgICAgdGltZVN0ZXAuc3dpdGNoZWRNb250aCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHByZXZWYWx1ZS5kYXlPZlllYXIoKSAhPSBuZXdWYWx1ZS5kYXlPZlllYXIoKSkge1xuICAgICAgICB0aW1lU3RlcC5zd2l0Y2hlZERheSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRpbWVTdGVwLmN1cnJlbnQgPSBuZXdWYWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgLy8vKipcbiAgLy8gKiBVc2VkIGluIFRpbWVTdGVwIHRvIGF2b2lkIHRoZSBoaWRkZW4gdGltZXMuXG4gIC8vICogQHBhcmFtIHRpbWVTdGVwXG4gIC8vICogQHBhcmFtIHByZXZpb3VzVGltZVxuICAvLyAqL1xuICAvL2V4cG9ydHMuY2hlY2tGaXJzdFN0ZXAgPSBmdW5jdGlvbih0aW1lU3RlcCkge1xuICAvLyAgdmFyIHN0ZXBJbkhpZGRlbiA9IGZhbHNlO1xuICAvLyAgdmFyIGN1cnJlbnRWYWx1ZSA9IHRpbWVTdGVwLmN1cnJlbnQudmFsdWVPZigpO1xuICAvLyAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lU3RlcC5oaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAvLyAgICB2YXIgc3RhcnREYXRlID0gdGltZVN0ZXAuaGlkZGVuRGF0ZXNbaV0uc3RhcnQ7XG4gIC8vICAgIHZhciBlbmREYXRlID0gdGltZVN0ZXAuaGlkZGVuRGF0ZXNbaV0uZW5kO1xuICAvLyAgICBpZiAoY3VycmVudFZhbHVlID49IHN0YXJ0RGF0ZSAmJiBjdXJyZW50VmFsdWUgPCBlbmREYXRlKSB7XG4gIC8vICAgICAgc3RlcEluSGlkZGVuID0gdHJ1ZTtcbiAgLy8gICAgICBicmVhaztcbiAgLy8gICAgfVxuICAvLyAgfVxuICAvL1xuICAvLyAgaWYgKHN0ZXBJbkhpZGRlbiA9PSB0cnVlICYmIGN1cnJlbnRWYWx1ZSA8PSB0aW1lU3RlcC5fZW5kLnZhbHVlT2YoKSkge1xuICAvLyAgICB2YXIgbmV3VmFsdWUgPSBtb21lbnQoZW5kRGF0ZSk7XG4gIC8vICAgIHRpbWVTdGVwLmN1cnJlbnQgPSBuZXdWYWx1ZS50b0RhdGUoKTtcbiAgLy8gIH1cbiAgLy99O1xuXG4gIC8qKlxuICAgKiByZXBsYWNlcyB0aGUgQ29yZSB0b1NjcmVlbiBtZXRob2RzXG4gICAqIEBwYXJhbSBDb3JlXG4gICAqIEBwYXJhbSB0aW1lXG4gICAqIEBwYXJhbSB3aWR0aFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZXhwb3J0cy50b1NjcmVlbiA9IGZ1bmN0aW9uIChDb3JlLCB0aW1lLCB3aWR0aCkge1xuICAgIGlmIChDb3JlLmJvZHkuaGlkZGVuRGF0ZXMubGVuZ3RoID09IDApIHtcbiAgICAgIHZhciBjb252ZXJzaW9uID0gQ29yZS5yYW5nZS5jb252ZXJzaW9uKHdpZHRoKTtcbiAgICAgIHJldHVybiAodGltZS52YWx1ZU9mKCkgLSBjb252ZXJzaW9uLm9mZnNldCkgKiBjb252ZXJzaW9uLnNjYWxlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaGlkZGVuID0gZXhwb3J0cy5pc0hpZGRlbih0aW1lLCBDb3JlLmJvZHkuaGlkZGVuRGF0ZXMpO1xuICAgICAgaWYgKGhpZGRlbi5oaWRkZW4gPT0gdHJ1ZSkge1xuICAgICAgICB0aW1lID0gaGlkZGVuLnN0YXJ0RGF0ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGR1cmF0aW9uID0gZXhwb3J0cy5nZXRIaWRkZW5EdXJhdGlvbkJldHdlZW4oQ29yZS5ib2R5LmhpZGRlbkRhdGVzLCBDb3JlLnJhbmdlLnN0YXJ0LCBDb3JlLnJhbmdlLmVuZCk7XG4gICAgICBpZiAodGltZSA8IENvcmUucmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgdmFyIGNvbnZlcnNpb24gPSBDb3JlLnJhbmdlLmNvbnZlcnNpb24od2lkdGgsIGR1cmF0aW9uKTtcbiAgICAgICAgdmFyIGhpZGRlbkJlZm9yZVN0YXJ0ID0gZXhwb3J0cy5nZXRIaWRkZW5EdXJhdGlvbkJlZm9yZVN0YXJ0KENvcmUuYm9keS5oaWRkZW5EYXRlcywgdGltZSwgY29udmVyc2lvbi5vZmZzZXQpO1xuICAgICAgICB0aW1lID0gQ29yZS5vcHRpb25zLm1vbWVudCh0aW1lKS50b0RhdGUoKS52YWx1ZU9mKCk7XG4gICAgICAgIHRpbWUgPSB0aW1lICsgaGlkZGVuQmVmb3JlU3RhcnQ7XG4gICAgICAgIHJldHVybiAtKGNvbnZlcnNpb24ub2Zmc2V0IC0gdGltZS52YWx1ZU9mKCkpICogY29udmVyc2lvbi5zY2FsZTtcbiAgICAgIH0gZWxzZSBpZiAodGltZSA+IENvcmUucmFuZ2UuZW5kKSB7XG4gICAgICAgIHZhciByYW5nZUFmdGVyRW5kID0geyBzdGFydDogQ29yZS5yYW5nZS5zdGFydCwgZW5kOiB0aW1lIH07XG4gICAgICAgIHRpbWUgPSBleHBvcnRzLmNvcnJlY3RUaW1lRm9ySGlkZGVuKENvcmUub3B0aW9ucy5tb21lbnQsIENvcmUuYm9keS5oaWRkZW5EYXRlcywgcmFuZ2VBZnRlckVuZCwgdGltZSk7XG4gICAgICAgIHZhciBjb252ZXJzaW9uID0gQ29yZS5yYW5nZS5jb252ZXJzaW9uKHdpZHRoLCBkdXJhdGlvbik7XG4gICAgICAgIHJldHVybiAodGltZS52YWx1ZU9mKCkgLSBjb252ZXJzaW9uLm9mZnNldCkgKiBjb252ZXJzaW9uLnNjYWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZSA9IGV4cG9ydHMuY29ycmVjdFRpbWVGb3JIaWRkZW4oQ29yZS5vcHRpb25zLm1vbWVudCwgQ29yZS5ib2R5LmhpZGRlbkRhdGVzLCBDb3JlLnJhbmdlLCB0aW1lKTtcbiAgICAgICAgdmFyIGNvbnZlcnNpb24gPSBDb3JlLnJhbmdlLmNvbnZlcnNpb24od2lkdGgsIGR1cmF0aW9uKTtcbiAgICAgICAgcmV0dXJuICh0aW1lLnZhbHVlT2YoKSAtIGNvbnZlcnNpb24ub2Zmc2V0KSAqIGNvbnZlcnNpb24uc2NhbGU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgY29yZSB0b1RpbWUgbWV0aG9kc1xuICAgKiBAcGFyYW0gYm9keVxuICAgKiBAcGFyYW0gcmFuZ2VcbiAgICogQHBhcmFtIHhcbiAgICogQHBhcmFtIHdpZHRoXG4gICAqIEByZXR1cm5zIHtEYXRlfVxuICAgKi9cbiAgZXhwb3J0cy50b1RpbWUgPSBmdW5jdGlvbiAoQ29yZSwgeCwgd2lkdGgpIHtcbiAgICBpZiAoQ29yZS5ib2R5LmhpZGRlbkRhdGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICB2YXIgY29udmVyc2lvbiA9IENvcmUucmFuZ2UuY29udmVyc2lvbih3aWR0aCk7XG4gICAgICByZXR1cm4gbmV3IERhdGUoeCAvIGNvbnZlcnNpb24uc2NhbGUgKyBjb252ZXJzaW9uLm9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBoaWRkZW5EdXJhdGlvbiA9IGV4cG9ydHMuZ2V0SGlkZGVuRHVyYXRpb25CZXR3ZWVuKENvcmUuYm9keS5oaWRkZW5EYXRlcywgQ29yZS5yYW5nZS5zdGFydCwgQ29yZS5yYW5nZS5lbmQpO1xuICAgICAgdmFyIHRvdGFsRHVyYXRpb24gPSBDb3JlLnJhbmdlLmVuZCAtIENvcmUucmFuZ2Uuc3RhcnQgLSBoaWRkZW5EdXJhdGlvbjtcbiAgICAgIHZhciBwYXJ0aWFsRHVyYXRpb24gPSB0b3RhbER1cmF0aW9uICogeCAvIHdpZHRoO1xuICAgICAgdmFyIGFjY3VtdWxhdGVkSGlkZGVuRHVyYXRpb24gPSBleHBvcnRzLmdldEFjY3VtdWxhdGVkSGlkZGVuRHVyYXRpb24oQ29yZS5ib2R5LmhpZGRlbkRhdGVzLCBDb3JlLnJhbmdlLCBwYXJ0aWFsRHVyYXRpb24pO1xuXG4gICAgICB2YXIgbmV3VGltZSA9IG5ldyBEYXRlKGFjY3VtdWxhdGVkSGlkZGVuRHVyYXRpb24gKyBwYXJ0aWFsRHVyYXRpb24gKyBDb3JlLnJhbmdlLnN0YXJ0KTtcbiAgICAgIHJldHVybiBuZXdUaW1lO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3VwcG9ydCBmdW5jdGlvblxuICAgKlxuICAgKiBAcGFyYW0gaGlkZGVuRGF0ZXNcbiAgICogQHBhcmFtIHJhbmdlXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBleHBvcnRzLmdldEhpZGRlbkR1cmF0aW9uQmV0d2VlbiA9IGZ1bmN0aW9uIChoaWRkZW5EYXRlcywgc3RhcnQsIGVuZCkge1xuICAgIHZhciBkdXJhdGlvbiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHN0YXJ0RGF0ZSA9IGhpZGRlbkRhdGVzW2ldLnN0YXJ0O1xuICAgICAgdmFyIGVuZERhdGUgPSBoaWRkZW5EYXRlc1tpXS5lbmQ7XG4gICAgICAvLyBpZiB0aW1lIGFmdGVyIHRoZSBjdXRvdXQsIGFuZCB0aGVcbiAgICAgIGlmIChzdGFydERhdGUgPj0gc3RhcnQgJiYgZW5kRGF0ZSA8IGVuZCkge1xuICAgICAgICBkdXJhdGlvbiArPSBlbmREYXRlIC0gc3RhcnREYXRlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZHVyYXRpb247XG4gIH07XG5cbiAgLyoqXG4gICAgICogU3VwcG9ydCBmdW5jdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIGhpZGRlbkRhdGVzXG4gICAgICogQHBhcmFtIHN0YXJ0XG4gICAgICogQHBhcmFtIGVuZFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gIGV4cG9ydHMuZ2V0SGlkZGVuRHVyYXRpb25CZWZvcmVTdGFydCA9IGZ1bmN0aW9uIChoaWRkZW5EYXRlcywgc3RhcnQsIGVuZCkge1xuICAgIHZhciBkdXJhdGlvbiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHN0YXJ0RGF0ZSA9IGhpZGRlbkRhdGVzW2ldLnN0YXJ0O1xuICAgICAgdmFyIGVuZERhdGUgPSBoaWRkZW5EYXRlc1tpXS5lbmQ7XG5cbiAgICAgIGlmIChzdGFydERhdGUgPj0gc3RhcnQgJiYgZW5kRGF0ZSA8PSBlbmQpIHtcbiAgICAgICAgZHVyYXRpb24gKz0gZW5kRGF0ZSAtIHN0YXJ0RGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGR1cmF0aW9uO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdXBwb3J0IGZ1bmN0aW9uXG4gICAqIEBwYXJhbSBtb21lbnRcbiAgICogQHBhcmFtIGhpZGRlbkRhdGVzXG4gICAqIEBwYXJhbSByYW5nZVxuICAgKiBAcGFyYW0gdGltZVxuICAgKiBAcmV0dXJucyB7e2R1cmF0aW9uOiBudW1iZXIsIHRpbWU6ICosIG9mZnNldDogbnVtYmVyfX1cbiAgICovXG4gIGV4cG9ydHMuY29ycmVjdFRpbWVGb3JIaWRkZW4gPSBmdW5jdGlvbiAobW9tZW50LCBoaWRkZW5EYXRlcywgcmFuZ2UsIHRpbWUpIHtcbiAgICB0aW1lID0gbW9tZW50KHRpbWUpLnRvRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICB0aW1lIC09IGV4cG9ydHMuZ2V0SGlkZGVuRHVyYXRpb25CZWZvcmUobW9tZW50LCBoaWRkZW5EYXRlcywgcmFuZ2UsIHRpbWUpO1xuICAgIHJldHVybiB0aW1lO1xuICB9O1xuXG4gIGV4cG9ydHMuZ2V0SGlkZGVuRHVyYXRpb25CZWZvcmUgPSBmdW5jdGlvbiAobW9tZW50LCBoaWRkZW5EYXRlcywgcmFuZ2UsIHRpbWUpIHtcbiAgICB2YXIgdGltZU9mZnNldCA9IDA7XG4gICAgdGltZSA9IG1vbWVudCh0aW1lKS50b0RhdGUoKS52YWx1ZU9mKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhpZGRlbkRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3RhcnREYXRlID0gaGlkZGVuRGF0ZXNbaV0uc3RhcnQ7XG4gICAgICB2YXIgZW5kRGF0ZSA9IGhpZGRlbkRhdGVzW2ldLmVuZDtcbiAgICAgIC8vIGlmIHRpbWUgYWZ0ZXIgdGhlIGN1dG91dCwgYW5kIHRoZVxuICAgICAgaWYgKHN0YXJ0RGF0ZSA+PSByYW5nZS5zdGFydCAmJiBlbmREYXRlIDwgcmFuZ2UuZW5kKSB7XG4gICAgICAgIGlmICh0aW1lID49IGVuZERhdGUpIHtcbiAgICAgICAgICB0aW1lT2Zmc2V0ICs9IGVuZERhdGUgLSBzdGFydERhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRpbWVPZmZzZXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIHN1bSB0aGUgZHVyYXRpb24gZnJvbSBzdGFydCB0byBmaW5pc2gsIGluY2x1ZGluZyB0aGUgaGlkZGVuIGR1cmF0aW9uLFxuICAgKiB1bnRpbCB0aGUgcmVxdWlyZWQgYW1vdW50IGhhcyBiZWVuIHJlYWNoZWQsIHJldHVybiB0aGUgYWNjdW11bGF0ZWQgaGlkZGVuIGR1cmF0aW9uXG4gICAqIEBwYXJhbSBoaWRkZW5EYXRlc1xuICAgKiBAcGFyYW0gcmFuZ2VcbiAgICogQHBhcmFtIHRpbWVcbiAgICogQHJldHVybnMge3tkdXJhdGlvbjogbnVtYmVyLCB0aW1lOiAqLCBvZmZzZXQ6IG51bWJlcn19XG4gICAqL1xuICBleHBvcnRzLmdldEFjY3VtdWxhdGVkSGlkZGVuRHVyYXRpb24gPSBmdW5jdGlvbiAoaGlkZGVuRGF0ZXMsIHJhbmdlLCByZXF1aXJlZER1cmF0aW9uKSB7XG4gICAgdmFyIGhpZGRlbkR1cmF0aW9uID0gMDtcbiAgICB2YXIgZHVyYXRpb24gPSAwO1xuICAgIHZhciBwcmV2aW91c1BvaW50ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgLy9leHBvcnRzLnByaW50RGF0ZXMoaGlkZGVuRGF0ZXMpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHN0YXJ0RGF0ZSA9IGhpZGRlbkRhdGVzW2ldLnN0YXJ0O1xuICAgICAgdmFyIGVuZERhdGUgPSBoaWRkZW5EYXRlc1tpXS5lbmQ7XG4gICAgICAvLyBpZiB0aW1lIGFmdGVyIHRoZSBjdXRvdXQsIGFuZCB0aGVcbiAgICAgIGlmIChzdGFydERhdGUgPj0gcmFuZ2Uuc3RhcnQgJiYgZW5kRGF0ZSA8IHJhbmdlLmVuZCkge1xuICAgICAgICBkdXJhdGlvbiArPSBzdGFydERhdGUgLSBwcmV2aW91c1BvaW50O1xuICAgICAgICBwcmV2aW91c1BvaW50ID0gZW5kRGF0ZTtcbiAgICAgICAgaWYgKGR1cmF0aW9uID49IHJlcXVpcmVkRHVyYXRpb24pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoaWRkZW5EdXJhdGlvbiArPSBlbmREYXRlIC0gc3RhcnREYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhpZGRlbkR1cmF0aW9uO1xuICB9O1xuXG4gIC8qKlxuICAgKiB1c2VkIHRvIHN0ZXAgb3ZlciB0byBlaXRoZXIgc2lkZSBvZiBhIGhpZGRlbiBibG9jay4gQ29ycmVjdGlvbiBpcyBkaXNhYmxlZCBvbiB0YWJsZXRzLCBtaWdodCBiZSBzZXQgdG8gdHJ1ZVxuICAgKiBAcGFyYW0gaGlkZGVuRGF0ZXNcbiAgICogQHBhcmFtIHRpbWVcbiAgICogQHBhcmFtIGRpcmVjdGlvblxuICAgKiBAcGFyYW0gY29ycmVjdGlvbkVuYWJsZWRcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBleHBvcnRzLnNuYXBBd2F5RnJvbUhpZGRlbiA9IGZ1bmN0aW9uIChoaWRkZW5EYXRlcywgdGltZSwgZGlyZWN0aW9uLCBjb3JyZWN0aW9uRW5hYmxlZCkge1xuICAgIHZhciBpc0hpZGRlbiA9IGV4cG9ydHMuaXNIaWRkZW4odGltZSwgaGlkZGVuRGF0ZXMpO1xuICAgIGlmIChpc0hpZGRlbi5oaWRkZW4gPT0gdHJ1ZSkge1xuICAgICAgaWYgKGRpcmVjdGlvbiA8IDApIHtcbiAgICAgICAgaWYgKGNvcnJlY3Rpb25FbmFibGVkID09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNIaWRkZW4uc3RhcnREYXRlIC0gKGlzSGlkZGVuLmVuZERhdGUgLSB0aW1lKSAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGlzSGlkZGVuLnN0YXJ0RGF0ZSAtIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjb3JyZWN0aW9uRW5hYmxlZCA9PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIGlzSGlkZGVuLmVuZERhdGUgKyAodGltZSAtIGlzSGlkZGVuLnN0YXJ0RGF0ZSkgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpc0hpZGRlbi5lbmREYXRlICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGltZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGltZSBpcyBoaWRkZW5cbiAgICpcbiAgICogQHBhcmFtIHRpbWVcbiAgICogQHBhcmFtIGhpZGRlbkRhdGVzXG4gICAqIEByZXR1cm5zIHt7aGlkZGVuOiBib29sZWFuLCBzdGFydERhdGU6IFdpbmRvdy5zdGFydCwgZW5kRGF0ZTogKn19XG4gICAqL1xuICBleHBvcnRzLmlzSGlkZGVuID0gZnVuY3Rpb24gKHRpbWUsIGhpZGRlbkRhdGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHN0YXJ0RGF0ZSA9IGhpZGRlbkRhdGVzW2ldLnN0YXJ0O1xuICAgICAgdmFyIGVuZERhdGUgPSBoaWRkZW5EYXRlc1tpXS5lbmQ7XG5cbiAgICAgIGlmICh0aW1lID49IHN0YXJ0RGF0ZSAmJiB0aW1lIDwgZW5kRGF0ZSkge1xuICAgICAgICAvLyBpZiB0aGUgc3RhcnQgaXMgZW50ZXJpbmcgYSBoaWRkZW4gem9uZVxuICAgICAgICByZXR1cm4geyBoaWRkZW46IHRydWUsIHN0YXJ0RGF0ZTogc3RhcnREYXRlLCBlbmREYXRlOiBlbmREYXRlIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBoaWRkZW46IGZhbHNlLCBzdGFydERhdGU6IHN0YXJ0RGF0ZSwgZW5kRGF0ZTogZW5kRGF0ZSB9O1xuICB9O1xuXG4vKioqLyB9LFxuLyogMzUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbiAgdmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbiAgdmFyIEhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuICB2YXIgaGFtbWVyVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBEYXRhU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbiAgdmFyIERhdGFWaWV3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG4gIHZhciBSYW5nZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xuICB2YXIgSXRlbVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xuICB2YXIgVGltZUF4aXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KTtcbiAgdmFyIEFjdGl2YXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpO1xuICB2YXIgRGF0ZVV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcbiAgdmFyIEN1c3RvbVRpbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgdGltZWxpbmUgdmlzdWFsaXphdGlvblxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIENvcmUoKSB7fVxuXG4gIC8vIHR1cm4gQ29yZSBpbnRvIGFuIGV2ZW50IGVtaXR0ZXJcbiAgRW1pdHRlcihDb3JlLnByb3RvdHlwZSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgbWFpbiBET00gZm9yIHRoZSBDb3JlOiBhIHJvb3QgcGFuZWwgY29udGFpbmluZyBsZWZ0LCByaWdodCxcbiAgICogdG9wLCBib3R0b20sIGNvbnRlbnQsIGFuZCBiYWNrZ3JvdW5kIHBhbmVsLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lciAgVGhlIGNvbnRhaW5lciBlbGVtZW50IHdoZXJlIHRoZSBDb3JlIHdpbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGF0dGFjaGVkLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIHRoaXMuZG9tID0ge307XG5cbiAgICB0aGlzLmRvbS5jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICB0aGlzLmRvbS5yb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uYmFja2dyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tLmJhY2tncm91bmRWZXJ0aWNhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tLmJhY2tncm91bmRIb3Jpem9udGFsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uY2VudGVyQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20ubGVmdENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tLnJpZ2h0Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uY2VudGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20ubGVmdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tLnJpZ2h0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20udG9wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uYm90dG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uc2hhZG93VG9wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uc2hhZG93Qm90dG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uc2hhZG93VG9wTGVmdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tLnNoYWRvd0JvdHRvbUxlZnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS5zaGFkb3dUb3BSaWdodCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tLnNoYWRvd0JvdHRvbVJpZ2h0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICB0aGlzLmRvbS5yb290LmNsYXNzTmFtZSA9ICd2aXMtdGltZWxpbmUnO1xuICAgIHRoaXMuZG9tLmJhY2tncm91bmQuY2xhc3NOYW1lID0gJ3Zpcy1wYW5lbCB2aXMtYmFja2dyb3VuZCc7XG4gICAgdGhpcy5kb20uYmFja2dyb3VuZFZlcnRpY2FsLmNsYXNzTmFtZSA9ICd2aXMtcGFuZWwgdmlzLWJhY2tncm91bmQgdmlzLXZlcnRpY2FsJztcbiAgICB0aGlzLmRvbS5iYWNrZ3JvdW5kSG9yaXpvbnRhbC5jbGFzc05hbWUgPSAndmlzLXBhbmVsIHZpcy1iYWNrZ3JvdW5kIHZpcy1ob3Jpem9udGFsJztcbiAgICB0aGlzLmRvbS5jZW50ZXJDb250YWluZXIuY2xhc3NOYW1lID0gJ3Zpcy1wYW5lbCB2aXMtY2VudGVyJztcbiAgICB0aGlzLmRvbS5sZWZ0Q29udGFpbmVyLmNsYXNzTmFtZSA9ICd2aXMtcGFuZWwgdmlzLWxlZnQnO1xuICAgIHRoaXMuZG9tLnJpZ2h0Q29udGFpbmVyLmNsYXNzTmFtZSA9ICd2aXMtcGFuZWwgdmlzLXJpZ2h0JztcbiAgICB0aGlzLmRvbS50b3AuY2xhc3NOYW1lID0gJ3Zpcy1wYW5lbCB2aXMtdG9wJztcbiAgICB0aGlzLmRvbS5ib3R0b20uY2xhc3NOYW1lID0gJ3Zpcy1wYW5lbCB2aXMtYm90dG9tJztcbiAgICB0aGlzLmRvbS5sZWZ0LmNsYXNzTmFtZSA9ICd2aXMtY29udGVudCc7XG4gICAgdGhpcy5kb20uY2VudGVyLmNsYXNzTmFtZSA9ICd2aXMtY29udGVudCc7XG4gICAgdGhpcy5kb20ucmlnaHQuY2xhc3NOYW1lID0gJ3Zpcy1jb250ZW50JztcbiAgICB0aGlzLmRvbS5zaGFkb3dUb3AuY2xhc3NOYW1lID0gJ3Zpcy1zaGFkb3cgdmlzLXRvcCc7XG4gICAgdGhpcy5kb20uc2hhZG93Qm90dG9tLmNsYXNzTmFtZSA9ICd2aXMtc2hhZG93IHZpcy1ib3R0b20nO1xuICAgIHRoaXMuZG9tLnNoYWRvd1RvcExlZnQuY2xhc3NOYW1lID0gJ3Zpcy1zaGFkb3cgdmlzLXRvcCc7XG4gICAgdGhpcy5kb20uc2hhZG93Qm90dG9tTGVmdC5jbGFzc05hbWUgPSAndmlzLXNoYWRvdyB2aXMtYm90dG9tJztcbiAgICB0aGlzLmRvbS5zaGFkb3dUb3BSaWdodC5jbGFzc05hbWUgPSAndmlzLXNoYWRvdyB2aXMtdG9wJztcbiAgICB0aGlzLmRvbS5zaGFkb3dCb3R0b21SaWdodC5jbGFzc05hbWUgPSAndmlzLXNoYWRvdyB2aXMtYm90dG9tJztcblxuICAgIHRoaXMuZG9tLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5kb20uYmFja2dyb3VuZCk7XG4gICAgdGhpcy5kb20ucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5iYWNrZ3JvdW5kVmVydGljYWwpO1xuICAgIHRoaXMuZG9tLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5kb20uYmFja2dyb3VuZEhvcml6b250YWwpO1xuICAgIHRoaXMuZG9tLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5kb20uY2VudGVyQ29udGFpbmVyKTtcbiAgICB0aGlzLmRvbS5yb290LmFwcGVuZENoaWxkKHRoaXMuZG9tLmxlZnRDb250YWluZXIpO1xuICAgIHRoaXMuZG9tLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5kb20ucmlnaHRDb250YWluZXIpO1xuICAgIHRoaXMuZG9tLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5kb20udG9wKTtcbiAgICB0aGlzLmRvbS5yb290LmFwcGVuZENoaWxkKHRoaXMuZG9tLmJvdHRvbSk7XG5cbiAgICB0aGlzLmRvbS5jZW50ZXJDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uY2VudGVyKTtcbiAgICB0aGlzLmRvbS5sZWZ0Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLmxlZnQpO1xuICAgIHRoaXMuZG9tLnJpZ2h0Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLnJpZ2h0KTtcbiAgICB0aGlzLmRvbS5jZW50ZXJDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uc2hhZG93VG9wKTtcbiAgICB0aGlzLmRvbS5jZW50ZXJDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uc2hhZG93Qm90dG9tKTtcbiAgICB0aGlzLmRvbS5sZWZ0Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLnNoYWRvd1RvcExlZnQpO1xuICAgIHRoaXMuZG9tLmxlZnRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uc2hhZG93Qm90dG9tTGVmdCk7XG4gICAgdGhpcy5kb20ucmlnaHRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uc2hhZG93VG9wUmlnaHQpO1xuICAgIHRoaXMuZG9tLnJpZ2h0Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLnNoYWRvd0JvdHRvbVJpZ2h0KTtcblxuICAgIC8vIHNpemUgcHJvcGVydGllcyBvZiBlYWNoIG9mIHRoZSBwYW5lbHNcbiAgICB0aGlzLnByb3BzID0ge1xuICAgICAgcm9vdDoge30sXG4gICAgICBiYWNrZ3JvdW5kOiB7fSxcbiAgICAgIGNlbnRlckNvbnRhaW5lcjoge30sXG4gICAgICBsZWZ0Q29udGFpbmVyOiB7fSxcbiAgICAgIHJpZ2h0Q29udGFpbmVyOiB7fSxcbiAgICAgIGNlbnRlcjoge30sXG4gICAgICBsZWZ0OiB7fSxcbiAgICAgIHJpZ2h0OiB7fSxcbiAgICAgIHRvcDoge30sXG4gICAgICBib3R0b206IHt9LFxuICAgICAgYm9yZGVyOiB7fSxcbiAgICAgIHNjcm9sbFRvcDogMCxcbiAgICAgIHNjcm9sbFRvcE1pbjogMFxuICAgIH07XG5cbiAgICB0aGlzLm9uKCdyYW5nZWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLmluaXRpYWxEcmF3RG9uZSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9yZWRyYXcoKTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuICAgIHRoaXMub24oJ3RvdWNoJywgdGhpcy5fb25Ub3VjaC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLm9uKCdwYW5tb3ZlJywgdGhpcy5fb25EcmFnLmJpbmQodGhpcykpO1xuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB0aGlzLm9uKCdfY2hhbmdlJywgZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcbiAgICAgIGlmIChwcm9wZXJ0aWVzICYmIHByb3BlcnRpZXMucXVldWUgPT0gdHJ1ZSkge1xuICAgICAgICAvLyByZWRyYXcgb25jZSBvbiBuZXh0IHRpY2tcbiAgICAgICAgaWYgKCFtZS5fcmVkcmF3VGltZXIpIHtcbiAgICAgICAgICBtZS5fcmVkcmF3VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1lLl9yZWRyYXdUaW1lciA9IG51bGw7XG4gICAgICAgICAgICBtZS5fcmVkcmF3KCk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlZHJhdyBpbW1lZGlhdGVseVxuICAgICAgICBtZS5fcmVkcmF3KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBjcmVhdGUgZXZlbnQgbGlzdGVuZXJzIGZvciBhbGwgaW50ZXJlc3RpbmcgZXZlbnRzLCB0aGVzZSBldmVudHMgd2lsbCBiZVxuICAgIC8vIGVtaXR0ZWQgdmlhIGVtaXR0ZXJcbiAgICB0aGlzLmhhbW1lciA9IG5ldyBIYW1tZXIodGhpcy5kb20ucm9vdCk7XG4gICAgdmFyIHBpbmNoUmVjb2duaXplciA9IHRoaXMuaGFtbWVyLmdldCgncGluY2gnKS5zZXQoeyBlbmFibGU6IHRydWUgfSk7XG4gICAgaGFtbWVyVXRpbC5kaXNhYmxlUHJldmVudERlZmF1bHRWZXJ0aWNhbGx5KHBpbmNoUmVjb2duaXplcik7XG4gICAgdGhpcy5oYW1tZXIuZ2V0KCdwYW4nKS5zZXQoeyB0aHJlc2hvbGQ6IDUsIGRpcmVjdGlvbjogSGFtbWVyLkRJUkVDVElPTl9IT1JJWk9OVEFMIH0pO1xuICAgIHRoaXMubGlzdGVuZXJzID0ge307XG5cbiAgICB2YXIgZXZlbnRzID0gWyd0YXAnLCAnZG91YmxldGFwJywgJ3ByZXNzJywgJ3BpbmNoJywgJ3BhbicsICdwYW5zdGFydCcsICdwYW5tb3ZlJywgJ3BhbmVuZCdcbiAgICAvLyBUT0RPOiBjbGVhbnVwXG4gICAgLy8ndG91Y2gnLCAncGluY2gnLFxuICAgIC8vJ3RhcCcsICdkb3VibGV0YXAnLCAnaG9sZCcsXG4gICAgLy8nZHJhZ3N0YXJ0JywgJ2RyYWcnLCAnZHJhZ2VuZCcsXG4gICAgLy8nbW91c2V3aGVlbCcsICdET01Nb3VzZVNjcm9sbCcgLy8gRE9NTW91c2VTY3JvbGwgaXMgbmVlZGVkIGZvciBGaXJlZm94XG4gICAgXTtcbiAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gbGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgICAgaWYgKG1lLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICBtZS5lbWl0KHR5cGUsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIG1lLmhhbW1lci5vbih0eXBlLCBsaXN0ZW5lcik7XG4gICAgICBtZS5saXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICB9KTtcblxuICAgIC8vIGVtdWxhdGUgYSB0b3VjaCBldmVudCAoZW1pdHRlZCBiZWZvcmUgdGhlIHN0YXJ0IG9mIGEgcGFuLCBwaW5jaCwgdGFwLCBvciBwcmVzcylcbiAgICBoYW1tZXJVdGlsLm9uVG91Y2godGhpcy5oYW1tZXIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgbWUuZW1pdCgndG91Y2gnLCBldmVudCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIGVtdWxhdGUgYSByZWxlYXNlIGV2ZW50IChlbWl0dGVkIGFmdGVyIGEgcGFuLCBwaW5jaCwgdGFwLCBvciBwcmVzcylcbiAgICBoYW1tZXJVdGlsLm9uUmVsZWFzZSh0aGlzLmhhbW1lciwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBtZS5lbWl0KCdyZWxlYXNlJywgZXZlbnQpO1xuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlV2hlZWwoZXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdtb3VzZXdoZWVsJywgZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBwcmV2ZW50IHNjcm9sbGluZyB3aGVuIHpvb21LZXkgZGVmaW5lZCBvciBhY3RpdmF0ZWRcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnpvb21LZXkgfHwgZXZlbnRbdGhpcy5vcHRpb25zLnpvb21LZXldKSByZXR1cm47XG5cbiAgICAgIC8vIHByZXZlbnQgc2Nyb2xsaW5nIHZlcnRpY2FsbHkgd2hlbiBob3Jpem9udGFsU2Nyb2xsIGlzIHRydWVcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbFNjcm9sbCkgcmV0dXJuO1xuXG4gICAgICB2YXIgZGVsdGEgPSAwO1xuICAgICAgaWYgKGV2ZW50LndoZWVsRGVsdGEpIHtcbiAgICAgICAgLyogSUUvT3BlcmEuICovXG4gICAgICAgIGRlbHRhID0gZXZlbnQud2hlZWxEZWx0YSAvIDEyMDtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGV0YWlsKSB7XG4gICAgICAgIC8qIE1vemlsbGEgY2FzZS4gKi9cbiAgICAgICAgLy8gSW4gTW96aWxsYSwgc2lnbiBvZiBkZWx0YSBpcyBkaWZmZXJlbnQgdGhhbiBpbiBJRS5cbiAgICAgICAgLy8gQWxzbywgZGVsdGEgaXMgbXVsdGlwbGUgb2YgMy5cbiAgICAgICAgZGVsdGEgPSAtZXZlbnQuZGV0YWlsIC8gMztcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLnByb3BzLnNjcm9sbFRvcDtcbiAgICAgIHZhciBhZGp1c3RlZCA9IGN1cnJlbnQgKyBkZWx0YSAqIDEyMDtcblxuICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgICB0aGlzLl9zZXRTY3JvbGxUb3AoYWRqdXN0ZWQpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnZlcnRpY2FsU2Nyb2xsKSB7XG4gICAgICAgICAgdGhpcy5kb20ubGVmdC5wYXJlbnROb2RlLnNjcm9sbFRvcCA9IC1hZGp1c3RlZDtcbiAgICAgICAgICB0aGlzLmRvbS5yaWdodC5wYXJlbnROb2RlLnNjcm9sbFRvcCA9IC1hZGp1c3RlZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZWRyYXcoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdzY3JvbGwnLCBldmVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXZlbnQgZGVmYXVsdCBhY3Rpb25zIGNhdXNlZCBieSBtb3VzZSB3aGVlbFxuICAgICAgLy8gKGVsc2UgdGhlIHBhZ2UgYW5kIHRpbWVsaW5lIGJvdGggc2Nyb2xsKVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kb20uY2VudGVyQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIC8vIElFOSwgQ2hyb21lLCBTYWZhcmksIE9wZXJhXG4gICAgICB0aGlzLmRvbS5jZW50ZXJDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNld2hlZWxcIiwgb25Nb3VzZVdoZWVsLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgICAgIC8vIEZpcmVmb3hcbiAgICAgIHRoaXMuZG9tLmNlbnRlckNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiRE9NTW91c2VTY3JvbGxcIiwgb25Nb3VzZVdoZWVsLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSUUgNi83LzhcbiAgICAgIHRoaXMuZG9tLmNlbnRlckNvbnRhaW5lci5hdHRhY2hFdmVudChcIm9ubW91c2V3aGVlbFwiLCBvbk1vdXNlV2hlZWwuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZVNjcm9sbFNpZGUoZXZlbnQpIHtcbiAgICAgIGlmICghbWUub3B0aW9ucy52ZXJ0aWNhbFNjcm9sbCkgcmV0dXJuO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmIChtZS5pc0FjdGl2ZSgpKSB7XG4gICAgICAgIHZhciBhZGp1c3RlZCA9IC1ldmVudC50YXJnZXQuc2Nyb2xsVG9wO1xuICAgICAgICBtZS5fc2V0U2Nyb2xsVG9wKGFkanVzdGVkKTtcbiAgICAgICAgbWUuX3JlZHJhdygpO1xuICAgICAgICBtZS5lbWl0KCdzY3JvbGxTaWRlJywgZXZlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZG9tLmxlZnQucGFyZW50Tm9kZS5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvbk1vdXNlU2Nyb2xsU2lkZS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmRvbS5yaWdodC5wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uTW91c2VTY3JvbGxTaWRlLmJpbmQodGhpcykpO1xuXG4gICAgdmFyIGl0ZW1BZGRlZFRvVGltZWxpbmUgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZURyYWdPdmVyKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gTmVjZXNzYXJ5LiBBbGxvd3MgdXMgdG8gZHJvcC5cbiAgICAgIH1cblxuICAgICAgLy8gbWFrZSBzdXJlIHlvdXIgdGFyZ2V0IGlzIGEgdmlzIGVsZW1lbnRcbiAgICAgIGlmICghZXZlbnQudGFyZ2V0LmNsYXNzTmFtZS5pbmNsdWRlcygndmlzJykpIHJldHVybjtcblxuICAgICAgLy8gbWFrZSBzdXJlIG9ubHkgb25lIGl0ZW0gaXMgYWRkZWQgZXZlcnkgdGltZSB5b3UncmUgb3ZlciB0aGUgdGltZWxpbmVcbiAgICAgIGlmIChpdGVtQWRkZWRUb1RpbWVsaW5lKSByZXR1cm47XG5cbiAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ21vdmUnO1xuICAgICAgaXRlbUFkZGVkVG9UaW1lbGluZSA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlRHJvcChldmVudCkge1xuICAgICAgLy8gcmV0dXJuIHdoZW4gZHJvcHBpbmcgbm9uLXZpcyBpdGVtcyBcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBpdGVtRGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpKTtcbiAgICAgICAgaWYgKCFpdGVtRGF0YS5jb250ZW50KSByZXR1cm47XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpdGVtQWRkZWRUb1RpbWVsaW5lID0gZmFsc2U7XG4gICAgICBldmVudC5jZW50ZXIgPSB7XG4gICAgICAgIHg6IGV2ZW50LngsXG4gICAgICAgIHk6IGV2ZW50LnlcbiAgICAgIH07XG4gICAgICBtZS5pdGVtU2V0Ll9vbkFkZEl0ZW0oZXZlbnQpO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5kb20uY2VudGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgaGFuZGxlRHJhZ092ZXIuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgIHRoaXMuZG9tLmNlbnRlci5hZGRFdmVudExpc3RlbmVyKCdkcm9wJywgaGFuZGxlRHJvcC5iaW5kKHRoaXMpLCBmYWxzZSk7XG5cbiAgICB0aGlzLmN1c3RvbVRpbWVzID0gW107XG5cbiAgICAvLyBzdG9yZSBzdGF0ZSBpbmZvcm1hdGlvbiBuZWVkZWQgZm9yIHRvdWNoIGV2ZW50c1xuICAgIHRoaXMudG91Y2ggPSB7fTtcblxuICAgIHRoaXMucmVkcmF3Q291bnQgPSAwO1xuICAgIHRoaXMuaW5pdGlhbERyYXdEb25lID0gZmFsc2U7XG5cbiAgICAvLyBhdHRhY2ggdGhlIHJvb3QgcGFuZWwgdG8gdGhlIHByb3ZpZGVkIGNvbnRhaW5lclxuICAgIGlmICghY29udGFpbmVyKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbnRhaW5lciBwcm92aWRlZCcpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5yb290KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IG9wdGlvbnMuIE9wdGlvbnMgd2lsbCBiZSBwYXNzZWQgdG8gYWxsIGNvbXBvbmVudHMgbG9hZGVkIGluIHRoZSBUaW1lbGluZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IG9yaWVudGF0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVydGljYWwgb3JpZW50YXRpb24gZm9yIHRoZSBUaW1lbGluZSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW4gYmUgJ2JvdHRvbScgKGRlZmF1bHQpIG9yICd0b3AnLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBOdW1iZXJ9IHdpZHRoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2lkdGggZm9yIHRoZSB0aW1lbGluZSwgYSBudW1iZXIgaW4gcGl4ZWxzIG9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBjc3Mgc3RyaW5nIGxpa2UgJzEwMDBweCcgb3IgJzc1JScuICcxMDAlJyBieSBkZWZhdWx0LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBOdW1iZXJ9IGhlaWdodFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZpeGVkIGhlaWdodCBmb3IgdGhlIFRpbWVsaW5lLCBhIG51bWJlciBpbiBwaXhlbHMgb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGNzcyBzdHJpbmcgbGlrZSAnNDAwcHgnIG9yICc3NSUnLiBJZiB1bmRlZmluZWQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIFRpbWVsaW5lIHdpbGwgYXV0b21hdGljYWxseSBzaXplIHN1Y2ggdGhhdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0cyBjb250ZW50cyBmaXQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IE51bWJlcn0gbWluSGVpZ2h0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWluaW11bSBoZWlnaHQgZm9yIHRoZSBUaW1lbGluZSwgYSBudW1iZXIgaW4gcGl4ZWxzIG9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBjc3Mgc3RyaW5nIGxpa2UgJzQwMHB4JyBvciAnNzUlJy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgTnVtYmVyfSBtYXhIZWlnaHRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXhpbXVtIGhlaWdodCBmb3IgdGhlIFRpbWVsaW5lLCBhIG51bWJlciBpbiBwaXhlbHMgb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGNzcyBzdHJpbmcgbGlrZSAnNDAwcHgnIG9yICc3NSUnLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXIgfCBEYXRlIHwgU3RyaW5nfSBzdGFydFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0YXJ0IGRhdGUgZm9yIHRoZSB2aXNpYmxlIHdpbmRvd1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXIgfCBEYXRlIHwgU3RyaW5nfSBlbmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbmQgZGF0ZSBmb3IgdGhlIHZpc2libGUgd2luZG93XG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgLy8gY29weSB0aGUga25vd24gb3B0aW9uc1xuICAgICAgdmFyIGZpZWxkcyA9IFsnd2lkdGgnLCAnaGVpZ2h0JywgJ21pbkhlaWdodCcsICdtYXhIZWlnaHQnLCAnYXV0b1Jlc2l6ZScsICdzdGFydCcsICdlbmQnLCAnY2xpY2tUb1VzZScsICdkYXRhQXR0cmlidXRlcycsICdoaWRkZW5EYXRlcycsICdsb2NhbGUnLCAnbG9jYWxlcycsICdtb21lbnQnLCAncnRsJywgJ3pvb21LZXknLCAnaG9yaXpvbnRhbFNjcm9sbCcsICd2ZXJ0aWNhbFNjcm9sbCddO1xuICAgICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICB0aGlzLmRvbS5jb250YWluZXIuc3R5bGUuZGlyZWN0aW9uID0gXCJydGxcIjtcbiAgICAgICAgdGhpcy5kb20uYmFja2dyb3VuZFZlcnRpY2FsLmNsYXNzTmFtZSA9ICd2aXMtcGFuZWwgdmlzLWJhY2tncm91bmQgdmlzLXZlcnRpY2FsLXJ0bCc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudmVydGljYWxTY3JvbGwpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgICB0aGlzLmRvbS5yaWdodENvbnRhaW5lci5jbGFzc05hbWUgPSAndmlzLXBhbmVsIHZpcy1yaWdodCB2aXMtdmVydGljYWwtc2Nyb2xsJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRvbS5sZWZ0Q29udGFpbmVyLmNsYXNzTmFtZSA9ICd2aXMtcGFuZWwgdmlzLWxlZnQgdmlzLXZlcnRpY2FsLXNjcm9sbCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uID0geyBpdGVtOiB1bmRlZmluZWQsIGF4aXM6IHVuZGVmaW5lZCB9O1xuICAgICAgaWYgKCdvcmllbnRhdGlvbicgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMub3JpZW50YXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uID0ge1xuICAgICAgICAgICAgaXRlbTogb3B0aW9ucy5vcmllbnRhdGlvbixcbiAgICAgICAgICAgIGF4aXM6IG9wdGlvbnMub3JpZW50YXRpb25cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2Yob3B0aW9ucy5vcmllbnRhdGlvbikgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWYgKCdpdGVtJyBpbiBvcHRpb25zLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbSA9IG9wdGlvbnMub3JpZW50YXRpb24uaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCdheGlzJyBpbiBvcHRpb25zLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uYXhpcyA9IG9wdGlvbnMub3JpZW50YXRpb24uYXhpcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5heGlzID09PSAnYm90aCcpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRpbWVBeGlzMikge1xuICAgICAgICAgIHZhciB0aW1lQXhpczIgPSB0aGlzLnRpbWVBeGlzMiA9IG5ldyBUaW1lQXhpcyh0aGlzLmJvZHkpO1xuICAgICAgICAgIHRpbWVBeGlzMi5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMgPyB1dGlsLmV4dGVuZCh7fSwgb3B0aW9ucykgOiB7fTtcbiAgICAgICAgICAgIF9vcHRpb25zLm9yaWVudGF0aW9uID0gJ3RvcCc7IC8vIG92ZXJyaWRlIHRoZSBvcmllbnRhdGlvbiBvcHRpb24sIGFsd2F5cyB0b3BcbiAgICAgICAgICAgIFRpbWVBeGlzLnByb3RvdHlwZS5zZXRPcHRpb25zLmNhbGwodGltZUF4aXMyLCBfb3B0aW9ucyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmNvbXBvbmVudHMucHVzaCh0aW1lQXhpczIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy50aW1lQXhpczIpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmNvbXBvbmVudHMuaW5kZXhPZih0aGlzLnRpbWVBeGlzMik7XG4gICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudGltZUF4aXMyLmRlc3Ryb3koKTtcbiAgICAgICAgICB0aGlzLnRpbWVBeGlzMiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlIGdyYXBoMmQncyBkcmF3UG9pbnRzIGlzIGEgZnVuY3Rpb24gZGVsZWdhdGUgdGhlIGNhbGxiYWNrIHRvIHRoZSBvblJlbmRlciBwcm9wZXJ0eVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRyYXdQb2ludHMgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvcHRpb25zLmRyYXdQb2ludHMgPSB7XG4gICAgICAgICAgb25SZW5kZXI6IG9wdGlvbnMuZHJhd1BvaW50c1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoJ2hpZGRlbkRhdGVzJyBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgRGF0ZVV0aWwuY29udmVydEhpZGRlbk9wdGlvbnModGhpcy5vcHRpb25zLm1vbWVudCwgdGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMuaGlkZGVuRGF0ZXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ2NsaWNrVG9Vc2UnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2xpY2tUb1VzZSkge1xuICAgICAgICAgIGlmICghdGhpcy5hY3RpdmF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdG9yID0gbmV3IEFjdGl2YXRvcih0aGlzLmRvbS5yb290KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuYWN0aXZhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRvci5kZXN0cm95KCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5hY3RpdmF0b3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgnc2hvd0N1c3RvbVRpbWUnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gYHNob3dDdXN0b21UaW1lYCBpcyBkZXByZWNhdGVkLiBDcmVhdGUgYSBjdXN0b20gdGltZSBiYXIgdmlhIHRpbWVsaW5lLmFkZEN1c3RvbVRpbWUodGltZSBbLCBpZF0pJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGVuYWJsZS9kaXNhYmxlIGF1dG9SZXNpemVcbiAgICAgIHRoaXMuX2luaXRBdXRvUmVzaXplKCk7XG4gICAgfVxuXG4gICAgLy8gcHJvcGFnYXRlIG9wdGlvbnMgdG8gYWxsIGNvbXBvbmVudHNcbiAgICB0aGlzLmNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gY29tcG9uZW50LnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfSk7XG5cbiAgICAvLyBlbmFibGUvZGlzYWJsZSBjb25maWd1cmVcbiAgICBpZiAoJ2NvbmZpZ3VyZScgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLmNvbmZpZ3VyYXRvcikge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRvciA9IHRoaXMuX2NyZWF0ZUNvbmZpZ3VyYXRvcigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbmZpZ3VyYXRvci5zZXRPcHRpb25zKG9wdGlvbnMuY29uZmlndXJlKTtcblxuICAgICAgLy8gY29sbGVjdCB0aGUgc2V0dGluZ3Mgb2YgYWxsIGNvbXBvbmVudHMsIGFuZCBwYXNzIHRoZW0gdG8gdGhlIGNvbmZpZ3VyYXRpb24gc3lzdGVtXG4gICAgICB2YXIgYXBwbGllZE9wdGlvbnMgPSB1dGlsLmRlZXBFeHRlbmQoe30sIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLmNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHV0aWwuZGVlcEV4dGVuZChhcHBsaWVkT3B0aW9ucywgY29tcG9uZW50Lm9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNvbmZpZ3VyYXRvci5zZXRNb2R1bGVPcHRpb25zKHsgZ2xvYmFsOiBhcHBsaWVkT3B0aW9ucyB9KTtcbiAgICB9XG5cbiAgICAvLyBvdmVycmlkZSByZWRyYXcgd2l0aCBhIHRocm90dGxlZCB2ZXJzaW9uXG4gICAgaWYgKCF0aGlzLl9vcmlnUmVkcmF3KSB7XG4gICAgICB0aGlzLl9vcmlnUmVkcmF3ID0gdGhpcy5fcmVkcmF3LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9yZWRyYXcgPSB1dGlsLnRocm90dGxlKHRoaXMuX29yaWdSZWRyYXcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOb3QgdGhlIGluaXRpYWwgcnVuOiByZWRyYXcgZXZlcnl0aGluZ1xuICAgICAgdGhpcy5fcmVkcmF3KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgVGltZWxpbmUgaXMgYWN0aXZlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIENvcmUucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhdGhpcy5hY3RpdmF0b3IgfHwgdGhpcy5hY3RpdmF0b3IuYWN0aXZlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBDb3JlLCBjbGVhbiB1cCBhbGwgRE9NIGVsZW1lbnRzIGFuZCBldmVudCBsaXN0ZW5lcnMuXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHVuYmluZCBkYXRhc2V0c1xuICAgIHRoaXMuc2V0SXRlbXMobnVsbCk7XG4gICAgdGhpcy5zZXRHcm91cHMobnVsbCk7XG5cbiAgICAvLyByZW1vdmUgYWxsIGV2ZW50IGxpc3RlbmVyc1xuICAgIHRoaXMub2ZmKCk7XG5cbiAgICAvLyBzdG9wIGNoZWNraW5nIGZvciBjaGFuZ2VkIHNpemVcbiAgICB0aGlzLl9zdG9wQXV0b1Jlc2l6ZSgpO1xuXG4gICAgLy8gcmVtb3ZlIGZyb20gRE9NXG4gICAgaWYgKHRoaXMuZG9tLnJvb3QucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5kb20ucm9vdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLnJvb3QpO1xuICAgIH1cbiAgICB0aGlzLmRvbSA9IG51bGw7XG5cbiAgICAvLyByZW1vdmUgQWN0aXZhdG9yXG4gICAgaWYgKHRoaXMuYWN0aXZhdG9yKSB7XG4gICAgICB0aGlzLmFjdGl2YXRvci5kZXN0cm95KCk7XG4gICAgICBkZWxldGUgdGhpcy5hY3RpdmF0b3I7XG4gICAgfVxuXG4gICAgLy8gY2xlYW51cCBoYW1tZXIgdG91Y2ggZXZlbnRzXG4gICAgZm9yICh2YXIgZXZlbnQgaW4gdGhpcy5saXN0ZW5lcnMpIHtcbiAgICAgIGlmICh0aGlzLmxpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMubGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBudWxsO1xuICAgIHRoaXMuaGFtbWVyID0gbnVsbDtcblxuICAgIC8vIGdpdmUgYWxsIGNvbXBvbmVudHMgdGhlIG9wcG9ydHVuaXR5IHRvIGNsZWFudXBcbiAgICB0aGlzLmNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICB9KTtcblxuICAgIHRoaXMuYm9keSA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIGN1c3RvbSB0aW1lIGJhclxuICAgKiBAcGFyYW0ge0RhdGV9IHRpbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpZD11bmRlZmluZWRdIE9wdGlvbmFsIGlkIG9mIHRoZSBjdXN0b20gdGltZSBiYXIgdG8gYmUgYWRqdXN0ZWQuXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5zZXRDdXN0b21UaW1lID0gZnVuY3Rpb24gKHRpbWUsIGlkKSB7XG4gICAgdmFyIGN1c3RvbVRpbWVzID0gdGhpcy5jdXN0b21UaW1lcy5maWx0ZXIoZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIGlkID09PSBjb21wb25lbnQub3B0aW9ucy5pZDtcbiAgICB9KTtcblxuICAgIGlmIChjdXN0b21UaW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY3VzdG9tIHRpbWUgYmFyIGZvdW5kIHdpdGggaWQgJyArIEpTT04uc3RyaW5naWZ5KGlkKSk7XG4gICAgfVxuXG4gICAgaWYgKGN1c3RvbVRpbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGN1c3RvbVRpbWVzWzBdLnNldEN1c3RvbVRpbWUodGltZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBjdXN0b20gdGltZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpZD11bmRlZmluZWRdICAgIElkIG9mIHRoZSBjdXN0b20gdGltZSBiYXIuXG4gICAqIEByZXR1cm4ge0RhdGUgfCB1bmRlZmluZWR9IGN1c3RvbVRpbWVcbiAgICovXG4gIENvcmUucHJvdG90eXBlLmdldEN1c3RvbVRpbWUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgY3VzdG9tVGltZXMgPSB0aGlzLmN1c3RvbVRpbWVzLmZpbHRlcihmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gY29tcG9uZW50Lm9wdGlvbnMuaWQgPT09IGlkO1xuICAgIH0pO1xuXG4gICAgaWYgKGN1c3RvbVRpbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjdXN0b20gdGltZSBiYXIgZm91bmQgd2l0aCBpZCAnICsgSlNPTi5zdHJpbmdpZnkoaWQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1c3RvbVRpbWVzWzBdLmdldEN1c3RvbVRpbWUoKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgY3VzdG9tIHRpdGxlIGZvciB0aGUgY3VzdG9tIHRpbWUgYmFyLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3RpdGxlXSBDdXN0b20gdGl0bGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpZD11bmRlZmluZWRdICAgIElkIG9mIHRoZSBjdXN0b20gdGltZSBiYXIuXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5zZXRDdXN0b21UaW1lVGl0bGUgPSBmdW5jdGlvbiAodGl0bGUsIGlkKSB7XG4gICAgdmFyIGN1c3RvbVRpbWVzID0gdGhpcy5jdXN0b21UaW1lcy5maWx0ZXIoZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIGNvbXBvbmVudC5vcHRpb25zLmlkID09PSBpZDtcbiAgICB9KTtcblxuICAgIGlmIChjdXN0b21UaW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY3VzdG9tIHRpbWUgYmFyIGZvdW5kIHdpdGggaWQgJyArIEpTT04uc3RyaW5naWZ5KGlkKSk7XG4gICAgfVxuICAgIGlmIChjdXN0b21UaW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gY3VzdG9tVGltZXNbMF0uc2V0Q3VzdG9tVGl0bGUodGl0bGUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgbWV0YSBpbmZvcm1hdGlvbiBmcm9tIGFuIGV2ZW50LlxuICAgKiBTaG91bGQgYmUgb3ZlcnJpZGRlbiBieSBjbGFzc2VzIGV4dGVuZGluZyBDb3JlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggcmVsYXRlZCBpbmZvcm1hdGlvbi5cbiAgICovXG4gIENvcmUucHJvdG90eXBlLmdldEV2ZW50UHJvcGVydGllcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiB7IGV2ZW50OiBldmVudCB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgY3VzdG9tIHZlcnRpY2FsIGJhclxuICAgKiBAcGFyYW0ge0RhdGUgfCBTdHJpbmcgfCBOdW1iZXJ9IFt0aW1lXSAgQSBEYXRlLCB1bml4IHRpbWVzdGFtcCwgb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElTTyBkYXRlIHN0cmluZy4gVGltZSBwb2ludCB3aGVyZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5ldyBiYXIgc2hvdWxkIGJlIHBsYWNlZC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIG5vdCBwcm92aWRlZCwgYG5ldyBEYXRlKClgIHdpbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIHVzZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgU3RyaW5nfSBbaWQ9dW5kZWZpbmVkXSBJZCBvZiB0aGUgbmV3IGJhci4gT3B0aW9uYWxcbiAgICogQHJldHVybiB7TnVtYmVyIHwgU3RyaW5nfSAgICAgICAgICAgICAgIFJldHVybnMgdGhlIGlkIG9mIHRoZSBuZXcgYmFyXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5hZGRDdXN0b21UaW1lID0gZnVuY3Rpb24gKHRpbWUsIGlkKSB7XG4gICAgdmFyIHRpbWVzdGFtcCA9IHRpbWUgIT09IHVuZGVmaW5lZCA/IHV0aWwuY29udmVydCh0aW1lLCAnRGF0ZScpLnZhbHVlT2YoKSA6IG5ldyBEYXRlKCk7XG5cbiAgICB2YXIgZXhpc3RzID0gdGhpcy5jdXN0b21UaW1lcy5zb21lKGZ1bmN0aW9uIChjdXN0b21UaW1lKSB7XG4gICAgICByZXR1cm4gY3VzdG9tVGltZS5vcHRpb25zLmlkID09PSBpZDtcbiAgICB9KTtcbiAgICBpZiAoZXhpc3RzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgY3VzdG9tIHRpbWUgd2l0aCBpZCAnICsgSlNPTi5zdHJpbmdpZnkoaWQpICsgJyBhbHJlYWR5IGV4aXN0cycpO1xuICAgIH1cblxuICAgIHZhciBjdXN0b21UaW1lID0gbmV3IEN1c3RvbVRpbWUodGhpcy5ib2R5LCB1dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCB7XG4gICAgICB0aW1lOiB0aW1lc3RhbXAsXG4gICAgICBpZDogaWRcbiAgICB9KSk7XG5cbiAgICB0aGlzLmN1c3RvbVRpbWVzLnB1c2goY3VzdG9tVGltZSk7XG4gICAgdGhpcy5jb21wb25lbnRzLnB1c2goY3VzdG9tVGltZSk7XG4gICAgdGhpcy5fcmVkcmF3KCk7XG5cbiAgICByZXR1cm4gaWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBwcmV2aW91c2x5IGFkZGVkIGN1c3RvbSBiYXJcbiAgICogQHBhcmFtIHtpbnR9IGlkIElEIG9mIHRoZSBjdXN0b20gYmFyIHRvIGJlIHJlbW92ZWRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYmFyIGV4aXN0cyBhbmQgaXMgcmVtb3ZlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5yZW1vdmVDdXN0b21UaW1lID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGN1c3RvbVRpbWVzID0gdGhpcy5jdXN0b21UaW1lcy5maWx0ZXIoZnVuY3Rpb24gKGJhcikge1xuICAgICAgcmV0dXJuIGJhci5vcHRpb25zLmlkID09PSBpZDtcbiAgICB9KTtcblxuICAgIGlmIChjdXN0b21UaW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY3VzdG9tIHRpbWUgYmFyIGZvdW5kIHdpdGggaWQgJyArIEpTT04uc3RyaW5naWZ5KGlkKSk7XG4gICAgfVxuXG4gICAgY3VzdG9tVGltZXMuZm9yRWFjaChmdW5jdGlvbiAoY3VzdG9tVGltZSkge1xuICAgICAgdGhpcy5jdXN0b21UaW1lcy5zcGxpY2UodGhpcy5jdXN0b21UaW1lcy5pbmRleE9mKGN1c3RvbVRpbWUpLCAxKTtcbiAgICAgIHRoaXMuY29tcG9uZW50cy5zcGxpY2UodGhpcy5jb21wb25lbnRzLmluZGV4T2YoY3VzdG9tVGltZSksIDEpO1xuICAgICAgY3VzdG9tVGltZS5kZXN0cm95KCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBpZCdzIG9mIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBpdGVtcy5cbiAgICogQHJldHVybnMge0FycmF5fSBUaGUgaWRzIG9mIHRoZSB2aXNpYmxlIGl0ZW1zXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5nZXRWaXNpYmxlSXRlbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbVNldCAmJiB0aGlzLml0ZW1TZXQuZ2V0VmlzaWJsZUl0ZW1zKCkgfHwgW107XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBDb3JlIHdpbmRvdyBzdWNoIHRoYXQgaXQgZml0cyBhbGwgaXRlbXNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYW5pbWF0aW9uOiBib29sZWFuIHwge2R1cmF0aW9uOiBudW1iZXIsIGVhc2luZ0Z1bmN0aW9uOiBzdHJpbmd9YFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCB0aGUgcmFuZ2UgaXMgYW5pbWF0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhseSB0byB0aGUgbmV3IHdpbmRvdy4gQW4gb2JqZWN0IGNhbiBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkIHRvIHNwZWNpZnkgZHVyYXRpb24gYW5kIGVhc2luZyBmdW5jdGlvbi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGR1cmF0aW9uIGlzIDUwMCBtcywgYW5kIGRlZmF1bHQgZWFzaW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaXMgJ2Vhc2VJbk91dFF1YWQnLlxuICAgKi9cbiAgQ29yZS5wcm90b3R5cGUuZml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldERhdGFSYW5nZSgpO1xuXG4gICAgLy8gc2tpcCByYW5nZSBzZXQgaWYgdGhlcmUgaXMgbm8gbWluIGFuZCBtYXggZGF0ZVxuICAgIGlmIChyYW5nZS5taW4gPT09IG51bGwgJiYgcmFuZ2UubWF4ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYSBtYXJnaW4gb2YgMSUgbGVmdCBhbmQgcmlnaHQgb2YgdGhlIGRhdGFcbiAgICB2YXIgaW50ZXJ2YWwgPSByYW5nZS5tYXggLSByYW5nZS5taW47XG4gICAgdmFyIG1pbiA9IG5ldyBEYXRlKHJhbmdlLm1pbi52YWx1ZU9mKCkgLSBpbnRlcnZhbCAqIDAuMDEpO1xuICAgIHZhciBtYXggPSBuZXcgRGF0ZShyYW5nZS5tYXgudmFsdWVPZigpICsgaW50ZXJ2YWwgKiAwLjAxKTtcbiAgICB2YXIgYW5pbWF0aW9uID0gb3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbmltYXRpb24gOiB0cnVlO1xuICAgIHRoaXMucmFuZ2Uuc2V0UmFuZ2UobWluLCBtYXgsIGFuaW1hdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZGF0YSByYW5nZSBvZiB0aGUgaXRlbXMgc3RhcnQgYW5kIGVuZCBkYXRlc1xuICAgKiBAcmV0dXJucyB7e21pbjogRGF0ZSB8IG51bGwsIG1heDogRGF0ZSB8IG51bGx9fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5nZXREYXRhUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBUaW1lbGluZSBhbmQgR3JhcGgyZFxuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludm9rZSBhYnN0cmFjdCBtZXRob2QgZ2V0RGF0YVJhbmdlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmlzaWJsZSB3aW5kb3cuIEJvdGggcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwsIHlvdSBjYW4gY2hhbmdlIG9ubHlcbiAgICogc3RhcnQgb3Igb25seSBlbmQuIFN5bnRheDpcbiAgICpcbiAgICogICAgIFRpbWVMaW5lLnNldFdpbmRvdyhzdGFydCwgZW5kKVxuICAgKiAgICAgVGltZUxpbmUuc2V0V2luZG93KHN0YXJ0LCBlbmQsIG9wdGlvbnMpXG4gICAqICAgICBUaW1lTGluZS5zZXRXaW5kb3cocmFuZ2UpXG4gICAqXG4gICAqIFdoZXJlIHN0YXJ0IGFuZCBlbmQgY2FuIGJlIGEgRGF0ZSwgbnVtYmVyLCBvciBzdHJpbmcsIGFuZCByYW5nZSBpcyBhblxuICAgKiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHN0YXJ0IGFuZCBlbmQuXG4gICAqXG4gICAqIEBwYXJhbSB7RGF0ZSB8IE51bWJlciB8IFN0cmluZyB8IE9iamVjdH0gW3N0YXJ0XSBTdGFydCBkYXRlIG9mIHZpc2libGUgd2luZG93XG4gICAqIEBwYXJhbSB7RGF0ZSB8IE51bWJlciB8IFN0cmluZ30gW2VuZF0gICAgICAgICAgICBFbmQgZGF0ZSBvZiB2aXNpYmxlIHdpbmRvd1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBhbmltYXRpb246IGJvb2xlYW4gfCB7ZHVyYXRpb246IG51bWJlciwgZWFzaW5nRnVuY3Rpb246IHN0cmluZ31gXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSAoZGVmYXVsdCksIHRoZSByYW5nZSBpcyBhbmltYXRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aGx5IHRvIHRoZSBuZXcgd2luZG93LiBBbiBvYmplY3QgY2FuIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWQgdG8gc3BlY2lmeSBkdXJhdGlvbiBhbmQgZWFzaW5nIGZ1bmN0aW9uLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgZHVyYXRpb24gaXMgNTAwIG1zLCBhbmQgZGVmYXVsdCBlYXNpbmdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBpcyAnZWFzZUluT3V0UXVhZCcuXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5zZXRXaW5kb3cgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgb3B0aW9ucykge1xuICAgIHZhciBhbmltYXRpb247XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgdmFyIHJhbmdlID0gYXJndW1lbnRzWzBdO1xuICAgICAgYW5pbWF0aW9uID0gcmFuZ2UuYW5pbWF0aW9uICE9PSB1bmRlZmluZWQgPyByYW5nZS5hbmltYXRpb24gOiB0cnVlO1xuICAgICAgdGhpcy5yYW5nZS5zZXRSYW5nZShyYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBhbmltYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmltYXRpb24gPSBvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFuaW1hdGlvbiA6IHRydWU7XG4gICAgICB0aGlzLnJhbmdlLnNldFJhbmdlKHN0YXJ0LCBlbmQsIGFuaW1hdGlvbik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSB3aW5kb3cgc3VjaCB0aGF0IGdpdmVuIHRpbWUgaXMgY2VudGVyZWQgb24gc2NyZWVuLlxuICAgKiBAcGFyYW0ge0RhdGUgfCBOdW1iZXIgfCBTdHJpbmd9IHRpbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYW5pbWF0aW9uOiBib29sZWFuIHwge2R1cmF0aW9uOiBudW1iZXIsIGVhc2luZ0Z1bmN0aW9uOiBzdHJpbmd9YFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCB0aGUgcmFuZ2UgaXMgYW5pbWF0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhseSB0byB0aGUgbmV3IHdpbmRvdy4gQW4gb2JqZWN0IGNhbiBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkIHRvIHNwZWNpZnkgZHVyYXRpb24gYW5kIGVhc2luZyBmdW5jdGlvbi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGR1cmF0aW9uIGlzIDUwMCBtcywgYW5kIGRlZmF1bHQgZWFzaW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaXMgJ2Vhc2VJbk91dFF1YWQnLlxuICAgKi9cbiAgQ29yZS5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gKHRpbWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW50ZXJ2YWwgPSB0aGlzLnJhbmdlLmVuZCAtIHRoaXMucmFuZ2Uuc3RhcnQ7XG4gICAgdmFyIHQgPSB1dGlsLmNvbnZlcnQodGltZSwgJ0RhdGUnKS52YWx1ZU9mKCk7XG5cbiAgICB2YXIgc3RhcnQgPSB0IC0gaW50ZXJ2YWwgLyAyO1xuICAgIHZhciBlbmQgPSB0ICsgaW50ZXJ2YWwgLyAyO1xuICAgIHZhciBhbmltYXRpb24gPSBvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFuaW1hdGlvbiA6IHRydWU7XG5cbiAgICB0aGlzLnJhbmdlLnNldFJhbmdlKHN0YXJ0LCBlbmQsIGFuaW1hdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmlzaWJsZSB3aW5kb3dcbiAgICogQHJldHVybiB7e3N0YXJ0OiBEYXRlLCBlbmQ6IERhdGV9fSAgIFZpc2libGUgcmFuZ2VcbiAgICovXG4gIENvcmUucHJvdG90eXBlLmdldFdpbmRvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLnJhbmdlLmdldFJhbmdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBuZXcgRGF0ZShyYW5nZS5zdGFydCksXG4gICAgICBlbmQ6IG5ldyBEYXRlKHJhbmdlLmVuZClcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBab29tIGluIHRoZSB3aW5kb3cgc3VjaCB0aGF0IGdpdmVuIHRpbWUgaXMgY2VudGVyZWQgb24gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGVyY2VudGFnZSAtIG11c3QgYmUgYmV0d2VlbiBbMC4uMV1cbiAgICovXG4gIENvcmUucHJvdG90eXBlLnpvb21JbiA9IGZ1bmN0aW9uIChwZXJjZW50YWdlKSB7XG4gICAgaWYgKCFwZXJjZW50YWdlIHx8IHBlcmNlbnRhZ2UgPCAwIHx8IHBlcmNlbnRhZ2UgPiAxKSByZXR1cm47XG4gICAgdmFyIHJhbmdlID0gdGhpcy5nZXRXaW5kb3coKTtcbiAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydC52YWx1ZU9mKCk7XG4gICAgdmFyIGVuZCA9IHJhbmdlLmVuZC52YWx1ZU9mKCk7XG4gICAgdmFyIGludGVydmFsID0gZW5kIC0gc3RhcnQ7XG4gICAgdmFyIG5ld0ludGVydmFsID0gaW50ZXJ2YWwgLyAoMSArIHBlcmNlbnRhZ2UpO1xuICAgIHZhciBkaXN0YW5jZSA9IChpbnRlcnZhbCAtIG5ld0ludGVydmFsKSAvIDI7XG4gICAgdmFyIG5ld1N0YXJ0ID0gc3RhcnQgKyBkaXN0YW5jZTtcbiAgICB2YXIgbmV3RW5kID0gZW5kIC0gZGlzdGFuY2U7XG5cbiAgICB0aGlzLnNldFdpbmRvdyh7XG4gICAgICBzdGFydDogbmV3U3RhcnQsXG4gICAgICBlbmQ6IG5ld0VuZFxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBab29tIG91dCB0aGUgd2luZG93IHN1Y2ggdGhhdCBnaXZlbiB0aW1lIGlzIGNlbnRlcmVkIG9uIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBlcmNlbnRhZ2UgLSBtdXN0IGJlIGJldHdlZW4gWzAuLjFdXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS56b29tT3V0ID0gZnVuY3Rpb24gKHBlcmNlbnRhZ2UpIHtcbiAgICBpZiAoIXBlcmNlbnRhZ2UgfHwgcGVyY2VudGFnZSA8IDAgfHwgcGVyY2VudGFnZSA+IDEpIHJldHVybjtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFdpbmRvdygpO1xuICAgIHZhciBzdGFydCA9IHJhbmdlLnN0YXJ0LnZhbHVlT2YoKTtcbiAgICB2YXIgZW5kID0gcmFuZ2UuZW5kLnZhbHVlT2YoKTtcbiAgICB2YXIgaW50ZXJ2YWwgPSBlbmQgLSBzdGFydDtcbiAgICB2YXIgbmV3U3RhcnQgPSBzdGFydCAtIGludGVydmFsICogcGVyY2VudGFnZSAvIDI7XG4gICAgdmFyIG5ld0VuZCA9IGVuZCArIGludGVydmFsICogcGVyY2VudGFnZSAvIDI7XG5cbiAgICB0aGlzLnNldFdpbmRvdyh7XG4gICAgICBzdGFydDogbmV3U3RhcnQsXG4gICAgICBlbmQ6IG5ld0VuZFxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGb3JjZSBhIHJlZHJhdy4gQ2FuIGJlIG92ZXJyaWRkZW4gYnkgaW1wbGVtZW50YXRpb25zIG9mIENvcmVcbiAgICpcbiAgICogTm90ZTogdGhpcyBmdW5jdGlvbiB3aWxsIGJlIG92ZXJyaWRkZW4gb24gY29uc3RydWN0aW9uIHdpdGggYSB0cm90dGxlZCB2ZXJzaW9uXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVkcmF3KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZHJhdyBmb3IgaW50ZXJuYWwgdXNlLiBSZWRyYXdzIGFsbCBjb21wb25lbnRzLiBTZWUgYWxzbyB0aGUgcHVibGljXG4gICAqIG1ldGhvZCByZWRyYXcuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIENvcmUucHJvdG90eXBlLl9yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWRyYXdDb3VudCsrO1xuICAgIHZhciByZXNpemVkID0gZmFsc2U7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgZG9tID0gdGhpcy5kb207XG5cbiAgICBpZiAoIWRvbSB8fCAhZG9tLmNvbnRhaW5lciB8fCBkb20ucm9vdC5vZmZzZXRXaWR0aCA9PSAwKSByZXR1cm47IC8vIHdoZW4gZGVzdHJveWVkLCBvciBpbnZpc2libGVcblxuICAgIERhdGVVdGlsLnVwZGF0ZUhpZGRlbkRhdGVzKHRoaXMub3B0aW9ucy5tb21lbnQsIHRoaXMuYm9keSwgdGhpcy5vcHRpb25zLmhpZGRlbkRhdGVzKTtcblxuICAgIC8vIHVwZGF0ZSBjbGFzcyBuYW1lc1xuICAgIGlmIChvcHRpb25zLm9yaWVudGF0aW9uID09ICd0b3AnKSB7XG4gICAgICB1dGlsLmFkZENsYXNzTmFtZShkb20ucm9vdCwgJ3Zpcy10b3AnKTtcbiAgICAgIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKGRvbS5yb290LCAndmlzLWJvdHRvbScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZShkb20ucm9vdCwgJ3Zpcy10b3AnKTtcbiAgICAgIHV0aWwuYWRkQ2xhc3NOYW1lKGRvbS5yb290LCAndmlzLWJvdHRvbScpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSByb290IHdpZHRoIGFuZCBoZWlnaHQgb3B0aW9uc1xuICAgIGRvbS5yb290LnN0eWxlLm1heEhlaWdodCA9IHV0aWwub3B0aW9uLmFzU2l6ZShvcHRpb25zLm1heEhlaWdodCwgJycpO1xuICAgIGRvbS5yb290LnN0eWxlLm1pbkhlaWdodCA9IHV0aWwub3B0aW9uLmFzU2l6ZShvcHRpb25zLm1pbkhlaWdodCwgJycpO1xuICAgIGRvbS5yb290LnN0eWxlLndpZHRoID0gdXRpbC5vcHRpb24uYXNTaXplKG9wdGlvbnMud2lkdGgsICcnKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBib3JkZXIgd2lkdGhzXG4gICAgcHJvcHMuYm9yZGVyLmxlZnQgPSAoZG9tLmNlbnRlckNvbnRhaW5lci5vZmZzZXRXaWR0aCAtIGRvbS5jZW50ZXJDb250YWluZXIuY2xpZW50V2lkdGgpIC8gMjtcbiAgICBwcm9wcy5ib3JkZXIucmlnaHQgPSBwcm9wcy5ib3JkZXIubGVmdDtcbiAgICBwcm9wcy5ib3JkZXIudG9wID0gKGRvbS5jZW50ZXJDb250YWluZXIub2Zmc2V0SGVpZ2h0IC0gZG9tLmNlbnRlckNvbnRhaW5lci5jbGllbnRIZWlnaHQpIC8gMjtcbiAgICBwcm9wcy5ib3JkZXIuYm90dG9tID0gcHJvcHMuYm9yZGVyLnRvcDtcbiAgICB2YXIgYm9yZGVyUm9vdEhlaWdodCA9IGRvbS5yb290Lm9mZnNldEhlaWdodCAtIGRvbS5yb290LmNsaWVudEhlaWdodDtcbiAgICB2YXIgYm9yZGVyUm9vdFdpZHRoID0gZG9tLnJvb3Qub2Zmc2V0V2lkdGggLSBkb20ucm9vdC5jbGllbnRXaWR0aDtcblxuICAgIC8vIHdvcmthcm91bmQgZm9yIGEgYnVnIGluIElFOiB0aGUgY2xpZW50V2lkdGggb2YgYW4gZWxlbWVudCB3aXRoXG4gICAgLy8gYSBoZWlnaHQ6MHB4IGFuZCBvdmVyZmxvdzpoaWRkZW4gaXMgbm90IGNhbGN1bGF0ZWQgYW5kIGFsd2F5cyBoYXMgdmFsdWUgMFxuICAgIGlmIChkb20uY2VudGVyQ29udGFpbmVyLmNsaWVudEhlaWdodCA9PT0gMCkge1xuICAgICAgcHJvcHMuYm9yZGVyLmxlZnQgPSBwcm9wcy5ib3JkZXIudG9wO1xuICAgICAgcHJvcHMuYm9yZGVyLnJpZ2h0ID0gcHJvcHMuYm9yZGVyLmxlZnQ7XG4gICAgfVxuICAgIGlmIChkb20ucm9vdC5jbGllbnRIZWlnaHQgPT09IDApIHtcbiAgICAgIGJvcmRlclJvb3RXaWR0aCA9IGJvcmRlclJvb3RIZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBoZWlnaHRzLiBJZiBhbnkgb2YgdGhlIHNpZGUgcGFuZWxzIGlzIGVtcHR5LCB3ZSBzZXQgdGhlIGhlaWdodCB0b1xuICAgIC8vIG1pbnVzIHRoZSBib3JkZXIgd2lkdGgsIHN1Y2ggdGhhdCB0aGUgYm9yZGVyIHdpbGwgYmUgaW52aXNpYmxlXG4gICAgcHJvcHMuY2VudGVyLmhlaWdodCA9IGRvbS5jZW50ZXIub2Zmc2V0SGVpZ2h0O1xuICAgIHByb3BzLmxlZnQuaGVpZ2h0ID0gZG9tLmxlZnQub2Zmc2V0SGVpZ2h0O1xuICAgIHByb3BzLnJpZ2h0LmhlaWdodCA9IGRvbS5yaWdodC5vZmZzZXRIZWlnaHQ7XG4gICAgcHJvcHMudG9wLmhlaWdodCA9IGRvbS50b3AuY2xpZW50SGVpZ2h0IHx8IC1wcm9wcy5ib3JkZXIudG9wO1xuICAgIHByb3BzLmJvdHRvbS5oZWlnaHQgPSBkb20uYm90dG9tLmNsaWVudEhlaWdodCB8fCAtcHJvcHMuYm9yZGVyLmJvdHRvbTtcblxuICAgIC8vIFRPRE86IGNvbXBlbnNhdGUgYm9yZGVycyB3aGVuIGFueSBvZiB0aGUgcGFuZWxzIGlzIGVtcHR5LlxuXG4gICAgLy8gYXBwbHkgYXV0byBoZWlnaHRcbiAgICAvLyBUT0RPOiBvbmx5IGNhbGN1bGF0ZSBhdXRvSGVpZ2h0IHdoZW4gbmVlZGVkIChlbHNlIHdlIGNhdXNlIGFuIGV4dHJhIHJlZmxvdy9yZXBhaW50IG9mIHRoZSBET00pXG4gICAgdmFyIGNvbnRlbnRIZWlnaHQgPSBNYXRoLm1heChwcm9wcy5sZWZ0LmhlaWdodCwgcHJvcHMuY2VudGVyLmhlaWdodCwgcHJvcHMucmlnaHQuaGVpZ2h0KTtcbiAgICB2YXIgYXV0b0hlaWdodCA9IHByb3BzLnRvcC5oZWlnaHQgKyBjb250ZW50SGVpZ2h0ICsgcHJvcHMuYm90dG9tLmhlaWdodCArIGJvcmRlclJvb3RIZWlnaHQgKyBwcm9wcy5ib3JkZXIudG9wICsgcHJvcHMuYm9yZGVyLmJvdHRvbTtcbiAgICBkb20ucm9vdC5zdHlsZS5oZWlnaHQgPSB1dGlsLm9wdGlvbi5hc1NpemUob3B0aW9ucy5oZWlnaHQsIGF1dG9IZWlnaHQgKyAncHgnKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBoZWlnaHRzIG9mIHRoZSBjb250ZW50IHBhbmVsc1xuICAgIHByb3BzLnJvb3QuaGVpZ2h0ID0gZG9tLnJvb3Qub2Zmc2V0SGVpZ2h0O1xuICAgIHByb3BzLmJhY2tncm91bmQuaGVpZ2h0ID0gcHJvcHMucm9vdC5oZWlnaHQgLSBib3JkZXJSb290SGVpZ2h0O1xuICAgIHZhciBjb250YWluZXJIZWlnaHQgPSBwcm9wcy5yb290LmhlaWdodCAtIHByb3BzLnRvcC5oZWlnaHQgLSBwcm9wcy5ib3R0b20uaGVpZ2h0IC0gYm9yZGVyUm9vdEhlaWdodDtcbiAgICBwcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0O1xuICAgIHByb3BzLmxlZnRDb250YWluZXIuaGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0O1xuICAgIHByb3BzLnJpZ2h0Q29udGFpbmVyLmhlaWdodCA9IHByb3BzLmxlZnRDb250YWluZXIuaGVpZ2h0O1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSB3aWR0aHMgb2YgdGhlIHBhbmVsc1xuICAgIHByb3BzLnJvb3Qud2lkdGggPSBkb20ucm9vdC5vZmZzZXRXaWR0aDtcbiAgICBwcm9wcy5iYWNrZ3JvdW5kLndpZHRoID0gcHJvcHMucm9vdC53aWR0aCAtIGJvcmRlclJvb3RXaWR0aDtcblxuICAgIGlmICghdGhpcy5pbml0aWFsRHJhd0RvbmUpIHtcbiAgICAgIHByb3BzLnNjcm9sbGJhcldpZHRoID0gdXRpbC5nZXRTY3JvbGxCYXJXaWR0aCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMudmVydGljYWxTY3JvbGwpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgIHByb3BzLmxlZnQud2lkdGggPSBkb20ubGVmdENvbnRhaW5lci5jbGllbnRXaWR0aCB8fCAtcHJvcHMuYm9yZGVyLmxlZnQ7XG4gICAgICAgIHByb3BzLnJpZ2h0LndpZHRoID0gZG9tLnJpZ2h0Q29udGFpbmVyLmNsaWVudFdpZHRoICsgcHJvcHMuc2Nyb2xsYmFyV2lkdGggfHwgLXByb3BzLmJvcmRlci5yaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BzLmxlZnQud2lkdGggPSBkb20ubGVmdENvbnRhaW5lci5jbGllbnRXaWR0aCArIHByb3BzLnNjcm9sbGJhcldpZHRoIHx8IC1wcm9wcy5ib3JkZXIubGVmdDtcbiAgICAgICAgcHJvcHMucmlnaHQud2lkdGggPSBkb20ucmlnaHRDb250YWluZXIuY2xpZW50V2lkdGggfHwgLXByb3BzLmJvcmRlci5yaWdodDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcHMubGVmdC53aWR0aCA9IGRvbS5sZWZ0Q29udGFpbmVyLmNsaWVudFdpZHRoIHx8IC1wcm9wcy5ib3JkZXIubGVmdDtcbiAgICAgIHByb3BzLnJpZ2h0LndpZHRoID0gZG9tLnJpZ2h0Q29udGFpbmVyLmNsaWVudFdpZHRoIHx8IC1wcm9wcy5ib3JkZXIucmlnaHQ7XG4gICAgfVxuXG4gICAgcHJvcHMubGVmdENvbnRhaW5lci53aWR0aCA9IHByb3BzLmxlZnQud2lkdGg7XG4gICAgcHJvcHMucmlnaHRDb250YWluZXIud2lkdGggPSBwcm9wcy5yaWdodC53aWR0aDtcbiAgICB2YXIgY2VudGVyV2lkdGggPSBwcm9wcy5yb290LndpZHRoIC0gcHJvcHMubGVmdC53aWR0aCAtIHByb3BzLnJpZ2h0LndpZHRoIC0gYm9yZGVyUm9vdFdpZHRoO1xuICAgIHByb3BzLmNlbnRlci53aWR0aCA9IGNlbnRlcldpZHRoO1xuICAgIHByb3BzLmNlbnRlckNvbnRhaW5lci53aWR0aCA9IGNlbnRlcldpZHRoO1xuICAgIHByb3BzLnRvcC53aWR0aCA9IGNlbnRlcldpZHRoO1xuICAgIHByb3BzLmJvdHRvbS53aWR0aCA9IGNlbnRlcldpZHRoO1xuXG4gICAgLy8gcmVzaXplIHRoZSBwYW5lbHNcbiAgICBkb20uYmFja2dyb3VuZC5zdHlsZS5oZWlnaHQgPSBwcm9wcy5iYWNrZ3JvdW5kLmhlaWdodCArICdweCc7XG4gICAgZG9tLmJhY2tncm91bmRWZXJ0aWNhbC5zdHlsZS5oZWlnaHQgPSBwcm9wcy5iYWNrZ3JvdW5kLmhlaWdodCArICdweCc7XG4gICAgZG9tLmJhY2tncm91bmRIb3Jpem9udGFsLnN0eWxlLmhlaWdodCA9IHByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQgKyAncHgnO1xuICAgIGRvbS5jZW50ZXJDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gcHJvcHMuY2VudGVyQ29udGFpbmVyLmhlaWdodCArICdweCc7XG4gICAgZG9tLmxlZnRDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gcHJvcHMubGVmdENvbnRhaW5lci5oZWlnaHQgKyAncHgnO1xuICAgIGRvbS5yaWdodENvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBwcm9wcy5yaWdodENvbnRhaW5lci5oZWlnaHQgKyAncHgnO1xuXG4gICAgZG9tLmJhY2tncm91bmQuc3R5bGUud2lkdGggPSBwcm9wcy5iYWNrZ3JvdW5kLndpZHRoICsgJ3B4JztcbiAgICBkb20uYmFja2dyb3VuZFZlcnRpY2FsLnN0eWxlLndpZHRoID0gcHJvcHMuY2VudGVyQ29udGFpbmVyLndpZHRoICsgJ3B4JztcbiAgICBkb20uYmFja2dyb3VuZEhvcml6b250YWwuc3R5bGUud2lkdGggPSBwcm9wcy5iYWNrZ3JvdW5kLndpZHRoICsgJ3B4JztcbiAgICBkb20uY2VudGVyQ29udGFpbmVyLnN0eWxlLndpZHRoID0gcHJvcHMuY2VudGVyLndpZHRoICsgJ3B4JztcbiAgICBkb20udG9wLnN0eWxlLndpZHRoID0gcHJvcHMudG9wLndpZHRoICsgJ3B4JztcbiAgICBkb20uYm90dG9tLnN0eWxlLndpZHRoID0gcHJvcHMuYm90dG9tLndpZHRoICsgJ3B4JztcblxuICAgIC8vIHJlcG9zaXRpb24gdGhlIHBhbmVsc1xuICAgIGRvbS5iYWNrZ3JvdW5kLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgZG9tLmJhY2tncm91bmQuc3R5bGUudG9wID0gJzAnO1xuICAgIGRvbS5iYWNrZ3JvdW5kVmVydGljYWwuc3R5bGUubGVmdCA9IHByb3BzLmxlZnQud2lkdGggKyBwcm9wcy5ib3JkZXIubGVmdCArICdweCc7XG4gICAgZG9tLmJhY2tncm91bmRWZXJ0aWNhbC5zdHlsZS50b3AgPSAnMCc7XG4gICAgZG9tLmJhY2tncm91bmRIb3Jpem9udGFsLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgZG9tLmJhY2tncm91bmRIb3Jpem9udGFsLnN0eWxlLnRvcCA9IHByb3BzLnRvcC5oZWlnaHQgKyAncHgnO1xuICAgIGRvbS5jZW50ZXJDb250YWluZXIuc3R5bGUubGVmdCA9IHByb3BzLmxlZnQud2lkdGggKyAncHgnO1xuICAgIGRvbS5jZW50ZXJDb250YWluZXIuc3R5bGUudG9wID0gcHJvcHMudG9wLmhlaWdodCArICdweCc7XG4gICAgZG9tLmxlZnRDb250YWluZXIuc3R5bGUubGVmdCA9ICcwJztcbiAgICBkb20ubGVmdENvbnRhaW5lci5zdHlsZS50b3AgPSBwcm9wcy50b3AuaGVpZ2h0ICsgJ3B4JztcbiAgICBkb20ucmlnaHRDb250YWluZXIuc3R5bGUubGVmdCA9IHByb3BzLmxlZnQud2lkdGggKyBwcm9wcy5jZW50ZXIud2lkdGggKyAncHgnO1xuICAgIGRvbS5yaWdodENvbnRhaW5lci5zdHlsZS50b3AgPSBwcm9wcy50b3AuaGVpZ2h0ICsgJ3B4JztcbiAgICBkb20udG9wLnN0eWxlLmxlZnQgPSBwcm9wcy5sZWZ0LndpZHRoICsgJ3B4JztcbiAgICBkb20udG9wLnN0eWxlLnRvcCA9ICcwJztcbiAgICBkb20uYm90dG9tLnN0eWxlLmxlZnQgPSBwcm9wcy5sZWZ0LndpZHRoICsgJ3B4JztcbiAgICBkb20uYm90dG9tLnN0eWxlLnRvcCA9IHByb3BzLnRvcC5oZWlnaHQgKyBwcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0ICsgJ3B4JztcblxuICAgIC8vIHVwZGF0ZSB0aGUgc2Nyb2xsVG9wLCBmZWFzaWJsZSByYW5nZSBmb3IgdGhlIG9mZnNldCBjYW4gYmUgY2hhbmdlZFxuICAgIC8vIHdoZW4gdGhlIGhlaWdodCBvZiB0aGUgQ29yZSBvciBvZiB0aGUgY29udGVudHMgb2YgdGhlIGNlbnRlciBjaGFuZ2VkXG4gICAgdmFyIG9mZnNldCA9IHRoaXMuX3VwZGF0ZVNjcm9sbFRvcCgpO1xuXG4gICAgLy8gcmVwb3NpdGlvbiB0aGUgc2Nyb2xsYWJsZSBjb250ZW50c1xuICAgIGlmIChvcHRpb25zLm9yaWVudGF0aW9uLml0ZW0gIT0gJ3RvcCcpIHtcbiAgICAgIG9mZnNldCArPSBNYXRoLm1heCh0aGlzLnByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQgLSB0aGlzLnByb3BzLmNlbnRlci5oZWlnaHQgLSB0aGlzLnByb3BzLmJvcmRlci50b3AgLSB0aGlzLnByb3BzLmJvcmRlci5ib3R0b20sIDApO1xuICAgIH1cbiAgICBkb20uY2VudGVyLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgZG9tLmNlbnRlci5zdHlsZS50b3AgPSBvZmZzZXQgKyAncHgnO1xuICAgIGRvbS5sZWZ0LnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgZG9tLnJpZ2h0LnN0eWxlLmxlZnQgPSAnMCc7XG5cbiAgICAvLyBzaG93IHNoYWRvd3Mgd2hlbiB2ZXJ0aWNhbCBzY3JvbGxpbmcgaXMgYXZhaWxhYmxlXG4gICAgdmFyIHZpc2liaWxpdHlUb3AgPSB0aGlzLnByb3BzLnNjcm9sbFRvcCA9PSAwID8gJ2hpZGRlbicgOiAnJztcbiAgICB2YXIgdmlzaWJpbGl0eUJvdHRvbSA9IHRoaXMucHJvcHMuc2Nyb2xsVG9wID09IHRoaXMucHJvcHMuc2Nyb2xsVG9wTWluID8gJ2hpZGRlbicgOiAnJztcbiAgICBkb20uc2hhZG93VG9wLnN0eWxlLnZpc2liaWxpdHkgPSB2aXNpYmlsaXR5VG9wO1xuICAgIGRvbS5zaGFkb3dCb3R0b20uc3R5bGUudmlzaWJpbGl0eSA9IHZpc2liaWxpdHlCb3R0b207XG4gICAgZG9tLnNoYWRvd1RvcExlZnQuc3R5bGUudmlzaWJpbGl0eSA9IHZpc2liaWxpdHlUb3A7XG4gICAgZG9tLnNoYWRvd0JvdHRvbUxlZnQuc3R5bGUudmlzaWJpbGl0eSA9IHZpc2liaWxpdHlCb3R0b207XG4gICAgZG9tLnNoYWRvd1RvcFJpZ2h0LnN0eWxlLnZpc2liaWxpdHkgPSB2aXNpYmlsaXR5VG9wO1xuICAgIGRvbS5zaGFkb3dCb3R0b21SaWdodC5zdHlsZS52aXNpYmlsaXR5ID0gdmlzaWJpbGl0eUJvdHRvbTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMudmVydGljYWxTY3JvbGwpIHtcbiAgICAgIGRvbS5zaGFkb3dUb3BSaWdodC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgIGRvbS5zaGFkb3dCb3R0b21SaWdodC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgIGRvbS5zaGFkb3dUb3BMZWZ0LnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgZG9tLnNoYWRvd0JvdHRvbUxlZnQuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbS5sZWZ0LnN0eWxlLnRvcCA9IG9mZnNldCArICdweCc7XG4gICAgICBkb20ucmlnaHQuc3R5bGUudG9wID0gb2Zmc2V0ICsgJ3B4JztcbiAgICB9XG5cbiAgICAvLyBlbmFibGUvZGlzYWJsZSB2ZXJ0aWNhbCBwYW5uaW5nXG4gICAgdmFyIGNvbnRlbnRzT3ZlcmZsb3cgPSB0aGlzLnByb3BzLmNlbnRlci5oZWlnaHQgPiB0aGlzLnByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQ7XG4gICAgdGhpcy5oYW1tZXIuZ2V0KCdwYW4nKS5zZXQoe1xuICAgICAgZGlyZWN0aW9uOiBjb250ZW50c092ZXJmbG93ID8gSGFtbWVyLkRJUkVDVElPTl9BTEwgOiBIYW1tZXIuRElSRUNUSU9OX0hPUklaT05UQUxcbiAgICB9KTtcblxuICAgIC8vIHJlZHJhdyBhbGwgY29tcG9uZW50c1xuICAgIHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgIHJlc2l6ZWQgPSBjb21wb25lbnQucmVkcmF3KCkgfHwgcmVzaXplZDtcbiAgICB9KTtcbiAgICB2YXIgTUFYX1JFRFJBVyA9IDU7XG4gICAgaWYgKHJlc2l6ZWQpIHtcbiAgICAgIGlmICh0aGlzLnJlZHJhd0NvdW50IDwgTUFYX1JFRFJBVykge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfY2hhbmdlJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBpbmZpbml0ZSBsb29wIGluIHJlZHJhdz8nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWRyYXdDb3VudCA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0aWFsRHJhd0RvbmUgPSB0cnVlO1xuXG4gICAgLy9FbWl0IHB1YmxpYyAnY2hhbmdlZCcgZXZlbnQgZm9yIFVJIHVwZGF0ZXMsIHNlZSBpc3N1ZSAjMTU5MlxuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJjaGFuZ2VkXCIpO1xuICB9O1xuXG4gIC8vIFRPRE86IGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjEuMCwgcmVtb3ZlIHNvbWUgZGF5XG4gIENvcmUucHJvdG90eXBlLnJlcGFpbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiByZXBhaW50IGlzIGRlcHJlY2F0ZWQuIFVzZSByZWRyYXcgaW5zdGVhZC4nKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgY3VycmVudCB0aW1lLiBUaGlzIGNhbiBiZSB1c2VkIGZvciBleGFtcGxlIHRvIGVuc3VyZSB0aGF0IGEgY2xpZW50J3NcbiAgICogdGltZSBpcyBzeW5jaHJvbml6ZWQgd2l0aCBhIHNoYXJlZCBzZXJ2ZXIgdGltZS5cbiAgICogT25seSBhcHBsaWNhYmxlIHdoZW4gb3B0aW9uIGBzaG93Q3VycmVudFRpbWVgIGlzIHRydWUuXG4gICAqIEBwYXJhbSB7RGF0ZSB8IFN0cmluZyB8IE51bWJlcn0gdGltZSAgICAgQSBEYXRlLCB1bml4IHRpbWVzdGFtcCwgb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJU08gZGF0ZSBzdHJpbmcuXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5zZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRUaW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbiBzaG93Q3VycmVudFRpbWUgbXVzdCBiZSB0cnVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50VGltZS5zZXRDdXJyZW50VGltZSh0aW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHRpbWUuXG4gICAqIE9ubHkgYXBwbGljYWJsZSB3aGVuIG9wdGlvbiBgc2hvd0N1cnJlbnRUaW1lYCBpcyB0cnVlLlxuICAgKiBAcmV0dXJuIHtEYXRlfSBSZXR1cm5zIHRoZSBjdXJyZW50IHRpbWUuXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5nZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuY3VycmVudFRpbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9uIHNob3dDdXJyZW50VGltZSBtdXN0IGJlIHRydWUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jdXJyZW50VGltZS5nZXRDdXJyZW50VGltZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgcG9zaXRpb24gb24gc2NyZWVuIChwaXhlbHMpIHRvIGEgZGF0ZXRpbWVcbiAgICogQHBhcmFtIHtpbnR9ICAgICB4ICAgIFBvc2l0aW9uIG9uIHRoZSBzY3JlZW4gaW4gcGl4ZWxzXG4gICAqIEByZXR1cm4ge0RhdGV9ICAgdGltZSBUaGUgZGF0ZXRpbWUgdGhlIGNvcnJlc3BvbmRzIHdpdGggZ2l2ZW4gcG9zaXRpb24geFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICAvLyBUT0RPOiBtb3ZlIHRoaXMgZnVuY3Rpb24gdG8gUmFuZ2VcbiAgQ29yZS5wcm90b3R5cGUuX3RvVGltZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIERhdGVVdGlsLnRvVGltZSh0aGlzLCB4LCB0aGlzLnByb3BzLmNlbnRlci53aWR0aCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBwb3NpdGlvbiBvbiB0aGUgZ2xvYmFsIHNjcmVlbiAocGl4ZWxzKSB0byBhIGRhdGV0aW1lXG4gICAqIEBwYXJhbSB7aW50fSAgICAgeCAgICBQb3NpdGlvbiBvbiB0aGUgc2NyZWVuIGluIHBpeGVsc1xuICAgKiBAcmV0dXJuIHtEYXRlfSAgIHRpbWUgVGhlIGRhdGV0aW1lIHRoZSBjb3JyZXNwb25kcyB3aXRoIGdpdmVuIHBvc2l0aW9uIHhcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgLy8gVE9ETzogbW92ZSB0aGlzIGZ1bmN0aW9uIHRvIFJhbmdlXG4gIENvcmUucHJvdG90eXBlLl90b0dsb2JhbFRpbWUgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBEYXRlVXRpbC50b1RpbWUodGhpcywgeCwgdGhpcy5wcm9wcy5yb290LndpZHRoKTtcbiAgICAvL3ZhciBjb252ZXJzaW9uID0gdGhpcy5yYW5nZS5jb252ZXJzaW9uKHRoaXMucHJvcHMucm9vdC53aWR0aCk7XG4gICAgLy9yZXR1cm4gbmV3IERhdGUoeCAvIGNvbnZlcnNpb24uc2NhbGUgKyBjb252ZXJzaW9uLm9mZnNldCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBkYXRldGltZSAoRGF0ZSBvYmplY3QpIGludG8gYSBwb3NpdGlvbiBvbiB0aGUgc2NyZWVuXG4gICAqIEBwYXJhbSB7RGF0ZX0gICB0aW1lIEEgZGF0ZVxuICAgKiBAcmV0dXJuIHtpbnR9ICAgeCAgICBUaGUgcG9zaXRpb24gb24gdGhlIHNjcmVlbiBpbiBwaXhlbHMgd2hpY2ggY29ycmVzcG9uZHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgd2l0aCB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgLy8gVE9ETzogbW92ZSB0aGlzIGZ1bmN0aW9uIHRvIFJhbmdlXG4gIENvcmUucHJvdG90eXBlLl90b1NjcmVlbiA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgcmV0dXJuIERhdGVVdGlsLnRvU2NyZWVuKHRoaXMsIHRpbWUsIHRoaXMucHJvcHMuY2VudGVyLndpZHRoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBhIGRhdGV0aW1lIChEYXRlIG9iamVjdCkgaW50byBhIHBvc2l0aW9uIG9uIHRoZSByb290XG4gICAqIFRoaXMgaXMgdXNlZCB0byBnZXQgdGhlIHBpeGVsIGRlbnNpdHkgZXN0aW1hdGUgZm9yIHRoZSBzY3JlZW4sIG5vdCB0aGUgY2VudGVyIHBhbmVsXG4gICAqIEBwYXJhbSB7RGF0ZX0gICB0aW1lIEEgZGF0ZVxuICAgKiBAcmV0dXJuIHtpbnR9ICAgeCAgICBUaGUgcG9zaXRpb24gb24gcm9vdCBpbiBwaXhlbHMgd2hpY2ggY29ycmVzcG9uZHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgd2l0aCB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgLy8gVE9ETzogbW92ZSB0aGlzIGZ1bmN0aW9uIHRvIFJhbmdlXG4gIENvcmUucHJvdG90eXBlLl90b0dsb2JhbFNjcmVlbiA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgcmV0dXJuIERhdGVVdGlsLnRvU2NyZWVuKHRoaXMsIHRpbWUsIHRoaXMucHJvcHMucm9vdC53aWR0aCk7XG4gICAgLy92YXIgY29udmVyc2lvbiA9IHRoaXMucmFuZ2UuY29udmVyc2lvbih0aGlzLnByb3BzLnJvb3Qud2lkdGgpO1xuICAgIC8vcmV0dXJuICh0aW1lLnZhbHVlT2YoKSAtIGNvbnZlcnNpb24ub2Zmc2V0KSAqIGNvbnZlcnNpb24uc2NhbGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgd2F0Y2hpbmcgd2hlbiBvcHRpb24gYXV0b1Jlc2l6ZSBpcyB0cnVlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5faW5pdEF1dG9SZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUmVzaXplID09IHRydWUpIHtcbiAgICAgIHRoaXMuX3N0YXJ0QXV0b1Jlc2l6ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdG9wQXV0b1Jlc2l6ZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogV2F0Y2ggZm9yIGNoYW5nZXMgaW4gdGhlIHNpemUgb2YgdGhlIGNvbnRhaW5lci4gT24gcmVzaXplLCB0aGUgUGFuZWwgd2lsbFxuICAgKiBhdXRvbWF0aWNhbGx5IHJlZHJhdyBpdHNlbGYuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5fc3RhcnRBdXRvUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICB0aGlzLl9zdG9wQXV0b1Jlc2l6ZSgpO1xuXG4gICAgdGhpcy5fb25SZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobWUub3B0aW9ucy5hdXRvUmVzaXplICE9IHRydWUpIHtcbiAgICAgICAgLy8gc3RvcCB3YXRjaGluZyB3aGVuIHRoZSBvcHRpb24gYXV0b1Jlc2l6ZSBpcyBjaGFuZ2VkIHRvIGZhbHNlXG4gICAgICAgIG1lLl9zdG9wQXV0b1Jlc2l6ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChtZS5kb20ucm9vdCkge1xuICAgICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBmcmFtZSBpcyByZXNpemVkXG4gICAgICAgIC8vIE5vdGU6IHdlIGNvbXBhcmUgb2Zmc2V0V2lkdGggaGVyZSwgbm90IGNsaWVudFdpZHRoLiBGb3Igc29tZSByZWFzb24sXG4gICAgICAgIC8vIElFIGRvZXMgbm90IHJlc3RvcmUgdGhlIGNsaWVudFdpZHRoIGZyb20gMCB0byB0aGUgYWN0dWFsIHdpZHRoIGFmdGVyXG4gICAgICAgIC8vIGNoYW5naW5nIHRoZSB0aW1lbGluZSdzIGNvbnRhaW5lciBkaXNwbGF5IHN0eWxlIGZyb20gbm9uZSB0byB2aXNpYmxlXG4gICAgICAgIGlmIChtZS5kb20ucm9vdC5vZmZzZXRXaWR0aCAhPSBtZS5wcm9wcy5sYXN0V2lkdGggfHwgbWUuZG9tLnJvb3Qub2Zmc2V0SGVpZ2h0ICE9IG1lLnByb3BzLmxhc3RIZWlnaHQpIHtcbiAgICAgICAgICBtZS5wcm9wcy5sYXN0V2lkdGggPSBtZS5kb20ucm9vdC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICBtZS5wcm9wcy5sYXN0SGVpZ2h0ID0gbWUuZG9tLnJvb3Qub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgICAgbWUuYm9keS5lbWl0dGVyLmVtaXQoJ19jaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBhZGQgZXZlbnQgbGlzdGVuZXIgdG8gd2luZG93IHJlc2l6ZVxuICAgIHV0aWwuYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSk7XG5cbiAgICAvL1ByZXZlbnQgaW5pdGlhbCB1bm5lY2Vzc2FyeSByZWRyYXdcbiAgICBpZiAobWUuZG9tLnJvb3QpIHtcbiAgICAgIG1lLnByb3BzLmxhc3RXaWR0aCA9IG1lLmRvbS5yb290Lm9mZnNldFdpZHRoO1xuICAgICAgbWUucHJvcHMubGFzdEhlaWdodCA9IG1lLmRvbS5yb290Lm9mZnNldEhlaWdodDtcbiAgICB9XG5cbiAgICB0aGlzLndhdGNoVGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLl9vblJlc2l6ZSwgMTAwMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3Agd2F0Y2hpbmcgZm9yIGEgcmVzaXplIG9mIHRoZSBmcmFtZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIENvcmUucHJvdG90eXBlLl9zdG9wQXV0b1Jlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy53YXRjaFRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMud2F0Y2hUaW1lcik7XG4gICAgICB0aGlzLndhdGNoVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyIG9uIHdpbmRvdy5yZXNpemVcbiAgICBpZiAodGhpcy5fb25SZXNpemUpIHtcbiAgICAgIHV0aWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSk7XG4gICAgICB0aGlzLl9vblJlc2l6ZSA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydCBtb3ZpbmcgdGhlIHRpbWVsaW5lIHZlcnRpY2FsbHlcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIENvcmUucHJvdG90eXBlLl9vblRvdWNoID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy50b3VjaC5hbGxvd0RyYWdnaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnRvdWNoLmluaXRpYWxTY3JvbGxUb3AgPSB0aGlzLnByb3BzLnNjcm9sbFRvcDtcbiAgfTtcblxuICAvKipcbiAgICogU3RhcnQgbW92aW5nIHRoZSB0aW1lbGluZSB2ZXJ0aWNhbGx5XG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5fb25QaW5jaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMudG91Y2guYWxsb3dEcmFnZ2luZyA9IGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSB0aW1lbGluZSB2ZXJ0aWNhbGx5XG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudCkgcmV0dXJuO1xuICAgIC8vIHJlZnVzZSB0byBkcmFnIHdoZW4gd2Ugd2hlcmUgcGluY2hpbmcgdG8gcHJldmVudCB0aGUgdGltZWxpbmUgbWFrZSBhIGp1bXBcbiAgICAvLyB3aGVuIHJlbGVhc2luZyB0aGUgZmluZ2VycyBpbiBvcHBvc2l0ZSBvcmRlciBmcm9tIHRoZSB0b3VjaCBzY3JlZW5cbiAgICBpZiAoIXRoaXMudG91Y2guYWxsb3dEcmFnZ2luZykgcmV0dXJuO1xuXG4gICAgdmFyIGRlbHRhID0gZXZlbnQuZGVsdGFZO1xuXG4gICAgdmFyIG9sZFNjcm9sbFRvcCA9IHRoaXMuX2dldFNjcm9sbFRvcCgpO1xuICAgIHZhciBuZXdTY3JvbGxUb3AgPSB0aGlzLl9zZXRTY3JvbGxUb3AodGhpcy50b3VjaC5pbml0aWFsU2Nyb2xsVG9wICsgZGVsdGEpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy52ZXJ0aWNhbFNjcm9sbCkge1xuICAgICAgdGhpcy5kb20ubGVmdC5wYXJlbnROb2RlLnNjcm9sbFRvcCA9IC10aGlzLnByb3BzLnNjcm9sbFRvcDtcbiAgICAgIHRoaXMuZG9tLnJpZ2h0LnBhcmVudE5vZGUuc2Nyb2xsVG9wID0gLXRoaXMucHJvcHMuc2Nyb2xsVG9wO1xuICAgIH1cblxuICAgIGlmIChuZXdTY3JvbGxUb3AgIT0gb2xkU2Nyb2xsVG9wKSB7XG4gICAgICB0aGlzLmVtaXQoXCJ2ZXJ0aWNhbERyYWdcIik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBcHBseSBhIHNjcm9sbFRvcFxuICAgKiBAcGFyYW0ge051bWJlcn0gc2Nyb2xsVG9wXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHNjcm9sbFRvcCAgUmV0dXJucyB0aGUgYXBwbGllZCBzY3JvbGxUb3BcbiAgICogQHByaXZhdGVcbiAgICovXG4gIENvcmUucHJvdG90eXBlLl9zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAoc2Nyb2xsVG9wKSB7XG4gICAgdGhpcy5wcm9wcy5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgdGhpcy5fdXBkYXRlU2Nyb2xsVG9wKCk7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuc2Nyb2xsVG9wO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGN1cnJlbnQgc2Nyb2xsVG9wIHdoZW4gdGhlIGhlaWdodCBvZiAgdGhlIGNvbnRhaW5lcnMgaGFzIGJlZW4gY2hhbmdlZFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBzY3JvbGxUb3AgIFJldHVybnMgdGhlIGFwcGxpZWQgc2Nyb2xsVG9wXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5fdXBkYXRlU2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHJlY2FsY3VsYXRlIHRoZSBzY3JvbGxUb3BNaW5cbiAgICB2YXIgc2Nyb2xsVG9wTWluID0gTWF0aC5taW4odGhpcy5wcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0IC0gdGhpcy5wcm9wcy5jZW50ZXIuaGVpZ2h0LCAwKTsgLy8gaXMgbmVnYXRpdmUgb3IgemVyb1xuICAgIGlmIChzY3JvbGxUb3BNaW4gIT0gdGhpcy5wcm9wcy5zY3JvbGxUb3BNaW4pIHtcbiAgICAgIC8vIGluIGNhc2Ugb2YgYm90dG9tIG9yaWVudGF0aW9uLCBjaGFuZ2UgdGhlIHNjcm9sbFRvcCBzdWNoIHRoYXQgdGhlIGNvbnRlbnRzXG4gICAgICAvLyBkbyBub3QgbW92ZSByZWxhdGl2ZSB0byB0aGUgdGltZSBheGlzIGF0IHRoZSBib3R0b21cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbSAhPSAndG9wJykge1xuICAgICAgICB0aGlzLnByb3BzLnNjcm9sbFRvcCArPSBzY3JvbGxUb3BNaW4gLSB0aGlzLnByb3BzLnNjcm9sbFRvcE1pbjtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJvcHMuc2Nyb2xsVG9wTWluID0gc2Nyb2xsVG9wTWluO1xuICAgIH1cblxuICAgIC8vIGxpbWl0IHRoZSBzY3JvbGxUb3AgdG8gdGhlIGZlYXNpYmxlIHNjcm9sbCByYW5nZVxuICAgIGlmICh0aGlzLnByb3BzLnNjcm9sbFRvcCA+IDApIHRoaXMucHJvcHMuc2Nyb2xsVG9wID0gMDtcbiAgICBpZiAodGhpcy5wcm9wcy5zY3JvbGxUb3AgPCBzY3JvbGxUb3BNaW4pIHRoaXMucHJvcHMuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wTWluO1xuXG4gICAgcmV0dXJuIHRoaXMucHJvcHMuc2Nyb2xsVG9wO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc2Nyb2xsVG9wXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IHNjcm9sbFRvcFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ29yZS5wcm90b3R5cGUuX2dldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5zY3JvbGxUb3A7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvYWQgYSBjb25maWd1cmF0b3JcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ29yZS5wcm90b3R5cGUuX2NyZWF0ZUNvbmZpZ3VyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZva2UgYWJzdHJhY3QgbWV0aG9kIF9jcmVhdGVDb25maWd1cmF0b3InKTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IENvcmU7XG5cbi8qKiovIH0sXG4vKiAzNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuICB2YXIgSGFtbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIERhdGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuICB2YXIgRGF0YVZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbiAgdmFyIFRpbWVTdGVwID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG4gIHZhciBDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbiAgdmFyIEdyb3VwID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XG4gIHZhciBCYWNrZ3JvdW5kR3JvdXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcbiAgdmFyIEJveEl0ZW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcbiAgdmFyIFBvaW50SXRlbSA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xuICB2YXIgUmFuZ2VJdGVtID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XG4gIHZhciBCYWNrZ3JvdW5kSXRlbSA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xuXG4gIHZhciBVTkdST1VQRUQgPSAnX191bmdyb3VwZWRfXyc7IC8vIHJlc2VydmVkIGdyb3VwIGlkIGZvciB1bmdyb3VwZWQgaXRlbXNcbiAgdmFyIEJBQ0tHUk9VTkQgPSAnX19iYWNrZ3JvdW5kX18nOyAvLyByZXNlcnZlZCBncm91cCBpZCBmb3IgYmFja2dyb3VuZCBpdGVtcyB3aXRob3V0IGdyb3VwXG5cbiAgLyoqXG4gICAqIEFuIEl0ZW1TZXQgaG9sZHMgYSBzZXQgb2YgaXRlbXMgYW5kIHJhbmdlcyB3aGljaCBjYW4gYmUgZGlzcGxheWVkIGluIGFcbiAgICogcmFuZ2UuIFRoZSB3aWR0aCBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBwYXJlbnQgb2YgdGhlIEl0ZW1TZXQsIGFuZCB0aGUgaGVpZ2h0XG4gICAqIGlzIGRldGVybWluZWQgYnkgdGhlIHNpemUgb2YgdGhlIGl0ZW1zLlxuICAgKiBAcGFyYW0ge3tkb206IE9iamVjdCwgZG9tUHJvcHM6IE9iamVjdCwgZW1pdHRlcjogRW1pdHRlciwgcmFuZ2U6IFJhbmdlfX0gYm9keVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgU2VlIEl0ZW1TZXQuc2V0T3B0aW9ucyBmb3IgdGhlIGF2YWlsYWJsZSBvcHRpb25zLlxuICAgKiBAY29uc3RydWN0b3IgSXRlbVNldFxuICAgKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAgICovXG4gIGZ1bmN0aW9uIEl0ZW1TZXQoYm9keSwgb3B0aW9ucykge1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHR5cGU6IG51bGwsIC8vICdib3gnLCAncG9pbnQnLCAncmFuZ2UnLCAnYmFja2dyb3VuZCdcbiAgICAgIG9yaWVudGF0aW9uOiB7XG4gICAgICAgIGl0ZW06ICdib3R0b20nIC8vIGl0ZW0gb3JpZW50YXRpb246ICd0b3AnIG9yICdib3R0b20nXG4gICAgICB9LFxuICAgICAgYWxpZ246ICdhdXRvJywgLy8gYWxpZ25tZW50IG9mIGJveCBpdGVtc1xuICAgICAgc3RhY2s6IHRydWUsXG4gICAgICBncm91cE9yZGVyU3dhcDogZnVuY3Rpb24gZ3JvdXBPcmRlclN3YXAoZnJvbUdyb3VwLCB0b0dyb3VwLCBncm91cHMpIHtcbiAgICAgICAgdmFyIHRhcmdldE9yZGVyID0gdG9Hcm91cC5vcmRlcjtcbiAgICAgICAgdG9Hcm91cC5vcmRlciA9IGZyb21Hcm91cC5vcmRlcjtcbiAgICAgICAgZnJvbUdyb3VwLm9yZGVyID0gdGFyZ2V0T3JkZXI7XG4gICAgICB9LFxuICAgICAgZ3JvdXBPcmRlcjogJ29yZGVyJyxcblxuICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICAgIG11bHRpc2VsZWN0OiBmYWxzZSxcbiAgICAgIGl0ZW1zQWx3YXlzRHJhZ2dhYmxlOiBmYWxzZSxcblxuICAgICAgZWRpdGFibGU6IHtcbiAgICAgICAgdXBkYXRlVGltZTogZmFsc2UsXG4gICAgICAgIHVwZGF0ZUdyb3VwOiBmYWxzZSxcbiAgICAgICAgYWRkOiBmYWxzZSxcbiAgICAgICAgcmVtb3ZlOiBmYWxzZVxuICAgICAgfSxcblxuICAgICAgZ3JvdXBFZGl0YWJsZToge1xuICAgICAgICBvcmRlcjogZmFsc2UsXG4gICAgICAgIGFkZDogZmFsc2UsXG4gICAgICAgIHJlbW92ZTogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgIHNuYXA6IFRpbWVTdGVwLnNuYXAsXG5cbiAgICAgIG9uQWRkOiBmdW5jdGlvbiBvbkFkZChpdGVtLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhpdGVtKTtcbiAgICAgIH0sXG4gICAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soaXRlbSk7XG4gICAgICB9LFxuICAgICAgb25Nb3ZlOiBmdW5jdGlvbiBvbk1vdmUoaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soaXRlbSk7XG4gICAgICB9LFxuICAgICAgb25SZW1vdmU6IGZ1bmN0aW9uIG9uUmVtb3ZlKGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKGl0ZW0pO1xuICAgICAgfSxcbiAgICAgIG9uTW92aW5nOiBmdW5jdGlvbiBvbk1vdmluZyhpdGVtLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhpdGVtKTtcbiAgICAgIH0sXG4gICAgICBvbkFkZEdyb3VwOiBmdW5jdGlvbiBvbkFkZEdyb3VwKGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKGl0ZW0pO1xuICAgICAgfSxcbiAgICAgIG9uTW92ZUdyb3VwOiBmdW5jdGlvbiBvbk1vdmVHcm91cChpdGVtLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhpdGVtKTtcbiAgICAgIH0sXG4gICAgICBvblJlbW92ZUdyb3VwOiBmdW5jdGlvbiBvblJlbW92ZUdyb3VwKGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKGl0ZW0pO1xuICAgICAgfSxcblxuICAgICAgbWFyZ2luOiB7XG4gICAgICAgIGl0ZW06IHtcbiAgICAgICAgICBob3Jpem9udGFsOiAxMCxcbiAgICAgICAgICB2ZXJ0aWNhbDogMTBcbiAgICAgICAgfSxcbiAgICAgICAgYXhpczogMjBcbiAgICAgIH0sXG5cbiAgICAgIHRvb2x0aXBPbkl0ZW1VcGRhdGVUaW1lOiBmYWxzZVxuICAgIH07XG5cbiAgICAvLyBvcHRpb25zIGlzIHNoYXJlZCBieSB0aGlzIEl0ZW1TZXQgYW5kIGFsbCBpdHMgaXRlbXNcbiAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgdGhpcy5vcHRpb25zLnJ0bCA9IG9wdGlvbnMucnRsO1xuXG4gICAgLy8gb3B0aW9ucyBmb3IgZ2V0dGluZyBpdGVtcyBmcm9tIHRoZSBEYXRhU2V0IHdpdGggdGhlIGNvcnJlY3QgdHlwZVxuICAgIHRoaXMuaXRlbU9wdGlvbnMgPSB7XG4gICAgICB0eXBlOiB7IHN0YXJ0OiAnRGF0ZScsIGVuZDogJ0RhdGUnIH1cbiAgICB9O1xuXG4gICAgdGhpcy5jb252ZXJzaW9uID0ge1xuICAgICAgdG9TY3JlZW46IGJvZHkudXRpbC50b1NjcmVlbixcbiAgICAgIHRvVGltZTogYm9keS51dGlsLnRvVGltZVxuICAgIH07XG4gICAgdGhpcy5kb20gPSB7fTtcbiAgICB0aGlzLnByb3BzID0ge307XG4gICAgdGhpcy5oYW1tZXIgPSBudWxsO1xuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB0aGlzLml0ZW1zRGF0YSA9IG51bGw7IC8vIERhdGFTZXRcbiAgICB0aGlzLmdyb3Vwc0RhdGEgPSBudWxsOyAvLyBEYXRhU2V0XG5cbiAgICAvLyBsaXN0ZW5lcnMgZm9yIHRoZSBEYXRhU2V0IG9mIHRoZSBpdGVtc1xuICAgIHRoaXMuaXRlbUxpc3RlbmVycyA9IHtcbiAgICAgICdhZGQnOiBmdW5jdGlvbiBhZGQoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICAgICAgbWUuX29uQWRkKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9LFxuICAgICAgJ3VwZGF0ZSc6IGZ1bmN0aW9uIHVwZGF0ZShldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgICAgICBtZS5fb25VcGRhdGUocGFyYW1zLml0ZW1zKTtcbiAgICAgIH0sXG4gICAgICAncmVtb3ZlJzogZnVuY3Rpb24gcmVtb3ZlKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgICAgIG1lLl9vblJlbW92ZShwYXJhbXMuaXRlbXMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBsaXN0ZW5lcnMgZm9yIHRoZSBEYXRhU2V0IG9mIHRoZSBncm91cHNcbiAgICB0aGlzLmdyb3VwTGlzdGVuZXJzID0ge1xuICAgICAgJ2FkZCc6IGZ1bmN0aW9uIGFkZChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgICAgICBtZS5fb25BZGRHcm91cHMocGFyYW1zLml0ZW1zKTtcbiAgICAgIH0sXG4gICAgICAndXBkYXRlJzogZnVuY3Rpb24gdXBkYXRlKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgICAgIG1lLl9vblVwZGF0ZUdyb3VwcyhwYXJhbXMuaXRlbXMpO1xuICAgICAgfSxcbiAgICAgICdyZW1vdmUnOiBmdW5jdGlvbiByZW1vdmUoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICAgICAgbWUuX29uUmVtb3ZlR3JvdXBzKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuaXRlbXMgPSB7fTsgLy8gb2JqZWN0IHdpdGggYW4gSXRlbSBmb3IgZXZlcnkgZGF0YSBpdGVtXG4gICAgdGhpcy5ncm91cHMgPSB7fTsgLy8gR3JvdXAgb2JqZWN0IGZvciBldmVyeSBncm91cFxuICAgIHRoaXMuZ3JvdXBJZHMgPSBbXTtcblxuICAgIHRoaXMuc2VsZWN0aW9uID0gW107IC8vIGxpc3Qgd2l0aCB0aGUgaWRzIG9mIGFsbCBzZWxlY3RlZCBub2Rlc1xuICAgIHRoaXMuc3RhY2tEaXJ0eSA9IHRydWU7IC8vIGlmIHRydWUsIGFsbCBpdGVtcyB3aWxsIGJlIHJlc3RhY2tlZCBvbiBuZXh0IHJlZHJhd1xuXG4gICAgdGhpcy50b3VjaFBhcmFtcyA9IHt9OyAvLyBzdG9yZXMgcHJvcGVydGllcyB3aGlsZSBkcmFnZ2luZ1xuICAgIHRoaXMuZ3JvdXBUb3VjaFBhcmFtcyA9IHt9O1xuICAgIC8vIGNyZWF0ZSB0aGUgSFRNTCBET01cblxuICAgIHRoaXMuX2NyZWF0ZSgpO1xuXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgSXRlbVNldC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cbiAgLy8gYXZhaWxhYmxlIGl0ZW0gdHlwZXMgd2lsbCBiZSByZWdpc3RlcmVkIGhlcmVcbiAgSXRlbVNldC50eXBlcyA9IHtcbiAgICBiYWNrZ3JvdW5kOiBCYWNrZ3JvdW5kSXRlbSxcbiAgICBib3g6IEJveEl0ZW0sXG4gICAgcmFuZ2U6IFJhbmdlSXRlbSxcbiAgICBwb2ludDogUG9pbnRJdGVtXG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgSFRNTCBET00gZm9yIHRoZSBJdGVtU2V0XG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtaXRlbXNldCc7XG4gICAgZnJhbWVbJ3RpbWVsaW5lLWl0ZW1zZXQnXSA9IHRoaXM7XG4gICAgdGhpcy5kb20uZnJhbWUgPSBmcmFtZTtcblxuICAgIC8vIGNyZWF0ZSBiYWNrZ3JvdW5kIHBhbmVsXG4gICAgdmFyIGJhY2tncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBiYWNrZ3JvdW5kLmNsYXNzTmFtZSA9ICd2aXMtYmFja2dyb3VuZCc7XG4gICAgZnJhbWUuYXBwZW5kQ2hpbGQoYmFja2dyb3VuZCk7XG4gICAgdGhpcy5kb20uYmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG5cbiAgICAvLyBjcmVhdGUgZm9yZWdyb3VuZCBwYW5lbFxuICAgIHZhciBmb3JlZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZm9yZWdyb3VuZC5jbGFzc05hbWUgPSAndmlzLWZvcmVncm91bmQnO1xuICAgIGZyYW1lLmFwcGVuZENoaWxkKGZvcmVncm91bmQpO1xuICAgIHRoaXMuZG9tLmZvcmVncm91bmQgPSBmb3JlZ3JvdW5kO1xuXG4gICAgLy8gY3JlYXRlIGF4aXMgcGFuZWxcbiAgICB2YXIgYXhpcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGF4aXMuY2xhc3NOYW1lID0gJ3Zpcy1heGlzJztcbiAgICB0aGlzLmRvbS5heGlzID0gYXhpcztcblxuICAgIC8vIGNyZWF0ZSBsYWJlbHNldFxuICAgIHZhciBsYWJlbFNldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxhYmVsU2V0LmNsYXNzTmFtZSA9ICd2aXMtbGFiZWxzZXQnO1xuICAgIHRoaXMuZG9tLmxhYmVsU2V0ID0gbGFiZWxTZXQ7XG5cbiAgICAvLyBjcmVhdGUgdW5ncm91cGVkIEdyb3VwXG4gICAgdGhpcy5fdXBkYXRlVW5ncm91cGVkKCk7XG5cbiAgICAvLyBjcmVhdGUgYmFja2dyb3VuZCBHcm91cFxuICAgIHZhciBiYWNrZ3JvdW5kR3JvdXAgPSBuZXcgQmFja2dyb3VuZEdyb3VwKEJBQ0tHUk9VTkQsIG51bGwsIHRoaXMpO1xuICAgIGJhY2tncm91bmRHcm91cC5zaG93KCk7XG4gICAgdGhpcy5ncm91cHNbQkFDS0dST1VORF0gPSBiYWNrZ3JvdW5kR3JvdXA7XG5cbiAgICAvLyBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzXG4gICAgLy8gTm90ZTogd2UgYmluZCB0byB0aGUgY2VudGVyQ29udGFpbmVyIGZvciB0aGUgY2FzZSB3aGVyZSB0aGUgaGVpZ2h0XG4gICAgLy8gICAgICAgb2YgdGhlIGNlbnRlciBjb250YWluZXIgaXMgbGFyZ2VyIHRoYW4gb2YgdGhlIEl0ZW1TZXQsIHNvIHdlXG4gICAgLy8gICAgICAgY2FuIGNsaWNrIGluIHRoZSBlbXB0eSBhcmVhIHRvIGNyZWF0ZSBhIG5ldyBpdGVtIG9yIGRlc2VsZWN0IGFuIGl0ZW0uXG4gICAgdGhpcy5oYW1tZXIgPSBuZXcgSGFtbWVyKHRoaXMuYm9keS5kb20uY2VudGVyQ29udGFpbmVyKTtcblxuICAgIC8vIGRyYWcgaXRlbXMgd2hlbiBzZWxlY3RlZFxuICAgIHRoaXMuaGFtbWVyLm9uKCdoYW1tZXIuaW5wdXQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5pc0ZpcnN0KSB7XG4gICAgICAgIHRoaXMuX29uVG91Y2goZXZlbnQpO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5oYW1tZXIub24oJ3BhbnN0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5oYW1tZXIub24oJ3Bhbm1vdmUnLCB0aGlzLl9vbkRyYWcuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5oYW1tZXIub24oJ3BhbmVuZCcsIHRoaXMuX29uRHJhZ0VuZC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmhhbW1lci5nZXQoJ3BhbicpLnNldCh7IHRocmVzaG9sZDogNSwgZGlyZWN0aW9uOiBIYW1tZXIuRElSRUNUSU9OX0hPUklaT05UQUwgfSk7XG5cbiAgICAvLyBzaW5nbGUgc2VsZWN0IChvciB1bnNlbGVjdCkgd2hlbiB0YXBwaW5nIGFuIGl0ZW1cbiAgICB0aGlzLmhhbW1lci5vbigndGFwJywgdGhpcy5fb25TZWxlY3RJdGVtLmJpbmQodGhpcykpO1xuXG4gICAgLy8gbXVsdGkgc2VsZWN0IHdoZW4gaG9sZGluZyBtb3VzZS90b3VjaCwgb3Igb24gY3RybCtjbGlja1xuICAgIHRoaXMuaGFtbWVyLm9uKCdwcmVzcycsIHRoaXMuX29uTXVsdGlTZWxlY3RJdGVtLmJpbmQodGhpcykpO1xuXG4gICAgLy8gYWRkIGl0ZW0gb24gZG91YmxldGFwXG4gICAgdGhpcy5oYW1tZXIub24oJ2RvdWJsZXRhcCcsIHRoaXMuX29uQWRkSXRlbS5iaW5kKHRoaXMpKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICB0aGlzLmdyb3VwSGFtbWVyID0gbmV3IEhhbW1lcih0aGlzLmJvZHkuZG9tLnJpZ2h0Q29udGFpbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ncm91cEhhbW1lciA9IG5ldyBIYW1tZXIodGhpcy5ib2R5LmRvbS5sZWZ0Q29udGFpbmVyKTtcbiAgICB9XG5cbiAgICB0aGlzLmdyb3VwSGFtbWVyLm9uKCdwYW5zdGFydCcsIHRoaXMuX29uR3JvdXBEcmFnU3RhcnQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5ncm91cEhhbW1lci5vbigncGFubW92ZScsIHRoaXMuX29uR3JvdXBEcmFnLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZ3JvdXBIYW1tZXIub24oJ3BhbmVuZCcsIHRoaXMuX29uR3JvdXBEcmFnRW5kLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZ3JvdXBIYW1tZXIuZ2V0KCdwYW4nKS5zZXQoeyB0aHJlc2hvbGQ6IDUsIGRpcmVjdGlvbjogSGFtbWVyLkRJUkVDVElPTl9IT1JJWk9OVEFMIH0pO1xuXG4gICAgdGhpcy5ib2R5LmRvbS5jZW50ZXJDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5fb25Nb3VzZU92ZXIuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5ib2R5LmRvbS5jZW50ZXJDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLl9vbk1vdXNlT3V0LmJpbmQodGhpcykpO1xuXG4gICAgLy8gYXR0YWNoIHRvIHRoZSBET01cbiAgICB0aGlzLnNob3coKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IG9wdGlvbnMgZm9yIHRoZSBJdGVtU2V0LiBFeGlzdGluZyBvcHRpb25zIHdpbGwgYmUgZXh0ZW5kZWQvb3ZlcndyaXR0ZW4uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBhdmFpbGFibGU6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdHlwZSBmb3IgdGhlIGl0ZW1zLiBDaG9vc2UgZnJvbSAnYm94J1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkZWZhdWx0KSwgJ3BvaW50JywgJ3JhbmdlJywgb3IgJ2JhY2tncm91bmQnLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBkZWZhdWx0IHN0eWxlIGNhbiBiZSBvdmVyd3JpdHRlbiBieVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGl2aWR1YWwgaXRlbXMuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gYWxpZ25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbGlnbm1lbnQgZm9yIHRoZSBpdGVtcywgb25seSBhcHBsaWNhYmxlIGZvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJveEl0ZW0uIENob29zZSAnY2VudGVyJyAoZGVmYXVsdCksICdsZWZ0Jywgb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmlnaHQnLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IG9yaWVudGF0aW9uLml0ZW1cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcmllbnRhdGlvbiBvZiB0aGUgaXRlbSBzZXQuIENob29zZSAndG9wJyBvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdib3R0b20nIChkZWZhdWx0KS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7RnVuY3Rpb259IGdyb3VwT3JkZXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBIHNvcnRpbmcgZnVuY3Rpb24gZm9yIG9yZGVyaW5nIGdyb3Vwc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBzdGFja1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCBpdGVtcyB3aWxsIGJlIHN0YWNrZWQgb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3Agb2YgZWFjaCBvdGhlci5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBtYXJnaW4uYXhpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hcmdpbiBiZXR3ZWVuIHRoZSBheGlzIGFuZCB0aGUgaXRlbXMgaW4gcGl4ZWxzLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgaXMgMjAuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gbWFyZ2luLml0ZW0uaG9yaXpvbnRhbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhvcml6b250YWwgbWFyZ2luIGJldHdlZW4gaXRlbXMgaW4gcGl4ZWxzLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgaXMgMTAuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gbWFyZ2luLml0ZW0udmVydGljYWxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZXJ0aWNhbCBNYXJnaW4gYmV0d2VlbiBpdGVtcyBpbiBwaXhlbHMuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBpcyAxMC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBtYXJnaW4uaXRlbVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hcmdpbiBiZXR3ZWVuIGl0ZW1zIGluIHBpeGVscyBpbiBib3RoIGhvcml6b250YWxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgdmVydGljYWwgZGlyZWN0aW9uLiBEZWZhdWx0IGlzIDEwLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IG1hcmdpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldCBtYXJnaW4gZm9yIGJvdGggYXhpcyBhbmQgaXRlbXMgaW4gcGl4ZWxzLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBzZWxlY3RhYmxlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSAoZGVmYXVsdCksIGl0ZW1zIGNhbiBiZSBzZWxlY3RlZC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gbXVsdGlzZWxlY3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlLCBtdWx0aXBsZSBpdGVtcyBjYW4gYmUgc2VsZWN0ZWQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRmFsc2UgYnkgZGVmYXVsdC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gZWRpdGFibGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXQgYWxsIGVkaXRhYmxlIG9wdGlvbnMgdG8gdHJ1ZSBvciBmYWxzZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBlZGl0YWJsZS51cGRhdGVUaW1lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWxsb3cgZHJhZ2dpbmcgYW4gaXRlbSB0byBhbiBvdGhlciBtb21lbnQgaW4gdGltZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBlZGl0YWJsZS51cGRhdGVHcm91cFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFsbG93IGRyYWdnaW5nIGFuIGl0ZW0gdG8gYW4gb3RoZXIgZ3JvdXBcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gZWRpdGFibGUuYWRkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWxsb3cgY3JlYXRpbmcgbmV3IGl0ZW1zIG9uIGRvdWJsZSB0YXBcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gZWRpdGFibGUucmVtb3ZlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWxsb3cgcmVtb3ZpbmcgaXRlbXMgYnkgY2xpY2tpbmcgdGhlIGRlbGV0ZSBidXR0b25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3AgcmlnaHQgb2YgYSBzZWxlY3RlZCBpdGVtLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtGdW5jdGlvbihpdGVtOiBJdGVtLCBjYWxsYmFjazogRnVuY3Rpb24pfSBvbkFkZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCB3aGVuIGFuIGl0ZW0gaXMgYWJvdXQgdG8gYmUgYWRkZWQ6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiB0aGUgdXNlciBkb3VibGUgdGFwcyBhbiBlbXB0eSBzcGFjZSBpbiB0aGUgVGltZWxpbmUuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Z1bmN0aW9uKGl0ZW06IEl0ZW0sIGNhbGxiYWNrOiBGdW5jdGlvbil9IG9uVXBkYXRlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FsbGJhY2sgZnVuY3Rpb24gZmlyZWQgd2hlbiBhbiBpdGVtIGlzIGFib3V0IHRvIGJlIHVwZGF0ZWQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBmdW5jdGlvbiB0eXBpY2FsbHkgaGFzIHRvIHNob3cgYSBkaWFsb2cgd2hlcmUgdGhlIHVzZXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UgdGhlIGl0ZW0uIElmIG5vdCBpbXBsZW1lbnRlZCwgbm90aGluZyBoYXBwZW5zLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtGdW5jdGlvbihpdGVtOiBJdGVtLCBjYWxsYmFjazogRnVuY3Rpb24pfSBvbk1vdmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGaXJlZCB3aGVuIGFuIGl0ZW0gaGFzIGJlZW4gbW92ZWQuIElmIG5vdCBpbXBsZW1lbnRlZCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbW92ZSBhY3Rpb24gd2lsbCBiZSBhY2NlcHRlZC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7RnVuY3Rpb24oaXRlbTogSXRlbSwgY2FsbGJhY2s6IEZ1bmN0aW9uKX0gb25SZW1vdmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGaXJlZCB3aGVuIGFuIGl0ZW0gaXMgYWJvdXQgdG8gYmUgZGVsZXRlZC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBub3QgaW1wbGVtZW50ZWQsIHRoZSBpdGVtIHdpbGwgYmUgYWx3YXlzIHJlbW92ZWQuXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgLy8gY29weSBhbGwgb3B0aW9ucyB0aGF0IHdlIGtub3dcbiAgICAgIHZhciBmaWVsZHMgPSBbJ3R5cGUnLCAncnRsJywgJ2FsaWduJywgJ29yZGVyJywgJ3N0YWNrJywgJ3NlbGVjdGFibGUnLCAnbXVsdGlzZWxlY3QnLCAnaXRlbXNBbHdheXNEcmFnZ2FibGUnLCAnbXVsdGlzZWxlY3RQZXJHcm91cCcsICdncm91cE9yZGVyJywgJ2RhdGFBdHRyaWJ1dGVzJywgJ3RlbXBsYXRlJywgJ2dyb3VwVGVtcGxhdGUnLCAnaGlkZScsICdzbmFwJywgJ2dyb3VwT3JkZXJTd2FwJywgJ3Rvb2x0aXBPbkl0ZW1VcGRhdGVUaW1lJ107XG4gICAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgIGlmICgnb3JpZW50YXRpb24nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm9yaWVudGF0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtID0gb3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ3RvcCcgPyAndG9wJyA6ICdib3R0b20nO1xuICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2Yob3B0aW9ucy5vcmllbnRhdGlvbikgPT09ICdvYmplY3QnICYmICdpdGVtJyBpbiBvcHRpb25zLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLml0ZW0gPSBvcHRpb25zLm9yaWVudGF0aW9uLml0ZW07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCdtYXJnaW4nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1hcmdpbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMubWFyZ2luLmF4aXMgPSBvcHRpb25zLm1hcmdpbjtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMubWFyZ2luLml0ZW0uaG9yaXpvbnRhbCA9IG9wdGlvbnMubWFyZ2luO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5tYXJnaW4uaXRlbS52ZXJ0aWNhbCA9IG9wdGlvbnMubWFyZ2luO1xuICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2Yob3B0aW9ucy5tYXJnaW4pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKFsnYXhpcyddLCB0aGlzLm9wdGlvbnMubWFyZ2luLCBvcHRpb25zLm1hcmdpbik7XG4gICAgICAgICAgaWYgKCdpdGVtJyBpbiBvcHRpb25zLm1hcmdpbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1hcmdpbi5pdGVtID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMubWFyZ2luLml0ZW0uaG9yaXpvbnRhbCA9IG9wdGlvbnMubWFyZ2luLml0ZW07XG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5tYXJnaW4uaXRlbS52ZXJ0aWNhbCA9IG9wdGlvbnMubWFyZ2luLml0ZW07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2Yob3B0aW9ucy5tYXJnaW4uaXRlbSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKFsnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCddLCB0aGlzLm9wdGlvbnMubWFyZ2luLml0ZW0sIG9wdGlvbnMubWFyZ2luLml0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoJ2VkaXRhYmxlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lZGl0YWJsZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZVRpbWUgPSBvcHRpb25zLmVkaXRhYmxlO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVHcm91cCA9IG9wdGlvbnMuZWRpdGFibGU7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmVkaXRhYmxlLmFkZCA9IG9wdGlvbnMuZWRpdGFibGU7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmVkaXRhYmxlLnJlbW92ZSA9IG9wdGlvbnMuZWRpdGFibGU7XG4gICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihvcHRpb25zLmVkaXRhYmxlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChbJ3VwZGF0ZVRpbWUnLCAndXBkYXRlR3JvdXAnLCAnYWRkJywgJ3JlbW92ZSddLCB0aGlzLm9wdGlvbnMuZWRpdGFibGUsIG9wdGlvbnMuZWRpdGFibGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgnZ3JvdXBFZGl0YWJsZScgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZ3JvdXBFZGl0YWJsZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmdyb3VwRWRpdGFibGUub3JkZXIgPSBvcHRpb25zLmdyb3VwRWRpdGFibGU7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmdyb3VwRWRpdGFibGUuYWRkID0gb3B0aW9ucy5ncm91cEVkaXRhYmxlO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5ncm91cEVkaXRhYmxlLnJlbW92ZSA9IG9wdGlvbnMuZ3JvdXBFZGl0YWJsZTtcbiAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKG9wdGlvbnMuZ3JvdXBFZGl0YWJsZSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoWydvcmRlcicsICdhZGQnLCAncmVtb3ZlJ10sIHRoaXMub3B0aW9ucy5ncm91cEVkaXRhYmxlLCBvcHRpb25zLmdyb3VwRWRpdGFibGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uc1xuICAgICAgdmFyIGFkZENhbGxiYWNrID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGZuID0gb3B0aW9uc1tuYW1lXTtcbiAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgaWYgKCEoZm4gaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9uICcgKyBuYW1lICsgJyBtdXN0IGJlIGEgZnVuY3Rpb24gJyArIG5hbWUgKyAnKGl0ZW0sIGNhbGxiYWNrKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm9wdGlvbnNbbmFtZV0gPSBmbjtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgWydvbkFkZCcsICdvblVwZGF0ZScsICdvblJlbW92ZScsICdvbk1vdmUnLCAnb25Nb3ZpbmcnLCAnb25BZGRHcm91cCcsICdvbk1vdmVHcm91cCcsICdvblJlbW92ZUdyb3VwJ10uZm9yRWFjaChhZGRDYWxsYmFjayk7XG5cbiAgICAgIC8vIGZvcmNlIHRoZSBpdGVtU2V0IHRvIHJlZnJlc2g6IG9wdGlvbnMgbGlrZSBvcmllbnRhdGlvbiBhbmQgbWFyZ2lucyBtYXkgYmUgY2hhbmdlZFxuICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE1hcmsgdGhlIEl0ZW1TZXQgZGlydHkgc28gaXQgd2lsbCByZWZyZXNoIGV2ZXJ5dGhpbmcgd2l0aCBuZXh0IHJlZHJhdy5cbiAgICogT3B0aW9uYWxseSwgYWxsIGl0ZW1zIGNhbiBiZSBtYXJrZWQgYXMgZGlydHkgYW5kIGJlIHJlZnJlc2hlZC5cbiAgICogQHBhcmFtIHt7cmVmcmVzaEl0ZW1zOiBib29sZWFufX0gW29wdGlvbnNdXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5tYXJrRGlydHkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMuZ3JvdXBJZHMgPSBbXTtcbiAgICB0aGlzLnN0YWNrRGlydHkgPSB0cnVlO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWZyZXNoSXRlbXMpIHtcbiAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLml0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpdGVtLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGl0ZW0uZGlzcGxheWVkKSBpdGVtLnJlZHJhdygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBJdGVtU2V0XG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaGlkZSgpO1xuICAgIHRoaXMuc2V0SXRlbXMobnVsbCk7XG4gICAgdGhpcy5zZXRHcm91cHMobnVsbCk7XG5cbiAgICB0aGlzLmhhbW1lciA9IG51bGw7XG5cbiAgICB0aGlzLmJvZHkgPSBudWxsO1xuICAgIHRoaXMuY29udmVyc2lvbiA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIGNvbXBvbmVudCBmcm9tIHRoZSBET01cbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcmVtb3ZlIHRoZSBmcmFtZSBjb250YWluaW5nIHRoZSBpdGVtc1xuICAgIGlmICh0aGlzLmRvbS5mcmFtZS5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmRvbS5mcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmZyYW1lKTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgdGhlIGF4aXMgd2l0aCBkb3RzXG4gICAgaWYgKHRoaXMuZG9tLmF4aXMucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5kb20uYXhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmF4aXMpO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSB0aGUgbGFiZWxzZXQgY29udGFpbmluZyBhbGwgZ3JvdXAgbGFiZWxzXG4gICAgaWYgKHRoaXMuZG9tLmxhYmVsU2V0LnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZG9tLmxhYmVsU2V0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20ubGFiZWxTZXQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2hvdyB0aGUgY29tcG9uZW50IGluIHRoZSBET00gKHdoZW4gbm90IGFscmVhZHkgdmlzaWJsZSkuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGNoYW5nZWRcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gc2hvdyBmcmFtZSBjb250YWluaW5nIHRoZSBpdGVtc1xuICAgIGlmICghdGhpcy5kb20uZnJhbWUucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5ib2R5LmRvbS5jZW50ZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uZnJhbWUpO1xuICAgIH1cblxuICAgIC8vIHNob3cgYXhpcyB3aXRoIGRvdHNcbiAgICBpZiAoIXRoaXMuZG9tLmF4aXMucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5ib2R5LmRvbS5iYWNrZ3JvdW5kVmVydGljYWwuYXBwZW5kQ2hpbGQodGhpcy5kb20uYXhpcyk7XG4gICAgfVxuXG4gICAgLy8gc2hvdyBsYWJlbHNldCBjb250YWluaW5nIGxhYmVsc1xuICAgIGlmICghdGhpcy5kb20ubGFiZWxTZXQucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRvbS5yaWdodC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5sYWJlbFNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvZHkuZG9tLmxlZnQuYXBwZW5kQ2hpbGQodGhpcy5kb20ubGFiZWxTZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHNlbGVjdGVkIGl0ZW1zIGJ5IHRoZWlyIGlkLiBSZXBsYWNlcyB0aGUgY3VycmVudCBzZWxlY3Rpb25cbiAgICogVW5rbm93biBpZCdzIGFyZSBzaWxlbnRseSBpZ25vcmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdIHwgc3RyaW5nfSBbaWRzXSBBbiBhcnJheSB3aXRoIHplcm8gb3IgbW9yZSBpZCdzIG9mIHRoZSBpdGVtcyB0byBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCwgb3IgYSBzaW5nbGUgaXRlbSBpZC4gSWYgaWRzIGlzIHVuZGVmaW5lZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBhbiBlbXB0eSBhcnJheSwgYWxsIGl0ZW1zIHdpbGwgYmUgdW5zZWxlY3RlZC5cbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICB2YXIgaSwgaWksIGlkLCBpdGVtO1xuXG4gICAgaWYgKGlkcyA9PSB1bmRlZmluZWQpIGlkcyA9IFtdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpZHMpKSBpZHMgPSBbaWRzXTtcblxuICAgIC8vIHVuc2VsZWN0IGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtc1xuICAgIGZvciAoaSA9IDAsIGlpID0gdGhpcy5zZWxlY3Rpb24ubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgaWQgPSB0aGlzLnNlbGVjdGlvbltpXTtcbiAgICAgIGl0ZW0gPSB0aGlzLml0ZW1zW2lkXTtcbiAgICAgIGlmIChpdGVtKSBpdGVtLnVuc2VsZWN0KCk7XG4gICAgfVxuXG4gICAgLy8gc2VsZWN0IGl0ZW1zXG4gICAgdGhpcy5zZWxlY3Rpb24gPSBbXTtcbiAgICBmb3IgKGkgPSAwLCBpaSA9IGlkcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBpZCA9IGlkc1tpXTtcbiAgICAgIGl0ZW0gPSB0aGlzLml0ZW1zW2lkXTtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnB1c2goaWQpO1xuICAgICAgICBpdGVtLnNlbGVjdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBzZWxlY3RlZCBpdGVtcyBieSB0aGVpciBpZFxuICAgKiBAcmV0dXJuIHtBcnJheX0gaWRzICBUaGUgaWRzIG9mIHRoZSBzZWxlY3RlZCBpdGVtc1xuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi5jb25jYXQoW10pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGlkJ3Mgb2YgdGhlIGN1cnJlbnRseSB2aXNpYmxlIGl0ZW1zLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBpZHMgb2YgdGhlIHZpc2libGUgaXRlbXNcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLmdldFZpc2libGVJdGVtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLmJvZHkucmFuZ2UuZ2V0UmFuZ2UoKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICB2YXIgcmlnaHQgPSB0aGlzLmJvZHkudXRpbC50b1NjcmVlbihyYW5nZS5zdGFydCk7XG4gICAgICB2YXIgbGVmdCA9IHRoaXMuYm9keS51dGlsLnRvU2NyZWVuKHJhbmdlLmVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsZWZ0ID0gdGhpcy5ib2R5LnV0aWwudG9TY3JlZW4ocmFuZ2Uuc3RhcnQpO1xuICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5ib2R5LnV0aWwudG9TY3JlZW4ocmFuZ2UuZW5kKTtcbiAgICB9XG5cbiAgICB2YXIgaWRzID0gW107XG4gICAgZm9yICh2YXIgZ3JvdXBJZCBpbiB0aGlzLmdyb3Vwcykge1xuICAgICAgaWYgKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KGdyb3VwSWQpKSB7XG4gICAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXBzW2dyb3VwSWRdO1xuICAgICAgICB2YXIgcmF3VmlzaWJsZUl0ZW1zID0gZ3JvdXAudmlzaWJsZUl0ZW1zO1xuXG4gICAgICAgIC8vIGZpbHRlciB0aGUgXCJyYXdcIiBzZXQgd2l0aCB2aXNpYmxlSXRlbXMgaW50byBhIHNldCB3aGljaCBpcyByZWFsbHlcbiAgICAgICAgLy8gdmlzaWJsZSBieSBwaXhlbHNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdWaXNpYmxlSXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IHJhd1Zpc2libGVJdGVtc1tpXTtcbiAgICAgICAgICAvLyBUT0RPOiBhbHNvIGNoZWNrIHdoZXRoZXIgdmlzaWJsZSB2ZXJ0aWNhbGx5XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLnJpZ2h0IDwgbGVmdCAmJiBpdGVtLnJpZ2h0ICsgaXRlbS53aWR0aCA+IHJpZ2h0KSB7XG4gICAgICAgICAgICAgIGlkcy5wdXNoKGl0ZW0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5sZWZ0IDwgcmlnaHQgJiYgaXRlbS5sZWZ0ICsgaXRlbS53aWR0aCA+IGxlZnQpIHtcbiAgICAgICAgICAgICAgaWRzLnB1c2goaXRlbS5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGlkcztcbiAgfTtcblxuICAvKipcbiAgICogRGVzZWxlY3QgYSBzZWxlY3RlZCBpdGVtXG4gICAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBpZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX2Rlc2VsZWN0ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHNlbGVjdGlvbi5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBpZiAoc2VsZWN0aW9uW2ldID09IGlkKSB7XG4gICAgICAgIC8vIG5vbi1zdHJpY3QgY29tcGFyaXNvbiFcbiAgICAgICAgc2VsZWN0aW9uLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBhaW50IHRoZSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBjb21wb25lbnQgaXMgcmVzaXplZFxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtYXJnaW4gPSB0aGlzLm9wdGlvbnMubWFyZ2luLFxuICAgICAgICByYW5nZSA9IHRoaXMuYm9keS5yYW5nZSxcbiAgICAgICAgYXNTaXplID0gdXRpbC5vcHRpb24uYXNTaXplLFxuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBvcmllbnRhdGlvbiA9IG9wdGlvbnMub3JpZW50YXRpb24uaXRlbSxcbiAgICAgICAgcmVzaXplZCA9IGZhbHNlLFxuICAgICAgICBmcmFtZSA9IHRoaXMuZG9tLmZyYW1lO1xuXG4gICAgLy8gcmVjYWxjdWxhdGUgYWJzb2x1dGUgcG9zaXRpb24gKGJlZm9yZSByZWRyYXdpbmcgZ3JvdXBzKVxuICAgIHRoaXMucHJvcHMudG9wID0gdGhpcy5ib2R5LmRvbVByb3BzLnRvcC5oZWlnaHQgKyB0aGlzLmJvZHkuZG9tUHJvcHMuYm9yZGVyLnRvcDtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICB0aGlzLnByb3BzLnJpZ2h0ID0gdGhpcy5ib2R5LmRvbVByb3BzLnJpZ2h0LndpZHRoICsgdGhpcy5ib2R5LmRvbVByb3BzLmJvcmRlci5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcm9wcy5sZWZ0ID0gdGhpcy5ib2R5LmRvbVByb3BzLmxlZnQud2lkdGggKyB0aGlzLmJvZHkuZG9tUHJvcHMuYm9yZGVyLmxlZnQ7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGNsYXNzIG5hbWVcbiAgICBmcmFtZS5jbGFzc05hbWUgPSAndmlzLWl0ZW1zZXQnO1xuXG4gICAgLy8gcmVvcmRlciB0aGUgZ3JvdXBzIChpZiBuZWVkZWQpXG4gICAgcmVzaXplZCA9IHRoaXMuX29yZGVyR3JvdXBzKCkgfHwgcmVzaXplZDtcblxuICAgIC8vIGNoZWNrIHdoZXRoZXIgem9vbWVkIChpbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byByZS1zdGFjayBldmVyeXRoaW5nKVxuICAgIC8vIFRPRE86IHdvdWxkIGJlIG5pY2VyIHRvIGdldCB0aGlzIGFzIGEgdHJpZ2dlciBmcm9tIFJhbmdlXG4gICAgdmFyIHZpc2libGVJbnRlcnZhbCA9IHJhbmdlLmVuZCAtIHJhbmdlLnN0YXJ0O1xuICAgIHZhciB6b29tZWQgPSB2aXNpYmxlSW50ZXJ2YWwgIT0gdGhpcy5sYXN0VmlzaWJsZUludGVydmFsIHx8IHRoaXMucHJvcHMud2lkdGggIT0gdGhpcy5wcm9wcy5sYXN0V2lkdGg7XG4gICAgaWYgKHpvb21lZCkgdGhpcy5zdGFja0RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLmxhc3RWaXNpYmxlSW50ZXJ2YWwgPSB2aXNpYmxlSW50ZXJ2YWw7XG4gICAgdGhpcy5wcm9wcy5sYXN0V2lkdGggPSB0aGlzLnByb3BzLndpZHRoO1xuXG4gICAgdmFyIHJlc3RhY2sgPSB0aGlzLnN0YWNrRGlydHk7XG4gICAgdmFyIGZpcnN0R3JvdXAgPSB0aGlzLl9maXJzdEdyb3VwKCk7XG4gICAgdmFyIGZpcnN0TWFyZ2luID0ge1xuICAgICAgaXRlbTogbWFyZ2luLml0ZW0sXG4gICAgICBheGlzOiBtYXJnaW4uYXhpc1xuICAgIH07XG4gICAgdmFyIG5vbkZpcnN0TWFyZ2luID0ge1xuICAgICAgaXRlbTogbWFyZ2luLml0ZW0sXG4gICAgICBheGlzOiBtYXJnaW4uaXRlbS52ZXJ0aWNhbCAvIDJcbiAgICB9O1xuICAgIHZhciBoZWlnaHQgPSAwO1xuICAgIHZhciBtaW5IZWlnaHQgPSBtYXJnaW4uYXhpcyArIG1hcmdpbi5pdGVtLnZlcnRpY2FsO1xuXG4gICAgLy8gcmVkcmF3IHRoZSBiYWNrZ3JvdW5kIGdyb3VwXG4gICAgdGhpcy5ncm91cHNbQkFDS0dST1VORF0ucmVkcmF3KHJhbmdlLCBub25GaXJzdE1hcmdpbiwgcmVzdGFjayk7XG5cbiAgICAvLyByZWRyYXcgYWxsIHJlZ3VsYXIgZ3JvdXBzXG4gICAgdXRpbC5mb3JFYWNoKHRoaXMuZ3JvdXBzLCBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgIHZhciBncm91cE1hcmdpbiA9IGdyb3VwID09IGZpcnN0R3JvdXAgPyBmaXJzdE1hcmdpbiA6IG5vbkZpcnN0TWFyZ2luO1xuICAgICAgdmFyIGdyb3VwUmVzaXplZCA9IGdyb3VwLnJlZHJhdyhyYW5nZSwgZ3JvdXBNYXJnaW4sIHJlc3RhY2spO1xuICAgICAgcmVzaXplZCA9IGdyb3VwUmVzaXplZCB8fCByZXNpemVkO1xuICAgICAgaGVpZ2h0ICs9IGdyb3VwLmhlaWdodDtcbiAgICB9KTtcbiAgICBoZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIG1pbkhlaWdodCk7XG4gICAgdGhpcy5zdGFja0RpcnR5ID0gZmFsc2U7XG5cbiAgICAvLyB1cGRhdGUgZnJhbWUgaGVpZ2h0XG4gICAgZnJhbWUuc3R5bGUuaGVpZ2h0ID0gYXNTaXplKGhlaWdodCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgYWN0dWFsIHNpemVcbiAgICB0aGlzLnByb3BzLndpZHRoID0gZnJhbWUub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5wcm9wcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAvLyByZXBvc2l0aW9uIGF4aXNcbiAgICB0aGlzLmRvbS5heGlzLnN0eWxlLnRvcCA9IGFzU2l6ZShvcmllbnRhdGlvbiA9PSAndG9wJyA/IHRoaXMuYm9keS5kb21Qcm9wcy50b3AuaGVpZ2h0ICsgdGhpcy5ib2R5LmRvbVByb3BzLmJvcmRlci50b3AgOiB0aGlzLmJvZHkuZG9tUHJvcHMudG9wLmhlaWdodCArIHRoaXMuYm9keS5kb21Qcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0KTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgdGhpcy5kb20uYXhpcy5zdHlsZS5yaWdodCA9ICcwJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb20uYXhpcy5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHRoaXMgY29tcG9uZW50IGlzIHJlc2l6ZWRcbiAgICByZXNpemVkID0gdGhpcy5faXNSZXNpemVkKCkgfHwgcmVzaXplZDtcblxuICAgIHJldHVybiByZXNpemVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpcnN0IGdyb3VwLCBhbGlnbmVkIHdpdGggdGhlIGF4aXNcbiAgICogQHJldHVybiB7R3JvdXAgfCBudWxsfSBmaXJzdEdyb3VwXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fZmlyc3RHcm91cCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmlyc3RHcm91cEluZGV4ID0gdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLml0ZW0gPT0gJ3RvcCcgPyAwIDogdGhpcy5ncm91cElkcy5sZW5ndGggLSAxO1xuICAgIHZhciBmaXJzdEdyb3VwSWQgPSB0aGlzLmdyb3VwSWRzW2ZpcnN0R3JvdXBJbmRleF07XG4gICAgdmFyIGZpcnN0R3JvdXAgPSB0aGlzLmdyb3Vwc1tmaXJzdEdyb3VwSWRdIHx8IHRoaXMuZ3JvdXBzW1VOR1JPVVBFRF07XG5cbiAgICByZXR1cm4gZmlyc3RHcm91cCB8fCBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgb3IgZGVsZXRlIHRoZSBncm91cCBob2xkaW5nIGFsbCB1bmdyb3VwZWQgaXRlbXMuIFRoaXMgZ3JvdXAgaXMgdXNlZCB3aGVuXG4gICAqIHRoZXJlIGFyZSBubyBncm91cHMgc3BlY2lmaWVkLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fdXBkYXRlVW5ncm91cGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB1bmdyb3VwZWQgPSB0aGlzLmdyb3Vwc1tVTkdST1VQRURdO1xuICAgIHZhciBiYWNrZ3JvdW5kID0gdGhpcy5ncm91cHNbQkFDS0dST1VORF07XG4gICAgdmFyIGl0ZW0sIGl0ZW1JZDtcblxuICAgIGlmICh0aGlzLmdyb3Vwc0RhdGEpIHtcbiAgICAgIC8vIHJlbW92ZSB0aGUgZ3JvdXAgaG9sZGluZyBhbGwgdW5ncm91cGVkIGl0ZW1zXG4gICAgICBpZiAodW5ncm91cGVkKSB7XG4gICAgICAgIHVuZ3JvdXBlZC5oaWRlKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmdyb3Vwc1tVTkdST1VQRURdO1xuXG4gICAgICAgIGZvciAoaXRlbUlkIGluIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5pdGVtcy5oYXNPd25Qcm9wZXJ0eShpdGVtSWQpKSB7XG4gICAgICAgICAgICBpdGVtID0gdGhpcy5pdGVtc1tpdGVtSWRdO1xuICAgICAgICAgICAgaXRlbS5wYXJlbnQgJiYgaXRlbS5wYXJlbnQucmVtb3ZlKGl0ZW0pO1xuICAgICAgICAgICAgdmFyIGdyb3VwSWQgPSB0aGlzLl9nZXRHcm91cElkKGl0ZW0uZGF0YSk7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cElkXTtcbiAgICAgICAgICAgIGdyb3VwICYmIGdyb3VwLmFkZChpdGVtKSB8fCBpdGVtLmhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY3JlYXRlIGEgZ3JvdXAgaG9sZGluZyBhbGwgKHVuZmlsdGVyZWQpIGl0ZW1zXG4gICAgICBpZiAoIXVuZ3JvdXBlZCkge1xuICAgICAgICB2YXIgaWQgPSBudWxsO1xuICAgICAgICB2YXIgZGF0YSA9IG51bGw7XG4gICAgICAgIHVuZ3JvdXBlZCA9IG5ldyBHcm91cChpZCwgZGF0YSwgdGhpcyk7XG4gICAgICAgIHRoaXMuZ3JvdXBzW1VOR1JPVVBFRF0gPSB1bmdyb3VwZWQ7XG5cbiAgICAgICAgZm9yIChpdGVtSWQgaW4gdGhpcy5pdGVtcykge1xuICAgICAgICAgIGlmICh0aGlzLml0ZW1zLmhhc093blByb3BlcnR5KGl0ZW1JZCkpIHtcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLml0ZW1zW2l0ZW1JZF07XG4gICAgICAgICAgICB1bmdyb3VwZWQuYWRkKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHVuZ3JvdXBlZC5zaG93KCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVsZW1lbnQgZm9yIHRoZSBsYWJlbHNldFxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gbGFiZWxTZXRcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLmdldExhYmVsU2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmRvbS5sYWJlbFNldDtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGl0ZW1zXG4gICAqIEBwYXJhbSB7dmlzLkRhdGFTZXQgfCBudWxsfSBpdGVtc1xuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuc2V0SXRlbXMgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICBpZHMsXG4gICAgICAgIG9sZEl0ZW1zRGF0YSA9IHRoaXMuaXRlbXNEYXRhO1xuXG4gICAgLy8gcmVwbGFjZSB0aGUgZGF0YXNldFxuICAgIGlmICghaXRlbXMpIHtcbiAgICAgIHRoaXMuaXRlbXNEYXRhID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGl0ZW1zIGluc3RhbmNlb2YgRGF0YVNldCB8fCBpdGVtcyBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgICB0aGlzLml0ZW1zRGF0YSA9IGl0ZW1zO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEYXRhIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRGF0YVNldCBvciBEYXRhVmlldycpO1xuICAgIH1cblxuICAgIGlmIChvbGRJdGVtc0RhdGEpIHtcbiAgICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gb2xkIGRhdGFzZXRcbiAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLml0ZW1MaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgb2xkSXRlbXNEYXRhLm9mZihldmVudCwgY2FsbGJhY2spO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHJlbW92ZSBhbGwgZHJhd24gaXRlbXNcbiAgICAgIGlkcyA9IG9sZEl0ZW1zRGF0YS5nZXRJZHMoKTtcbiAgICAgIHRoaXMuX29uUmVtb3ZlKGlkcyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXRlbXNEYXRhKSB7XG4gICAgICAvLyBzdWJzY3JpYmUgdG8gbmV3IGRhdGFzZXRcbiAgICAgIHZhciBpZCA9IHRoaXMuaWQ7XG4gICAgICB1dGlsLmZvckVhY2godGhpcy5pdGVtTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgIG1lLml0ZW1zRGF0YS5vbihldmVudCwgY2FsbGJhY2ssIGlkKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBhZGQgYWxsIG5ldyBpdGVtc1xuICAgICAgaWRzID0gdGhpcy5pdGVtc0RhdGEuZ2V0SWRzKCk7XG4gICAgICB0aGlzLl9vbkFkZChpZHMpO1xuXG4gICAgICAvLyB1cGRhdGUgdGhlIGdyb3VwIGhvbGRpbmcgYWxsIHVuZ3JvdXBlZCBpdGVtc1xuICAgICAgdGhpcy5fdXBkYXRlVW5ncm91cGVkKCk7XG4gICAgfVxuXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2NoYW5nZScsIHsgcXVldWU6IHRydWUgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBpdGVtc1xuICAgKiBAcmV0dXJucyB7dmlzLkRhdGFTZXQgfCBudWxsfVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuZ2V0SXRlbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXNEYXRhO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgZ3JvdXBzXG4gICAqIEBwYXJhbSB7dmlzLkRhdGFTZXR9IGdyb3Vwc1xuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuc2V0R3JvdXBzID0gZnVuY3Rpb24gKGdyb3Vwcykge1xuICAgIHZhciBtZSA9IHRoaXMsXG4gICAgICAgIGlkcztcblxuICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gY3VycmVudCBkYXRhc2V0XG4gICAgaWYgKHRoaXMuZ3JvdXBzRGF0YSkge1xuICAgICAgdXRpbC5mb3JFYWNoKHRoaXMuZ3JvdXBMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgbWUuZ3JvdXBzRGF0YS5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyByZW1vdmUgYWxsIGRyYXduIGdyb3Vwc1xuICAgICAgaWRzID0gdGhpcy5ncm91cHNEYXRhLmdldElkcygpO1xuICAgICAgdGhpcy5ncm91cHNEYXRhID0gbnVsbDtcbiAgICAgIHRoaXMuX29uUmVtb3ZlR3JvdXBzKGlkcyk7IC8vIG5vdGU6IHRoaXMgd2lsbCBjYXVzZSBhIHJlZHJhd1xuICAgIH1cblxuICAgIC8vIHJlcGxhY2UgdGhlIGRhdGFzZXRcbiAgICBpZiAoIWdyb3Vwcykge1xuICAgICAgdGhpcy5ncm91cHNEYXRhID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGdyb3VwcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgZ3JvdXBzIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICAgIHRoaXMuZ3JvdXBzRGF0YSA9IGdyb3VwcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRGF0YSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIERhdGFTZXQgb3IgRGF0YVZpZXcnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ncm91cHNEYXRhKSB7XG4gICAgICAvLyBzdWJzY3JpYmUgdG8gbmV3IGRhdGFzZXRcbiAgICAgIHZhciBpZCA9IHRoaXMuaWQ7XG4gICAgICB1dGlsLmZvckVhY2godGhpcy5ncm91cExpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICBtZS5ncm91cHNEYXRhLm9uKGV2ZW50LCBjYWxsYmFjaywgaWQpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGRyYXcgYWxsIG1zXG4gICAgICBpZHMgPSB0aGlzLmdyb3Vwc0RhdGEuZ2V0SWRzKCk7XG4gICAgICB0aGlzLl9vbkFkZEdyb3VwcyhpZHMpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSB0aGUgZ3JvdXAgaG9sZGluZyBhbGwgdW5ncm91cGVkIGl0ZW1zXG4gICAgdGhpcy5fdXBkYXRlVW5ncm91cGVkKCk7XG5cbiAgICAvLyB1cGRhdGUgdGhlIG9yZGVyIG9mIGFsbCBpdGVtcyBpbiBlYWNoIGdyb3VwXG4gICAgdGhpcy5fb3JkZXIoKTtcblxuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19jaGFuZ2UnLCB7IHF1ZXVlOiB0cnVlIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgZ3JvdXBzXG4gICAqIEByZXR1cm5zIHt2aXMuRGF0YVNldCB8IG51bGx9IGdyb3Vwc1xuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuZ2V0R3JvdXBzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdyb3Vwc0RhdGE7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBpdGVtIGJ5IGl0cyBpZFxuICAgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gaWRcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLnJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IHRoaXMuaXRlbXNEYXRhLmdldChpZCksXG4gICAgICAgIGRhdGFzZXQgPSB0aGlzLml0ZW1zRGF0YS5nZXREYXRhU2V0KCk7XG5cbiAgICBpZiAoaXRlbSkge1xuICAgICAgLy8gY29uZmlybSBkZWxldGlvblxuICAgICAgdGhpcy5vcHRpb25zLm9uUmVtb3ZlKGl0ZW0sIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIGJ5IGlkIGhlcmUsIGl0IGlzIHBvc3NpYmxlIHRoYXQgYW4gaXRlbSBoYXMgbm8gaWQgZGVmaW5lZFxuICAgICAgICAgIC8vIGl0c2VsZiwgc28gYmV0dGVyIG5vdCBkZWxldGUgYnkgdGhlIGl0ZW0gaXRzZWxmXG4gICAgICAgICAgZGF0YXNldC5yZW1vdmUoaWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGltZSBvZiBhbiBpdGVtIGJhc2VkIG9uIGl0J3MgZGF0YSBhbmQgb3B0aW9ucy50eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtRGF0YVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0eXBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fZ2V0VHlwZSA9IGZ1bmN0aW9uIChpdGVtRGF0YSkge1xuICAgIHJldHVybiBpdGVtRGF0YS50eXBlIHx8IHRoaXMub3B0aW9ucy50eXBlIHx8IChpdGVtRGF0YS5lbmQgPyAncmFuZ2UnIDogJ2JveCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGdyb3VwIGlkIGZvciBhbiBpdGVtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtRGF0YVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBncm91cElkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fZ2V0R3JvdXBJZCA9IGZ1bmN0aW9uIChpdGVtRGF0YSkge1xuICAgIHZhciB0eXBlID0gdGhpcy5fZ2V0VHlwZShpdGVtRGF0YSk7XG4gICAgaWYgKHR5cGUgPT0gJ2JhY2tncm91bmQnICYmIGl0ZW1EYXRhLmdyb3VwID09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIEJBQ0tHUk9VTkQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdyb3Vwc0RhdGEgPyBpdGVtRGF0YS5ncm91cCA6IFVOR1JPVVBFRDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB1cGRhdGVkIGl0ZW1zXG4gICAqIEBwYXJhbSB7TnVtYmVyW119IGlkc1xuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fb25VcGRhdGUgPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgdmFyIG1lID0gdGhpcztcblxuICAgIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgdmFyIGl0ZW1EYXRhID0gbWUuaXRlbXNEYXRhLmdldChpZCwgbWUuaXRlbU9wdGlvbnMpO1xuICAgICAgdmFyIGl0ZW0gPSBtZS5pdGVtc1tpZF07XG4gICAgICB2YXIgdHlwZSA9IGl0ZW1EYXRhID8gbWUuX2dldFR5cGUoaXRlbURhdGEpIDogbnVsbDtcblxuICAgICAgdmFyIGNvbnN0cnVjdG9yID0gSXRlbVNldC50eXBlc1t0eXBlXTtcbiAgICAgIHZhciBzZWxlY3RlZDtcblxuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgLy8gdXBkYXRlIGl0ZW1cbiAgICAgICAgaWYgKCFjb25zdHJ1Y3RvciB8fCAhKGl0ZW0gaW5zdGFuY2VvZiBjb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAvLyBpdGVtIHR5cGUgaGFzIGNoYW5nZWQsIGRlbGV0ZSB0aGUgaXRlbSBhbmQgcmVjcmVhdGUgaXRcbiAgICAgICAgICBzZWxlY3RlZCA9IGl0ZW0uc2VsZWN0ZWQ7IC8vIHByZXNlcnZlIHNlbGVjdGlvbiBvZiB0aGlzIGl0ZW1cbiAgICAgICAgICBtZS5fcmVtb3ZlSXRlbShpdGVtKTtcbiAgICAgICAgICBpdGVtID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZS5fdXBkYXRlSXRlbShpdGVtLCBpdGVtRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFpdGVtICYmIGl0ZW1EYXRhKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBpdGVtXG4gICAgICAgIGlmIChjb25zdHJ1Y3Rvcikge1xuICAgICAgICAgIGl0ZW0gPSBuZXcgY29uc3RydWN0b3IoaXRlbURhdGEsIG1lLmNvbnZlcnNpb24sIG1lLm9wdGlvbnMpO1xuICAgICAgICAgIGl0ZW0uaWQgPSBpZDsgLy8gVE9ETzogbm90IHNvIG5pY2Ugc2V0dGluZyBpZCBhZnRlcndhcmRzXG4gICAgICAgICAgbWUuX2FkZEl0ZW0oaXRlbSk7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5wdXNoKGlkKTtcbiAgICAgICAgICAgIGl0ZW0uc2VsZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ3Jhbmdlb3ZlcmZsb3cnKSB7XG4gICAgICAgICAgLy8gVE9ETzogZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuMS4wIChvciAzLjAuMD8pLiBjbGVhbnVwIHNvbWUgZGF5XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSXRlbSB0eXBlIFwicmFuZ2VvdmVyZmxvd1wiIGlzIGRlcHJlY2F0ZWQuIFVzZSBjc3Mgc3R5bGluZyBpbnN0ZWFkOiAnICsgJy52aXMtaXRlbS52aXMtcmFuZ2UgLnZpcy1pdGVtLWNvbnRlbnQge292ZXJmbG93OiB2aXNpYmxlO30nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGl0ZW0gdHlwZSBcIicgKyB0eXBlICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5fb3JkZXIoKTtcbiAgICB0aGlzLnN0YWNrRGlydHkgPSB0cnVlOyAvLyBmb3JjZSByZS1zdGFja2luZyBvZiBhbGwgaXRlbXMgbmV4dCByZWRyYXdcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfY2hhbmdlJywgeyBxdWV1ZTogdHJ1ZSB9KTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGFkZGVkIGl0ZW1zXG4gICAqIEBwYXJhbSB7TnVtYmVyW119IGlkc1xuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fb25BZGQgPSBJdGVtU2V0LnByb3RvdHlwZS5fb25VcGRhdGU7XG5cbiAgLyoqXG4gICAqIEhhbmRsZSByZW1vdmVkIGl0ZW1zXG4gICAqIEBwYXJhbSB7TnVtYmVyW119IGlkc1xuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fb25SZW1vdmUgPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgdmFyIGl0ZW0gPSBtZS5pdGVtc1tpZF07XG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICBjb3VudCsrO1xuICAgICAgICBtZS5fcmVtb3ZlSXRlbShpdGVtKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChjb3VudCkge1xuICAgICAgLy8gdXBkYXRlIG9yZGVyXG4gICAgICB0aGlzLl9vcmRlcigpO1xuICAgICAgdGhpcy5zdGFja0RpcnR5ID0gdHJ1ZTsgLy8gZm9yY2UgcmUtc3RhY2tpbmcgb2YgYWxsIGl0ZW1zIG5leHQgcmVkcmF3XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfY2hhbmdlJywgeyBxdWV1ZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgb3JkZXIgb2YgaXRlbSBpbiBhbGwgZ3JvdXBzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fb3JkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcmVvcmRlciB0aGUgaXRlbXMgaW4gYWxsIGdyb3Vwc1xuICAgIC8vIFRPRE86IG9wdGltaXphdGlvbjogb25seSByZW9yZGVyIGdyb3VwcyBhZmZlY3RlZCBieSB0aGUgY2hhbmdlZCBpdGVtc1xuICAgIHV0aWwuZm9yRWFjaCh0aGlzLmdyb3VwcywgZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICBncm91cC5vcmRlcigpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgdXBkYXRlZCBncm91cHNcbiAgICogQHBhcmFtIHtOdW1iZXJbXX0gaWRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fb25VcGRhdGVHcm91cHMgPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgdGhpcy5fb25BZGRHcm91cHMoaWRzKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGNoYW5nZWQgZ3JvdXBzIChhZGRlZCBvciB1cGRhdGVkKVxuICAgKiBAcGFyYW0ge051bWJlcltdfSBpZHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9vbkFkZEdyb3VwcyA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICB2YXIgZ3JvdXBEYXRhID0gbWUuZ3JvdXBzRGF0YS5nZXQoaWQpO1xuICAgICAgdmFyIGdyb3VwID0gbWUuZ3JvdXBzW2lkXTtcblxuICAgICAgaWYgKCFncm91cCkge1xuICAgICAgICAvLyBjaGVjayBmb3IgcmVzZXJ2ZWQgaWRzXG4gICAgICAgIGlmIChpZCA9PSBVTkdST1VQRUQgfHwgaWQgPT0gQkFDS0dST1VORCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBncm91cCBpZC4gJyArIGlkICsgJyBpcyBhIHJlc2VydmVkIGlkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdyb3VwT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobWUub3B0aW9ucyk7XG4gICAgICAgIHV0aWwuZXh0ZW5kKGdyb3VwT3B0aW9ucywge1xuICAgICAgICAgIGhlaWdodDogbnVsbFxuICAgICAgICB9KTtcblxuICAgICAgICBncm91cCA9IG5ldyBHcm91cChpZCwgZ3JvdXBEYXRhLCBtZSk7XG4gICAgICAgIG1lLmdyb3Vwc1tpZF0gPSBncm91cDtcblxuICAgICAgICAvLyBhZGQgaXRlbXMgd2l0aCB0aGlzIGdyb3VwSWQgdG8gdGhlIG5ldyBncm91cFxuICAgICAgICBmb3IgKHZhciBpdGVtSWQgaW4gbWUuaXRlbXMpIHtcbiAgICAgICAgICBpZiAobWUuaXRlbXMuaGFzT3duUHJvcGVydHkoaXRlbUlkKSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBtZS5pdGVtc1tpdGVtSWRdO1xuICAgICAgICAgICAgaWYgKGl0ZW0uZGF0YS5ncm91cCA9PSBpZCkge1xuICAgICAgICAgICAgICBncm91cC5hZGQoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ3JvdXAub3JkZXIoKTtcbiAgICAgICAgZ3JvdXAuc2hvdygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXBkYXRlIGdyb3VwXG4gICAgICAgIGdyb3VwLnNldERhdGEoZ3JvdXBEYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19jaGFuZ2UnLCB7IHF1ZXVlOiB0cnVlIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgcmVtb3ZlZCBncm91cHNcbiAgICogQHBhcmFtIHtOdW1iZXJbXX0gaWRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fb25SZW1vdmVHcm91cHMgPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgdmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuICAgIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzW2lkXTtcblxuICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgIGdyb3VwLmhpZGUoKTtcbiAgICAgICAgZGVsZXRlIGdyb3Vwc1tpZF07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2NoYW5nZScsIHsgcXVldWU6IHRydWUgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlb3JkZXIgdGhlIGdyb3VwcyBpZiBuZWVkZWRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gY2hhbmdlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX29yZGVyR3JvdXBzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmdyb3Vwc0RhdGEpIHtcbiAgICAgIC8vIHJlb3JkZXIgdGhlIGdyb3Vwc1xuICAgICAgdmFyIGdyb3VwSWRzID0gdGhpcy5ncm91cHNEYXRhLmdldElkcyh7XG4gICAgICAgIG9yZGVyOiB0aGlzLm9wdGlvbnMuZ3JvdXBPcmRlclxuICAgICAgfSk7XG5cbiAgICAgIHZhciBjaGFuZ2VkID0gIXV0aWwuZXF1YWxBcnJheShncm91cElkcywgdGhpcy5ncm91cElkcyk7XG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAvLyBoaWRlIGFsbCBncm91cHMsIHJlbW92ZXMgdGhlbSBmcm9tIHRoZSBET01cbiAgICAgICAgdmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuICAgICAgICBncm91cElkcy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cElkKSB7XG4gICAgICAgICAgZ3JvdXBzW2dyb3VwSWRdLmhpZGUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc2hvdyB0aGUgZ3JvdXBzIGFnYWluLCBhdHRhY2ggdGhlbSB0byB0aGUgRE9NIGluIGNvcnJlY3Qgb3JkZXJcbiAgICAgICAgZ3JvdXBJZHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXBJZCkge1xuICAgICAgICAgIGdyb3Vwc1tncm91cElkXS5zaG93KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZ3JvdXBJZHMgPSBncm91cElkcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBpdGVtXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX2FkZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHRoaXMuaXRlbXNbaXRlbS5pZF0gPSBpdGVtO1xuXG4gICAgLy8gYWRkIHRvIGdyb3VwXG4gICAgdmFyIGdyb3VwSWQgPSB0aGlzLl9nZXRHcm91cElkKGl0ZW0uZGF0YSk7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZF07XG4gICAgaWYgKGdyb3VwKSBncm91cC5hZGQoaXRlbSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhbiBleGlzdGluZyBpdGVtXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbURhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl91cGRhdGVJdGVtID0gZnVuY3Rpb24gKGl0ZW0sIGl0ZW1EYXRhKSB7XG4gICAgdmFyIG9sZEdyb3VwSWQgPSBpdGVtLmRhdGEuZ3JvdXA7XG4gICAgdmFyIG9sZFN1Ykdyb3VwSWQgPSBpdGVtLmRhdGEuc3ViZ3JvdXA7XG5cbiAgICAvLyB1cGRhdGUgdGhlIGl0ZW1zIGRhdGEgKHdpbGwgcmVkcmF3IHRoZSBpdGVtIHdoZW4gZGlzcGxheWVkKVxuICAgIGl0ZW0uc2V0RGF0YShpdGVtRGF0YSk7XG5cbiAgICAvLyB1cGRhdGUgZ3JvdXBcbiAgICBpZiAob2xkR3JvdXBJZCAhPSBpdGVtLmRhdGEuZ3JvdXAgfHwgb2xkU3ViR3JvdXBJZCAhPSBpdGVtLmRhdGEuc3ViZ3JvdXApIHtcbiAgICAgIHZhciBvbGRHcm91cCA9IHRoaXMuZ3JvdXBzW29sZEdyb3VwSWRdO1xuICAgICAgaWYgKG9sZEdyb3VwKSBvbGRHcm91cC5yZW1vdmUoaXRlbSk7XG5cbiAgICAgIHZhciBncm91cElkID0gdGhpcy5fZ2V0R3JvdXBJZChpdGVtLmRhdGEpO1xuICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZF07XG4gICAgICBpZiAoZ3JvdXApIGdyb3VwLmFkZChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhbiBpdGVtIGZyb20gdGhlIEl0ZW1TZXQ6IHJlbW92ZSBpdCBmcm9tIHRoZSBET00sIGZyb20gdGhlIG1hcFxuICAgKiB3aXRoIGl0ZW1zLCBhbmQgZnJvbSB0aGUgbWFwIHdpdGggdmlzaWJsZSBpdGVtcywgYW5kIGZyb20gdGhlIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9yZW1vdmVJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAvLyByZW1vdmUgZnJvbSBET01cbiAgICBpdGVtLmhpZGUoKTtcblxuICAgIC8vIHJlbW92ZSBmcm9tIGl0ZW1zXG4gICAgZGVsZXRlIHRoaXMuaXRlbXNbaXRlbS5pZF07XG5cbiAgICAvLyByZW1vdmUgZnJvbSBzZWxlY3Rpb25cbiAgICB2YXIgaW5kZXggPSB0aGlzLnNlbGVjdGlvbi5pbmRleE9mKGl0ZW0uaWQpO1xuICAgIGlmIChpbmRleCAhPSAtMSkgdGhpcy5zZWxlY3Rpb24uc3BsaWNlKGluZGV4LCAxKTtcblxuICAgIC8vIHJlbW92ZSBmcm9tIGdyb3VwXG4gICAgaXRlbS5wYXJlbnQgJiYgaXRlbS5wYXJlbnQucmVtb3ZlKGl0ZW0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gYXJyYXkgY29udGFpbmluZyBhbGwgaXRlbXMgYmVpbmcgYSByYW5nZSAoaGF2aW5nIGFuIGVuZCBkYXRlKVxuICAgKiBAcGFyYW0gYXJyYXlcbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX2NvbnN0cnVjdEJ5RW5kQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICB2YXIgZW5kQXJyYXkgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJheVtpXSBpbnN0YW5jZW9mIFJhbmdlSXRlbSkge1xuICAgICAgICBlbmRBcnJheS5wdXNoKGFycmF5W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuZEFycmF5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciB0aGUgY2xpY2tlZCBpdGVtIG9uIHRvdWNoLCBiZWZvcmUgZHJhZ1N0YXJ0IGlzIGluaXRpYXRlZC5cbiAgICpcbiAgICogZHJhZ1N0YXJ0IGlzIGluaXRpYXRlZCBmcm9tIGEgbW91c2Vtb3ZlIGV2ZW50LCBBRlRFUiB0aGUgbW91c2UvdG91Y2ggaXNcbiAgICogYWxyZWFkeSBtb3ZpbmcuIFRoZXJlZm9yZSwgdGhlIG1vdXNlL3RvdWNoIGNhbiBzb21ldGltZXMgYmUgYWJvdmUgYW4gb3RoZXJcbiAgICogRE9NIGVsZW1lbnQgdGhhbiB0aGUgaXRlbSBpdHNlbGYuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fb25Ub3VjaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIHN0b3JlIHRoZSB0b3VjaGVkIGl0ZW0sIHVzZWQgaW4gX29uRHJhZ1N0YXJ0XG4gICAgdGhpcy50b3VjaFBhcmFtcy5pdGVtID0gdGhpcy5pdGVtRnJvbVRhcmdldChldmVudCk7XG4gICAgdGhpcy50b3VjaFBhcmFtcy5kcmFnTGVmdEl0ZW0gPSBldmVudC50YXJnZXQuZHJhZ0xlZnRJdGVtIHx8IGZhbHNlO1xuICAgIHRoaXMudG91Y2hQYXJhbXMuZHJhZ1JpZ2h0SXRlbSA9IGV2ZW50LnRhcmdldC5kcmFnUmlnaHRJdGVtIHx8IGZhbHNlO1xuICAgIHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2l2ZW4gYW4gZ3JvdXAgaWQsIHJldHVybnMgdGhlIGluZGV4IGl0IGhhcy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGdyb3VwSURcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9nZXRHcm91cEluZGV4ID0gZnVuY3Rpb24gKGdyb3VwSWQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ3JvdXBJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChncm91cElkID09IHRoaXMuZ3JvdXBJZHNbaV0pIHJldHVybiBpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3RhcnQgZHJhZ2dpbmcgdGhlIHNlbGVjdGVkIGV2ZW50c1xuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGl0ZW0gPSB0aGlzLnRvdWNoUGFyYW1zLml0ZW0gfHwgbnVsbDtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBwcm9wcztcblxuICAgIGlmIChpdGVtICYmIChpdGVtLnNlbGVjdGVkIHx8IHRoaXMub3B0aW9ucy5pdGVtc0Fsd2F5c0RyYWdnYWJsZSkpIHtcblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlVGltZSAmJiAhdGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZUdyb3VwICYmICFpdGVtLmVkaXRhYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gb3ZlcnJpZGUgb3B0aW9ucy5lZGl0YWJsZVxuICAgICAgaWYgKGl0ZW0uZWRpdGFibGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRyYWdMZWZ0SXRlbSA9IHRoaXMudG91Y2hQYXJhbXMuZHJhZ0xlZnRJdGVtO1xuICAgICAgdmFyIGRyYWdSaWdodEl0ZW0gPSB0aGlzLnRvdWNoUGFyYW1zLmRyYWdSaWdodEl0ZW07XG4gICAgICB0aGlzLnRvdWNoUGFyYW1zLml0ZW1Jc0RyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKGRyYWdMZWZ0SXRlbSkge1xuICAgICAgICBwcm9wcyA9IHtcbiAgICAgICAgICBpdGVtOiBkcmFnTGVmdEl0ZW0sXG4gICAgICAgICAgaW5pdGlhbFg6IGV2ZW50LmNlbnRlci54LFxuICAgICAgICAgIGRyYWdMZWZ0OiB0cnVlLFxuICAgICAgICAgIGRhdGE6IHRoaXMuX2Nsb25lSXRlbURhdGEoaXRlbS5kYXRhKVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzID0gW3Byb3BzXTtcbiAgICAgIH0gZWxzZSBpZiAoZHJhZ1JpZ2h0SXRlbSkge1xuICAgICAgICBwcm9wcyA9IHtcbiAgICAgICAgICBpdGVtOiBkcmFnUmlnaHRJdGVtLFxuICAgICAgICAgIGluaXRpYWxYOiBldmVudC5jZW50ZXIueCxcbiAgICAgICAgICBkcmFnUmlnaHQ6IHRydWUsXG4gICAgICAgICAgZGF0YTogdGhpcy5fY2xvbmVJdGVtRGF0YShpdGVtLmRhdGEpXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHMgPSBbcHJvcHNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50b3VjaFBhcmFtcy5zZWxlY3RlZEl0ZW0gPSBpdGVtO1xuXG4gICAgICAgIHZhciBiYXNlR3JvdXBJbmRleCA9IHRoaXMuX2dldEdyb3VwSW5kZXgoaXRlbS5kYXRhLmdyb3VwKTtcblxuICAgICAgICB2YXIgaXRlbXNUb0RyYWcgPSB0aGlzLm9wdGlvbnMuaXRlbXNBbHdheXNEcmFnZ2FibGUgJiYgIWl0ZW0uc2VsZWN0ZWQgPyBbaXRlbS5pZF0gOiB0aGlzLmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgIHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzID0gaXRlbXNUb0RyYWcubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgIHZhciBpdGVtID0gbWUuaXRlbXNbaWRdO1xuICAgICAgICAgIHZhciBncm91cEluZGV4ID0gbWUuX2dldEdyb3VwSW5kZXgoaXRlbS5kYXRhLmdyb3VwKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgIGluaXRpYWxYOiBldmVudC5jZW50ZXIueCxcbiAgICAgICAgICAgIGdyb3VwT2Zmc2V0OiBiYXNlR3JvdXBJbmRleCAtIGdyb3VwSW5kZXgsXG4gICAgICAgICAgICBkYXRhOiB0aGlzLl9jbG9uZUl0ZW1EYXRhKGl0ZW0uZGF0YSlcbiAgICAgICAgICB9O1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgfVxuXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lZGl0YWJsZS5hZGQgJiYgKGV2ZW50LnNyY0V2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc3JjRXZlbnQubWV0YUtleSkpIHtcbiAgICAgIC8vIGNyZWF0ZSBhIG5ldyByYW5nZSBpdGVtIHdoZW4gZHJhZ2dpbmcgd2l0aCBjdHJsIGtleSBkb3duXG4gICAgICB0aGlzLl9vbkRyYWdTdGFydEFkZEl0ZW0oZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3RhcnQgY3JlYXRpbmcgYSBuZXcgcmFuZ2UgaXRlbSBieSBkcmFnZ2luZy5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9vbkRyYWdTdGFydEFkZEl0ZW0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgc25hcCA9IHRoaXMub3B0aW9ucy5zbmFwIHx8IG51bGw7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgdmFyIHhBYnMgPSB1dGlsLmdldEFic29sdXRlUmlnaHQodGhpcy5kb20uZnJhbWUpO1xuICAgICAgdmFyIHggPSB4QWJzIC0gZXZlbnQuY2VudGVyLnggKyAxMDsgLy8gcGx1cyAxMCB0byBjb21wZW5zYXRlIGZvciB0aGUgZHJhZyBzdGFydGluZyBhcyBzb29uIGFzIHlvdSd2ZSBtb3ZlZCAxMHB4XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB4QWJzID0gdXRpbC5nZXRBYnNvbHV0ZUxlZnQodGhpcy5kb20uZnJhbWUpO1xuICAgICAgdmFyIHggPSBldmVudC5jZW50ZXIueCAtIHhBYnMgLSAxMDsgLy8gbWludXMgMTAgdG8gY29tcGVuc2F0ZSBmb3IgdGhlIGRyYWcgc3RhcnRpbmcgYXMgc29vbiBhcyB5b3UndmUgbW92ZWQgMTBweFxuICAgIH1cblxuICAgIHZhciB0aW1lID0gdGhpcy5ib2R5LnV0aWwudG9UaW1lKHgpO1xuICAgIHZhciBzY2FsZSA9IHRoaXMuYm9keS51dGlsLmdldFNjYWxlKCk7XG4gICAgdmFyIHN0ZXAgPSB0aGlzLmJvZHkudXRpbC5nZXRTdGVwKCk7XG4gICAgdmFyIHN0YXJ0ID0gc25hcCA/IHNuYXAodGltZSwgc2NhbGUsIHN0ZXApIDogdGltZTtcbiAgICB2YXIgZW5kID0gc3RhcnQ7XG5cbiAgICB2YXIgaXRlbURhdGEgPSB7XG4gICAgICB0eXBlOiAncmFuZ2UnLFxuICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgZW5kOiBlbmQsXG4gICAgICBjb250ZW50OiAnbmV3IGl0ZW0nXG4gICAgfTtcblxuICAgIHZhciBpZCA9IHV0aWwucmFuZG9tVVVJRCgpO1xuICAgIGl0ZW1EYXRhW3RoaXMuaXRlbXNEYXRhLl9maWVsZElkXSA9IGlkO1xuXG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cEZyb21UYXJnZXQoZXZlbnQpO1xuICAgIGlmIChncm91cCkge1xuICAgICAgaXRlbURhdGEuZ3JvdXAgPSBncm91cC5ncm91cElkO1xuICAgIH1cbiAgICB2YXIgbmV3SXRlbSA9IG5ldyBSYW5nZUl0ZW0oaXRlbURhdGEsIHRoaXMuY29udmVyc2lvbiwgdGhpcy5vcHRpb25zKTtcbiAgICBuZXdJdGVtLmlkID0gaWQ7IC8vIFRPRE86IG5vdCBzbyBuaWNlIHNldHRpbmcgaWQgYWZ0ZXJ3YXJkc1xuICAgIG5ld0l0ZW0uZGF0YSA9IHRoaXMuX2Nsb25lSXRlbURhdGEoaXRlbURhdGEpO1xuICAgIHRoaXMuX2FkZEl0ZW0obmV3SXRlbSk7XG5cbiAgICB2YXIgcHJvcHMgPSB7XG4gICAgICBpdGVtOiBuZXdJdGVtLFxuICAgICAgaW5pdGlhbFg6IGV2ZW50LmNlbnRlci54LFxuICAgICAgZGF0YTogbmV3SXRlbS5kYXRhXG4gICAgfTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICBwcm9wcy5kcmFnTGVmdCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3BzLmRyYWdSaWdodCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzID0gW3Byb3BzXTtcblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEcmFnIHNlbGVjdGVkIGl0ZW1zXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHZhciBzbmFwID0gdGhpcy5vcHRpb25zLnNuYXAgfHwgbnVsbDtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgdmFyIHhPZmZzZXQgPSB0aGlzLmJvZHkuZG9tLnJvb3Qub2Zmc2V0TGVmdCArIHRoaXMuYm9keS5kb21Qcm9wcy5yaWdodC53aWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB4T2Zmc2V0ID0gdGhpcy5ib2R5LmRvbS5yb290Lm9mZnNldExlZnQgKyB0aGlzLmJvZHkuZG9tUHJvcHMubGVmdC53aWR0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIHNjYWxlID0gdGhpcy5ib2R5LnV0aWwuZ2V0U2NhbGUoKTtcbiAgICAgIHZhciBzdGVwID0gdGhpcy5ib2R5LnV0aWwuZ2V0U3RlcCgpO1xuXG4gICAgICAvL29ubHkgY2FsY3VsYXRlIHRoZSBuZXcgZ3JvdXAgZm9yIHRoZSBpdGVtIHRoYXQncyBhY3R1YWxseSBkcmFnZ2VkXG4gICAgICB2YXIgc2VsZWN0ZWRJdGVtID0gdGhpcy50b3VjaFBhcmFtcy5zZWxlY3RlZEl0ZW07XG4gICAgICB2YXIgdXBkYXRlR3JvdXBBbGxvd2VkID0gbWUub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVHcm91cDtcbiAgICAgIHZhciBuZXdHcm91cEJhc2UgPSBudWxsO1xuICAgICAgaWYgKHVwZGF0ZUdyb3VwQWxsb3dlZCAmJiBzZWxlY3RlZEl0ZW0pIHtcbiAgICAgICAgaWYgKHNlbGVjdGVkSXRlbS5kYXRhLmdyb3VwICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGRyYWcgZnJvbSBvbmUgZ3JvdXAgdG8gYW5vdGhlclxuICAgICAgICAgIHZhciBncm91cCA9IG1lLmdyb3VwRnJvbVRhcmdldChldmVudCk7XG4gICAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICAvL3dlIGtub3cgdGhlIG9mZnNldCBmb3IgYWxsIGl0ZW1zLCBzbyB0aGUgbmV3IGdyb3VwIGZvciBhbGwgaXRlbXNcbiAgICAgICAgICAgIC8vd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzIG9uZS5cbiAgICAgICAgICAgIG5ld0dyb3VwQmFzZSA9IHRoaXMuX2dldEdyb3VwSW5kZXgoZ3JvdXAuZ3JvdXBJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG1vdmVcbiAgICAgIHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbWUuYm9keS51dGlsLnRvVGltZShldmVudC5jZW50ZXIueCAtIHhPZmZzZXQpO1xuICAgICAgICB2YXIgaW5pdGlhbCA9IG1lLmJvZHkudXRpbC50b1RpbWUocHJvcHMuaW5pdGlhbFggLSB4T2Zmc2V0KTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICAgIHZhciBvZmZzZXQgPSAtKGN1cnJlbnQgLSBpbml0aWFsKTsgLy8gbXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gY3VycmVudCAtIGluaXRpYWw7IC8vIG1zXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlbURhdGEgPSB0aGlzLl9jbG9uZUl0ZW1EYXRhKHByb3BzLml0ZW0uZGF0YSk7IC8vIGNsb25lIHRoZSBkYXRhXG4gICAgICAgIGlmIChwcm9wcy5pdGVtLmVkaXRhYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1cGRhdGVUaW1lQWxsb3dlZCA9IG1lLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlVGltZSB8fCBwcm9wcy5pdGVtLmVkaXRhYmxlID09PSB0cnVlO1xuICAgICAgICBpZiAodXBkYXRlVGltZUFsbG93ZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHMuZHJhZ0xlZnQpIHtcbiAgICAgICAgICAgIC8vIGRyYWcgbGVmdCBzaWRlIG9mIGEgcmFuZ2UgaXRlbVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgICAgICAgaWYgKGl0ZW1EYXRhLmVuZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbEVuZCA9IHV0aWwuY29udmVydChwcm9wcy5kYXRhLmVuZCwgJ0RhdGUnKTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gbmV3IERhdGUoaW5pdGlhbEVuZC52YWx1ZU9mKCkgKyBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHBhc3MgYSBNb21lbnQgaW5zdGVhZCBvZiBhIERhdGUgdG8gc25hcCgpLiAoQnJlYWtpbmcgY2hhbmdlKVxuICAgICAgICAgICAgICAgIGl0ZW1EYXRhLmVuZCA9IHNuYXAgPyBzbmFwKGVuZCwgc2NhbGUsIHN0ZXApIDogZW5kO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoaXRlbURhdGEuc3RhcnQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluaXRpYWxTdGFydCA9IHV0aWwuY29udmVydChwcm9wcy5kYXRhLnN0YXJ0LCAnRGF0ZScpO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKGluaXRpYWxTdGFydC52YWx1ZU9mKCkgKyBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHBhc3MgYSBNb21lbnQgaW5zdGVhZCBvZiBhIERhdGUgdG8gc25hcCgpLiAoQnJlYWtpbmcgY2hhbmdlKVxuICAgICAgICAgICAgICAgIGl0ZW1EYXRhLnN0YXJ0ID0gc25hcCA/IHNuYXAoc3RhcnQsIHNjYWxlLCBzdGVwKSA6IHN0YXJ0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9wcy5kcmFnUmlnaHQpIHtcbiAgICAgICAgICAgIC8vIGRyYWcgcmlnaHQgc2lkZSBvZiBhIHJhbmdlIGl0ZW1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgICAgICAgIGlmIChpdGVtRGF0YS5zdGFydCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbFN0YXJ0ID0gdXRpbC5jb252ZXJ0KHByb3BzLmRhdGEuc3RhcnQsICdEYXRlJyk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoaW5pdGlhbFN0YXJ0LnZhbHVlT2YoKSArIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcGFzcyBhIE1vbWVudCBpbnN0ZWFkIG9mIGEgRGF0ZSB0byBzbmFwKCkuIChCcmVha2luZyBjaGFuZ2UpXG4gICAgICAgICAgICAgICAgaXRlbURhdGEuc3RhcnQgPSBzbmFwID8gc25hcChzdGFydCwgc2NhbGUsIHN0ZXApIDogc3RhcnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChpdGVtRGF0YS5lbmQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluaXRpYWxFbmQgPSB1dGlsLmNvbnZlcnQocHJvcHMuZGF0YS5lbmQsICdEYXRlJyk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IG5ldyBEYXRlKGluaXRpYWxFbmQudmFsdWVPZigpICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBwYXNzIGEgTW9tZW50IGluc3RlYWQgb2YgYSBEYXRlIHRvIHNuYXAoKS4gKEJyZWFraW5nIGNoYW5nZSlcbiAgICAgICAgICAgICAgICBpdGVtRGF0YS5lbmQgPSBzbmFwID8gc25hcChlbmQsIHNjYWxlLCBzdGVwKSA6IGVuZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkcmFnIGJvdGggc3RhcnQgYW5kIGVuZFxuICAgICAgICAgICAgaWYgKGl0ZW1EYXRhLnN0YXJ0ICE9IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgIHZhciBpbml0aWFsU3RhcnQgPSB1dGlsLmNvbnZlcnQocHJvcHMuZGF0YS5zdGFydCwgJ0RhdGUnKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKGluaXRpYWxTdGFydCArIG9mZnNldCk7XG5cbiAgICAgICAgICAgICAgaWYgKGl0ZW1EYXRhLmVuZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbEVuZCA9IHV0aWwuY29udmVydChwcm9wcy5kYXRhLmVuZCwgJ0RhdGUnKTtcbiAgICAgICAgICAgICAgICB2YXIgZHVyYXRpb24gPSBpbml0aWFsRW5kLnZhbHVlT2YoKSAtIGluaXRpYWxTdGFydC52YWx1ZU9mKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBwYXNzIGEgTW9tZW50IGluc3RlYWQgb2YgYSBEYXRlIHRvIHNuYXAoKS4gKEJyZWFraW5nIGNoYW5nZSlcbiAgICAgICAgICAgICAgICBpdGVtRGF0YS5zdGFydCA9IHNuYXAgPyBzbmFwKHN0YXJ0LCBzY2FsZSwgc3RlcCkgOiBzdGFydDtcbiAgICAgICAgICAgICAgICBpdGVtRGF0YS5lbmQgPSBuZXcgRGF0ZShpdGVtRGF0YS5zdGFydC52YWx1ZU9mKCkgKyBkdXJhdGlvbik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcGFzcyBhIE1vbWVudCBpbnN0ZWFkIG9mIGEgRGF0ZSB0byBzbmFwKCkuIChCcmVha2luZyBjaGFuZ2UpXG4gICAgICAgICAgICAgICAgaXRlbURhdGEuc3RhcnQgPSBzbmFwID8gc25hcChzdGFydCwgc2NhbGUsIHN0ZXApIDogc3RhcnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXBkYXRlR3JvdXBBbGxvd2VkID0gbWUub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVHcm91cCB8fCBwcm9wcy5pdGVtLmVkaXRhYmxlID09PSB0cnVlO1xuXG4gICAgICAgIGlmICh1cGRhdGVHcm91cEFsbG93ZWQgJiYgIXByb3BzLmRyYWdMZWZ0ICYmICFwcm9wcy5kcmFnUmlnaHQgJiYgbmV3R3JvdXBCYXNlICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoaXRlbURhdGEuZ3JvdXAgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgbmV3T2Zmc2V0ID0gbmV3R3JvdXBCYXNlIC0gcHJvcHMuZ3JvdXBPZmZzZXQ7XG5cbiAgICAgICAgICAgIC8vbWFrZSBzdXJlIHdlIHN0YXkgaW4gYm91bmRzXG4gICAgICAgICAgICBuZXdPZmZzZXQgPSBNYXRoLm1heCgwLCBuZXdPZmZzZXQpO1xuICAgICAgICAgICAgbmV3T2Zmc2V0ID0gTWF0aC5taW4obWUuZ3JvdXBJZHMubGVuZ3RoIC0gMSwgbmV3T2Zmc2V0KTtcblxuICAgICAgICAgICAgaXRlbURhdGEuZ3JvdXAgPSBtZS5ncm91cElkc1tuZXdPZmZzZXRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbmZpcm0gbW92aW5nIHRoZSBpdGVtXG4gICAgICAgIGl0ZW1EYXRhID0gdGhpcy5fY2xvbmVJdGVtRGF0YShpdGVtRGF0YSk7IC8vIGNvbnZlcnQgc3RhcnQgYW5kIGVuZCB0byB0aGUgY29ycmVjdCB0eXBlXG4gICAgICAgIG1lLm9wdGlvbnMub25Nb3ZpbmcoaXRlbURhdGEsIGZ1bmN0aW9uIChpdGVtRGF0YSkge1xuICAgICAgICAgIGlmIChpdGVtRGF0YSkge1xuICAgICAgICAgICAgcHJvcHMuaXRlbS5zZXREYXRhKHRoaXMuX2Nsb25lSXRlbURhdGEoaXRlbURhdGEsICdEYXRlJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgIHRoaXMuc3RhY2tEaXJ0eSA9IHRydWU7IC8vIGZvcmNlIHJlLXN0YWNraW5nIG9mIGFsbCBpdGVtcyBuZXh0IHJlZHJhd1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2NoYW5nZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTW92ZSBhbiBpdGVtIHRvIGFub3RoZXIgZ3JvdXBcbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBncm91cElkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fbW92ZVRvR3JvdXAgPSBmdW5jdGlvbiAoaXRlbSwgZ3JvdXBJZCkge1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXBzW2dyb3VwSWRdO1xuICAgIGlmIChncm91cCAmJiBncm91cC5ncm91cElkICE9IGl0ZW0uZGF0YS5ncm91cCkge1xuICAgICAgdmFyIG9sZEdyb3VwID0gaXRlbS5wYXJlbnQ7XG4gICAgICBvbGRHcm91cC5yZW1vdmUoaXRlbSk7XG4gICAgICBvbGRHcm91cC5vcmRlcigpO1xuICAgICAgZ3JvdXAuYWRkKGl0ZW0pO1xuICAgICAgZ3JvdXAub3JkZXIoKTtcblxuICAgICAgaXRlbS5kYXRhLmdyb3VwID0gZ3JvdXAuZ3JvdXBJZDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuZCBvZiBkcmFnZ2luZyBzZWxlY3RlZCBpdGVtc1xuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX29uRHJhZ0VuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICh0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcykge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB2YXIgZGF0YXNldCA9IHRoaXMuaXRlbXNEYXRhLmdldERhdGFTZXQoKTtcbiAgICAgIHZhciBpdGVtUHJvcHMgPSB0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcztcbiAgICAgIHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzID0gbnVsbDtcbiAgICAgIHRoaXMudG91Y2hQYXJhbXMuaXRlbUlzRHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgICAgaXRlbVByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHZhciBpZCA9IHByb3BzLml0ZW0uaWQ7XG4gICAgICAgIHZhciBleGlzdHMgPSBtZS5pdGVtc0RhdGEuZ2V0KGlkLCBtZS5pdGVtT3B0aW9ucykgIT0gbnVsbDtcblxuICAgICAgICBpZiAoIWV4aXN0cykge1xuICAgICAgICAgIC8vIGFkZCBhIG5ldyBpdGVtXG4gICAgICAgICAgbWUub3B0aW9ucy5vbkFkZChwcm9wcy5pdGVtLmRhdGEsIGZ1bmN0aW9uIChpdGVtRGF0YSkge1xuICAgICAgICAgICAgbWUuX3JlbW92ZUl0ZW0ocHJvcHMuaXRlbSk7IC8vIHJlbW92ZSB0ZW1wb3JhcnkgaXRlbVxuICAgICAgICAgICAgaWYgKGl0ZW1EYXRhKSB7XG4gICAgICAgICAgICAgIG1lLml0ZW1zRGF0YS5nZXREYXRhU2V0KCkuYWRkKGl0ZW1EYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZm9yY2UgcmUtc3RhY2tpbmcgb2YgYWxsIGl0ZW1zIG5leHQgcmVkcmF3XG4gICAgICAgICAgICBtZS5zdGFja0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIG1lLmJvZHkuZW1pdHRlci5lbWl0KCdfY2hhbmdlJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXBkYXRlIGV4aXN0aW5nIGl0ZW1cbiAgICAgICAgICB2YXIgaXRlbURhdGEgPSB0aGlzLl9jbG9uZUl0ZW1EYXRhKHByb3BzLml0ZW0uZGF0YSk7IC8vIGNvbnZlcnQgc3RhcnQgYW5kIGVuZCB0byB0aGUgY29ycmVjdCB0eXBlXG4gICAgICAgICAgbWUub3B0aW9ucy5vbk1vdmUoaXRlbURhdGEsIGZ1bmN0aW9uIChpdGVtRGF0YSkge1xuICAgICAgICAgICAgaWYgKGl0ZW1EYXRhKSB7XG4gICAgICAgICAgICAgIC8vIGFwcGx5IGNoYW5nZXNcbiAgICAgICAgICAgICAgaXRlbURhdGFbZGF0YXNldC5fZmllbGRJZF0gPSBpZDsgLy8gZW5zdXJlIHRoZSBpdGVtIGNvbnRhaW5zIGl0cyBpZCAoY2FuIGJlIHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgZGF0YXNldC51cGRhdGUoaXRlbURhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICAgICAgICAgICAgcHJvcHMuaXRlbS5zZXREYXRhKHByb3BzLmRhdGEpO1xuXG4gICAgICAgICAgICAgIG1lLnN0YWNrRGlydHkgPSB0cnVlOyAvLyBmb3JjZSByZS1zdGFja2luZyBvZiBhbGwgaXRlbXMgbmV4dCByZWRyYXdcbiAgICAgICAgICAgICAgbWUuYm9keS5lbWl0dGVyLmVtaXQoJ19jaGFuZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH07XG5cbiAgSXRlbVNldC5wcm90b3R5cGUuX29uR3JvdXBEcmFnU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmdyb3VwRWRpdGFibGUub3JkZXIpIHtcbiAgICAgIHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cCA9IHRoaXMuZ3JvdXBGcm9tVGFyZ2V0KGV2ZW50KTtcblxuICAgICAgaWYgKHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICB0aGlzLmdyb3VwVG91Y2hQYXJhbXMub3JpZ2luYWxPcmRlciA9IHRoaXMuZ3JvdXBzRGF0YS5nZXRJZHMoe1xuICAgICAgICAgIG9yZGVyOiB0aGlzLm9wdGlvbnMuZ3JvdXBPcmRlclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgSXRlbVNldC5wcm90b3R5cGUuX29uR3JvdXBEcmFnID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ncm91cEVkaXRhYmxlLm9yZGVyICYmIHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cCkge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIC8vIGRyYWcgZnJvbSBvbmUgZ3JvdXAgdG8gYW5vdGhlclxuICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cEZyb21UYXJnZXQoZXZlbnQpO1xuXG4gICAgICAvLyB0cnkgdG8gYXZvaWQgdG9nZ2xpbmcgd2hlbiBncm91cHMgZGlmZmVyIGluIGhlaWdodFxuICAgICAgaWYgKGdyb3VwICYmIGdyb3VwLmhlaWdodCAhPSB0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXAuaGVpZ2h0KSB7XG4gICAgICAgIHZhciBtb3ZpbmdVcCA9IGdyb3VwLnRvcCA8IHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cC50b3A7XG4gICAgICAgIHZhciBjbGllbnRZID0gZXZlbnQuY2VudGVyID8gZXZlbnQuY2VudGVyLnkgOiBldmVudC5jbGllbnRZO1xuICAgICAgICB2YXIgdGFyZ2V0R3JvdXBUb3AgPSB1dGlsLmdldEFic29sdXRlVG9wKGdyb3VwLmRvbS5mb3JlZ3JvdW5kKTtcbiAgICAgICAgdmFyIGRyYWdnZWRHcm91cEhlaWdodCA9IHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cC5oZWlnaHQ7XG4gICAgICAgIGlmIChtb3ZpbmdVcCkge1xuICAgICAgICAgIC8vIHNraXAgc3dhcHBpbmcgdGhlIGdyb3VwcyB3aGVuIHRoZSBkcmFnZ2VkIGdyb3VwIGlzIG5vdCBiZWxvdyBjbGllbnRZIGFmdGVyd2FyZHNcbiAgICAgICAgICBpZiAodGFyZ2V0R3JvdXBUb3AgKyBkcmFnZ2VkR3JvdXBIZWlnaHQgPCBjbGllbnRZKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0YXJnZXRHcm91cEhlaWdodCA9IGdyb3VwLmhlaWdodDtcbiAgICAgICAgICAvLyBza2lwIHN3YXBwaW5nIHRoZSBncm91cHMgd2hlbiB0aGUgZHJhZ2dlZCBncm91cCBpcyBub3QgYmVsb3cgY2xpZW50WSBhZnRlcndhcmRzXG4gICAgICAgICAgaWYgKHRhcmdldEdyb3VwVG9wICsgdGFyZ2V0R3JvdXBIZWlnaHQgLSBkcmFnZ2VkR3JvdXBIZWlnaHQgPiBjbGllbnRZKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChncm91cCAmJiBncm91cCAhPSB0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXApIHtcbiAgICAgICAgdmFyIGdyb3Vwc0RhdGEgPSB0aGlzLmdyb3Vwc0RhdGE7XG4gICAgICAgIHZhciB0YXJnZXRHcm91cCA9IGdyb3Vwc0RhdGEuZ2V0KGdyb3VwLmdyb3VwSWQpO1xuICAgICAgICB2YXIgZHJhZ2dlZEdyb3VwID0gZ3JvdXBzRGF0YS5nZXQodGhpcy5ncm91cFRvdWNoUGFyYW1zLmdyb3VwLmdyb3VwSWQpO1xuXG4gICAgICAgIC8vIHN3aXRjaCBncm91cHNcbiAgICAgICAgaWYgKGRyYWdnZWRHcm91cCAmJiB0YXJnZXRHcm91cCkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5ncm91cE9yZGVyU3dhcChkcmFnZ2VkR3JvdXAsIHRhcmdldEdyb3VwLCB0aGlzLmdyb3Vwc0RhdGEpO1xuICAgICAgICAgIHRoaXMuZ3JvdXBzRGF0YS51cGRhdGUoZHJhZ2dlZEdyb3VwKTtcbiAgICAgICAgICB0aGlzLmdyb3Vwc0RhdGEudXBkYXRlKHRhcmdldEdyb3VwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZldGNoIGN1cnJlbnQgb3JkZXIgb2YgZ3JvdXBzXG4gICAgICAgIHZhciBuZXdPcmRlciA9IHRoaXMuZ3JvdXBzRGF0YS5nZXRJZHMoe1xuICAgICAgICAgIG9yZGVyOiB0aGlzLm9wdGlvbnMuZ3JvdXBPcmRlclxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpbiBjYXNlIG9mIGNoYW5nZXMgc2luY2UgX29uR3JvdXBEcmFnU3RhcnRcbiAgICAgICAgaWYgKCF1dGlsLmVxdWFsQXJyYXkobmV3T3JkZXIsIHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5vcmlnaW5hbE9yZGVyKSkge1xuICAgICAgICAgIHZhciBncm91cHNEYXRhID0gdGhpcy5ncm91cHNEYXRhO1xuICAgICAgICAgIHZhciBvcmlnT3JkZXIgPSB0aGlzLmdyb3VwVG91Y2hQYXJhbXMub3JpZ2luYWxPcmRlcjtcbiAgICAgICAgICB2YXIgZHJhZ2dlZElkID0gdGhpcy5ncm91cFRvdWNoUGFyYW1zLmdyb3VwLmdyb3VwSWQ7XG4gICAgICAgICAgdmFyIG51bUdyb3VwcyA9IE1hdGgubWluKG9yaWdPcmRlci5sZW5ndGgsIG5ld09yZGVyLmxlbmd0aCk7XG4gICAgICAgICAgdmFyIGN1clBvcyA9IDA7XG4gICAgICAgICAgdmFyIG5ld09mZnNldCA9IDA7XG4gICAgICAgICAgdmFyIG9yZ09mZnNldCA9IDA7XG4gICAgICAgICAgd2hpbGUgKGN1clBvcyA8IG51bUdyb3Vwcykge1xuICAgICAgICAgICAgLy8gYXMgbG9uZyBhcyB0aGUgZ3JvdXBzIGFyZSB3aGVyZSB0aGV5IHNob3VsZCBiZSBzdGVwIGRvd24gYWxvbmcgdGhlIGdyb3VwcyBvcmRlclxuICAgICAgICAgICAgd2hpbGUgKGN1clBvcyArIG5ld09mZnNldCA8IG51bUdyb3VwcyAmJiBjdXJQb3MgKyBvcmdPZmZzZXQgPCBudW1Hcm91cHMgJiYgbmV3T3JkZXJbY3VyUG9zICsgbmV3T2Zmc2V0XSA9PSBvcmlnT3JkZXJbY3VyUG9zICsgb3JnT2Zmc2V0XSkge1xuICAgICAgICAgICAgICBjdXJQb3MrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWxsIG9rXG4gICAgICAgICAgICBpZiAoY3VyUG9zICsgbmV3T2Zmc2V0ID49IG51bUdyb3Vwcykge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm90IGFsbCBva1xuICAgICAgICAgICAgLy8gaWYgZHJhZ2dlZCBncm91cCB3YXMgbW92ZSB1cHdhcmRzIGV2ZXJ5dGhpbmcgYmVsb3cgc2hvdWxkIGhhdmUgYW4gb2Zmc2V0XG4gICAgICAgICAgICBpZiAobmV3T3JkZXJbY3VyUG9zICsgbmV3T2Zmc2V0XSA9PSBkcmFnZ2VkSWQpIHtcbiAgICAgICAgICAgICAgbmV3T2Zmc2V0ID0gMTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBkcmFnZ2VkIGdyb3VwIHdhcyBtb3ZlIGRvd253YXJkcyBldmVyeXRoaW5nIGFib3ZlIHNob3VsZCBoYXZlIGFuIG9mZnNldFxuICAgICAgICAgICAgZWxzZSBpZiAob3JpZ09yZGVyW2N1clBvcyArIG9yZ09mZnNldF0gPT0gZHJhZ2dlZElkKSB7XG4gICAgICAgICAgICAgICAgb3JnT2Zmc2V0ID0gMTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBmb3VuZCBhIGdyb3VwIChhcGFydCBmcm9tIGRyYWdnZWQgZ3JvdXApIHRoYXQgaGFzIHRoZSB3cm9uZyBwb3NpdGlvbiAtPiBzd2l0Y2ggd2l0aCB0aGUgXG4gICAgICAgICAgICAgIC8vIGdyb3VwIGF0IHRoZSBwb3NpdGlvbiB3aGVyZSBvdGhlciBvbmUgc2hvdWxkIGJlLCBmaXggaW5kZXggYXJyYXlzIGFuZCBjb250aW51ZVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzbGlwcGVkUG9zaXRpb24gPSBuZXdPcmRlci5pbmRleE9mKG9yaWdPcmRlcltjdXJQb3MgKyBvcmdPZmZzZXRdKTtcbiAgICAgICAgICAgICAgICAgIHZhciBzd2l0Y2hHcm91cCA9IGdyb3Vwc0RhdGEuZ2V0KG5ld09yZGVyW2N1clBvcyArIG5ld09mZnNldF0pO1xuICAgICAgICAgICAgICAgICAgdmFyIHNob3VsZEJlR3JvdXAgPSBncm91cHNEYXRhLmdldChvcmlnT3JkZXJbY3VyUG9zICsgb3JnT2Zmc2V0XSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZ3JvdXBPcmRlclN3YXAoc3dpdGNoR3JvdXAsIHNob3VsZEJlR3JvdXAsIGdyb3Vwc0RhdGEpO1xuICAgICAgICAgICAgICAgICAgZ3JvdXBzRGF0YS51cGRhdGUoc3dpdGNoR3JvdXApO1xuICAgICAgICAgICAgICAgICAgZ3JvdXBzRGF0YS51cGRhdGUoc2hvdWxkQmVHcm91cCk7XG5cbiAgICAgICAgICAgICAgICAgIHZhciBzd2l0Y2hHcm91cElkID0gbmV3T3JkZXJbY3VyUG9zICsgbmV3T2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgIG5ld09yZGVyW2N1clBvcyArIG5ld09mZnNldF0gPSBvcmlnT3JkZXJbY3VyUG9zICsgb3JnT2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgIG5ld09yZGVyW3NsaXBwZWRQb3NpdGlvbl0gPSBzd2l0Y2hHcm91cElkO1xuXG4gICAgICAgICAgICAgICAgICBjdXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9vbkdyb3VwRHJhZ0VuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZ3JvdXBFZGl0YWJsZS5vcmRlciAmJiB0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXApIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAvLyB1cGRhdGUgZXhpc3RpbmcgZ3JvdXBcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB2YXIgaWQgPSBtZS5ncm91cFRvdWNoUGFyYW1zLmdyb3VwLmdyb3VwSWQ7XG4gICAgICB2YXIgZGF0YXNldCA9IG1lLmdyb3Vwc0RhdGEuZ2V0RGF0YVNldCgpO1xuICAgICAgdmFyIGdyb3VwRGF0YSA9IHV0aWwuZXh0ZW5kKHt9LCBkYXRhc2V0LmdldChpZCkpOyAvLyBjbG9uZSB0aGUgZGF0YVxuICAgICAgbWUub3B0aW9ucy5vbk1vdmVHcm91cChncm91cERhdGEsIGZ1bmN0aW9uIChncm91cERhdGEpIHtcbiAgICAgICAgaWYgKGdyb3VwRGF0YSkge1xuICAgICAgICAgIC8vIGFwcGx5IGNoYW5nZXNcbiAgICAgICAgICBncm91cERhdGFbZGF0YXNldC5fZmllbGRJZF0gPSBpZDsgLy8gZW5zdXJlIHRoZSBncm91cCBjb250YWlucyBpdHMgaWQgKGNhbiBiZSB1bmRlZmluZWQpXG4gICAgICAgICAgZGF0YXNldC51cGRhdGUoZ3JvdXBEYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIC8vIGZldGNoIGN1cnJlbnQgb3JkZXIgb2YgZ3JvdXBzXG4gICAgICAgICAgdmFyIG5ld09yZGVyID0gZGF0YXNldC5nZXRJZHMoe1xuICAgICAgICAgICAgb3JkZXI6IG1lLm9wdGlvbnMuZ3JvdXBPcmRlclxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCBvcmRlclxuICAgICAgICAgIGlmICghdXRpbC5lcXVhbEFycmF5KG5ld09yZGVyLCBtZS5ncm91cFRvdWNoUGFyYW1zLm9yaWdpbmFsT3JkZXIpKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ09yZGVyID0gbWUuZ3JvdXBUb3VjaFBhcmFtcy5vcmlnaW5hbE9yZGVyO1xuICAgICAgICAgICAgdmFyIG51bUdyb3VwcyA9IE1hdGgubWluKG9yaWdPcmRlci5sZW5ndGgsIG5ld09yZGVyLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgY3VyUG9zID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJQb3MgPCBudW1Hcm91cHMpIHtcbiAgICAgICAgICAgICAgLy8gYXMgbG9uZyBhcyB0aGUgZ3JvdXBzIGFyZSB3aGVyZSB0aGV5IHNob3VsZCBiZSBzdGVwIGRvd24gYWxvbmcgdGhlIGdyb3VwcyBvcmRlclxuICAgICAgICAgICAgICB3aGlsZSAoY3VyUG9zIDwgbnVtR3JvdXBzICYmIG5ld09yZGVyW2N1clBvc10gPT0gb3JpZ09yZGVyW2N1clBvc10pIHtcbiAgICAgICAgICAgICAgICBjdXJQb3MrKztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGFsbCBva1xuICAgICAgICAgICAgICBpZiAoY3VyUG9zID49IG51bUdyb3Vwcykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gZm91bmQgYSBncm91cCB0aGF0IGhhcyB0aGUgd3JvbmcgcG9zaXRpb24gLT4gc3dpdGNoIHdpdGggdGhlIFxuICAgICAgICAgICAgICAvLyBncm91cCBhdCB0aGUgcG9zaXRpb24gd2hlcmUgb3RoZXIgb25lIHNob3VsZCBiZSwgZml4IGluZGV4IGFycmF5cyBhbmQgY29udGludWVcbiAgICAgICAgICAgICAgdmFyIHNsaXBwZWRQb3NpdGlvbiA9IG5ld09yZGVyLmluZGV4T2Yob3JpZ09yZGVyW2N1clBvc10pO1xuICAgICAgICAgICAgICB2YXIgc3dpdGNoR3JvdXAgPSBkYXRhc2V0LmdldChuZXdPcmRlcltjdXJQb3NdKTtcbiAgICAgICAgICAgICAgdmFyIHNob3VsZEJlR3JvdXAgPSBkYXRhc2V0LmdldChvcmlnT3JkZXJbY3VyUG9zXSk7XG4gICAgICAgICAgICAgIG1lLm9wdGlvbnMuZ3JvdXBPcmRlclN3YXAoc3dpdGNoR3JvdXAsIHNob3VsZEJlR3JvdXAsIGRhdGFzZXQpO1xuICAgICAgICAgICAgICBncm91cHNEYXRhLnVwZGF0ZShzd2l0Y2hHcm91cCk7XG4gICAgICAgICAgICAgIGdyb3Vwc0RhdGEudXBkYXRlKHNob3VsZEJlR3JvdXApO1xuXG4gICAgICAgICAgICAgIHZhciBzd2l0Y2hHcm91cElkID0gbmV3T3JkZXJbY3VyUG9zXTtcbiAgICAgICAgICAgICAgbmV3T3JkZXJbY3VyUG9zXSA9IG9yaWdPcmRlcltjdXJQb3NdO1xuICAgICAgICAgICAgICBuZXdPcmRlcltzbGlwcGVkUG9zaXRpb25dID0gc3dpdGNoR3JvdXBJZDtcblxuICAgICAgICAgICAgICBjdXJQb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBtZS5ib2R5LmVtaXR0ZXIuZW1pdCgnZ3JvdXBEcmFnZ2VkJywgeyBncm91cElkOiBpZCB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBzZWxlY3RpbmcvZGVzZWxlY3RpbmcgYW4gaXRlbSB3aGVuIHRhcHBpbmcgaXRcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9vblNlbGVjdEl0ZW0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zZWxlY3RhYmxlKSByZXR1cm47XG5cbiAgICB2YXIgY3RybEtleSA9IGV2ZW50LnNyY0V2ZW50ICYmIChldmVudC5zcmNFdmVudC5jdHJsS2V5IHx8IGV2ZW50LnNyY0V2ZW50Lm1ldGFLZXkpO1xuICAgIHZhciBzaGlmdEtleSA9IGV2ZW50LnNyY0V2ZW50ICYmIGV2ZW50LnNyY0V2ZW50LnNoaWZ0S2V5O1xuICAgIGlmIChjdHJsS2V5IHx8IHNoaWZ0S2V5KSB7XG4gICAgICB0aGlzLl9vbk11bHRpU2VsZWN0SXRlbShldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9sZFNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICB2YXIgaXRlbSA9IHRoaXMuaXRlbUZyb21UYXJnZXQoZXZlbnQpO1xuICAgIHZhciBzZWxlY3Rpb24gPSBpdGVtID8gW2l0ZW0uaWRdIDogW107XG4gICAgdGhpcy5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcblxuICAgIHZhciBuZXdTZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuXG4gICAgLy8gZW1pdCBhIHNlbGVjdCBldmVudCxcbiAgICAvLyBleGNlcHQgd2hlbiBvbGQgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCBuZXcgc2VsZWN0aW9uIGlzIHN0aWxsIGVtcHR5XG4gICAgaWYgKG5ld1NlbGVjdGlvbi5sZW5ndGggPiAwIHx8IG9sZFNlbGVjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzZWxlY3QnLCB7XG4gICAgICAgIGl0ZW1zOiBuZXdTZWxlY3Rpb24sXG4gICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgaG92ZXJpbmcgYW4gaXRlbVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX29uTW91c2VPdmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1Gcm9tVGFyZ2V0KGV2ZW50KTtcbiAgICBpZiAoIWl0ZW0pIHJldHVybjtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdpdGVtb3ZlcicsIHtcbiAgICAgIGl0ZW06IGl0ZW0uaWQsXG4gICAgICBldmVudDogZXZlbnRcbiAgICB9KTtcbiAgfTtcbiAgSXRlbVNldC5wcm90b3R5cGUuX29uTW91c2VPdXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgaXRlbSA9IHRoaXMuaXRlbUZyb21UYXJnZXQoZXZlbnQpO1xuICAgIGlmICghaXRlbSkgcmV0dXJuO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2l0ZW1vdXQnLCB7XG4gICAgICBpdGVtOiBpdGVtLmlkLFxuICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBjcmVhdGlvbiBhbmQgdXBkYXRlcyBvZiBhbiBpdGVtIG9uIGRvdWJsZSB0YXBcbiAgICogQHBhcmFtIGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fb25BZGRJdGVtID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2VsZWN0YWJsZSkgcmV0dXJuO1xuICAgIGlmICghdGhpcy5vcHRpb25zLmVkaXRhYmxlLmFkZCkgcmV0dXJuO1xuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgc25hcCA9IHRoaXMub3B0aW9ucy5zbmFwIHx8IG51bGw7XG4gICAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1Gcm9tVGFyZ2V0KGV2ZW50KTtcblxuICAgIGlmIChpdGVtKSB7XG4gICAgICAvLyB1cGRhdGUgaXRlbVxuXG4gICAgICAvLyBleGVjdXRlIGFzeW5jIGhhbmRsZXIgdG8gdXBkYXRlIHRoZSBpdGVtIChvciBjYW5jZWwgaXQpXG4gICAgICB2YXIgaXRlbURhdGEgPSBtZS5pdGVtc0RhdGEuZ2V0KGl0ZW0uaWQpOyAvLyBnZXQgYSBjbG9uZSBvZiB0aGUgZGF0YSBmcm9tIHRoZSBkYXRhc2V0XG4gICAgICB0aGlzLm9wdGlvbnMub25VcGRhdGUoaXRlbURhdGEsIGZ1bmN0aW9uIChpdGVtRGF0YSkge1xuICAgICAgICBpZiAoaXRlbURhdGEpIHtcbiAgICAgICAgICBtZS5pdGVtc0RhdGEuZ2V0RGF0YVNldCgpLnVwZGF0ZShpdGVtRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhZGQgaXRlbVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgdmFyIHhBYnMgPSB1dGlsLmdldEFic29sdXRlUmlnaHQodGhpcy5kb20uZnJhbWUpO1xuICAgICAgICB2YXIgeCA9IHhBYnMgLSBldmVudC5jZW50ZXIueDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB4QWJzID0gdXRpbC5nZXRBYnNvbHV0ZUxlZnQodGhpcy5kb20uZnJhbWUpO1xuICAgICAgICB2YXIgeCA9IGV2ZW50LmNlbnRlci54IC0geEFicztcbiAgICAgIH1cbiAgICAgIC8vIHZhciB4QWJzID0gdXRpbC5nZXRBYnNvbHV0ZUxlZnQodGhpcy5kb20uZnJhbWUpO1xuICAgICAgLy8gdmFyIHggPSBldmVudC5jZW50ZXIueCAtIHhBYnM7XG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLmJvZHkudXRpbC50b1RpbWUoeCk7XG4gICAgICB2YXIgc2NhbGUgPSB0aGlzLmJvZHkudXRpbC5nZXRTY2FsZSgpO1xuICAgICAgdmFyIHN0ZXAgPSB0aGlzLmJvZHkudXRpbC5nZXRTdGVwKCk7XG5cbiAgICAgIHZhciBuZXdJdGVtRGF0YSA9IHtcbiAgICAgICAgc3RhcnQ6IHNuYXAgPyBzbmFwKHN0YXJ0LCBzY2FsZSwgc3RlcCkgOiBzdGFydCxcbiAgICAgICAgY29udGVudDogJ25ldyBpdGVtJ1xuICAgICAgfTtcblxuICAgICAgaWYgKGV2ZW50LnR5cGUgPT0gJ2Ryb3AnKSB7XG4gICAgICAgIHZhciBpdGVtRGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpKTtcbiAgICAgICAgbmV3SXRlbURhdGEuY29udGVudCA9IGl0ZW1EYXRhLmNvbnRlbnQ7IC8vIGNvbnRlbnQgaXMgcmVxdWlyZWQgXG4gICAgICAgIG5ld0l0ZW1EYXRhLnR5cGUgPSBpdGVtRGF0YS50eXBlIHx8ICdib3gnO1xuICAgICAgICBuZXdJdGVtRGF0YVt0aGlzLml0ZW1zRGF0YS5fZmllbGRJZF0gPSBpdGVtRGF0YS5pZCB8fCB1dGlsLnJhbmRvbVVVSUQoKTtcblxuICAgICAgICBpZiAoaXRlbURhdGEudHlwZSA9PSAncmFuZ2UnIHx8IGl0ZW1EYXRhLmVuZCAmJiBpdGVtRGF0YS5zdGFydCkge1xuXG4gICAgICAgICAgaWYgKCFpdGVtRGF0YS5lbmQpIHtcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLmJvZHkudXRpbC50b1RpbWUoeCArIHRoaXMucHJvcHMud2lkdGggLyA1KTtcbiAgICAgICAgICAgIG5ld0l0ZW1EYXRhLmVuZCA9IHNuYXAgPyBzbmFwKGVuZCwgc2NhbGUsIHN0ZXApIDogZW5kO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdJdGVtRGF0YS5lbmQgPSBuZXcgRGF0ZShuZXdJdGVtRGF0YS5zdGFydC5faSkuZ2V0VGltZSgpICsgbmV3IERhdGUoaXRlbURhdGEuZW5kKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShpdGVtRGF0YS5zdGFydCkuZ2V0VGltZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3SXRlbURhdGFbdGhpcy5pdGVtc0RhdGEuX2ZpZWxkSWRdID0gdXRpbC5yYW5kb21VVUlEKCk7XG5cbiAgICAgICAgLy8gd2hlbiBkZWZhdWx0IHR5cGUgaXMgYSByYW5nZSwgYWRkIGEgZGVmYXVsdCBlbmQgZGF0ZSB0byB0aGUgbmV3IGl0ZW1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50eXBlID09PSAncmFuZ2UnKSB7XG4gICAgICAgICAgdmFyIGVuZCA9IHRoaXMuYm9keS51dGlsLnRvVGltZSh4ICsgdGhpcy5wcm9wcy53aWR0aCAvIDUpO1xuICAgICAgICAgIG5ld0l0ZW1EYXRhLmVuZCA9IHNuYXAgPyBzbmFwKGVuZCwgc2NhbGUsIHN0ZXApIDogZW5kO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXBGcm9tVGFyZ2V0KGV2ZW50KTtcbiAgICAgIGlmIChncm91cCkge1xuICAgICAgICBuZXdJdGVtRGF0YS5ncm91cCA9IGdyb3VwLmdyb3VwSWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIGV4ZWN1dGUgYXN5bmMgaGFuZGxlciB0byBjdXN0b21pemUgKG9yIGNhbmNlbCkgYWRkaW5nIGFuIGl0ZW1cbiAgICAgIG5ld0l0ZW1EYXRhID0gdGhpcy5fY2xvbmVJdGVtRGF0YShuZXdJdGVtRGF0YSk7IC8vIGNvbnZlcnQgc3RhcnQgYW5kIGVuZCB0byB0aGUgY29ycmVjdCB0eXBlXG4gICAgICB0aGlzLm9wdGlvbnMub25BZGQobmV3SXRlbURhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgbWUuaXRlbXNEYXRhLmdldERhdGFTZXQoKS5hZGQoaXRlbSk7XG4gICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT0gJ2Ryb3AnKSB7XG4gICAgICAgICAgICBtZS5zZXRTZWxlY3Rpb24oW2l0ZW0uaWRdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVE9ETzogbmVlZCB0byB0cmlnZ2VyIGEgcmVkcmF3P1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBzZWxlY3RpbmcvZGVzZWxlY3RpbmcgbXVsdGlwbGUgaXRlbXMgd2hlbiBob2xkaW5nIGFuIGl0ZW1cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9vbk11bHRpU2VsZWN0SXRlbSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLnNlbGVjdGFibGUpIHJldHVybjtcblxuICAgIHZhciBpdGVtID0gdGhpcy5pdGVtRnJvbVRhcmdldChldmVudCk7XG5cbiAgICBpZiAoaXRlbSkge1xuICAgICAgLy8gbXVsdGkgc2VsZWN0IGl0ZW1zIChpZiBhbGxvd2VkKVxuXG4gICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5vcHRpb25zLm11bHRpc2VsZWN0ID8gdGhpcy5nZXRTZWxlY3Rpb24oKSAvLyB0YWtlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICA6IFtdOyAvLyBkZXNlbGVjdCBjdXJyZW50IHNlbGVjdGlvblxuXG4gICAgICB2YXIgc2hpZnRLZXkgPSBldmVudC5zcmNFdmVudCAmJiBldmVudC5zcmNFdmVudC5zaGlmdEtleSB8fCBmYWxzZTtcblxuICAgICAgaWYgKHNoaWZ0S2V5ICYmIHRoaXMub3B0aW9ucy5tdWx0aXNlbGVjdCkge1xuICAgICAgICAvLyBzZWxlY3QgYWxsIGl0ZW1zIGJldHdlZW4gdGhlIG9sZCBzZWxlY3Rpb24gYW5kIHRoZSB0YXBwZWQgaXRlbVxuICAgICAgICB2YXIgaXRlbUdyb3VwID0gdGhpcy5pdGVtc0RhdGEuZ2V0KGl0ZW0uaWQpLmdyb3VwO1xuXG4gICAgICAgIC8vIHdoZW4gZmlsdGVyaW5nIGdldCB0aGUgZ3JvdXAgb2YgdGhlIGxhc3Qgc2VsZWN0ZWQgaXRlbVxuICAgICAgICB2YXIgbGFzdFNlbGVjdGVkR3JvdXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubXVsdGlzZWxlY3RQZXJHcm91cCkge1xuICAgICAgICAgIGlmIChzZWxlY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGFzdFNlbGVjdGVkR3JvdXAgPSB0aGlzLml0ZW1zRGF0YS5nZXQoc2VsZWN0aW9uWzBdKS5ncm91cDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIHNlbGVjdGlvbiByYW5nZVxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5tdWx0aXNlbGVjdFBlckdyb3VwIHx8IGxhc3RTZWxlY3RlZEdyb3VwID09IHVuZGVmaW5lZCB8fCBsYXN0U2VsZWN0ZWRHcm91cCA9PSBpdGVtR3JvdXApIHtcbiAgICAgICAgICBzZWxlY3Rpb24ucHVzaChpdGVtLmlkKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZ2UgPSBJdGVtU2V0Ll9nZXRJdGVtUmFuZ2UodGhpcy5pdGVtc0RhdGEuZ2V0KHNlbGVjdGlvbiwgdGhpcy5pdGVtT3B0aW9ucykpO1xuXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLm11bHRpc2VsZWN0UGVyR3JvdXAgfHwgbGFzdFNlbGVjdGVkR3JvdXAgPT0gaXRlbUdyb3VwKSB7XG4gICAgICAgICAgLy8gc2VsZWN0IGFsbCBpdGVtcyB3aXRoaW4gdGhlIHNlbGVjdGlvbiByYW5nZVxuICAgICAgICAgIHNlbGVjdGlvbiA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICB2YXIgX2l0ZW0gPSB0aGlzLml0ZW1zW2lkXTtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gX2l0ZW0uZGF0YS5zdGFydDtcbiAgICAgICAgICAgICAgdmFyIGVuZCA9IF9pdGVtLmRhdGEuZW5kICE9PSB1bmRlZmluZWQgPyBfaXRlbS5kYXRhLmVuZCA6IHN0YXJ0O1xuXG4gICAgICAgICAgICAgIGlmIChzdGFydCA+PSByYW5nZS5taW4gJiYgZW5kIDw9IHJhbmdlLm1heCAmJiAoIXRoaXMub3B0aW9ucy5tdWx0aXNlbGVjdFBlckdyb3VwIHx8IGxhc3RTZWxlY3RlZEdyb3VwID09IHRoaXMuaXRlbXNEYXRhLmdldChfaXRlbS5pZCkuZ3JvdXApICYmICEoX2l0ZW0gaW5zdGFuY2VvZiBCYWNrZ3JvdW5kSXRlbSkpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24ucHVzaChfaXRlbS5pZCk7IC8vIGRvIG5vdCB1c2UgaWQgYnV0IGl0ZW0uaWQsIGlkIGl0c2VsZiBpcyBzdHJpbmdpZmllZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhZGQvcmVtb3ZlIHRoaXMgaXRlbSBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAgICB2YXIgaW5kZXggPSBzZWxlY3Rpb24uaW5kZXhPZihpdGVtLmlkKTtcbiAgICAgICAgaWYgKGluZGV4ID09IC0xKSB7XG4gICAgICAgICAgLy8gaXRlbSBpcyBub3QgeWV0IHNlbGVjdGVkIC0+IHNlbGVjdCBpdFxuICAgICAgICAgIHNlbGVjdGlvbi5wdXNoKGl0ZW0uaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGl0ZW0gaXMgYWxyZWFkeSBzZWxlY3RlZCAtPiBkZXNlbGVjdCBpdFxuICAgICAgICAgIHNlbGVjdGlvbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3NlbGVjdCcsIHtcbiAgICAgICAgaXRlbXM6IHRoaXMuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIHRpbWUgcmFuZ2Ugb2YgYSBsaXN0IG9mIGl0ZW1zXG4gICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGl0ZW1zRGF0YVxuICAgKiBAcmV0dXJuIHt7bWluOiBEYXRlLCBtYXg6IERhdGV9fSBSZXR1cm5zIHRoZSByYW5nZSBvZiB0aGUgcHJvdmlkZWQgaXRlbXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQuX2dldEl0ZW1SYW5nZSA9IGZ1bmN0aW9uIChpdGVtc0RhdGEpIHtcbiAgICB2YXIgbWF4ID0gbnVsbDtcbiAgICB2YXIgbWluID0gbnVsbDtcblxuICAgIGl0ZW1zRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBpZiAobWluID09IG51bGwgfHwgZGF0YS5zdGFydCA8IG1pbikge1xuICAgICAgICBtaW4gPSBkYXRhLnN0YXJ0O1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS5lbmQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChtYXggPT0gbnVsbCB8fCBkYXRhLmVuZCA+IG1heCkge1xuICAgICAgICAgIG1heCA9IGRhdGEuZW5kO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobWF4ID09IG51bGwgfHwgZGF0YS5zdGFydCA+IG1heCkge1xuICAgICAgICAgIG1heCA9IGRhdGEuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBtaW46IG1pbixcbiAgICAgIG1heDogbWF4XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogRmluZCBhbiBpdGVtIGZyb20gYW4gZXZlbnQgdGFyZ2V0OlxuICAgKiBzZWFyY2hlcyBmb3IgdGhlIGF0dHJpYnV0ZSAndGltZWxpbmUtaXRlbScgaW4gdGhlIGV2ZW50IHRhcmdldCdzIGVsZW1lbnQgdHJlZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcmV0dXJuIHtJdGVtIHwgbnVsbH0gaXRlbVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuaXRlbUZyb21UYXJnZXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIHdoaWxlICh0YXJnZXQpIHtcbiAgICAgIGlmICh0YXJnZXQuaGFzT3duUHJvcGVydHkoJ3RpbWVsaW5lLWl0ZW0nKSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0Wyd0aW1lbGluZS1pdGVtJ107XG4gICAgICB9XG4gICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogRmluZCB0aGUgR3JvdXAgZnJvbSBhbiBldmVudCB0YXJnZXQ6XG4gICAqIHNlYXJjaGVzIGZvciB0aGUgYXR0cmlidXRlICd0aW1lbGluZS1ncm91cCcgaW4gdGhlIGV2ZW50IHRhcmdldCdzIGVsZW1lbnQgdHJlZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcmV0dXJuIHtHcm91cCB8IG51bGx9IGdyb3VwXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5ncm91cEZyb21UYXJnZXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgY2xpZW50WSA9IGV2ZW50LmNlbnRlciA/IGV2ZW50LmNlbnRlci55IDogZXZlbnQuY2xpZW50WTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ3JvdXBJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBncm91cElkID0gdGhpcy5ncm91cElkc1tpXTtcbiAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXBzW2dyb3VwSWRdO1xuICAgICAgdmFyIGZvcmVncm91bmQgPSBncm91cC5kb20uZm9yZWdyb3VuZDtcbiAgICAgIHZhciB0b3AgPSB1dGlsLmdldEFic29sdXRlVG9wKGZvcmVncm91bmQpO1xuICAgICAgaWYgKGNsaWVudFkgPiB0b3AgJiYgY2xpZW50WSA8IHRvcCArIGZvcmVncm91bmQub2Zmc2V0SGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtID09PSAndG9wJykge1xuICAgICAgICBpZiAoaSA9PT0gdGhpcy5ncm91cElkcy5sZW5ndGggLSAxICYmIGNsaWVudFkgPiB0b3ApIHtcbiAgICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpID09PSAwICYmIGNsaWVudFkgPCB0b3AgKyBmb3JlZ3JvdW5kLm9mZnNldCkge1xuICAgICAgICAgIHJldHVybiBncm91cDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBJdGVtU2V0IGZyb20gYW4gZXZlbnQgdGFyZ2V0OlxuICAgKiBzZWFyY2hlcyBmb3IgdGhlIGF0dHJpYnV0ZSAndGltZWxpbmUtaXRlbXNldCcgaW4gdGhlIGV2ZW50IHRhcmdldCdzIGVsZW1lbnQgdHJlZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcmV0dXJuIHtJdGVtU2V0IHwgbnVsbH0gaXRlbVxuICAgKi9cbiAgSXRlbVNldC5pdGVtU2V0RnJvbVRhcmdldCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgd2hpbGUgKHRhcmdldCkge1xuICAgICAgaWYgKHRhcmdldC5oYXNPd25Qcm9wZXJ0eSgndGltZWxpbmUtaXRlbXNldCcpKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRbJ3RpbWVsaW5lLWl0ZW1zZXQnXTtcbiAgICAgIH1cbiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbG9uZSB0aGUgZGF0YSBvZiBhbiBpdGVtLCBhbmQgXCJub3JtYWxpemVcIiBpdDogY29udmVydCB0aGUgc3RhcnQgYW5kIGVuZCBkYXRlXG4gICAqIHRvIHRoZSB0eXBlIChEYXRlLCBNb21lbnQsIC4uLikgY29uZmlndXJlZCBpbiB0aGUgRGF0YVNldC4gSWYgbm90IGNvbmZpZ3VyZWQsXG4gICAqIHN0YXJ0IGFuZCBlbmQgYXJlIGNvbnZlcnRlZCB0byBEYXRlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbURhdGEsIHR5cGljYWxseSBgaXRlbS5kYXRhYFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdICBPcHRpb25hbCBEYXRlIHR5cGUuIElmIG5vdCBwcm92aWRlZCwgdGhlIHR5cGUgZnJvbSB0aGUgRGF0YVNldCBpcyB0YWtlblxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZWQgb2JqZWN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fY2xvbmVJdGVtRGF0YSA9IGZ1bmN0aW9uIChpdGVtRGF0YSwgdHlwZSkge1xuICAgIHZhciBjbG9uZSA9IHV0aWwuZXh0ZW5kKHt9LCBpdGVtRGF0YSk7XG5cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIC8vIGNvbnZlcnQgc3RhcnQgYW5kIGVuZCBkYXRlIHRvIHRoZSB0eXBlIChEYXRlLCBNb21lbnQsIC4uLikgY29uZmlndXJlZCBpbiB0aGUgRGF0YVNldFxuICAgICAgdHlwZSA9IHRoaXMuaXRlbXNEYXRhLmdldERhdGFTZXQoKS5fb3B0aW9ucy50eXBlO1xuICAgIH1cblxuICAgIGlmIChjbG9uZS5zdGFydCAhPSB1bmRlZmluZWQpIHtcbiAgICAgIGNsb25lLnN0YXJ0ID0gdXRpbC5jb252ZXJ0KGNsb25lLnN0YXJ0LCB0eXBlICYmIHR5cGUuc3RhcnQgfHwgJ0RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGNsb25lLmVuZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgIGNsb25lLmVuZCA9IHV0aWwuY29udmVydChjbG9uZS5lbmQsIHR5cGUgJiYgdHlwZS5lbmQgfHwgJ0RhdGUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmU7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBJdGVtU2V0O1xuXG4vKioqLyB9LFxuLyogMzcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbiAgdmFyIERhdGVVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yICBUaW1lU3RlcFxuICAgKiBUaGUgY2xhc3MgVGltZVN0ZXAgaXMgYW4gaXRlcmF0b3IgZm9yIGRhdGVzLiBZb3UgcHJvdmlkZSBhIHN0YXJ0IGRhdGUgYW5kIGFuXG4gICAqIGVuZCBkYXRlLiBUaGUgY2xhc3MgaXRzZWxmIGRldGVybWluZXMgdGhlIGJlc3Qgc2NhbGUgKHN0ZXAgc2l6ZSkgYmFzZWQgb24gdGhlXG4gICAqIHByb3ZpZGVkIHN0YXJ0IERhdGUsIGVuZCBEYXRlLCBhbmQgbWluaW11bVN0ZXAuXG4gICAqXG4gICAqIElmIG1pbmltdW1TdGVwIGlzIHByb3ZpZGVkLCB0aGUgc3RlcCBzaXplIGlzIGNob3NlbiBhcyBjbG9zZSBhcyBwb3NzaWJsZVxuICAgKiB0byB0aGUgbWluaW11bVN0ZXAgYnV0IGxhcmdlciB0aGFuIG1pbmltdW1TdGVwLiBJZiBtaW5pbXVtU3RlcCBpcyBub3RcbiAgICogcHJvdmlkZWQsIHRoZSBzY2FsZSBpcyBzZXQgdG8gMSBEQVkuXG4gICAqIFRoZSBtaW5pbXVtU3RlcCBzaG91bGQgY29ycmVzcG9uZCB3aXRoIHRoZSBvbnNjcmVlbiBzaXplIG9mIGFib3V0IDYgY2hhcmFjdGVyc1xuICAgKlxuICAgKiBBbHRlcm5hdGl2ZWx5LCB5b3UgY2FuIHNldCBhIHNjYWxlIGJ5IGhhbmQuXG4gICAqIEFmdGVyIGNyZWF0aW9uLCB5b3UgY2FuIGluaXRpYWxpemUgdGhlIGNsYXNzIGJ5IGV4ZWN1dGluZyBmaXJzdCgpLiBUaGVuIHlvdVxuICAgKiBjYW4gaXRlcmF0ZSBmcm9tIHRoZSBzdGFydCBkYXRlIHRvIHRoZSBlbmQgZGF0ZSB2aWEgbmV4dCgpLiBZb3UgY2FuIGNoZWNrIGlmXG4gICAqIHRoZSBlbmQgZGF0ZSBpcyByZWFjaGVkIHdpdGggdGhlIGZ1bmN0aW9uIGhhc05leHQoKS4gQWZ0ZXIgZWFjaCBzdGVwLCB5b3UgY2FuXG4gICAqIHJldHJpZXZlIHRoZSBjdXJyZW50IGRhdGUgdmlhIGdldEN1cnJlbnQoKS5cbiAgICogVGhlIFRpbWVTdGVwIGhhcyBzY2FsZXMgcmFuZ2luZyBmcm9tIG1pbGxpc2Vjb25kcywgc2Vjb25kcywgbWludXRlcywgaG91cnMsXG4gICAqIGRheXMsIHRvIHllYXJzLlxuICAgKlxuICAgKiBWZXJzaW9uOiAxLjJcbiAgICpcbiAgICogQHBhcmFtIHtEYXRlfSBbc3RhcnRdICAgICAgICAgVGhlIHN0YXJ0IGRhdGUsIGZvciBleGFtcGxlIG5ldyBEYXRlKDIwMTAsIDksIDIxKVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBuZXcgRGF0ZSgyMDEwLCA5LCAyMSwgMjMsIDQ1LCAwMClcbiAgICogQHBhcmFtIHtEYXRlfSBbZW5kXSAgICAgICAgICAgVGhlIGVuZCBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbWluaW11bVN0ZXBdIE9wdGlvbmFsLiBNaW5pbXVtIHN0ZXAgc2l6ZSBpbiBtaWxsaXNlY29uZHNcbiAgICovXG4gIGZ1bmN0aW9uIFRpbWVTdGVwKHN0YXJ0LCBlbmQsIG1pbmltdW1TdGVwLCBoaWRkZW5EYXRlcykge1xuICAgIHRoaXMubW9tZW50ID0gbW9tZW50O1xuXG4gICAgLy8gdmFyaWFibGVzXG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5tb21lbnQoKTtcbiAgICB0aGlzLl9zdGFydCA9IHRoaXMubW9tZW50KCk7XG4gICAgdGhpcy5fZW5kID0gdGhpcy5tb21lbnQoKTtcblxuICAgIHRoaXMuYXV0b1NjYWxlID0gdHJ1ZTtcbiAgICB0aGlzLnNjYWxlID0gJ2RheSc7XG4gICAgdGhpcy5zdGVwID0gMTtcblxuICAgIC8vIGluaXRpYWxpemUgdGhlIHJhbmdlXG4gICAgdGhpcy5zZXRSYW5nZShzdGFydCwgZW5kLCBtaW5pbXVtU3RlcCk7XG5cbiAgICAvLyBoaWRkZW4gRGF0ZXMgb3B0aW9uc1xuICAgIHRoaXMuc3dpdGNoZWREYXkgPSBmYWxzZTtcbiAgICB0aGlzLnN3aXRjaGVkTW9udGggPSBmYWxzZTtcbiAgICB0aGlzLnN3aXRjaGVkWWVhciA9IGZhbHNlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhpZGRlbkRhdGVzKSkge1xuICAgICAgdGhpcy5oaWRkZW5EYXRlcyA9IGhpZGRlbkRhdGVzO1xuICAgIH0gZWxzZSBpZiAoaGlkZGVuRGF0ZXMgIT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmhpZGRlbkRhdGVzID0gW2hpZGRlbkRhdGVzXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRkZW5EYXRlcyA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMuZm9ybWF0ID0gVGltZVN0ZXAuRk9STUFUOyAvLyBkZWZhdWx0IGZvcm1hdHRpbmdcbiAgfVxuXG4gIC8vIFRpbWUgZm9ybWF0dGluZ1xuICBUaW1lU3RlcC5GT1JNQVQgPSB7XG4gICAgbWlub3JMYWJlbHM6IHtcbiAgICAgIG1pbGxpc2Vjb25kOiAnU1NTJyxcbiAgICAgIHNlY29uZDogJ3MnLFxuICAgICAgbWludXRlOiAnSEg6bW0nLFxuICAgICAgaG91cjogJ0hIOm1tJyxcbiAgICAgIHdlZWtkYXk6ICdkZGQgRCcsXG4gICAgICBkYXk6ICdEJyxcbiAgICAgIG1vbnRoOiAnTU1NJyxcbiAgICAgIHllYXI6ICdZWVlZJ1xuICAgIH0sXG4gICAgbWFqb3JMYWJlbHM6IHtcbiAgICAgIG1pbGxpc2Vjb25kOiAnSEg6bW06c3MnLFxuICAgICAgc2Vjb25kOiAnRCBNTU1NIEhIOm1tJyxcbiAgICAgIG1pbnV0ZTogJ2RkZCBEIE1NTU0nLFxuICAgICAgaG91cjogJ2RkZCBEIE1NTU0nLFxuICAgICAgd2Vla2RheTogJ01NTU0gWVlZWScsXG4gICAgICBkYXk6ICdNTU1NIFlZWVknLFxuICAgICAgbW9udGg6ICdZWVlZJyxcbiAgICAgIHllYXI6ICcnXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgY3VzdG9tIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciBtb21lbnQuIENhbiBiZSB1c2VkIHRvIHNldCBkYXRlc1xuICAgKiB0byBVVEMgb3IgdG8gc2V0IGEgdXRjT2Zmc2V0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtb21lbnRcbiAgICovXG4gIFRpbWVTdGVwLnByb3RvdHlwZS5zZXRNb21lbnQgPSBmdW5jdGlvbiAobW9tZW50KSB7XG4gICAgdGhpcy5tb21lbnQgPSBtb21lbnQ7XG5cbiAgICAvLyB1cGRhdGUgdGhlIGRhdGUgcHJvcGVydGllcywgY2FuIGhhdmUgYSBuZXcgdXRjT2Zmc2V0XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5tb21lbnQodGhpcy5jdXJyZW50LnZhbHVlT2YoKSk7XG4gICAgdGhpcy5fc3RhcnQgPSB0aGlzLm1vbWVudCh0aGlzLl9zdGFydC52YWx1ZU9mKCkpO1xuICAgIHRoaXMuX2VuZCA9IHRoaXMubW9tZW50KHRoaXMuX2VuZC52YWx1ZU9mKCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgY3VzdG9tIGZvcm1hdHRpbmcgZm9yIHRoZSBtaW5vciBhbiBtYWpvciBsYWJlbHMgb2YgdGhlIFRpbWVTdGVwLlxuICAgKiBCb3RoIGBtaW5vckxhYmVsc2AgYW5kIGBtYWpvckxhYmVsc2AgYXJlIGFuIE9iamVjdCB3aXRoIHByb3BlcnRpZXM6XG4gICAqICdtaWxsaXNlY29uZCcsICdzZWNvbmQnLCAnbWludXRlJywgJ2hvdXInLCAnd2Vla2RheScsICdkYXknLCAnbW9udGgnLCAneWVhcicuXG4gICAqIEBwYXJhbSB7e21pbm9yTGFiZWxzOiBPYmplY3QsIG1ham9yTGFiZWxzOiBPYmplY3R9fSBmb3JtYXRcbiAgICovXG4gIFRpbWVTdGVwLnByb3RvdHlwZS5zZXRGb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgdmFyIGRlZmF1bHRGb3JtYXQgPSB1dGlsLmRlZXBFeHRlbmQoe30sIFRpbWVTdGVwLkZPUk1BVCk7XG4gICAgdGhpcy5mb3JtYXQgPSB1dGlsLmRlZXBFeHRlbmQoZGVmYXVsdEZvcm1hdCwgZm9ybWF0KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgbmV3IHJhbmdlXG4gICAqIElmIG1pbmltdW1TdGVwIGlzIHByb3ZpZGVkLCB0aGUgc3RlcCBzaXplIGlzIGNob3NlbiBhcyBjbG9zZSBhcyBwb3NzaWJsZVxuICAgKiB0byB0aGUgbWluaW11bVN0ZXAgYnV0IGxhcmdlciB0aGFuIG1pbmltdW1TdGVwLiBJZiBtaW5pbXVtU3RlcCBpcyBub3RcbiAgICogcHJvdmlkZWQsIHRoZSBzY2FsZSBpcyBzZXQgdG8gMSBEQVkuXG4gICAqIFRoZSBtaW5pbXVtU3RlcCBzaG91bGQgY29ycmVzcG9uZCB3aXRoIHRoZSBvbnNjcmVlbiBzaXplIG9mIGFib3V0IDYgY2hhcmFjdGVyc1xuICAgKiBAcGFyYW0ge0RhdGV9IFtzdGFydF0gICAgICBUaGUgc3RhcnQgZGF0ZSBhbmQgdGltZS5cbiAgICogQHBhcmFtIHtEYXRlfSBbZW5kXSAgICAgICAgVGhlIGVuZCBkYXRlIGFuZCB0aW1lLlxuICAgKiBAcGFyYW0ge2ludH0gW21pbmltdW1TdGVwXSBPcHRpb25hbC4gTWluaW11bSBzdGVwIHNpemUgaW4gbWlsbGlzZWNvbmRzXG4gICAqL1xuICBUaW1lU3RlcC5wcm90b3R5cGUuc2V0UmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgbWluaW11bVN0ZXApIHtcbiAgICBpZiAoIShzdGFydCBpbnN0YW5jZW9mIERhdGUpIHx8ICEoZW5kIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgIHRocm93IFwiTm8gbGVnYWwgc3RhcnQgb3IgZW5kIGRhdGUgaW4gbWV0aG9kIHNldFJhbmdlXCI7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhcnQgPSBzdGFydCAhPSB1bmRlZmluZWQgPyB0aGlzLm1vbWVudChzdGFydC52YWx1ZU9mKCkpIDogbmV3IERhdGUoKTtcbiAgICB0aGlzLl9lbmQgPSBlbmQgIT0gdW5kZWZpbmVkID8gdGhpcy5tb21lbnQoZW5kLnZhbHVlT2YoKSkgOiBuZXcgRGF0ZSgpO1xuXG4gICAgaWYgKHRoaXMuYXV0b1NjYWxlKSB7XG4gICAgICB0aGlzLnNldE1pbmltdW1TdGVwKG1pbmltdW1TdGVwKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcmFuZ2UgaXRlcmF0b3IgdG8gdGhlIHN0YXJ0IGRhdGUuXG4gICAqL1xuICBUaW1lU3RlcC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5fc3RhcnQuY2xvbmUoKTtcbiAgICB0aGlzLnJvdW5kVG9NaW5vcigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSb3VuZCB0aGUgY3VycmVudCBkYXRlIHRvIHRoZSBmaXJzdCBtaW5vciBkYXRlIHZhbHVlXG4gICAqIFRoaXMgbXVzdCBiZSBleGVjdXRlZCBvbmNlIHdoZW4gdGhlIGN1cnJlbnQgZGF0ZSBpcyBzZXQgdG8gc3RhcnQgRGF0ZVxuICAgKi9cbiAgVGltZVN0ZXAucHJvdG90eXBlLnJvdW5kVG9NaW5vciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyByb3VuZCB0byBmbG9vclxuICAgIC8vIElNUE9SVEFOVDogd2UgaGF2ZSBubyBicmVha3MgaW4gdGhpcyBzd2l0Y2ghICh0aGlzIGlzIG5vIGJ1ZylcbiAgICAvLyBub2luc3BlY3Rpb24gRmFsbFRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgdGhpcy5jdXJyZW50LnllYXIodGhpcy5zdGVwICogTWF0aC5mbG9vcih0aGlzLmN1cnJlbnQueWVhcigpIC8gdGhpcy5zdGVwKSk7XG4gICAgICAgIHRoaXMuY3VycmVudC5tb250aCgwKTtcbiAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgdGhpcy5jdXJyZW50LmRhdGUoMSk7XG4gICAgICBjYXNlICdkYXknOiAvLyBpbnRlbnRpb25hbCBmYWxsIHRocm91Z2hcbiAgICAgIGNhc2UgJ3dlZWtkYXknOlxuICAgICAgICB0aGlzLmN1cnJlbnQuaG91cnMoMCk7XG4gICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgdGhpcy5jdXJyZW50Lm1pbnV0ZXMoMCk7XG4gICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICB0aGlzLmN1cnJlbnQuc2Vjb25kcygwKTtcbiAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgIHRoaXMuY3VycmVudC5taWxsaXNlY29uZHMoMCk7XG4gICAgICAvL2Nhc2UgJ21pbGxpc2Vjb25kJzogLy8gbm90aGluZyB0byBkbyBmb3IgbWlsbGlzZWNvbmRzXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RlcCAhPSAxKSB7XG4gICAgICAvLyByb3VuZCBkb3duIHRvIHRoZSBmaXJzdCBtaW5vciB2YWx1ZSB0aGF0IGlzIGEgbXVsdGlwbGUgb2YgdGhlIGN1cnJlbnQgc3RlcCBzaXplXG4gICAgICBzd2l0Y2ggKHRoaXMuc2NhbGUpIHtcbiAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5zdWJ0cmFjdCh0aGlzLmN1cnJlbnQubWlsbGlzZWNvbmRzKCkgJSB0aGlzLnN0ZXAsICdtaWxsaXNlY29uZHMnKTticmVhaztcbiAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuc3VidHJhY3QodGhpcy5jdXJyZW50LnNlY29uZHMoKSAlIHRoaXMuc3RlcCwgJ3NlY29uZHMnKTticmVhaztcbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuc3VidHJhY3QodGhpcy5jdXJyZW50Lm1pbnV0ZXMoKSAlIHRoaXMuc3RlcCwgJ21pbnV0ZXMnKTticmVhaztcbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LnN1YnRyYWN0KHRoaXMuY3VycmVudC5ob3VycygpICUgdGhpcy5zdGVwLCAnaG91cnMnKTticmVhaztcbiAgICAgICAgY2FzZSAnd2Vla2RheSc6IC8vIGludGVudGlvbmFsIGZhbGwgdGhyb3VnaFxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5zdWJ0cmFjdCgodGhpcy5jdXJyZW50LmRhdGUoKSAtIDEpICUgdGhpcy5zdGVwLCAnZGF5Jyk7YnJlYWs7XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuc3VidHJhY3QodGhpcy5jdXJyZW50Lm1vbnRoKCkgJSB0aGlzLnN0ZXAsICdtb250aCcpO2JyZWFrO1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuc3VidHJhY3QodGhpcy5jdXJyZW50LnllYXIoKSAlIHRoaXMuc3RlcCwgJ3llYXInKTticmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSB0aGVyZSBpcyBhIG5leHQgc3RlcFxuICAgKiBAcmV0dXJuIHtib29sZWFufSAgdHJ1ZSBpZiB0aGUgY3VycmVudCBkYXRlIGhhcyBub3QgcGFzc2VkIHRoZSBlbmQgZGF0ZVxuICAgKi9cbiAgVGltZVN0ZXAucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudC52YWx1ZU9mKCkgPD0gdGhpcy5fZW5kLnZhbHVlT2YoKTtcbiAgfTtcblxuICAvKipcbiAgICogRG8gdGhlIG5leHQgc3RlcFxuICAgKi9cbiAgVGltZVN0ZXAucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZXYgPSB0aGlzLmN1cnJlbnQudmFsdWVPZigpO1xuXG4gICAgLy8gVHdvIGNhc2VzLCBuZWVkZWQgdG8gcHJldmVudCBpc3N1ZXMgd2l0aCBzd2l0Y2hpbmcgZGF5bGlnaHQgc2F2aW5nc1xuICAgIC8vIChlbmQgb2YgTWFyY2ggYW5kIGVuZCBvZiBPY3RvYmVyKVxuICAgIGlmICh0aGlzLmN1cnJlbnQubW9udGgoKSA8IDYpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zY2FsZSkge1xuICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdtaWxsaXNlY29uZCcpO2JyZWFrO1xuICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnc2Vjb25kJyk7YnJlYWs7XG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdtaW51dGUnKTticmVhaztcbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdob3VyJyk7XG4gICAgICAgICAgLy8gaW4gY2FzZSBvZiBza2lwcGluZyBhbiBob3VyIGZvciBkYXlsaWdodCBzYXZpbmdzLCBhZGp1c3QgdGhlIGhvdXIgYWdhaW4gKGVsc2UgeW91IGdldDogMGggNWggOWggLi4uIGluc3RlYWQgb2YgMGggNGggOGggLi4uKVxuICAgICAgICAgIC8vIFRPRE86IGlzIHRoaXMgc3RpbGwgbmVlZGVkIG5vdyB3ZSB1c2UgdGhlIGZ1bmN0aW9uIG9mIG1vbWVudC5qcz9cbiAgICAgICAgICB0aGlzLmN1cnJlbnQuc3VidHJhY3QodGhpcy5jdXJyZW50LmhvdXJzKCkgJSB0aGlzLnN0ZXAsICdob3VyJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3dlZWtkYXknOiAvLyBpbnRlbnRpb25hbCBmYWxsIHRocm91Z2hcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ2RheScpO2JyZWFrO1xuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdtb250aCcpO2JyZWFrO1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ3llYXInKTticmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ21pbGxpc2Vjb25kJyk7YnJlYWs7XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdzZWNvbmQnKTticmVhaztcbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ21pbnV0ZScpO2JyZWFrO1xuICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ2hvdXInKTticmVhaztcbiAgICAgICAgY2FzZSAnd2Vla2RheSc6IC8vIGludGVudGlvbmFsIGZhbGwgdGhyb3VnaFxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnZGF5Jyk7YnJlYWs7XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ21vbnRoJyk7YnJlYWs7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAneWVhcicpO2JyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnN0ZXAgIT0gMSkge1xuICAgICAgLy8gcm91bmQgZG93biB0byB0aGUgY29ycmVjdCBtYWpvciB2YWx1ZVxuICAgICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgICBpZiAodGhpcy5jdXJyZW50Lm1pbGxpc2Vjb25kcygpIDwgdGhpcy5zdGVwKSB0aGlzLmN1cnJlbnQubWlsbGlzZWNvbmRzKDApO2JyZWFrO1xuICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQuc2Vjb25kcygpIDwgdGhpcy5zdGVwKSB0aGlzLmN1cnJlbnQuc2Vjb25kcygwKTticmVhaztcbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICBpZiAodGhpcy5jdXJyZW50Lm1pbnV0ZXMoKSA8IHRoaXMuc3RlcCkgdGhpcy5jdXJyZW50Lm1pbnV0ZXMoMCk7YnJlYWs7XG4gICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQuaG91cnMoKSA8IHRoaXMuc3RlcCkgdGhpcy5jdXJyZW50LmhvdXJzKDApO2JyZWFrO1xuICAgICAgICBjYXNlICd3ZWVrZGF5JzogLy8gaW50ZW50aW9uYWwgZmFsbCB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgaWYgKHRoaXMuY3VycmVudC5kYXRlKCkgPCB0aGlzLnN0ZXAgKyAxKSB0aGlzLmN1cnJlbnQuZGF0ZSgxKTticmVhaztcbiAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQubW9udGgoKSA8IHRoaXMuc3RlcCkgdGhpcy5jdXJyZW50Lm1vbnRoKDApO2JyZWFrO1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICBicmVhazsgLy8gbm90aGluZyB0byBkbyBmb3IgeWVhclxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNhZmV0eSBtZWNoYW5pc206IGlmIGN1cnJlbnQgdGltZSBpcyBzdGlsbCB1bmNoYW5nZWQsIG1vdmUgdG8gdGhlIGVuZFxuICAgIGlmICh0aGlzLmN1cnJlbnQudmFsdWVPZigpID09IHByZXYpIHtcbiAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMuX2VuZC5jbG9uZSgpO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IHN3aXRjaGVzIGZvciB5ZWFyLCBtb250aCBhbmQgZGF5LiBXaWxsIGdldCBzZXQgdG8gdHJ1ZSB3aGVyZSBhcHByb3ByaWF0ZSBpbiBEYXRlVXRpbC5zdGVwT3ZlckhpZGRlbkRhdGVzXG4gICAgdGhpcy5zd2l0Y2hlZERheSA9IGZhbHNlO1xuICAgIHRoaXMuc3dpdGNoZWRNb250aCA9IGZhbHNlO1xuICAgIHRoaXMuc3dpdGNoZWRZZWFyID0gZmFsc2U7XG5cbiAgICBEYXRlVXRpbC5zdGVwT3ZlckhpZGRlbkRhdGVzKHRoaXMubW9tZW50LCB0aGlzLCBwcmV2KTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGRhdGV0aW1lXG4gICAqIEByZXR1cm4ge01vbWVudH0gIGN1cnJlbnQgVGhlIGN1cnJlbnQgZGF0ZVxuICAgKi9cbiAgVGltZVN0ZXAucHJvdG90eXBlLmdldEN1cnJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgY3VzdG9tIHNjYWxlLiBBdXRvc2NhbGluZyB3aWxsIGJlIGRpc2FibGVkLlxuICAgKiBGb3IgZXhhbXBsZSBzZXRTY2FsZSgnbWludXRlJywgNSkgd2lsbCByZXN1bHRcbiAgICogaW4gbWlub3Igc3RlcHMgb2YgNSBtaW51dGVzLCBhbmQgbWFqb3Igc3RlcHMgb2YgYW4gaG91ci5cbiAgICpcbiAgICogQHBhcmFtIHt7c2NhbGU6IHN0cmluZywgc3RlcDogbnVtYmVyfX0gcGFyYW1zXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIHR3byBwcm9wZXJ0aWVzOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIEEgc3RyaW5nICdzY2FsZScuIENob29zZSBmcm9tICdtaWxsaXNlY29uZCcsICdzZWNvbmQnLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtaW51dGUnLCAnaG91cicsICd3ZWVrZGF5JywgJ2RheScsICdtb250aCcsICd5ZWFyJy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBBIG51bWJlciAnc3RlcCcuIEEgc3RlcCBzaXplLCBieSBkZWZhdWx0IDEuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hvb3NlIGZvciBleGFtcGxlIDEsIDIsIDUsIG9yIDEwLlxuICAgKi9cbiAgVGltZVN0ZXAucHJvdG90eXBlLnNldFNjYWxlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcy5zY2FsZSA9PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5zY2FsZSA9IHBhcmFtcy5zY2FsZTtcbiAgICAgIHRoaXMuc3RlcCA9IHBhcmFtcy5zdGVwID4gMCA/IHBhcmFtcy5zdGVwIDogMTtcbiAgICAgIHRoaXMuYXV0b1NjYWxlID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBhdXRvc2NhbGluZ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZSAgSWYgdHJ1ZSwgYXV0b2FzY2FsaW5nIGlzIHNldCB0cnVlXG4gICAqL1xuICBUaW1lU3RlcC5wcm90b3R5cGUuc2V0QXV0b1NjYWxlID0gZnVuY3Rpb24gKGVuYWJsZSkge1xuICAgIHRoaXMuYXV0b1NjYWxlID0gZW5hYmxlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBdXRvbWF0aWNhbGx5IGRldGVybWluZSB0aGUgc2NhbGUgdGhhdCBiZXN0cyBmaXRzIHRoZSBwcm92aWRlZCBtaW5pbXVtIHN0ZXBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFttaW5pbXVtU3RlcF0gIFRoZSBtaW5pbXVtIHN0ZXAgc2l6ZSBpbiBtaWxsaXNlY29uZHNcbiAgICovXG4gIFRpbWVTdGVwLnByb3RvdHlwZS5zZXRNaW5pbXVtU3RlcCA9IGZ1bmN0aW9uIChtaW5pbXVtU3RlcCkge1xuICAgIGlmIChtaW5pbXVtU3RlcCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvL3ZhciBiID0gYXNjICsgZHM7XG5cbiAgICB2YXIgc3RlcFllYXIgPSAxMDAwICogNjAgKiA2MCAqIDI0ICogMzAgKiAxMjtcbiAgICB2YXIgc3RlcE1vbnRoID0gMTAwMCAqIDYwICogNjAgKiAyNCAqIDMwO1xuICAgIHZhciBzdGVwRGF5ID0gMTAwMCAqIDYwICogNjAgKiAyNDtcbiAgICB2YXIgc3RlcEhvdXIgPSAxMDAwICogNjAgKiA2MDtcbiAgICB2YXIgc3RlcE1pbnV0ZSA9IDEwMDAgKiA2MDtcbiAgICB2YXIgc3RlcFNlY29uZCA9IDEwMDA7XG4gICAgdmFyIHN0ZXBNaWxsaXNlY29uZCA9IDE7XG5cbiAgICAvLyBmaW5kIHRoZSBzbWFsbGVzdCBzdGVwIHRoYXQgaXMgbGFyZ2VyIHRoYW4gdGhlIHByb3ZpZGVkIG1pbmltdW1TdGVwXG4gICAgaWYgKHN0ZXBZZWFyICogMTAwMCA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ3llYXInO3RoaXMuc3RlcCA9IDEwMDA7XG4gICAgfVxuICAgIGlmIChzdGVwWWVhciAqIDUwMCA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ3llYXInO3RoaXMuc3RlcCA9IDUwMDtcbiAgICB9XG4gICAgaWYgKHN0ZXBZZWFyICogMTAwID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAneWVhcic7dGhpcy5zdGVwID0gMTAwO1xuICAgIH1cbiAgICBpZiAoc3RlcFllYXIgKiA1MCA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ3llYXInO3RoaXMuc3RlcCA9IDUwO1xuICAgIH1cbiAgICBpZiAoc3RlcFllYXIgKiAxMCA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ3llYXInO3RoaXMuc3RlcCA9IDEwO1xuICAgIH1cbiAgICBpZiAoc3RlcFllYXIgKiA1ID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAneWVhcic7dGhpcy5zdGVwID0gNTtcbiAgICB9XG4gICAgaWYgKHN0ZXBZZWFyID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAneWVhcic7dGhpcy5zdGVwID0gMTtcbiAgICB9XG4gICAgaWYgKHN0ZXBNb250aCAqIDMgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICdtb250aCc7dGhpcy5zdGVwID0gMztcbiAgICB9XG4gICAgaWYgKHN0ZXBNb250aCA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ21vbnRoJzt0aGlzLnN0ZXAgPSAxO1xuICAgIH1cbiAgICBpZiAoc3RlcERheSAqIDUgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICdkYXknO3RoaXMuc3RlcCA9IDU7XG4gICAgfVxuICAgIGlmIChzdGVwRGF5ICogMiA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ2RheSc7dGhpcy5zdGVwID0gMjtcbiAgICB9XG4gICAgaWYgKHN0ZXBEYXkgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICdkYXknO3RoaXMuc3RlcCA9IDE7XG4gICAgfVxuICAgIGlmIChzdGVwRGF5IC8gMiA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ3dlZWtkYXknO3RoaXMuc3RlcCA9IDE7XG4gICAgfVxuICAgIGlmIChzdGVwSG91ciAqIDQgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICdob3VyJzt0aGlzLnN0ZXAgPSA0O1xuICAgIH1cbiAgICBpZiAoc3RlcEhvdXIgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICdob3VyJzt0aGlzLnN0ZXAgPSAxO1xuICAgIH1cbiAgICBpZiAoc3RlcE1pbnV0ZSAqIDE1ID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAnbWludXRlJzt0aGlzLnN0ZXAgPSAxNTtcbiAgICB9XG4gICAgaWYgKHN0ZXBNaW51dGUgKiAxMCA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ21pbnV0ZSc7dGhpcy5zdGVwID0gMTA7XG4gICAgfVxuICAgIGlmIChzdGVwTWludXRlICogNSA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ21pbnV0ZSc7dGhpcy5zdGVwID0gNTtcbiAgICB9XG4gICAgaWYgKHN0ZXBNaW51dGUgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICdtaW51dGUnO3RoaXMuc3RlcCA9IDE7XG4gICAgfVxuICAgIGlmIChzdGVwU2Vjb25kICogMTUgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICdzZWNvbmQnO3RoaXMuc3RlcCA9IDE1O1xuICAgIH1cbiAgICBpZiAoc3RlcFNlY29uZCAqIDEwID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAnc2Vjb25kJzt0aGlzLnN0ZXAgPSAxMDtcbiAgICB9XG4gICAgaWYgKHN0ZXBTZWNvbmQgKiA1ID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAnc2Vjb25kJzt0aGlzLnN0ZXAgPSA1O1xuICAgIH1cbiAgICBpZiAoc3RlcFNlY29uZCA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ3NlY29uZCc7dGhpcy5zdGVwID0gMTtcbiAgICB9XG4gICAgaWYgKHN0ZXBNaWxsaXNlY29uZCAqIDIwMCA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ21pbGxpc2Vjb25kJzt0aGlzLnN0ZXAgPSAyMDA7XG4gICAgfVxuICAgIGlmIChzdGVwTWlsbGlzZWNvbmQgKiAxMDAgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICdtaWxsaXNlY29uZCc7dGhpcy5zdGVwID0gMTAwO1xuICAgIH1cbiAgICBpZiAoc3RlcE1pbGxpc2Vjb25kICogNTAgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICdtaWxsaXNlY29uZCc7dGhpcy5zdGVwID0gNTA7XG4gICAgfVxuICAgIGlmIChzdGVwTWlsbGlzZWNvbmQgKiAxMCA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ21pbGxpc2Vjb25kJzt0aGlzLnN0ZXAgPSAxMDtcbiAgICB9XG4gICAgaWYgKHN0ZXBNaWxsaXNlY29uZCAqIDUgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICdtaWxsaXNlY29uZCc7dGhpcy5zdGVwID0gNTtcbiAgICB9XG4gICAgaWYgKHN0ZXBNaWxsaXNlY29uZCA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ21pbGxpc2Vjb25kJzt0aGlzLnN0ZXAgPSAxO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU25hcCBhIGRhdGUgdG8gYSByb3VuZGVkIHZhbHVlLlxuICAgKiBUaGUgc25hcCBpbnRlcnZhbHMgYXJlIGRlcGVuZGVudCBvbiB0aGUgY3VycmVudCBzY2FsZSBhbmQgc3RlcC5cbiAgICogU3RhdGljIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSAgICB0aGUgZGF0ZSB0byBiZSBzbmFwcGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2NhbGUgQ3VycmVudCBzY2FsZSwgY2FuIGJlICdtaWxsaXNlY29uZCcsICdzZWNvbmQnLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgJ21pbnV0ZScsICdob3VyJywgJ3dlZWtkYXksICdkYXknLCAnbW9udGgnLCAneWVhcicuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwICBDdXJyZW50IHN0ZXAgKDEsIDIsIDQsIDUsIC4uLlxuICAgKiBAcmV0dXJuIHtEYXRlfSBzbmFwcGVkRGF0ZVxuICAgKi9cbiAgVGltZVN0ZXAuc25hcCA9IGZ1bmN0aW9uIChkYXRlLCBzY2FsZSwgc3RlcCkge1xuICAgIHZhciBjbG9uZSA9IG1vbWVudChkYXRlKTtcblxuICAgIGlmIChzY2FsZSA9PSAneWVhcicpIHtcbiAgICAgIHZhciB5ZWFyID0gY2xvbmUueWVhcigpICsgTWF0aC5yb3VuZChjbG9uZS5tb250aCgpIC8gMTIpO1xuICAgICAgY2xvbmUueWVhcihNYXRoLnJvdW5kKHllYXIgLyBzdGVwKSAqIHN0ZXApO1xuICAgICAgY2xvbmUubW9udGgoMCk7XG4gICAgICBjbG9uZS5kYXRlKDApO1xuICAgICAgY2xvbmUuaG91cnMoMCk7XG4gICAgICBjbG9uZS5taW51dGVzKDApO1xuICAgICAgY2xvbmUuc2Vjb25kcygwKTtcbiAgICAgIGNsb25lLm1pbGxpc2Vjb25kcygwKTtcbiAgICB9IGVsc2UgaWYgKHNjYWxlID09ICdtb250aCcpIHtcbiAgICAgIGlmIChjbG9uZS5kYXRlKCkgPiAxNSkge1xuICAgICAgICBjbG9uZS5kYXRlKDEpO1xuICAgICAgICBjbG9uZS5hZGQoMSwgJ21vbnRoJyk7XG4gICAgICAgIC8vIGltcG9ydGFudDogZmlyc3Qgc2V0IERhdGUgdG8gMSwgYWZ0ZXIgdGhhdCBjaGFuZ2UgdGhlIG1vbnRoLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvbmUuZGF0ZSgxKTtcbiAgICAgIH1cblxuICAgICAgY2xvbmUuaG91cnMoMCk7XG4gICAgICBjbG9uZS5taW51dGVzKDApO1xuICAgICAgY2xvbmUuc2Vjb25kcygwKTtcbiAgICAgIGNsb25lLm1pbGxpc2Vjb25kcygwKTtcbiAgICB9IGVsc2UgaWYgKHNjYWxlID09ICdkYXknKSB7XG4gICAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgICAgIHN3aXRjaCAoc3RlcCkge1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBjbG9uZS5ob3VycyhNYXRoLnJvdW5kKGNsb25lLmhvdXJzKCkgLyAyNCkgKiAyNCk7YnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2xvbmUuaG91cnMoTWF0aC5yb3VuZChjbG9uZS5ob3VycygpIC8gMTIpICogMTIpO2JyZWFrO1xuICAgICAgfVxuICAgICAgY2xvbmUubWludXRlcygwKTtcbiAgICAgIGNsb25lLnNlY29uZHMoMCk7XG4gICAgICBjbG9uZS5taWxsaXNlY29uZHMoMCk7XG4gICAgfSBlbHNlIGlmIChzY2FsZSA9PSAnd2Vla2RheScpIHtcbiAgICAgIC8vbm9pbnNwZWN0aW9uIEZhbGx0aHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgICAgc3dpdGNoIChzdGVwKSB7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNsb25lLmhvdXJzKE1hdGgucm91bmQoY2xvbmUuaG91cnMoKSAvIDEyKSAqIDEyKTticmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjbG9uZS5ob3VycyhNYXRoLnJvdW5kKGNsb25lLmhvdXJzKCkgLyA2KSAqIDYpO2JyZWFrO1xuICAgICAgfVxuICAgICAgY2xvbmUubWludXRlcygwKTtcbiAgICAgIGNsb25lLnNlY29uZHMoMCk7XG4gICAgICBjbG9uZS5taWxsaXNlY29uZHMoMCk7XG4gICAgfSBlbHNlIGlmIChzY2FsZSA9PSAnaG91cicpIHtcbiAgICAgIHN3aXRjaCAoc3RlcCkge1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2xvbmUubWludXRlcyhNYXRoLnJvdW5kKGNsb25lLm1pbnV0ZXMoKSAvIDYwKSAqIDYwKTticmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjbG9uZS5taW51dGVzKE1hdGgucm91bmQoY2xvbmUubWludXRlcygpIC8gMzApICogMzApO2JyZWFrO1xuICAgICAgfVxuICAgICAgY2xvbmUuc2Vjb25kcygwKTtcbiAgICAgIGNsb25lLm1pbGxpc2Vjb25kcygwKTtcbiAgICB9IGVsc2UgaWYgKHNjYWxlID09ICdtaW51dGUnKSB7XG4gICAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgICAgIHN3aXRjaCAoc3RlcCkge1xuICAgICAgICBjYXNlIDE1OlxuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIGNsb25lLm1pbnV0ZXMoTWF0aC5yb3VuZChjbG9uZS5taW51dGVzKCkgLyA1KSAqIDUpO1xuICAgICAgICAgIGNsb25lLnNlY29uZHMoMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBjbG9uZS5zZWNvbmRzKE1hdGgucm91bmQoY2xvbmUuc2Vjb25kcygpIC8gNjApICogNjApO2JyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNsb25lLnNlY29uZHMoTWF0aC5yb3VuZChjbG9uZS5zZWNvbmRzKCkgLyAzMCkgKiAzMCk7YnJlYWs7XG4gICAgICB9XG4gICAgICBjbG9uZS5taWxsaXNlY29uZHMoMCk7XG4gICAgfSBlbHNlIGlmIChzY2FsZSA9PSAnc2Vjb25kJykge1xuICAgICAgLy9ub2luc3BlY3Rpb24gRmFsbHRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gICAgICBzd2l0Y2ggKHN0ZXApIHtcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBjbG9uZS5zZWNvbmRzKE1hdGgucm91bmQoY2xvbmUuc2Vjb25kcygpIC8gNSkgKiA1KTtcbiAgICAgICAgICBjbG9uZS5taWxsaXNlY29uZHMoMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBjbG9uZS5taWxsaXNlY29uZHMoTWF0aC5yb3VuZChjbG9uZS5taWxsaXNlY29uZHMoKSAvIDEwMDApICogMTAwMCk7YnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2xvbmUubWlsbGlzZWNvbmRzKE1hdGgucm91bmQoY2xvbmUubWlsbGlzZWNvbmRzKCkgLyA1MDApICogNTAwKTticmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNjYWxlID09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgIHZhciBfc3RlcCA9IHN0ZXAgPiA1ID8gc3RlcCAvIDIgOiAxO1xuICAgICAgY2xvbmUubWlsbGlzZWNvbmRzKE1hdGgucm91bmQoY2xvbmUubWlsbGlzZWNvbmRzKCkgLyBfc3RlcCkgKiBfc3RlcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgY3VycmVudCB2YWx1ZSBpcyBhIG1ham9yIHZhbHVlIChmb3IgZXhhbXBsZSB3aGVuIHRoZSBzdGVwXG4gICAqIGlzIERBWSwgYSBtYWpvciB2YWx1ZSBpcyBlYWNoIGZpcnN0IGRheSBvZiB0aGUgTU9OVEgpXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgY3VycmVudCBkYXRlIGlzIG1ham9yLCBlbHNlIGZhbHNlLlxuICAgKi9cbiAgVGltZVN0ZXAucHJvdG90eXBlLmlzTWFqb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc3dpdGNoZWRZZWFyID09IHRydWUpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zY2FsZSkge1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICBjYXNlICd3ZWVrZGF5JzpcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnN3aXRjaGVkTW9udGggPT0gdHJ1ZSkge1xuICAgICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICAgIGNhc2UgJ3dlZWtkYXknOlxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuc3dpdGNoZWREYXkgPT0gdHJ1ZSkge1xuICAgICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkYXRlID0gdGhpcy5tb21lbnQodGhpcy5jdXJyZW50KTtcbiAgICBzd2l0Y2ggKHRoaXMuc2NhbGUpIHtcbiAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgcmV0dXJuIGRhdGUubWlsbGlzZWNvbmRzKCkgPT0gMDtcbiAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgIHJldHVybiBkYXRlLnNlY29uZHMoKSA9PSAwO1xuICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgcmV0dXJuIGRhdGUuaG91cnMoKSA9PSAwICYmIGRhdGUubWludXRlcygpID09IDA7XG4gICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgcmV0dXJuIGRhdGUuaG91cnMoKSA9PSAwO1xuICAgICAgY2FzZSAnd2Vla2RheSc6IC8vIGludGVudGlvbmFsIGZhbGwgdGhyb3VnaFxuICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgcmV0dXJuIGRhdGUuZGF0ZSgpID09IDE7XG4gICAgICBjYXNlICdtb250aCc6XG4gICAgICAgIHJldHVybiBkYXRlLm1vbnRoKCkgPT0gMDtcbiAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZvcm1hdHRlZCB0ZXh0IGZvciB0aGUgbWlub3IgYXhpc2xhYmVsLCBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnRcbiAgICogZGF0ZSBhbmQgdGhlIHNjYWxlLiBGb3IgZXhhbXBsZSB3aGVuIHNjYWxlIGlzIE1JTlVURSwgdGhlIGN1cnJlbnQgdGltZSBpc1xuICAgKiBmb3JtYXR0ZWQgYXMgXCJoaDptbVwiLlxuICAgKiBAcGFyYW0ge0RhdGV9IFtkYXRlXSBjdXN0b20gZGF0ZS4gaWYgbm90IHByb3ZpZGVkLCBjdXJyZW50IGRhdGUgaXMgdGFrZW5cbiAgICovXG4gIFRpbWVTdGVwLnByb3RvdHlwZS5nZXRMYWJlbE1pbm9yID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICBpZiAoZGF0ZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRhdGUgPSB0aGlzLmN1cnJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLmZvcm1hdC5taW5vckxhYmVscyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb3JtYXQubWlub3JMYWJlbHMoZGF0ZSwgdGhpcy5zY2FsZSwgdGhpcy5zdGVwKTtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0ID0gdGhpcy5mb3JtYXQubWlub3JMYWJlbHNbdGhpcy5zY2FsZV07XG4gICAgcmV0dXJuIGZvcm1hdCAmJiBmb3JtYXQubGVuZ3RoID4gMCA/IHRoaXMubW9tZW50KGRhdGUpLmZvcm1hdChmb3JtYXQpIDogJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZm9ybWF0dGVkIHRleHQgZm9yIHRoZSBtYWpvciBheGlzIGxhYmVsLCBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnRcbiAgICogZGF0ZSBhbmQgdGhlIHNjYWxlLiBGb3IgZXhhbXBsZSB3aGVuIHNjYWxlIGlzIE1JTlVURSwgdGhlIG1ham9yIHNjYWxlIGlzXG4gICAqIGhvdXJzLCBhbmQgdGhlIGhvdXIgd2lsbCBiZSBmb3JtYXR0ZWQgYXMgXCJoaFwiLlxuICAgKiBAcGFyYW0ge0RhdGV9IFtkYXRlXSBjdXN0b20gZGF0ZS4gaWYgbm90IHByb3ZpZGVkLCBjdXJyZW50IGRhdGUgaXMgdGFrZW5cbiAgICovXG4gIFRpbWVTdGVwLnByb3RvdHlwZS5nZXRMYWJlbE1ham9yID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICBpZiAoZGF0ZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRhdGUgPSB0aGlzLmN1cnJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLmZvcm1hdC5tYWpvckxhYmVscyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb3JtYXQubWFqb3JMYWJlbHMoZGF0ZSwgdGhpcy5zY2FsZSwgdGhpcy5zdGVwKTtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0ID0gdGhpcy5mb3JtYXQubWFqb3JMYWJlbHNbdGhpcy5zY2FsZV07XG4gICAgcmV0dXJuIGZvcm1hdCAmJiBmb3JtYXQubGVuZ3RoID4gMCA/IHRoaXMubW9tZW50KGRhdGUpLmZvcm1hdChmb3JtYXQpIDogJyc7XG4gIH07XG5cbiAgVGltZVN0ZXAucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX21vbWVudCA9IHRoaXMubW9tZW50O1xuICAgIHZhciBtID0gdGhpcy5tb21lbnQodGhpcy5jdXJyZW50KTtcbiAgICB2YXIgY3VycmVudCA9IG0ubG9jYWxlID8gbS5sb2NhbGUoJ2VuJykgOiBtLmxhbmcoJ2VuJyk7IC8vIG9sZCB2ZXJzaW9ucyBvZiBtb21lbnQgaGF2ZSAubGFuZygpIGZ1bmN0aW9uXG4gICAgdmFyIHN0ZXAgPSB0aGlzLnN0ZXA7XG5cbiAgICBmdW5jdGlvbiBldmVuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgLyBzdGVwICUgMiA9PSAwID8gJyB2aXMtZXZlbicgOiAnIHZpcy1vZGQnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvZGF5KGRhdGUpIHtcbiAgICAgIGlmIChkYXRlLmlzU2FtZShuZXcgRGF0ZSgpLCAnZGF5JykpIHtcbiAgICAgICAgcmV0dXJuICcgdmlzLXRvZGF5JztcbiAgICAgIH1cbiAgICAgIGlmIChkYXRlLmlzU2FtZShfbW9tZW50KCkuYWRkKDEsICdkYXknKSwgJ2RheScpKSB7XG4gICAgICAgIHJldHVybiAnIHZpcy10b21vcnJvdyc7XG4gICAgICB9XG4gICAgICBpZiAoZGF0ZS5pc1NhbWUoX21vbWVudCgpLmFkZCgtMSwgJ2RheScpLCAnZGF5JykpIHtcbiAgICAgICAgcmV0dXJuICcgdmlzLXllc3RlcmRheSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3VycmVudFdlZWsoZGF0ZSkge1xuICAgICAgcmV0dXJuIGRhdGUuaXNTYW1lKG5ldyBEYXRlKCksICd3ZWVrJykgPyAnIHZpcy1jdXJyZW50LXdlZWsnIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3VycmVudE1vbnRoKGRhdGUpIHtcbiAgICAgIHJldHVybiBkYXRlLmlzU2FtZShuZXcgRGF0ZSgpLCAnbW9udGgnKSA/ICcgdmlzLWN1cnJlbnQtbW9udGgnIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3VycmVudFllYXIoZGF0ZSkge1xuICAgICAgcmV0dXJuIGRhdGUuaXNTYW1lKG5ldyBEYXRlKCksICd5ZWFyJykgPyAnIHZpcy1jdXJyZW50LXllYXInIDogJyc7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgICAgIHJldHVybiB0b2RheShjdXJyZW50KSArIGV2ZW4oY3VycmVudC5taWxsaXNlY29uZHMoKSkudHJpbSgpO1xuXG4gICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICByZXR1cm4gdG9kYXkoY3VycmVudCkgKyBldmVuKGN1cnJlbnQuc2Vjb25kcygpKS50cmltKCk7XG5cbiAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgIHJldHVybiB0b2RheShjdXJyZW50KSArIGV2ZW4oY3VycmVudC5taW51dGVzKCkpLnRyaW0oKTtcblxuICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgIHJldHVybiAndmlzLWgnICsgY3VycmVudC5ob3VycygpICsgKHRoaXMuc3RlcCA9PSA0ID8gJy1oJyArIChjdXJyZW50LmhvdXJzKCkgKyA0KSA6ICcnKSArIHRvZGF5KGN1cnJlbnQpICsgZXZlbihjdXJyZW50LmhvdXJzKCkpO1xuXG4gICAgICBjYXNlICd3ZWVrZGF5JzpcbiAgICAgICAgcmV0dXJuICd2aXMtJyArIGN1cnJlbnQuZm9ybWF0KCdkZGRkJykudG9Mb3dlckNhc2UoKSArIHRvZGF5KGN1cnJlbnQpICsgY3VycmVudFdlZWsoY3VycmVudCkgKyBldmVuKGN1cnJlbnQuZGF0ZSgpKTtcblxuICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgcmV0dXJuICd2aXMtZGF5JyArIGN1cnJlbnQuZGF0ZSgpICsgJyB2aXMtJyArIGN1cnJlbnQuZm9ybWF0KCdNTU1NJykudG9Mb3dlckNhc2UoKSArIHRvZGF5KGN1cnJlbnQpICsgY3VycmVudE1vbnRoKGN1cnJlbnQpICsgdGhpcy5zdGVwIDw9IDIgPyB0b2RheShjdXJyZW50KSA6ICcnICsgdGhpcy5zdGVwIDw9IDIgPyAnIHZpcy0nICsgY3VycmVudC5mb3JtYXQoJ2RkZGQnKS50b0xvd2VyQ2FzZSgpIDogJycgKyBldmVuKGN1cnJlbnQuZGF0ZSgpIC0gMSk7XG5cbiAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgcmV0dXJuICd2aXMtJyArIGN1cnJlbnQuZm9ybWF0KCdNTU1NJykudG9Mb3dlckNhc2UoKSArIGN1cnJlbnRNb250aChjdXJyZW50KSArIGV2ZW4oY3VycmVudC5tb250aCgpKTtcblxuICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgIHZhciB5ZWFyID0gY3VycmVudC55ZWFyKCk7XG4gICAgICAgIHJldHVybiAndmlzLXllYXInICsgeWVhciArIGN1cnJlbnRZZWFyKGN1cnJlbnQpICsgZXZlbih5ZWFyKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFRpbWVTdGVwO1xuXG4vKioqLyB9LFxuLyogMzggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBzdGFjayA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuICB2YXIgUmFuZ2VJdGVtID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBHcm91cFxuICAgKiBAcGFyYW0ge051bWJlciB8IFN0cmluZ30gZ3JvdXBJZFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge0l0ZW1TZXR9IGl0ZW1TZXRcbiAgICovXG4gIGZ1bmN0aW9uIEdyb3VwKGdyb3VwSWQsIGRhdGEsIGl0ZW1TZXQpIHtcbiAgICB0aGlzLmdyb3VwSWQgPSBncm91cElkO1xuICAgIHRoaXMuc3ViZ3JvdXBzID0ge307XG4gICAgdGhpcy5zdWJncm91cEluZGV4ID0gMDtcbiAgICB0aGlzLnN1Ymdyb3VwT3JkZXJlciA9IGRhdGEgJiYgZGF0YS5zdWJncm91cE9yZGVyO1xuICAgIHRoaXMuaXRlbVNldCA9IGl0ZW1TZXQ7XG4gICAgdGhpcy5pc1Zpc2libGUgPSBudWxsO1xuXG4gICAgdGhpcy5kb20gPSB7fTtcbiAgICB0aGlzLnByb3BzID0ge1xuICAgICAgbGFiZWw6IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5jbGFzc05hbWUgPSBudWxsO1xuXG4gICAgdGhpcy5pdGVtcyA9IHt9OyAvLyBpdGVtcyBmaWx0ZXJlZCBieSBncm91cElkIG9mIHRoaXMgZ3JvdXBcbiAgICB0aGlzLnZpc2libGVJdGVtcyA9IFtdOyAvLyBpdGVtcyBjdXJyZW50bHkgdmlzaWJsZSBpbiB3aW5kb3dcbiAgICB0aGlzLm9yZGVyZWRJdGVtcyA9IHtcbiAgICAgIGJ5U3RhcnQ6IFtdLFxuICAgICAgYnlFbmQ6IFtdXG4gICAgfTtcbiAgICB0aGlzLmNoZWNrUmFuZ2VkSXRlbXMgPSBmYWxzZTsgLy8gbmVlZGVkIHRvIHJlZnJlc2ggdGhlIHJhbmdlZCBpdGVtcyBpZiB0aGUgd2luZG93IGlzIHByb2dyYW1hdGljYWxseSBjaGFuZ2VkIHdpdGggTk8gb3ZlcmxhcC5cbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHRoaXMuaXRlbVNldC5ib2R5LmVtaXR0ZXIub24oXCJjaGVja1JhbmdlZEl0ZW1zXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIG1lLmNoZWNrUmFuZ2VkSXRlbXMgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fY3JlYXRlKCk7XG5cbiAgICB0aGlzLnNldERhdGEoZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIERPTSBlbGVtZW50cyBmb3IgdGhlIGdyb3VwXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBHcm91cC5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpZiAodGhpcy5pdGVtU2V0Lm9wdGlvbnMuZ3JvdXBFZGl0YWJsZS5vcmRlcikge1xuICAgICAgbGFiZWwuY2xhc3NOYW1lID0gJ3Zpcy1sYWJlbCBkcmFnZ2FibGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYWJlbC5jbGFzc05hbWUgPSAndmlzLWxhYmVsJztcbiAgICB9XG4gICAgdGhpcy5kb20ubGFiZWwgPSBsYWJlbDtcblxuICAgIHZhciBpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGlubmVyLmNsYXNzTmFtZSA9ICd2aXMtaW5uZXInO1xuICAgIGxhYmVsLmFwcGVuZENoaWxkKGlubmVyKTtcbiAgICB0aGlzLmRvbS5pbm5lciA9IGlubmVyO1xuXG4gICAgdmFyIGZvcmVncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBmb3JlZ3JvdW5kLmNsYXNzTmFtZSA9ICd2aXMtZ3JvdXAnO1xuICAgIGZvcmVncm91bmRbJ3RpbWVsaW5lLWdyb3VwJ10gPSB0aGlzO1xuICAgIHRoaXMuZG9tLmZvcmVncm91bmQgPSBmb3JlZ3JvdW5kO1xuXG4gICAgdGhpcy5kb20uYmFja2dyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tLmJhY2tncm91bmQuY2xhc3NOYW1lID0gJ3Zpcy1ncm91cCc7XG5cbiAgICB0aGlzLmRvbS5heGlzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uYXhpcy5jbGFzc05hbWUgPSAndmlzLWdyb3VwJztcblxuICAgIC8vIGNyZWF0ZSBhIGhpZGRlbiBtYXJrZXIgdG8gZGV0ZWN0IHdoZW4gdGhlIFRpbWVsaW5lcyBjb250YWluZXIgaXMgYXR0YWNoZWRcbiAgICAvLyB0byB0aGUgRE9NLCBvciB0aGUgc3R5bGUgb2YgYSBwYXJlbnQgb2YgdGhlIFRpbWVsaW5lIGlzIGNoYW5nZWQgZnJvbVxuICAgIC8vIGRpc3BsYXk6bm9uZSBpcyBjaGFuZ2VkIHRvIHZpc2libGUuXG4gICAgdGhpcy5kb20ubWFya2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20ubWFya2VyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICB0aGlzLmRvbS5tYXJrZXIuaW5uZXJIVE1MID0gJz8nO1xuICAgIHRoaXMuZG9tLmJhY2tncm91bmQuYXBwZW5kQ2hpbGQodGhpcy5kb20ubWFya2VyKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBncm91cCBkYXRhIGZvciB0aGlzIGdyb3VwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgR3JvdXAgZGF0YSwgY2FuIGNvbnRhaW4gcHJvcGVydGllcyBjb250ZW50IGFuZCBjbGFzc05hbWVcbiAgICovXG4gIEdyb3VwLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAvLyB1cGRhdGUgY29udGVudHNcbiAgICB2YXIgY29udGVudDtcbiAgICB2YXIgdGVtcGxhdGVGdW5jdGlvbjtcblxuICAgIGlmICh0aGlzLml0ZW1TZXQub3B0aW9ucyAmJiB0aGlzLml0ZW1TZXQub3B0aW9ucy5ncm91cFRlbXBsYXRlKSB7XG4gICAgICB0ZW1wbGF0ZUZ1bmN0aW9uID0gdGhpcy5pdGVtU2V0Lm9wdGlvbnMuZ3JvdXBUZW1wbGF0ZS5iaW5kKHRoaXMpO1xuICAgICAgY29udGVudCA9IHRlbXBsYXRlRnVuY3Rpb24oZGF0YSwgdGhpcy5kb20uaW5uZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50ID0gZGF0YSAmJiBkYXRhLmNvbnRlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICB0aGlzLmRvbS5pbm5lci5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgIHdoaWxlICh0aGlzLmRvbS5pbm5lci5maXJzdENoaWxkKSB7XG4gICAgICAgIHRoaXMuZG9tLmlubmVyLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmlubmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgdGhpcy5kb20uaW5uZXIuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgfSBlbHNlIGlmIChjb250ZW50IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICB0ZW1wbGF0ZUZ1bmN0aW9uKGRhdGEsIHRoaXMuZG9tLmlubmVyKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRlbnQgIT09IHVuZGVmaW5lZCAmJiBjb250ZW50ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmRvbS5pbm5lci5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvbS5pbm5lci5pbm5lckhUTUwgPSB0aGlzLmdyb3VwSWQgfHwgJyc7IC8vIGdyb3VwSWQgY2FuIGJlIG51bGxcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGl0bGVcbiAgICB0aGlzLmRvbS5sYWJlbC50aXRsZSA9IGRhdGEgJiYgZGF0YS50aXRsZSB8fCAnJztcblxuICAgIGlmICghdGhpcy5kb20uaW5uZXIuZmlyc3RDaGlsZCkge1xuICAgICAgdXRpbC5hZGRDbGFzc05hbWUodGhpcy5kb20uaW5uZXIsICd2aXMtaGlkZGVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKHRoaXMuZG9tLmlubmVyLCAndmlzLWhpZGRlbicpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBjbGFzc05hbWVcbiAgICB2YXIgY2xhc3NOYW1lID0gZGF0YSAmJiBkYXRhLmNsYXNzTmFtZSB8fCBudWxsO1xuICAgIGlmIChjbGFzc05hbWUgIT0gdGhpcy5jbGFzc05hbWUpIHtcbiAgICAgIGlmICh0aGlzLmNsYXNzTmFtZSkge1xuICAgICAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZSh0aGlzLmRvbS5sYWJlbCwgdGhpcy5jbGFzc05hbWUpO1xuICAgICAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZSh0aGlzLmRvbS5mb3JlZ3JvdW5kLCB0aGlzLmNsYXNzTmFtZSk7XG4gICAgICAgIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKHRoaXMuZG9tLmJhY2tncm91bmQsIHRoaXMuY2xhc3NOYW1lKTtcbiAgICAgICAgdXRpbC5yZW1vdmVDbGFzc05hbWUodGhpcy5kb20uYXhpcywgdGhpcy5jbGFzc05hbWUpO1xuICAgICAgfVxuICAgICAgdXRpbC5hZGRDbGFzc05hbWUodGhpcy5kb20ubGFiZWwsIGNsYXNzTmFtZSk7XG4gICAgICB1dGlsLmFkZENsYXNzTmFtZSh0aGlzLmRvbS5mb3JlZ3JvdW5kLCBjbGFzc05hbWUpO1xuICAgICAgdXRpbC5hZGRDbGFzc05hbWUodGhpcy5kb20uYmFja2dyb3VuZCwgY2xhc3NOYW1lKTtcbiAgICAgIHV0aWwuYWRkQ2xhc3NOYW1lKHRoaXMuZG9tLmF4aXMsIGNsYXNzTmFtZSk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgc3R5bGVcbiAgICBpZiAodGhpcy5zdHlsZSkge1xuICAgICAgdXRpbC5yZW1vdmVDc3NUZXh0KHRoaXMuZG9tLmxhYmVsLCB0aGlzLnN0eWxlKTtcbiAgICAgIHRoaXMuc3R5bGUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZGF0YSAmJiBkYXRhLnN0eWxlKSB7XG4gICAgICB1dGlsLmFkZENzc1RleHQodGhpcy5kb20ubGFiZWwsIGRhdGEuc3R5bGUpO1xuICAgICAgdGhpcy5zdHlsZSA9IGRhdGEuc3R5bGU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdpZHRoIG9mIHRoZSBncm91cCBsYWJlbFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IHdpZHRoXG4gICAqL1xuICBHcm91cC5wcm90b3R5cGUuZ2V0TGFiZWxXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5sYWJlbC53aWR0aDtcbiAgfTtcblxuICAvKipcbiAgICogUmVwYWludCB0aGlzIGdyb3VwXG4gICAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gcmFuZ2VcbiAgICogQHBhcmFtIHt7aXRlbToge2hvcml6b250YWw6IG51bWJlciwgdmVydGljYWw6IG51bWJlcn0sIGF4aXM6IG51bWJlcn19IG1hcmdpblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXN0YWNrPWZhbHNlXSAgRm9yY2UgcmVzdGFja2luZyBvZiBhbGwgaXRlbXNcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBncm91cCBpcyByZXNpemVkXG4gICAqL1xuICBHcm91cC5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24gKHJhbmdlLCBtYXJnaW4sIHJlc3RhY2spIHtcbiAgICB2YXIgcmVzaXplZCA9IGZhbHNlO1xuXG4gICAgLy8gZm9yY2UgcmVjYWxjdWxhdGlvbiBvZiB0aGUgaGVpZ2h0IG9mIHRoZSBpdGVtcyB3aGVuIHRoZSBtYXJrZXIgaGVpZ2h0IGNoYW5nZWRcbiAgICAvLyAoZHVlIHRvIHRoZSBUaW1lbGluZSBiZWluZyBhdHRhY2hlZCB0byB0aGUgRE9NIG9yIGNoYW5nZWQgZnJvbSBkaXNwbGF5Om5vbmUgdG8gdmlzaWJsZSlcbiAgICB2YXIgbWFya2VySGVpZ2h0ID0gdGhpcy5kb20ubWFya2VyLmNsaWVudEhlaWdodDtcbiAgICBpZiAobWFya2VySGVpZ2h0ICE9IHRoaXMubGFzdE1hcmtlckhlaWdodCkge1xuICAgICAgdGhpcy5sYXN0TWFya2VySGVpZ2h0ID0gbWFya2VySGVpZ2h0O1xuXG4gICAgICB1dGlsLmZvckVhY2godGhpcy5pdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaXRlbS5kaXJ0eSA9IHRydWU7XG4gICAgICAgIGlmIChpdGVtLmRpc3BsYXllZCkgaXRlbS5yZWRyYXcoKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXN0YWNrID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyByZWNhbGN1bGF0ZSB0aGUgaGVpZ2h0IG9mIHRoZSBzdWJncm91cHNcbiAgICB0aGlzLl9jYWxjdWxhdGVTdWJHcm91cEhlaWdodHMoKTtcblxuICAgIHRoaXMuaXNWaXNpYmxlID0gdGhpcy5faXNHcm91cFZpc2libGUocmFuZ2UsIG1hcmdpbik7XG5cbiAgICAvLyBjYWxjdWxhdGUgYWN0dWFsIHNpemUgYW5kIHBvc2l0aW9uXG4gICAgdmFyIGZvcmVncm91bmQgPSB0aGlzLmRvbS5mb3JlZ3JvdW5kO1xuICAgIHRoaXMudG9wID0gZm9yZWdyb3VuZC5vZmZzZXRUb3A7XG4gICAgdGhpcy5yaWdodCA9IGZvcmVncm91bmQub2Zmc2V0TGVmdDtcbiAgICB0aGlzLndpZHRoID0gZm9yZWdyb3VuZC5vZmZzZXRXaWR0aDtcblxuICAgIHRoaXMuaXNWaXNpYmxlID0gdGhpcy5faXNHcm91cFZpc2libGUocmFuZ2UsIG1hcmdpbik7XG4gICAgLy8gcmVwb3NpdGlvbiB2aXNpYmxlIGl0ZW1zIHZlcnRpY2FsbHlcbiAgICBpZiAodHlwZW9mIHRoaXMuaXRlbVNldC5vcHRpb25zLm9yZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBhIGN1c3RvbSBvcmRlciBmdW5jdGlvblxuXG4gICAgICBpZiAocmVzdGFjaykge1xuICAgICAgICAvLyBicnV0ZSBmb3JjZSByZXN0YWNrIG9mIGFsbCBpdGVtc1xuXG4gICAgICAgIC8vIHNob3cgYWxsIGl0ZW1zXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBsaW1pdFNpemUgPSBmYWxzZTtcbiAgICAgICAgdXRpbC5mb3JFYWNoKHRoaXMuaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgaWYgKCFpdGVtLmRpc3BsYXllZCkge1xuICAgICAgICAgICAgaXRlbS5yZWRyYXcoKTtcbiAgICAgICAgICAgIG1lLnZpc2libGVJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtLnJlcG9zaXRpb25YKGxpbWl0U2l6ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIG9yZGVyIGFsbCBpdGVtcyBhbmQgZm9yY2UgYSByZXN0YWNraW5nXG4gICAgICAgIHZhciBjdXN0b21PcmRlcmVkSXRlbXMgPSB0aGlzLm9yZGVyZWRJdGVtcy5ieVN0YXJ0LnNsaWNlKCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBtZS5pdGVtU2V0Lm9wdGlvbnMub3JkZXIoYS5kYXRhLCBiLmRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RhY2suc3RhY2soY3VzdG9tT3JkZXJlZEl0ZW1zLCBtYXJnaW4sIHRydWUgLyogcmVzdGFjaz10cnVlICovKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy52aXNpYmxlSXRlbXMgPSB0aGlzLl91cGRhdGVWaXNpYmxlSXRlbXModGhpcy5vcmRlcmVkSXRlbXMsIHRoaXMudmlzaWJsZUl0ZW1zLCByYW5nZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vIGN1c3RvbSBvcmRlciBmdW5jdGlvbiwgbGF6eSBzdGFja2luZ1xuXG4gICAgICB0aGlzLnZpc2libGVJdGVtcyA9IHRoaXMuX3VwZGF0ZVZpc2libGVJdGVtcyh0aGlzLm9yZGVyZWRJdGVtcywgdGhpcy52aXNpYmxlSXRlbXMsIHJhbmdlKTtcbiAgICAgIGlmICh0aGlzLml0ZW1TZXQub3B0aW9ucy5zdGFjaykge1xuICAgICAgICAvLyBUT0RPOiB1Z2x5IHdheSB0byBhY2Nlc3Mgb3B0aW9ucy4uLlxuICAgICAgICBzdGFjay5zdGFjayh0aGlzLnZpc2libGVJdGVtcywgbWFyZ2luLCByZXN0YWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vIHN0YWNraW5nXG4gICAgICAgIHN0YWNrLm5vc3RhY2sodGhpcy52aXNpYmxlSXRlbXMsIG1hcmdpbiwgdGhpcy5zdWJncm91cHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5pc1Zpc2libGUgJiYgdGhpcy5oZWlnaHQpIHtcbiAgICAgIHJldHVybiByZXNpemVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gcmVjYWxjdWxhdGUgdGhlIGhlaWdodCBvZiB0aGUgZ3JvdXBcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5fY2FsY3VsYXRlSGVpZ2h0KG1hcmdpbik7XG5cbiAgICAvLyBjYWxjdWxhdGUgYWN0dWFsIHNpemUgYW5kIHBvc2l0aW9uXG4gICAgdmFyIGZvcmVncm91bmQgPSB0aGlzLmRvbS5mb3JlZ3JvdW5kO1xuICAgIHRoaXMudG9wID0gZm9yZWdyb3VuZC5vZmZzZXRUb3A7XG4gICAgdGhpcy5yaWdodCA9IGZvcmVncm91bmQub2Zmc2V0TGVmdDtcbiAgICB0aGlzLndpZHRoID0gZm9yZWdyb3VuZC5vZmZzZXRXaWR0aDtcbiAgICByZXNpemVkID0gdXRpbC51cGRhdGVQcm9wZXJ0eSh0aGlzLCAnaGVpZ2h0JywgaGVpZ2h0KSB8fCByZXNpemVkO1xuICAgIC8vIHJlY2FsY3VsYXRlIHNpemUgb2YgbGFiZWxcbiAgICByZXNpemVkID0gdXRpbC51cGRhdGVQcm9wZXJ0eSh0aGlzLnByb3BzLmxhYmVsLCAnd2lkdGgnLCB0aGlzLmRvbS5pbm5lci5jbGllbnRXaWR0aCkgfHwgcmVzaXplZDtcbiAgICByZXNpemVkID0gdXRpbC51cGRhdGVQcm9wZXJ0eSh0aGlzLnByb3BzLmxhYmVsLCAnaGVpZ2h0JywgdGhpcy5kb20uaW5uZXIuY2xpZW50SGVpZ2h0KSB8fCByZXNpemVkO1xuXG4gICAgLy8gYXBwbHkgbmV3IGhlaWdodFxuICAgIHRoaXMuZG9tLmJhY2tncm91bmQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICB0aGlzLmRvbS5mb3JlZ3JvdW5kLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgdGhpcy5kb20ubGFiZWwuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgIC8vIHVwZGF0ZSB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiBpdGVtcyBhZnRlciB0aGV5IGFyZSByZS1zdGFja2VkIGFuZCB0aGUgaGVpZ2h0IG9mIHRoZSBncm91cCBpcyBjYWxjdWxhdGVkXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy52aXNpYmxlSXRlbXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSB0aGlzLnZpc2libGVJdGVtc1tpXTtcbiAgICAgIGl0ZW0ucmVwb3NpdGlvblkobWFyZ2luKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzaXplZDtcbiAgfTtcblxuICAvKipcbiAgICogcmVjYWxjdWxhdGUgdGhlIGhlaWdodCBvZiB0aGUgc3ViZ3JvdXBzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBHcm91cC5wcm90b3R5cGUuX2NhbGN1bGF0ZVN1Ykdyb3VwSGVpZ2h0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5zdWJncm91cHMpLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICAgIHRoaXMucmVzZXRTdWJncm91cHMoKTtcblxuICAgICAgdXRpbC5mb3JFYWNoKHRoaXMudmlzaWJsZUl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5kYXRhLnN1Ymdyb3VwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBtZS5zdWJncm91cHNbaXRlbS5kYXRhLnN1Ymdyb3VwXS5oZWlnaHQgPSBNYXRoLm1heChtZS5zdWJncm91cHNbaXRlbS5kYXRhLnN1Ymdyb3VwXS5oZWlnaHQsIGl0ZW0uaGVpZ2h0KTtcbiAgICAgICAgICBtZS5zdWJncm91cHNbaXRlbS5kYXRhLnN1Ymdyb3VwXS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBjaGVjayBpZiBncm91cCBpcyB2aXNpYmxlXG4gICAqIEBwcml2YXRlXG4gICAgKi9cbiAgR3JvdXAucHJvdG90eXBlLl9pc0dyb3VwVmlzaWJsZSA9IGZ1bmN0aW9uIChyYW5nZSwgbWFyZ2luKSB7XG4gICAgdmFyIGlzVmlzaWJsZSA9IHRoaXMudG9wIDw9IHJhbmdlLmJvZHkuZG9tUHJvcHMuY2VudGVyQ29udGFpbmVyLmhlaWdodCAtIHJhbmdlLmJvZHkuZG9tUHJvcHMuc2Nyb2xsVG9wICsgbWFyZ2luLmF4aXMgJiYgdGhpcy50b3AgKyB0aGlzLmhlaWdodCArIG1hcmdpbi5heGlzID49IC1yYW5nZS5ib2R5LmRvbVByb3BzLnNjcm9sbFRvcDtcbiAgICByZXR1cm4gaXNWaXNpYmxlO1xuICB9O1xuXG4gIC8qKlxuICAgKiByZWNhbGN1bGF0ZSB0aGUgaGVpZ2h0IG9mIHRoZSBncm91cFxuICAgKiBAcGFyYW0ge3tpdGVtOiB7aG9yaXpvbnRhbDogbnVtYmVyLCB2ZXJ0aWNhbDogbnVtYmVyfSwgYXhpczogbnVtYmVyfX0gbWFyZ2luXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGhlaWdodFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgR3JvdXAucHJvdG90eXBlLl9jYWxjdWxhdGVIZWlnaHQgPSBmdW5jdGlvbiAobWFyZ2luKSB7XG4gICAgLy8gcmVjYWxjdWxhdGUgdGhlIGhlaWdodCBvZiB0aGUgZ3JvdXBcbiAgICB2YXIgaGVpZ2h0O1xuICAgIHZhciB2aXNpYmxlSXRlbXMgPSB0aGlzLnZpc2libGVJdGVtcztcbiAgICBpZiAodmlzaWJsZUl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBtaW4gPSB2aXNpYmxlSXRlbXNbMF0udG9wO1xuICAgICAgdmFyIG1heCA9IHZpc2libGVJdGVtc1swXS50b3AgKyB2aXNpYmxlSXRlbXNbMF0uaGVpZ2h0O1xuICAgICAgdXRpbC5mb3JFYWNoKHZpc2libGVJdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBpdGVtLnRvcCk7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgaXRlbS50b3AgKyBpdGVtLmhlaWdodCk7XG4gICAgICB9KTtcbiAgICAgIGlmIChtaW4gPiBtYXJnaW4uYXhpcykge1xuICAgICAgICAvLyB0aGVyZSBpcyBhbiBlbXB0eSBnYXAgYmV0d2VlbiB0aGUgbG93ZXN0IGl0ZW0gYW5kIHRoZSBheGlzXG4gICAgICAgIHZhciBvZmZzZXQgPSBtaW4gLSBtYXJnaW4uYXhpcztcbiAgICAgICAgbWF4IC09IG9mZnNldDtcbiAgICAgICAgdXRpbC5mb3JFYWNoKHZpc2libGVJdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICBpdGVtLnRvcCAtPSBvZmZzZXQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaGVpZ2h0ID0gbWF4ICsgbWFyZ2luLml0ZW0udmVydGljYWwgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWlnaHQgPSAwO1xuICAgIH1cbiAgICBoZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIHRoaXMucHJvcHMubGFiZWwuaGVpZ2h0KTtcblxuICAgIHJldHVybiBoZWlnaHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3cgdGhpcyBncm91cDogYXR0YWNoIHRvIHRoZSBET01cbiAgICovXG4gIEdyb3VwLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5kb20ubGFiZWwucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5pdGVtU2V0LmRvbS5sYWJlbFNldC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5sYWJlbCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmRvbS5mb3JlZ3JvdW5kLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuaXRlbVNldC5kb20uZm9yZWdyb3VuZC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5mb3JlZ3JvdW5kKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZG9tLmJhY2tncm91bmQucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5pdGVtU2V0LmRvbS5iYWNrZ3JvdW5kLmFwcGVuZENoaWxkKHRoaXMuZG9tLmJhY2tncm91bmQpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5kb20uYXhpcy5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLml0ZW1TZXQuZG9tLmF4aXMuYXBwZW5kQ2hpbGQodGhpcy5kb20uYXhpcyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIaWRlIHRoaXMgZ3JvdXA6IHJlbW92ZSBmcm9tIHRoZSBET01cbiAgICovXG4gIEdyb3VwLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsYWJlbCA9IHRoaXMuZG9tLmxhYmVsO1xuICAgIGlmIChsYWJlbC5wYXJlbnROb2RlKSB7XG4gICAgICBsYWJlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxhYmVsKTtcbiAgICB9XG5cbiAgICB2YXIgZm9yZWdyb3VuZCA9IHRoaXMuZG9tLmZvcmVncm91bmQ7XG4gICAgaWYgKGZvcmVncm91bmQucGFyZW50Tm9kZSkge1xuICAgICAgZm9yZWdyb3VuZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGZvcmVncm91bmQpO1xuICAgIH1cblxuICAgIHZhciBiYWNrZ3JvdW5kID0gdGhpcy5kb20uYmFja2dyb3VuZDtcbiAgICBpZiAoYmFja2dyb3VuZC5wYXJlbnROb2RlKSB7XG4gICAgICBiYWNrZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYmFja2dyb3VuZCk7XG4gICAgfVxuXG4gICAgdmFyIGF4aXMgPSB0aGlzLmRvbS5heGlzO1xuICAgIGlmIChheGlzLnBhcmVudE5vZGUpIHtcbiAgICAgIGF4aXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChheGlzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBpdGVtIHRvIHRoZSBncm91cFxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIEdyb3VwLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHRoaXMuaXRlbXNbaXRlbS5pZF0gPSBpdGVtO1xuICAgIGl0ZW0uc2V0UGFyZW50KHRoaXMpO1xuXG4gICAgLy8gYWRkIHRvXG4gICAgaWYgKGl0ZW0uZGF0YS5zdWJncm91cCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy5zdWJncm91cHNbaXRlbS5kYXRhLnN1Ymdyb3VwXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF0gPSB7IGhlaWdodDogMCwgdmlzaWJsZTogZmFsc2UsIGluZGV4OiB0aGlzLnN1Ymdyb3VwSW5kZXgsIGl0ZW1zOiBbXSB9O1xuICAgICAgICB0aGlzLnN1Ymdyb3VwSW5kZXgrKztcbiAgICAgIH1cbiAgICAgIHRoaXMuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF0uaXRlbXMucHVzaChpdGVtKTtcbiAgICB9XG4gICAgdGhpcy5vcmRlclN1Ymdyb3VwcygpO1xuXG4gICAgaWYgKHRoaXMudmlzaWJsZUl0ZW1zLmluZGV4T2YoaXRlbSkgPT0gLTEpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuaXRlbVNldC5ib2R5LnJhbmdlOyAvLyBUT0RPOiBub3QgbmljZSBhY2Nlc3NpbmcgdGhlIHJhbmdlIGxpa2UgdGhpc1xuICAgICAgdGhpcy5fY2hlY2tJZlZpc2libGUoaXRlbSwgdGhpcy52aXNpYmxlSXRlbXMsIHJhbmdlKTtcbiAgICB9XG4gIH07XG5cbiAgR3JvdXAucHJvdG90eXBlLm9yZGVyU3ViZ3JvdXBzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnN1Ymdyb3VwT3JkZXJlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgc29ydEFycmF5ID0gW107XG4gICAgICBpZiAodHlwZW9mIHRoaXMuc3ViZ3JvdXBPcmRlcmVyID09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZvciAodmFyIHN1Ymdyb3VwIGluIHRoaXMuc3ViZ3JvdXBzKSB7XG4gICAgICAgICAgc29ydEFycmF5LnB1c2goeyBzdWJncm91cDogc3ViZ3JvdXAsIHNvcnRGaWVsZDogdGhpcy5zdWJncm91cHNbc3ViZ3JvdXBdLml0ZW1zWzBdLmRhdGFbdGhpcy5zdWJncm91cE9yZGVyZXJdIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNvcnRBcnJheS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGEuc29ydEZpZWxkIC0gYi5zb3J0RmllbGQ7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5zdWJncm91cE9yZGVyZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3IgKHZhciBzdWJncm91cCBpbiB0aGlzLnN1Ymdyb3Vwcykge1xuICAgICAgICAgIHNvcnRBcnJheS5wdXNoKHRoaXMuc3ViZ3JvdXBzW3N1Ymdyb3VwXS5pdGVtc1swXS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBzb3J0QXJyYXkuc29ydCh0aGlzLnN1Ymdyb3VwT3JkZXJlcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzb3J0QXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvcnRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuc3ViZ3JvdXBzW3NvcnRBcnJheVtpXS5zdWJncm91cF0uaW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEdyb3VwLnByb3RvdHlwZS5yZXNldFN1Ymdyb3VwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzdWJncm91cCBpbiB0aGlzLnN1Ymdyb3Vwcykge1xuICAgICAgaWYgKHRoaXMuc3ViZ3JvdXBzLmhhc093blByb3BlcnR5KHN1Ymdyb3VwKSkge1xuICAgICAgICB0aGlzLnN1Ymdyb3Vwc1tzdWJncm91cF0udmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSB0aGUgZ3JvdXBcbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBHcm91cC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBkZWxldGUgdGhpcy5pdGVtc1tpdGVtLmlkXTtcbiAgICBpdGVtLnNldFBhcmVudChudWxsKTtcblxuICAgIC8vIHJlbW92ZSBmcm9tIHZpc2libGUgaXRlbXNcbiAgICB2YXIgaW5kZXggPSB0aGlzLnZpc2libGVJdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCAhPSAtMSkgdGhpcy52aXNpYmxlSXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgIGlmIChpdGVtLmRhdGEuc3ViZ3JvdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHN1Ymdyb3VwID0gdGhpcy5zdWJncm91cHNbaXRlbS5kYXRhLnN1Ymdyb3VwXTtcbiAgICAgIGlmIChzdWJncm91cCkge1xuICAgICAgICB2YXIgaXRlbUluZGV4ID0gc3ViZ3JvdXAuaXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgc3ViZ3JvdXAuaXRlbXMuc3BsaWNlKGl0ZW1JbmRleCwgMSk7XG4gICAgICAgIGlmICghc3ViZ3JvdXAuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF07XG4gICAgICAgICAgdGhpcy5zdWJncm91cEluZGV4LS07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcmRlclN1Ymdyb3VwcygpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSB0aGUgY29ycmVzcG9uZGluZyBEYXRhU2V0XG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgR3JvdXAucHJvdG90eXBlLnJlbW92ZUZyb21EYXRhU2V0ID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB0aGlzLml0ZW1TZXQucmVtb3ZlSXRlbShpdGVtLmlkKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVvcmRlciB0aGUgaXRlbXNcbiAgICovXG4gIEdyb3VwLnByb3RvdHlwZS5vcmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyYXkgPSB1dGlsLnRvQXJyYXkodGhpcy5pdGVtcyk7XG4gICAgdmFyIHN0YXJ0QXJyYXkgPSBbXTtcbiAgICB2YXIgZW5kQXJyYXkgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJheVtpXS5kYXRhLmVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZEFycmF5LnB1c2goYXJyYXlbaV0pO1xuICAgICAgfVxuICAgICAgc3RhcnRBcnJheS5wdXNoKGFycmF5W2ldKTtcbiAgICB9XG4gICAgdGhpcy5vcmRlcmVkSXRlbXMgPSB7XG4gICAgICBieVN0YXJ0OiBzdGFydEFycmF5LFxuICAgICAgYnlFbmQ6IGVuZEFycmF5XG4gICAgfTtcblxuICAgIHN0YWNrLm9yZGVyQnlTdGFydCh0aGlzLm9yZGVyZWRJdGVtcy5ieVN0YXJ0KTtcbiAgICBzdGFjay5vcmRlckJ5RW5kKHRoaXMub3JkZXJlZEl0ZW1zLmJ5RW5kKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB2aXNpYmxlIGl0ZW1zXG4gICAqIEBwYXJhbSB7e2J5U3RhcnQ6IEl0ZW1bXSwgYnlFbmQ6IEl0ZW1bXX19IG9yZGVyZWRJdGVtcyAgIEFsbCBpdGVtcyBvcmRlcmVkIGJ5IHN0YXJ0IGRhdGUgYW5kIGJ5IGVuZCBkYXRlXG4gICAqIEBwYXJhbSB7SXRlbVtdfSB2aXNpYmxlSXRlbXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBwcmV2aW91c2x5IHZpc2libGUgaXRlbXMuXG4gICAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gcmFuZ2UgICAgICAgICAgICAgIFZpc2libGUgcmFuZ2VcbiAgICogQHJldHVybiB7SXRlbVtdfSB2aXNpYmxlSXRlbXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG5ldyB2aXNpYmxlIGl0ZW1zLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgR3JvdXAucHJvdG90eXBlLl91cGRhdGVWaXNpYmxlSXRlbXMgPSBmdW5jdGlvbiAob3JkZXJlZEl0ZW1zLCBvbGRWaXNpYmxlSXRlbXMsIHJhbmdlKSB7XG4gICAgdmFyIHZpc2libGVJdGVtcyA9IFtdO1xuICAgIHZhciB2aXNpYmxlSXRlbXNMb29rdXAgPSB7fTsgLy8gd2Uga2VlcCB0aGlzIHRvIHF1aWNrbHkgbG9vayB1cCBpZiBhbiBpdGVtIGFscmVhZHkgZXhpc3RzIGluIHRoZSBsaXN0IHdpdGhvdXQgdXNpbmcgaW5kZXhPZiBvbiB2aXNpYmxlSXRlbXNcbiAgICBpZiAoIXRoaXMuaXNWaXNpYmxlICYmIHRoaXMuZ3JvdXBJZCAhPSBcIl9fYmFja2dyb3VuZF9fXCIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2xkVmlzaWJsZUl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gb2xkVmlzaWJsZUl0ZW1zW2ldO1xuICAgICAgICBpZiAoaXRlbS5kaXNwbGF5ZWQpIGl0ZW0uaGlkZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZpc2libGVJdGVtcztcbiAgICB9XG5cbiAgICB2YXIgaW50ZXJ2YWwgPSAocmFuZ2UuZW5kIC0gcmFuZ2Uuc3RhcnQpIC8gNDtcbiAgICB2YXIgbG93ZXJCb3VuZCA9IHJhbmdlLnN0YXJ0IC0gaW50ZXJ2YWw7XG4gICAgdmFyIHVwcGVyQm91bmQgPSByYW5nZS5lbmQgKyBpbnRlcnZhbDtcblxuICAgIC8vIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBkbyB0aGUgYmluYXJ5IHNlYXJjaC5cbiAgICB2YXIgc2VhcmNoRnVuY3Rpb24gPSBmdW5jdGlvbiBzZWFyY2hGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlIDwgbG93ZXJCb3VuZCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlIDw9IHVwcGVyQm91bmQpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gZmlyc3QgY2hlY2sgaWYgdGhlIGl0ZW1zIHRoYXQgd2VyZSBpbiB2aWV3IHByZXZpb3VzbHkgYXJlIHN0aWxsIGluIHZpZXcuXG4gICAgLy8gSU1QT1JUQU5UOiB0aGlzIGhhbmRsZXMgdGhlIGNhc2UgZm9yIHRoZSBpdGVtcyB3aXRoIHN0YXJ0ZGF0ZSBiZWZvcmUgdGhlIHdpbmRvdyBhbmQgZW5kZGF0ZSBhZnRlciB0aGUgd2luZG93IVxuICAgIC8vIGFsc28gY2xlYW5zIHVwIGludmlzaWJsZSBpdGVtcy5cbiAgICBpZiAob2xkVmlzaWJsZUl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2xkVmlzaWJsZUl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrSWZWaXNpYmxlV2l0aFJlZmVyZW5jZShvbGRWaXNpYmxlSXRlbXNbaV0sIHZpc2libGVJdGVtcywgdmlzaWJsZUl0ZW1zTG9va3VwLCByYW5nZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gd2UgZG8gYSBiaW5hcnkgc2VhcmNoIGZvciB0aGUgaXRlbXMgdGhhdCBoYXZlIG9ubHkgc3RhcnQgdmFsdWVzLlxuICAgIHZhciBpbml0aWFsUG9zQnlTdGFydCA9IHV0aWwuYmluYXJ5U2VhcmNoQ3VzdG9tKG9yZGVyZWRJdGVtcy5ieVN0YXJ0LCBzZWFyY2hGdW5jdGlvbiwgJ2RhdGEnLCAnc3RhcnQnKTtcblxuICAgIC8vIHRyYWNlIHRoZSB2aXNpYmxlIGl0ZW1zIGZyb20gdGhlIGluaXRhbCBzdGFydCBwb3MgYm90aCB3YXlzIHVudGlsIGFuIGludmlzaWJsZSBpdGVtIGlzIGZvdW5kLCB3ZSBvbmx5IGxvb2sgYXQgdGhlIHN0YXJ0IHZhbHVlcy5cbiAgICB0aGlzLl90cmFjZVZpc2libGUoaW5pdGlhbFBvc0J5U3RhcnQsIG9yZGVyZWRJdGVtcy5ieVN0YXJ0LCB2aXNpYmxlSXRlbXMsIHZpc2libGVJdGVtc0xvb2t1cCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLmRhdGEuc3RhcnQgPCBsb3dlckJvdW5kIHx8IGl0ZW0uZGF0YS5zdGFydCA+IHVwcGVyQm91bmQ7XG4gICAgfSk7XG5cbiAgICAvLyBpZiB0aGUgd2luZG93IGhhcyBjaGFuZ2VkIHByb2dyYW1tYXRpY2FsbHkgd2l0aG91dCBvdmVybGFwcGluZyB0aGUgb2xkIHdpbmRvdywgdGhlIHJhbmdlZCBpdGVtcyB3aXRoIHN0YXJ0IDwgbG93ZXJCb3VuZCBhbmQgZW5kID4gdXBwZXJib3VuZCBhcmUgbm90IHNob3duLlxuICAgIC8vIFdlIHRoZXJlZm9yZSBoYXZlIHRvIGJydXRlIGZvcmNlIGNoZWNrIGFsbCBpdGVtcyBpbiB0aGUgYnlFbmQgbGlzdFxuICAgIGlmICh0aGlzLmNoZWNrUmFuZ2VkSXRlbXMgPT0gdHJ1ZSkge1xuICAgICAgdGhpcy5jaGVja1JhbmdlZEl0ZW1zID0gZmFsc2U7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgb3JkZXJlZEl0ZW1zLmJ5RW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrSWZWaXNpYmxlV2l0aFJlZmVyZW5jZShvcmRlcmVkSXRlbXMuYnlFbmRbaV0sIHZpc2libGVJdGVtcywgdmlzaWJsZUl0ZW1zTG9va3VwLCByYW5nZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdlIGRvIGEgYmluYXJ5IHNlYXJjaCBmb3IgdGhlIGl0ZW1zIHRoYXQgaGF2ZSBkZWZpbmVkIGVuZCB0aW1lcy5cbiAgICAgIHZhciBpbml0aWFsUG9zQnlFbmQgPSB1dGlsLmJpbmFyeVNlYXJjaEN1c3RvbShvcmRlcmVkSXRlbXMuYnlFbmQsIHNlYXJjaEZ1bmN0aW9uLCAnZGF0YScsICdlbmQnKTtcblxuICAgICAgLy8gdHJhY2UgdGhlIHZpc2libGUgaXRlbXMgZnJvbSB0aGUgaW5pdGFsIHN0YXJ0IHBvcyBib3RoIHdheXMgdW50aWwgYW4gaW52aXNpYmxlIGl0ZW0gaXMgZm91bmQsIHdlIG9ubHkgbG9vayBhdCB0aGUgZW5kIHZhbHVlcy5cbiAgICAgIHRoaXMuX3RyYWNlVmlzaWJsZShpbml0aWFsUG9zQnlFbmQsIG9yZGVyZWRJdGVtcy5ieUVuZCwgdmlzaWJsZUl0ZW1zLCB2aXNpYmxlSXRlbXNMb29rdXAsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmRhdGEuZW5kIDwgbG93ZXJCb3VuZCB8fCBpdGVtLmRhdGEuZW5kID4gdXBwZXJCb3VuZDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGZpbmFsbHksIHdlIHJlcG9zaXRpb24gYWxsIHRoZSB2aXNpYmxlIGl0ZW1zLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlzaWJsZUl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHZpc2libGVJdGVtc1tpXTtcbiAgICAgIGlmICghaXRlbS5kaXNwbGF5ZWQpIGl0ZW0uc2hvdygpO1xuICAgICAgLy8gcmVwb3NpdGlvbiBpdGVtIGhvcml6b250YWxseVxuICAgICAgaXRlbS5yZXBvc2l0aW9uWCgpO1xuICAgIH1cblxuICAgIHJldHVybiB2aXNpYmxlSXRlbXM7XG4gIH07XG5cbiAgR3JvdXAucHJvdG90eXBlLl90cmFjZVZpc2libGUgPSBmdW5jdGlvbiAoaW5pdGlhbFBvcywgaXRlbXMsIHZpc2libGVJdGVtcywgdmlzaWJsZUl0ZW1zTG9va3VwLCBicmVha0NvbmRpdGlvbikge1xuICAgIGlmIChpbml0aWFsUG9zICE9IC0xKSB7XG4gICAgICBmb3IgKHZhciBpID0gaW5pdGlhbFBvczsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKGJyZWFrQ29uZGl0aW9uKGl0ZW0pKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZpc2libGVJdGVtc0xvb2t1cFtpdGVtLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2aXNpYmxlSXRlbXNMb29rdXBbaXRlbS5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgdmlzaWJsZUl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSBpbml0aWFsUG9zICsgMTsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChicmVha0NvbmRpdGlvbihpdGVtKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2aXNpYmxlSXRlbXNMb29rdXBbaXRlbS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmlzaWJsZUl0ZW1zTG9va3VwW2l0ZW0uaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIHZpc2libGVJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogdGhpcyBmdW5jdGlvbiBpcyB2ZXJ5IHNpbWlsYXIgdG8gdGhlIF9jaGVja0lmSW52aXNpYmxlKCkgYnV0IGl0IGRvZXMgbm90XG4gICAqIHJldHVybiBib29sZWFucywgaGlkZXMgdGhlIGl0ZW0gaWYgaXQgc2hvdWxkIG5vdCBiZSBzZWVuIGFuZCBhbHdheXMgYWRkcyB0b1xuICAgKiB0aGUgdmlzaWJsZUl0ZW1zLlxuICAgKiB0aGlzIG9uZSBpcyBmb3IgYnJ1dGUgZm9yY2luZyBhbmQgaGlkaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICogQHBhcmFtIHtBcnJheX0gdmlzaWJsZUl0ZW1zXG4gICAqIEBwYXJhbSB7e3N0YXJ0Om51bWJlciwgZW5kOm51bWJlcn19IHJhbmdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBHcm91cC5wcm90b3R5cGUuX2NoZWNrSWZWaXNpYmxlID0gZnVuY3Rpb24gKGl0ZW0sIHZpc2libGVJdGVtcywgcmFuZ2UpIHtcbiAgICBpZiAoaXRlbS5pc1Zpc2libGUocmFuZ2UpKSB7XG4gICAgICBpZiAoIWl0ZW0uZGlzcGxheWVkKSBpdGVtLnNob3coKTtcbiAgICAgIC8vIHJlcG9zaXRpb24gaXRlbSBob3Jpem9udGFsbHlcbiAgICAgIGl0ZW0ucmVwb3NpdGlvblgoKTtcbiAgICAgIHZpc2libGVJdGVtcy5wdXNoKGl0ZW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXRlbS5kaXNwbGF5ZWQpIGl0ZW0uaGlkZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogdGhpcyBmdW5jdGlvbiBpcyB2ZXJ5IHNpbWlsYXIgdG8gdGhlIF9jaGVja0lmSW52aXNpYmxlKCkgYnV0IGl0IGRvZXMgbm90XG4gICAqIHJldHVybiBib29sZWFucywgaGlkZXMgdGhlIGl0ZW0gaWYgaXQgc2hvdWxkIG5vdCBiZSBzZWVuIGFuZCBhbHdheXMgYWRkcyB0b1xuICAgKiB0aGUgdmlzaWJsZUl0ZW1zLlxuICAgKiB0aGlzIG9uZSBpcyBmb3IgYnJ1dGUgZm9yY2luZyBhbmQgaGlkaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICogQHBhcmFtIHtBcnJheX0gdmlzaWJsZUl0ZW1zXG4gICAqIEBwYXJhbSB7e3N0YXJ0Om51bWJlciwgZW5kOm51bWJlcn19IHJhbmdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBHcm91cC5wcm90b3R5cGUuX2NoZWNrSWZWaXNpYmxlV2l0aFJlZmVyZW5jZSA9IGZ1bmN0aW9uIChpdGVtLCB2aXNpYmxlSXRlbXMsIHZpc2libGVJdGVtc0xvb2t1cCwgcmFuZ2UpIHtcbiAgICBpZiAoaXRlbS5pc1Zpc2libGUocmFuZ2UpKSB7XG4gICAgICBpZiAodmlzaWJsZUl0ZW1zTG9va3VwW2l0ZW0uaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmlzaWJsZUl0ZW1zTG9va3VwW2l0ZW0uaWRdID0gdHJ1ZTtcbiAgICAgICAgdmlzaWJsZUl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpdGVtLmRpc3BsYXllZCkgaXRlbS5oaWRlKCk7XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gR3JvdXA7XG5cbi8qKiovIH0sXG4vKiAzOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBvcmRlcmluZyBhbmQgc3RhY2tpbmcgb2YgaXRlbXNcbiAgdmFyIEVQU0lMT04gPSAwLjAwMTsgLy8gdXNlZCB3aGVuIGNoZWNraW5nIGNvbGxpc2lvbnMsIHRvIHByZXZlbnQgcm91bmQtb2ZmIGVycm9yc1xuXG4gIC8qKlxuICAgKiBPcmRlciBpdGVtcyBieSB0aGVpciBzdGFydCBkYXRhXG4gICAqIEBwYXJhbSB7SXRlbVtdfSBpdGVtc1xuICAgKi9cbiAgZXhwb3J0cy5vcmRlckJ5U3RhcnQgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICBpdGVtcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5kYXRhLnN0YXJ0IC0gYi5kYXRhLnN0YXJ0O1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBPcmRlciBpdGVtcyBieSB0aGVpciBlbmQgZGF0ZS4gSWYgdGhleSBoYXZlIG5vIGVuZCBkYXRlLCB0aGVpciBzdGFydCBkYXRlXG4gICAqIGlzIHVzZWQuXG4gICAqIEBwYXJhbSB7SXRlbVtdfSBpdGVtc1xuICAgKi9cbiAgZXhwb3J0cy5vcmRlckJ5RW5kID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgaXRlbXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgdmFyIGFUaW1lID0gJ2VuZCcgaW4gYS5kYXRhID8gYS5kYXRhLmVuZCA6IGEuZGF0YS5zdGFydCxcbiAgICAgICAgICBiVGltZSA9ICdlbmQnIGluIGIuZGF0YSA/IGIuZGF0YS5lbmQgOiBiLmRhdGEuc3RhcnQ7XG5cbiAgICAgIHJldHVybiBhVGltZSAtIGJUaW1lO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGp1c3QgdmVydGljYWwgcG9zaXRpb25zIG9mIHRoZSBpdGVtcyBzdWNoIHRoYXQgdGhleSBkb24ndCBvdmVybGFwIGVhY2hcbiAgICogb3RoZXIuXG4gICAqIEBwYXJhbSB7SXRlbVtdfSBpdGVtc1xuICAgKiAgICAgICAgICAgIEFsbCB2aXNpYmxlIGl0ZW1zXG4gICAqIEBwYXJhbSB7e2l0ZW06IHtob3Jpem9udGFsOiBudW1iZXIsIHZlcnRpY2FsOiBudW1iZXJ9LCBheGlzOiBudW1iZXJ9fSBtYXJnaW5cbiAgICogICAgICAgICAgICBNYXJnaW5zIGJldHdlZW4gaXRlbXMgYW5kIGJldHdlZW4gaXRlbXMgYW5kIHRoZSBheGlzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZT1mYWxzZV1cbiAgICogICAgICAgICAgICBJZiB0cnVlLCBhbGwgaXRlbXMgd2lsbCBiZSByZXBvc2l0aW9uZWQuIElmIGZhbHNlIChkZWZhdWx0KSwgb25seVxuICAgKiAgICAgICAgICAgIGl0ZW1zIGhhdmluZyBhIHRvcD09PW51bGwgd2lsbCBiZSByZS1zdGFja2VkXG4gICAqL1xuICBleHBvcnRzLnN0YWNrID0gZnVuY3Rpb24gKGl0ZW1zLCBtYXJnaW4sIGZvcmNlKSB7XG4gICAgdmFyIGksIGlNYXg7XG4gICAgaWYgKGZvcmNlKSB7XG4gICAgICAvLyByZXNldCB0b3AgcG9zaXRpb24gb2YgYWxsIGl0ZW1zXG4gICAgICBmb3IgKGkgPSAwLCBpTWF4ID0gaXRlbXMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICAgIGl0ZW1zW2ldLnRvcCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIG5ldywgbm9uLW92ZXJsYXBwaW5nIHBvc2l0aW9uc1xuICAgIGZvciAoaSA9IDAsIGlNYXggPSBpdGVtcy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG4gICAgICBpZiAoaXRlbS5zdGFjayAmJiBpdGVtLnRvcCA9PT0gbnVsbCkge1xuICAgICAgICAvLyBpbml0aWFsaXplIHRvcCBwb3NpdGlvblxuICAgICAgICBpdGVtLnRvcCA9IG1hcmdpbi5heGlzO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvLyBUT0RPOiBvcHRpbWl6ZSBjaGVja2luZyBmb3Igb3ZlcmxhcC4gd2hlbiB0aGVyZSBpcyBhIGdhcCB3aXRob3V0IGl0ZW1zLFxuICAgICAgICAgIC8vICAgICAgIHlvdSBvbmx5IG5lZWQgdG8gY2hlY2sgZm9yIGl0ZW1zIGZyb20gdGhlIG5leHQgaXRlbSBvbiwgbm90IGZyb20gemVyb1xuICAgICAgICAgIHZhciBjb2xsaWRpbmdJdGVtID0gbnVsbDtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamogPSBpdGVtcy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBpdGVtc1tqXTtcbiAgICAgICAgICAgIGlmIChvdGhlci50b3AgIT09IG51bGwgJiYgb3RoZXIgIT09IGl0ZW0gJiYgb3RoZXIuc3RhY2sgJiYgZXhwb3J0cy5jb2xsaXNpb24oaXRlbSwgb3RoZXIsIG1hcmdpbi5pdGVtLCBvdGhlci5vcHRpb25zLnJ0bCkpIHtcbiAgICAgICAgICAgICAgY29sbGlkaW5nSXRlbSA9IG90aGVyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29sbGlkaW5nSXRlbSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBhIGNvbGxpc2lvbi4gUmVwb3NpdGlvbiB0aGUgaXRlbXMgYWJvdmUgdGhlIGNvbGxpZGluZyBlbGVtZW50XG4gICAgICAgICAgICBpdGVtLnRvcCA9IGNvbGxpZGluZ0l0ZW0udG9wICsgY29sbGlkaW5nSXRlbS5oZWlnaHQgKyBtYXJnaW4uaXRlbS52ZXJ0aWNhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGNvbGxpZGluZ0l0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRqdXN0IHZlcnRpY2FsIHBvc2l0aW9ucyBvZiB0aGUgaXRlbXMgd2l0aG91dCBzdGFja2luZyB0aGVtXG4gICAqIEBwYXJhbSB7SXRlbVtdfSBpdGVtc1xuICAgKiAgICAgICAgICAgIEFsbCB2aXNpYmxlIGl0ZW1zXG4gICAqIEBwYXJhbSB7e2l0ZW06IHtob3Jpem9udGFsOiBudW1iZXIsIHZlcnRpY2FsOiBudW1iZXJ9LCBheGlzOiBudW1iZXJ9fSBtYXJnaW5cbiAgICogICAgICAgICAgICBNYXJnaW5zIGJldHdlZW4gaXRlbXMgYW5kIGJldHdlZW4gaXRlbXMgYW5kIHRoZSBheGlzLlxuICAgKi9cbiAgZXhwb3J0cy5ub3N0YWNrID0gZnVuY3Rpb24gKGl0ZW1zLCBtYXJnaW4sIHN1Ymdyb3Vwcykge1xuICAgIHZhciBpLCBpTWF4LCBuZXdUb3A7XG5cbiAgICAvLyByZXNldCB0b3AgcG9zaXRpb24gb2YgYWxsIGl0ZW1zXG4gICAgZm9yIChpID0gMCwgaU1heCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgaWYgKGl0ZW1zW2ldLmRhdGEuc3ViZ3JvdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdUb3AgPSBtYXJnaW4uYXhpcztcbiAgICAgICAgZm9yICh2YXIgc3ViZ3JvdXAgaW4gc3ViZ3JvdXBzKSB7XG4gICAgICAgICAgaWYgKHN1Ymdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShzdWJncm91cCkpIHtcbiAgICAgICAgICAgIGlmIChzdWJncm91cHNbc3ViZ3JvdXBdLnZpc2libGUgPT0gdHJ1ZSAmJiBzdWJncm91cHNbc3ViZ3JvdXBdLmluZGV4IDwgc3ViZ3JvdXBzW2l0ZW1zW2ldLmRhdGEuc3ViZ3JvdXBdLmluZGV4KSB7XG4gICAgICAgICAgICAgIG5ld1RvcCArPSBzdWJncm91cHNbc3ViZ3JvdXBdLmhlaWdodCArIG1hcmdpbi5pdGVtLnZlcnRpY2FsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpdGVtc1tpXS50b3AgPSBuZXdUb3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtc1tpXS50b3AgPSBtYXJnaW4uYXhpcztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlc3QgaWYgdGhlIHR3byBwcm92aWRlZCBpdGVtcyBjb2xsaWRlXG4gICAqIFRoZSBpdGVtcyBtdXN0IGhhdmUgcGFyYW1ldGVycyBsZWZ0LCB3aWR0aCwgdG9wLCBhbmQgaGVpZ2h0LlxuICAgKiBAcGFyYW0ge0l0ZW19IGEgICAgICAgICAgVGhlIGZpcnN0IGl0ZW1cbiAgICogQHBhcmFtIHtJdGVtfSBiICAgICAgICAgIFRoZSBzZWNvbmQgaXRlbVxuICAgKiBAcGFyYW0ge3tob3Jpem9udGFsOiBudW1iZXIsIHZlcnRpY2FsOiBudW1iZXJ9fSBtYXJnaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIGEgaG9yaXpvbnRhbCBhbmQgdmVydGljYWxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW0gcmVxdWlyZWQgbWFyZ2luLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJ0bFxuICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgdHJ1ZSBpZiBhIGFuZCBiIGNvbGxpZGUsIGVsc2UgZmFsc2VcbiAgICovXG4gIGV4cG9ydHMuY29sbGlzaW9uID0gZnVuY3Rpb24gKGEsIGIsIG1hcmdpbiwgcnRsKSB7XG4gICAgaWYgKHJ0bCkge1xuICAgICAgcmV0dXJuIGEucmlnaHQgLSBtYXJnaW4uaG9yaXpvbnRhbCArIEVQU0lMT04gPCBiLnJpZ2h0ICsgYi53aWR0aCAmJiBhLnJpZ2h0ICsgYS53aWR0aCArIG1hcmdpbi5ob3Jpem9udGFsIC0gRVBTSUxPTiA+IGIucmlnaHQgJiYgYS50b3AgLSBtYXJnaW4udmVydGljYWwgKyBFUFNJTE9OIDwgYi50b3AgKyBiLmhlaWdodCAmJiBhLnRvcCArIGEuaGVpZ2h0ICsgbWFyZ2luLnZlcnRpY2FsIC0gRVBTSUxPTiA+IGIudG9wO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYS5sZWZ0IC0gbWFyZ2luLmhvcml6b250YWwgKyBFUFNJTE9OIDwgYi5sZWZ0ICsgYi53aWR0aCAmJiBhLmxlZnQgKyBhLndpZHRoICsgbWFyZ2luLmhvcml6b250YWwgLSBFUFNJTE9OID4gYi5sZWZ0ICYmIGEudG9wIC0gbWFyZ2luLnZlcnRpY2FsICsgRVBTSUxPTiA8IGIudG9wICsgYi5oZWlnaHQgJiYgYS50b3AgKyBhLmhlaWdodCArIG1hcmdpbi52ZXJ0aWNhbCAtIEVQU0lMT04gPiBiLnRvcDtcbiAgICB9XG4gIH07XG5cbi8qKiovIH0sXG4vKiA0MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBIYW1tZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcbiAgdmFyIEl0ZW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yIFJhbmdlSXRlbVxuICAgKiBAZXh0ZW5kcyBJdGVtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnMgc3RhcnQsIGVuZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LCBjbGFzc05hbWUuXG4gICAqIEBwYXJhbSB7e3RvU2NyZWVuOiBmdW5jdGlvbiwgdG9UaW1lOiBmdW5jdGlvbn19IGNvbnZlcnNpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udmVyc2lvbiBmdW5jdGlvbnMgZnJvbSB0aW1lIHRvIHNjcmVlbiBhbmQgdmljZSB2ZXJzYVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZGVzY3JpYmUgb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gUmFuZ2VJdGVtKGRhdGEsIGNvbnZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICB0aGlzLnByb3BzID0ge1xuICAgICAgY29udGVudDoge1xuICAgICAgICB3aWR0aDogMFxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vdmVyZmxvdyA9IGZhbHNlOyAvLyBpZiBjb250ZW50cyBjYW4gb3ZlcmZsb3cgKGNzcyBzdHlsaW5nKSwgdGhpcyBmbGFnIGlzIHNldCB0byB0cnVlXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyB2YWxpZGF0ZSBkYXRhXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLnN0YXJ0ID09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IFwic3RhcnRcIiBtaXNzaW5nIGluIGl0ZW0gJyArIGRhdGEuaWQpO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuZW5kID09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IFwiZW5kXCIgbWlzc2luZyBpbiBpdGVtICcgKyBkYXRhLmlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBJdGVtLmNhbGwodGhpcywgZGF0YSwgY29udmVyc2lvbiwgb3B0aW9ucyk7XG4gIH1cblxuICBSYW5nZUl0ZW0ucHJvdG90eXBlID0gbmV3IEl0ZW0obnVsbCwgbnVsbCwgbnVsbCk7XG5cbiAgUmFuZ2VJdGVtLnByb3RvdHlwZS5iYXNlQ2xhc3NOYW1lID0gJ3Zpcy1pdGVtIHZpcy1yYW5nZSc7XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhpcyBpdGVtIGlzIHZpc2libGUgaW5zaWRlIGdpdmVuIHJhbmdlXG4gICAqIEByZXR1cm5zIHt7c3RhcnQ6IE51bWJlciwgZW5kOiBOdW1iZXJ9fSByYW5nZSB3aXRoIGEgdGltZXN0YW1wIGZvciBzdGFydCBhbmQgZW5kXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZpc2libGVcbiAgICovXG4gIFJhbmdlSXRlbS5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgLy8gZGV0ZXJtaW5lIHZpc2liaWxpdHlcbiAgICByZXR1cm4gdGhpcy5kYXRhLnN0YXJ0IDwgcmFuZ2UuZW5kICYmIHRoaXMuZGF0YS5lbmQgPiByYW5nZS5zdGFydDtcbiAgfTtcblxuICAvKipcbiAgICogUmVwYWludCB0aGUgaXRlbVxuICAgKi9cbiAgUmFuZ2VJdGVtLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgIGlmICghZG9tKSB7XG4gICAgICAvLyBjcmVhdGUgRE9NXG4gICAgICB0aGlzLmRvbSA9IHt9O1xuICAgICAgZG9tID0gdGhpcy5kb207XG5cbiAgICAgIC8vIGJhY2tncm91bmQgYm94XG4gICAgICBkb20uYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAvLyBjbGFzc05hbWUgaXMgdXBkYXRlZCBpbiByZWRyYXcoKVxuXG4gICAgICAvLyBmcmFtZSBib3ggKHRvIHByZXZlbnQgdGhlIGl0ZW0gY29udGVudHMgZnJvbSBvdmVyZmxvd2luZ1xuICAgICAgZG9tLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkb20uZnJhbWUuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtLW92ZXJmbG93JztcbiAgICAgIGRvbS5ib3guYXBwZW5kQ2hpbGQoZG9tLmZyYW1lKTtcblxuICAgICAgLy8gY29udGVudHMgYm94XG4gICAgICBkb20uY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZG9tLmNvbnRlbnQuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtLWNvbnRlbnQnO1xuICAgICAgZG9tLmZyYW1lLmFwcGVuZENoaWxkKGRvbS5jb250ZW50KTtcblxuICAgICAgLy8gYXR0YWNoIHRoaXMgaXRlbSBhcyBhdHRyaWJ1dGVcbiAgICAgIGRvbS5ib3hbJ3RpbWVsaW5lLWl0ZW0nXSA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGFwcGVuZCBET00gdG8gcGFyZW50IERPTVxuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyBpdGVtOiBubyBwYXJlbnQgYXR0YWNoZWQnKTtcbiAgICB9XG4gICAgaWYgKCFkb20uYm94LnBhcmVudE5vZGUpIHtcbiAgICAgIHZhciBmb3JlZ3JvdW5kID0gdGhpcy5wYXJlbnQuZG9tLmZvcmVncm91bmQ7XG4gICAgICBpZiAoIWZvcmVncm91bmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IHBhcmVudCBoYXMgbm8gZm9yZWdyb3VuZCBjb250YWluZXIgZWxlbWVudCcpO1xuICAgICAgfVxuICAgICAgZm9yZWdyb3VuZC5hcHBlbmRDaGlsZChkb20uYm94KTtcbiAgICB9XG4gICAgdGhpcy5kaXNwbGF5ZWQgPSB0cnVlO1xuXG4gICAgLy8gVXBkYXRlIERPTSB3aGVuIGl0ZW0gaXMgbWFya2VkIGRpcnR5LiBBbiBpdGVtIGlzIG1hcmtlZCBkaXJ0eSB3aGVuOlxuICAgIC8vIC0gdGhlIGl0ZW0gaXMgbm90IHlldCByZW5kZXJlZFxuICAgIC8vIC0gdGhlIGl0ZW0ncyBkYXRhIGlzIGNoYW5nZWRcbiAgICAvLyAtIHRoZSBpdGVtIGlzIHNlbGVjdGVkL2Rlc2VsZWN0ZWRcbiAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgdGhpcy5fdXBkYXRlQ29udGVudHModGhpcy5kb20uY29udGVudCk7XG4gICAgICB0aGlzLl91cGRhdGVUaXRsZSh0aGlzLmRvbS5ib3gpO1xuICAgICAgdGhpcy5fdXBkYXRlRGF0YUF0dHJpYnV0ZXModGhpcy5kb20uYm94KTtcbiAgICAgIHRoaXMuX3VwZGF0ZVN0eWxlKHRoaXMuZG9tLmJveCk7XG5cbiAgICAgIHZhciBlZGl0YWJsZSA9ICh0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlVGltZSB8fCB0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlR3JvdXAgfHwgdGhpcy5lZGl0YWJsZSA9PT0gdHJ1ZSkgJiYgdGhpcy5lZGl0YWJsZSAhPT0gZmFsc2U7XG5cbiAgICAgIC8vIHVwZGF0ZSBjbGFzc1xuICAgICAgdmFyIGNsYXNzTmFtZSA9ICh0aGlzLmRhdGEuY2xhc3NOYW1lID8gJyAnICsgdGhpcy5kYXRhLmNsYXNzTmFtZSA6ICcnKSArICh0aGlzLnNlbGVjdGVkID8gJyB2aXMtc2VsZWN0ZWQnIDogJycpICsgKGVkaXRhYmxlID8gJyB2aXMtZWRpdGFibGUnIDogJyB2aXMtcmVhZG9ubHknKTtcbiAgICAgIGRvbS5ib3guY2xhc3NOYW1lID0gdGhpcy5iYXNlQ2xhc3NOYW1lICsgY2xhc3NOYW1lO1xuXG4gICAgICAvLyBkZXRlcm1pbmUgZnJvbSBjc3Mgd2hldGhlciB0aGlzIGJveCBoYXMgb3ZlcmZsb3dcbiAgICAgIHRoaXMub3ZlcmZsb3cgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20uZnJhbWUpLm92ZXJmbG93ICE9PSAnaGlkZGVuJztcblxuICAgICAgLy8gcmVjYWxjdWxhdGUgc2l6ZVxuICAgICAgLy8gdHVybiBvZmYgbWF4LXdpZHRoIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHRoZSByZWFsIHdpZHRoXG4gICAgICAvLyB0aGlzIGNhdXNlcyBhbiBleHRyYSBicm93c2VyIHJlcGFpbnQvcmVmbG93LCBidXQgc28gYmUgaXRcbiAgICAgIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUubWF4V2lkdGggPSAnbm9uZSc7XG4gICAgICB0aGlzLnByb3BzLmNvbnRlbnQud2lkdGggPSB0aGlzLmRvbS5jb250ZW50Lm9mZnNldFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmRvbS5ib3gub2Zmc2V0SGVpZ2h0O1xuICAgICAgdGhpcy5kb20uY29udGVudC5zdHlsZS5tYXhXaWR0aCA9ICcnO1xuXG4gICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVwYWludE9uSXRlbVVwZGF0ZVRpbWVUb29sdGlwKGRvbS5ib3gpO1xuICAgIHRoaXMuX3JlcGFpbnREZWxldGVCdXR0b24oZG9tLmJveCk7XG4gICAgdGhpcy5fcmVwYWludERyYWdDZW50ZXIoKTtcbiAgICB0aGlzLl9yZXBhaW50RHJhZ0xlZnQoKTtcbiAgICB0aGlzLl9yZXBhaW50RHJhZ1JpZ2h0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIGl0ZW0gaW4gdGhlIERPTSAod2hlbiBub3QgYWxyZWFkeSB2aXNpYmxlKS4gVGhlIGl0ZW1zIERPTSB3aWxsXG4gICAqIGJlIGNyZWF0ZWQgd2hlbiBuZWVkZWQuXG4gICAqL1xuICBSYW5nZUl0ZW0ucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmRpc3BsYXllZCkge1xuICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIGl0ZW0gZnJvbSB0aGUgRE9NICh3aGVuIHZpc2libGUpXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGNoYW5nZWRcbiAgICovXG4gIFJhbmdlSXRlbS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kaXNwbGF5ZWQpIHtcbiAgICAgIHZhciBib3ggPSB0aGlzLmRvbS5ib3g7XG5cbiAgICAgIGlmIChib3gucGFyZW50Tm9kZSkge1xuICAgICAgICBib3gucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChib3gpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRpc3BsYXllZCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVwb3NpdGlvbiB0aGUgaXRlbSBob3Jpem9udGFsbHlcbiAgICogQHBhcmFtIHtib29sZWFufSBbbGltaXRTaXplPXRydWVdIElmIHRydWUgKGRlZmF1bHQpLCB0aGUgd2lkdGggb2YgdGhlIHJhbmdlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtIHdpbGwgYmUgbGltaXRlZCwgYXMgdGhlIGJyb3dzZXIgY2Fubm90XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5IHZlcnkgd2lkZSBkaXZzLiBUaGlzIG1lYW5zIHRob3VnaFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCB0aGUgYXBwbGllZCBsZWZ0IGFuZCB3aWR0aCBtYXlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCBjb3JyZXNwb25kIHRvIHRoZSByYW5nZXMgc3RhcnQgYW5kIGVuZFxuICAgKiBAT3ZlcnJpZGVcbiAgICovXG4gIFJhbmdlSXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblggPSBmdW5jdGlvbiAobGltaXRTaXplKSB7XG4gICAgdmFyIHBhcmVudFdpZHRoID0gdGhpcy5wYXJlbnQud2lkdGg7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5jb252ZXJzaW9uLnRvU2NyZWVuKHRoaXMuZGF0YS5zdGFydCk7XG4gICAgdmFyIGVuZCA9IHRoaXMuY29udmVyc2lvbi50b1NjcmVlbih0aGlzLmRhdGEuZW5kKTtcbiAgICB2YXIgY29udGVudFN0YXJ0UG9zaXRpb247XG4gICAgdmFyIGNvbnRlbnRXaWR0aDtcblxuICAgIC8vIGxpbWl0IHRoZSB3aWR0aCBvZiB0aGUgcmFuZ2UsIGFzIGJyb3dzZXJzIGNhbm5vdCBkcmF3IHZlcnkgd2lkZSBkaXZzXG4gICAgaWYgKGxpbWl0U2l6ZSA9PT0gdW5kZWZpbmVkIHx8IGxpbWl0U2l6ZSA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKHN0YXJ0IDwgLXBhcmVudFdpZHRoKSB7XG4gICAgICAgIHN0YXJ0ID0gLXBhcmVudFdpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCA+IDIgKiBwYXJlbnRXaWR0aCkge1xuICAgICAgICBlbmQgPSAyICogcGFyZW50V2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkIDAuNSB0byBjb21wZW5zYXRlIGZsb2F0aW5nLXBvaW50IHZhbHVlcyByb3VuZGluZ1xuICAgIHZhciBib3hXaWR0aCA9IE1hdGgubWF4KGVuZCAtIHN0YXJ0ICsgMC41LCAxKTtcblxuICAgIGlmICh0aGlzLm92ZXJmbG93KSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICB0aGlzLnJpZ2h0ID0gc3RhcnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxlZnQgPSBzdGFydDtcbiAgICAgIH1cbiAgICAgIHRoaXMud2lkdGggPSBib3hXaWR0aCArIHRoaXMucHJvcHMuY29udGVudC53aWR0aDtcbiAgICAgIGNvbnRlbnRXaWR0aCA9IHRoaXMucHJvcHMuY29udGVudC53aWR0aDtcblxuICAgICAgLy8gTm90ZTogVGhlIGNhbGN1bGF0aW9uIG9mIHdpZHRoIGlzIGFuIG9wdGltaXN0aWMgY2FsY3VsYXRpb24sIGdpdmluZ1xuICAgICAgLy8gICAgICAgYSB3aWR0aCB3aGljaCB3aWxsIG5vdCBjaGFuZ2Ugd2hlbiBtb3ZpbmcgdGhlIFRpbWVsaW5lXG4gICAgICAvLyAgICAgICBTbyBubyByZS1zdGFja2luZyBuZWVkZWQsIHdoaWNoIGlzIG5pY2VyIGZvciB0aGUgZXllO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICB0aGlzLnJpZ2h0ID0gc3RhcnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxlZnQgPSBzdGFydDtcbiAgICAgIH1cbiAgICAgIHRoaXMud2lkdGggPSBib3hXaWR0aDtcbiAgICAgIGNvbnRlbnRXaWR0aCA9IE1hdGgubWluKGVuZCAtIHN0YXJ0LCB0aGlzLnByb3BzLmNvbnRlbnQud2lkdGgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICB0aGlzLmRvbS5ib3guc3R5bGUucmlnaHQgPSB0aGlzLnJpZ2h0ICsgJ3B4JztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb20uYm94LnN0eWxlLmxlZnQgPSB0aGlzLmxlZnQgKyAncHgnO1xuICAgIH1cbiAgICB0aGlzLmRvbS5ib3guc3R5bGUud2lkdGggPSBib3hXaWR0aCArICdweCc7XG5cbiAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5hbGlnbikge1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgICAgdGhpcy5kb20uY29udGVudC5zdHlsZS5yaWdodCA9ICcwJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRvbS5jb250ZW50LnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgICB0aGlzLmRvbS5jb250ZW50LnN0eWxlLnJpZ2h0ID0gTWF0aC5tYXgoYm94V2lkdGggLSBjb250ZW50V2lkdGgsIDApICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRvbS5jb250ZW50LnN0eWxlLmxlZnQgPSBNYXRoLm1heChib3hXaWR0aCAtIGNvbnRlbnRXaWR0aCwgMCkgKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICAgIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUucmlnaHQgPSBNYXRoLm1heCgoYm94V2lkdGggLSBjb250ZW50V2lkdGgpIC8gMiwgMCkgKyAncHgnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUubGVmdCA9IE1hdGgubWF4KChib3hXaWR0aCAtIGNvbnRlbnRXaWR0aCkgLyAyLCAwKSArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gJ2F1dG8nXG4gICAgICAgIC8vIHdoZW4gcmFuZ2UgZXhjZWVkcyBsZWZ0IG9mIHRoZSB3aW5kb3csIHBvc2l0aW9uIHRoZSBjb250ZW50cyBhdCB0aGUgbGVmdCBvZiB0aGUgdmlzaWJsZSBhcmVhXG4gICAgICAgIGlmICh0aGlzLm92ZXJmbG93KSB7XG4gICAgICAgICAgaWYgKGVuZCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRlbnRTdGFydFBvc2l0aW9uID0gTWF0aC5tYXgoLXN0YXJ0LCAwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudFN0YXJ0UG9zaXRpb24gPSAtY29udGVudFdpZHRoOyAvLyBlbnN1cmUgaXQncyBub3QgdmlzaWJsZSBhbnltb3JlXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIGNvbnRlbnRTdGFydFBvc2l0aW9uID0gLXN0YXJ0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50U3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgICAgdGhpcy5kb20uY29udGVudC5zdHlsZS5yaWdodCA9IGNvbnRlbnRTdGFydFBvc2l0aW9uICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRvbS5jb250ZW50LnN0eWxlLmxlZnQgPSBjb250ZW50U3RhcnRQb3NpdGlvbiArICdweCc7XG4gICAgICAgICAgdGhpcy5kb20uY29udGVudC5zdHlsZS53aWR0aCA9ICdjYWxjKDEwMCUgLSAnICsgY29udGVudFN0YXJ0UG9zaXRpb24gKyAncHgpJztcbiAgICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVwb3NpdGlvbiB0aGUgaXRlbSB2ZXJ0aWNhbGx5XG4gICAqIEBPdmVycmlkZVxuICAgKi9cbiAgUmFuZ2VJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3JpZW50YXRpb24gPSB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbTtcbiAgICB2YXIgYm94ID0gdGhpcy5kb20uYm94O1xuXG4gICAgaWYgKG9yaWVudGF0aW9uID09ICd0b3AnKSB7XG4gICAgICBib3guc3R5bGUudG9wID0gdGhpcy50b3AgKyAncHgnO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3guc3R5bGUudG9wID0gdGhpcy5wYXJlbnQuaGVpZ2h0IC0gdGhpcy50b3AgLSB0aGlzLmhlaWdodCArICdweCc7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBhaW50IGEgZHJhZyBhcmVhIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHJhbmdlIHdoZW4gdGhlIHJhbmdlIGlzIHNlbGVjdGVkXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIFJhbmdlSXRlbS5wcm90b3R5cGUuX3JlcGFpbnREcmFnTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5zZWxlY3RlZCAmJiB0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlVGltZSAmJiAhdGhpcy5kb20uZHJhZ0xlZnQpIHtcbiAgICAgIC8vIGNyZWF0ZSBhbmQgc2hvdyBkcmFnIGFyZWFcbiAgICAgIHZhciBkcmFnTGVmdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZHJhZ0xlZnQuY2xhc3NOYW1lID0gJ3Zpcy1kcmFnLWxlZnQnO1xuICAgICAgZHJhZ0xlZnQuZHJhZ0xlZnRJdGVtID0gdGhpcztcblxuICAgICAgdGhpcy5kb20uYm94LmFwcGVuZENoaWxkKGRyYWdMZWZ0KTtcbiAgICAgIHRoaXMuZG9tLmRyYWdMZWZ0ID0gZHJhZ0xlZnQ7XG4gICAgfSBlbHNlIGlmICghdGhpcy5zZWxlY3RlZCAmJiB0aGlzLmRvbS5kcmFnTGVmdCkge1xuICAgICAgLy8gZGVsZXRlIGRyYWcgYXJlYVxuICAgICAgaWYgKHRoaXMuZG9tLmRyYWdMZWZ0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5kb20uZHJhZ0xlZnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5kcmFnTGVmdCk7XG4gICAgICB9XG4gICAgICB0aGlzLmRvbS5kcmFnTGVmdCA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBhaW50IGEgZHJhZyBhcmVhIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSByYW5nZSB3aGVuIHRoZSByYW5nZSBpcyBzZWxlY3RlZFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBSYW5nZUl0ZW0ucHJvdG90eXBlLl9yZXBhaW50RHJhZ1JpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGVkICYmIHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVUaW1lICYmICF0aGlzLmRvbS5kcmFnUmlnaHQpIHtcbiAgICAgIC8vIGNyZWF0ZSBhbmQgc2hvdyBkcmFnIGFyZWFcbiAgICAgIHZhciBkcmFnUmlnaHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRyYWdSaWdodC5jbGFzc05hbWUgPSAndmlzLWRyYWctcmlnaHQnO1xuICAgICAgZHJhZ1JpZ2h0LmRyYWdSaWdodEl0ZW0gPSB0aGlzO1xuXG4gICAgICB0aGlzLmRvbS5ib3guYXBwZW5kQ2hpbGQoZHJhZ1JpZ2h0KTtcbiAgICAgIHRoaXMuZG9tLmRyYWdSaWdodCA9IGRyYWdSaWdodDtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnNlbGVjdGVkICYmIHRoaXMuZG9tLmRyYWdSaWdodCkge1xuICAgICAgLy8gZGVsZXRlIGRyYWcgYXJlYVxuICAgICAgaWYgKHRoaXMuZG9tLmRyYWdSaWdodC5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMuZG9tLmRyYWdSaWdodC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmRyYWdSaWdodCk7XG4gICAgICB9XG4gICAgICB0aGlzLmRvbS5kcmFnUmlnaHQgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFJhbmdlSXRlbTtcblxuLyoqKi8gfSxcbi8qIDQxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIEhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3IgSXRlbVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyAob3B0aW9uYWwpIHBhcmFtZXRlcnMgdHlwZSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQsIGVuZCwgY29udGVudCwgZ3JvdXAsIGNsYXNzTmFtZS5cbiAgICogQHBhcmFtIHt7dG9TY3JlZW46IGZ1bmN0aW9uLCB0b1RpbWU6IGZ1bmN0aW9ufX0gY29udmVyc2lvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb252ZXJzaW9uIGZ1bmN0aW9ucyBmcm9tIHRpbWUgdG8gc2NyZWVuIGFuZCB2aWNlIHZlcnNhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBkZXNjcmliZSBhdmFpbGFibGUgb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gSXRlbShkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKSB7XG4gICAgdGhpcy5pZCA9IG51bGw7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5kb20gPSBudWxsO1xuICAgIHRoaXMuY29udmVyc2lvbiA9IGNvbnZlcnNpb24gfHwge307XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5kaXNwbGF5ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHRoaXMudG9wID0gbnVsbDtcbiAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcbiAgICB0aGlzLmxlZnQgPSBudWxsO1xuICAgIHRoaXMud2lkdGggPSBudWxsO1xuICAgIHRoaXMuaGVpZ2h0ID0gbnVsbDtcblxuICAgIHRoaXMuZWRpdGFibGUgPSBudWxsO1xuICAgIGlmICh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmhhc093blByb3BlcnR5KCdlZGl0YWJsZScpICYmIHR5cGVvZiB0aGlzLmRhdGEuZWRpdGFibGUgPT09ICdib29sZWFuJykge1xuICAgICAgdGhpcy5lZGl0YWJsZSA9IGRhdGEuZWRpdGFibGU7XG4gICAgfVxuICB9XG5cbiAgSXRlbS5wcm90b3R5cGUuc3RhY2sgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBTZWxlY3QgY3VycmVudCBpdGVtXG4gICAqL1xuICBJdGVtLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgaWYgKHRoaXMuZGlzcGxheWVkKSB0aGlzLnJlZHJhdygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbnNlbGVjdCBjdXJyZW50IGl0ZW1cbiAgICovXG4gIEl0ZW0ucHJvdG90eXBlLnVuc2VsZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5kaXNwbGF5ZWQpIHRoaXMucmVkcmF3KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBkYXRhIGZvciB0aGUgaXRlbS4gRXhpc3RpbmcgZGF0YSB3aWxsIGJlIHVwZGF0ZWQuIFRoZSBpZCBzaG91bGQgbm90XG4gICAqIGJlIGNoYW5nZWQuIFdoZW4gdGhlIGl0ZW0gaXMgZGlzcGxheWVkLCBpdCB3aWxsIGJlIHJlZHJhd24gaW1tZWRpYXRlbHkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqL1xuICBJdGVtLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgZ3JvdXBDaGFuZ2VkID0gZGF0YS5ncm91cCAhPSB1bmRlZmluZWQgJiYgdGhpcy5kYXRhLmdyb3VwICE9IGRhdGEuZ3JvdXA7XG4gICAgaWYgKGdyb3VwQ2hhbmdlZCkge1xuICAgICAgdGhpcy5wYXJlbnQuaXRlbVNldC5fbW92ZVRvR3JvdXAodGhpcywgZGF0YS5ncm91cCk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoJ2VkaXRhYmxlJykgJiYgdHlwZW9mIGRhdGEuZWRpdGFibGUgPT09ICdib29sZWFuJykge1xuICAgICAgdGhpcy5lZGl0YWJsZSA9IGRhdGEuZWRpdGFibGU7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5kaXNwbGF5ZWQpIHRoaXMucmVkcmF3KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIHBhcmVudCBmb3IgdGhlIGl0ZW1cbiAgICogQHBhcmFtIHtJdGVtU2V0IHwgR3JvdXB9IHBhcmVudFxuICAgKi9cbiAgSXRlbS5wcm90b3R5cGUuc2V0UGFyZW50ID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgIGlmICh0aGlzLmRpc3BsYXllZCkge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoaXMgaXRlbSBpcyB2aXNpYmxlIGluc2lkZSBnaXZlbiByYW5nZVxuICAgKiBAcmV0dXJucyB7e3N0YXJ0OiBOdW1iZXIsIGVuZDogTnVtYmVyfX0gcmFuZ2Ugd2l0aCBhIHRpbWVzdGFtcCBmb3Igc3RhcnQgYW5kIGVuZFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2aXNpYmxlXG4gICAqL1xuICBJdGVtLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIEl0ZW0gaW4gdGhlIERPTSAod2hlbiBub3QgYWxyZWFkeSB2aXNpYmxlKVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBjaGFuZ2VkXG4gICAqL1xuICBJdGVtLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogSGlkZSB0aGUgSXRlbSBmcm9tIHRoZSBET00gKHdoZW4gdmlzaWJsZSlcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gY2hhbmdlZFxuICAgKi9cbiAgSXRlbS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGFpbnQgdGhlIGl0ZW1cbiAgICovXG4gIEl0ZW0ucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYnkgdGhlIGl0ZW1cbiAgfTtcblxuICAvKipcbiAgICogUmVwb3NpdGlvbiB0aGUgSXRlbSBob3Jpem9udGFsbHlcbiAgICovXG4gIEl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25YID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgaXRlbVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBvc2l0aW9uIHRoZSBJdGVtIHZlcnRpY2FsbHlcbiAgICovXG4gIEl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25ZID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgaXRlbVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBhaW50IGEgZGVsZXRlIGJ1dHRvbiBvbiB0aGUgdG9wIHJpZ2h0IG9mIHRoZSBpdGVtIHdoZW4gdGhlIGl0ZW0gaXMgc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYW5jaG9yXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIEl0ZW0ucHJvdG90eXBlLl9yZXBhaW50RGVsZXRlQnV0dG9uID0gZnVuY3Rpb24gKGFuY2hvcikge1xuICAgIHZhciBlZGl0YWJsZSA9ICh0aGlzLm9wdGlvbnMuZWRpdGFibGUucmVtb3ZlIHx8IHRoaXMuZGF0YS5lZGl0YWJsZSA9PT0gdHJ1ZSkgJiYgdGhpcy5kYXRhLmVkaXRhYmxlICE9PSBmYWxzZTtcblxuICAgIGlmICh0aGlzLnNlbGVjdGVkICYmIGVkaXRhYmxlICYmICF0aGlzLmRvbS5kZWxldGVCdXR0b24pIHtcbiAgICAgIC8vIGNyZWF0ZSBhbmQgc2hvdyBidXR0b25cbiAgICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICAgIHZhciBkZWxldGVCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgZGVsZXRlQnV0dG9uLmNsYXNzTmFtZSA9ICd2aXMtZGVsZXRlLXJ0bCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVCdXR0b24uY2xhc3NOYW1lID0gJ3Zpcy1kZWxldGUnO1xuICAgICAgfVxuICAgICAgZGVsZXRlQnV0dG9uLnRpdGxlID0gJ0RlbGV0ZSB0aGlzIGl0ZW0nO1xuXG4gICAgICAvLyBUT0RPOiBiZSBhYmxlIHRvIGRlc3Ryb3kgdGhlIGRlbGV0ZSBidXR0b25cbiAgICAgIG5ldyBIYW1tZXIoZGVsZXRlQnV0dG9uKS5vbigndGFwJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBtZS5wYXJlbnQucmVtb3ZlRnJvbURhdGFTZXQobWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGFuY2hvci5hcHBlbmRDaGlsZChkZWxldGVCdXR0b24pO1xuICAgICAgdGhpcy5kb20uZGVsZXRlQnV0dG9uID0gZGVsZXRlQnV0dG9uO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuc2VsZWN0ZWQgJiYgdGhpcy5kb20uZGVsZXRlQnV0dG9uKSB7XG4gICAgICAvLyByZW1vdmUgYnV0dG9uXG4gICAgICBpZiAodGhpcy5kb20uZGVsZXRlQnV0dG9uLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5kb20uZGVsZXRlQnV0dG9uLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20uZGVsZXRlQnV0dG9uKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZG9tLmRlbGV0ZUJ1dHRvbiA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBhaW50IGEgb25DaGFuZ2UgdG9vbHRpcCBvbiB0aGUgdG9wIHJpZ2h0IG9mIHRoZSBpdGVtIHdoZW4gdGhlIGl0ZW0gaXMgc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYW5jaG9yXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIEl0ZW0ucHJvdG90eXBlLl9yZXBhaW50T25JdGVtVXBkYXRlVGltZVRvb2x0aXAgPSBmdW5jdGlvbiAoYW5jaG9yKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMudG9vbHRpcE9uSXRlbVVwZGF0ZVRpbWUpIHJldHVybjtcblxuICAgIHZhciBlZGl0YWJsZSA9ICh0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlVGltZSB8fCB0aGlzLmRhdGEuZWRpdGFibGUgPT09IHRydWUpICYmIHRoaXMuZGF0YS5lZGl0YWJsZSAhPT0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5zZWxlY3RlZCAmJiBlZGl0YWJsZSAmJiAhdGhpcy5kb20ub25JdGVtVXBkYXRlVGltZVRvb2x0aXApIHtcbiAgICAgIC8vIGNyZWF0ZSBhbmQgc2hvdyB0b29sdGlwXG4gICAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgICB2YXIgb25JdGVtVXBkYXRlVGltZVRvb2x0aXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgb25JdGVtVXBkYXRlVGltZVRvb2x0aXAuY2xhc3NOYW1lID0gJ3Zpcy1vblVwZGF0ZVRpbWUtdG9vbHRpcCc7XG4gICAgICBhbmNob3IuYXBwZW5kQ2hpbGQob25JdGVtVXBkYXRlVGltZVRvb2x0aXApO1xuICAgICAgdGhpcy5kb20ub25JdGVtVXBkYXRlVGltZVRvb2x0aXAgPSBvbkl0ZW1VcGRhdGVUaW1lVG9vbHRpcDtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnNlbGVjdGVkICYmIHRoaXMuZG9tLm9uSXRlbVVwZGF0ZVRpbWVUb29sdGlwKSB7XG4gICAgICAvLyByZW1vdmUgYnV0dG9uXG4gICAgICBpZiAodGhpcy5kb20ub25JdGVtVXBkYXRlVGltZVRvb2x0aXAucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmRvbS5vbkl0ZW1VcGRhdGVUaW1lVG9vbHRpcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLm9uSXRlbVVwZGF0ZVRpbWVUb29sdGlwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZG9tLm9uSXRlbVVwZGF0ZVRpbWVUb29sdGlwID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBwb3NpdGlvbiBvbkNoYW5nZSB0b29sdGlwXG4gICAgaWYgKHRoaXMuZG9tLm9uSXRlbVVwZGF0ZVRpbWVUb29sdGlwKSB7XG5cbiAgICAgIC8vIG9ubHkgc2hvdyB3aGVuIGVkaXRpbmdcbiAgICAgIHRoaXMuZG9tLm9uSXRlbVVwZGF0ZVRpbWVUb29sdGlwLnN0eWxlLnZpc2liaWxpdHkgPSB0aGlzLnBhcmVudC5pdGVtU2V0LnRvdWNoUGFyYW1zLml0ZW1Jc0RyYWdnaW5nID8gJ3Zpc2libGUnIDogJ2hpZGRlbic7XG5cbiAgICAgIC8vIHBvc2l0aW9uIHJlbGF0aXZlIHRvIGl0ZW0ncyBjb250ZW50XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICB0aGlzLmRvbS5vbkl0ZW1VcGRhdGVUaW1lVG9vbHRpcC5zdHlsZS5yaWdodCA9IHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUucmlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRvbS5vbkl0ZW1VcGRhdGVUaW1lVG9vbHRpcC5zdHlsZS5sZWZ0ID0gdGhpcy5kb20uY29udGVudC5zdHlsZS5sZWZ0O1xuICAgICAgfVxuXG4gICAgICAvLyBwb3NpdGlvbiBhYm92ZSBvciBiZWxvdyB0aGUgaXRlbSBkZXBlbmRpbmcgb24gdGhlIGl0ZW0ncyBwb3NpdGlvbiBpbiB0aGUgd2luZG93XG4gICAgICB2YXIgdG9vbHRpcE9mZnNldCA9IDUwOyAvLyBUT0RPOiBzaG91bGQgYmUgdG9vbHRpcCBoZWlnaHQgKGRlcGVuZHMgb24gdGVtcGxhdGUpXG4gICAgICB2YXIgc2Nyb2xsVG9wID0gdGhpcy5wYXJlbnQuaXRlbVNldC5ib2R5LmRvbVByb3BzLnNjcm9sbFRvcDtcblxuICAgICAgLy8gVE9ETzogdGhpcy50b3AgZm9yIG9yaWVudGF0aW9uOnRydWUgaXMgYWN0dWFsbHkgdGhlIGl0ZW1zIGRpc3RhbmNlIGZyb20gdGhlIGJvdHRvbS4uLiBcbiAgICAgIC8vIChzaG91bGQgYmUgdGhpcy5ib3R0b20pXG4gICAgICB2YXIgaXRlbURpc3RhbmNlRnJvbVRvcDtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbSA9PSAndG9wJykge1xuICAgICAgICBpdGVtRGlzdGFuY2VGcm9tVG9wID0gdGhpcy50b3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtRGlzdGFuY2VGcm9tVG9wID0gdGhpcy5wYXJlbnQuaGVpZ2h0IC0gdGhpcy50b3AgLSB0aGlzLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIHZhciBpc0Nsb3NlVG9Ub3AgPSBpdGVtRGlzdGFuY2VGcm9tVG9wICsgdGhpcy5wYXJlbnQudG9wIC0gdG9vbHRpcE9mZnNldCA8IC1zY3JvbGxUb3A7XG5cbiAgICAgIGlmIChpc0Nsb3NlVG9Ub3ApIHtcbiAgICAgICAgdGhpcy5kb20ub25JdGVtVXBkYXRlVGltZVRvb2x0aXAuc3R5bGUuYm90dG9tID0gXCJcIjtcbiAgICAgICAgdGhpcy5kb20ub25JdGVtVXBkYXRlVGltZVRvb2x0aXAuc3R5bGUudG9wID0gdGhpcy5oZWlnaHQgKyAyICsgXCJweFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kb20ub25JdGVtVXBkYXRlVGltZVRvb2x0aXAuc3R5bGUudG9wID0gXCJcIjtcbiAgICAgICAgdGhpcy5kb20ub25JdGVtVXBkYXRlVGltZVRvb2x0aXAuc3R5bGUuYm90dG9tID0gdGhpcy5oZWlnaHQgKyAyICsgXCJweFwiO1xuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgdG9vbHRpcCBjb250ZW50XG4gICAgICB2YXIgY29udGVudDtcbiAgICAgIHZhciB0ZW1wbGF0ZUZ1bmN0aW9uO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRvb2x0aXBPbkl0ZW1VcGRhdGVUaW1lICYmIHRoaXMub3B0aW9ucy50b29sdGlwT25JdGVtVXBkYXRlVGltZS50ZW1wbGF0ZSkge1xuICAgICAgICB0ZW1wbGF0ZUZ1bmN0aW9uID0gdGhpcy5vcHRpb25zLnRvb2x0aXBPbkl0ZW1VcGRhdGVUaW1lLnRlbXBsYXRlLmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnRlbnQgPSB0ZW1wbGF0ZUZ1bmN0aW9uKHRoaXMuZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50ID0gJ3N0YXJ0OiAnICsgbW9tZW50KHRoaXMuZGF0YS5zdGFydCkuZm9ybWF0KCdNTS9ERC9ZWVlZIGhoOm1tJyk7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuZW5kKSB7XG4gICAgICAgICAgY29udGVudCArPSAnPGJyPiBlbmQ6ICcgKyBtb21lbnQodGhpcy5kYXRhLmVuZCkuZm9ybWF0KCdNTS9ERC9ZWVlZIGhoOm1tJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZG9tLm9uSXRlbVVwZGF0ZVRpbWVUb29sdGlwLmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgSFRNTCBjb250ZW50cyBmb3IgdGhlIGl0ZW1cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50ICAgSFRNTCBlbGVtZW50IHRvIGZpbGwgd2l0aCB0aGUgY29udGVudHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW0ucHJvdG90eXBlLl91cGRhdGVDb250ZW50cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdmFyIGNvbnRlbnQ7XG4gICAgdmFyIHRlbXBsYXRlRnVuY3Rpb247XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnRlbXBsYXRlKSB7XG4gICAgICB2YXIgaXRlbURhdGEgPSB0aGlzLnBhcmVudC5pdGVtU2V0Lml0ZW1zRGF0YS5nZXQodGhpcy5pZCk7IC8vIGdldCBhIGNsb25lIG9mIHRoZSBkYXRhIGZyb20gdGhlIGRhdGFzZXRcbiAgICAgIHRlbXBsYXRlRnVuY3Rpb24gPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUuYmluZCh0aGlzKTtcbiAgICAgIGNvbnRlbnQgPSB0ZW1wbGF0ZUZ1bmN0aW9uKGl0ZW1EYXRhLCBlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IHRoaXMuZGF0YS5jb250ZW50O1xuICAgIH1cblxuICAgIGlmIChjb250ZW50IGluc3RhbmNlb2YgT2JqZWN0ICYmICEoY29udGVudCBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICB0ZW1wbGF0ZUZ1bmN0aW9uKGl0ZW1EYXRhLCBlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNoYW5nZWQgPSB0aGlzLl9jb250ZW50VG9TdHJpbmcodGhpcy5jb250ZW50KSAhPT0gdGhpcy5fY29udGVudFRvU3RyaW5nKGNvbnRlbnQpO1xuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgLy8gb25seSByZXBsYWNlIHRoZSBjb250ZW50IHdoZW4gY2hhbmdlZFxuICAgICAgICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGVudCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCEodGhpcy5kYXRhLnR5cGUgPT0gJ2JhY2tncm91bmQnICYmIHRoaXMuZGF0YS5jb250ZW50ID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IFwiY29udGVudFwiIG1pc3NpbmcgaW4gaXRlbSAnICsgdGhpcy5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBIVE1MIGNvbnRlbnRzIGZvciB0aGUgaXRlbVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgICBIVE1MIGVsZW1lbnQgdG8gZmlsbCB3aXRoIHRoZSBjb250ZW50c1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbS5wcm90b3R5cGUuX3VwZGF0ZVRpdGxlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5kYXRhLnRpdGxlICE9IG51bGwpIHtcbiAgICAgIGVsZW1lbnQudGl0bGUgPSB0aGlzLmRhdGEudGl0bGUgfHwgJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd2aXMtdGl0bGUnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgZGF0YUF0dHJpYnV0ZXMgdGltZWxpbmUgb3B0aW9uIGFuZCBzZXQgYXMgZGF0YS0gYXR0cmlidXRlcyBvbiBkb20uY29udGVudFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgICBIVE1MIGVsZW1lbnQgdG8gd2hpY2ggdGhlIGF0dHJpYnV0ZXMgd2lsbCBiZSBhdHRhY2hlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbS5wcm90b3R5cGUuX3VwZGF0ZURhdGFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmRhdGFBdHRyaWJ1dGVzICYmIHRoaXMub3B0aW9ucy5kYXRhQXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IFtdO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMuZGF0YUF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSB0aGlzLm9wdGlvbnMuZGF0YUF0dHJpYnV0ZXM7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5kYXRhQXR0cmlidXRlcyA9PSAnYWxsJykge1xuICAgICAgICBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXModGhpcy5kYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lID0gYXR0cmlidXRlc1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5kYXRhW25hbWVdO1xuXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS0nICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBjdXN0b20gc3R5bGVzIG9mIHRoZSBlbGVtZW50XG4gICAqIEBwYXJhbSBlbGVtZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtLnByb3RvdHlwZS5fdXBkYXRlU3R5bGUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIC8vIHJlbW92ZSBvbGQgc3R5bGVzXG4gICAgaWYgKHRoaXMuc3R5bGUpIHtcbiAgICAgIHV0aWwucmVtb3ZlQ3NzVGV4dChlbGVtZW50LCB0aGlzLnN0eWxlKTtcbiAgICAgIHRoaXMuc3R5bGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIGFwcGVuZCBuZXcgc3R5bGVzXG4gICAgaWYgKHRoaXMuZGF0YS5zdHlsZSkge1xuICAgICAgdXRpbC5hZGRDc3NUZXh0KGVsZW1lbnQsIHRoaXMuZGF0YS5zdHlsZSk7XG4gICAgICB0aGlzLnN0eWxlID0gdGhpcy5kYXRhLnN0eWxlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3RyaW5naWZ5IHRoZSBpdGVtcyBjb250ZW50c1xuICAgKiBAcGFyYW0ge3N0cmluZyB8IEVsZW1lbnQgfCB1bmRlZmluZWR9IGNvbnRlbnRcbiAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW0ucHJvdG90eXBlLl9jb250ZW50VG9TdHJpbmcgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHJldHVybiBjb250ZW50O1xuICAgIGlmIChjb250ZW50ICYmICdvdXRlckhUTUwnIGluIGNvbnRlbnQpIHJldHVybiBjb250ZW50Lm91dGVySFRNTDtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgaXRlbSBsZWZ0IGZyb20gaXRzIHN0YXJ0IGRhdGVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgSXRlbS5wcm90b3R5cGUuZ2V0V2lkdGhMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSBpdGVtIHJpZ2h0IGZyb20gdGhlIG1heCBvZiBpdHMgc3RhcnQgYW5kIGVuZCBkYXRlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIEl0ZW0ucHJvdG90eXBlLmdldFdpZHRoUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGFpbnQgYSBkcmFnIGFyZWEgb24gdGhlIGNlbnRlciBvZiB0aGUgaXRlbSB3aGVuIHRoZSBpdGVtIGlzIHNlbGVjdGVkXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIEl0ZW0ucHJvdG90eXBlLl9yZXBhaW50RHJhZ0NlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5zZWxlY3RlZCAmJiB0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlVGltZSAmJiAhdGhpcy5kb20uZHJhZ0NlbnRlcikge1xuICAgICAgLy8gY3JlYXRlIGFuZCBzaG93IGRyYWcgYXJlYVxuICAgICAgdmFyIGRyYWdDZW50ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRyYWdDZW50ZXIuY2xhc3NOYW1lID0gJ3Zpcy1kcmFnLWNlbnRlcic7XG4gICAgICBkcmFnQ2VudGVyLmRyYWdDZW50ZXJJdGVtID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuZG9tLmJveCkge1xuICAgICAgICB0aGlzLmRvbS5ib3guYXBwZW5kQ2hpbGQoZHJhZ0NlbnRlcik7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZG9tLnBvaW50KSB7XG4gICAgICAgIHRoaXMuZG9tLnBvaW50LmFwcGVuZENoaWxkKGRyYWdDZW50ZXIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRvbS5kcmFnQ2VudGVyID0gZHJhZ0NlbnRlcjtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnNlbGVjdGVkICYmIHRoaXMuZG9tLmRyYWdDZW50ZXIpIHtcbiAgICAgIC8vIGRlbGV0ZSBkcmFnIGFyZWFcbiAgICAgIGlmICh0aGlzLmRvbS5kcmFnQ2VudGVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5kb20uZHJhZ0NlbnRlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmRyYWdDZW50ZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5kb20uZHJhZ0NlbnRlciA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gSXRlbTtcblxuLyoqKi8gfSxcbi8qIDQyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuICB2YXIgR3JvdXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yIEJhY2tncm91bmRHcm91cFxuICAgKiBAcGFyYW0ge051bWJlciB8IFN0cmluZ30gZ3JvdXBJZFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge0l0ZW1TZXR9IGl0ZW1TZXRcbiAgICovXG4gIGZ1bmN0aW9uIEJhY2tncm91bmRHcm91cChncm91cElkLCBkYXRhLCBpdGVtU2V0KSB7XG4gICAgR3JvdXAuY2FsbCh0aGlzLCBncm91cElkLCBkYXRhLCBpdGVtU2V0KTtcblxuICAgIHRoaXMud2lkdGggPSAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLnRvcCA9IDA7XG4gICAgdGhpcy5sZWZ0ID0gMDtcbiAgfVxuXG4gIEJhY2tncm91bmRHcm91cC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdyb3VwLnByb3RvdHlwZSk7XG5cbiAgLyoqXG4gICAqIFJlcGFpbnQgdGhpcyBncm91cFxuICAgKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHJhbmdlXG4gICAqIEBwYXJhbSB7e2l0ZW06IHtob3Jpem9udGFsOiBudW1iZXIsIHZlcnRpY2FsOiBudW1iZXJ9LCBheGlzOiBudW1iZXJ9fSBtYXJnaW5cbiAgICogQHBhcmFtIHtib29sZWFufSBbcmVzdGFjaz1mYWxzZV0gIEZvcmNlIHJlc3RhY2tpbmcgb2YgYWxsIGl0ZW1zXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZ3JvdXAgaXMgcmVzaXplZFxuICAgKi9cbiAgQmFja2dyb3VuZEdyb3VwLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAocmFuZ2UsIG1hcmdpbiwgcmVzdGFjaykge1xuICAgIHZhciByZXNpemVkID0gZmFsc2U7XG5cbiAgICB0aGlzLnZpc2libGVJdGVtcyA9IHRoaXMuX3VwZGF0ZVZpc2libGVJdGVtcyh0aGlzLm9yZGVyZWRJdGVtcywgdGhpcy52aXNpYmxlSXRlbXMsIHJhbmdlKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBhY3R1YWwgc2l6ZVxuICAgIHRoaXMud2lkdGggPSB0aGlzLmRvbS5iYWNrZ3JvdW5kLm9mZnNldFdpZHRoO1xuXG4gICAgLy8gYXBwbHkgbmV3IGhlaWdodCAoanVzdCBhbHdheXMgemVybyBmb3IgQmFja2dyb3VuZEdyb3VwXG4gICAgdGhpcy5kb20uYmFja2dyb3VuZC5zdHlsZS5oZWlnaHQgPSAnMCc7XG5cbiAgICAvLyB1cGRhdGUgdmVydGljYWwgcG9zaXRpb24gb2YgaXRlbXMgYWZ0ZXIgdGhleSBhcmUgcmUtc3RhY2tlZCBhbmQgdGhlIGhlaWdodCBvZiB0aGUgZ3JvdXAgaXMgY2FsY3VsYXRlZFxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMudmlzaWJsZUl0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gdGhpcy52aXNpYmxlSXRlbXNbaV07XG4gICAgICBpdGVtLnJlcG9zaXRpb25ZKG1hcmdpbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc2l6ZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3cgdGhpcyBncm91cDogYXR0YWNoIHRvIHRoZSBET01cbiAgICovXG4gIEJhY2tncm91bmRHcm91cC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuZG9tLmJhY2tncm91bmQucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5pdGVtU2V0LmRvbS5iYWNrZ3JvdW5kLmFwcGVuZENoaWxkKHRoaXMuZG9tLmJhY2tncm91bmQpO1xuICAgIH1cbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IEJhY2tncm91bmRHcm91cDtcblxuLyoqKi8gfSxcbi8qIDQzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIEl0ZW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3IgQm94SXRlbVxuICAgKiBAZXh0ZW5kcyBJdGVtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnMgc3RhcnRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCwgY2xhc3NOYW1lLlxuICAgKiBAcGFyYW0ge3t0b1NjcmVlbjogZnVuY3Rpb24sIHRvVGltZTogZnVuY3Rpb259fSBjb252ZXJzaW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnZlcnNpb24gZnVuY3Rpb25zIGZyb20gdGltZSB0byBzY3JlZW4gYW5kIHZpY2UgdmVyc2FcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGRlc2NyaWJlIGF2YWlsYWJsZSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBCb3hJdGVtKGRhdGEsIGNvbnZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICB0aGlzLnByb3BzID0ge1xuICAgICAgZG90OiB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH0sXG4gICAgICBsaW5lOiB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgLy8gdmFsaWRhdGUgZGF0YVxuICAgIGlmIChkYXRhKSB7XG4gICAgICBpZiAoZGF0YS5zdGFydCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBcInN0YXJ0XCIgbWlzc2luZyBpbiBpdGVtICcgKyBkYXRhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBJdGVtLmNhbGwodGhpcywgZGF0YSwgY29udmVyc2lvbiwgb3B0aW9ucyk7XG4gIH1cblxuICBCb3hJdGVtLnByb3RvdHlwZSA9IG5ldyBJdGVtKG51bGwsIG51bGwsIG51bGwpO1xuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoaXMgaXRlbSBpcyB2aXNpYmxlIGluc2lkZSBnaXZlbiByYW5nZVxuICAgKiBAcmV0dXJucyB7e3N0YXJ0OiBOdW1iZXIsIGVuZDogTnVtYmVyfX0gcmFuZ2Ugd2l0aCBhIHRpbWVzdGFtcCBmb3Igc3RhcnQgYW5kIGVuZFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2aXNpYmxlXG4gICAqL1xuICBCb3hJdGVtLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAvLyBkZXRlcm1pbmUgdmlzaWJpbGl0eVxuICAgIHZhciBpc1Zpc2libGU7XG4gICAgdmFyIGFsaWduID0gdGhpcy5vcHRpb25zLmFsaWduO1xuICAgIHZhciBtc1BlclBpeGVsID0gKHJhbmdlLmVuZCAtIHJhbmdlLnN0YXJ0KSAvIHJhbmdlLmJvZHkuZG9tLmNlbnRlci5jbGllbnRXaWR0aDtcbiAgICB2YXIgd2lkdGhJbk1zID0gdGhpcy53aWR0aCAqIG1zUGVyUGl4ZWw7XG5cbiAgICBpZiAoYWxpZ24gPT0gJ3JpZ2h0Jykge1xuICAgICAgaXNWaXNpYmxlID0gdGhpcy5kYXRhLnN0YXJ0LmdldFRpbWUoKSA+IHJhbmdlLnN0YXJ0ICYmIHRoaXMuZGF0YS5zdGFydC5nZXRUaW1lKCkgLSB3aWR0aEluTXMgPCByYW5nZS5lbmQ7XG4gICAgfSBlbHNlIGlmIChhbGlnbiA9PSAnbGVmdCcpIHtcbiAgICAgIGlzVmlzaWJsZSA9IHRoaXMuZGF0YS5zdGFydC5nZXRUaW1lKCkgKyB3aWR0aEluTXMgPiByYW5nZS5zdGFydCAmJiB0aGlzLmRhdGEuc3RhcnQuZ2V0VGltZSgpIDwgcmFuZ2UuZW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkZWZhdWx0IG9yICdjZW50ZXInXG4gICAgICBpc1Zpc2libGUgPSB0aGlzLmRhdGEuc3RhcnQuZ2V0VGltZSgpICsgd2lkdGhJbk1zIC8gMiA+IHJhbmdlLnN0YXJ0ICYmIHRoaXMuZGF0YS5zdGFydC5nZXRUaW1lKCkgLSB3aWR0aEluTXMgLyAyIDwgcmFuZ2UuZW5kO1xuICAgIH1cbiAgICByZXR1cm4gaXNWaXNpYmxlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBhaW50IHRoZSBpdGVtXG4gICAqL1xuICBCb3hJdGVtLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgIGlmICghZG9tKSB7XG4gICAgICAvLyBjcmVhdGUgRE9NXG4gICAgICB0aGlzLmRvbSA9IHt9O1xuICAgICAgZG9tID0gdGhpcy5kb207XG5cbiAgICAgIC8vIGNyZWF0ZSBtYWluIGJveFxuICAgICAgZG9tLmJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuXG4gICAgICAvLyBjb250ZW50cyBib3ggKGluc2lkZSB0aGUgYmFja2dyb3VuZCBib3gpLiB1c2VkIGZvciBtYWtpbmcgbWFyZ2luc1xuICAgICAgZG9tLmNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgIGRvbS5jb250ZW50LmNsYXNzTmFtZSA9ICd2aXMtaXRlbS1jb250ZW50JztcbiAgICAgIGRvbS5ib3guYXBwZW5kQ2hpbGQoZG9tLmNvbnRlbnQpO1xuXG4gICAgICAvLyBsaW5lIHRvIGF4aXNcbiAgICAgIGRvbS5saW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgICBkb20ubGluZS5jbGFzc05hbWUgPSAndmlzLWxpbmUnO1xuXG4gICAgICAvLyBkb3Qgb24gYXhpc1xuICAgICAgZG9tLmRvdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgZG9tLmRvdC5jbGFzc05hbWUgPSAndmlzLWRvdCc7XG5cbiAgICAgIC8vIGF0dGFjaCB0aGlzIGl0ZW0gYXMgYXR0cmlidXRlXG4gICAgICBkb20uYm94Wyd0aW1lbGluZS1pdGVtJ10gPSB0aGlzO1xuXG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBhcHBlbmQgRE9NIHRvIHBhcmVudCBET01cbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogbm8gcGFyZW50IGF0dGFjaGVkJyk7XG4gICAgfVxuICAgIGlmICghZG9tLmJveC5wYXJlbnROb2RlKSB7XG4gICAgICB2YXIgZm9yZWdyb3VuZCA9IHRoaXMucGFyZW50LmRvbS5mb3JlZ3JvdW5kO1xuICAgICAgaWYgKCFmb3JlZ3JvdW5kKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogcGFyZW50IGhhcyBubyBmb3JlZ3JvdW5kIGNvbnRhaW5lciBlbGVtZW50Jyk7XG4gICAgICBmb3JlZ3JvdW5kLmFwcGVuZENoaWxkKGRvbS5ib3gpO1xuICAgIH1cbiAgICBpZiAoIWRvbS5saW5lLnBhcmVudE5vZGUpIHtcbiAgICAgIHZhciBiYWNrZ3JvdW5kID0gdGhpcy5wYXJlbnQuZG9tLmJhY2tncm91bmQ7XG4gICAgICBpZiAoIWJhY2tncm91bmQpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyBpdGVtOiBwYXJlbnQgaGFzIG5vIGJhY2tncm91bmQgY29udGFpbmVyIGVsZW1lbnQnKTtcbiAgICAgIGJhY2tncm91bmQuYXBwZW5kQ2hpbGQoZG9tLmxpbmUpO1xuICAgIH1cbiAgICBpZiAoIWRvbS5kb3QucGFyZW50Tm9kZSkge1xuICAgICAgdmFyIGF4aXMgPSB0aGlzLnBhcmVudC5kb20uYXhpcztcbiAgICAgIGlmICghYmFja2dyb3VuZCkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IHBhcmVudCBoYXMgbm8gYXhpcyBjb250YWluZXIgZWxlbWVudCcpO1xuICAgICAgYXhpcy5hcHBlbmRDaGlsZChkb20uZG90KTtcbiAgICB9XG4gICAgdGhpcy5kaXNwbGF5ZWQgPSB0cnVlO1xuXG4gICAgLy8gVXBkYXRlIERPTSB3aGVuIGl0ZW0gaXMgbWFya2VkIGRpcnR5LiBBbiBpdGVtIGlzIG1hcmtlZCBkaXJ0eSB3aGVuOlxuICAgIC8vIC0gdGhlIGl0ZW0gaXMgbm90IHlldCByZW5kZXJlZFxuICAgIC8vIC0gdGhlIGl0ZW0ncyBkYXRhIGlzIGNoYW5nZWRcbiAgICAvLyAtIHRoZSBpdGVtIGlzIHNlbGVjdGVkL2Rlc2VsZWN0ZWRcbiAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgdGhpcy5fdXBkYXRlQ29udGVudHModGhpcy5kb20uY29udGVudCk7XG4gICAgICB0aGlzLl91cGRhdGVUaXRsZSh0aGlzLmRvbS5ib3gpO1xuICAgICAgdGhpcy5fdXBkYXRlRGF0YUF0dHJpYnV0ZXModGhpcy5kb20uYm94KTtcbiAgICAgIHRoaXMuX3VwZGF0ZVN0eWxlKHRoaXMuZG9tLmJveCk7XG5cbiAgICAgIHZhciBlZGl0YWJsZSA9ICh0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlVGltZSB8fCB0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlR3JvdXAgfHwgdGhpcy5lZGl0YWJsZSA9PT0gdHJ1ZSkgJiYgdGhpcy5lZGl0YWJsZSAhPT0gZmFsc2U7XG5cbiAgICAgIC8vIHVwZGF0ZSBjbGFzc1xuICAgICAgdmFyIGNsYXNzTmFtZSA9ICh0aGlzLmRhdGEuY2xhc3NOYW1lID8gJyAnICsgdGhpcy5kYXRhLmNsYXNzTmFtZSA6ICcnKSArICh0aGlzLnNlbGVjdGVkID8gJyB2aXMtc2VsZWN0ZWQnIDogJycpICsgKGVkaXRhYmxlID8gJyB2aXMtZWRpdGFibGUnIDogJyB2aXMtcmVhZG9ubHknKTtcbiAgICAgIGRvbS5ib3guY2xhc3NOYW1lID0gJ3Zpcy1pdGVtIHZpcy1ib3gnICsgY2xhc3NOYW1lO1xuICAgICAgZG9tLmxpbmUuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtIHZpcy1saW5lJyArIGNsYXNzTmFtZTtcbiAgICAgIGRvbS5kb3QuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtIHZpcy1kb3QnICsgY2xhc3NOYW1lO1xuXG4gICAgICAvLyBzZXQgaW5pdGlhbCBwb3NpdGlvbiBpbiB0aGUgdmlzaWJsZSByYW5nZSBvZiB0aGUgZ3JpZCBzbyB0aGF0IHRoZVxuICAgICAgLy8gcmVuZGVyZWQgYm94IHNpemUgY2FuIGJlIGRldGVybWluYXRlZCBjb3JyZWN0bHksIGV2ZW4gdGhlIGNvbnRlbnRcbiAgICAgIC8vIGhhcyBhIGR5bmFtaWMgd2lkdGggKGZpeGVzICMyMDMyKS5cbiAgICAgIHZhciBwcmV2aW91c1JpZ2h0ID0gZG9tLmJveC5zdHlsZS5yaWdodDtcbiAgICAgIHZhciBwcmV2aW91c0xlZnQgPSBkb20uYm94LnN0eWxlLmxlZnQ7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICBkb20uYm94LnN0eWxlLnJpZ2h0ID0gXCIwcHhcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbS5ib3guc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlY2FsY3VsYXRlIHNpemVcbiAgICAgIHRoaXMucHJvcHMuZG90LmhlaWdodCA9IGRvbS5kb3Qub2Zmc2V0SGVpZ2h0O1xuICAgICAgdGhpcy5wcm9wcy5kb3Qud2lkdGggPSBkb20uZG90Lm9mZnNldFdpZHRoO1xuICAgICAgdGhpcy5wcm9wcy5saW5lLndpZHRoID0gZG9tLmxpbmUub2Zmc2V0V2lkdGg7XG4gICAgICB0aGlzLndpZHRoID0gZG9tLmJveC5vZmZzZXRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gZG9tLmJveC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgIC8vIHJlc3RvcmUgcHJldmlvdXMgcG9zaXRpb25cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgIGRvbS5ib3guc3R5bGUucmlnaHQgPSBwcmV2aW91c1JpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tLmJveC5zdHlsZS5sZWZ0ID0gcHJldmlvdXNMZWZ0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVwYWludE9uSXRlbVVwZGF0ZVRpbWVUb29sdGlwKGRvbS5ib3gpO1xuICAgIHRoaXMuX3JlcGFpbnREcmFnQ2VudGVyKCk7XG4gICAgdGhpcy5fcmVwYWludERlbGV0ZUJ1dHRvbihkb20uYm94KTtcbiAgfTtcblxuICAvKipcbiAgICogU2hvdyB0aGUgaXRlbSBpbiB0aGUgRE9NICh3aGVuIG5vdCBhbHJlYWR5IGRpc3BsYXllZCkuIFRoZSBpdGVtcyBET00gd2lsbFxuICAgKiBiZSBjcmVhdGVkIHdoZW4gbmVlZGVkLlxuICAgKi9cbiAgQm94SXRlbS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuZGlzcGxheWVkKSB7XG4gICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGlkZSB0aGUgaXRlbSBmcm9tIHRoZSBET00gKHdoZW4gdmlzaWJsZSlcbiAgICovXG4gIEJveEl0ZW0ucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZGlzcGxheWVkKSB7XG4gICAgICB2YXIgZG9tID0gdGhpcy5kb207XG5cbiAgICAgIGlmIChkb20uYm94LnBhcmVudE5vZGUpIGRvbS5ib3gucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb20uYm94KTtcbiAgICAgIGlmIChkb20ubGluZS5wYXJlbnROb2RlKSBkb20ubGluZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvbS5saW5lKTtcbiAgICAgIGlmIChkb20uZG90LnBhcmVudE5vZGUpIGRvbS5kb3QucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb20uZG90KTtcblxuICAgICAgdGhpcy5kaXNwbGF5ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcG9zaXRpb24gdGhlIGl0ZW0gaG9yaXpvbnRhbGx5XG4gICAqIEBPdmVycmlkZVxuICAgKi9cbiAgQm94SXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5jb252ZXJzaW9uLnRvU2NyZWVuKHRoaXMuZGF0YS5zdGFydCk7XG4gICAgdmFyIGFsaWduID0gdGhpcy5vcHRpb25zLmFsaWduO1xuXG4gICAgLy8gY2FsY3VsYXRlIGxlZnQgcG9zaXRpb24gb2YgdGhlIGJveFxuICAgIGlmIChhbGlnbiA9PSAncmlnaHQnKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICB0aGlzLnJpZ2h0ID0gc3RhcnQgLSB0aGlzLndpZHRoO1xuXG4gICAgICAgIC8vIHJlcG9zaXRpb24gYm94LCBsaW5lLCBhbmQgZG90XG4gICAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS5yaWdodCA9IHRoaXMucmlnaHQgKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS5saW5lLnN0eWxlLnJpZ2h0ID0gc3RhcnQgLSB0aGlzLnByb3BzLmxpbmUud2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS5kb3Quc3R5bGUucmlnaHQgPSBzdGFydCAtIHRoaXMucHJvcHMubGluZS53aWR0aCAvIDIgLSB0aGlzLnByb3BzLmRvdC53aWR0aCAvIDIgKyAncHgnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0gc3RhcnQgLSB0aGlzLndpZHRoO1xuXG4gICAgICAgIC8vIHJlcG9zaXRpb24gYm94LCBsaW5lLCBhbmQgZG90XG4gICAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS5sZWZ0ID0gdGhpcy5sZWZ0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb20ubGluZS5zdHlsZS5sZWZ0ID0gc3RhcnQgLSB0aGlzLnByb3BzLmxpbmUud2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS5kb3Quc3R5bGUubGVmdCA9IHN0YXJ0IC0gdGhpcy5wcm9wcy5saW5lLndpZHRoIC8gMiAtIHRoaXMucHJvcHMuZG90LndpZHRoIC8gMiArICdweCc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhbGlnbiA9PSAnbGVmdCcpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgIHRoaXMucmlnaHQgPSBzdGFydDtcblxuICAgICAgICAvLyByZXBvc2l0aW9uIGJveCwgbGluZSwgYW5kIGRvdFxuICAgICAgICB0aGlzLmRvbS5ib3guc3R5bGUucmlnaHQgPSB0aGlzLnJpZ2h0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb20ubGluZS5zdHlsZS5yaWdodCA9IHN0YXJ0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb20uZG90LnN0eWxlLnJpZ2h0ID0gc3RhcnQgKyB0aGlzLnByb3BzLmxpbmUud2lkdGggLyAyIC0gdGhpcy5wcm9wcy5kb3Qud2lkdGggLyAyICsgJ3B4JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGVmdCA9IHN0YXJ0O1xuXG4gICAgICAgIC8vIHJlcG9zaXRpb24gYm94LCBsaW5lLCBhbmQgZG90XG4gICAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS5sZWZ0ID0gdGhpcy5sZWZ0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb20ubGluZS5zdHlsZS5sZWZ0ID0gc3RhcnQgKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS5kb3Quc3R5bGUubGVmdCA9IHN0YXJ0ICsgdGhpcy5wcm9wcy5saW5lLndpZHRoIC8gMiAtIHRoaXMucHJvcHMuZG90LndpZHRoIC8gMiArICdweCc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRlZmF1bHQgb3IgJ2NlbnRlcidcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgIHRoaXMucmlnaHQgPSBzdGFydCAtIHRoaXMud2lkdGggLyAyO1xuXG4gICAgICAgIC8vIHJlcG9zaXRpb24gYm94LCBsaW5lLCBhbmQgZG90XG4gICAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS5yaWdodCA9IHRoaXMucmlnaHQgKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS5saW5lLnN0eWxlLnJpZ2h0ID0gc3RhcnQgLSB0aGlzLnByb3BzLmxpbmUud2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS5kb3Quc3R5bGUucmlnaHQgPSBzdGFydCAtIHRoaXMucHJvcHMuZG90LndpZHRoIC8gMiArICdweCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxlZnQgPSBzdGFydCAtIHRoaXMud2lkdGggLyAyO1xuXG4gICAgICAgIC8vIHJlcG9zaXRpb24gYm94LCBsaW5lLCBhbmQgZG90XG4gICAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS5sZWZ0ID0gdGhpcy5sZWZ0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb20ubGluZS5zdHlsZS5sZWZ0ID0gc3RhcnQgLSB0aGlzLnByb3BzLmxpbmUud2lkdGggLyAyICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb20uZG90LnN0eWxlLmxlZnQgPSBzdGFydCAtIHRoaXMucHJvcHMuZG90LndpZHRoIC8gMiArICdweCc7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBvc2l0aW9uIHRoZSBpdGVtIHZlcnRpY2FsbHlcbiAgICogQE92ZXJyaWRlXG4gICAqL1xuICBCb3hJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3JpZW50YXRpb24gPSB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbTtcbiAgICB2YXIgYm94ID0gdGhpcy5kb20uYm94O1xuICAgIHZhciBsaW5lID0gdGhpcy5kb20ubGluZTtcbiAgICB2YXIgZG90ID0gdGhpcy5kb20uZG90O1xuXG4gICAgaWYgKG9yaWVudGF0aW9uID09ICd0b3AnKSB7XG4gICAgICBib3guc3R5bGUudG9wID0gKHRoaXMudG9wIHx8IDApICsgJ3B4JztcblxuICAgICAgbGluZS5zdHlsZS50b3AgPSAnMCc7XG4gICAgICBsaW5lLnN0eWxlLmhlaWdodCA9IHRoaXMucGFyZW50LnRvcCArIHRoaXMudG9wICsgMSArICdweCc7XG4gICAgICBsaW5lLnN0eWxlLmJvdHRvbSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvcmllbnRhdGlvbiAnYm90dG9tJ1xuICAgICAgdmFyIGl0ZW1TZXRIZWlnaHQgPSB0aGlzLnBhcmVudC5pdGVtU2V0LnByb3BzLmhlaWdodDsgLy8gVE9ETzogdGhpcyBpcyBuYXN0eVxuICAgICAgdmFyIGxpbmVIZWlnaHQgPSBpdGVtU2V0SGVpZ2h0IC0gdGhpcy5wYXJlbnQudG9wIC0gdGhpcy5wYXJlbnQuaGVpZ2h0ICsgdGhpcy50b3A7XG5cbiAgICAgIGJveC5zdHlsZS50b3AgPSAodGhpcy5wYXJlbnQuaGVpZ2h0IC0gdGhpcy50b3AgLSB0aGlzLmhlaWdodCB8fCAwKSArICdweCc7XG4gICAgICBsaW5lLnN0eWxlLnRvcCA9IGl0ZW1TZXRIZWlnaHQgLSBsaW5lSGVpZ2h0ICsgJ3B4JztcbiAgICAgIGxpbmUuc3R5bGUuYm90dG9tID0gJzAnO1xuICAgIH1cblxuICAgIGRvdC5zdHlsZS50b3AgPSAtdGhpcy5wcm9wcy5kb3QuaGVpZ2h0IC8gMiArICdweCc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgd2lkdGggb2YgdGhlIGl0ZW0gbGVmdCBmcm9tIGl0cyBzdGFydCBkYXRlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIEJveEl0ZW0ucHJvdG90eXBlLmdldFdpZHRoTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy53aWR0aCAvIDI7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgd2lkdGggb2YgdGhlIGl0ZW0gcmlnaHQgZnJvbSBpdHMgc3RhcnQgZGF0ZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBCb3hJdGVtLnByb3RvdHlwZS5nZXRXaWR0aFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLndpZHRoIC8gMjtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IEJveEl0ZW07XG5cbi8qKiovIH0sXG4vKiA0NCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBJdGVtID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBQb2ludEl0ZW1cbiAgICogQGV4dGVuZHMgSXRlbVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzIHN0YXJ0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsIGNsYXNzTmFtZS5cbiAgICogQHBhcmFtIHt7dG9TY3JlZW46IGZ1bmN0aW9uLCB0b1RpbWU6IGZ1bmN0aW9ufX0gY29udmVyc2lvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb252ZXJzaW9uIGZ1bmN0aW9ucyBmcm9tIHRpbWUgdG8gc2NyZWVuIGFuZCB2aWNlIHZlcnNhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBkZXNjcmliZSBhdmFpbGFibGUgb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gUG9pbnRJdGVtKGRhdGEsIGNvbnZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICB0aGlzLnByb3BzID0ge1xuICAgICAgZG90OiB7XG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfSxcbiAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICBtYXJnaW5MZWZ0OiAwLFxuICAgICAgICBtYXJnaW5SaWdodDogMFxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyB2YWxpZGF0ZSBkYXRhXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLnN0YXJ0ID09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IFwic3RhcnRcIiBtaXNzaW5nIGluIGl0ZW0gJyArIGRhdGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEl0ZW0uY2FsbCh0aGlzLCBkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKTtcbiAgfVxuXG4gIFBvaW50SXRlbS5wcm90b3R5cGUgPSBuZXcgSXRlbShudWxsLCBudWxsLCBudWxsKTtcblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGlzIGl0ZW0gaXMgdmlzaWJsZSBpbnNpZGUgZ2l2ZW4gcmFuZ2VcbiAgICogQHJldHVybnMge3tzdGFydDogTnVtYmVyLCBlbmQ6IE51bWJlcn19IHJhbmdlIHdpdGggYSB0aW1lc3RhbXAgZm9yIHN0YXJ0IGFuZCBlbmRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmlzaWJsZVxuICAgKi9cbiAgUG9pbnRJdGVtLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAvLyBkZXRlcm1pbmUgdmlzaWJpbGl0eVxuICAgIHZhciBtc1BlclBpeGVsID0gKHJhbmdlLmVuZCAtIHJhbmdlLnN0YXJ0KSAvIHJhbmdlLmJvZHkuZG9tLmNlbnRlci5jbGllbnRXaWR0aDtcbiAgICB2YXIgd2lkdGhJbk1zID0gdGhpcy53aWR0aCAqIG1zUGVyUGl4ZWw7XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhLnN0YXJ0LmdldFRpbWUoKSArIHdpZHRoSW5NcyA+IHJhbmdlLnN0YXJ0ICYmIHRoaXMuZGF0YS5zdGFydCA8IHJhbmdlLmVuZDtcbiAgfTtcblxuICAvKipcbiAgICogUmVwYWludCB0aGUgaXRlbVxuICAgKi9cbiAgUG9pbnRJdGVtLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgIGlmICghZG9tKSB7XG4gICAgICAvLyBjcmVhdGUgRE9NXG4gICAgICB0aGlzLmRvbSA9IHt9O1xuICAgICAgZG9tID0gdGhpcy5kb207XG5cbiAgICAgIC8vIGJhY2tncm91bmQgYm94XG4gICAgICBkb20ucG9pbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIC8vIGNsYXNzTmFtZSBpcyB1cGRhdGVkIGluIHJlZHJhdygpXG5cbiAgICAgIC8vIGNvbnRlbnRzIGJveCwgcmlnaHQgZnJvbSB0aGUgZG90XG4gICAgICBkb20uY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZG9tLmNvbnRlbnQuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtLWNvbnRlbnQnO1xuICAgICAgZG9tLnBvaW50LmFwcGVuZENoaWxkKGRvbS5jb250ZW50KTtcblxuICAgICAgLy8gZG90IGF0IHN0YXJ0XG4gICAgICBkb20uZG90ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkb20ucG9pbnQuYXBwZW5kQ2hpbGQoZG9tLmRvdCk7XG5cbiAgICAgIC8vIGF0dGFjaCB0aGlzIGl0ZW0gYXMgYXR0cmlidXRlXG4gICAgICBkb20ucG9pbnRbJ3RpbWVsaW5lLWl0ZW0nXSA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGFwcGVuZCBET00gdG8gcGFyZW50IERPTVxuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyBpdGVtOiBubyBwYXJlbnQgYXR0YWNoZWQnKTtcbiAgICB9XG4gICAgaWYgKCFkb20ucG9pbnQucGFyZW50Tm9kZSkge1xuICAgICAgdmFyIGZvcmVncm91bmQgPSB0aGlzLnBhcmVudC5kb20uZm9yZWdyb3VuZDtcbiAgICAgIGlmICghZm9yZWdyb3VuZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogcGFyZW50IGhhcyBubyBmb3JlZ3JvdW5kIGNvbnRhaW5lciBlbGVtZW50Jyk7XG4gICAgICB9XG4gICAgICBmb3JlZ3JvdW5kLmFwcGVuZENoaWxkKGRvbS5wb2ludCk7XG4gICAgfVxuICAgIHRoaXMuZGlzcGxheWVkID0gdHJ1ZTtcblxuICAgIC8vIFVwZGF0ZSBET00gd2hlbiBpdGVtIGlzIG1hcmtlZCBkaXJ0eS4gQW4gaXRlbSBpcyBtYXJrZWQgZGlydHkgd2hlbjpcbiAgICAvLyAtIHRoZSBpdGVtIGlzIG5vdCB5ZXQgcmVuZGVyZWRcbiAgICAvLyAtIHRoZSBpdGVtJ3MgZGF0YSBpcyBjaGFuZ2VkXG4gICAgLy8gLSB0aGUgaXRlbSBpcyBzZWxlY3RlZC9kZXNlbGVjdGVkXG4gICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUNvbnRlbnRzKHRoaXMuZG9tLmNvbnRlbnQpO1xuICAgICAgdGhpcy5fdXBkYXRlVGl0bGUodGhpcy5kb20ucG9pbnQpO1xuICAgICAgdGhpcy5fdXBkYXRlRGF0YUF0dHJpYnV0ZXModGhpcy5kb20ucG9pbnQpO1xuICAgICAgdGhpcy5fdXBkYXRlU3R5bGUodGhpcy5kb20ucG9pbnQpO1xuXG4gICAgICB2YXIgZWRpdGFibGUgPSAodGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZVRpbWUgfHwgdGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZUdyb3VwIHx8IHRoaXMuZWRpdGFibGUgPT09IHRydWUpICYmIHRoaXMuZWRpdGFibGUgIT09IGZhbHNlO1xuXG4gICAgICAvLyB1cGRhdGUgY2xhc3NcbiAgICAgIHZhciBjbGFzc05hbWUgPSAodGhpcy5kYXRhLmNsYXNzTmFtZSA/ICcgJyArIHRoaXMuZGF0YS5jbGFzc05hbWUgOiAnJykgKyAodGhpcy5zZWxlY3RlZCA/ICcgdmlzLXNlbGVjdGVkJyA6ICcnKSArIChlZGl0YWJsZSA/ICcgdmlzLWVkaXRhYmxlJyA6ICcgdmlzLXJlYWRvbmx5Jyk7XG4gICAgICBkb20ucG9pbnQuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtIHZpcy1wb2ludCcgKyBjbGFzc05hbWU7XG4gICAgICBkb20uZG90LmNsYXNzTmFtZSA9ICd2aXMtaXRlbSB2aXMtZG90JyArIGNsYXNzTmFtZTtcblxuICAgICAgLy8gcmVjYWxjdWxhdGUgc2l6ZSBvZiBkb3QgYW5kIGNvbnRlbnRzXG4gICAgICB0aGlzLnByb3BzLmRvdC53aWR0aCA9IGRvbS5kb3Qub2Zmc2V0V2lkdGg7XG4gICAgICB0aGlzLnByb3BzLmRvdC5oZWlnaHQgPSBkb20uZG90Lm9mZnNldEhlaWdodDtcbiAgICAgIHRoaXMucHJvcHMuY29udGVudC5oZWlnaHQgPSBkb20uY29udGVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgIC8vIHJlc2l6ZSBjb250ZW50c1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgZG9tLmNvbnRlbnQuc3R5bGUubWFyZ2luUmlnaHQgPSAyICogdGhpcy5wcm9wcy5kb3Qud2lkdGggKyAncHgnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tLmNvbnRlbnQuc3R5bGUubWFyZ2luTGVmdCA9IDIgKiB0aGlzLnByb3BzLmRvdC53aWR0aCArICdweCc7XG4gICAgICB9XG4gICAgICAvL2RvbS5jb250ZW50LnN0eWxlLm1hcmdpblJpZ2h0ID0gLi4uICsgJ3B4JzsgLy8gVE9ETzogbWFyZ2luIHJpZ2h0XG5cbiAgICAgIC8vIHJlY2FsY3VsYXRlIHNpemVcbiAgICAgIHRoaXMud2lkdGggPSBkb20ucG9pbnQub2Zmc2V0V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGRvbS5wb2ludC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgIC8vIHJlcG9zaXRpb24gdGhlIGRvdFxuICAgICAgZG9tLmRvdC5zdHlsZS50b3AgPSAodGhpcy5oZWlnaHQgLSB0aGlzLnByb3BzLmRvdC5oZWlnaHQpIC8gMiArICdweCc7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICBkb20uZG90LnN0eWxlLnJpZ2h0ID0gdGhpcy5wcm9wcy5kb3Qud2lkdGggLyAyICsgJ3B4JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbS5kb3Quc3R5bGUubGVmdCA9IHRoaXMucHJvcHMuZG90LndpZHRoIC8gMiArICdweCc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXBhaW50T25JdGVtVXBkYXRlVGltZVRvb2x0aXAoZG9tLnBvaW50KTtcbiAgICB0aGlzLl9yZXBhaW50RHJhZ0NlbnRlcigpO1xuICAgIHRoaXMuX3JlcGFpbnREZWxldGVCdXR0b24oZG9tLnBvaW50KTtcbiAgfTtcblxuICAvKipcbiAgICogU2hvdyB0aGUgaXRlbSBpbiB0aGUgRE9NICh3aGVuIG5vdCBhbHJlYWR5IHZpc2libGUpLiBUaGUgaXRlbXMgRE9NIHdpbGxcbiAgICogYmUgY3JlYXRlZCB3aGVuIG5lZWRlZC5cbiAgICovXG4gIFBvaW50SXRlbS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuZGlzcGxheWVkKSB7XG4gICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGlkZSB0aGUgaXRlbSBmcm9tIHRoZSBET00gKHdoZW4gdmlzaWJsZSlcbiAgICovXG4gIFBvaW50SXRlbS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kaXNwbGF5ZWQpIHtcbiAgICAgIGlmICh0aGlzLmRvbS5wb2ludC5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMuZG9tLnBvaW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20ucG9pbnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRpc3BsYXllZCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVwb3NpdGlvbiB0aGUgaXRlbSBob3Jpem9udGFsbHlcbiAgICogQE92ZXJyaWRlXG4gICAqL1xuICBQb2ludEl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25YID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuY29udmVyc2lvbi50b1NjcmVlbih0aGlzLmRhdGEuc3RhcnQpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgIHRoaXMucmlnaHQgPSBzdGFydCAtIHRoaXMucHJvcHMuZG90LndpZHRoO1xuXG4gICAgICAvLyByZXBvc2l0aW9uIHBvaW50XG4gICAgICB0aGlzLmRvbS5wb2ludC5zdHlsZS5yaWdodCA9IHRoaXMucmlnaHQgKyAncHgnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxlZnQgPSBzdGFydCAtIHRoaXMucHJvcHMuZG90LndpZHRoO1xuXG4gICAgICAvLyByZXBvc2l0aW9uIHBvaW50XG4gICAgICB0aGlzLmRvbS5wb2ludC5zdHlsZS5sZWZ0ID0gdGhpcy5sZWZ0ICsgJ3B4JztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcG9zaXRpb24gdGhlIGl0ZW0gdmVydGljYWxseVxuICAgKiBAT3ZlcnJpZGVcbiAgICovXG4gIFBvaW50SXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9yaWVudGF0aW9uID0gdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLml0ZW07XG4gICAgdmFyIHBvaW50ID0gdGhpcy5kb20ucG9pbnQ7XG4gICAgaWYgKG9yaWVudGF0aW9uID09ICd0b3AnKSB7XG4gICAgICBwb2ludC5zdHlsZS50b3AgPSB0aGlzLnRvcCArICdweCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50LnN0eWxlLnRvcCA9IHRoaXMucGFyZW50LmhlaWdodCAtIHRoaXMudG9wIC0gdGhpcy5oZWlnaHQgKyAncHgnO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgaXRlbSBsZWZ0IGZyb20gaXRzIHN0YXJ0IGRhdGVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgUG9pbnRJdGVtLnByb3RvdHlwZS5nZXRXaWR0aExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuZG90LndpZHRoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSBpdGVtIHJpZ2h0IGZyb20gIGl0cyBzdGFydCBkYXRlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIFBvaW50SXRlbS5wcm90b3R5cGUuZ2V0V2lkdGhSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5kb3Qud2lkdGg7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBQb2ludEl0ZW07XG5cbi8qKiovIH0sXG4vKiA0NSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBIYW1tZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcbiAgdmFyIEl0ZW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcbiAgdmFyIEJhY2tncm91bmRHcm91cCA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xuICB2YXIgUmFuZ2VJdGVtID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBCYWNrZ3JvdW5kSXRlbVxuICAgKiBAZXh0ZW5kcyBJdGVtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnMgc3RhcnQsIGVuZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LCBjbGFzc05hbWUuXG4gICAqIEBwYXJhbSB7e3RvU2NyZWVuOiBmdW5jdGlvbiwgdG9UaW1lOiBmdW5jdGlvbn19IGNvbnZlcnNpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udmVyc2lvbiBmdW5jdGlvbnMgZnJvbSB0aW1lIHRvIHNjcmVlbiBhbmQgdmljZSB2ZXJzYVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZGVzY3JpYmUgb3B0aW9uc1xuICAgKi9cbiAgLy8gVE9ETzogaW1wbGVtZW50IHN1cHBvcnQgZm9yIHRoZSBCYWNrZ3JvdW5kSXRlbSBqdXN0IGhhdmluZyBhIHN0YXJ0LCB0aGVuIGJlaW5nIGRpc3BsYXllZCBhcyBhIHNvcnQgb2YgYW4gYW5ub3RhdGlvblxuICBmdW5jdGlvbiBCYWNrZ3JvdW5kSXRlbShkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKSB7XG4gICAgdGhpcy5wcm9wcyA9IHtcbiAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgd2lkdGg6IDBcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub3ZlcmZsb3cgPSBmYWxzZTsgLy8gaWYgY29udGVudHMgY2FuIG92ZXJmbG93IChjc3Mgc3R5bGluZyksIHRoaXMgZmxhZyBpcyBzZXQgdG8gdHJ1ZVxuXG4gICAgLy8gdmFsaWRhdGUgZGF0YVxuICAgIGlmIChkYXRhKSB7XG4gICAgICBpZiAoZGF0YS5zdGFydCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBcInN0YXJ0XCIgbWlzc2luZyBpbiBpdGVtICcgKyBkYXRhLmlkKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLmVuZCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBcImVuZFwiIG1pc3NpbmcgaW4gaXRlbSAnICsgZGF0YS5pZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgSXRlbS5jYWxsKHRoaXMsIGRhdGEsIGNvbnZlcnNpb24sIG9wdGlvbnMpO1xuICB9XG5cbiAgQmFja2dyb3VuZEl0ZW0ucHJvdG90eXBlID0gbmV3IEl0ZW0obnVsbCwgbnVsbCwgbnVsbCk7XG5cbiAgQmFja2dyb3VuZEl0ZW0ucHJvdG90eXBlLmJhc2VDbGFzc05hbWUgPSAndmlzLWl0ZW0gdmlzLWJhY2tncm91bmQnO1xuICBCYWNrZ3JvdW5kSXRlbS5wcm90b3R5cGUuc3RhY2sgPSBmYWxzZTtcblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGlzIGl0ZW0gaXMgdmlzaWJsZSBpbnNpZGUgZ2l2ZW4gcmFuZ2VcbiAgICogQHJldHVybnMge3tzdGFydDogTnVtYmVyLCBlbmQ6IE51bWJlcn19IHJhbmdlIHdpdGggYSB0aW1lc3RhbXAgZm9yIHN0YXJ0IGFuZCBlbmRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmlzaWJsZVxuICAgKi9cbiAgQmFja2dyb3VuZEl0ZW0ucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgIC8vIGRldGVybWluZSB2aXNpYmlsaXR5XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zdGFydCA8IHJhbmdlLmVuZCAmJiB0aGlzLmRhdGEuZW5kID4gcmFuZ2Uuc3RhcnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGFpbnQgdGhlIGl0ZW1cbiAgICovXG4gIEJhY2tncm91bmRJdGVtLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgIGlmICghZG9tKSB7XG4gICAgICAvLyBjcmVhdGUgRE9NXG4gICAgICB0aGlzLmRvbSA9IHt9O1xuICAgICAgZG9tID0gdGhpcy5kb207XG5cbiAgICAgIC8vIGJhY2tncm91bmQgYm94XG4gICAgICBkb20uYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAvLyBjbGFzc05hbWUgaXMgdXBkYXRlZCBpbiByZWRyYXcoKVxuXG4gICAgICAvLyBmcmFtZSBib3ggKHRvIHByZXZlbnQgdGhlIGl0ZW0gY29udGVudHMgZnJvbSBvdmVyZmxvd2luZ1xuICAgICAgZG9tLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkb20uZnJhbWUuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtLW92ZXJmbG93JztcbiAgICAgIGRvbS5ib3guYXBwZW5kQ2hpbGQoZG9tLmZyYW1lKTtcblxuICAgICAgLy8gY29udGVudHMgYm94XG4gICAgICBkb20uY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZG9tLmNvbnRlbnQuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtLWNvbnRlbnQnO1xuICAgICAgZG9tLmZyYW1lLmFwcGVuZENoaWxkKGRvbS5jb250ZW50KTtcblxuICAgICAgLy8gTm90ZTogd2UgZG8gTk9UIGF0dGFjaCB0aGlzIGl0ZW0gYXMgYXR0cmlidXRlIHRvIHRoZSBET00sXG4gICAgICAvLyAgICAgICBzdWNoIHRoYXQgYmFja2dyb3VuZCBpdGVtcyBjYW5ub3QgYmUgc2VsZWN0ZWRcbiAgICAgIC8vZG9tLmJveFsndGltZWxpbmUtaXRlbSddID0gdGhpcztcblxuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gYXBwZW5kIERPTSB0byBwYXJlbnQgRE9NXG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IG5vIHBhcmVudCBhdHRhY2hlZCcpO1xuICAgIH1cbiAgICBpZiAoIWRvbS5ib3gucGFyZW50Tm9kZSkge1xuICAgICAgdmFyIGJhY2tncm91bmQgPSB0aGlzLnBhcmVudC5kb20uYmFja2dyb3VuZDtcbiAgICAgIGlmICghYmFja2dyb3VuZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogcGFyZW50IGhhcyBubyBiYWNrZ3JvdW5kIGNvbnRhaW5lciBlbGVtZW50Jyk7XG4gICAgICB9XG4gICAgICBiYWNrZ3JvdW5kLmFwcGVuZENoaWxkKGRvbS5ib3gpO1xuICAgIH1cbiAgICB0aGlzLmRpc3BsYXllZCA9IHRydWU7XG5cbiAgICAvLyBVcGRhdGUgRE9NIHdoZW4gaXRlbSBpcyBtYXJrZWQgZGlydHkuIEFuIGl0ZW0gaXMgbWFya2VkIGRpcnR5IHdoZW46XG4gICAgLy8gLSB0aGUgaXRlbSBpcyBub3QgeWV0IHJlbmRlcmVkXG4gICAgLy8gLSB0aGUgaXRlbSdzIGRhdGEgaXMgY2hhbmdlZFxuICAgIC8vIC0gdGhlIGl0ZW0gaXMgc2VsZWN0ZWQvZGVzZWxlY3RlZFxuICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICB0aGlzLl91cGRhdGVDb250ZW50cyh0aGlzLmRvbS5jb250ZW50KTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRpdGxlKHRoaXMuZG9tLmNvbnRlbnQpO1xuICAgICAgdGhpcy5fdXBkYXRlRGF0YUF0dHJpYnV0ZXModGhpcy5kb20uY29udGVudCk7XG4gICAgICB0aGlzLl91cGRhdGVTdHlsZSh0aGlzLmRvbS5ib3gpO1xuXG4gICAgICAvLyB1cGRhdGUgY2xhc3NcbiAgICAgIHZhciBjbGFzc05hbWUgPSAodGhpcy5kYXRhLmNsYXNzTmFtZSA/ICcgJyArIHRoaXMuZGF0YS5jbGFzc05hbWUgOiAnJykgKyAodGhpcy5zZWxlY3RlZCA/ICcgdmlzLXNlbGVjdGVkJyA6ICcnKTtcbiAgICAgIGRvbS5ib3guY2xhc3NOYW1lID0gdGhpcy5iYXNlQ2xhc3NOYW1lICsgY2xhc3NOYW1lO1xuXG4gICAgICAvLyBkZXRlcm1pbmUgZnJvbSBjc3Mgd2hldGhlciB0aGlzIGJveCBoYXMgb3ZlcmZsb3dcbiAgICAgIHRoaXMub3ZlcmZsb3cgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20uY29udGVudCkub3ZlcmZsb3cgIT09ICdoaWRkZW4nO1xuXG4gICAgICAvLyByZWNhbGN1bGF0ZSBzaXplXG4gICAgICB0aGlzLnByb3BzLmNvbnRlbnQud2lkdGggPSB0aGlzLmRvbS5jb250ZW50Lm9mZnNldFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSAwOyAvLyBzZXQgaGVpZ2h0IHplcm8sIHNvIHRoaXMgaXRlbSB3aWxsIGJlIGlnbm9yZWQgd2hlbiBzdGFja2luZyBpdGVtc1xuXG4gICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBpdGVtIGluIHRoZSBET00gKHdoZW4gbm90IGFscmVhZHkgdmlzaWJsZSkuIFRoZSBpdGVtcyBET00gd2lsbFxuICAgKiBiZSBjcmVhdGVkIHdoZW4gbmVlZGVkLlxuICAgKi9cbiAgQmFja2dyb3VuZEl0ZW0ucHJvdG90eXBlLnNob3cgPSBSYW5nZUl0ZW0ucHJvdG90eXBlLnNob3c7XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIGl0ZW0gZnJvbSB0aGUgRE9NICh3aGVuIHZpc2libGUpXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGNoYW5nZWRcbiAgICovXG4gIEJhY2tncm91bmRJdGVtLnByb3RvdHlwZS5oaWRlID0gUmFuZ2VJdGVtLnByb3RvdHlwZS5oaWRlO1xuXG4gIC8qKlxuICAgKiBSZXBvc2l0aW9uIHRoZSBpdGVtIGhvcml6b250YWxseVxuICAgKiBAT3ZlcnJpZGVcbiAgICovXG4gIEJhY2tncm91bmRJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWCA9IFJhbmdlSXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblg7XG5cbiAgLyoqXG4gICAqIFJlcG9zaXRpb24gdGhlIGl0ZW0gdmVydGljYWxseVxuICAgKiBAT3ZlcnJpZGVcbiAgICovXG4gIEJhY2tncm91bmRJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWSA9IGZ1bmN0aW9uIChtYXJnaW4pIHtcbiAgICB2YXIgb25Ub3AgPSB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbSA9PT0gJ3RvcCc7XG4gICAgdGhpcy5kb20uY29udGVudC5zdHlsZS50b3AgPSBvblRvcCA/ICcnIDogJzAnO1xuICAgIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUuYm90dG9tID0gb25Ub3AgPyAnMCcgOiAnJztcbiAgICB2YXIgaGVpZ2h0O1xuXG4gICAgLy8gc3BlY2lhbCBwb3NpdGlvbmluZyBmb3Igc3ViZ3JvdXBzXG4gICAgaWYgKHRoaXMuZGF0YS5zdWJncm91cCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBUT0RPOiBpbnN0ZWFkIG9mIGNhbGN1bGF0aW5nIHRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIHN1Ymdyb3VwcyBoZXJlIGZvciBldmVyeSBCYWNrZ3JvdW5kSXRlbSwgY2FsY3VsYXRlIHRoZSB0b3Agb2YgdGhlIHN1Ymdyb3VwIG9uY2UgaW4gSXRlbXNldFxuXG4gICAgICB2YXIgaXRlbVN1Ymdyb3VwID0gdGhpcy5kYXRhLnN1Ymdyb3VwO1xuICAgICAgdmFyIHN1Ymdyb3VwcyA9IHRoaXMucGFyZW50LnN1Ymdyb3VwcztcbiAgICAgIHZhciBzdWJncm91cEluZGV4ID0gc3ViZ3JvdXBzW2l0ZW1TdWJncm91cF0uaW5kZXg7XG4gICAgICAvLyBpZiB0aGUgb3JpZW50YXRpb24gaXMgdG9wLCB3ZSBuZWVkIHRvIHRha2UgdGhlIGRpZmZlcmVuY2UgaW4gaGVpZ2h0IGludG8gYWNjb3VudC5cbiAgICAgIGlmIChvblRvcCA9PSB0cnVlKSB7XG4gICAgICAgIC8vIHRoZSBmaXJzdCBzdWJncm91cCB3aWxsIGhhdmUgdG8gYWNjb3VudCBmb3IgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHRvcCB0byB0aGUgZmlyc3QgaXRlbS5cbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5wYXJlbnQuc3ViZ3JvdXBzW2l0ZW1TdWJncm91cF0uaGVpZ2h0ICsgbWFyZ2luLml0ZW0udmVydGljYWw7XG4gICAgICAgIGhlaWdodCArPSBzdWJncm91cEluZGV4ID09IDAgPyBtYXJnaW4uYXhpcyAtIDAuNSAqIG1hcmdpbi5pdGVtLnZlcnRpY2FsIDogMDtcbiAgICAgICAgdmFyIG5ld1RvcCA9IHRoaXMucGFyZW50LnRvcDtcbiAgICAgICAgZm9yICh2YXIgc3ViZ3JvdXAgaW4gc3ViZ3JvdXBzKSB7XG4gICAgICAgICAgaWYgKHN1Ymdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShzdWJncm91cCkpIHtcbiAgICAgICAgICAgIGlmIChzdWJncm91cHNbc3ViZ3JvdXBdLnZpc2libGUgPT0gdHJ1ZSAmJiBzdWJncm91cHNbc3ViZ3JvdXBdLmluZGV4IDwgc3ViZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgICBuZXdUb3AgKz0gc3ViZ3JvdXBzW3N1Ymdyb3VwXS5oZWlnaHQgKyBtYXJnaW4uaXRlbS52ZXJ0aWNhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgb3RoZXJzIHdpbGwgaGF2ZSB0byBiZSBvZmZzZXQgZG93bndhcmRzIHdpdGggdGhpcyBzYW1lIGRpc3RhbmNlLlxuICAgICAgICBuZXdUb3AgKz0gc3ViZ3JvdXBJbmRleCAhPSAwID8gbWFyZ2luLmF4aXMgLSAwLjUgKiBtYXJnaW4uaXRlbS52ZXJ0aWNhbCA6IDA7XG4gICAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS50b3AgPSBuZXdUb3AgKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS5ib3guc3R5bGUuYm90dG9tID0gJyc7XG4gICAgICB9XG4gICAgICAvLyBhbmQgd2hlbiB0aGUgb3JpZW50YXRpb24gaXMgYm90dG9tOlxuICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIG5ld1RvcCA9IHRoaXMucGFyZW50LnRvcDtcbiAgICAgICAgICB2YXIgdG90YWxIZWlnaHQgPSAwO1xuICAgICAgICAgIGZvciAodmFyIHN1Ymdyb3VwIGluIHN1Ymdyb3Vwcykge1xuICAgICAgICAgICAgaWYgKHN1Ymdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShzdWJncm91cCkpIHtcbiAgICAgICAgICAgICAgaWYgKHN1Ymdyb3Vwc1tzdWJncm91cF0udmlzaWJsZSA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0hlaWdodCA9IHN1Ymdyb3Vwc1tzdWJncm91cF0uaGVpZ2h0ICsgbWFyZ2luLml0ZW0udmVydGljYWw7XG4gICAgICAgICAgICAgICAgdG90YWxIZWlnaHQgKz0gbmV3SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChzdWJncm91cHNbc3ViZ3JvdXBdLmluZGV4ID4gc3ViZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgbmV3VG9wICs9IG5ld0hlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaGVpZ2h0ID0gdGhpcy5wYXJlbnQuc3ViZ3JvdXBzW2l0ZW1TdWJncm91cF0uaGVpZ2h0ICsgbWFyZ2luLml0ZW0udmVydGljYWw7XG4gICAgICAgICAgdGhpcy5kb20uYm94LnN0eWxlLnRvcCA9IHRoaXMucGFyZW50LmhlaWdodCAtIHRvdGFsSGVpZ2h0ICsgbmV3VG9wICsgJ3B4JztcbiAgICAgICAgICB0aGlzLmRvbS5ib3guc3R5bGUuYm90dG9tID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYW5kIGluIHRoZSBjYXNlIG9mIG5vIHN1Ymdyb3VwczpcbiAgICBlbHNlIHtcbiAgICAgICAgLy8gd2Ugd2FudCBiYWNrZ3JvdW5kcyB3aXRoIGdyb3VwcyB0byBvbmx5IHNob3cgaW4gZ3JvdXBzLlxuICAgICAgICBpZiAodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBCYWNrZ3JvdW5kR3JvdXApIHtcbiAgICAgICAgICAvLyBpZiB0aGUgaXRlbSBpcyBub3QgaW4gYSBncm91cDpcbiAgICAgICAgICBoZWlnaHQgPSBNYXRoLm1heCh0aGlzLnBhcmVudC5oZWlnaHQsIHRoaXMucGFyZW50Lml0ZW1TZXQuYm9keS5kb21Qcm9wcy5jZW50ZXIuaGVpZ2h0LCB0aGlzLnBhcmVudC5pdGVtU2V0LmJvZHkuZG9tUHJvcHMuY2VudGVyQ29udGFpbmVyLmhlaWdodCk7XG4gICAgICAgICAgdGhpcy5kb20uYm94LnN0eWxlLnRvcCA9IG9uVG9wID8gJzAnIDogJyc7XG4gICAgICAgICAgdGhpcy5kb20uYm94LnN0eWxlLmJvdHRvbSA9IG9uVG9wID8gJycgOiAnMCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGVpZ2h0ID0gdGhpcy5wYXJlbnQuaGVpZ2h0O1xuICAgICAgICAgIC8vIHNhbWUgYWxpZ25tZW50IGZvciBpdGVtcyB3aGVuIG9yaWVudGF0aW9uIGlzIHRvcCBvciBib3R0b21cbiAgICAgICAgICB0aGlzLmRvbS5ib3guc3R5bGUudG9wID0gdGhpcy5wYXJlbnQudG9wICsgJ3B4JztcbiAgICAgICAgICB0aGlzLmRvbS5ib3guc3R5bGUuYm90dG9tID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB0aGlzLmRvbS5ib3guc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IEJhY2tncm91bmRJdGVtO1xuXG4vKioqLyB9LFxuLyogNDYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuICB2YXIgQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG4gIHZhciBUaW1lU3RlcCA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuICB2YXIgRGF0ZVV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcbiAgdmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbiAgLyoqXG4gICAqIEEgaG9yaXpvbnRhbCB0aW1lIGF4aXNcbiAgICogQHBhcmFtIHt7ZG9tOiBPYmplY3QsIGRvbVByb3BzOiBPYmplY3QsIGVtaXR0ZXI6IEVtaXR0ZXIsIHJhbmdlOiBSYW5nZX19IGJvZHlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgU2VlIFRpbWVBeGlzLnNldE9wdGlvbnMgZm9yIHRoZSBhdmFpbGFibGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5cbiAgICogQGNvbnN0cnVjdG9yIFRpbWVBeGlzXG4gICAqIEBleHRlbmRzIENvbXBvbmVudFxuICAgKi9cbiAgZnVuY3Rpb24gVGltZUF4aXMoYm9keSwgb3B0aW9ucykge1xuICAgIHRoaXMuZG9tID0ge1xuICAgICAgZm9yZWdyb3VuZDogbnVsbCxcbiAgICAgIGxpbmVzOiBbXSxcbiAgICAgIG1ham9yVGV4dHM6IFtdLFxuICAgICAgbWlub3JUZXh0czogW10sXG4gICAgICByZWR1bmRhbnQ6IHtcbiAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICBtYWpvclRleHRzOiBbXSxcbiAgICAgICAgbWlub3JUZXh0czogW11cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucHJvcHMgPSB7XG4gICAgICByYW5nZToge1xuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgZW5kOiAwLFxuICAgICAgICBtaW5pbXVtU3RlcDogMFxuICAgICAgfSxcbiAgICAgIGxpbmVUb3A6IDBcbiAgICB9O1xuXG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIG9yaWVudGF0aW9uOiB7XG4gICAgICAgIGF4aXM6ICdib3R0b20nXG4gICAgICB9LCAvLyBheGlzIG9yaWVudGF0aW9uOiAndG9wJyBvciAnYm90dG9tJ1xuICAgICAgc2hvd01pbm9yTGFiZWxzOiB0cnVlLFxuICAgICAgc2hvd01ham9yTGFiZWxzOiB0cnVlLFxuICAgICAgbWF4TWlub3JDaGFyczogNyxcbiAgICAgIGZvcm1hdDogVGltZVN0ZXAuRk9STUFULFxuICAgICAgbW9tZW50OiBtb21lbnQsXG4gICAgICB0aW1lQXhpczogbnVsbFxuICAgIH07XG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcblxuICAgIC8vIGNyZWF0ZSB0aGUgSFRNTCBET01cbiAgICB0aGlzLl9jcmVhdGUoKTtcblxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIFRpbWVBeGlzLnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuICAvKipcbiAgICogU2V0IG9wdGlvbnMgZm9yIHRoZSBUaW1lQXhpcy5cbiAgICogUGFyYW1ldGVycyB3aWxsIGJlIG1lcmdlZCBpbiBjdXJyZW50IG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IFtvcmllbnRhdGlvbi5heGlzXVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAge2Jvb2xlYW59IFtzaG93TWlub3JMYWJlbHNdXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB7Ym9vbGVhbn0gW3Nob3dNYWpvckxhYmVsc11cbiAgICovXG4gIFRpbWVBeGlzLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgLy8gY29weSBhbGwgb3B0aW9ucyB0aGF0IHdlIGtub3dcbiAgICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKFsnc2hvd01pbm9yTGFiZWxzJywgJ3Nob3dNYWpvckxhYmVscycsICdtYXhNaW5vckNoYXJzJywgJ2hpZGRlbkRhdGVzJywgJ3RpbWVBeGlzJywgJ21vbWVudCcsICdydGwnXSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgLy8gZGVlcCBjb3B5IHRoZSBmb3JtYXQgb3B0aW9uc1xuICAgICAgdXRpbC5zZWxlY3RpdmVEZWVwRXh0ZW5kKFsnZm9ybWF0J10sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgIGlmICgnb3JpZW50YXRpb24nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm9yaWVudGF0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5heGlzID0gb3B0aW9ucy5vcmllbnRhdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKG9wdGlvbnMub3JpZW50YXRpb24pID09PSAnb2JqZWN0JyAmJiAnYXhpcycgaW4gb3B0aW9ucy5vcmllbnRhdGlvbikge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5heGlzID0gb3B0aW9ucy5vcmllbnRhdGlvbi5heGlzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IGxvY2FsZSB0byBtb21lbnQuanNcbiAgICAgIC8vIFRPRE86IG5vdCBzbyBuaWNlLCB0aGlzIGlzIGFwcGxpZWQgZ2xvYmFsbHkgdG8gbW9tZW50LmpzXG4gICAgICBpZiAoJ2xvY2FsZScgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG1vbWVudC5sb2NhbGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBtb21lbnQuanMgMi44LjErXG4gICAgICAgICAgbW9tZW50LmxvY2FsZShvcHRpb25zLmxvY2FsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9tZW50Lmxhbmcob3B0aW9ucy5sb2NhbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIEhUTUwgRE9NIGZvciB0aGUgVGltZUF4aXNcbiAgICovXG4gIFRpbWVBeGlzLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZG9tLmZvcmVncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS5iYWNrZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICB0aGlzLmRvbS5mb3JlZ3JvdW5kLmNsYXNzTmFtZSA9ICd2aXMtdGltZS1heGlzIHZpcy1mb3JlZ3JvdW5kJztcbiAgICB0aGlzLmRvbS5iYWNrZ3JvdW5kLmNsYXNzTmFtZSA9ICd2aXMtdGltZS1heGlzIHZpcy1iYWNrZ3JvdW5kJztcbiAgfTtcblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgVGltZUF4aXNcbiAgICovXG4gIFRpbWVBeGlzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHJlbW92ZSBmcm9tIERPTVxuICAgIGlmICh0aGlzLmRvbS5mb3JlZ3JvdW5kLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZG9tLmZvcmVncm91bmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5mb3JlZ3JvdW5kKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZG9tLmJhY2tncm91bmQucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5kb20uYmFja2dyb3VuZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmJhY2tncm91bmQpO1xuICAgIH1cblxuICAgIHRoaXMuYm9keSA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGFpbnQgdGhlIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZXNpemVkXG4gICAqL1xuICBUaW1lQXhpcy5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGZvcmVncm91bmQgPSB0aGlzLmRvbS5mb3JlZ3JvdW5kO1xuICAgIHZhciBiYWNrZ3JvdW5kID0gdGhpcy5kb20uYmFja2dyb3VuZDtcblxuICAgIC8vIGRldGVybWluZSB0aGUgY29ycmVjdCBwYXJlbnQgRE9NIGVsZW1lbnQgKGRlcGVuZGluZyBvbiBvcHRpb24gb3JpZW50YXRpb24pXG4gICAgdmFyIHBhcmVudCA9IHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5heGlzID09ICd0b3AnID8gdGhpcy5ib2R5LmRvbS50b3AgOiB0aGlzLmJvZHkuZG9tLmJvdHRvbTtcbiAgICB2YXIgcGFyZW50Q2hhbmdlZCA9IGZvcmVncm91bmQucGFyZW50Tm9kZSAhPT0gcGFyZW50O1xuXG4gICAgLy8gY2FsY3VsYXRlIGNoYXJhY3RlciB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgdGhpcy5fY2FsY3VsYXRlQ2hhclNpemUoKTtcblxuICAgIC8vIFRPRE86IHJlY2FsY3VsYXRlIHNpemVzIG9ubHkgbmVlZGVkIHdoZW4gcGFyZW50IGlzIHJlc2l6ZWQgb3Igb3B0aW9ucyBpcyBjaGFuZ2VkXG4gICAgdmFyIHNob3dNaW5vckxhYmVscyA9IHRoaXMub3B0aW9ucy5zaG93TWlub3JMYWJlbHMgJiYgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLmF4aXMgIT09ICdub25lJztcbiAgICB2YXIgc2hvd01ham9yTGFiZWxzID0gdGhpcy5vcHRpb25zLnNob3dNYWpvckxhYmVscyAmJiB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uYXhpcyAhPT0gJ25vbmUnO1xuXG4gICAgLy8gZGV0ZXJtaW5lIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBlbGVtZW5zIGZvciB0aGUgYXhpc1xuICAgIHByb3BzLm1pbm9yTGFiZWxIZWlnaHQgPSBzaG93TWlub3JMYWJlbHMgPyBwcm9wcy5taW5vckNoYXJIZWlnaHQgOiAwO1xuICAgIHByb3BzLm1ham9yTGFiZWxIZWlnaHQgPSBzaG93TWFqb3JMYWJlbHMgPyBwcm9wcy5tYWpvckNoYXJIZWlnaHQgOiAwO1xuICAgIHByb3BzLmhlaWdodCA9IHByb3BzLm1pbm9yTGFiZWxIZWlnaHQgKyBwcm9wcy5tYWpvckxhYmVsSGVpZ2h0O1xuICAgIHByb3BzLndpZHRoID0gZm9yZWdyb3VuZC5vZmZzZXRXaWR0aDtcblxuICAgIHByb3BzLm1pbm9yTGluZUhlaWdodCA9IHRoaXMuYm9keS5kb21Qcm9wcy5yb290LmhlaWdodCAtIHByb3BzLm1ham9yTGFiZWxIZWlnaHQgLSAodGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLmF4aXMgPT0gJ3RvcCcgPyB0aGlzLmJvZHkuZG9tUHJvcHMuYm90dG9tLmhlaWdodCA6IHRoaXMuYm9keS5kb21Qcm9wcy50b3AuaGVpZ2h0KTtcbiAgICBwcm9wcy5taW5vckxpbmVXaWR0aCA9IDE7IC8vIFRPRE86IHJlYWxseSBjYWxjdWxhdGUgd2lkdGhcbiAgICBwcm9wcy5tYWpvckxpbmVIZWlnaHQgPSBwcm9wcy5taW5vckxpbmVIZWlnaHQgKyBwcm9wcy5tYWpvckxhYmVsSGVpZ2h0O1xuICAgIHByb3BzLm1ham9yTGluZVdpZHRoID0gMTsgLy8gVE9ETzogcmVhbGx5IGNhbGN1bGF0ZSB3aWR0aFxuXG4gICAgLy8gIHRha2UgZm9yZWdyb3VuZCBhbmQgYmFja2dyb3VuZCBvZmZsaW5lIHdoaWxlIHVwZGF0aW5nIChpcyBhbG1vc3QgdHdpY2UgYXMgZmFzdClcbiAgICB2YXIgZm9yZWdyb3VuZE5leHRTaWJsaW5nID0gZm9yZWdyb3VuZC5uZXh0U2libGluZztcbiAgICB2YXIgYmFja2dyb3VuZE5leHRTaWJsaW5nID0gYmFja2dyb3VuZC5uZXh0U2libGluZztcbiAgICBmb3JlZ3JvdW5kLnBhcmVudE5vZGUgJiYgZm9yZWdyb3VuZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGZvcmVncm91bmQpO1xuICAgIGJhY2tncm91bmQucGFyZW50Tm9kZSAmJiBiYWNrZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYmFja2dyb3VuZCk7XG5cbiAgICBmb3JlZ3JvdW5kLnN0eWxlLmhlaWdodCA9IHRoaXMucHJvcHMuaGVpZ2h0ICsgJ3B4JztcblxuICAgIHRoaXMuX3JlcGFpbnRMYWJlbHMoKTtcblxuICAgIC8vIHB1dCBET00gb25saW5lIGFnYWluIChhdCB0aGUgc2FtZSBwbGFjZSlcbiAgICBpZiAoZm9yZWdyb3VuZE5leHRTaWJsaW5nKSB7XG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGZvcmVncm91bmQsIGZvcmVncm91bmROZXh0U2libGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChmb3JlZ3JvdW5kKTtcbiAgICB9XG4gICAgaWYgKGJhY2tncm91bmROZXh0U2libGluZykge1xuICAgICAgdGhpcy5ib2R5LmRvbS5iYWNrZ3JvdW5kVmVydGljYWwuaW5zZXJ0QmVmb3JlKGJhY2tncm91bmQsIGJhY2tncm91bmROZXh0U2libGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYm9keS5kb20uYmFja2dyb3VuZFZlcnRpY2FsLmFwcGVuZENoaWxkKGJhY2tncm91bmQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faXNSZXNpemVkKCkgfHwgcGFyZW50Q2hhbmdlZDtcbiAgfTtcblxuICAvKipcbiAgICogUmVwYWludCBtYWpvciBhbmQgbWlub3IgdGV4dCBsYWJlbHMgYW5kIHZlcnRpY2FsIGdyaWQgbGluZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRpbWVBeGlzLnByb3RvdHlwZS5fcmVwYWludExhYmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3JpZW50YXRpb24gPSB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uYXhpcztcblxuICAgIC8vIGNhbGN1bGF0ZSByYW5nZSBhbmQgc3RlcCAoc3RlcCBzdWNoIHRoYXQgd2UgaGF2ZSBzcGFjZSBmb3IgNyBjaGFyYWN0ZXJzIHBlciBsYWJlbClcbiAgICB2YXIgc3RhcnQgPSB1dGlsLmNvbnZlcnQodGhpcy5ib2R5LnJhbmdlLnN0YXJ0LCAnTnVtYmVyJyk7XG4gICAgdmFyIGVuZCA9IHV0aWwuY29udmVydCh0aGlzLmJvZHkucmFuZ2UuZW5kLCAnTnVtYmVyJyk7XG4gICAgdmFyIHRpbWVMYWJlbHNpemUgPSB0aGlzLmJvZHkudXRpbC50b1RpbWUoKHRoaXMucHJvcHMubWlub3JDaGFyV2lkdGggfHwgMTApICogdGhpcy5vcHRpb25zLm1heE1pbm9yQ2hhcnMpLnZhbHVlT2YoKTtcbiAgICB2YXIgbWluaW11bVN0ZXAgPSB0aW1lTGFiZWxzaXplIC0gRGF0ZVV0aWwuZ2V0SGlkZGVuRHVyYXRpb25CZWZvcmUodGhpcy5vcHRpb25zLm1vbWVudCwgdGhpcy5ib2R5LmhpZGRlbkRhdGVzLCB0aGlzLmJvZHkucmFuZ2UsIHRpbWVMYWJlbHNpemUpO1xuICAgIG1pbmltdW1TdGVwIC09IHRoaXMuYm9keS51dGlsLnRvVGltZSgwKS52YWx1ZU9mKCk7XG5cbiAgICB2YXIgc3RlcCA9IG5ldyBUaW1lU3RlcChuZXcgRGF0ZShzdGFydCksIG5ldyBEYXRlKGVuZCksIG1pbmltdW1TdGVwLCB0aGlzLmJvZHkuaGlkZGVuRGF0ZXMpO1xuICAgIHN0ZXAuc2V0TW9tZW50KHRoaXMub3B0aW9ucy5tb21lbnQpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZm9ybWF0KSB7XG4gICAgICBzdGVwLnNldEZvcm1hdCh0aGlzLm9wdGlvbnMuZm9ybWF0KTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy50aW1lQXhpcykge1xuICAgICAgc3RlcC5zZXRTY2FsZSh0aGlzLm9wdGlvbnMudGltZUF4aXMpO1xuICAgIH1cbiAgICB0aGlzLnN0ZXAgPSBzdGVwO1xuXG4gICAgLy8gTW92ZSBhbGwgRE9NIGVsZW1lbnRzIHRvIGEgXCJyZWR1bmRhbnRcIiBsaXN0LCB3aGVyZSB0aGV5XG4gICAgLy8gY2FuIGJlIHBpY2tlZCBmb3IgcmUtdXNlLCBhbmQgY2xlYXIgdGhlIGxpc3RzIHdpdGggbGluZXMgYW5kIHRleHRzLlxuICAgIC8vIEF0IHRoZSBlbmQgb2YgdGhlIGZ1bmN0aW9uIF9yZXBhaW50TGFiZWxzLCBsZWZ0IG92ZXIgZWxlbWVudHMgd2lsbCBiZSBjbGVhbmVkIHVwXG4gICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgIGRvbS5yZWR1bmRhbnQubGluZXMgPSBkb20ubGluZXM7XG4gICAgZG9tLnJlZHVuZGFudC5tYWpvclRleHRzID0gZG9tLm1ham9yVGV4dHM7XG4gICAgZG9tLnJlZHVuZGFudC5taW5vclRleHRzID0gZG9tLm1pbm9yVGV4dHM7XG4gICAgZG9tLmxpbmVzID0gW107XG4gICAgZG9tLm1ham9yVGV4dHMgPSBbXTtcbiAgICBkb20ubWlub3JUZXh0cyA9IFtdO1xuXG4gICAgdmFyIGN1cnJlbnQ7XG4gICAgdmFyIG5leHQ7XG4gICAgdmFyIHg7XG4gICAgdmFyIHhOZXh0O1xuICAgIHZhciBpc01ham9yLCBuZXh0SXNNYWpvcjtcbiAgICB2YXIgd2lkdGggPSAwLFxuICAgICAgICBwcmV2V2lkdGg7XG4gICAgdmFyIGxpbmU7XG4gICAgdmFyIGxhYmVsTWlub3I7XG4gICAgdmFyIHhGaXJzdE1ham9yTGFiZWwgPSB1bmRlZmluZWQ7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgTUFYID0gMTAwMDtcbiAgICB2YXIgY2xhc3NOYW1lO1xuXG4gICAgc3RlcC5zdGFydCgpO1xuICAgIG5leHQgPSBzdGVwLmdldEN1cnJlbnQoKTtcbiAgICB4TmV4dCA9IHRoaXMuYm9keS51dGlsLnRvU2NyZWVuKG5leHQpO1xuICAgIHdoaWxlIChzdGVwLmhhc05leHQoKSAmJiBjb3VudCA8IE1BWCkge1xuICAgICAgY291bnQrKztcblxuICAgICAgaXNNYWpvciA9IHN0ZXAuaXNNYWpvcigpO1xuICAgICAgY2xhc3NOYW1lID0gc3RlcC5nZXRDbGFzc05hbWUoKTtcbiAgICAgIGxhYmVsTWlub3IgPSBzdGVwLmdldExhYmVsTWlub3IoKTtcblxuICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICB4ID0geE5leHQ7XG5cbiAgICAgIHN0ZXAubmV4dCgpO1xuICAgICAgbmV4dCA9IHN0ZXAuZ2V0Q3VycmVudCgpO1xuICAgICAgbmV4dElzTWFqb3IgPSBzdGVwLmlzTWFqb3IoKTtcbiAgICAgIHhOZXh0ID0gdGhpcy5ib2R5LnV0aWwudG9TY3JlZW4obmV4dCk7XG5cbiAgICAgIHByZXZXaWR0aCA9IHdpZHRoO1xuICAgICAgd2lkdGggPSB4TmV4dCAtIHg7XG4gICAgICB2YXIgc2hvd01pbm9yR3JpZCA9IHdpZHRoID49IHByZXZXaWR0aCAqIDAuNDsgLy8gcHJldmVudCBkaXNwbGF5aW5nIG9mIHRoZSAzMXRoIG9mIHRoZSBtb250aCBvbiBhIHNjYWxlIG9mIDUgZGF5c1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNob3dNaW5vckxhYmVscyAmJiBzaG93TWlub3JHcmlkKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IHRoaXMuX3JlcGFpbnRNaW5vclRleHQoeCwgbGFiZWxNaW5vciwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSk7XG4gICAgICAgIGxhYmVsLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnOyAvLyBzZXQgd2lkdGggdG8gcHJldmVudCBvdmVyZmxvd1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNNYWpvciAmJiB0aGlzLm9wdGlvbnMuc2hvd01ham9yTGFiZWxzKSB7XG4gICAgICAgIGlmICh4ID4gMCkge1xuICAgICAgICAgIGlmICh4Rmlyc3RNYWpvckxhYmVsID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgeEZpcnN0TWFqb3JMYWJlbCA9IHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhYmVsID0gdGhpcy5fcmVwYWludE1ham9yVGV4dCh4LCBzdGVwLmdldExhYmVsTWFqb3IoKSwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGluZSA9IHRoaXMuX3JlcGFpbnRNYWpvckxpbmUoeCwgd2lkdGgsIG9yaWVudGF0aW9uLCBjbGFzc05hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbWlub3IgbGluZVxuICAgICAgICBpZiAoc2hvd01pbm9yR3JpZCkge1xuICAgICAgICAgIGxpbmUgPSB0aGlzLl9yZXBhaW50TWlub3JMaW5lKHgsIHdpZHRoLCBvcmllbnRhdGlvbiwgY2xhc3NOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgICAgLy8gYWRqdXN0IHRoZSB3aWR0aCBvZiB0aGUgcHJldmlvdXMgZ3JpZFxuICAgICAgICAgICAgbGluZS5zdHlsZS53aWR0aCA9IHBhcnNlSW50KGxpbmUuc3R5bGUud2lkdGgpICsgd2lkdGggKyAncHgnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb3VudCA9PT0gTUFYICYmICF3YXJuZWRGb3JPdmVyZmxvdykge1xuICAgICAgY29uc29sZS53YXJuKCdTb21ldGhpbmcgaXMgd3Jvbmcgd2l0aCB0aGUgVGltZWxpbmUgc2NhbGUuIExpbWl0ZWQgZHJhd2luZyBvZiBncmlkIGxpbmVzIHRvICcgKyBNQVggKyAnIGxpbmVzLicpO1xuICAgICAgd2FybmVkRm9yT3ZlcmZsb3cgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhIG1ham9yIGxhYmVsIG9uIHRoZSBsZWZ0IHdoZW4gbmVlZGVkXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaG93TWFqb3JMYWJlbHMpIHtcbiAgICAgIHZhciBsZWZ0VGltZSA9IHRoaXMuYm9keS51dGlsLnRvVGltZSgwKSxcbiAgICAgICAgICBsZWZ0VGV4dCA9IHN0ZXAuZ2V0TGFiZWxNYWpvcihsZWZ0VGltZSksXG4gICAgICAgICAgd2lkdGhUZXh0ID0gbGVmdFRleHQubGVuZ3RoICogKHRoaXMucHJvcHMubWFqb3JDaGFyV2lkdGggfHwgMTApICsgMTA7IC8vIHVwcGVyIGJvdW5kIGVzdGltYXRpb25cblxuICAgICAgaWYgKHhGaXJzdE1ham9yTGFiZWwgPT0gdW5kZWZpbmVkIHx8IHdpZHRoVGV4dCA8IHhGaXJzdE1ham9yTGFiZWwpIHtcbiAgICAgICAgdGhpcy5fcmVwYWludE1ham9yVGV4dCgwLCBsZWZ0VGV4dCwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2xlYW51cCBsZWZ0b3ZlciBET00gZWxlbWVudHMgZnJvbSB0aGUgcmVkdW5kYW50IGxpc3RcbiAgICB1dGlsLmZvckVhY2godGhpcy5kb20ucmVkdW5kYW50LCBmdW5jdGlvbiAoYXJyKSB7XG4gICAgICB3aGlsZSAoYXJyLmxlbmd0aCkge1xuICAgICAgICB2YXIgZWxlbSA9IGFyci5wb3AoKTtcbiAgICAgICAgaWYgKGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgZWxlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1pbm9yIGxhYmVsIGZvciB0aGUgYXhpcyBhdCBwb3NpdGlvbiB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcmllbnRhdGlvbiAgIFwidG9wXCIgb3IgXCJib3R0b21cIiAoZGVmYXVsdClcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgb2YgdGhlIGNyZWF0ZWQgbGFiZWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRpbWVBeGlzLnByb3RvdHlwZS5fcmVwYWludE1pbm9yVGV4dCA9IGZ1bmN0aW9uICh4LCB0ZXh0LCBvcmllbnRhdGlvbiwgY2xhc3NOYW1lKSB7XG4gICAgLy8gcmV1c2UgcmVkdW5kYW50IGxhYmVsXG4gICAgdmFyIGxhYmVsID0gdGhpcy5kb20ucmVkdW5kYW50Lm1pbm9yVGV4dHMuc2hpZnQoKTtcblxuICAgIGlmICghbGFiZWwpIHtcbiAgICAgIC8vIGNyZWF0ZSBuZXcgbGFiZWxcbiAgICAgIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgICAgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGxhYmVsLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgdGhpcy5kb20uZm9yZWdyb3VuZC5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgfVxuICAgIHRoaXMuZG9tLm1pbm9yVGV4dHMucHVzaChsYWJlbCk7XG5cbiAgICBsYWJlbC5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSA9IHRleHQ7XG5cbiAgICBsYWJlbC5zdHlsZS50b3AgPSBvcmllbnRhdGlvbiA9PSAndG9wJyA/IHRoaXMucHJvcHMubWFqb3JMYWJlbEhlaWdodCArICdweCcgOiAnMCc7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgbGFiZWwuc3R5bGUubGVmdCA9IFwiXCI7XG4gICAgICBsYWJlbC5zdHlsZS5yaWdodCA9IHggKyAncHgnO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYWJlbC5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgfTtcbiAgICBsYWJlbC5jbGFzc05hbWUgPSAndmlzLXRleHQgdmlzLW1pbm9yICcgKyBjbGFzc05hbWU7XG4gICAgLy9sYWJlbC50aXRsZSA9IHRpdGxlOyAgLy8gVE9ETzogdGhpcyBpcyBhIGhlYXZ5IG9wZXJhdGlvblxuXG4gICAgcmV0dXJuIGxhYmVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBNYWpvciBsYWJlbCBmb3IgdGhlIGF4aXMgYXQgcG9zaXRpb24geFxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZW50YXRpb24gICBcInRvcFwiIG9yIFwiYm90dG9tXCIgKGRlZmF1bHQpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7RWxlbWVudH0gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IG9mIHRoZSBjcmVhdGVkIGxhYmVsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBUaW1lQXhpcy5wcm90b3R5cGUuX3JlcGFpbnRNYWpvclRleHQgPSBmdW5jdGlvbiAoeCwgdGV4dCwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSkge1xuICAgIC8vIHJldXNlIHJlZHVuZGFudCBsYWJlbFxuICAgIHZhciBsYWJlbCA9IHRoaXMuZG9tLnJlZHVuZGFudC5tYWpvclRleHRzLnNoaWZ0KCk7XG5cbiAgICBpZiAoIWxhYmVsKSB7XG4gICAgICAvLyBjcmVhdGUgbGFiZWxcbiAgICAgIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgICBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgbGFiZWwuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICB0aGlzLmRvbS5mb3JlZ3JvdW5kLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICB9XG4gICAgdGhpcy5kb20ubWFqb3JUZXh0cy5wdXNoKGxhYmVsKTtcblxuICAgIGxhYmVsLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlID0gdGV4dDtcbiAgICBsYWJlbC5jbGFzc05hbWUgPSAndmlzLXRleHQgdmlzLW1ham9yICcgKyBjbGFzc05hbWU7XG4gICAgLy9sYWJlbC50aXRsZSA9IHRpdGxlOyAvLyBUT0RPOiB0aGlzIGlzIGEgaGVhdnkgb3BlcmF0aW9uXG5cbiAgICBsYWJlbC5zdHlsZS50b3AgPSBvcmllbnRhdGlvbiA9PSAndG9wJyA/ICcwJyA6IHRoaXMucHJvcHMubWlub3JMYWJlbEhlaWdodCArICdweCc7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgIGxhYmVsLnN0eWxlLmxlZnQgPSBcIlwiO1xuICAgICAgbGFiZWwuc3R5bGUucmlnaHQgPSB4ICsgJ3B4JztcbiAgICB9IGVsc2Uge1xuICAgICAgbGFiZWwuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgIH07XG5cbiAgICByZXR1cm4gbGFiZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1pbm9yIGxpbmUgZm9yIHRoZSBheGlzIGF0IHBvc2l0aW9uIHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcmllbnRhdGlvbiAgIFwidG9wXCIgb3IgXCJib3R0b21cIiAoZGVmYXVsdClcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBSZXR1cm5zIHRoZSBjcmVhdGVkIGxpbmVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRpbWVBeGlzLnByb3RvdHlwZS5fcmVwYWludE1pbm9yTGluZSA9IGZ1bmN0aW9uICh4LCB3aWR0aCwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSkge1xuICAgIC8vIHJldXNlIHJlZHVuZGFudCBsaW5lXG4gICAgdmFyIGxpbmUgPSB0aGlzLmRvbS5yZWR1bmRhbnQubGluZXMuc2hpZnQoKTtcbiAgICBpZiAoIWxpbmUpIHtcbiAgICAgIC8vIGNyZWF0ZSB2ZXJ0aWNhbCBsaW5lXG4gICAgICBsaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLmRvbS5iYWNrZ3JvdW5kLmFwcGVuZENoaWxkKGxpbmUpO1xuICAgIH1cbiAgICB0aGlzLmRvbS5saW5lcy5wdXNoKGxpbmUpO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBpZiAob3JpZW50YXRpb24gPT0gJ3RvcCcpIHtcbiAgICAgIGxpbmUuc3R5bGUudG9wID0gcHJvcHMubWFqb3JMYWJlbEhlaWdodCArICdweCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmUuc3R5bGUudG9wID0gdGhpcy5ib2R5LmRvbVByb3BzLnRvcC5oZWlnaHQgKyAncHgnO1xuICAgIH1cbiAgICBsaW5lLnN0eWxlLmhlaWdodCA9IHByb3BzLm1pbm9yTGluZUhlaWdodCArICdweCc7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgIGxpbmUuc3R5bGUubGVmdCA9IFwiXCI7XG4gICAgICBsaW5lLnN0eWxlLnJpZ2h0ID0geCAtIHByb3BzLm1pbm9yTGluZVdpZHRoIC8gMiArICdweCc7XG4gICAgICBsaW5lLmNsYXNzTmFtZSA9ICd2aXMtZ3JpZCB2aXMtdmVydGljYWwtcnRsIHZpcy1taW5vciAnICsgY2xhc3NOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lLnN0eWxlLmxlZnQgPSB4IC0gcHJvcHMubWlub3JMaW5lV2lkdGggLyAyICsgJ3B4JztcbiAgICAgIGxpbmUuY2xhc3NOYW1lID0gJ3Zpcy1ncmlkIHZpcy12ZXJ0aWNhbCB2aXMtbWlub3IgJyArIGNsYXNzTmFtZTtcbiAgICB9O1xuICAgIGxpbmUuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cbiAgICByZXR1cm4gbGluZTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgTWFqb3IgbGluZSBmb3IgdGhlIGF4aXMgYXQgcG9zaXRpb24geFxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWVudGF0aW9uICAgXCJ0b3BcIiBvciBcImJvdHRvbVwiIChkZWZhdWx0KVxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IFJldHVybnMgdGhlIGNyZWF0ZWQgbGluZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgVGltZUF4aXMucHJvdG90eXBlLl9yZXBhaW50TWFqb3JMaW5lID0gZnVuY3Rpb24gKHgsIHdpZHRoLCBvcmllbnRhdGlvbiwgY2xhc3NOYW1lKSB7XG4gICAgLy8gcmV1c2UgcmVkdW5kYW50IGxpbmVcbiAgICB2YXIgbGluZSA9IHRoaXMuZG9tLnJlZHVuZGFudC5saW5lcy5zaGlmdCgpO1xuICAgIGlmICghbGluZSkge1xuICAgICAgLy8gY3JlYXRlIHZlcnRpY2FsIGxpbmVcbiAgICAgIGxpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuZG9tLmJhY2tncm91bmQuYXBwZW5kQ2hpbGQobGluZSk7XG4gICAgfVxuICAgIHRoaXMuZG9tLmxpbmVzLnB1c2gobGluZSk7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGlmIChvcmllbnRhdGlvbiA9PSAndG9wJykge1xuICAgICAgbGluZS5zdHlsZS50b3AgPSAnMCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmUuc3R5bGUudG9wID0gdGhpcy5ib2R5LmRvbVByb3BzLnRvcC5oZWlnaHQgKyAncHgnO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICBsaW5lLnN0eWxlLmxlZnQgPSBcIlwiO1xuICAgICAgbGluZS5zdHlsZS5yaWdodCA9IHggLSBwcm9wcy5tYWpvckxpbmVXaWR0aCAvIDIgKyAncHgnO1xuICAgICAgbGluZS5jbGFzc05hbWUgPSAndmlzLWdyaWQgdmlzLXZlcnRpY2FsLXJ0bCB2aXMtbWFqb3IgJyArIGNsYXNzTmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZS5zdHlsZS5sZWZ0ID0geCAtIHByb3BzLm1ham9yTGluZVdpZHRoIC8gMiArICdweCc7XG4gICAgICBsaW5lLmNsYXNzTmFtZSA9ICd2aXMtZ3JpZCB2aXMtdmVydGljYWwgdmlzLW1ham9yICcgKyBjbGFzc05hbWU7XG4gICAgfVxuXG4gICAgbGluZS5zdHlsZS5oZWlnaHQgPSBwcm9wcy5tYWpvckxpbmVIZWlnaHQgKyAncHgnO1xuICAgIGxpbmUuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cbiAgICByZXR1cm4gbGluZTtcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRleHQgb24gdGhlIGF4aXMgKGJvdGggbWFqb3IgYW5kIG1pbm9yIGF4aXMpLlxuICAgKiBUaGUgc2l6ZSBpcyBjYWxjdWxhdGVkIG9ubHkgb25jZSBhbmQgdGhlbiBjYWNoZWQgaW4gdGhpcy5wcm9wcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRpbWVBeGlzLnByb3RvdHlwZS5fY2FsY3VsYXRlQ2hhclNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gTm90ZTogV2UgY2FsY3VsYXRlIGNoYXIgc2l6ZSB3aXRoIGV2ZXJ5IHJlZHJhdy4gU2l6ZSBtYXkgY2hhbmdlLCBmb3JcbiAgICAvLyBleGFtcGxlIHdoZW4gYW55IG9mIHRoZSB0aW1lbGluZXMgcGFyZW50cyBoYWQgZGlzcGxheTpub25lIGZvciBleGFtcGxlLlxuXG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBjaGFyIHdpZHRoIGFuZCBoZWlnaHQgb24gdGhlIG1pbm9yIGF4aXNcbiAgICBpZiAoIXRoaXMuZG9tLm1lYXN1cmVDaGFyTWlub3IpIHtcbiAgICAgIHRoaXMuZG9tLm1lYXN1cmVDaGFyTWlub3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgIHRoaXMuZG9tLm1lYXN1cmVDaGFyTWlub3IuY2xhc3NOYW1lID0gJ3Zpcy10ZXh0IHZpcy1taW5vciB2aXMtbWVhc3VyZSc7XG4gICAgICB0aGlzLmRvbS5tZWFzdXJlQ2hhck1pbm9yLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblxuICAgICAgdGhpcy5kb20ubWVhc3VyZUNoYXJNaW5vci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnMCcpKTtcbiAgICAgIHRoaXMuZG9tLmZvcmVncm91bmQuYXBwZW5kQ2hpbGQodGhpcy5kb20ubWVhc3VyZUNoYXJNaW5vcik7XG4gICAgfVxuICAgIHRoaXMucHJvcHMubWlub3JDaGFySGVpZ2h0ID0gdGhpcy5kb20ubWVhc3VyZUNoYXJNaW5vci5jbGllbnRIZWlnaHQ7XG4gICAgdGhpcy5wcm9wcy5taW5vckNoYXJXaWR0aCA9IHRoaXMuZG9tLm1lYXN1cmVDaGFyTWlub3IuY2xpZW50V2lkdGg7XG5cbiAgICAvLyBkZXRlcm1pbmUgdGhlIGNoYXIgd2lkdGggYW5kIGhlaWdodCBvbiB0aGUgbWFqb3IgYXhpc1xuICAgIGlmICghdGhpcy5kb20ubWVhc3VyZUNoYXJNYWpvcikge1xuICAgICAgdGhpcy5kb20ubWVhc3VyZUNoYXJNYWpvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgdGhpcy5kb20ubWVhc3VyZUNoYXJNYWpvci5jbGFzc05hbWUgPSAndmlzLXRleHQgdmlzLW1ham9yIHZpcy1tZWFzdXJlJztcbiAgICAgIHRoaXMuZG9tLm1lYXN1cmVDaGFyTWFqb3Iuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXG4gICAgICB0aGlzLmRvbS5tZWFzdXJlQ2hhck1ham9yLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcwJykpO1xuICAgICAgdGhpcy5kb20uZm9yZWdyb3VuZC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5tZWFzdXJlQ2hhck1ham9yKTtcbiAgICB9XG4gICAgdGhpcy5wcm9wcy5tYWpvckNoYXJIZWlnaHQgPSB0aGlzLmRvbS5tZWFzdXJlQ2hhck1ham9yLmNsaWVudEhlaWdodDtcbiAgICB0aGlzLnByb3BzLm1ham9yQ2hhcldpZHRoID0gdGhpcy5kb20ubWVhc3VyZUNoYXJNYWpvci5jbGllbnRXaWR0aDtcbiAgfTtcblxuICB2YXIgd2FybmVkRm9yT3ZlcmZsb3cgPSBmYWxzZTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFRpbWVBeGlzO1xuXG4vKioqLyB9LFxuLyogNDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIga2V5Y2hhcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcbiAgdmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbiAgdmFyIEhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgLyoqXG4gICAqIFR1cm4gYW4gZWxlbWVudCBpbnRvIGFuIGNsaWNrVG9Vc2UgZWxlbWVudC5cbiAgICogV2hlbiBub3QgYWN0aXZlLCB0aGUgZWxlbWVudCBoYXMgYSB0cmFuc3BhcmVudCBvdmVybGF5LiBXaGVuIHRoZSBvdmVybGF5IGlzXG4gICAqIGNsaWNrZWQsIHRoZSBtb2RlIGlzIGNoYW5nZWQgdG8gYWN0aXZlLlxuICAgKiBXaGVuIGFjdGl2ZSwgdGhlIGVsZW1lbnQgaXMgZGlzcGxheWVkIHdpdGggYSBibHVlIGJvcmRlciBhcm91bmQgaXQsIGFuZFxuICAgKiB0aGUgaW50ZXJhY3RpdmUgY29udGVudHMgb2YgdGhlIGVsZW1lbnQgY2FuIGJlIHVzZWQuIFdoZW4gY2xpY2tlZCBvdXRzaWRlXG4gICAqIHRoZSBlbGVtZW50LCB0aGUgZWxlbWVudHMgbW9kZSBpcyBjaGFuZ2VkIHRvIGluYWN0aXZlLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lclxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIEFjdGl2YXRvcihjb250YWluZXIpIHtcbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5kb20gPSB7XG4gICAgICBjb250YWluZXI6IGNvbnRhaW5lclxuICAgIH07XG5cbiAgICB0aGlzLmRvbS5vdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20ub3ZlcmxheS5jbGFzc05hbWUgPSAndmlzLW92ZXJsYXknO1xuXG4gICAgdGhpcy5kb20uY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLm92ZXJsYXkpO1xuXG4gICAgdGhpcy5oYW1tZXIgPSBIYW1tZXIodGhpcy5kb20ub3ZlcmxheSk7XG4gICAgdGhpcy5oYW1tZXIub24oJ3RhcCcsIHRoaXMuX29uVGFwT3ZlcmxheS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIGJsb2NrIGFsbCB0b3VjaCBldmVudHMgKGV4Y2VwdCB0YXApXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgZXZlbnRzID0gWyd0YXAnLCAnZG91YmxldGFwJywgJ3ByZXNzJywgJ3BpbmNoJywgJ3BhbicsICdwYW5zdGFydCcsICdwYW5tb3ZlJywgJ3BhbmVuZCddO1xuICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgbWUuaGFtbWVyLm9uKGV2ZW50LCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIGF0dGFjaCBhIGNsaWNrIGV2ZW50IHRvIHRoZSB3aW5kb3csIGluIG9yZGVyIHRvIGRlYWN0aXZhdGUgd2hlbiBjbGlja2luZyBvdXRzaWRlIHRoZSB0aW1lbGluZVxuICAgIGlmIChkb2N1bWVudCAmJiBkb2N1bWVudC5ib2R5KSB7XG4gICAgICB0aGlzLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFfaGFzUGFyZW50KGV2ZW50LnRhcmdldCwgY29udGFpbmVyKSkge1xuICAgICAgICAgIG1lLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmtleWNoYXJtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMua2V5Y2hhcm0uZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmtleWNoYXJtID0ga2V5Y2hhcm0oKTtcblxuICAgIC8vIGtleWNoYXJtIGxpc3RlbmVyIG9ubHkgYm91bmRlZCB3aGVuIGFjdGl2ZSlcbiAgICB0aGlzLmVzY0xpc3RlbmVyID0gdGhpcy5kZWFjdGl2YXRlLmJpbmQodGhpcyk7XG4gIH1cblxuICAvLyB0dXJuIGludG8gYW4gZXZlbnQgZW1pdHRlclxuICBFbWl0dGVyKEFjdGl2YXRvci5wcm90b3R5cGUpO1xuXG4gIC8vIFRoZSBjdXJyZW50bHkgYWN0aXZlIGFjdGl2YXRvclxuICBBY3RpdmF0b3IuY3VycmVudCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIGFjdGl2YXRvci4gQ2xlYW5zIHVwIGFsbCBjcmVhdGVkIERPTSBhbmQgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuICBBY3RpdmF0b3IucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZWFjdGl2YXRlKCk7XG5cbiAgICAvLyByZW1vdmUgZG9tXG4gICAgdGhpcy5kb20ub3ZlcmxheS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLm92ZXJsYXkpO1xuXG4gICAgLy8gcmVtb3ZlIGdsb2JhbCBldmVudCBsaXN0ZW5lclxuICAgIGlmICh0aGlzLm9uQ2xpY2spIHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xuICAgIH1cblxuICAgIC8vIGNsZWFudXAgaGFtbWVyIGluc3RhbmNlc1xuICAgIHRoaXMuaGFtbWVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmhhbW1lciA9IG51bGw7XG4gICAgLy8gRklYTUU6IGNsZWFuaW5nIHVwIGhhbW1lciBpbnN0YW5jZXMgZG9lc24ndCB3b3JrIChUaW1lbGluZSBub3QgcmVtb3ZlZCBmcm9tIG1lbW9yeSlcbiAgfTtcblxuICAvKipcbiAgICogQWN0aXZhdGUgdGhlIGVsZW1lbnRcbiAgICogT3ZlcmxheSBpcyBoaWRkZW4sIGVsZW1lbnQgaXMgZGVjb3JhdGVkIHdpdGggYSBibHVlIHNoYWRvdyBib3JkZXJcbiAgICovXG4gIEFjdGl2YXRvci5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gd2UgYWxsb3cgb25seSBvbmUgYWN0aXZlIGFjdGl2YXRvciBhdCBhIHRpbWVcbiAgICBpZiAoQWN0aXZhdG9yLmN1cnJlbnQpIHtcbiAgICAgIEFjdGl2YXRvci5jdXJyZW50LmRlYWN0aXZhdGUoKTtcbiAgICB9XG4gICAgQWN0aXZhdG9yLmN1cnJlbnQgPSB0aGlzO1xuXG4gICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuZG9tLm92ZXJsYXkuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB1dGlsLmFkZENsYXNzTmFtZSh0aGlzLmRvbS5jb250YWluZXIsICd2aXMtYWN0aXZlJyk7XG5cbiAgICB0aGlzLmVtaXQoJ2NoYW5nZScpO1xuICAgIHRoaXMuZW1pdCgnYWN0aXZhdGUnKTtcblxuICAgIC8vIHVnbHkgaGFjazogYmluZCBFU0MgYWZ0ZXIgZW1pdHRpbmcgdGhlIGV2ZW50cywgYXMgdGhlIE5ldHdvcmsgcmViaW5kcyBhbGxcbiAgICAvLyBrZXlib2FyZCBldmVudHMgb24gYSAnY2hhbmdlJyBldmVudFxuICAgIHRoaXMua2V5Y2hhcm0uYmluZCgnZXNjJywgdGhpcy5lc2NMaXN0ZW5lcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlYWN0aXZhdGUgdGhlIGVsZW1lbnRcbiAgICogT3ZlcmxheSBpcyBkaXNwbGF5ZWQgb24gdG9wIG9mIHRoZSBlbGVtZW50XG4gICAqL1xuICBBY3RpdmF0b3IucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmRvbS5vdmVybGF5LnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZSh0aGlzLmRvbS5jb250YWluZXIsICd2aXMtYWN0aXZlJyk7XG4gICAgdGhpcy5rZXljaGFybS51bmJpbmQoJ2VzYycsIHRoaXMuZXNjTGlzdGVuZXIpO1xuXG4gICAgdGhpcy5lbWl0KCdjaGFuZ2UnKTtcbiAgICB0aGlzLmVtaXQoJ2RlYWN0aXZhdGUnKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGEgdGFwIGV2ZW50OiBhY3RpdmF0ZSB0aGUgY29udGFpbmVyXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQWN0aXZhdG9yLnByb3RvdHlwZS5fb25UYXBPdmVybGF5ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYWN0aXZhdGUgdGhlIGNvbnRhaW5lclxuICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfTtcblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIHRoZSBlbGVtZW50IGhhcyB0aGUgcmVxdWVzdGVkIHBhcmVudCBlbGVtZW50IHNvbWV3aGVyZSBpblxuICAgKiBpdHMgY2hhaW4gb2YgcGFyZW50IG5vZGVzLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIHdoZW4gdGhlIHBhcmVudCBpcyBmb3VuZCBzb21ld2hlcmUgaW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICBjaGFpbiBvZiBwYXJlbnQgbm9kZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfaGFzUGFyZW50KGVsZW1lbnQsIHBhcmVudCkge1xuICAgIHdoaWxlIChlbGVtZW50KSB7XG4gICAgICBpZiAoZWxlbWVudCA9PT0gcGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBBY3RpdmF0b3I7XG5cbi8qKiovIH0sXG4vKiA0OCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBIYW1tZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuICB2YXIgQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG4gIHZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuICB2YXIgbG9jYWxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpO1xuXG4gIC8qKlxuICAgKiBBIGN1c3RvbSB0aW1lIGJhclxuICAgKiBAcGFyYW0ge3tyYW5nZTogUmFuZ2UsIGRvbTogT2JqZWN0fX0gYm9keVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBBdmFpbGFibGUgcGFyYW1ldGVyczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlciB8IHN0cmluZ30gaWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gbG9jYWxlc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBsb2NhbGVcbiAgICogQGNvbnN0cnVjdG9yIEN1c3RvbVRpbWVcbiAgICogQGV4dGVuZHMgQ29tcG9uZW50XG4gICAqL1xuXG4gIGZ1bmN0aW9uIEN1c3RvbVRpbWUoYm9keSwgb3B0aW9ucykge1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cbiAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgbW9tZW50OiBtb21lbnQsXG4gICAgICBsb2NhbGVzOiBsb2NhbGVzLFxuICAgICAgbG9jYWxlOiAnZW4nLFxuICAgICAgaWQ6IHVuZGVmaW5lZCxcbiAgICAgIHRpdGxlOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudGltZSkge1xuICAgICAgdGhpcy5jdXN0b21UaW1lID0gb3B0aW9ucy50aW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN1c3RvbVRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgIH1cblxuICAgIHRoaXMuZXZlbnRQYXJhbXMgPSB7fTsgLy8gc3RvcmVzIHN0YXRlIHBhcmFtZXRlcnMgd2hpbGUgZHJhZ2dpbmcgdGhlIGJhclxuXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBET01cbiAgICB0aGlzLl9jcmVhdGUoKTtcbiAgfVxuXG4gIEN1c3RvbVRpbWUucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG4gIC8qKlxuICAgKiBTZXQgb3B0aW9ucyBmb3IgdGhlIGNvbXBvbmVudC4gT3B0aW9ucyB3aWxsIGJlIG1lcmdlZCBpbiBjdXJyZW50IG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICBBdmFpbGFibGUgcGFyYW1ldGVyczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlciB8IHN0cmluZ30gaWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gbG9jYWxlc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBsb2NhbGVcbiAgICovXG4gIEN1c3RvbVRpbWUucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAvLyBjb3B5IGFsbCBvcHRpb25zIHRoYXQgd2Uga25vd1xuICAgICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoWydtb21lbnQnLCAnbG9jYWxlJywgJ2xvY2FsZXMnLCAnaWQnXSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgRE9NIGZvciB0aGUgY3VzdG9tIHRpbWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEN1c3RvbVRpbWUucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGJhclsnY3VzdG9tLXRpbWUnXSA9IHRoaXM7XG4gICAgYmFyLmNsYXNzTmFtZSA9ICd2aXMtY3VzdG9tLXRpbWUgJyArICh0aGlzLm9wdGlvbnMuaWQgfHwgJycpO1xuICAgIGJhci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgYmFyLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgIGJhci5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgdGhpcy5iYXIgPSBiYXI7XG5cbiAgICB2YXIgZHJhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRyYWcuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIGRyYWcuc3R5bGUudG9wID0gJzBweCc7XG4gICAgZHJhZy5zdHlsZS5sZWZ0ID0gJy0xMHB4JztcbiAgICBkcmFnLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICBkcmFnLnN0eWxlLndpZHRoID0gJzIwcHgnO1xuICAgIGJhci5hcHBlbmRDaGlsZChkcmFnKTtcblxuICAgIC8vIGF0dGFjaCBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLmhhbW1lciA9IG5ldyBIYW1tZXIoZHJhZyk7XG4gICAgdGhpcy5oYW1tZXIub24oJ3BhbnN0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5oYW1tZXIub24oJ3Bhbm1vdmUnLCB0aGlzLl9vbkRyYWcuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5oYW1tZXIub24oJ3BhbmVuZCcsIHRoaXMuX29uRHJhZ0VuZC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmhhbW1lci5nZXQoJ3BhbicpLnNldCh7IHRocmVzaG9sZDogNSwgZGlyZWN0aW9uOiBIYW1tZXIuRElSRUNUSU9OX0hPUklaT05UQUwgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIEN1c3RvbVRpbWUgYmFyXG4gICAqL1xuICBDdXN0b21UaW1lLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaGlkZSgpO1xuXG4gICAgdGhpcy5oYW1tZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuaGFtbWVyID0gbnVsbDtcblxuICAgIHRoaXMuYm9keSA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGFpbnQgdGhlIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZXNpemVkXG4gICAqL1xuICBDdXN0b21UaW1lLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuYm9keS5kb20uYmFja2dyb3VuZFZlcnRpY2FsO1xuICAgIGlmICh0aGlzLmJhci5wYXJlbnROb2RlICE9IHBhcmVudCkge1xuICAgICAgLy8gYXR0YWNoIHRvIHRoZSBkb21cbiAgICAgIGlmICh0aGlzLmJhci5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMuYmFyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5iYXIpO1xuICAgICAgfVxuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMuYmFyKTtcbiAgICB9XG5cbiAgICB2YXIgeCA9IHRoaXMuYm9keS51dGlsLnRvU2NyZWVuKHRoaXMuY3VzdG9tVGltZSk7XG5cbiAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gICAgaWYgKCFsb2NhbGUpIHtcbiAgICAgIGlmICghdGhpcy53YXJuZWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IG9wdGlvbnMubG9jYWxlc1tcXCcnICsgdGhpcy5vcHRpb25zLmxvY2FsZSArICdcXCddIG5vdCBmb3VuZC4gU2VlIGh0dHA6Ly92aXNqcy5vcmcvZG9jcy90aW1lbGluZS8jTG9jYWxpemF0aW9uJyk7XG4gICAgICAgIHRoaXMud2FybmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddOyAvLyBmYWxsIGJhY2sgb24gZW5nbGlzaCB3aGVuIG5vdCBhdmFpbGFibGVcbiAgICB9XG5cbiAgICB2YXIgdGl0bGUgPSB0aGlzLm9wdGlvbnMudGl0bGU7XG4gICAgLy8gVG8gaGlkZSB0aGUgdGl0bGUgY29tcGxldGVseSB1c2UgZW1wdHkgc3RyaW5nICcnLlxuICAgIGlmICh0aXRsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aXRsZSA9IGxvY2FsZS50aW1lICsgJzogJyArIHRoaXMub3B0aW9ucy5tb21lbnQodGhpcy5jdXN0b21UaW1lKS5mb3JtYXQoJ2RkZGQsIE1NTU0gRG8gWVlZWSwgSDptbTpzcycpO1xuICAgICAgdGl0bGUgPSB0aXRsZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRpdGxlLnN1YnN0cmluZygxKTtcbiAgICB9XG5cbiAgICB0aGlzLmJhci5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgdGhpcy5iYXIudGl0bGUgPSB0aXRsZTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBDdXN0b21UaW1lIGZyb20gdGhlIERPTVxuICAgKi9cbiAgQ3VzdG9tVGltZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyByZW1vdmUgdGhlIGxpbmUgZnJvbSB0aGUgRE9NXG4gICAgaWYgKHRoaXMuYmFyLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuYmFyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5iYXIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IGN1c3RvbSB0aW1lLlxuICAgKiBAcGFyYW0ge0RhdGUgfCBudW1iZXIgfCBzdHJpbmd9IHRpbWVcbiAgICovXG4gIEN1c3RvbVRpbWUucHJvdG90eXBlLnNldEN1c3RvbVRpbWUgPSBmdW5jdGlvbiAodGltZSkge1xuICAgIHRoaXMuY3VzdG9tVGltZSA9IHV0aWwuY29udmVydCh0aW1lLCAnRGF0ZScpO1xuICAgIHRoaXMucmVkcmF3KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGN1c3RvbSB0aW1lLlxuICAgKiBAcmV0dXJuIHtEYXRlfSBjdXN0b21UaW1lXG4gICAqL1xuICBDdXN0b21UaW1lLnByb3RvdHlwZS5nZXRDdXN0b21UaW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLmN1c3RvbVRpbWUudmFsdWVPZigpKTtcbiAgfTtcblxuICAvKipcbiAgICAqIFNldCBjdXN0b20gdGl0bGUuXG4gICAgKiBAcGFyYW0ge0RhdGUgfCBudW1iZXIgfCBzdHJpbmd9IHRpdGxlXG4gICAgKi9cbiAgQ3VzdG9tVGltZS5wcm90b3R5cGUuc2V0Q3VzdG9tVGl0bGUgPSBmdW5jdGlvbiAodGl0bGUpIHtcbiAgICB0aGlzLm9wdGlvbnMudGl0bGUgPSB0aXRsZTtcbiAgfTtcblxuICAvKipcbiAgICogU3RhcnQgbW92aW5nIGhvcml6b250YWxseVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ3VzdG9tVGltZS5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy5ldmVudFBhcmFtcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgdGhpcy5ldmVudFBhcmFtcy5jdXN0b21UaW1lID0gdGhpcy5jdXN0b21UaW1lO1xuXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gbW92aW5nIG9wZXJhdGluZy5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEN1c3RvbVRpbWUucHJvdG90eXBlLl9vbkRyYWcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRQYXJhbXMuZHJhZ2dpbmcpIHJldHVybjtcblxuICAgIHZhciB4ID0gdGhpcy5ib2R5LnV0aWwudG9TY3JlZW4odGhpcy5ldmVudFBhcmFtcy5jdXN0b21UaW1lKSArIGV2ZW50LmRlbHRhWDtcbiAgICB2YXIgdGltZSA9IHRoaXMuYm9keS51dGlsLnRvVGltZSh4KTtcblxuICAgIHRoaXMuc2V0Q3VzdG9tVGltZSh0aW1lKTtcblxuICAgIC8vIGZpcmUgYSB0aW1lY2hhbmdlIGV2ZW50XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgndGltZWNoYW5nZScsIHtcbiAgICAgIGlkOiB0aGlzLm9wdGlvbnMuaWQsXG4gICAgICB0aW1lOiBuZXcgRGF0ZSh0aGlzLmN1c3RvbVRpbWUudmFsdWVPZigpKVxuICAgIH0pO1xuXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3AgbW92aW5nIG9wZXJhdGluZy5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEN1c3RvbVRpbWUucHJvdG90eXBlLl9vbkRyYWdFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRQYXJhbXMuZHJhZ2dpbmcpIHJldHVybjtcblxuICAgIC8vIGZpcmUgYSB0aW1lY2hhbmdlZCBldmVudFxuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3RpbWVjaGFuZ2VkJywge1xuICAgICAgaWQ6IHRoaXMub3B0aW9ucy5pZCxcbiAgICAgIHRpbWU6IG5ldyBEYXRlKHRoaXMuY3VzdG9tVGltZS52YWx1ZU9mKCkpXG4gICAgfSk7XG5cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfTtcblxuICAvKipcbiAgICogRmluZCBhIGN1c3RvbSB0aW1lIGZyb20gYW4gZXZlbnQgdGFyZ2V0OlxuICAgKiBzZWFyY2hlcyBmb3IgdGhlIGF0dHJpYnV0ZSAnY3VzdG9tLXRpbWUnIGluIHRoZSBldmVudCB0YXJnZXQncyBlbGVtZW50IHRyZWVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHJldHVybiB7Q3VzdG9tVGltZSB8IG51bGx9IGN1c3RvbVRpbWVcbiAgICovXG4gIEN1c3RvbVRpbWUuY3VzdG9tVGltZUZyb21UYXJnZXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIHdoaWxlICh0YXJnZXQpIHtcbiAgICAgIGlmICh0YXJnZXQuaGFzT3duUHJvcGVydHkoJ2N1c3RvbS10aW1lJykpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldFsnY3VzdG9tLXRpbWUnXTtcbiAgICAgIH1cbiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gQ3VzdG9tVGltZTtcblxuLyoqKi8gfSxcbi8qIDQ5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gRW5nbGlzaFxuICBleHBvcnRzWydlbiddID0ge1xuICAgIGN1cnJlbnQ6ICdjdXJyZW50JyxcbiAgICB0aW1lOiAndGltZSdcbiAgfTtcbiAgZXhwb3J0c1snZW5fRU4nXSA9IGV4cG9ydHNbJ2VuJ107XG4gIGV4cG9ydHNbJ2VuX1VTJ10gPSBleHBvcnRzWydlbiddO1xuXG4gIC8vIEl0YWxpYW5vXG4gIGV4cG9ydHNbJ2l0J10gPSB7XG4gICAgY3VycmVudDogJ2F0dHVhbGUnLFxuICAgIHRpbWU6ICd0ZW1wbydcbiAgfTtcbiAgZXhwb3J0c1snaXRfSVQnXSA9IGV4cG9ydHNbJ2l0J107XG4gIGV4cG9ydHNbJ2l0X0NIJ10gPSBleHBvcnRzWydpdCddO1xuXG4gIC8vIER1dGNoXG4gIGV4cG9ydHNbJ25sJ10gPSB7XG4gICAgY3VycmVudDogJ2h1aWRpZ2UnLFxuICAgIHRpbWU6ICd0aWpkJ1xuICB9O1xuICBleHBvcnRzWydubF9OTCddID0gZXhwb3J0c1snbmwnXTtcbiAgZXhwb3J0c1snbmxfQkUnXSA9IGV4cG9ydHNbJ25sJ107XG5cbiAgLy8gR2VybWFuXG4gIGV4cG9ydHNbJ2RlJ10gPSB7XG4gICAgY3VycmVudDogJ0FrdHVlbGxlJyxcbiAgICB0aW1lOiAnWmVpdCdcbiAgfTtcbiAgZXhwb3J0c1snZGVfREUnXSA9IGV4cG9ydHNbJ2RlJ107XG5cbi8qKiovIH0sXG4vKiA1MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xuICB2YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbiAgdmFyIGxvY2FsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KTtcblxuICAvKipcbiAgICogQSBjdXJyZW50IHRpbWUgYmFyXG4gICAqIEBwYXJhbSB7e3JhbmdlOiBSYW5nZSwgZG9tOiBPYmplY3QsIGRvbVByb3BzOiBPYmplY3R9fSBib2R5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgIEF2YWlsYWJsZSBwYXJhbWV0ZXJzOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gW3Nob3dDdXJyZW50VGltZV1cbiAgICogQGNvbnN0cnVjdG9yIEN1cnJlbnRUaW1lXG4gICAqIEBleHRlbmRzIENvbXBvbmVudFxuICAgKi9cbiAgZnVuY3Rpb24gQ3VycmVudFRpbWUoYm9keSwgb3B0aW9ucykge1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cbiAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgcnRsOiBmYWxzZSxcbiAgICAgIHNob3dDdXJyZW50VGltZTogdHJ1ZSxcblxuICAgICAgbW9tZW50OiBtb21lbnQsXG4gICAgICBsb2NhbGVzOiBsb2NhbGVzLFxuICAgICAgbG9jYWxlOiAnZW4nXG4gICAgfTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgdGhpcy5vZmZzZXQgPSAwO1xuXG4gICAgdGhpcy5fY3JlYXRlKCk7XG5cbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICBDdXJyZW50VGltZS5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgSFRNTCBET00gZm9yIHRoZSBjdXJyZW50IHRpbWUgYmFyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDdXJyZW50VGltZS5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYmFyLmNsYXNzTmFtZSA9ICd2aXMtY3VycmVudC10aW1lJztcbiAgICBiYXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGJhci5zdHlsZS50b3AgPSAnMHB4JztcbiAgICBiYXIuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXG4gICAgdGhpcy5iYXIgPSBiYXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIEN1cnJlbnRUaW1lIGJhclxuICAgKi9cbiAgQ3VycmVudFRpbWUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5vcHRpb25zLnNob3dDdXJyZW50VGltZSA9IGZhbHNlO1xuICAgIHRoaXMucmVkcmF3KCk7IC8vIHdpbGwgcmVtb3ZlIHRoZSBiYXIgZnJvbSB0aGUgRE9NIGFuZCBzdG9wIHJlZnJlc2hpbmdcblxuICAgIHRoaXMuYm9keSA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBvcHRpb25zIGZvciB0aGUgY29tcG9uZW50LiBPcHRpb25zIHdpbGwgYmUgbWVyZ2VkIGluIGN1cnJlbnQgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgIEF2YWlsYWJsZSBwYXJhbWV0ZXJzOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAge2Jvb2xlYW59IFtzaG93Q3VycmVudFRpbWVdXG4gICAqL1xuICBDdXJyZW50VGltZS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIC8vIGNvcHkgYWxsIG9wdGlvbnMgdGhhdCB3ZSBrbm93XG4gICAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChbJ3J0bCcsICdzaG93Q3VycmVudFRpbWUnLCAnbW9tZW50JywgJ2xvY2FsZScsICdsb2NhbGVzJ10sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBhaW50IHRoZSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBjb21wb25lbnQgaXMgcmVzaXplZFxuICAgKi9cbiAgQ3VycmVudFRpbWUucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNob3dDdXJyZW50VGltZSkge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuYm9keS5kb20uYmFja2dyb3VuZFZlcnRpY2FsO1xuICAgICAgaWYgKHRoaXMuYmFyLnBhcmVudE5vZGUgIT0gcGFyZW50KSB7XG4gICAgICAgIC8vIGF0dGFjaCB0byB0aGUgZG9tXG4gICAgICAgIGlmICh0aGlzLmJhci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgdGhpcy5iYXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmJhcik7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMuYmFyKTtcblxuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBub3cgPSB0aGlzLm9wdGlvbnMubW9tZW50KG5ldyBEYXRlKCkudmFsdWVPZigpICsgdGhpcy5vZmZzZXQpO1xuICAgICAgdmFyIHggPSB0aGlzLmJvZHkudXRpbC50b1NjcmVlbihub3cpO1xuXG4gICAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gICAgICBpZiAoIWxvY2FsZSkge1xuICAgICAgICBpZiAoIXRoaXMud2FybmVkKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IG9wdGlvbnMubG9jYWxlc1tcXCcnICsgdGhpcy5vcHRpb25zLmxvY2FsZSArICdcXCddIG5vdCBmb3VuZC4gU2VlIGh0dHA6Ly92aXNqcy5vcmcvZG9jcy90aW1lbGluZS8jTG9jYWxpemF0aW9uJyk7XG4gICAgICAgICAgdGhpcy53YXJuZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddOyAvLyBmYWxsIGJhY2sgb24gZW5nbGlzaCB3aGVuIG5vdCBhdmFpbGFibGVcbiAgICAgIH1cbiAgICAgIHZhciB0aXRsZSA9IGxvY2FsZS5jdXJyZW50ICsgJyAnICsgbG9jYWxlLnRpbWUgKyAnOiAnICsgbm93LmZvcm1hdCgnZGRkZCwgTU1NTSBEbyBZWVlZLCBIOm1tOnNzJyk7XG4gICAgICB0aXRsZSA9IHRpdGxlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGl0bGUuc3Vic3RyaW5nKDEpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICB0aGlzLmJhci5zdHlsZS5yaWdodCA9IHggKyAncHgnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iYXIuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgICAgfVxuICAgICAgdGhpcy5iYXIudGl0bGUgPSB0aXRsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVtb3ZlIHRoZSBsaW5lIGZyb20gdGhlIERPTVxuICAgICAgaWYgKHRoaXMuYmFyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5iYXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmJhcik7XG4gICAgICB9XG4gICAgICB0aGlzLnN0b3AoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGF1dG8gcmVmcmVzaGluZyB0aGUgY3VycmVudCB0aW1lIGJhclxuICAgKi9cbiAgQ3VycmVudFRpbWUucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICBtZS5zdG9wKCk7XG5cbiAgICAgIC8vIGRldGVybWluZSBpbnRlcnZhbCB0byByZWZyZXNoXG4gICAgICB2YXIgc2NhbGUgPSBtZS5ib2R5LnJhbmdlLmNvbnZlcnNpb24obWUuYm9keS5kb21Qcm9wcy5jZW50ZXIud2lkdGgpLnNjYWxlO1xuICAgICAgdmFyIGludGVydmFsID0gMSAvIHNjYWxlIC8gMTA7XG4gICAgICBpZiAoaW50ZXJ2YWwgPCAzMCkgaW50ZXJ2YWwgPSAzMDtcbiAgICAgIGlmIChpbnRlcnZhbCA+IDEwMDApIGludGVydmFsID0gMTAwMDtcblxuICAgICAgbWUucmVkcmF3KCk7XG4gICAgICBtZS5ib2R5LmVtaXR0ZXIuZW1pdCgnY3VycmVudFRpbWVUaWNrJyk7XG5cbiAgICAgIC8vIHN0YXJ0IGEgcmVuZGVyVGltZXIgdG8gYWRqdXN0IGZvciB0aGUgbmV3IHRpbWVcbiAgICAgIG1lLmN1cnJlbnRUaW1lVGltZXIgPSBzZXRUaW1lb3V0KHVwZGF0ZSwgaW50ZXJ2YWwpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9wIGF1dG8gcmVmcmVzaGluZyB0aGUgY3VycmVudCB0aW1lIGJhclxuICAgKi9cbiAgQ3VycmVudFRpbWUucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFRpbWVUaW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jdXJyZW50VGltZVRpbWVyKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRUaW1lVGltZXI7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYSBjdXJyZW50IHRpbWUuIFRoaXMgY2FuIGJlIHVzZWQgZm9yIGV4YW1wbGUgdG8gZW5zdXJlIHRoYXQgYSBjbGllbnQnc1xuICAgKiB0aW1lIGlzIHN5bmNocm9uaXplZCB3aXRoIGEgc2hhcmVkIHNlcnZlciB0aW1lLlxuICAgKiBAcGFyYW0ge0RhdGUgfCBTdHJpbmcgfCBOdW1iZXJ9IHRpbWUgICAgIEEgRGF0ZSwgdW5peCB0aW1lc3RhbXAsIG9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSVNPIGRhdGUgc3RyaW5nLlxuICAgKi9cbiAgQ3VycmVudFRpbWUucHJvdG90eXBlLnNldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICB2YXIgdCA9IHV0aWwuY29udmVydCh0aW1lLCAnRGF0ZScpLnZhbHVlT2YoKTtcbiAgICB2YXIgbm93ID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgdGhpcy5vZmZzZXQgPSB0IC0gbm93O1xuICAgIHRoaXMucmVkcmF3KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCB0aW1lLlxuICAgKiBAcmV0dXJuIHtEYXRlfSBSZXR1cm5zIHRoZSBjdXJyZW50IHRpbWUuXG4gICAqL1xuICBDdXJyZW50VGltZS5wcm90b3R5cGUuZ2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKG5ldyBEYXRlKCkudmFsdWVPZigpICsgdGhpcy5vZmZzZXQpO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gQ3VycmVudFRpbWU7XG5cbi8qKiovIH0sXG4vKiA1MSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICAvKipcbiAgICogVGhpcyBvYmplY3QgY29udGFpbnMgYWxsIHBvc3NpYmxlIG9wdGlvbnMuIEl0IHdpbGwgY2hlY2sgaWYgdGhlIHR5cGVzIGFyZSBjb3JyZWN0LCBpZiByZXF1aXJlZCBpZiB0aGUgb3B0aW9uIGlzIG9uZVxuICAgKiBvZiB0aGUgYWxsb3dlZCB2YWx1ZXMuXG4gICAqXG4gICAqIF9fYW55X18gbWVhbnMgdGhhdCB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgZG9lcyBub3QgbWF0dGVyLlxuICAgKiBfX3R5cGVfXyBpcyBhIHJlcXVpcmVkIGZpZWxkIGZvciBhbGwgb2JqZWN0cyBhbmQgY29udGFpbnMgdGhlIGFsbG93ZWQgdHlwZXMgb2YgYWxsIG9iamVjdHNcbiAgICovXG4gIHZhciBzdHJpbmcgPSAnc3RyaW5nJztcbiAgdmFyIGJvb2xlYW4gPSAnYm9vbGVhbic7XG4gIHZhciBudW1iZXIgPSAnbnVtYmVyJztcbiAgdmFyIGFycmF5ID0gJ2FycmF5JztcbiAgdmFyIGRhdGUgPSAnZGF0ZSc7XG4gIHZhciBvYmplY3QgPSAnb2JqZWN0JzsgLy8gc2hvdWxkIG9ubHkgYmUgaW4gYSBfX3R5cGVfXyBwcm9wZXJ0eVxuICB2YXIgZG9tID0gJ2RvbSc7XG4gIHZhciBtb21lbnQgPSAnbW9tZW50JztcbiAgdmFyIGFueSA9ICdhbnknO1xuXG4gIHZhciBhbGxPcHRpb25zID0ge1xuICAgIGNvbmZpZ3VyZToge1xuICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBmaWx0ZXI6IHsgYm9vbGVhbjogYm9vbGVhbiwgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgY29udGFpbmVyOiB7IGRvbTogZG9tIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbGVhbiwgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9XG4gICAgfSxcblxuICAgIC8vZ2xvYmFscyA6XG4gICAgYWxpZ246IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICBydGw6IHsgYm9vbGVhbjogYm9vbGVhbiwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgdmVydGljYWxTY3JvbGw6IHsgYm9vbGVhbjogYm9vbGVhbiwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgaG9yaXpvbnRhbFNjcm9sbDogeyBib29sZWFuOiBib29sZWFuLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICBhdXRvUmVzaXplOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICBjbGlja1RvVXNlOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICBkYXRhQXR0cmlidXRlczogeyBzdHJpbmc6IHN0cmluZywgYXJyYXk6IGFycmF5IH0sXG4gICAgZWRpdGFibGU6IHtcbiAgICAgIGFkZDogeyBib29sZWFuOiBib29sZWFuLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgIHJlbW92ZTogeyBib29sZWFuOiBib29sZWFuLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgIHVwZGF0ZUdyb3VwOiB7IGJvb2xlYW46IGJvb2xlYW4sICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgdXBkYXRlVGltZTogeyBib29sZWFuOiBib29sZWFuLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgIF9fdHlwZV9fOiB7IGJvb2xlYW46IGJvb2xlYW4sIG9iamVjdDogb2JqZWN0IH1cbiAgICB9LFxuICAgIGVuZDogeyBudW1iZXI6IG51bWJlciwgZGF0ZTogZGF0ZSwgc3RyaW5nOiBzdHJpbmcsIG1vbWVudDogbW9tZW50IH0sXG4gICAgZm9ybWF0OiB7XG4gICAgICBtaW5vckxhYmVsczoge1xuICAgICAgICBtaWxsaXNlY29uZDogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIHNlY29uZDogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIG1pbnV0ZTogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIGhvdXI6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICB3ZWVrZGF5OiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgZGF5OiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgbW9udGg6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICB5ZWFyOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfVxuICAgICAgfSxcbiAgICAgIG1ham9yTGFiZWxzOiB7XG4gICAgICAgIG1pbGxpc2Vjb25kOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgc2Vjb25kOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgbWludXRlOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgaG91cjogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIHdlZWtkYXk6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICBkYXk6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICBtb250aDogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIHllYXI6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9XG4gICAgICB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgbW9tZW50OiB7ICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICBncm91cE9yZGVyOiB7IHN0cmluZzogc3RyaW5nLCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgZ3JvdXBFZGl0YWJsZToge1xuICAgICAgYWRkOiB7IGJvb2xlYW46IGJvb2xlYW4sICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgcmVtb3ZlOiB7IGJvb2xlYW46IGJvb2xlYW4sICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgb3JkZXI6IHsgYm9vbGVhbjogYm9vbGVhbiwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICBfX3R5cGVfXzogeyBib29sZWFuOiBib29sZWFuLCBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcbiAgICBncm91cE9yZGVyU3dhcDogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgaGVpZ2h0OiB7IHN0cmluZzogc3RyaW5nLCBudW1iZXI6IG51bWJlciB9LFxuICAgIGhpZGRlbkRhdGVzOiB7XG4gICAgICBzdGFydDogeyBkYXRlOiBkYXRlLCBudW1iZXI6IG51bWJlciwgc3RyaW5nOiBzdHJpbmcsIG1vbWVudDogbW9tZW50IH0sXG4gICAgICBlbmQ6IHsgZGF0ZTogZGF0ZSwgbnVtYmVyOiBudW1iZXIsIHN0cmluZzogc3RyaW5nLCBtb21lbnQ6IG1vbWVudCB9LFxuICAgICAgcmVwZWF0OiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYXJyYXk6IGFycmF5IH1cbiAgICB9LFxuICAgIGl0ZW1zQWx3YXlzRHJhZ2dhYmxlOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICBsb2NhbGU6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICBsb2NhbGVzOiB7XG4gICAgICBfX2FueV9fOiB7IGFueTogYW55IH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcbiAgICBtYXJnaW46IHtcbiAgICAgIGF4aXM6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIGl0ZW06IHtcbiAgICAgICAgaG9yaXpvbnRhbDogeyBudW1iZXI6IG51bWJlciwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIHZlcnRpY2FsOiB7IG51bWJlcjogbnVtYmVyLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIG51bWJlcjogbnVtYmVyIH1cbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgbnVtYmVyOiBudW1iZXIgfVxuICAgIH0sXG4gICAgbWF4OiB7IGRhdGU6IGRhdGUsIG51bWJlcjogbnVtYmVyLCBzdHJpbmc6IHN0cmluZywgbW9tZW50OiBtb21lbnQgfSxcbiAgICBtYXhIZWlnaHQ6IHsgbnVtYmVyOiBudW1iZXIsIHN0cmluZzogc3RyaW5nIH0sXG4gICAgbWF4TWlub3JDaGFyczogeyBudW1iZXI6IG51bWJlciB9LFxuICAgIG1pbjogeyBkYXRlOiBkYXRlLCBudW1iZXI6IG51bWJlciwgc3RyaW5nOiBzdHJpbmcsIG1vbWVudDogbW9tZW50IH0sXG4gICAgbWluSGVpZ2h0OiB7IG51bWJlcjogbnVtYmVyLCBzdHJpbmc6IHN0cmluZyB9LFxuICAgIG1vdmVhYmxlOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICBtdWx0aXNlbGVjdDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgbXVsdGlzZWxlY3RQZXJHcm91cDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgb25BZGQ6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgIG9uVXBkYXRlOiB7ICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICBvbk1vdmU6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgIG9uTW92aW5nOiB7ICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICBvblJlbW92ZTogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgb25BZGRHcm91cDogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgb25Nb3ZlR3JvdXA6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgIG9uUmVtb3ZlR3JvdXA6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgIG9yZGVyOiB7ICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICBvcmllbnRhdGlvbjoge1xuICAgICAgYXhpczogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICBpdGVtOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgIF9fdHlwZV9fOiB7IHN0cmluZzogc3RyaW5nLCBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcbiAgICBzZWxlY3RhYmxlOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICBzaG93Q3VycmVudFRpbWU6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgIHNob3dNYWpvckxhYmVsczogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgc2hvd01pbm9yTGFiZWxzOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICBzdGFjazogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgc25hcDogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nLCAnbnVsbCc6ICdudWxsJyB9LFxuICAgIHN0YXJ0OiB7IGRhdGU6IGRhdGUsIG51bWJlcjogbnVtYmVyLCBzdHJpbmc6IHN0cmluZywgbW9tZW50OiBtb21lbnQgfSxcbiAgICB0ZW1wbGF0ZTogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgZ3JvdXBUZW1wbGF0ZTogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgdG9vbHRpcE9uSXRlbVVwZGF0ZVRpbWU6IHtcbiAgICAgIHRlbXBsYXRlOiB7ICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICAgIF9fdHlwZV9fOiB7IGJvb2xlYW46IGJvb2xlYW4sIG9iamVjdDogb2JqZWN0IH1cbiAgICB9LFxuICAgIHRpbWVBeGlzOiB7XG4gICAgICBzY2FsZTogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICBzdGVwOiB7IG51bWJlcjogbnVtYmVyLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICB9LFxuICAgIHR5cGU6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICB3aWR0aDogeyBzdHJpbmc6IHN0cmluZywgbnVtYmVyOiBudW1iZXIgfSxcbiAgICB6b29tYWJsZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgem9vbUtleTogeyBzdHJpbmc6IFsnY3RybEtleScsICdhbHRLZXknLCAnbWV0YUtleScsICcnXSB9LFxuICAgIHpvb21NYXg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICB6b29tTWluOiB7IG51bWJlcjogbnVtYmVyIH0sXG5cbiAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gIH07XG5cbiAgdmFyIGNvbmZpZ3VyZU9wdGlvbnMgPSB7XG4gICAgZ2xvYmFsOiB7XG4gICAgICBhbGlnbjogWydjZW50ZXInLCAnbGVmdCcsICdyaWdodCddLFxuICAgICAgZGlyZWN0aW9uOiBmYWxzZSxcbiAgICAgIGF1dG9SZXNpemU6IHRydWUsXG4gICAgICBjbGlja1RvVXNlOiBmYWxzZSxcbiAgICAgIC8vIGRhdGFBdHRyaWJ1dGVzOiBbJ2FsbCddLCAvLyBGSVhNRTogY2FuIGJlICdhbGwnIG9yIHN0cmluZ1tdXG4gICAgICBlZGl0YWJsZToge1xuICAgICAgICBhZGQ6IGZhbHNlLFxuICAgICAgICByZW1vdmU6IGZhbHNlLFxuICAgICAgICB1cGRhdGVHcm91cDogZmFsc2UsXG4gICAgICAgIHVwZGF0ZVRpbWU6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZW5kOiAnJyxcbiAgICAgIGZvcm1hdDoge1xuICAgICAgICBtaW5vckxhYmVsczoge1xuICAgICAgICAgIG1pbGxpc2Vjb25kOiAnU1NTJyxcbiAgICAgICAgICBzZWNvbmQ6ICdzJyxcbiAgICAgICAgICBtaW51dGU6ICdISDptbScsXG4gICAgICAgICAgaG91cjogJ0hIOm1tJyxcbiAgICAgICAgICB3ZWVrZGF5OiAnZGRkIEQnLFxuICAgICAgICAgIGRheTogJ0QnLFxuICAgICAgICAgIG1vbnRoOiAnTU1NJyxcbiAgICAgICAgICB5ZWFyOiAnWVlZWSdcbiAgICAgICAgfSxcbiAgICAgICAgbWFqb3JMYWJlbHM6IHtcbiAgICAgICAgICBtaWxsaXNlY29uZDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICBzZWNvbmQ6ICdEIE1NTU0gSEg6bW0nLFxuICAgICAgICAgIG1pbnV0ZTogJ2RkZCBEIE1NTU0nLFxuICAgICAgICAgIGhvdXI6ICdkZGQgRCBNTU1NJyxcbiAgICAgICAgICB3ZWVrZGF5OiAnTU1NTSBZWVlZJyxcbiAgICAgICAgICBkYXk6ICdNTU1NIFlZWVknLFxuICAgICAgICAgIG1vbnRoOiAnWVlZWScsXG4gICAgICAgICAgeWVhcjogJydcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLy9ncm91cE9yZGVyOiB7c3RyaW5nLCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICAgIGdyb3Vwc0RyYWdnYWJsZTogZmFsc2UsXG4gICAgICBoZWlnaHQ6ICcnLFxuICAgICAgLy9oaWRkZW5EYXRlczoge29iamVjdCwgYXJyYXl9LFxuICAgICAgbG9jYWxlOiAnJyxcbiAgICAgIG1hcmdpbjoge1xuICAgICAgICBheGlzOiBbMjAsIDAsIDEwMCwgMV0sXG4gICAgICAgIGl0ZW06IHtcbiAgICAgICAgICBob3Jpem9udGFsOiBbMTAsIDAsIDEwMCwgMV0sXG4gICAgICAgICAgdmVydGljYWw6IFsxMCwgMCwgMTAwLCAxXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWF4OiAnJyxcbiAgICAgIG1heEhlaWdodDogJycsXG4gICAgICBtYXhNaW5vckNoYXJzOiBbNywgMCwgMjAsIDFdLFxuICAgICAgbWluOiAnJyxcbiAgICAgIG1pbkhlaWdodDogJycsXG4gICAgICBtb3ZlYWJsZTogZmFsc2UsXG4gICAgICBtdWx0aXNlbGVjdDogZmFsc2UsXG4gICAgICBtdWx0aXNlbGVjdFBlckdyb3VwOiBmYWxzZSxcbiAgICAgIC8vb25BZGQ6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICAgIC8vb25VcGRhdGU6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICAgIC8vb25Nb3ZlOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gICAgICAvL29uTW92aW5nOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gICAgICAvL29uUmVuYW1lOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gICAgICAvL29yZGVyOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gICAgICBvcmllbnRhdGlvbjoge1xuICAgICAgICBheGlzOiBbJ2JvdGgnLCAnYm90dG9tJywgJ3RvcCddLFxuICAgICAgICBpdGVtOiBbJ2JvdHRvbScsICd0b3AnXVxuICAgICAgfSxcbiAgICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgICBzaG93Q3VycmVudFRpbWU6IGZhbHNlLFxuICAgICAgc2hvd01ham9yTGFiZWxzOiB0cnVlLFxuICAgICAgc2hvd01pbm9yTGFiZWxzOiB0cnVlLFxuICAgICAgc3RhY2s6IHRydWUsXG4gICAgICAvL3NuYXA6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nLCBuYWRhfSxcbiAgICAgIHN0YXJ0OiAnJyxcbiAgICAgIC8vdGVtcGxhdGU6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICAgIC8vdGltZUF4aXM6IHtcbiAgICAgIC8vICBzY2FsZTogWydtaWxsaXNlY29uZCcsICdzZWNvbmQnLCAnbWludXRlJywgJ2hvdXInLCAnd2Vla2RheScsICdkYXknLCAnbW9udGgnLCAneWVhciddLFxuICAgICAgLy8gIHN0ZXA6IFsxLCAxLCAxMCwgMV1cbiAgICAgIC8vfSxcbiAgICAgIHRvb2x0aXBPbkl0ZW1VcGRhdGVUaW1lOiBmYWxzZSxcbiAgICAgIHR5cGU6IFsnYm94JywgJ3BvaW50JywgJ3JhbmdlJywgJ2JhY2tncm91bmQnXSxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICB6b29tYWJsZTogdHJ1ZSxcbiAgICAgIHpvb21LZXk6IFsnY3RybEtleScsICdhbHRLZXknLCAnbWV0YUtleScsICcnXSxcbiAgICAgIHpvb21NYXg6IFszMTUzNjAwMDAwMDAwMDAsIDEwLCAzMTUzNjAwMDAwMDAwMDAsIDFdLFxuICAgICAgem9vbU1pbjogWzEwLCAxMCwgMzE1MzYwMDAwMDAwMDAwLCAxXVxuICAgIH1cbiAgfTtcblxuICBleHBvcnRzLmFsbE9wdGlvbnMgPSBhbGxPcHRpb25zO1xuICBleHBvcnRzLmNvbmZpZ3VyZU9wdGlvbnMgPSBjb25maWd1cmVPcHRpb25zO1xuXG4vKioqLyB9LFxuLyogNTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX0NvbmZpZ3VyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuXG4gIHZhciBfQ29uZmlndXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbmZpZ3VyYXRvcik7XG5cbiAgdmFyIF9WYWxpZGF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcblxuICB2YXIgX1ZhbGlkYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9WYWxpZGF0b3IpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgdmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbiAgdmFyIEhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuICB2YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuICB2YXIgRGF0YVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG4gIHZhciBEYXRhVmlldyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuICB2YXIgUmFuZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbiAgdmFyIENvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcbiAgdmFyIFRpbWVBeGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nik7XG4gIHZhciBDdXJyZW50VGltZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTApO1xuICB2YXIgQ3VzdG9tVGltZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xuICB2YXIgTGluZUdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XG5cbiAgdmFyIHByaW50U3R5bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKS5wcmludFN0eWxlO1xuICB2YXIgYWxsT3B0aW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpLmFsbE9wdGlvbnM7XG4gIHZhciBjb25maWd1cmVPcHRpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSkuY29uZmlndXJlT3B0aW9ucztcblxuICAvKipcbiAgICogQ3JlYXRlIGEgdGltZWxpbmUgdmlzdWFsaXphdGlvblxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXJcbiAgICogQHBhcmFtIHt2aXMuRGF0YVNldCB8IEFycmF5fSBbaXRlbXNdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gIFNlZSBHcmFwaDJkLnNldE9wdGlvbnMgZm9yIHRoZSBhdmFpbGFibGUgb3B0aW9ucy5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIENvcmVcbiAgICovXG4gIGZ1bmN0aW9uIEdyYXBoMmQoY29udGFpbmVyLCBpdGVtcywgZ3JvdXBzLCBvcHRpb25zKSB7XG4gICAgLy8gaWYgdGhlIHRoaXJkIGVsZW1lbnQgaXMgb3B0aW9ucywgdGhlIGZvcnRoIGlzIGdyb3VwcyAob3B0aW9uYWxseSk7XG4gICAgaWYgKCEoQXJyYXkuaXNBcnJheShncm91cHMpIHx8IGdyb3VwcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgZ3JvdXBzIGluc3RhbmNlb2YgRGF0YVZpZXcpICYmIGdyb3VwcyBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgdmFyIGZvcnRoQXJndW1lbnQgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IGdyb3VwcztcbiAgICAgIGdyb3VwcyA9IGZvcnRoQXJndW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgc3RhcnQ6IG51bGwsXG4gICAgICBlbmQ6IG51bGwsXG5cbiAgICAgIGF1dG9SZXNpemU6IHRydWUsXG5cbiAgICAgIG9yaWVudGF0aW9uOiB7XG4gICAgICAgIGF4aXM6ICdib3R0b20nLCAvLyBheGlzIG9yaWVudGF0aW9uOiAnYm90dG9tJywgJ3RvcCcsIG9yICdib3RoJ1xuICAgICAgICBpdGVtOiAnYm90dG9tJyAvLyBub3QgcmVsZXZhbnQgZm9yIEdyYXBoMmRcbiAgICAgIH0sXG5cbiAgICAgIG1vbWVudDogbW9tZW50LFxuXG4gICAgICB3aWR0aDogbnVsbCxcbiAgICAgIGhlaWdodDogbnVsbCxcbiAgICAgIG1heEhlaWdodDogbnVsbCxcbiAgICAgIG1pbkhlaWdodDogbnVsbFxuICAgIH07XG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5kZWVwRXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIC8vIENyZWF0ZSB0aGUgRE9NLCBwcm9wcywgYW5kIGVtaXR0ZXJcbiAgICB0aGlzLl9jcmVhdGUoY29udGFpbmVyKTtcblxuICAgIC8vIGFsbCBjb21wb25lbnRzIGxpc3RlZCBoZXJlIHdpbGwgYmUgcmVwYWludGVkIGF1dG9tYXRpY2FsbHlcbiAgICB0aGlzLmNvbXBvbmVudHMgPSBbXTtcblxuICAgIHRoaXMuYm9keSA9IHtcbiAgICAgIGRvbTogdGhpcy5kb20sXG4gICAgICBkb21Qcm9wczogdGhpcy5wcm9wcyxcbiAgICAgIGVtaXR0ZXI6IHtcbiAgICAgICAgb246IHRoaXMub24uYmluZCh0aGlzKSxcbiAgICAgICAgb2ZmOiB0aGlzLm9mZi5iaW5kKHRoaXMpLFxuICAgICAgICBlbWl0OiB0aGlzLmVtaXQuYmluZCh0aGlzKVxuICAgICAgfSxcbiAgICAgIGhpZGRlbkRhdGVzOiBbXSxcbiAgICAgIHV0aWw6IHtcbiAgICAgICAgdG9TY3JlZW46IG1lLl90b1NjcmVlbi5iaW5kKG1lKSxcbiAgICAgICAgdG9HbG9iYWxTY3JlZW46IG1lLl90b0dsb2JhbFNjcmVlbi5iaW5kKG1lKSwgLy8gdGhpcyByZWZlcnMgdG8gdGhlIHJvb3Qud2lkdGhcbiAgICAgICAgdG9UaW1lOiBtZS5fdG9UaW1lLmJpbmQobWUpLFxuICAgICAgICB0b0dsb2JhbFRpbWU6IG1lLl90b0dsb2JhbFRpbWUuYmluZChtZSlcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gcmFuZ2VcbiAgICB0aGlzLnJhbmdlID0gbmV3IFJhbmdlKHRoaXMuYm9keSk7XG4gICAgdGhpcy5jb21wb25lbnRzLnB1c2godGhpcy5yYW5nZSk7XG4gICAgdGhpcy5ib2R5LnJhbmdlID0gdGhpcy5yYW5nZTtcblxuICAgIC8vIHRpbWUgYXhpc1xuICAgIHRoaXMudGltZUF4aXMgPSBuZXcgVGltZUF4aXModGhpcy5ib2R5KTtcbiAgICB0aGlzLmNvbXBvbmVudHMucHVzaCh0aGlzLnRpbWVBeGlzKTtcbiAgICAvL3RoaXMuYm9keS51dGlsLnNuYXAgPSB0aGlzLnRpbWVBeGlzLnNuYXAuYmluZCh0aGlzLnRpbWVBeGlzKTtcblxuICAgIC8vIGN1cnJlbnQgdGltZSBiYXJcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gbmV3IEN1cnJlbnRUaW1lKHRoaXMuYm9keSk7XG4gICAgdGhpcy5jb21wb25lbnRzLnB1c2godGhpcy5jdXJyZW50VGltZSk7XG5cbiAgICAvLyBpdGVtIHNldFxuICAgIHRoaXMubGluZWdyYXBoID0gbmV3IExpbmVHcmFwaCh0aGlzLmJvZHkpO1xuXG4gICAgdGhpcy5jb21wb25lbnRzLnB1c2godGhpcy5saW5lZ3JhcGgpO1xuXG4gICAgdGhpcy5pdGVtc0RhdGEgPSBudWxsOyAvLyBEYXRhU2V0XG4gICAgdGhpcy5ncm91cHNEYXRhID0gbnVsbDsgLy8gRGF0YVNldFxuXG5cbiAgICB0aGlzLm9uKCd0YXAnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIG1lLmVtaXQoJ2NsaWNrJywgbWUuZ2V0RXZlbnRQcm9wZXJ0aWVzKGV2ZW50KSk7XG4gICAgfSk7XG4gICAgdGhpcy5vbignZG91YmxldGFwJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBtZS5lbWl0KCdkb3VibGVDbGljaycsIG1lLmdldEV2ZW50UHJvcGVydGllcyhldmVudCkpO1xuICAgIH0pO1xuICAgIHRoaXMuZG9tLnJvb3Qub25jb250ZXh0bWVudSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgbWUuZW1pdCgnY29udGV4dG1lbnUnLCBtZS5nZXRFdmVudFByb3BlcnRpZXMoZXZlbnQpKTtcbiAgICB9O1xuXG4gICAgLy8gYXBwbHkgb3B0aW9uc1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gSU1QT1JUQU5UOiBUSElTIEhBUFBFTlMgQkVGT1JFIFNFVCBJVEVNUyFcbiAgICBpZiAoZ3JvdXBzKSB7XG4gICAgICB0aGlzLnNldEdyb3Vwcyhncm91cHMpO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBpdGVtc2V0XG4gICAgaWYgKGl0ZW1zKSB7XG4gICAgICB0aGlzLnNldEl0ZW1zKGl0ZW1zKTtcbiAgICB9XG5cbiAgICAvLyBkcmF3IGZvciB0aGUgZmlyc3QgdGltZVxuICAgIHRoaXMuX3JlZHJhdygpO1xuICB9XG5cbiAgLy8gRXh0ZW5kIHRoZSBmdW5jdGlvbmFsaXR5IGZyb20gQ29yZVxuICBHcmFwaDJkLnByb3RvdHlwZSA9IG5ldyBDb3JlKCk7XG5cbiAgR3JhcGgyZC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gdmFsaWRhdGUgb3B0aW9uc1xuICAgIHZhciBlcnJvckZvdW5kID0gX1ZhbGlkYXRvcjIuZGVmYXVsdC52YWxpZGF0ZShvcHRpb25zLCBhbGxPcHRpb25zKTtcbiAgICBpZiAoZXJyb3JGb3VuZCA9PT0gdHJ1ZSkge1xuICAgICAgY29uc29sZS5sb2coJyVjRXJyb3JzIGhhdmUgYmVlbiBmb3VuZCBpbiB0aGUgc3VwcGxpZWQgb3B0aW9ucyBvYmplY3QuJywgcHJpbnRTdHlsZSk7XG4gICAgfVxuXG4gICAgQ29yZS5wcm90b3R5cGUuc2V0T3B0aW9ucy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgaXRlbXNcbiAgICogQHBhcmFtIHt2aXMuRGF0YVNldCB8IEFycmF5IHwgbnVsbH0gaXRlbXNcbiAgICovXG4gIEdyYXBoMmQucHJvdG90eXBlLnNldEl0ZW1zID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgdmFyIGluaXRpYWxMb2FkID0gdGhpcy5pdGVtc0RhdGEgPT0gbnVsbDtcblxuICAgIC8vIGNvbnZlcnQgdG8gdHlwZSBEYXRhU2V0IHdoZW4gbmVlZGVkXG4gICAgdmFyIG5ld0RhdGFTZXQ7XG4gICAgaWYgKCFpdGVtcykge1xuICAgICAgbmV3RGF0YVNldCA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChpdGVtcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgaXRlbXMgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgICAgbmV3RGF0YVNldCA9IGl0ZW1zO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0dXJuIGFuIGFycmF5IGludG8gYSBkYXRhc2V0XG4gICAgICBuZXdEYXRhU2V0ID0gbmV3IERhdGFTZXQoaXRlbXMsIHtcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgIHN0YXJ0OiAnRGF0ZScsXG4gICAgICAgICAgZW5kOiAnRGF0ZSdcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gc2V0IGl0ZW1zXG4gICAgdGhpcy5pdGVtc0RhdGEgPSBuZXdEYXRhU2V0O1xuICAgIHRoaXMubGluZWdyYXBoICYmIHRoaXMubGluZWdyYXBoLnNldEl0ZW1zKG5ld0RhdGFTZXQpO1xuXG4gICAgaWYgKGluaXRpYWxMb2FkKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN0YXJ0ICE9IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMuZW5kICE9IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLm9wdGlvbnMuc3RhcnQgIT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLnN0YXJ0IDogbnVsbDtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMub3B0aW9ucy5lbmQgIT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLmVuZCA6IG51bGw7XG4gICAgICAgIHRoaXMuc2V0V2luZG93KHN0YXJ0LCBlbmQsIHsgYW5pbWF0aW9uOiBmYWxzZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZml0KHsgYW5pbWF0aW9uOiBmYWxzZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBncm91cHNcbiAgICogQHBhcmFtIHt2aXMuRGF0YVNldCB8IEFycmF5fSBncm91cHNcbiAgICovXG4gIEdyYXBoMmQucHJvdG90eXBlLnNldEdyb3VwcyA9IGZ1bmN0aW9uIChncm91cHMpIHtcbiAgICAvLyBjb252ZXJ0IHRvIHR5cGUgRGF0YVNldCB3aGVuIG5lZWRlZFxuICAgIHZhciBuZXdEYXRhU2V0O1xuICAgIGlmICghZ3JvdXBzKSB7XG4gICAgICBuZXdEYXRhU2V0ID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGdyb3VwcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgZ3JvdXBzIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICAgIG5ld0RhdGFTZXQgPSBncm91cHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHR1cm4gYW4gYXJyYXkgaW50byBhIGRhdGFzZXRcbiAgICAgIG5ld0RhdGFTZXQgPSBuZXcgRGF0YVNldChncm91cHMpO1xuICAgIH1cblxuICAgIHRoaXMuZ3JvdXBzRGF0YSA9IG5ld0RhdGFTZXQ7XG4gICAgdGhpcy5saW5lZ3JhcGguc2V0R3JvdXBzKG5ld0RhdGFTZXQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIGFuIFNWRyBlbGVtZW50IHdpdGggdGhlIGljb24gb2YgdGhlIGdyb3VwIChzaXplIGRldGVybWluZWQgYnkgaWNvbldpZHRoIGFuZCBpY29uSGVpZ2h0KSwgdGhlIGxhYmVsIG9mIHRoZSBncm91cCAoY29udGVudCkgYW5kIHRoZSB5QXhpc09yaWVudGF0aW9uIG9mIHRoZSBncm91cCAobGVmdCBvciByaWdodCkuXG4gICAqIEBwYXJhbSBncm91cElkXG4gICAqIEBwYXJhbSB3aWR0aFxuICAgKiBAcGFyYW0gaGVpZ2h0XG4gICAqL1xuICBHcmFwaDJkLnByb3RvdHlwZS5nZXRMZWdlbmQgPSBmdW5jdGlvbiAoZ3JvdXBJZCwgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB3aWR0aCA9IDE1O1xuICAgIH1cbiAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGhlaWdodCA9IDE1O1xuICAgIH1cbiAgICBpZiAodGhpcy5saW5lZ3JhcGguZ3JvdXBzW2dyb3VwSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpbmVncmFwaC5ncm91cHNbZ3JvdXBJZF0uZ2V0TGVnZW5kKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJjYW5ub3QgZmluZCBncm91cDonXCIgKyBncm91cElkICsgXCInXCI7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGNoZWNrcyBpZiB0aGUgdmlzaWJsZSBvcHRpb24gb2YgdGhlIHN1cHBsaWVkIGdyb3VwIChieSBJRCkgaXMgdHJ1ZSBvciBmYWxzZS5cbiAgICogQHBhcmFtIGdyb3VwSWRcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBHcmFwaDJkLnByb3RvdHlwZS5pc0dyb3VwVmlzaWJsZSA9IGZ1bmN0aW9uIChncm91cElkKSB7XG4gICAgaWYgKHRoaXMubGluZWdyYXBoLmdyb3Vwc1tncm91cElkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5saW5lZ3JhcGguZ3JvdXBzW2dyb3VwSWRdLnZpc2libGUgJiYgKHRoaXMubGluZWdyYXBoLm9wdGlvbnMuZ3JvdXBzLnZpc2liaWxpdHlbZ3JvdXBJZF0gPT09IHVuZGVmaW5lZCB8fCB0aGlzLmxpbmVncmFwaC5vcHRpb25zLmdyb3Vwcy52aXNpYmlsaXR5W2dyb3VwSWRdID09IHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRhdGEgcmFuZ2Ugb2YgdGhlIGl0ZW0gc2V0LlxuICAgKiBAcmV0dXJucyB7e21pbjogRGF0ZSwgbWF4OiBEYXRlfX0gcmFuZ2UgIEEgcmFuZ2Ugd2l0aCBhIHN0YXJ0IGFuZCBlbmQgRGF0ZS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGVuIG5vIG1pbmltdW0gaXMgZm91bmQsIG1pbj09bnVsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gbm8gbWF4aW11bSBpcyBmb3VuZCwgbWF4PT1udWxsXG4gICAqL1xuICBHcmFwaDJkLnByb3RvdHlwZS5nZXREYXRhUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1pbiA9IG51bGw7XG4gICAgdmFyIG1heCA9IG51bGw7XG5cbiAgICAvLyBjYWxjdWxhdGUgbWluIGZyb20gc3RhcnQgZmlsZWRcbiAgICBmb3IgKHZhciBncm91cElkIGluIHRoaXMubGluZWdyYXBoLmdyb3Vwcykge1xuICAgICAgaWYgKHRoaXMubGluZWdyYXBoLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShncm91cElkKSkge1xuICAgICAgICBpZiAodGhpcy5saW5lZ3JhcGguZ3JvdXBzW2dyb3VwSWRdLnZpc2libGUgPT0gdHJ1ZSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lZ3JhcGguZ3JvdXBzW2dyb3VwSWRdLml0ZW1zRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmxpbmVncmFwaC5ncm91cHNbZ3JvdXBJZF0uaXRlbXNEYXRhW2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdXRpbC5jb252ZXJ0KGl0ZW0ueCwgJ0RhdGUnKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICBtaW4gPSBtaW4gPT0gbnVsbCA/IHZhbHVlIDogbWluID4gdmFsdWUgPyB2YWx1ZSA6IG1pbjtcbiAgICAgICAgICAgIG1heCA9IG1heCA9PSBudWxsID8gdmFsdWUgOiBtYXggPCB2YWx1ZSA/IHZhbHVlIDogbWF4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBtaW46IG1pbiAhPSBudWxsID8gbmV3IERhdGUobWluKSA6IG51bGwsXG4gICAgICBtYXg6IG1heCAhPSBudWxsID8gbmV3IERhdGUobWF4KSA6IG51bGxcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBUaW1lbGluZSByZWxhdGVkIGluZm9ybWF0aW9uIGZyb20gYW4gZXZlbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCByZWxhdGVkIGluZm9ybWF0aW9uLCBsaWtlIG9uIHdoaWNoIGFyZWFcbiAgICogICAgICAgICAgICAgICAgICBUaGUgZXZlbnQgaGFwcGVuZWQsIHdoZXRoZXIgY2xpY2tlZCBvbiBhbiBpdGVtLCBldGMuXG4gICAqL1xuICBHcmFwaDJkLnByb3RvdHlwZS5nZXRFdmVudFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgY2xpZW50WCA9IGV2ZW50LmNlbnRlciA/IGV2ZW50LmNlbnRlci54IDogZXZlbnQuY2xpZW50WDtcbiAgICB2YXIgY2xpZW50WSA9IGV2ZW50LmNlbnRlciA/IGV2ZW50LmNlbnRlci55IDogZXZlbnQuY2xpZW50WTtcbiAgICB2YXIgeCA9IGNsaWVudFggLSB1dGlsLmdldEFic29sdXRlTGVmdCh0aGlzLmRvbS5jZW50ZXJDb250YWluZXIpO1xuICAgIHZhciB5ID0gY2xpZW50WSAtIHV0aWwuZ2V0QWJzb2x1dGVUb3AodGhpcy5kb20uY2VudGVyQ29udGFpbmVyKTtcbiAgICB2YXIgdGltZSA9IHRoaXMuX3RvVGltZSh4KTtcblxuICAgIHZhciBjdXN0b21UaW1lID0gQ3VzdG9tVGltZS5jdXN0b21UaW1lRnJvbVRhcmdldChldmVudCk7XG5cbiAgICB2YXIgZWxlbWVudCA9IHV0aWwuZ2V0VGFyZ2V0KGV2ZW50KTtcbiAgICB2YXIgd2hhdCA9IG51bGw7XG4gICAgaWYgKHV0aWwuaGFzUGFyZW50KGVsZW1lbnQsIHRoaXMudGltZUF4aXMuZG9tLmZvcmVncm91bmQpKSB7XG4gICAgICB3aGF0ID0gJ2F4aXMnO1xuICAgIH0gZWxzZSBpZiAodGhpcy50aW1lQXhpczIgJiYgdXRpbC5oYXNQYXJlbnQoZWxlbWVudCwgdGhpcy50aW1lQXhpczIuZG9tLmZvcmVncm91bmQpKSB7XG4gICAgICB3aGF0ID0gJ2F4aXMnO1xuICAgIH0gZWxzZSBpZiAodXRpbC5oYXNQYXJlbnQoZWxlbWVudCwgdGhpcy5saW5lZ3JhcGgueUF4aXNMZWZ0LmRvbS5mcmFtZSkpIHtcbiAgICAgIHdoYXQgPSAnZGF0YS1heGlzJztcbiAgICB9IGVsc2UgaWYgKHV0aWwuaGFzUGFyZW50KGVsZW1lbnQsIHRoaXMubGluZWdyYXBoLnlBeGlzUmlnaHQuZG9tLmZyYW1lKSkge1xuICAgICAgd2hhdCA9ICdkYXRhLWF4aXMnO1xuICAgIH0gZWxzZSBpZiAodXRpbC5oYXNQYXJlbnQoZWxlbWVudCwgdGhpcy5saW5lZ3JhcGgubGVnZW5kTGVmdC5kb20uZnJhbWUpKSB7XG4gICAgICB3aGF0ID0gJ2xlZ2VuZCc7XG4gICAgfSBlbHNlIGlmICh1dGlsLmhhc1BhcmVudChlbGVtZW50LCB0aGlzLmxpbmVncmFwaC5sZWdlbmRSaWdodC5kb20uZnJhbWUpKSB7XG4gICAgICB3aGF0ID0gJ2xlZ2VuZCc7XG4gICAgfSBlbHNlIGlmIChjdXN0b21UaW1lICE9IG51bGwpIHtcbiAgICAgIHdoYXQgPSAnY3VzdG9tLXRpbWUnO1xuICAgIH0gZWxzZSBpZiAodXRpbC5oYXNQYXJlbnQoZWxlbWVudCwgdGhpcy5jdXJyZW50VGltZS5iYXIpKSB7XG4gICAgICB3aGF0ID0gJ2N1cnJlbnQtdGltZSc7XG4gICAgfSBlbHNlIGlmICh1dGlsLmhhc1BhcmVudChlbGVtZW50LCB0aGlzLmRvbS5jZW50ZXIpKSB7XG4gICAgICB3aGF0ID0gJ2JhY2tncm91bmQnO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IFtdO1xuICAgIHZhciB5QXhpc0xlZnQgPSB0aGlzLmxpbmVncmFwaC55QXhpc0xlZnQ7XG4gICAgdmFyIHlBeGlzUmlnaHQgPSB0aGlzLmxpbmVncmFwaC55QXhpc1JpZ2h0O1xuICAgIGlmICgheUF4aXNMZWZ0LmhpZGRlbikge1xuICAgICAgdmFsdWUucHVzaCh5QXhpc0xlZnQuc2NyZWVuVG9WYWx1ZSh5KSk7XG4gICAgfVxuICAgIGlmICgheUF4aXNSaWdodC5oaWRkZW4pIHtcbiAgICAgIHZhbHVlLnB1c2goeUF4aXNSaWdodC5zY3JlZW5Ub1ZhbHVlKHkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgd2hhdDogd2hhdCxcbiAgICAgIHBhZ2VYOiBldmVudC5zcmNFdmVudCA/IGV2ZW50LnNyY0V2ZW50LnBhZ2VYIDogZXZlbnQucGFnZVgsXG4gICAgICBwYWdlWTogZXZlbnQuc3JjRXZlbnQgPyBldmVudC5zcmNFdmVudC5wYWdlWSA6IGV2ZW50LnBhZ2VZLFxuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICB0aW1lOiB0aW1lLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogTG9hZCBhIGNvbmZpZ3VyYXRvclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBHcmFwaDJkLnByb3RvdHlwZS5fY3JlYXRlQ29uZmlndXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgX0NvbmZpZ3VyYXRvcjIuZGVmYXVsdCh0aGlzLCB0aGlzLmRvbS5jb250YWluZXIsIGNvbmZpZ3VyZU9wdGlvbnMpO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gR3JhcGgyZDtcblxuLyoqKi8gfSxcbi8qIDUzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIERPTXV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuICB2YXIgRGF0YVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG4gIHZhciBEYXRhVmlldyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuICB2YXIgQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG4gIHZhciBEYXRhQXhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNTQpO1xuICB2YXIgR3JhcGhHcm91cCA9IF9fd2VicGFja19yZXF1aXJlX18oNTYpO1xuICB2YXIgTGVnZW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MCk7XG4gIHZhciBCYXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nyk7XG4gIHZhciBMaW5lcyA9IF9fd2VicGFja19yZXF1aXJlX18oNTkpO1xuICB2YXIgUG9pbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XG5cbiAgdmFyIFVOR1JPVVBFRCA9ICdfX3VuZ3JvdXBlZF9fJzsgLy8gcmVzZXJ2ZWQgZ3JvdXAgaWQgZm9yIHVuZ3JvdXBlZCBpdGVtc1xuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgTGluZUdyYXBoLiBJdCByZXF1aXJlcyBhIFRpbWVsaW5lIGJvZHkgYW5kIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBib2R5XG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gTGluZUdyYXBoKGJvZHksIG9wdGlvbnMpIHtcbiAgICB0aGlzLmlkID0gdXRpbC5yYW5kb21VVUlEKCk7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcblxuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICB5QXhpc09yaWVudGF0aW9uOiAnbGVmdCcsXG4gICAgICBkZWZhdWx0R3JvdXA6ICdkZWZhdWx0JyxcbiAgICAgIHNvcnQ6IHRydWUsXG4gICAgICBzYW1wbGluZzogdHJ1ZSxcbiAgICAgIHN0YWNrOiBmYWxzZSxcbiAgICAgIGdyYXBoSGVpZ2h0OiAnNDAwcHgnLFxuICAgICAgc2hhZGVkOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBvcmllbnRhdGlvbjogJ2JvdHRvbScgLy8gdG9wLCBib3R0b20sIHplcm9cbiAgICAgIH0sXG4gICAgICBzdHlsZTogJ2xpbmUnLCAvLyBsaW5lLCBiYXJcbiAgICAgIGJhckNoYXJ0OiB7XG4gICAgICAgIHdpZHRoOiA1MCxcbiAgICAgICAgc2lkZUJ5U2lkZTogZmFsc2UsXG4gICAgICAgIGFsaWduOiAnY2VudGVyJyAvLyBsZWZ0LCBjZW50ZXIsIHJpZ2h0XG4gICAgICB9LFxuICAgICAgaW50ZXJwb2xhdGlvbjoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBwYXJhbWV0cml6YXRpb246ICdjZW50cmlwZXRhbCcsIC8vIHVuaWZvcm0gKGFscGhhID0gMC4wKSwgY2hvcmRhbCAoYWxwaGEgPSAxLjApLCBjZW50cmlwZXRhbCAoYWxwaGEgPSAwLjUpXG4gICAgICAgIGFscGhhOiAwLjVcbiAgICAgIH0sXG4gICAgICBkcmF3UG9pbnRzOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIHNpemU6IDYsXG4gICAgICAgIHN0eWxlOiAnc3F1YXJlJyAvLyBzcXVhcmUsIGNpcmNsZVxuICAgICAgfSxcbiAgICAgIGRhdGFBeGlzOiB7fSwgLy9EZWZhdWx0cyBhcmUgZG9uZSBvbiBEYXRhQXhpcyBsZXZlbFxuICAgICAgbGVnZW5kOiB7fSwgLy9EZWZhdWx0cyBhcmUgZG9uZSBvbiBMZWdlbmQgbGV2ZWxcbiAgICAgIGdyb3Vwczoge1xuICAgICAgICB2aXNpYmlsaXR5OiB7fVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBvcHRpb25zIGlzIHNoYXJlZCBieSB0aGlzIGxpbmVHcmFwaCBhbmQgYWxsIGl0cyBpdGVtc1xuICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgICB0aGlzLmRvbSA9IHt9O1xuICAgIHRoaXMucHJvcHMgPSB7fTtcbiAgICB0aGlzLmhhbW1lciA9IG51bGw7XG4gICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICB0aGlzLmFib3J0ZWRHcmFwaFVwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlU1ZHaGVpZ2h0ID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGVTVkdoZWlnaHRPblJlc2l6ZSA9IGZhbHNlO1xuICAgIHRoaXMuZm9yY2VHcmFwaFVwZGF0ZSA9IHRydWU7XG5cbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHRoaXMuaXRlbXNEYXRhID0gbnVsbDsgLy8gRGF0YVNldFxuICAgIHRoaXMuZ3JvdXBzRGF0YSA9IG51bGw7IC8vIERhdGFTZXRcblxuICAgIC8vIGxpc3RlbmVycyBmb3IgdGhlIERhdGFTZXQgb2YgdGhlIGl0ZW1zXG4gICAgdGhpcy5pdGVtTGlzdGVuZXJzID0ge1xuICAgICAgJ2FkZCc6IGZ1bmN0aW9uIGFkZChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgICAgICBtZS5fb25BZGQocGFyYW1zLml0ZW1zKTtcbiAgICAgIH0sXG4gICAgICAndXBkYXRlJzogZnVuY3Rpb24gdXBkYXRlKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgICAgIG1lLl9vblVwZGF0ZShwYXJhbXMuaXRlbXMpO1xuICAgICAgfSxcbiAgICAgICdyZW1vdmUnOiBmdW5jdGlvbiByZW1vdmUoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICAgICAgbWUuX29uUmVtb3ZlKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGxpc3RlbmVycyBmb3IgdGhlIERhdGFTZXQgb2YgdGhlIGdyb3Vwc1xuICAgIHRoaXMuZ3JvdXBMaXN0ZW5lcnMgPSB7XG4gICAgICAnYWRkJzogZnVuY3Rpb24gYWRkKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgICAgIG1lLl9vbkFkZEdyb3VwcyhwYXJhbXMuaXRlbXMpO1xuICAgICAgfSxcbiAgICAgICd1cGRhdGUnOiBmdW5jdGlvbiB1cGRhdGUoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICAgICAgbWUuX29uVXBkYXRlR3JvdXBzKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9LFxuICAgICAgJ3JlbW92ZSc6IGZ1bmN0aW9uIHJlbW92ZShldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgICAgICBtZS5fb25SZW1vdmVHcm91cHMocGFyYW1zLml0ZW1zKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5pdGVtcyA9IHt9OyAvLyBvYmplY3Qgd2l0aCBhbiBJdGVtIGZvciBldmVyeSBkYXRhIGl0ZW1cbiAgICB0aGlzLnNlbGVjdGlvbiA9IFtdOyAvLyBsaXN0IHdpdGggdGhlIGlkcyBvZiBhbGwgc2VsZWN0ZWQgbm9kZXNcbiAgICB0aGlzLmxhc3RTdGFydCA9IHRoaXMuYm9keS5yYW5nZS5zdGFydDtcbiAgICB0aGlzLnRvdWNoUGFyYW1zID0ge307IC8vIHN0b3JlcyBwcm9wZXJ0aWVzIHdoaWxlIGRyYWdnaW5nXG5cbiAgICB0aGlzLnN2Z0VsZW1lbnRzID0ge307XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuZ3JvdXBzVXNpbmdEZWZhdWx0U3R5bGVzID0gWzBdO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdyYW5nZWNoYW5nZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBtZS5sYXN0U3RhcnQgPSBtZS5ib2R5LnJhbmdlLnN0YXJ0O1xuICAgICAgbWUuc3ZnLnN0eWxlLmxlZnQgPSB1dGlsLm9wdGlvbi5hc1NpemUoLW1lLnByb3BzLndpZHRoKTtcblxuICAgICAgbWUuZm9yY2VHcmFwaFVwZGF0ZSA9IHRydWU7XG4gICAgICAvL0lzIHRoaXMgbG9jYWwgcmVkcmF3IG5lY2Vzc2FyeT8gKENvcmUgYWxzbyBkb2VzIGEgY2hhbmdlIGV2ZW50ISlcbiAgICAgIG1lLnJlZHJhdy5jYWxsKG1lKTtcbiAgICB9KTtcblxuICAgIC8vIGNyZWF0ZSB0aGUgSFRNTCBET01cbiAgICB0aGlzLl9jcmVhdGUoKTtcbiAgICB0aGlzLmZyYW1ld29yayA9IHsgc3ZnOiB0aGlzLnN2Zywgc3ZnRWxlbWVudHM6IHRoaXMuc3ZnRWxlbWVudHMsIG9wdGlvbnM6IHRoaXMub3B0aW9ucywgZ3JvdXBzOiB0aGlzLmdyb3VwcyB9O1xuICB9XG5cbiAgTGluZUdyYXBoLnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBIVE1MIERPTSBmb3IgdGhlIEl0ZW1TZXRcbiAgICovXG4gIExpbmVHcmFwaC5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBmcmFtZS5jbGFzc05hbWUgPSAndmlzLWxpbmUtZ3JhcGgnO1xuICAgIHRoaXMuZG9tLmZyYW1lID0gZnJhbWU7XG5cbiAgICAvLyBjcmVhdGUgc3ZnIGVsZW1lbnQgZm9yIGdyYXBoIGRyYXdpbmcuXG4gICAgdGhpcy5zdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3N2ZycpO1xuICAgIHRoaXMuc3ZnLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICB0aGlzLnN2Zy5zdHlsZS5oZWlnaHQgPSAoJycgKyB0aGlzLm9wdGlvbnMuZ3JhcGhIZWlnaHQpLnJlcGxhY2UoJ3B4JywgJycpICsgJ3B4JztcbiAgICB0aGlzLnN2Zy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICBmcmFtZS5hcHBlbmRDaGlsZCh0aGlzLnN2Zyk7XG5cbiAgICAvLyBkYXRhIGF4aXNcbiAgICB0aGlzLm9wdGlvbnMuZGF0YUF4aXMub3JpZW50YXRpb24gPSAnbGVmdCc7XG4gICAgdGhpcy55QXhpc0xlZnQgPSBuZXcgRGF0YUF4aXModGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMuZGF0YUF4aXMsIHRoaXMuc3ZnLCB0aGlzLm9wdGlvbnMuZ3JvdXBzKTtcblxuICAgIHRoaXMub3B0aW9ucy5kYXRhQXhpcy5vcmllbnRhdGlvbiA9ICdyaWdodCc7XG4gICAgdGhpcy55QXhpc1JpZ2h0ID0gbmV3IERhdGFBeGlzKHRoaXMuYm9keSwgdGhpcy5vcHRpb25zLmRhdGFBeGlzLCB0aGlzLnN2ZywgdGhpcy5vcHRpb25zLmdyb3Vwcyk7XG4gICAgZGVsZXRlIHRoaXMub3B0aW9ucy5kYXRhQXhpcy5vcmllbnRhdGlvbjtcblxuICAgIC8vIGxlZ2VuZHNcbiAgICB0aGlzLmxlZ2VuZExlZnQgPSBuZXcgTGVnZW5kKHRoaXMuYm9keSwgdGhpcy5vcHRpb25zLmxlZ2VuZCwgJ2xlZnQnLCB0aGlzLm9wdGlvbnMuZ3JvdXBzKTtcbiAgICB0aGlzLmxlZ2VuZFJpZ2h0ID0gbmV3IExlZ2VuZCh0aGlzLmJvZHksIHRoaXMub3B0aW9ucy5sZWdlbmQsICdyaWdodCcsIHRoaXMub3B0aW9ucy5ncm91cHMpO1xuXG4gICAgdGhpcy5zaG93KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIHNldCB0aGUgb3B0aW9ucyBvZiB0aGUgTGluZUdyYXBoLiB0aGUgbWVyZ2VPcHRpb25zIGlzIHVzZWQgZm9yIHN1Yk9iamVjdHMgdGhhdCBoYXZlIGFuIGVuYWJsZWQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIExpbmVHcmFwaC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIHZhciBmaWVsZHMgPSBbJ3NhbXBsaW5nJywgJ2RlZmF1bHRHcm91cCcsICdzdGFjaycsICdoZWlnaHQnLCAnZ3JhcGhIZWlnaHQnLCAneUF4aXNPcmllbnRhdGlvbicsICdzdHlsZScsICdiYXJDaGFydCcsICdkYXRhQXhpcycsICdzb3J0JywgJ2dyb3VwcyddO1xuICAgICAgaWYgKG9wdGlvbnMuZ3JhcGhIZWlnaHQgPT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU1ZHaGVpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVTVkdoZWlnaHRPblJlc2l6ZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYm9keS5kb21Qcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5ncmFwaEhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChwYXJzZUludCgob3B0aW9ucy5ncmFwaEhlaWdodCArICcnKS5yZXBsYWNlKFwicHhcIiwgJycpKSA8IHRoaXMuYm9keS5kb21Qcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0KSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVTVkdoZWlnaHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB1dGlsLnNlbGVjdGl2ZURlZXBFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgdXRpbC5tZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zLCAnaW50ZXJwb2xhdGlvbicpO1xuICAgICAgdXRpbC5tZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zLCAnZHJhd1BvaW50cycpO1xuICAgICAgdXRpbC5tZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zLCAnc2hhZGVkJyk7XG4gICAgICB1dGlsLm1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsICdsZWdlbmQnKTtcblxuICAgICAgaWYgKG9wdGlvbnMuaW50ZXJwb2xhdGlvbikge1xuICAgICAgICBpZiAoX3R5cGVvZihvcHRpb25zLmludGVycG9sYXRpb24pID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5wYXJhbWV0cml6YXRpb24pIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmludGVycG9sYXRpb24ucGFyYW1ldHJpemF0aW9uID09ICd1bmlmb3JtJykge1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5hbHBoYSA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5wYXJhbWV0cml6YXRpb24gPT0gJ2Nob3JkYWwnKSB7XG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmFscGhhID0gMS4wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24ucGFyYW1ldHJpemF0aW9uID0gJ2NlbnRyaXBldGFsJztcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uYWxwaGEgPSAwLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnlBeGlzTGVmdCkge1xuICAgICAgICBpZiAob3B0aW9ucy5kYXRhQXhpcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy55QXhpc0xlZnQuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMuZGF0YUF4aXMpO1xuICAgICAgICAgIHRoaXMueUF4aXNSaWdodC5zZXRPcHRpb25zKHRoaXMub3B0aW9ucy5kYXRhQXhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubGVnZW5kTGVmdCkge1xuICAgICAgICBpZiAob3B0aW9ucy5sZWdlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMubGVnZW5kTGVmdC5zZXRPcHRpb25zKHRoaXMub3B0aW9ucy5sZWdlbmQpO1xuICAgICAgICAgIHRoaXMubGVnZW5kUmlnaHQuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMubGVnZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkoVU5HUk9VUEVEKSkge1xuICAgICAgICB0aGlzLmdyb3Vwc1tVTkdST1VQRURdLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGhpcyBpcyB1c2VkIHRvIHJlZHJhdyB0aGUgZ3JhcGggaWYgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGdyb3VwcyBpcyBjaGFuZ2VkLlxuICAgIGlmICh0aGlzLmRvbS5mcmFtZSkge1xuICAgICAgLy9ub3Qgb24gaW5pdGlhbCBydW4/XG4gICAgICB0aGlzLmZvcmNlR3JhcGhVcGRhdGUgPSB0cnVlO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9jaGFuZ2VcIiwgeyBxdWV1ZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIGNvbXBvbmVudCBmcm9tIHRoZSBET01cbiAgICovXG4gIExpbmVHcmFwaC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyByZW1vdmUgdGhlIGZyYW1lIGNvbnRhaW5pbmcgdGhlIGl0ZW1zXG4gICAgaWYgKHRoaXMuZG9tLmZyYW1lLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZG9tLmZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20uZnJhbWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2hvdyB0aGUgY29tcG9uZW50IGluIHRoZSBET00gKHdoZW4gbm90IGFscmVhZHkgdmlzaWJsZSkuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGNoYW5nZWRcbiAgICovXG4gIExpbmVHcmFwaC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBzaG93IGZyYW1lIGNvbnRhaW5pbmcgdGhlIGl0ZW1zXG4gICAgaWYgKCF0aGlzLmRvbS5mcmFtZS5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmJvZHkuZG9tLmNlbnRlci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5mcmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgaXRlbXNcbiAgICogQHBhcmFtIHt2aXMuRGF0YVNldCB8IG51bGx9IGl0ZW1zXG4gICAqL1xuICBMaW5lR3JhcGgucHJvdG90eXBlLnNldEl0ZW1zID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgaWRzLFxuICAgICAgICBvbGRJdGVtc0RhdGEgPSB0aGlzLml0ZW1zRGF0YTtcblxuICAgIC8vIHJlcGxhY2UgdGhlIGRhdGFzZXRcbiAgICBpZiAoIWl0ZW1zKSB7XG4gICAgICB0aGlzLml0ZW1zRGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChpdGVtcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgaXRlbXMgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgICAgdGhpcy5pdGVtc0RhdGEgPSBpdGVtcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRGF0YSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIERhdGFTZXQgb3IgRGF0YVZpZXcnKTtcbiAgICB9XG5cbiAgICBpZiAob2xkSXRlbXNEYXRhKSB7XG4gICAgICAvLyB1bnN1YnNjcmliZSBmcm9tIG9sZCBkYXRhc2V0XG4gICAgICB1dGlsLmZvckVhY2godGhpcy5pdGVtTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgIG9sZEl0ZW1zRGF0YS5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyByZW1vdmUgYWxsIGRyYXduIGl0ZW1zXG4gICAgICBpZHMgPSBvbGRJdGVtc0RhdGEuZ2V0SWRzKCk7XG4gICAgICB0aGlzLl9vblJlbW92ZShpZHMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLml0ZW1zRGF0YSkge1xuICAgICAgLy8gc3Vic2NyaWJlIHRvIG5ldyBkYXRhc2V0XG4gICAgICB2YXIgaWQgPSB0aGlzLmlkO1xuICAgICAgdXRpbC5mb3JFYWNoKHRoaXMuaXRlbUxpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICBtZS5pdGVtc0RhdGEub24oZXZlbnQsIGNhbGxiYWNrLCBpZCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gYWRkIGFsbCBuZXcgaXRlbXNcbiAgICAgIGlkcyA9IHRoaXMuaXRlbXNEYXRhLmdldElkcygpO1xuICAgICAgdGhpcy5fb25BZGQoaWRzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBncm91cHNcbiAgICogQHBhcmFtIHt2aXMuRGF0YVNldH0gZ3JvdXBzXG4gICAqL1xuICBMaW5lR3JhcGgucHJvdG90eXBlLnNldEdyb3VwcyA9IGZ1bmN0aW9uIChncm91cHMpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBpZHM7XG5cbiAgICAvLyB1bnN1YnNjcmliZSBmcm9tIGN1cnJlbnQgZGF0YXNldFxuICAgIGlmICh0aGlzLmdyb3Vwc0RhdGEpIHtcbiAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLmdyb3VwTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgIG1lLmdyb3Vwc0RhdGEub2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICB9KTtcblxuICAgICAgLy8gcmVtb3ZlIGFsbCBkcmF3biBncm91cHNcbiAgICAgIGlkcyA9IHRoaXMuZ3JvdXBzRGF0YS5nZXRJZHMoKTtcbiAgICAgIHRoaXMuZ3JvdXBzRGF0YSA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9yZW1vdmVHcm91cChpZHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlcGxhY2UgdGhlIGRhdGFzZXRcbiAgICBpZiAoIWdyb3Vwcykge1xuICAgICAgdGhpcy5ncm91cHNEYXRhID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGdyb3VwcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgZ3JvdXBzIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICAgIHRoaXMuZ3JvdXBzRGF0YSA9IGdyb3VwcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRGF0YSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIERhdGFTZXQgb3IgRGF0YVZpZXcnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ncm91cHNEYXRhKSB7XG4gICAgICAvLyBzdWJzY3JpYmUgdG8gbmV3IGRhdGFzZXRcbiAgICAgIHZhciBpZCA9IHRoaXMuaWQ7XG4gICAgICB1dGlsLmZvckVhY2godGhpcy5ncm91cExpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICBtZS5ncm91cHNEYXRhLm9uKGV2ZW50LCBjYWxsYmFjaywgaWQpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGRyYXcgYWxsIG1zXG4gICAgICBpZHMgPSB0aGlzLmdyb3Vwc0RhdGEuZ2V0SWRzKCk7XG4gICAgICB0aGlzLl9vbkFkZEdyb3VwcyhpZHMpO1xuICAgIH1cbiAgfTtcblxuICBMaW5lR3JhcGgucHJvdG90eXBlLl9vblVwZGF0ZSA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICB0aGlzLl91cGRhdGVBbGxHcm91cERhdGEoKTtcbiAgfTtcbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fb25BZGQgPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgdGhpcy5fb25VcGRhdGUoaWRzKTtcbiAgfTtcbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fb25SZW1vdmUgPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgdGhpcy5fb25VcGRhdGUoaWRzKTtcbiAgfTtcbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fb25VcGRhdGVHcm91cHMgPSBmdW5jdGlvbiAoZ3JvdXBJZHMpIHtcbiAgICB0aGlzLl91cGRhdGVBbGxHcm91cERhdGEoKTtcbiAgfTtcbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fb25BZGRHcm91cHMgPSBmdW5jdGlvbiAoZ3JvdXBJZHMpIHtcbiAgICB0aGlzLl9vblVwZGF0ZUdyb3Vwcyhncm91cElkcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIHRoaXMgY2xlYW5zIHRoZSBncm91cCBvdXQgb2ZmIHRoZSBsZWdlbmRzIGFuZCB0aGUgZGF0YWF4aXMsIHVwZGF0ZXMgdGhlIHVuZ3JvdXBlZCBhbmQgdXBkYXRlcyB0aGUgZ3JhcGhcbiAgICogQHBhcmFtIHtBcnJheX0gZ3JvdXBJZHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIExpbmVHcmFwaC5wcm90b3R5cGUuX29uUmVtb3ZlR3JvdXBzID0gZnVuY3Rpb24gKGdyb3VwSWRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fcmVtb3ZlR3JvdXAoZ3JvdXBJZHNbaV0pO1xuICAgIH1cbiAgICB0aGlzLmZvcmNlR3JhcGhVcGRhdGUgPSB0cnVlO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfY2hhbmdlXCIsIHsgcXVldWU6IHRydWUgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIHRoaXMgY2xlYW5zIHRoZSBncm91cCBvdXQgb2ZmIHRoZSBsZWdlbmRzIGFuZCB0aGUgZGF0YWF4aXNcbiAgICogQHBhcmFtIGdyb3VwSWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIExpbmVHcmFwaC5wcm90b3R5cGUuX3JlbW92ZUdyb3VwID0gZnVuY3Rpb24gKGdyb3VwSWQpIHtcbiAgICBpZiAodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkoZ3JvdXBJZCkpIHtcbiAgICAgIGlmICh0aGlzLmdyb3Vwc1tncm91cElkXS5vcHRpb25zLnlBeGlzT3JpZW50YXRpb24gPT0gJ3JpZ2h0Jykge1xuICAgICAgICB0aGlzLnlBeGlzUmlnaHQucmVtb3ZlR3JvdXAoZ3JvdXBJZCk7XG4gICAgICAgIHRoaXMubGVnZW5kUmlnaHQucmVtb3ZlR3JvdXAoZ3JvdXBJZCk7XG4gICAgICAgIHRoaXMubGVnZW5kUmlnaHQucmVkcmF3KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnlBeGlzTGVmdC5yZW1vdmVHcm91cChncm91cElkKTtcbiAgICAgICAgdGhpcy5sZWdlbmRMZWZ0LnJlbW92ZUdyb3VwKGdyb3VwSWQpO1xuICAgICAgICB0aGlzLmxlZ2VuZExlZnQucmVkcmF3KCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5ncm91cHNbZ3JvdXBJZF07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiB1cGRhdGUgYSBncm91cCBvYmplY3Qgd2l0aCB0aGUgZ3JvdXAgZGF0YXNldCBlbnRyZWVcbiAgICpcbiAgICogQHBhcmFtIGdyb3VwXG4gICAqIEBwYXJhbSBncm91cElkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBMaW5lR3JhcGgucHJvdG90eXBlLl91cGRhdGVHcm91cCA9IGZ1bmN0aW9uIChncm91cCwgZ3JvdXBJZCkge1xuICAgIGlmICghdGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkoZ3JvdXBJZCkpIHtcbiAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwSWRdID0gbmV3IEdyYXBoR3JvdXAoZ3JvdXAsIGdyb3VwSWQsIHRoaXMub3B0aW9ucywgdGhpcy5ncm91cHNVc2luZ0RlZmF1bHRTdHlsZXMpO1xuICAgICAgaWYgKHRoaXMuZ3JvdXBzW2dyb3VwSWRdLm9wdGlvbnMueUF4aXNPcmllbnRhdGlvbiA9PSAncmlnaHQnKSB7XG4gICAgICAgIHRoaXMueUF4aXNSaWdodC5hZGRHcm91cChncm91cElkLCB0aGlzLmdyb3Vwc1tncm91cElkXSk7XG4gICAgICAgIHRoaXMubGVnZW5kUmlnaHQuYWRkR3JvdXAoZ3JvdXBJZCwgdGhpcy5ncm91cHNbZ3JvdXBJZF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy55QXhpc0xlZnQuYWRkR3JvdXAoZ3JvdXBJZCwgdGhpcy5ncm91cHNbZ3JvdXBJZF0pO1xuICAgICAgICB0aGlzLmxlZ2VuZExlZnQuYWRkR3JvdXAoZ3JvdXBJZCwgdGhpcy5ncm91cHNbZ3JvdXBJZF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmdyb3Vwc1tncm91cElkXS51cGRhdGUoZ3JvdXApO1xuICAgICAgaWYgKHRoaXMuZ3JvdXBzW2dyb3VwSWRdLm9wdGlvbnMueUF4aXNPcmllbnRhdGlvbiA9PSAncmlnaHQnKSB7XG4gICAgICAgIHRoaXMueUF4aXNSaWdodC51cGRhdGVHcm91cChncm91cElkLCB0aGlzLmdyb3Vwc1tncm91cElkXSk7XG4gICAgICAgIHRoaXMubGVnZW5kUmlnaHQudXBkYXRlR3JvdXAoZ3JvdXBJZCwgdGhpcy5ncm91cHNbZ3JvdXBJZF0pO1xuICAgICAgICAvL0lmIHlBeGlzT3JpZW50YXRpb24gY2hhbmdlZCwgY2xlYW4gb3V0IHRoZSBncm91cCBmcm9tIHRoZSBvdGhlciBheGlzLlxuICAgICAgICB0aGlzLnlBeGlzTGVmdC5yZW1vdmVHcm91cChncm91cElkKTtcbiAgICAgICAgdGhpcy5sZWdlbmRMZWZ0LnJlbW92ZUdyb3VwKGdyb3VwSWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy55QXhpc0xlZnQudXBkYXRlR3JvdXAoZ3JvdXBJZCwgdGhpcy5ncm91cHNbZ3JvdXBJZF0pO1xuICAgICAgICB0aGlzLmxlZ2VuZExlZnQudXBkYXRlR3JvdXAoZ3JvdXBJZCwgdGhpcy5ncm91cHNbZ3JvdXBJZF0pO1xuICAgICAgICAvL0lmIHlBeGlzT3JpZW50YXRpb24gY2hhbmdlZCwgY2xlYW4gb3V0IHRoZSBncm91cCBmcm9tIHRoZSBvdGhlciBheGlzLlxuICAgICAgICB0aGlzLnlBeGlzUmlnaHQucmVtb3ZlR3JvdXAoZ3JvdXBJZCk7XG4gICAgICAgIHRoaXMubGVnZW5kUmlnaHQucmVtb3ZlR3JvdXAoZ3JvdXBJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGVnZW5kTGVmdC5yZWRyYXcoKTtcbiAgICB0aGlzLmxlZ2VuZFJpZ2h0LnJlZHJhdygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiB0aGlzIHVwZGF0ZXMgYWxsIGdyb3VwcywgaXQgaXMgdXNlZCB3aGVuIHRoZXJlIGlzIGFuIHVwZGF0ZSB0aGUgdGhlIGl0ZW1zZXQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBMaW5lR3JhcGgucHJvdG90eXBlLl91cGRhdGVBbGxHcm91cERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXRlbXNEYXRhICE9IG51bGwpIHtcbiAgICAgIHZhciBncm91cHNDb250ZW50ID0ge307XG4gICAgICB2YXIgaXRlbXMgPSB0aGlzLml0ZW1zRGF0YS5nZXQoKTtcbiAgICAgIC8vcHJlLURldGVybWluZSBhcnJheSBzaXplcywgZm9yIG1vcmUgZWZmaWNpZW50IG1lbW9yeSBjbGFpbVxuICAgICAgdmFyIGdyb3VwQ291bnRzID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIHZhciBncm91cElkID0gaXRlbS5ncm91cDtcbiAgICAgICAgaWYgKGdyb3VwSWQgPT09IG51bGwgfHwgZ3JvdXBJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZ3JvdXBJZCA9IFVOR1JPVVBFRDtcbiAgICAgICAgfVxuICAgICAgICBncm91cENvdW50cy5oYXNPd25Qcm9wZXJ0eShncm91cElkKSA/IGdyb3VwQ291bnRzW2dyb3VwSWRdKysgOiBncm91cENvdW50c1tncm91cElkXSA9IDE7XG4gICAgICB9XG4gICAgICAvL05vdyBpbnNlcnQgZGF0YSBpbnRvIHRoZSBhcnJheXMuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIHZhciBncm91cElkID0gaXRlbS5ncm91cDtcbiAgICAgICAgaWYgKGdyb3VwSWQgPT09IG51bGwgfHwgZ3JvdXBJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZ3JvdXBJZCA9IFVOR1JPVVBFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWdyb3Vwc0NvbnRlbnQuaGFzT3duUHJvcGVydHkoZ3JvdXBJZCkpIHtcbiAgICAgICAgICBncm91cHNDb250ZW50W2dyb3VwSWRdID0gbmV3IEFycmF5KGdyb3VwQ291bnRzW2dyb3VwSWRdKTtcbiAgICAgICAgfVxuICAgICAgICAvL0NvcHkgZGF0YSAoYmVjYXVzZSBvZiB1bm1vZGlmaWFibGUgRGF0YVZpZXcgaW5wdXQuXG4gICAgICAgIHZhciBleHRlbmRlZCA9IHV0aWwuYnJpZGdlT2JqZWN0KGl0ZW0pO1xuICAgICAgICBleHRlbmRlZC54ID0gdXRpbC5jb252ZXJ0KGl0ZW0ueCwgJ0RhdGUnKTtcbiAgICAgICAgZXh0ZW5kZWQub3JnaW5hbFkgPSBpdGVtLnk7IC8vcmVhbCBZXG4gICAgICAgIGV4dGVuZGVkLnkgPSBOdW1iZXIoaXRlbS55KTtcblxuICAgICAgICB2YXIgaW5kZXggPSBncm91cHNDb250ZW50W2dyb3VwSWRdLmxlbmd0aCAtIGdyb3VwQ291bnRzW2dyb3VwSWRdLS07XG4gICAgICAgIGdyb3Vwc0NvbnRlbnRbZ3JvdXBJZF1baW5kZXhdID0gZXh0ZW5kZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vTWFrZSBzdXJlIGFsbCBncm91cHMgYXJlIHByZXNlbnQsIHRvIGFsbG93IHJlbW92YWwgb2Ygb2xkIGdyb3Vwc1xuICAgICAgZm9yICh2YXIgZ3JvdXBJZCBpbiB0aGlzLmdyb3Vwcykge1xuICAgICAgICBpZiAodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkoZ3JvdXBJZCkpIHtcbiAgICAgICAgICBpZiAoIWdyb3Vwc0NvbnRlbnQuaGFzT3duUHJvcGVydHkoZ3JvdXBJZCkpIHtcbiAgICAgICAgICAgIGdyb3Vwc0NvbnRlbnRbZ3JvdXBJZF0gPSBuZXcgQXJyYXkoMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vVXBkYXRlIGxlZ2VuZGFzLCBzdHlsZSBhbmQgYXhpc1xuICAgICAgZm9yICh2YXIgZ3JvdXBJZCBpbiBncm91cHNDb250ZW50KSB7XG4gICAgICAgIGlmIChncm91cHNDb250ZW50Lmhhc093blByb3BlcnR5KGdyb3VwSWQpKSB7XG4gICAgICAgICAgaWYgKGdyb3Vwc0NvbnRlbnRbZ3JvdXBJZF0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShncm91cElkKSkge1xuICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVHcm91cChncm91cElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JvdXBzRGF0YSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZ3JvdXAgPSB0aGlzLmdyb3Vwc0RhdGEuZ2V0KGdyb3VwSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBncm91cCA9IHsgaWQ6IGdyb3VwSWQsIGNvbnRlbnQ6IHRoaXMub3B0aW9ucy5kZWZhdWx0R3JvdXAgKyBncm91cElkIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVHcm91cChncm91cCwgZ3JvdXBJZCk7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cElkXS5zZXRJdGVtcyhncm91cHNDb250ZW50W2dyb3VwSWRdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZm9yY2VHcmFwaFVwZGF0ZSA9IHRydWU7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2NoYW5nZVwiLCB7IHF1ZXVlOiB0cnVlIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVkcmF3IHRoZSBjb21wb25lbnQsIG1hbmRhdG9yeSBmdW5jdGlvblxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZXNpemVkXG4gICAqL1xuICBMaW5lR3JhcGgucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzaXplZCA9IGZhbHNlO1xuXG4gICAgLy8gY2FsY3VsYXRlIGFjdHVhbCBzaXplIGFuZCBwb3NpdGlvblxuICAgIHRoaXMucHJvcHMud2lkdGggPSB0aGlzLmRvbS5mcmFtZS5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLnByb3BzLmhlaWdodCA9IHRoaXMuYm9keS5kb21Qcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0IC0gdGhpcy5ib2R5LmRvbVByb3BzLmJvcmRlci50b3AgLSB0aGlzLmJvZHkuZG9tUHJvcHMuYm9yZGVyLmJvdHRvbTtcblxuICAgIC8vIGNoZWNrIGlmIHRoaXMgY29tcG9uZW50IGlzIHJlc2l6ZWRcbiAgICByZXNpemVkID0gdGhpcy5faXNSZXNpemVkKCkgfHwgcmVzaXplZDtcblxuICAgIC8vIGNoZWNrIHdoZXRoZXIgem9vbWVkIChpbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byByZS1zdGFjayBldmVyeXRoaW5nKVxuICAgIHZhciB2aXNpYmxlSW50ZXJ2YWwgPSB0aGlzLmJvZHkucmFuZ2UuZW5kIC0gdGhpcy5ib2R5LnJhbmdlLnN0YXJ0O1xuICAgIHZhciB6b29tZWQgPSB2aXNpYmxlSW50ZXJ2YWwgIT0gdGhpcy5sYXN0VmlzaWJsZUludGVydmFsO1xuICAgIHRoaXMubGFzdFZpc2libGVJbnRlcnZhbCA9IHZpc2libGVJbnRlcnZhbDtcblxuICAgIC8vIHRoZSBzdmcgZWxlbWVudCBpcyB0aHJlZSB0aW1lcyBhcyBiaWcgYXMgdGhlIHdpZHRoLCB0aGlzIGFsbG93cyBmb3IgZnVsbHkgZHJhZ2dpbmcgbGVmdCBhbmQgcmlnaHRcbiAgICAvLyB3aXRob3V0IHJlbG9hZGluZyB0aGUgZ3JhcGguIHRoZSBjb250cm9scyBmb3IgdGhpcyBhcmUgYm91bmQgdG8gZXZlbnRzIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgIGlmIChyZXNpemVkID09IHRydWUpIHtcbiAgICAgIHRoaXMuc3ZnLnN0eWxlLndpZHRoID0gdXRpbC5vcHRpb24uYXNTaXplKDMgKiB0aGlzLnByb3BzLndpZHRoKTtcbiAgICAgIHRoaXMuc3ZnLnN0eWxlLmxlZnQgPSB1dGlsLm9wdGlvbi5hc1NpemUoLXRoaXMucHJvcHMud2lkdGgpO1xuXG4gICAgICAvLyBpZiB0aGUgaGVpZ2h0IG9mIHRoZSBncmFwaCBpcyBzZXQgYXMgcHJvcG9ydGlvbmFsLCBjaGFuZ2UgdGhlIGhlaWdodCBvZiB0aGUgc3ZnXG4gICAgICBpZiAoKHRoaXMub3B0aW9ucy5oZWlnaHQgKyAnJykuaW5kZXhPZihcIiVcIikgIT0gLTEgfHwgdGhpcy51cGRhdGVTVkdoZWlnaHRPblJlc2l6ZSA9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU1ZHaGVpZ2h0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGhlIGhlaWdodCBvZiB0aGUgZ3JhcGggb24gZWFjaCByZWRyYXcgb2YgdGhlIGdyYXBoLlxuICAgIGlmICh0aGlzLnVwZGF0ZVNWR2hlaWdodCA9PSB0cnVlKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmdyYXBoSGVpZ2h0ICE9IHRoaXMucHJvcHMuaGVpZ2h0ICsgJ3B4Jykge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZ3JhcGhIZWlnaHQgPSB0aGlzLnByb3BzLmhlaWdodCArICdweCc7XG4gICAgICAgIHRoaXMuc3ZnLnN0eWxlLmhlaWdodCA9IHRoaXMucHJvcHMuaGVpZ2h0ICsgJ3B4JztcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlU1ZHaGVpZ2h0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3ZnLnN0eWxlLmhlaWdodCA9ICgnJyArIHRoaXMub3B0aW9ucy5ncmFwaEhlaWdodCkucmVwbGFjZSgncHgnLCAnJykgKyAncHgnO1xuICAgIH1cblxuICAgIC8vIHpvb21lZCBpcyBoZXJlIHRvIGVuc3VyZSB0aGF0IGFuaW1hdGlvbnMgYXJlIHNob3duIGNvcnJlY3RseS5cbiAgICBpZiAocmVzaXplZCA9PSB0cnVlIHx8IHpvb21lZCA9PSB0cnVlIHx8IHRoaXMuYWJvcnRlZEdyYXBoVXBkYXRlID09IHRydWUgfHwgdGhpcy5mb3JjZUdyYXBoVXBkYXRlID09IHRydWUpIHtcbiAgICAgIHJlc2l6ZWQgPSB0aGlzLl91cGRhdGVHcmFwaCgpIHx8IHJlc2l6ZWQ7XG4gICAgICB0aGlzLmZvcmNlR3JhcGhVcGRhdGUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbW92ZSB0aGUgd2hvbGUgc3ZnIHdoaWxlIGRyYWdnaW5nXG4gICAgICBpZiAodGhpcy5sYXN0U3RhcnQgIT0gMCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5ib2R5LnJhbmdlLnN0YXJ0IC0gdGhpcy5sYXN0U3RhcnQ7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuYm9keS5yYW5nZS5lbmQgLSB0aGlzLmJvZHkucmFuZ2Uuc3RhcnQ7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLndpZHRoICE9IDApIHtcbiAgICAgICAgICB2YXIgcmFuZ2VQZXJQaXhlbEludiA9IHRoaXMucHJvcHMud2lkdGggLyByYW5nZTtcbiAgICAgICAgICB2YXIgeE9mZnNldCA9IG9mZnNldCAqIHJhbmdlUGVyUGl4ZWxJbnY7XG4gICAgICAgICAgdGhpcy5zdmcuc3R5bGUubGVmdCA9IC10aGlzLnByb3BzLndpZHRoIC0geE9mZnNldCArICdweCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sZWdlbmRMZWZ0LnJlZHJhdygpO1xuICAgIHRoaXMubGVnZW5kUmlnaHQucmVkcmF3KCk7XG4gICAgcmV0dXJuIHJlc2l6ZWQ7XG4gIH07XG5cbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fZ2V0U29ydGVkR3JvdXBJZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gZ2V0dGluZyBncm91cCBJZHNcbiAgICB2YXIgZ3JvdXBsaXN0ID0gW107XG4gICAgZm9yICh2YXIgZ3JvdXBJZCBpbiB0aGlzLmdyb3Vwcykge1xuICAgICAgaWYgKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KGdyb3VwSWQpKSB7XG4gICAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXBzW2dyb3VwSWRdO1xuICAgICAgICBpZiAoZ3JvdXAudmlzaWJsZSA9PSB0cnVlICYmICh0aGlzLm9wdGlvbnMuZ3JvdXBzLnZpc2liaWxpdHlbZ3JvdXBJZF0gPT09IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMuZ3JvdXBzLnZpc2liaWxpdHlbZ3JvdXBJZF0gPT0gdHJ1ZSkpIHtcbiAgICAgICAgICBncm91cGxpc3QucHVzaCh7IGlkOiBncm91cElkLCB6SW5kZXg6IGdyb3VwLm9wdGlvbnMuekluZGV4IH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHV0aWwuaW5zZXJ0U29ydChncm91cGxpc3QsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgYXogPSBhLnpJbmRleDtcbiAgICAgIHZhciBieiA9IGIuekluZGV4O1xuICAgICAgaWYgKGF6ID09PSB1bmRlZmluZWQpIGF6ID0gMDtcbiAgICAgIGlmIChieiA9PT0gdW5kZWZpbmVkKSBieiA9IDA7XG4gICAgICByZXR1cm4gYXogPT0gYnogPyAwIDogYXogPCBieiA/IC0xIDogMTtcbiAgICB9KTtcbiAgICB2YXIgZ3JvdXBJZHMgPSBuZXcgQXJyYXkoZ3JvdXBsaXN0Lmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGdyb3VwSWRzW2ldID0gZ3JvdXBsaXN0W2ldLmlkO1xuICAgIH1cbiAgICByZXR1cm4gZ3JvdXBJZHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhbmQgcmVkcmF3IHRoZSBncmFwaC5cbiAgICpcbiAgICovXG4gIExpbmVHcmFwaC5wcm90b3R5cGUuX3VwZGF0ZUdyYXBoID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHJlc2V0IHRoZSBzdmcgZWxlbWVudHNcbiAgICBET011dGlsLnByZXBhcmVFbGVtZW50cyh0aGlzLnN2Z0VsZW1lbnRzKTtcbiAgICBpZiAodGhpcy5wcm9wcy53aWR0aCAhPSAwICYmIHRoaXMuaXRlbXNEYXRhICE9IG51bGwpIHtcbiAgICAgIHZhciBncm91cCwgaTtcbiAgICAgIHZhciBncm91cFJhbmdlcyA9IHt9O1xuICAgICAgdmFyIGNoYW5nZUNhbGxlZCA9IGZhbHNlO1xuICAgICAgLy8gdGhpcyBpcyB0aGUgcmFuZ2Ugb2YgdGhlIFNWRyBjYW52YXNcbiAgICAgIHZhciBtaW5EYXRlID0gdGhpcy5ib2R5LnV0aWwudG9HbG9iYWxUaW1lKC10aGlzLmJvZHkuZG9tUHJvcHMucm9vdC53aWR0aCk7XG4gICAgICB2YXIgbWF4RGF0ZSA9IHRoaXMuYm9keS51dGlsLnRvR2xvYmFsVGltZSgyICogdGhpcy5ib2R5LmRvbVByb3BzLnJvb3Qud2lkdGgpO1xuXG4gICAgICAvLyBnZXR0aW5nIGdyb3VwIElkc1xuICAgICAgdmFyIGdyb3VwSWRzID0gdGhpcy5fZ2V0U29ydGVkR3JvdXBJZHMoKTtcbiAgICAgIGlmIChncm91cElkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBncm91cHNEYXRhID0ge307XG5cbiAgICAgICAgLy8gZmlsbCBncm91cHMgZGF0YSwgdGhpcyBvbmx5IGxvYWRzIHRoZSBkYXRhIHdlIHJlcXVpcmUgYmFzZWQgb24gdGhlIHRpbWV3aW5kb3dcbiAgICAgICAgdGhpcy5fZ2V0UmVsZXZhbnREYXRhKGdyb3VwSWRzLCBncm91cHNEYXRhLCBtaW5EYXRlLCBtYXhEYXRlKTtcblxuICAgICAgICAvLyBhcHBseSBzYW1wbGluZywgaWYgZGlzYWJsZWQsIGl0IHdpbGwgcGFzcyB0aHJvdWdoIHRoaXMgZnVuY3Rpb24uXG4gICAgICAgIHRoaXMuX2FwcGx5U2FtcGxpbmcoZ3JvdXBJZHMsIGdyb3Vwc0RhdGEpO1xuXG4gICAgICAgIC8vIHdlIHRyYW5zZm9ybSB0aGUgWCBjb29yZGluYXRlcyB0byBkZXRlY3QgY29sbGlzaW9uc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl9jb252ZXJ0WGNvb3JkaW5hdGVzKGdyb3Vwc0RhdGFbZ3JvdXBJZHNbaV1dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdyBhbGwgbmVlZGVkIGRhdGEgaGFzIGJlZW4gY29sbGVjdGVkIHdlIHN0YXJ0IHRoZSBwcm9jZXNzaW5nLlxuICAgICAgICB0aGlzLl9nZXRZUmFuZ2VzKGdyb3VwSWRzLCBncm91cHNEYXRhLCBncm91cFJhbmdlcyk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBZIGF4aXMgZmlyc3QsIHdlIHVzZSB0aGlzIGRhdGEgdG8gZHJhdyBhdCB0aGUgY29ycmVjdCBZIHBvaW50c1xuICAgICAgICBjaGFuZ2VDYWxsZWQgPSB0aGlzLl91cGRhdGVZQXhpcyhncm91cElkcywgZ3JvdXBSYW5nZXMpO1xuXG4gICAgICAgIC8vICBhdCBjaGFuZ2VDYWxsZWQsIGFib3J0IHRoaXMgdXBkYXRlIGN5Y2xlIGFzIHRoZSBncmFwaCBuZWVkcyBhbm90aGVyIHVwZGF0ZSB3aXRoIG5ldyBXaWR0aCBpbnB1dCBmcm9tIHRoZSBSZWRyYXcgY29udGFpbmVyLlxuICAgICAgICAvLyAgQ2xlYW51cCBTVkcgZWxlbWVudHMgb24gYWJvcnQuXG4gICAgICAgIGlmIChjaGFuZ2VDYWxsZWQgPT0gdHJ1ZSkge1xuICAgICAgICAgIERPTXV0aWwuY2xlYW51cEVsZW1lbnRzKHRoaXMuc3ZnRWxlbWVudHMpO1xuICAgICAgICAgIHRoaXMuYWJvcnRlZEdyYXBoVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFib3J0ZWRHcmFwaFVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFdpdGggdGhlIHlBeGlzIHNjYWxlZCBjb3JyZWN0bHksIHVzZSB0aGlzIHRvIGdldCB0aGUgWSB2YWx1ZXMgb2YgdGhlIHBvaW50cy5cbiAgICAgICAgdmFyIGJlbG93ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBncm91cCA9IHRoaXMuZ3JvdXBzW2dyb3VwSWRzW2ldXTtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0YWNrID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5zdHlsZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICBpZiAoZ3JvdXAub3B0aW9ucy5leGNsdWRlRnJvbVN0YWNraW5nID09IHVuZGVmaW5lZCB8fCAhZ3JvdXAub3B0aW9ucy5leGNsdWRlRnJvbVN0YWNraW5nKSB7XG4gICAgICAgICAgICAgIGlmIChiZWxvdyAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFjayhncm91cHNEYXRhW2dyb3VwLmlkXSwgZ3JvdXBzRGF0YVtiZWxvdy5pZF0pO1xuICAgICAgICAgICAgICAgIGlmIChncm91cC5vcHRpb25zLnNoYWRlZC5lbmFibGVkID09IHRydWUgJiYgZ3JvdXAub3B0aW9ucy5zaGFkZWQub3JpZW50YXRpb24gIT09IFwiZ3JvdXBcIikge1xuICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuc2hhZGVkLm9yaWVudGF0aW9uID09IFwidG9wXCIgJiYgYmVsb3cub3B0aW9ucy5zaGFkZWQub3JpZW50YXRpb24gIT09IFwiZ3JvdXBcIikge1xuICAgICAgICAgICAgICAgICAgICBiZWxvdy5vcHRpb25zLnNoYWRlZC5vcmllbnRhdGlvbiA9IFwiZ3JvdXBcIjtcbiAgICAgICAgICAgICAgICAgICAgYmVsb3cub3B0aW9ucy5zaGFkZWQuZ3JvdXBJZCA9IGdyb3VwLmlkO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAub3B0aW9ucy5zaGFkZWQub3JpZW50YXRpb24gPSBcImdyb3VwXCI7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLm9wdGlvbnMuc2hhZGVkLmdyb3VwSWQgPSBiZWxvdy5pZDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYmVsb3cgPSBncm91cDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fY29udmVydFljb29yZGluYXRlcyhncm91cHNEYXRhW2dyb3VwSWRzW2ldXSwgZ3JvdXApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9QcmVjYWxjdWxhdGUgcGF0aHMgYW5kIGRyYXcgc2hhZGluZyBpZiBhcHByb3ByaWF0ZS4gVGhpcyB3aWxsIG1ha2Ugc3VyZSB0aGUgc2hhZGluZyBpcyBhbHdheXMgYmVoaW5kIGFueSBsaW5lcy5cbiAgICAgICAgdmFyIHBhdGhzID0ge307XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBncm91cElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZHNbaV1dO1xuICAgICAgICAgIGlmIChncm91cC5vcHRpb25zLnN0eWxlID09PSAnbGluZScgJiYgZ3JvdXAub3B0aW9ucy5zaGFkZWQuZW5hYmxlZCA9PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YXNldCA9IGdyb3Vwc0RhdGFbZ3JvdXBJZHNbaV1dO1xuICAgICAgICAgICAgaWYgKGRhdGFzZXQgPT0gbnVsbCB8fCBkYXRhc2V0Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwYXRocy5oYXNPd25Qcm9wZXJ0eShncm91cElkc1tpXSkpIHtcbiAgICAgICAgICAgICAgcGF0aHNbZ3JvdXBJZHNbaV1dID0gTGluZXMuY2FsY1BhdGgoZGF0YXNldCwgZ3JvdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuc2hhZGVkLm9yaWVudGF0aW9uID09PSBcImdyb3VwXCIpIHtcbiAgICAgICAgICAgICAgdmFyIHN1Ykdyb3VwSWQgPSBncm91cC5vcHRpb25zLnNoYWRlZC5ncm91cElkO1xuICAgICAgICAgICAgICBpZiAoZ3JvdXBJZHMuaW5kZXhPZihzdWJHcm91cElkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhncm91cC5pZCArIFwiOiBVbmtub3duIHNoYWRpbmcgZ3JvdXAgdGFyZ2V0IGdpdmVuOlwiICsgc3ViR3JvdXBJZCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFwYXRocy5oYXNPd25Qcm9wZXJ0eShzdWJHcm91cElkKSkge1xuICAgICAgICAgICAgICAgIHBhdGhzW3N1Ykdyb3VwSWRdID0gTGluZXMuY2FsY1BhdGgoZ3JvdXBzRGF0YVtzdWJHcm91cElkXSwgdGhpcy5ncm91cHNbc3ViR3JvdXBJZF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIExpbmVzLmRyYXdTaGFkaW5nKHBhdGhzW2dyb3VwSWRzW2ldXSwgZ3JvdXAsIHBhdGhzW3N1Ykdyb3VwSWRdLCB0aGlzLmZyYW1ld29yayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBMaW5lcy5kcmF3U2hhZGluZyhwYXRoc1tncm91cElkc1tpXV0sIGdyb3VwLCB1bmRlZmluZWQsIHRoaXMuZnJhbWV3b3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkcmF3IHRoZSBncm91cHMsIGNhbGN1bGF0aW5nIHBhdGhzIGlmIHN0aWxsIG5lY2Vzc2FyeS5cbiAgICAgICAgQmFycy5kcmF3KGdyb3VwSWRzLCBncm91cHNEYXRhLCB0aGlzLmZyYW1ld29yayk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBncm91cElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZHNbaV1dO1xuICAgICAgICAgIGlmIChncm91cHNEYXRhW2dyb3VwSWRzW2ldXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGdyb3VwLm9wdGlvbnMuc3R5bGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImxpbmVcIjpcbiAgICAgICAgICAgICAgICBpZiAoIXBhdGhzLmhhc093blByb3BlcnR5KGdyb3VwSWRzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgcGF0aHNbZ3JvdXBJZHNbaV1dID0gTGluZXMuY2FsY1BhdGgoZ3JvdXBzRGF0YVtncm91cElkc1tpXV0sIGdyb3VwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgTGluZXMuZHJhdyhwYXRoc1tncm91cElkc1tpXV0sIGdyb3VwLCB0aGlzLmZyYW1ld29yayk7XG4gICAgICAgICAgICAgIC8vZXhwbGljaXQgbm8gYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJwb2ludFwiOlxuICAgICAgICAgICAgICAvL2V4cGxpY2l0IG5vIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwicG9pbnRzXCI6XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuc3R5bGUgPT0gXCJwb2ludFwiIHx8IGdyb3VwLm9wdGlvbnMuc3R5bGUgPT0gXCJwb2ludHNcIiB8fCBncm91cC5vcHRpb25zLmRyYXdQb2ludHMuZW5hYmxlZCA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICBQb2ludHMuZHJhdyhncm91cHNEYXRhW2dyb3VwSWRzW2ldXSwgZ3JvdXAsIHRoaXMuZnJhbWV3b3JrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJiYXJcIjpcbiAgICAgICAgICAgICAgLy8gYmFyIG5lZWRzIHRvIGJlIGRyYXduIGVubWFzc2VcbiAgICAgICAgICAgICAgLy9leHBsaWNpdCBubyBicmVha1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvL2RvIG5vdGhpbmcuLi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjbGVhbnVwIHVudXNlZCBzdmcgZWxlbWVudHNcbiAgICBET011dGlsLmNsZWFudXBFbGVtZW50cyh0aGlzLnN2Z0VsZW1lbnRzKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fc3RhY2sgPSBmdW5jdGlvbiAoZGF0YSwgc3ViRGF0YSkge1xuICAgIHZhciBpbmRleCwgZHgsIGR5LCBzdWJQcmV2UG9pbnQsIHN1Yk5leHRQb2ludDtcbiAgICBpbmRleCA9IDA7XG4gICAgLy8gZm9yIGVhY2ggZGF0YSBwb2ludCB3ZSBsb29rIGZvciBhIG1hdGNoaW5nIG9uIGluIHRoZSBzZXQgYmVsb3dcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgIHN1YlByZXZQb2ludCA9IHVuZGVmaW5lZDtcbiAgICAgIHN1Yk5leHRQb2ludCA9IHVuZGVmaW5lZDtcbiAgICAgIC8vIHdlIGxvb2sgZm9yIHRpbWUgbWF0Y2hlcyBvciBhIGJlZm9yZS1hZnRlciBwb2ludFxuICAgICAgZm9yICh2YXIgayA9IGluZGV4OyBrIDwgc3ViRGF0YS5sZW5ndGg7IGsrKykge1xuICAgICAgICAvLyBpZiB0aW1lcyBtYXRjaCBleGFjdGx5XG4gICAgICAgIGlmIChzdWJEYXRhW2tdLnggPT09IGRhdGFbal0ueCkge1xuICAgICAgICAgIHN1YlByZXZQb2ludCA9IHN1YkRhdGFba107XG4gICAgICAgICAgc3ViTmV4dFBvaW50ID0gc3ViRGF0YVtrXTtcbiAgICAgICAgICBpbmRleCA9IGs7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoc3ViRGF0YVtrXS54ID4gZGF0YVtqXS54KSB7XG4gICAgICAgICAgLy8gb3ZlcnNob290XG4gICAgICAgICAgc3ViTmV4dFBvaW50ID0gc3ViRGF0YVtrXTtcbiAgICAgICAgICBpZiAoayA9PSAwKSB7XG4gICAgICAgICAgICBzdWJQcmV2UG9pbnQgPSBzdWJOZXh0UG9pbnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YlByZXZQb2ludCA9IHN1YkRhdGFbayAtIDFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbmRleCA9IGs7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGluIGNhc2UgdGhlIGxhc3QgZGF0YSBwb2ludCBoYXMgYmVlbiB1c2VkLCB3ZSBhc3N1bWUgaXQgc3RheXMgbGlrZSB0aGlzLlxuICAgICAgaWYgKHN1Yk5leHRQb2ludCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN1YlByZXZQb2ludCA9IHN1YkRhdGFbc3ViRGF0YS5sZW5ndGggLSAxXTtcbiAgICAgICAgc3ViTmV4dFBvaW50ID0gc3ViRGF0YVtzdWJEYXRhLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuICAgICAgLy8gbGluZWFyIGludGVycG9sYXRpb25cbiAgICAgIGR4ID0gc3ViTmV4dFBvaW50LnggLSBzdWJQcmV2UG9pbnQueDtcbiAgICAgIGR5ID0gc3ViTmV4dFBvaW50LnkgLSBzdWJQcmV2UG9pbnQueTtcbiAgICAgIGlmIChkeCA9PSAwKSB7XG4gICAgICAgIGRhdGFbal0ueSA9IGRhdGFbal0ub3JnaW5hbFkgKyBzdWJOZXh0UG9pbnQueTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFbal0ueSA9IGRhdGFbal0ub3JnaW5hbFkgKyBkeSAvIGR4ICogKGRhdGFbal0ueCAtIHN1YlByZXZQb2ludC54KSArIHN1YlByZXZQb2ludC55OyAvLyBheCArIGIgd2hlcmUgYiBpcyBkYXRhW2pdLnlcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIGZpcnN0IHNlbGVjdCBhbmQgcHJlcHJvY2VzcyB0aGUgZGF0YSBmcm9tIHRoZSBkYXRhc2V0cy5cbiAgICogdGhlIGdyb3VwcyBoYXZlIHRoZWlyIHByZXNlbGVjdGlvbiBvZiBkYXRhLCB3ZSBub3cgbG9vcCBvdmVyIHRoaXMgZGF0YSB0byBzZWVcbiAgICogd2hhdCBkYXRhIHdlIG5lZWQgdG8gZHJhdy4gU29ydGVkIGRhdGEgaXMgbXVjaCBmYXN0ZXIuXG4gICAqIG1vcmUgb3B0aW1pemF0aW9uIGlzIHBvc3NpYmxlIGJ5IGRvaW5nIHRoZSBzYW1wbGluZyBiZWZvcmUgYW5kIHVzaW5nIHRoZSBiaW5hcnkgc2VhcmNoXG4gICAqIHRvIGZpbmQgdGhlIGVuZCBkYXRlIHRvIGRldGVybWluZSB0aGUgaW5jcmVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5fSAgZ3JvdXBJZHNcbiAgICogQHBhcmFtIHtvYmplY3R9IGdyb3Vwc0RhdGFcbiAgICogQHBhcmFtIHtkYXRlfSAgIG1pbkRhdGVcbiAgICogQHBhcmFtIHtkYXRlfSAgIG1heERhdGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIExpbmVHcmFwaC5wcm90b3R5cGUuX2dldFJlbGV2YW50RGF0YSA9IGZ1bmN0aW9uIChncm91cElkcywgZ3JvdXBzRGF0YSwgbWluRGF0ZSwgbWF4RGF0ZSkge1xuICAgIHZhciBncm91cCwgaSwgaiwgaXRlbTtcbiAgICBpZiAoZ3JvdXBJZHMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGdyb3VwSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZHNbaV1dO1xuICAgICAgICB2YXIgaXRlbXNEYXRhID0gZ3JvdXAuZ2V0SXRlbXMoKTtcbiAgICAgICAgLy8gb3B0aW1pemF0aW9uIGZvciBzb3J0ZWQgZGF0YVxuICAgICAgICBpZiAoZ3JvdXAub3B0aW9ucy5zb3J0ID09IHRydWUpIHtcbiAgICAgICAgICB2YXIgZGF0ZUNvbXBhcmF0b3IgPSBmdW5jdGlvbiBkYXRlQ29tcGFyYXRvcihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5nZXRUaW1lKCkgPT0gYi5nZXRUaW1lKCkgPyAwIDogYSA8IGIgPyAtMSA6IDE7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgZmlyc3QgPSBNYXRoLm1heCgwLCB1dGlsLmJpbmFyeVNlYXJjaFZhbHVlKGl0ZW1zRGF0YSwgbWluRGF0ZSwgJ3gnLCAnYmVmb3JlJywgZGF0ZUNvbXBhcmF0b3IpKTtcbiAgICAgICAgICB2YXIgbGFzdCA9IE1hdGgubWluKGl0ZW1zRGF0YS5sZW5ndGgsIHV0aWwuYmluYXJ5U2VhcmNoVmFsdWUoaXRlbXNEYXRhLCBtYXhEYXRlLCAneCcsICdhZnRlcicsIGRhdGVDb21wYXJhdG9yKSArIDEpO1xuICAgICAgICAgIGlmIChsYXN0IDw9IDApIHtcbiAgICAgICAgICAgIGxhc3QgPSBpdGVtc0RhdGEubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGF0YUNvbnRhaW5lciA9IG5ldyBBcnJheShsYXN0IC0gZmlyc3QpO1xuICAgICAgICAgIGZvciAoaiA9IGZpcnN0OyBqIDwgbGFzdDsgaisrKSB7XG4gICAgICAgICAgICBpdGVtID0gZ3JvdXAuaXRlbXNEYXRhW2pdO1xuICAgICAgICAgICAgZGF0YUNvbnRhaW5lcltqIC0gZmlyc3RdID0gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ3JvdXBzRGF0YVtncm91cElkc1tpXV0gPSBkYXRhQ29udGFpbmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHVuc29ydGVkIGRhdGEsIGFsbCBkYXRhIGlzIHJlbGV2YW50LCBqdXN0IHJldHVybmluZyBlbnRpcmUgc3RydWN0dXJlXG4gICAgICAgICAgZ3JvdXBzRGF0YVtncm91cElkc1tpXV0gPSBncm91cC5pdGVtc0RhdGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBncm91cElkc1xuICAgKiBAcGFyYW0gZ3JvdXBzRGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fYXBwbHlTYW1wbGluZyA9IGZ1bmN0aW9uIChncm91cElkcywgZ3JvdXBzRGF0YSkge1xuICAgIHZhciBncm91cDtcbiAgICBpZiAoZ3JvdXBJZHMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBncm91cCA9IHRoaXMuZ3JvdXBzW2dyb3VwSWRzW2ldXTtcbiAgICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuc2FtcGxpbmcgPT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBkYXRhQ29udGFpbmVyID0gZ3JvdXBzRGF0YVtncm91cElkc1tpXV07XG4gICAgICAgICAgaWYgKGRhdGFDb250YWluZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGluY3JlbWVudCA9IDE7XG4gICAgICAgICAgICB2YXIgYW1vdW50T2ZQb2ludHMgPSBkYXRhQ29udGFpbmVyLmxlbmd0aDtcblxuICAgICAgICAgICAgLy8gdGhlIGdsb2JhbCBzY3JlZW4gaXMgdXNlZCBiZWNhdXNlIGNoYW5naW5nIHRoZSB3aWR0aCBvZiB0aGUgeUF4aXMgbWF5IGFmZmVjdCB0aGUgaW5jcmVtZW50LCByZXN1bHRpbmcgaW4gYW4gZW5kbGVzcyBsb29wXG4gICAgICAgICAgICAvLyBvZiB3aWR0aCBjaGFuZ2luZyBvZiB0aGUgeUF4aXMuXG4gICAgICAgICAgICB2YXIgeERpc3RhbmNlID0gdGhpcy5ib2R5LnV0aWwudG9HbG9iYWxTY3JlZW4oZGF0YUNvbnRhaW5lcltkYXRhQ29udGFpbmVyLmxlbmd0aCAtIDFdLngpIC0gdGhpcy5ib2R5LnV0aWwudG9HbG9iYWxTY3JlZW4oZGF0YUNvbnRhaW5lclswXS54KTtcbiAgICAgICAgICAgIHZhciBwb2ludHNQZXJQaXhlbCA9IGFtb3VudE9mUG9pbnRzIC8geERpc3RhbmNlO1xuICAgICAgICAgICAgaW5jcmVtZW50ID0gTWF0aC5taW4oTWF0aC5jZWlsKDAuMiAqIGFtb3VudE9mUG9pbnRzKSwgTWF0aC5tYXgoMSwgTWF0aC5yb3VuZChwb2ludHNQZXJQaXhlbCkpKTtcblxuICAgICAgICAgICAgdmFyIHNhbXBsZWREYXRhID0gbmV3IEFycmF5KGFtb3VudE9mUG9pbnRzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYW1vdW50T2ZQb2ludHM7IGogKz0gaW5jcmVtZW50KSB7XG4gICAgICAgICAgICAgIHZhciBpZHggPSBNYXRoLnJvdW5kKGogLyBpbmNyZW1lbnQpO1xuICAgICAgICAgICAgICBzYW1wbGVkRGF0YVtpZHhdID0gZGF0YUNvbnRhaW5lcltqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyb3Vwc0RhdGFbZ3JvdXBJZHNbaV1dID0gc2FtcGxlZERhdGEuc3BsaWNlKDAsIE1hdGgucm91bmQoYW1vdW50T2ZQb2ludHMgLyBpbmNyZW1lbnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXl9ICBncm91cElkc1xuICAgKiBAcGFyYW0ge29iamVjdH0gZ3JvdXBzRGF0YVxuICAgKiBAcGFyYW0ge29iamVjdH0gZ3JvdXBSYW5nZXMgIHwgdGhpcyBpcyBiZWluZyBmaWxsZWQgaGVyZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fZ2V0WVJhbmdlcyA9IGZ1bmN0aW9uIChncm91cElkcywgZ3JvdXBzRGF0YSwgZ3JvdXBSYW5nZXMpIHtcbiAgICB2YXIgZ3JvdXBEYXRhLCBncm91cCwgaTtcbiAgICB2YXIgY29tYmluZWREYXRhTGVmdCA9IFtdO1xuICAgIHZhciBjb21iaW5lZERhdGFSaWdodCA9IFtdO1xuICAgIHZhciBvcHRpb25zO1xuICAgIGlmIChncm91cElkcy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ3JvdXBEYXRhID0gZ3JvdXBzRGF0YVtncm91cElkc1tpXV07XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLmdyb3Vwc1tncm91cElkc1tpXV0ub3B0aW9ucztcbiAgICAgICAgaWYgKGdyb3VwRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cElkc1tpXV07XG4gICAgICAgICAgLy8gaWYgYmFyIGdyYXBocyBhcmUgc3RhY2tlZCwgdGhlaXIgcmFuZ2UgbmVlZCB0byBiZSBoYW5kbGVkIGRpZmZlcmVudGx5IGFuZCBhY2N1bXVsYXRlZCBvdmVyIGFsbCBncm91cHMuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuc3RhY2sgPT09IHRydWUgJiYgb3B0aW9ucy5zdHlsZSA9PT0gJ2JhcicpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnlBeGlzT3JpZW50YXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICBjb21iaW5lZERhdGFMZWZ0ID0gY29tYmluZWREYXRhTGVmdC5jb25jYXQoZ3JvdXAuZ2V0SXRlbXMoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb21iaW5lZERhdGFSaWdodCA9IGNvbWJpbmVkRGF0YVJpZ2h0LmNvbmNhdChncm91cC5nZXRJdGVtcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JvdXBSYW5nZXNbZ3JvdXBJZHNbaV1dID0gZ3JvdXAuZ2V0WVJhbmdlKGdyb3VwRGF0YSwgZ3JvdXBJZHNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBpZiBiYXIgZ3JhcGhzIGFyZSBzdGFja2VkLCB0aGVpciByYW5nZSBuZWVkIHRvIGJlIGhhbmRsZWQgZGlmZmVyZW50bHkgYW5kIGFjY3VtdWxhdGVkIG92ZXIgYWxsIGdyb3Vwcy5cbiAgICAgIEJhcnMuZ2V0U3RhY2tlZFlSYW5nZShjb21iaW5lZERhdGFMZWZ0LCBncm91cFJhbmdlcywgZ3JvdXBJZHMsICdfX2JhclN0YWNrTGVmdCcsICdsZWZ0Jyk7XG4gICAgICBCYXJzLmdldFN0YWNrZWRZUmFuZ2UoY29tYmluZWREYXRhUmlnaHQsIGdyb3VwUmFuZ2VzLCBncm91cElkcywgJ19fYmFyU3RhY2tSaWdodCcsICdyaWdodCcpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogdGhpcyBzZXRzIHRoZSBZIHJhbmdlcyBmb3IgdGhlIFkgYXhpcy4gSXQgYWxzbyBkZXRlcm1pbmVzIHdoaWNoIG9mIHRoZSBheGlzIHNob3VsZCBiZSBzaG93biBvciBoaWRkZW4uXG4gICAqIEBwYXJhbSB7QXJyYXl9IGdyb3VwSWRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBncm91cFJhbmdlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fdXBkYXRlWUF4aXMgPSBmdW5jdGlvbiAoZ3JvdXBJZHMsIGdyb3VwUmFuZ2VzKSB7XG4gICAgdmFyIHJlc2l6ZWQgPSBmYWxzZTtcbiAgICB2YXIgeUF4aXNMZWZ0VXNlZCA9IGZhbHNlO1xuICAgIHZhciB5QXhpc1JpZ2h0VXNlZCA9IGZhbHNlO1xuICAgIHZhciBtaW5MZWZ0ID0gMWU5LFxuICAgICAgICBtaW5SaWdodCA9IDFlOSxcbiAgICAgICAgbWF4TGVmdCA9IC0xZTksXG4gICAgICAgIG1heFJpZ2h0ID0gLTFlOSxcbiAgICAgICAgbWluVmFsLFxuICAgICAgICBtYXhWYWw7XG4gICAgLy8gaWYgZ3JvdXBzIGFyZSBwcmVzZW50XG4gICAgaWYgKGdyb3VwSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIHRoaXMgaXMgaGVyZSB0byBtYWtlIHN1cmUgdGhhdCBpZiB0aGVyZSBhcmUgbm8gaXRlbXMgaW4gdGhlIGF4aXMgYnV0IHRoZXJlIGFyZSBncm91cHMsIHRoYXQgdGhlcmUgaXMgbm8gaW5maW5pdGUgZHJhdy9yZWRyYXcgbG9vcC5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZHNbaV1dO1xuICAgICAgICBpZiAoZ3JvdXAgJiYgZ3JvdXAub3B0aW9ucy55QXhpc09yaWVudGF0aW9uICE9ICdyaWdodCcpIHtcbiAgICAgICAgICB5QXhpc0xlZnRVc2VkID0gdHJ1ZTtcbiAgICAgICAgICBtaW5MZWZ0ID0gMWU5O1xuICAgICAgICAgIG1heExlZnQgPSAtMWU5O1xuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwICYmIGdyb3VwLm9wdGlvbnMueUF4aXNPcmllbnRhdGlvbikge1xuICAgICAgICAgIHlBeGlzUmlnaHRVc2VkID0gdHJ1ZTtcbiAgICAgICAgICBtaW5SaWdodCA9IDFlOTtcbiAgICAgICAgICBtYXhSaWdodCA9IC0xZTk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlcmUgYXJlIGl0ZW1zOlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZ3JvdXBSYW5nZXMuaGFzT3duUHJvcGVydHkoZ3JvdXBJZHNbaV0pKSB7XG4gICAgICAgICAgaWYgKGdyb3VwUmFuZ2VzW2dyb3VwSWRzW2ldXS5pZ25vcmUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIG1pblZhbCA9IGdyb3VwUmFuZ2VzW2dyb3VwSWRzW2ldXS5taW47XG4gICAgICAgICAgICBtYXhWYWwgPSBncm91cFJhbmdlc1tncm91cElkc1tpXV0ubWF4O1xuXG4gICAgICAgICAgICBpZiAoZ3JvdXBSYW5nZXNbZ3JvdXBJZHNbaV1dLnlBeGlzT3JpZW50YXRpb24gIT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICB5QXhpc0xlZnRVc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgbWluTGVmdCA9IG1pbkxlZnQgPiBtaW5WYWwgPyBtaW5WYWwgOiBtaW5MZWZ0O1xuICAgICAgICAgICAgICBtYXhMZWZ0ID0gbWF4TGVmdCA8IG1heFZhbCA/IG1heFZhbCA6IG1heExlZnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB5QXhpc1JpZ2h0VXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgIG1pblJpZ2h0ID0gbWluUmlnaHQgPiBtaW5WYWwgPyBtaW5WYWwgOiBtaW5SaWdodDtcbiAgICAgICAgICAgICAgbWF4UmlnaHQgPSBtYXhSaWdodCA8IG1heFZhbCA/IG1heFZhbCA6IG1heFJpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoeUF4aXNMZWZ0VXNlZCA9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMueUF4aXNMZWZ0LnNldFJhbmdlKG1pbkxlZnQsIG1heExlZnQpO1xuICAgICAgfVxuICAgICAgaWYgKHlBeGlzUmlnaHRVc2VkID09IHRydWUpIHtcbiAgICAgICAgdGhpcy55QXhpc1JpZ2h0LnNldFJhbmdlKG1pblJpZ2h0LCBtYXhSaWdodCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc2l6ZWQgPSB0aGlzLl90b2dnbGVBeGlzVmlzaWJsaXR5KHlBeGlzTGVmdFVzZWQsIHRoaXMueUF4aXNMZWZ0KSB8fCByZXNpemVkO1xuICAgIHJlc2l6ZWQgPSB0aGlzLl90b2dnbGVBeGlzVmlzaWJsaXR5KHlBeGlzUmlnaHRVc2VkLCB0aGlzLnlBeGlzUmlnaHQpIHx8IHJlc2l6ZWQ7XG5cbiAgICBpZiAoeUF4aXNSaWdodFVzZWQgPT0gdHJ1ZSAmJiB5QXhpc0xlZnRVc2VkID09IHRydWUpIHtcbiAgICAgIHRoaXMueUF4aXNMZWZ0LmRyYXdJY29ucyA9IHRydWU7XG4gICAgICB0aGlzLnlBeGlzUmlnaHQuZHJhd0ljb25zID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy55QXhpc0xlZnQuZHJhd0ljb25zID0gZmFsc2U7XG4gICAgICB0aGlzLnlBeGlzUmlnaHQuZHJhd0ljb25zID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMueUF4aXNSaWdodC5tYXN0ZXIgPSAheUF4aXNMZWZ0VXNlZDtcbiAgICB0aGlzLnlBeGlzUmlnaHQubWFzdGVyQXhpcyA9IHRoaXMueUF4aXNMZWZ0O1xuXG4gICAgaWYgKHRoaXMueUF4aXNSaWdodC5tYXN0ZXIgPT0gZmFsc2UpIHtcbiAgICAgIGlmICh5QXhpc1JpZ2h0VXNlZCA9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMueUF4aXNMZWZ0LmxpbmVPZmZzZXQgPSB0aGlzLnlBeGlzUmlnaHQud2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnlBeGlzTGVmdC5saW5lT2Zmc2V0ID0gMDtcbiAgICAgIH1cblxuICAgICAgcmVzaXplZCA9IHRoaXMueUF4aXNMZWZ0LnJlZHJhdygpIHx8IHJlc2l6ZWQ7XG4gICAgICByZXNpemVkID0gdGhpcy55QXhpc1JpZ2h0LnJlZHJhdygpIHx8IHJlc2l6ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc2l6ZWQgPSB0aGlzLnlBeGlzUmlnaHQucmVkcmF3KCkgfHwgcmVzaXplZDtcbiAgICB9XG5cbiAgICAvLyBjbGVhbiB0aGUgYWNjdW11bGF0ZWQgbGlzdHNcbiAgICB2YXIgdGVtcEdyb3VwcyA9IFsnX19iYXJTdGFja0xlZnQnLCAnX19iYXJTdGFja1JpZ2h0JywgJ19fbGluZVN0YWNrTGVmdCcsICdfX2xpbmVTdGFja1JpZ2h0J107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wR3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZ3JvdXBJZHMuaW5kZXhPZih0ZW1wR3JvdXBzW2ldKSAhPSAtMSkge1xuICAgICAgICBncm91cElkcy5zcGxpY2UoZ3JvdXBJZHMuaW5kZXhPZih0ZW1wR3JvdXBzW2ldKSwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc2l6ZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgc2hvd3Mgb3IgaGlkZXMgdGhlIFkgYXhpcyBpZiBuZWVkZWQuIElmIHRoZXJlIGlzIGEgY2hhbmdlLCB0aGUgY2hhbmdlZCBldmVudCBpcyBlbWl0dGVkIGJ5IHRoZSB1cGRhdGVZQXhpcyBmdW5jdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGF4aXNVc2VkXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gYXhpc1xuICAgKi9cbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fdG9nZ2xlQXhpc1Zpc2libGl0eSA9IGZ1bmN0aW9uIChheGlzVXNlZCwgYXhpcykge1xuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgaWYgKGF4aXNVc2VkID09IGZhbHNlKSB7XG4gICAgICBpZiAoYXhpcy5kb20uZnJhbWUucGFyZW50Tm9kZSAmJiBheGlzLmhpZGRlbiA9PSBmYWxzZSkge1xuICAgICAgICBheGlzLmhpZGUoKTtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghYXhpcy5kb20uZnJhbWUucGFyZW50Tm9kZSAmJiBheGlzLmhpZGRlbiA9PSB0cnVlKSB7XG4gICAgICAgIGF4aXMuc2hvdygpO1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgdXNlcyB0aGUgRGF0YUF4aXMgb2JqZWN0IHRvIGdlbmVyYXRlIHRoZSBjb3JyZWN0IFggY29vcmRpbmF0ZSBvbiB0aGUgU1ZHIHdpbmRvdy4gSXQgdXNlcyB0aGVcbiAgICogdXRpbCBmdW5jdGlvbiB0b1NjcmVlbiB0byBnZXQgdGhlIHggY29vcmRpbmF0ZSBmcm9tIHRoZSB0aW1lc3RhbXAuIEl0IGFsc28gcHJlLWZpbHRlcnMgdGhlIGRhdGEgYW5kIGdldCB0aGUgbWluTWF4IHJhbmdlcyBmb3JcbiAgICogdGhlIHlBeGlzLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YXBvaW50c1xuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBMaW5lR3JhcGgucHJvdG90eXBlLl9jb252ZXJ0WGNvb3JkaW5hdGVzID0gZnVuY3Rpb24gKGRhdGFwb2ludHMpIHtcbiAgICB2YXIgdG9TY3JlZW4gPSB0aGlzLmJvZHkudXRpbC50b1NjcmVlbjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGFwb2ludHNbaV0uc2NyZWVuX3ggPSB0b1NjcmVlbihkYXRhcG9pbnRzW2ldLngpICsgdGhpcy5wcm9wcy53aWR0aDtcbiAgICAgIGRhdGFwb2ludHNbaV0uc2NyZWVuX3kgPSBkYXRhcG9pbnRzW2ldLnk7IC8vc3RhcnRpbmcgcG9pbnQgZm9yIHJhbmdlIGNhbGN1bGF0aW9uc1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGhpcyB1c2VzIHRoZSBEYXRhQXhpcyBvYmplY3QgdG8gZ2VuZXJhdGUgdGhlIGNvcnJlY3QgWCBjb29yZGluYXRlIG9uIHRoZSBTVkcgd2luZG93LiBJdCB1c2VzIHRoZVxuICAgKiB1dGlsIGZ1bmN0aW9uIHRvU2NyZWVuIHRvIGdldCB0aGUgeCBjb29yZGluYXRlIGZyb20gdGhlIHRpbWVzdGFtcC4gSXQgYWxzbyBwcmUtZmlsdGVycyB0aGUgZGF0YSBhbmQgZ2V0IHRoZSBtaW5NYXggcmFuZ2VzIGZvclxuICAgKiB0aGUgeUF4aXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhcG9pbnRzXG4gICAqIEBwYXJhbSBncm91cFxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBMaW5lR3JhcGgucHJvdG90eXBlLl9jb252ZXJ0WWNvb3JkaW5hdGVzID0gZnVuY3Rpb24gKGRhdGFwb2ludHMsIGdyb3VwKSB7XG4gICAgdmFyIGF4aXMgPSB0aGlzLnlBeGlzTGVmdDtcbiAgICB2YXIgc3ZnSGVpZ2h0ID0gTnVtYmVyKHRoaXMuc3ZnLnN0eWxlLmhlaWdodC5yZXBsYWNlKCdweCcsICcnKSk7XG4gICAgaWYgKGdyb3VwLm9wdGlvbnMueUF4aXNPcmllbnRhdGlvbiA9PSAncmlnaHQnKSB7XG4gICAgICBheGlzID0gdGhpcy55QXhpc1JpZ2h0O1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGFwb2ludHNbaV0uc2NyZWVuX3kgPSBNYXRoLnJvdW5kKGF4aXMuY29udmVydFZhbHVlKGRhdGFwb2ludHNbaV0ueSkpO1xuICAgIH1cbiAgICBncm91cC5zZXRaZXJvUG9zaXRpb24oTWF0aC5taW4oc3ZnSGVpZ2h0LCBheGlzLmNvbnZlcnRWYWx1ZSgwKSkpO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gTGluZUdyYXBoO1xuXG4vKioqLyB9LFxuLyogNTQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBET011dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbiAgdmFyIENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xuICB2YXIgRGF0YVNjYWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NSk7XG4gIC8qKlxuICAgKiBBIGhvcml6b250YWwgdGltZSBheGlzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgIFNlZSBEYXRhQXhpcy5zZXRPcHRpb25zIGZvciB0aGUgYXZhaWxhYmxlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuXG4gICAqIEBjb25zdHJ1Y3RvciBEYXRhQXhpc1xuICAgKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAgICogQHBhcmFtIGJvZHlcbiAgICovXG4gIGZ1bmN0aW9uIERhdGFBeGlzKGJvZHksIG9wdGlvbnMsIHN2ZywgbGluZWdyYXBoT3B0aW9ucykge1xuICAgIHRoaXMuaWQgPSB1dGlsLnJhbmRvbVVVSUQoKTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIG9yaWVudGF0aW9uOiAnbGVmdCcsIC8vIHN1cHBvcnRlZDogJ2xlZnQnLCAncmlnaHQnXG4gICAgICBzaG93TWlub3JMYWJlbHM6IHRydWUsXG4gICAgICBzaG93TWFqb3JMYWJlbHM6IHRydWUsXG4gICAgICBpY29uczogZmFsc2UsXG4gICAgICBtYWpvckxpbmVzT2Zmc2V0OiA3LFxuICAgICAgbWlub3JMaW5lc09mZnNldDogNCxcbiAgICAgIGxhYmVsT2Zmc2V0WDogMTAsXG4gICAgICBsYWJlbE9mZnNldFk6IDIsXG4gICAgICBpY29uV2lkdGg6IDIwLFxuICAgICAgd2lkdGg6ICc0MHB4JyxcbiAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICBhbGlnblplcm9zOiB0cnVlLFxuICAgICAgbGVmdDoge1xuICAgICAgICByYW5nZTogeyBtaW46IHVuZGVmaW5lZCwgbWF4OiB1bmRlZmluZWQgfSxcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbiBmb3JtYXQodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gJycgKyBwYXJzZUZsb2F0KHZhbHVlLnRvUHJlY2lzaW9uKDMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGU6IHsgdGV4dDogdW5kZWZpbmVkLCBzdHlsZTogdW5kZWZpbmVkIH1cbiAgICAgIH0sXG4gICAgICByaWdodDoge1xuICAgICAgICByYW5nZTogeyBtaW46IHVuZGVmaW5lZCwgbWF4OiB1bmRlZmluZWQgfSxcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbiBmb3JtYXQodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gJycgKyBwYXJzZUZsb2F0KHZhbHVlLnRvUHJlY2lzaW9uKDMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGU6IHsgdGV4dDogdW5kZWZpbmVkLCBzdHlsZTogdW5kZWZpbmVkIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5saW5lZ3JhcGhPcHRpb25zID0gbGluZWdyYXBoT3B0aW9ucztcbiAgICB0aGlzLmxpbmVncmFwaFNWRyA9IHN2ZztcbiAgICB0aGlzLnByb3BzID0ge307XG4gICAgdGhpcy5ET01lbGVtZW50cyA9IHsgLy8gZHluYW1pYyBlbGVtZW50c1xuICAgICAgbGluZXM6IHt9LFxuICAgICAgbGFiZWxzOiB7fSxcbiAgICAgIHRpdGxlOiB7fVxuICAgIH07XG5cbiAgICB0aGlzLmRvbSA9IHt9O1xuICAgIHRoaXMuc2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yYW5nZSA9IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xuXG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIHRoaXMuY29udmVyc2lvbkZhY3RvciA9IDE7XG5cbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy53aWR0aCA9IE51bWJlcigoJycgKyB0aGlzLm9wdGlvbnMud2lkdGgpLnJlcGxhY2UoXCJweFwiLCBcIlwiKSk7XG4gICAgdGhpcy5taW5XaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmxpbmVncmFwaFNWRy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcblxuICAgIHRoaXMuc3RlcFBpeGVscyA9IDI1O1xuICAgIHRoaXMuemVyb0Nyb3NzaW5nID0gLTE7XG4gICAgdGhpcy5hbW91bnRPZlN0ZXBzID0gLTE7XG5cbiAgICB0aGlzLmxpbmVPZmZzZXQgPSAwO1xuICAgIHRoaXMubWFzdGVyID0gdHJ1ZTtcbiAgICB0aGlzLm1hc3RlckF4aXMgPSBudWxsO1xuICAgIHRoaXMuc3ZnRWxlbWVudHMgPSB7fTtcbiAgICB0aGlzLmljb25zUmVtb3ZlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICB0aGlzLmFtb3VudE9mR3JvdXBzID0gMDtcblxuICAgIC8vIGNyZWF0ZSB0aGUgSFRNTCBET01cbiAgICB0aGlzLl9jcmVhdGUoKTtcbiAgICB0aGlzLmZyYW1ld29yayA9IHsgc3ZnOiB0aGlzLnN2Zywgc3ZnRWxlbWVudHM6IHRoaXMuc3ZnRWxlbWVudHMsIG9wdGlvbnM6IHRoaXMub3B0aW9ucywgZ3JvdXBzOiB0aGlzLmdyb3VwcyB9O1xuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInZlcnRpY2FsRHJhZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBtZS5kb20ubGluZUNvbnRhaW5lci5zdHlsZS50b3AgPSBtZS5ib2R5LmRvbVByb3BzLnNjcm9sbFRvcCArICdweCc7XG4gICAgfSk7XG4gIH1cblxuICBEYXRhQXhpcy5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cbiAgRGF0YUF4aXMucHJvdG90eXBlLmFkZEdyb3VwID0gZnVuY3Rpb24gKGxhYmVsLCBncmFwaE9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KGxhYmVsKSkge1xuICAgICAgdGhpcy5ncm91cHNbbGFiZWxdID0gZ3JhcGhPcHRpb25zO1xuICAgIH1cbiAgICB0aGlzLmFtb3VudE9mR3JvdXBzICs9IDE7XG4gIH07XG5cbiAgRGF0YUF4aXMucHJvdG90eXBlLnVwZGF0ZUdyb3VwID0gZnVuY3Rpb24gKGxhYmVsLCBncmFwaE9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KGxhYmVsKSkge1xuICAgICAgdGhpcy5hbW91bnRPZkdyb3VwcyArPSAxO1xuICAgIH1cbiAgICB0aGlzLmdyb3Vwc1tsYWJlbF0gPSBncmFwaE9wdGlvbnM7XG4gIH07XG5cbiAgRGF0YUF4aXMucHJvdG90eXBlLnJlbW92ZUdyb3VwID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgaWYgKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KGxhYmVsKSkge1xuICAgICAgZGVsZXRlIHRoaXMuZ3JvdXBzW2xhYmVsXTtcbiAgICAgIHRoaXMuYW1vdW50T2ZHcm91cHMgLT0gMTtcbiAgICB9XG4gIH07XG5cbiAgRGF0YUF4aXMucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB2YXIgcmVkcmF3ID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm9yaWVudGF0aW9uICE9IG9wdGlvbnMub3JpZW50YXRpb24gJiYgb3B0aW9ucy5vcmllbnRhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlZHJhdyA9IHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgZmllbGRzID0gWydvcmllbnRhdGlvbicsICdzaG93TWlub3JMYWJlbHMnLCAnc2hvd01ham9yTGFiZWxzJywgJ2ljb25zJywgJ21ham9yTGluZXNPZmZzZXQnLCAnbWlub3JMaW5lc09mZnNldCcsICdsYWJlbE9mZnNldFgnLCAnbGFiZWxPZmZzZXRZJywgJ2ljb25XaWR0aCcsICd3aWR0aCcsICd2aXNpYmxlJywgJ2xlZnQnLCAncmlnaHQnLCAnYWxpZ25aZXJvcyddO1xuICAgICAgdXRpbC5zZWxlY3RpdmVEZWVwRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgdGhpcy5taW5XaWR0aCA9IE51bWJlcigoJycgKyB0aGlzLm9wdGlvbnMud2lkdGgpLnJlcGxhY2UoXCJweFwiLCBcIlwiKSk7XG4gICAgICBpZiAocmVkcmF3ID09PSB0cnVlICYmIHRoaXMuZG9tLmZyYW1lKSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgSFRNTCBET00gZm9yIHRoZSBEYXRhQXhpc1xuICAgKi9cbiAgRGF0YUF4aXMucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kb20uZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS5mcmFtZS5zdHlsZS53aWR0aCA9IHRoaXMub3B0aW9ucy53aWR0aDtcbiAgICB0aGlzLmRvbS5mcmFtZS5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodDtcblxuICAgIHRoaXMuZG9tLmxpbmVDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS5saW5lQ29udGFpbmVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHRoaXMuZG9tLmxpbmVDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgdGhpcy5kb20ubGluZUNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG5cbiAgICAvLyBjcmVhdGUgc3ZnIGVsZW1lbnQgZm9yIGdyYXBoIGRyYXdpbmcuXG4gICAgdGhpcy5zdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgXCJzdmdcIik7XG4gICAgdGhpcy5zdmcuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgdGhpcy5zdmcuc3R5bGUudG9wID0gJzBweCc7XG4gICAgdGhpcy5zdmcuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIHRoaXMuc3ZnLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHRoaXMuc3ZnLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgdGhpcy5kb20uZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5zdmcpO1xuICB9O1xuXG4gIERhdGFBeGlzLnByb3RvdHlwZS5fcmVkcmF3R3JvdXBJY29ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICBET011dGlsLnByZXBhcmVFbGVtZW50cyh0aGlzLnN2Z0VsZW1lbnRzKTtcblxuICAgIHZhciB4O1xuICAgIHZhciBpY29uV2lkdGggPSB0aGlzLm9wdGlvbnMuaWNvbldpZHRoO1xuICAgIHZhciBpY29uSGVpZ2h0ID0gMTU7XG4gICAgdmFyIGljb25PZmZzZXQgPSA0O1xuICAgIHZhciB5ID0gaWNvbk9mZnNldCArIDAuNSAqIGljb25IZWlnaHQ7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm9yaWVudGF0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIHggPSBpY29uT2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gdGhpcy53aWR0aCAtIGljb25XaWR0aCAtIGljb25PZmZzZXQ7XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwQXJyYXkgPSBPYmplY3Qua2V5cyh0aGlzLmdyb3Vwcyk7XG4gICAgZ3JvdXBBcnJheS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IDE7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBncm91cElkID0gZ3JvdXBBcnJheVtpXTtcbiAgICAgIGlmICh0aGlzLmdyb3Vwc1tncm91cElkXS52aXNpYmxlID09PSB0cnVlICYmICh0aGlzLmxpbmVncmFwaE9wdGlvbnMudmlzaWJpbGl0eVtncm91cElkXSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMubGluZWdyYXBoT3B0aW9ucy52aXNpYmlsaXR5W2dyb3VwSWRdID09PSB0cnVlKSkge1xuICAgICAgICB0aGlzLmdyb3Vwc1tncm91cElkXS5nZXRMZWdlbmQoaWNvbldpZHRoLCBpY29uSGVpZ2h0LCB0aGlzLmZyYW1ld29yaywgeCwgeSk7XG4gICAgICAgIHkgKz0gaWNvbkhlaWdodCArIGljb25PZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgRE9NdXRpbC5jbGVhbnVwRWxlbWVudHModGhpcy5zdmdFbGVtZW50cyk7XG4gICAgdGhpcy5pY29uc1JlbW92ZWQgPSBmYWxzZTtcbiAgfTtcblxuICBEYXRhQXhpcy5wcm90b3R5cGUuX2NsZWFudXBJY29ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pY29uc1JlbW92ZWQgPT09IGZhbHNlKSB7XG4gICAgICBET011dGlsLnByZXBhcmVFbGVtZW50cyh0aGlzLnN2Z0VsZW1lbnRzKTtcbiAgICAgIERPTXV0aWwuY2xlYW51cEVsZW1lbnRzKHRoaXMuc3ZnRWxlbWVudHMpO1xuICAgICAgdGhpcy5pY29uc1JlbW92ZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBIVE1MIERPTSBmb3IgdGhlIERhdGFBeGlzXG4gICAqL1xuICBEYXRhQXhpcy5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5kb20uZnJhbWUucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHRoaXMuYm9keS5kb20ubGVmdC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5mcmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvZHkuZG9tLnJpZ2h0LmFwcGVuZENoaWxkKHRoaXMuZG9tLmZyYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZG9tLmxpbmVDb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5ib2R5LmRvbS5iYWNrZ3JvdW5kSG9yaXpvbnRhbC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5saW5lQ29udGFpbmVyKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgSFRNTCBET00gZm9yIHRoZSBEYXRhQXhpc1xuICAgKi9cbiAgRGF0YUF4aXMucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5oaWRkZW4gPSB0cnVlO1xuICAgIGlmICh0aGlzLmRvbS5mcmFtZS5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmRvbS5mcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmZyYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kb20ubGluZUNvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmRvbS5saW5lQ29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20ubGluZUNvbnRhaW5lcik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYSByYW5nZSAoc3RhcnQgYW5kIGVuZClcbiAgICogQHBhcmFtIGVuZFxuICAgKiBAcGFyYW0gc3RhcnRcbiAgICogQHBhcmFtIGVuZFxuICAgKi9cbiAgRGF0YUF4aXMucHJvdG90eXBlLnNldFJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLnJhbmdlLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5yYW5nZS5lbmQgPSBlbmQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGFpbnQgdGhlIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZXNpemVkXG4gICAqL1xuICBEYXRhQXhpcy5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXNpemVkID0gZmFsc2U7XG4gICAgdmFyIGFjdGl2ZUdyb3VwcyA9IDA7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGxpbmUgY29udGFpbmVyIGFkaGVyZXMgdG8gdGhlIHZlcnRpY2FsIHNjcm9sbGluZy5cbiAgICB0aGlzLmRvbS5saW5lQ29udGFpbmVyLnN0eWxlLnRvcCA9IHRoaXMuYm9keS5kb21Qcm9wcy5zY3JvbGxUb3AgKyAncHgnO1xuXG4gICAgZm9yICh2YXIgZ3JvdXBJZCBpbiB0aGlzLmdyb3Vwcykge1xuICAgICAgaWYgKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KGdyb3VwSWQpKSB7XG4gICAgICAgIGlmICh0aGlzLmdyb3Vwc1tncm91cElkXS52aXNpYmxlID09PSB0cnVlICYmICh0aGlzLmxpbmVncmFwaE9wdGlvbnMudmlzaWJpbGl0eVtncm91cElkXSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMubGluZWdyYXBoT3B0aW9ucy52aXNpYmlsaXR5W2dyb3VwSWRdID09PSB0cnVlKSkge1xuICAgICAgICAgIGFjdGl2ZUdyb3VwcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmFtb3VudE9mR3JvdXBzID09PSAwIHx8IGFjdGl2ZUdyb3VwcyA9PT0gMCkge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgdGhpcy5oZWlnaHQgPSBOdW1iZXIodGhpcy5saW5lZ3JhcGhTVkcuc3R5bGUuaGVpZ2h0LnJlcGxhY2UoXCJweFwiLCBcIlwiKSk7XG5cbiAgICAgIC8vIHN2ZyBvZmZzZXRoZWlnaHQgZGlkIG5vdCB3b3JrIGluIGZpcmVmb3ggYW5kIGV4cGxvcmVyLi4uXG4gICAgICB0aGlzLmRvbS5saW5lQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgJ3B4JztcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLm9wdGlvbnMudmlzaWJsZSA9PT0gdHJ1ZSA/IE51bWJlcigoJycgKyB0aGlzLm9wdGlvbnMud2lkdGgpLnJlcGxhY2UoXCJweFwiLCBcIlwiKSkgOiAwO1xuXG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIGZyYW1lID0gdGhpcy5kb20uZnJhbWU7XG5cbiAgICAgIC8vIHVwZGF0ZSBjbGFzc25hbWVcbiAgICAgIGZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtZGF0YS1heGlzJztcblxuICAgICAgLy8gY2FsY3VsYXRlIGNoYXJhY3RlciB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICB0aGlzLl9jYWxjdWxhdGVDaGFyU2l6ZSgpO1xuXG4gICAgICB2YXIgb3JpZW50YXRpb24gPSB0aGlzLm9wdGlvbnMub3JpZW50YXRpb247XG4gICAgICB2YXIgc2hvd01pbm9yTGFiZWxzID0gdGhpcy5vcHRpb25zLnNob3dNaW5vckxhYmVscztcbiAgICAgIHZhciBzaG93TWFqb3JMYWJlbHMgPSB0aGlzLm9wdGlvbnMuc2hvd01ham9yTGFiZWxzO1xuXG4gICAgICAvLyBkZXRlcm1pbmUgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGVsZW1lbnRzIGZvciB0aGUgYXhpc1xuICAgICAgcHJvcHMubWlub3JMYWJlbEhlaWdodCA9IHNob3dNaW5vckxhYmVscyA/IHByb3BzLm1pbm9yQ2hhckhlaWdodCA6IDA7XG4gICAgICBwcm9wcy5tYWpvckxhYmVsSGVpZ2h0ID0gc2hvd01ham9yTGFiZWxzID8gcHJvcHMubWFqb3JDaGFySGVpZ2h0IDogMDtcblxuICAgICAgcHJvcHMubWlub3JMaW5lV2lkdGggPSB0aGlzLmJvZHkuZG9tLmJhY2tncm91bmRIb3Jpem9udGFsLm9mZnNldFdpZHRoIC0gdGhpcy5saW5lT2Zmc2V0IC0gdGhpcy53aWR0aCArIDIgKiB0aGlzLm9wdGlvbnMubWlub3JMaW5lc09mZnNldDtcbiAgICAgIHByb3BzLm1pbm9yTGluZUhlaWdodCA9IDE7XG4gICAgICBwcm9wcy5tYWpvckxpbmVXaWR0aCA9IHRoaXMuYm9keS5kb20uYmFja2dyb3VuZEhvcml6b250YWwub2Zmc2V0V2lkdGggLSB0aGlzLmxpbmVPZmZzZXQgLSB0aGlzLndpZHRoICsgMiAqIHRoaXMub3B0aW9ucy5tYWpvckxpbmVzT2Zmc2V0O1xuICAgICAgcHJvcHMubWFqb3JMaW5lSGVpZ2h0ID0gMTtcblxuICAgICAgLy8gIHRha2UgZnJhbWUgb2ZmbGluZSB3aGlsZSB1cGRhdGluZyAoaXMgYWxtb3N0IHR3aWNlIGFzIGZhc3QpXG4gICAgICBpZiAob3JpZW50YXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICBmcmFtZS5zdHlsZS50b3AgPSAnMCc7XG4gICAgICAgIGZyYW1lLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICAgIGZyYW1lLnN0eWxlLmJvdHRvbSA9ICcnO1xuICAgICAgICBmcmFtZS5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyAncHgnO1xuICAgICAgICBmcmFtZS5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5wcm9wcy53aWR0aCA9IHRoaXMuYm9keS5kb21Qcm9wcy5sZWZ0LndpZHRoO1xuICAgICAgICB0aGlzLnByb3BzLmhlaWdodCA9IHRoaXMuYm9keS5kb21Qcm9wcy5sZWZ0LmhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJpZ2h0XG4gICAgICAgIGZyYW1lLnN0eWxlLnRvcCA9ICcnO1xuICAgICAgICBmcmFtZS5zdHlsZS5ib3R0b20gPSAnMCc7XG4gICAgICAgIGZyYW1lLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICAgIGZyYW1lLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArICdweCc7XG4gICAgICAgIGZyYW1lLnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICB0aGlzLnByb3BzLndpZHRoID0gdGhpcy5ib2R5LmRvbVByb3BzLnJpZ2h0LndpZHRoO1xuICAgICAgICB0aGlzLnByb3BzLmhlaWdodCA9IHRoaXMuYm9keS5kb21Qcm9wcy5yaWdodC5oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHJlc2l6ZWQgPSB0aGlzLl9yZWRyYXdMYWJlbHMoKTtcbiAgICAgIHJlc2l6ZWQgPSB0aGlzLl9pc1Jlc2l6ZWQoKSB8fCByZXNpemVkO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmljb25zID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX3JlZHJhd0dyb3VwSWNvbnMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NsZWFudXBJY29ucygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZWRyYXdUaXRsZShvcmllbnRhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiByZXNpemVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBhaW50IG1ham9yIGFuZCBtaW5vciB0ZXh0IGxhYmVscyBhbmQgdmVydGljYWwgZ3JpZCBsaW5lc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRGF0YUF4aXMucHJvdG90eXBlLl9yZWRyYXdMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciByZXNpemVkID0gZmFsc2U7XG4gICAgRE9NdXRpbC5wcmVwYXJlRWxlbWVudHModGhpcy5ET01lbGVtZW50cy5saW5lcyk7XG4gICAgRE9NdXRpbC5wcmVwYXJlRWxlbWVudHModGhpcy5ET01lbGVtZW50cy5sYWJlbHMpO1xuICAgIHZhciBvcmllbnRhdGlvbiA9IHRoaXMub3B0aW9uc1snb3JpZW50YXRpb24nXTtcbiAgICB2YXIgY3VzdG9tUmFuZ2UgPSB0aGlzLm9wdGlvbnNbb3JpZW50YXRpb25dLnJhbmdlICE9IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9uc1tvcmllbnRhdGlvbl0ucmFuZ2UgOiB7fTtcblxuICAgIC8vT3ZlcnJpZGUgcmFuZ2Ugd2l0aCBtYW51YWwgb3B0aW9uczpcbiAgICB2YXIgYXV0b1NjYWxlRW5kID0gdHJ1ZTtcbiAgICBpZiAoY3VzdG9tUmFuZ2UubWF4ICE9IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5yYW5nZS5lbmQgPSBjdXN0b21SYW5nZS5tYXg7XG4gICAgICBhdXRvU2NhbGVFbmQgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGF1dG9TY2FsZVN0YXJ0ID0gdHJ1ZTtcbiAgICBpZiAoY3VzdG9tUmFuZ2UubWluICE9IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5yYW5nZS5zdGFydCA9IGN1c3RvbVJhbmdlLm1pbjtcbiAgICAgIGF1dG9TY2FsZVN0YXJ0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5zY2FsZSA9IG5ldyBEYXRhU2NhbGUodGhpcy5yYW5nZS5zdGFydCwgdGhpcy5yYW5nZS5lbmQsIGF1dG9TY2FsZVN0YXJ0LCBhdXRvU2NhbGVFbmQsIHRoaXMuZG9tLmZyYW1lLm9mZnNldEhlaWdodCwgdGhpcy5wcm9wcy5tYWpvckNoYXJIZWlnaHQsIHRoaXMub3B0aW9ucy5hbGlnblplcm9zLCB0aGlzLm9wdGlvbnNbb3JpZW50YXRpb25dLmZvcm1hdCk7XG5cbiAgICBpZiAodGhpcy5tYXN0ZXIgPT09IGZhbHNlICYmIHRoaXMubWFzdGVyQXhpcyAhPSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2NhbGUuZm9sbG93U2NhbGUodGhpcy5tYXN0ZXJBeGlzLnNjYWxlKTtcbiAgICB9XG5cbiAgICAvL0lzIHVwZGF0ZWQgaW4gc2lkZS1lZmZlY3Qgb2YgX3JlZHJhd0xhYmVsKCk6XG4gICAgdGhpcy5tYXhMYWJlbFNpemUgPSAwO1xuXG4gICAgdmFyIGxpbmVzID0gdGhpcy5zY2FsZS5nZXRMaW5lcygpO1xuICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHZhciB5ID0gbGluZS55O1xuICAgICAgdmFyIGlzTWFqb3IgPSBsaW5lLm1ham9yO1xuICAgICAgaWYgKF90aGlzLm9wdGlvbnNbJ3Nob3dNaW5vckxhYmVscyddICYmIGlzTWFqb3IgPT09IGZhbHNlKSB7XG4gICAgICAgIF90aGlzLl9yZWRyYXdMYWJlbCh5IC0gMiwgbGluZS52YWwsIG9yaWVudGF0aW9uLCAndmlzLXktYXhpcyB2aXMtbWlub3InLCBfdGhpcy5wcm9wcy5taW5vckNoYXJIZWlnaHQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzTWFqb3IpIHtcbiAgICAgICAgaWYgKHkgPj0gMCkge1xuICAgICAgICAgIF90aGlzLl9yZWRyYXdMYWJlbCh5IC0gMiwgbGluZS52YWwsIG9yaWVudGF0aW9uLCAndmlzLXktYXhpcyB2aXMtbWFqb3InLCBfdGhpcy5wcm9wcy5tYWpvckNoYXJIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX3RoaXMubWFzdGVyID09PSB0cnVlKSB7XG4gICAgICAgIGlmIChpc01ham9yKSB7XG4gICAgICAgICAgX3RoaXMuX3JlZHJhd0xpbmUoeSwgb3JpZW50YXRpb24sICd2aXMtZ3JpZCB2aXMtaG9yaXpvbnRhbCB2aXMtbWFqb3InLCBfdGhpcy5vcHRpb25zLm1ham9yTGluZXNPZmZzZXQsIF90aGlzLnByb3BzLm1ham9yTGluZVdpZHRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5fcmVkcmF3TGluZSh5LCBvcmllbnRhdGlvbiwgJ3Zpcy1ncmlkIHZpcy1ob3Jpem9udGFsIHZpcy1taW5vcicsIF90aGlzLm9wdGlvbnMubWlub3JMaW5lc09mZnNldCwgX3RoaXMucHJvcHMubWlub3JMaW5lV2lkdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBOb3RlIHRoYXQgdGl0bGUgaXMgcm90YXRlZCwgc28gd2UncmUgdXNpbmcgdGhlIGhlaWdodCwgbm90IHdpZHRoIVxuICAgIHZhciB0aXRsZVdpZHRoID0gMDtcbiAgICBpZiAodGhpcy5vcHRpb25zW29yaWVudGF0aW9uXS50aXRsZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9uc1tvcmllbnRhdGlvbl0udGl0bGUudGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aXRsZVdpZHRoID0gdGhpcy5wcm9wcy50aXRsZUNoYXJIZWlnaHQ7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9wdGlvbnMuaWNvbnMgPT09IHRydWUgPyBNYXRoLm1heCh0aGlzLm9wdGlvbnMuaWNvbldpZHRoLCB0aXRsZVdpZHRoKSArIHRoaXMub3B0aW9ucy5sYWJlbE9mZnNldFggKyAxNSA6IHRpdGxlV2lkdGggKyB0aGlzLm9wdGlvbnMubGFiZWxPZmZzZXRYICsgMTU7XG5cbiAgICAvLyB0aGlzIHdpbGwgcmVzaXplIHRoZSB5QXhpcyB0byBhY2NvbW1vZGF0ZSB0aGUgbGFiZWxzLlxuICAgIGlmICh0aGlzLm1heExhYmVsU2l6ZSA+IHRoaXMud2lkdGggLSBvZmZzZXQgJiYgdGhpcy5vcHRpb25zLnZpc2libGUgPT09IHRydWUpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLm1heExhYmVsU2l6ZSArIG9mZnNldDtcbiAgICAgIHRoaXMub3B0aW9ucy53aWR0aCA9IHRoaXMud2lkdGggKyBcInB4XCI7XG4gICAgICBET011dGlsLmNsZWFudXBFbGVtZW50cyh0aGlzLkRPTWVsZW1lbnRzLmxpbmVzKTtcbiAgICAgIERPTXV0aWwuY2xlYW51cEVsZW1lbnRzKHRoaXMuRE9NZWxlbWVudHMubGFiZWxzKTtcbiAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICByZXNpemVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gdGhpcyB3aWxsIHJlc2l6ZSB0aGUgeUF4aXMgaWYgaXQgaXMgdG9vIGJpZyBmb3IgdGhlIGxhYmVscy5cbiAgICBlbHNlIGlmICh0aGlzLm1heExhYmVsU2l6ZSA8IHRoaXMud2lkdGggLSBvZmZzZXQgJiYgdGhpcy5vcHRpb25zLnZpc2libGUgPT09IHRydWUgJiYgdGhpcy53aWR0aCA+IHRoaXMubWluV2lkdGgpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IE1hdGgubWF4KHRoaXMubWluV2lkdGgsIHRoaXMubWF4TGFiZWxTaXplICsgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5vcHRpb25zLndpZHRoID0gdGhpcy53aWR0aCArIFwicHhcIjtcbiAgICAgICAgRE9NdXRpbC5jbGVhbnVwRWxlbWVudHModGhpcy5ET01lbGVtZW50cy5saW5lcyk7XG4gICAgICAgIERPTXV0aWwuY2xlYW51cEVsZW1lbnRzKHRoaXMuRE9NZWxlbWVudHMubGFiZWxzKTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgICAgcmVzaXplZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBET011dGlsLmNsZWFudXBFbGVtZW50cyh0aGlzLkRPTWVsZW1lbnRzLmxpbmVzKTtcbiAgICAgICAgRE9NdXRpbC5jbGVhbnVwRWxlbWVudHModGhpcy5ET01lbGVtZW50cy5sYWJlbHMpO1xuICAgICAgICByZXNpemVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICByZXR1cm4gcmVzaXplZDtcbiAgfTtcblxuICBEYXRhQXhpcy5wcm90b3R5cGUuY29udmVydFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGUuY29udmVydFZhbHVlKHZhbHVlKTtcbiAgfTtcblxuICBEYXRhQXhpcy5wcm90b3R5cGUuc2NyZWVuVG9WYWx1ZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGUuc2NyZWVuVG9WYWx1ZSh4KTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbGFiZWwgZm9yIHRoZSBheGlzIGF0IHBvc2l0aW9uIHhcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHlcbiAgICogQHBhcmFtIHRleHRcbiAgICogQHBhcmFtIG9yaWVudGF0aW9uXG4gICAqIEBwYXJhbSBjbGFzc05hbWVcbiAgICogQHBhcmFtIGNoYXJhY3RlckhlaWdodFxuICAgKi9cbiAgRGF0YUF4aXMucHJvdG90eXBlLl9yZWRyYXdMYWJlbCA9IGZ1bmN0aW9uICh5LCB0ZXh0LCBvcmllbnRhdGlvbiwgY2xhc3NOYW1lLCBjaGFyYWN0ZXJIZWlnaHQpIHtcbiAgICAvLyByZXVzZSByZWR1bmRhbnQgbGFiZWxcbiAgICB2YXIgbGFiZWwgPSBET011dGlsLmdldERPTUVsZW1lbnQoJ2RpdicsIHRoaXMuRE9NZWxlbWVudHMubGFiZWxzLCB0aGlzLmRvbS5mcmFtZSk7IC8vdGhpcy5kb20ucmVkdW5kYW50LmxhYmVscy5zaGlmdCgpO1xuICAgIGxhYmVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICBsYWJlbC5pbm5lckhUTUwgPSB0ZXh0O1xuICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBsYWJlbC5zdHlsZS5sZWZ0ID0gJy0nICsgdGhpcy5vcHRpb25zLmxhYmVsT2Zmc2V0WCArICdweCc7XG4gICAgICBsYWJlbC5zdHlsZS50ZXh0QWxpZ24gPSBcInJpZ2h0XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhYmVsLnN0eWxlLnJpZ2h0ID0gJy0nICsgdGhpcy5vcHRpb25zLmxhYmVsT2Zmc2V0WCArICdweCc7XG4gICAgICBsYWJlbC5zdHlsZS50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICB9XG5cbiAgICBsYWJlbC5zdHlsZS50b3AgPSB5IC0gMC41ICogY2hhcmFjdGVySGVpZ2h0ICsgdGhpcy5vcHRpb25zLmxhYmVsT2Zmc2V0WSArICdweCc7XG5cbiAgICB0ZXh0ICs9ICcnO1xuXG4gICAgdmFyIGxhcmdlc3RXaWR0aCA9IE1hdGgubWF4KHRoaXMucHJvcHMubWFqb3JDaGFyV2lkdGgsIHRoaXMucHJvcHMubWlub3JDaGFyV2lkdGgpO1xuICAgIGlmICh0aGlzLm1heExhYmVsU2l6ZSA8IHRleHQubGVuZ3RoICogbGFyZ2VzdFdpZHRoKSB7XG4gICAgICB0aGlzLm1heExhYmVsU2l6ZSA9IHRleHQubGVuZ3RoICogbGFyZ2VzdFdpZHRoO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbWlub3IgbGluZSBmb3IgdGhlIGF4aXMgYXQgcG9zaXRpb24geVxuICAgKiBAcGFyYW0geVxuICAgKiBAcGFyYW0gb3JpZW50YXRpb25cbiAgICogQHBhcmFtIGNsYXNzTmFtZVxuICAgKiBAcGFyYW0gb2Zmc2V0XG4gICAqIEBwYXJhbSB3aWR0aFxuICAgKi9cbiAgRGF0YUF4aXMucHJvdG90eXBlLl9yZWRyYXdMaW5lID0gZnVuY3Rpb24gKHksIG9yaWVudGF0aW9uLCBjbGFzc05hbWUsIG9mZnNldCwgd2lkdGgpIHtcbiAgICBpZiAodGhpcy5tYXN0ZXIgPT09IHRydWUpIHtcbiAgICAgIHZhciBsaW5lID0gRE9NdXRpbC5nZXRET01FbGVtZW50KCdkaXYnLCB0aGlzLkRPTWVsZW1lbnRzLmxpbmVzLCB0aGlzLmRvbS5saW5lQ29udGFpbmVyKTsgLy90aGlzLmRvbS5yZWR1bmRhbnQubGluZXMuc2hpZnQoKTtcbiAgICAgIGxpbmUuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgbGluZS5pbm5lckhUTUwgPSAnJztcblxuICAgICAgaWYgKG9yaWVudGF0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgbGluZS5zdHlsZS5sZWZ0ID0gdGhpcy53aWR0aCAtIG9mZnNldCArICdweCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lLnN0eWxlLnJpZ2h0ID0gdGhpcy53aWR0aCAtIG9mZnNldCArICdweCc7XG4gICAgICB9XG5cbiAgICAgIGxpbmUuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICBsaW5lLnN0eWxlLnRvcCA9IHkgKyAncHgnO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgdGl0bGUgZm9yIHRoZSBheGlzXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSBvcmllbnRhdGlvblxuICAgKi9cbiAgRGF0YUF4aXMucHJvdG90eXBlLl9yZWRyYXdUaXRsZSA9IGZ1bmN0aW9uIChvcmllbnRhdGlvbikge1xuICAgIERPTXV0aWwucHJlcGFyZUVsZW1lbnRzKHRoaXMuRE9NZWxlbWVudHMudGl0bGUpO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHRpdGxlIGlzIGRlZmluZWQgZm9yIHRoaXMgYXhlc1xuICAgIGlmICh0aGlzLm9wdGlvbnNbb3JpZW50YXRpb25dLnRpdGxlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zW29yaWVudGF0aW9uXS50aXRsZS50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciB0aXRsZSA9IERPTXV0aWwuZ2V0RE9NRWxlbWVudCgnZGl2JywgdGhpcy5ET01lbGVtZW50cy50aXRsZSwgdGhpcy5kb20uZnJhbWUpO1xuICAgICAgdGl0bGUuY2xhc3NOYW1lID0gJ3Zpcy15LWF4aXMgdmlzLXRpdGxlIHZpcy0nICsgb3JpZW50YXRpb247XG4gICAgICB0aXRsZS5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnNbb3JpZW50YXRpb25dLnRpdGxlLnRleHQ7XG5cbiAgICAgIC8vIEFkZCBzdHlsZSAtIGlmIHByb3ZpZGVkXG4gICAgICBpZiAodGhpcy5vcHRpb25zW29yaWVudGF0aW9uXS50aXRsZS5zdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHV0aWwuYWRkQ3NzVGV4dCh0aXRsZSwgdGhpcy5vcHRpb25zW29yaWVudGF0aW9uXS50aXRsZS5zdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHRpdGxlLnN0eWxlLmxlZnQgPSB0aGlzLnByb3BzLnRpdGxlQ2hhckhlaWdodCArICdweCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aXRsZS5zdHlsZS5yaWdodCA9IHRoaXMucHJvcHMudGl0bGVDaGFySGVpZ2h0ICsgJ3B4JztcbiAgICAgIH1cblxuICAgICAgdGl0bGUuc3R5bGUud2lkdGggPSB0aGlzLmhlaWdodCArICdweCc7XG4gICAgfVxuXG4gICAgLy8gd2UgbmVlZCB0byBjbGVhbiB1cCBpbiBjYXNlIHdlIGRpZCBub3QgdXNlIGFsbCBlbGVtZW50cy5cbiAgICBET011dGlsLmNsZWFudXBFbGVtZW50cyh0aGlzLkRPTWVsZW1lbnRzLnRpdGxlKTtcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRleHQgb24gdGhlIGF4aXMgKGJvdGggbWFqb3IgYW5kIG1pbm9yIGF4aXMpLlxuICAgKiBUaGUgc2l6ZSBpcyBjYWxjdWxhdGVkIG9ubHkgb25jZSBhbmQgdGhlbiBjYWNoZWQgaW4gdGhpcy5wcm9wcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIERhdGFBeGlzLnByb3RvdHlwZS5fY2FsY3VsYXRlQ2hhclNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBjaGFyIHdpZHRoIGFuZCBoZWlnaHQgb24gdGhlIG1pbm9yIGF4aXNcbiAgICBpZiAoISgnbWlub3JDaGFySGVpZ2h0JyBpbiB0aGlzLnByb3BzKSkge1xuICAgICAgdmFyIHRleHRNaW5vciA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcwJyk7XG4gICAgICB2YXIgbWVhc3VyZUNoYXJNaW5vciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgbWVhc3VyZUNoYXJNaW5vci5jbGFzc05hbWUgPSAndmlzLXktYXhpcyB2aXMtbWlub3IgdmlzLW1lYXN1cmUnO1xuICAgICAgbWVhc3VyZUNoYXJNaW5vci5hcHBlbmRDaGlsZCh0ZXh0TWlub3IpO1xuICAgICAgdGhpcy5kb20uZnJhbWUuYXBwZW5kQ2hpbGQobWVhc3VyZUNoYXJNaW5vcik7XG5cbiAgICAgIHRoaXMucHJvcHMubWlub3JDaGFySGVpZ2h0ID0gbWVhc3VyZUNoYXJNaW5vci5jbGllbnRIZWlnaHQ7XG4gICAgICB0aGlzLnByb3BzLm1pbm9yQ2hhcldpZHRoID0gbWVhc3VyZUNoYXJNaW5vci5jbGllbnRXaWR0aDtcblxuICAgICAgdGhpcy5kb20uZnJhbWUucmVtb3ZlQ2hpbGQobWVhc3VyZUNoYXJNaW5vcik7XG4gICAgfVxuXG4gICAgaWYgKCEoJ21ham9yQ2hhckhlaWdodCcgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgIHZhciB0ZXh0TWFqb3IgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnMCcpO1xuICAgICAgdmFyIG1lYXN1cmVDaGFyTWFqb3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIG1lYXN1cmVDaGFyTWFqb3IuY2xhc3NOYW1lID0gJ3Zpcy15LWF4aXMgdmlzLW1ham9yIHZpcy1tZWFzdXJlJztcbiAgICAgIG1lYXN1cmVDaGFyTWFqb3IuYXBwZW5kQ2hpbGQodGV4dE1ham9yKTtcbiAgICAgIHRoaXMuZG9tLmZyYW1lLmFwcGVuZENoaWxkKG1lYXN1cmVDaGFyTWFqb3IpO1xuXG4gICAgICB0aGlzLnByb3BzLm1ham9yQ2hhckhlaWdodCA9IG1lYXN1cmVDaGFyTWFqb3IuY2xpZW50SGVpZ2h0O1xuICAgICAgdGhpcy5wcm9wcy5tYWpvckNoYXJXaWR0aCA9IG1lYXN1cmVDaGFyTWFqb3IuY2xpZW50V2lkdGg7XG5cbiAgICAgIHRoaXMuZG9tLmZyYW1lLnJlbW92ZUNoaWxkKG1lYXN1cmVDaGFyTWFqb3IpO1xuICAgIH1cblxuICAgIGlmICghKCd0aXRsZUNoYXJIZWlnaHQnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICB2YXIgdGV4dFRpdGxlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJzAnKTtcbiAgICAgIHZhciBtZWFzdXJlQ2hhclRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBtZWFzdXJlQ2hhclRpdGxlLmNsYXNzTmFtZSA9ICd2aXMteS1heGlzIHZpcy10aXRsZSB2aXMtbWVhc3VyZSc7XG4gICAgICBtZWFzdXJlQ2hhclRpdGxlLmFwcGVuZENoaWxkKHRleHRUaXRsZSk7XG4gICAgICB0aGlzLmRvbS5mcmFtZS5hcHBlbmRDaGlsZChtZWFzdXJlQ2hhclRpdGxlKTtcblxuICAgICAgdGhpcy5wcm9wcy50aXRsZUNoYXJIZWlnaHQgPSBtZWFzdXJlQ2hhclRpdGxlLmNsaWVudEhlaWdodDtcbiAgICAgIHRoaXMucHJvcHMudGl0bGVDaGFyV2lkdGggPSBtZWFzdXJlQ2hhclRpdGxlLmNsaWVudFdpZHRoO1xuXG4gICAgICB0aGlzLmRvbS5mcmFtZS5yZW1vdmVDaGlsZChtZWFzdXJlQ2hhclRpdGxlKTtcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBEYXRhQXhpcztcblxuLyoqKi8gfSxcbi8qIDU1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIENyZWF0ZWQgYnkgbHVkbyBvbiAyNS0xLTE2LlxuICAgKi9cblxuICBmdW5jdGlvbiBEYXRhU2NhbGUoc3RhcnQsIGVuZCwgYXV0b1NjYWxlU3RhcnQsIGF1dG9TY2FsZUVuZCwgY29udGFpbmVySGVpZ2h0LCBtYWpvckNoYXJIZWlnaHQpIHtcbiAgICB2YXIgemVyb0FsaWduID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiBmYWxzZTtcbiAgICB2YXIgZm9ybWF0dGluZ0Z1bmN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDcgJiYgYXJndW1lbnRzWzddICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbN10gOiBmYWxzZTtcblxuICAgIHRoaXMubWFqb3JTdGVwcyA9IFsxLCAyLCA1LCAxMF07XG4gICAgdGhpcy5taW5vclN0ZXBzID0gWzAuMjUsIDAuNSwgMSwgMl07XG4gICAgdGhpcy5jdXN0b21MaW5lcyA9IG51bGw7XG5cbiAgICB0aGlzLmNvbnRhaW5lckhlaWdodCA9IGNvbnRhaW5lckhlaWdodDtcbiAgICB0aGlzLm1ham9yQ2hhckhlaWdodCA9IG1ham9yQ2hhckhlaWdodDtcbiAgICB0aGlzLl9zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuX2VuZCA9IGVuZDtcblxuICAgIHRoaXMuc2NhbGUgPSAxO1xuICAgIHRoaXMubWlub3JTdGVwSWR4ID0gLTE7XG4gICAgdGhpcy5tYWduaXR1ZGVmYWN0b3IgPSAxO1xuICAgIHRoaXMuZGV0ZXJtaW5lU2NhbGUoKTtcblxuICAgIHRoaXMuemVyb0FsaWduID0gemVyb0FsaWduO1xuICAgIHRoaXMuYXV0b1NjYWxlU3RhcnQgPSBhdXRvU2NhbGVTdGFydDtcbiAgICB0aGlzLmF1dG9TY2FsZUVuZCA9IGF1dG9TY2FsZUVuZDtcblxuICAgIHRoaXMuZm9ybWF0dGluZ0Z1bmN0aW9uID0gZm9ybWF0dGluZ0Z1bmN0aW9uO1xuXG4gICAgaWYgKGF1dG9TY2FsZVN0YXJ0IHx8IGF1dG9TY2FsZUVuZCkge1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHZhciByb3VuZFRvTWlub3IgPSBmdW5jdGlvbiByb3VuZFRvTWlub3IodmFsdWUpIHtcbiAgICAgICAgdmFyIHJvdW5kZWQgPSB2YWx1ZSAtIHZhbHVlICUgKG1lLm1hZ25pdHVkZWZhY3RvciAqIG1lLm1pbm9yU3RlcHNbbWUubWlub3JTdGVwSWR4XSk7XG4gICAgICAgIGlmICh2YWx1ZSAlIChtZS5tYWduaXR1ZGVmYWN0b3IgKiBtZS5taW5vclN0ZXBzW21lLm1pbm9yU3RlcElkeF0pID4gMC41ICogKG1lLm1hZ25pdHVkZWZhY3RvciAqIG1lLm1pbm9yU3RlcHNbbWUubWlub3JTdGVwSWR4XSkpIHtcbiAgICAgICAgICByZXR1cm4gcm91bmRlZCArIG1lLm1hZ25pdHVkZWZhY3RvciAqIG1lLm1pbm9yU3RlcHNbbWUubWlub3JTdGVwSWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcm91bmRlZDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChhdXRvU2NhbGVTdGFydCkge1xuICAgICAgICB0aGlzLl9zdGFydCAtPSB0aGlzLm1hZ25pdHVkZWZhY3RvciAqIDIgKiB0aGlzLm1pbm9yU3RlcHNbdGhpcy5taW5vclN0ZXBJZHhdO1xuICAgICAgICB0aGlzLl9zdGFydCA9IHJvdW5kVG9NaW5vcih0aGlzLl9zdGFydCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdXRvU2NhbGVFbmQpIHtcbiAgICAgICAgdGhpcy5fZW5kICs9IHRoaXMubWFnbml0dWRlZmFjdG9yICogdGhpcy5taW5vclN0ZXBzW3RoaXMubWlub3JTdGVwSWR4XTtcbiAgICAgICAgdGhpcy5fZW5kID0gcm91bmRUb01pbm9yKHRoaXMuX2VuZCk7XG4gICAgICB9XG4gICAgICB0aGlzLmRldGVybWluZVNjYWxlKCk7XG4gICAgfVxuICB9XG5cbiAgRGF0YVNjYWxlLnByb3RvdHlwZS5zZXRDaGFySGVpZ2h0ID0gZnVuY3Rpb24gKG1ham9yQ2hhckhlaWdodCkge1xuICAgIHRoaXMubWFqb3JDaGFySGVpZ2h0ID0gbWFqb3JDaGFySGVpZ2h0O1xuICB9O1xuXG4gIERhdGFTY2FsZS5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGNvbnRhaW5lckhlaWdodCkge1xuICAgIHRoaXMuY29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0O1xuICB9O1xuXG4gIERhdGFTY2FsZS5wcm90b3R5cGUuZGV0ZXJtaW5lU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5fZW5kIC0gdGhpcy5fc3RhcnQ7XG4gICAgdGhpcy5zY2FsZSA9IHRoaXMuY29udGFpbmVySGVpZ2h0IC8gcmFuZ2U7XG4gICAgdmFyIG1pbmltdW1TdGVwVmFsdWUgPSB0aGlzLm1ham9yQ2hhckhlaWdodCAvIHRoaXMuc2NhbGU7XG4gICAgdmFyIG9yZGVyT2ZNYWduaXR1ZGUgPSByYW5nZSA+IDAgPyBNYXRoLnJvdW5kKE1hdGgubG9nKHJhbmdlKSAvIE1hdGguTE4xMCkgOiAwO1xuXG4gICAgdGhpcy5taW5vclN0ZXBJZHggPSAtMTtcbiAgICB0aGlzLm1hZ25pdHVkZWZhY3RvciA9IE1hdGgucG93KDEwLCBvcmRlck9mTWFnbml0dWRlKTtcblxuICAgIHZhciBzdGFydCA9IDA7XG4gICAgaWYgKG9yZGVyT2ZNYWduaXR1ZGUgPCAwKSB7XG4gICAgICBzdGFydCA9IG9yZGVyT2ZNYWduaXR1ZGU7XG4gICAgfVxuXG4gICAgdmFyIHNvbHV0aW9uRm91bmQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBsID0gc3RhcnQ7IE1hdGguYWJzKGwpIDw9IE1hdGguYWJzKG9yZGVyT2ZNYWduaXR1ZGUpOyBsKyspIHtcbiAgICAgIHRoaXMubWFnbml0dWRlZmFjdG9yID0gTWF0aC5wb3coMTAsIGwpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLm1pbm9yU3RlcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHN0ZXBTaXplID0gdGhpcy5tYWduaXR1ZGVmYWN0b3IgKiB0aGlzLm1pbm9yU3RlcHNbal07XG4gICAgICAgIGlmIChzdGVwU2l6ZSA+PSBtaW5pbXVtU3RlcFZhbHVlKSB7XG4gICAgICAgICAgc29sdXRpb25Gb3VuZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5taW5vclN0ZXBJZHggPSBqO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc29sdXRpb25Gb3VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgRGF0YVNjYWxlLnByb3RvdHlwZS5pc19tYWpvciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAlICh0aGlzLm1hZ25pdHVkZWZhY3RvciAqIHRoaXMubWFqb3JTdGVwc1t0aGlzLm1pbm9yU3RlcElkeF0pID09PSAwO1xuICB9O1xuXG4gIERhdGFTY2FsZS5wcm90b3R5cGUuZ2V0U3RlcCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYWduaXR1ZGVmYWN0b3IgKiB0aGlzLm1pbm9yU3RlcHNbdGhpcy5taW5vclN0ZXBJZHhdO1xuICB9O1xuXG4gIERhdGFTY2FsZS5wcm90b3R5cGUuZ2V0Rmlyc3RNYWpvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWFqb3JTdGVwID0gdGhpcy5tYWduaXR1ZGVmYWN0b3IgKiB0aGlzLm1ham9yU3RlcHNbdGhpcy5taW5vclN0ZXBJZHhdO1xuICAgIHJldHVybiB0aGlzLmNvbnZlcnRWYWx1ZSh0aGlzLl9zdGFydCArIChtYWpvclN0ZXAgLSB0aGlzLl9zdGFydCAlIG1ham9yU3RlcCkgJSBtYWpvclN0ZXApO1xuICB9O1xuXG4gIERhdGFTY2FsZS5wcm90b3R5cGUuZm9ybWF0VmFsdWUgPSBmdW5jdGlvbiAoY3VycmVudCkge1xuICAgIHZhciByZXR1cm5WYWx1ZSA9IGN1cnJlbnQudG9QcmVjaXNpb24oNSk7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmZvcm1hdHRpbmdGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuVmFsdWUgPSB0aGlzLmZvcm1hdHRpbmdGdW5jdGlvbihjdXJyZW50KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJldHVyblZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICcnICsgcmV0dXJuVmFsdWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmV0dXJuVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdXJyZW50LnRvUHJlY2lzaW9uKDUpO1xuICAgIH1cbiAgfTtcblxuICBEYXRhU2NhbGUucHJvdG90eXBlLmdldExpbmVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIHZhciBzdGVwID0gdGhpcy5nZXRTdGVwKCk7XG4gICAgdmFyIGJvdHRvbU9mZnNldCA9IChzdGVwIC0gdGhpcy5fc3RhcnQgJSBzdGVwKSAlIHN0ZXA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuX3N0YXJ0ICsgYm90dG9tT2Zmc2V0OyB0aGlzLl9lbmQgLSBpID4gMC4wMDAwMTsgaSArPSBzdGVwKSB7XG4gICAgICBpZiAoaSAhPSB0aGlzLl9zdGFydCkge1xuICAgICAgICAvL1NraXAgdGhlIGJvdHRvbSBsaW5lXG4gICAgICAgIGxpbmVzLnB1c2goeyBtYWpvcjogdGhpcy5pc19tYWpvcihpKSwgeTogdGhpcy5jb252ZXJ0VmFsdWUoaSksIHZhbDogdGhpcy5mb3JtYXRWYWx1ZShpKSB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9O1xuXG4gIERhdGFTY2FsZS5wcm90b3R5cGUuZm9sbG93U2NhbGUgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICB2YXIgb2xkU3RlcElkeCA9IHRoaXMubWlub3JTdGVwSWR4O1xuICAgIHZhciBvbGRTdGFydCA9IHRoaXMuX3N0YXJ0O1xuICAgIHZhciBvbGRFbmQgPSB0aGlzLl9lbmQ7XG5cbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBpbmNyZWFzZU1hZ25pdHVkZSA9IGZ1bmN0aW9uIGluY3JlYXNlTWFnbml0dWRlKCkge1xuICAgICAgbWUubWFnbml0dWRlZmFjdG9yICo9IDI7XG4gICAgfTtcbiAgICB2YXIgZGVjcmVhc2VNYWduaXR1ZGUgPSBmdW5jdGlvbiBkZWNyZWFzZU1hZ25pdHVkZSgpIHtcbiAgICAgIG1lLm1hZ25pdHVkZWZhY3RvciAvPSAyO1xuICAgIH07XG5cbiAgICBpZiAob3RoZXIubWlub3JTdGVwSWR4IDw9IDEgJiYgdGhpcy5taW5vclN0ZXBJZHggPD0gMSB8fCBvdGhlci5taW5vclN0ZXBJZHggPiAxICYmIHRoaXMubWlub3JTdGVwSWR4ID4gMSkge1xuICAgICAgLy9lYXN5LCBubyBuZWVkIHRvIGNoYW5nZSBzdGVwSWR4IG5vciBtdWx0aXBsaWNhdGlvbiBmYWN0b3JcbiAgICB9IGVsc2UgaWYgKG90aGVyLm1pbm9yU3RlcElkeCA8IHRoaXMubWlub3JTdGVwSWR4KSB7XG4gICAgICAvL0knbSA1LCB0aGV5IGFyZSA0IHBlciBtYWpvci5cbiAgICAgIHRoaXMubWlub3JTdGVwSWR4ID0gMTtcbiAgICAgIGlmIChvbGRTdGVwSWR4ID09IDIpIHtcbiAgICAgICAgaW5jcmVhc2VNYWduaXR1ZGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluY3JlYXNlTWFnbml0dWRlKCk7XG4gICAgICAgIGluY3JlYXNlTWFnbml0dWRlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vSSdtIDQsIHRoZXkgYXJlIDUgcGVyIG1ham9yXG4gICAgICB0aGlzLm1pbm9yU3RlcElkeCA9IDI7XG4gICAgICBpZiAob2xkU3RlcElkeCA9PSAxKSB7XG4gICAgICAgIGRlY3JlYXNlTWFnbml0dWRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWNyZWFzZU1hZ25pdHVkZSgpO1xuICAgICAgICBkZWNyZWFzZU1hZ25pdHVkZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vR2V0IG1hc3RlcnMgc3RhdHM6XG4gICAgdmFyIGxpbmVzID0gb3RoZXIuZ2V0TGluZXMoKTtcbiAgICB2YXIgb3RoZXJaZXJvID0gb3RoZXIuY29udmVydFZhbHVlKDApO1xuICAgIHZhciBvdGhlclN0ZXAgPSBvdGhlci5nZXRTdGVwKCkgKiBvdGhlci5zY2FsZTtcblxuICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICAvL0xvb3AgdW50aWwgbWFnbml0dWRlIGlzIGNvcnJlY3QgZm9yIGdpdmVuIGNvbnN0cmFpbnMuXG4gICAgd2hpbGUgKCFkb25lICYmIGNvdW50KysgPCA1KSB7XG5cbiAgICAgIC8vR2V0IG15IHN0YXRzOlxuICAgICAgdGhpcy5zY2FsZSA9IG90aGVyU3RlcCAvICh0aGlzLm1pbm9yU3RlcHNbdGhpcy5taW5vclN0ZXBJZHhdICogdGhpcy5tYWduaXR1ZGVmYWN0b3IpO1xuICAgICAgdmFyIG5ld1JhbmdlID0gdGhpcy5jb250YWluZXJIZWlnaHQgLyB0aGlzLnNjYWxlO1xuXG4gICAgICAvL0ZvciB0aGUgY2FzZSB0aGUgbWFnbml0dWRlZmFjdG9yIGhhcyBjaGFuZ2VkOlxuICAgICAgdGhpcy5fc3RhcnQgPSBvbGRTdGFydDtcbiAgICAgIHRoaXMuX2VuZCA9IHRoaXMuX3N0YXJ0ICsgbmV3UmFuZ2U7XG5cbiAgICAgIHZhciBteU9yaWdpbmFsWmVybyA9IHRoaXMuX2VuZCAqIHRoaXMuc2NhbGU7XG4gICAgICB2YXIgbWFqb3JTdGVwID0gdGhpcy5tYWduaXR1ZGVmYWN0b3IgKiB0aGlzLm1ham9yU3RlcHNbdGhpcy5taW5vclN0ZXBJZHhdO1xuICAgICAgdmFyIG1ham9yT2Zmc2V0ID0gdGhpcy5nZXRGaXJzdE1ham9yKCkgLSBvdGhlci5nZXRGaXJzdE1ham9yKCk7XG5cbiAgICAgIGlmICh0aGlzLnplcm9BbGlnbikge1xuICAgICAgICB2YXIgemVyb09mZnNldCA9IG90aGVyWmVybyAtIG15T3JpZ2luYWxaZXJvO1xuICAgICAgICB0aGlzLl9lbmQgKz0gemVyb09mZnNldCAvIHRoaXMuc2NhbGU7XG4gICAgICAgIHRoaXMuX3N0YXJ0ID0gdGhpcy5fZW5kIC0gbmV3UmFuZ2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuYXV0b1NjYWxlU3RhcnQpIHtcbiAgICAgICAgICB0aGlzLl9zdGFydCArPSBtYWpvclN0ZXAgLSBtYWpvck9mZnNldCAvIHRoaXMuc2NhbGU7XG4gICAgICAgICAgdGhpcy5fZW5kID0gdGhpcy5fc3RhcnQgKyBuZXdSYW5nZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zdGFydCAtPSBtYWpvck9mZnNldCAvIHRoaXMuc2NhbGU7XG4gICAgICAgICAgdGhpcy5fZW5kID0gdGhpcy5fc3RhcnQgKyBuZXdSYW5nZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmF1dG9TY2FsZUVuZCAmJiB0aGlzLl9lbmQgPiBvbGRFbmQgKyAwLjAwMDAxKSB7XG4gICAgICAgIC8vTmVlZCB0byBkZWNyZWFzZSBtYWduaXR1ZGUgdG8gcHJldmVudCBzY2FsZSBvdmVyc2hvb3QhIChlbmQpXG4gICAgICAgIGRlY3JlYXNlTWFnbml0dWRlKCk7XG4gICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuYXV0b1NjYWxlU3RhcnQgJiYgdGhpcy5fc3RhcnQgPCBvbGRTdGFydCAtIDAuMDAwMDEpIHtcbiAgICAgICAgaWYgKHRoaXMuemVyb0FsaWduICYmIG9sZFN0YXJ0ID49IDApIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJDYW4ndCBhZGhlcmUgdG8gZ2l2ZW4gJ21pbicgcmFuZ2UsIGR1ZSB0byB6ZXJvYWxpZ25cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9OZWVkIHRvIGRlY3JlYXNlIG1hZ25pdHVkZSB0byBwcmV2ZW50IHNjYWxlIG92ZXJzaG9vdCEgKHN0YXJ0KVxuICAgICAgICAgIGRlY3JlYXNlTWFnbml0dWRlKCk7XG4gICAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5hdXRvU2NhbGVTdGFydCAmJiB0aGlzLmF1dG9TY2FsZUVuZCAmJiBuZXdSYW5nZSA8IG9sZEVuZCAtIG9sZFN0YXJ0KSB7XG4gICAgICAgIGluY3JlYXNlTWFnbml0dWRlKCk7XG4gICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgRGF0YVNjYWxlLnByb3RvdHlwZS5jb252ZXJ0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXJIZWlnaHQgLSAodmFsdWUgLSB0aGlzLl9zdGFydCkgKiB0aGlzLnNjYWxlO1xuICB9O1xuXG4gIERhdGFTY2FsZS5wcm90b3R5cGUuc2NyZWVuVG9WYWx1ZSA9IGZ1bmN0aW9uIChwaXhlbHMpIHtcbiAgICByZXR1cm4gKHRoaXMuY29udGFpbmVySGVpZ2h0IC0gcGl4ZWxzKSAvIHRoaXMuc2NhbGUgKyB0aGlzLl9zdGFydDtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IERhdGFTY2FsZTtcblxuLyoqKi8gfSxcbi8qIDU2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIERPTXV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuICB2YXIgQmFycyA9IF9fd2VicGFja19yZXF1aXJlX18oNTcpO1xuICB2YXIgTGluZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KTtcbiAgdmFyIFBvaW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpO1xuXG4gIC8qKlxuICAgKiAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGdyb3VwICAgICAgICAgICAgfCB0aGUgb2JqZWN0IG9mIHRoZSBncm91cCBmcm9tIHRoZSBkYXRhc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBncm91cElkICAgICAgICAgIHwgSUQgb2YgdGhlIGdyb3VwXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICAgICAgICAgIHwgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge2FycmF5fSBncm91cHNVc2luZ0RlZmF1bHRTdHlsZXMgIHwgdGhpcyBhcnJheSBoYXMgb25lIGVudHJlZS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEl0IGlzIHBhc3NlZCBhcyBhbiBhcnJheSBzbyBpdCBpcyBwYXNzZWQgYnkgcmVmZXJlbmNlLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSXQgZW51bWVyYXRlcyB0aHJvdWdoIHRoZSBkZWZhdWx0IHN0eWxlc1xuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIEdyYXBoR3JvdXAoZ3JvdXAsIGdyb3VwSWQsIG9wdGlvbnMsIGdyb3Vwc1VzaW5nRGVmYXVsdFN0eWxlcykge1xuICAgIHRoaXMuaWQgPSBncm91cElkO1xuICAgIHZhciBmaWVsZHMgPSBbJ3NhbXBsaW5nJywgJ3N0eWxlJywgJ3NvcnQnLCAneUF4aXNPcmllbnRhdGlvbicsICdiYXJDaGFydCcsICdkcmF3UG9pbnRzJywgJ3NoYWRlZCcsICdpbnRlcnBvbGF0aW9uJywgJ3pJbmRleCcsICdleGNsdWRlRnJvbVN0YWNraW5nJywgJ2V4Y2x1ZGVGcm9tTGVnZW5kJ107XG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5zZWxlY3RpdmVCcmlkZ2VPYmplY3QoZmllbGRzLCBvcHRpb25zKTtcbiAgICB0aGlzLnVzaW5nRGVmYXVsdFN0eWxlID0gZ3JvdXAuY2xhc3NOYW1lID09PSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ncm91cHNVc2luZ0RlZmF1bHRTdHlsZXMgPSBncm91cHNVc2luZ0RlZmF1bHRTdHlsZXM7XG4gICAgdGhpcy56ZXJvUG9zaXRpb24gPSAwO1xuICAgIHRoaXMudXBkYXRlKGdyb3VwKTtcbiAgICBpZiAodGhpcy51c2luZ0RlZmF1bHRTdHlsZSA9PSB0cnVlKSB7XG4gICAgICB0aGlzLmdyb3Vwc1VzaW5nRGVmYXVsdFN0eWxlc1swXSArPSAxO1xuICAgIH1cbiAgICB0aGlzLml0ZW1zRGF0YSA9IFtdO1xuICAgIHRoaXMudmlzaWJsZSA9IGdyb3VwLnZpc2libGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBncm91cC52aXNpYmxlO1xuICB9XG5cbiAgLyoqXG4gICAqIHRoaXMgbG9hZHMgYSByZWZlcmVuY2UgdG8gYWxsIGl0ZW1zIGluIHRoaXMgZ3JvdXAgaW50byB0aGlzIGdyb3VwLlxuICAgKiBAcGFyYW0ge2FycmF5fSBpdGVtc1xuICAgKi9cbiAgR3JhcGhHcm91cC5wcm90b3R5cGUuc2V0SXRlbXMgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICBpZiAoaXRlbXMgIT0gbnVsbCkge1xuICAgICAgdGhpcy5pdGVtc0RhdGEgPSBpdGVtcztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc29ydCA9PSB0cnVlKSB7XG4gICAgICAgIHV0aWwuaW5zZXJ0U29ydCh0aGlzLml0ZW1zRGF0YSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYS54ID4gYi54ID8gMSA6IC0xO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pdGVtc0RhdGEgPSBbXTtcbiAgICB9XG4gIH07XG5cbiAgR3JhcGhHcm91cC5wcm90b3R5cGUuZ2V0SXRlbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXNEYXRhO1xuICB9O1xuXG4gIC8qKlxuICAgKiB0aGlzIGlzIHVzZWQgZm9yIGJhcmNoYXJ0cyBhbmQgc2hhZGluZywgdGhpcyB3YXksIHdlIG9ubHkgaGF2ZSB0byBjYWxjdWxhdGUgaXQgb25jZS5cbiAgICogQHBhcmFtIHBvc1xuICAgKi9cbiAgR3JhcGhHcm91cC5wcm90b3R5cGUuc2V0WmVyb1Bvc2l0aW9uID0gZnVuY3Rpb24gKHBvcykge1xuICAgIHRoaXMuemVyb1Bvc2l0aW9uID0gcG9zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBzZXQgdGhlIG9wdGlvbnMgb2YgdGhlIGdyYXBoIGdyb3VwIG92ZXIgdGhlIGRlZmF1bHQgb3B0aW9ucy5cbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICovXG4gIEdyYXBoR3JvdXAucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBmaWVsZHMgPSBbJ3NhbXBsaW5nJywgJ3N0eWxlJywgJ3NvcnQnLCAneUF4aXNPcmllbnRhdGlvbicsICdiYXJDaGFydCcsICd6SW5kZXgnLCAnZXhjbHVkZUZyb21TdGFja2luZycsICdleGNsdWRlRnJvbUxlZ2VuZCddO1xuICAgICAgdXRpbC5zZWxlY3RpdmVEZWVwRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgLy8gaWYgdGhlIGdyb3VwJ3MgZHJhd1BvaW50cyBpcyBhIGZ1bmN0aW9uIGRlbGVnYXRlIHRoZSBjYWxsYmFjayB0byB0aGUgb25SZW5kZXIgcHJvcGVydHlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kcmF3UG9pbnRzID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0aW9ucy5kcmF3UG9pbnRzID0ge1xuICAgICAgICAgIG9uUmVuZGVyOiBvcHRpb25zLmRyYXdQb2ludHNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdXRpbC5tZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zLCAnaW50ZXJwb2xhdGlvbicpO1xuICAgICAgdXRpbC5tZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zLCAnZHJhd1BvaW50cycpO1xuICAgICAgdXRpbC5tZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zLCAnc2hhZGVkJyk7XG5cbiAgICAgIGlmIChvcHRpb25zLmludGVycG9sYXRpb24pIHtcbiAgICAgICAgaWYgKF90eXBlb2Yob3B0aW9ucy5pbnRlcnBvbGF0aW9uKSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmIChvcHRpb25zLmludGVycG9sYXRpb24ucGFyYW1ldHJpemF0aW9uKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pbnRlcnBvbGF0aW9uLnBhcmFtZXRyaXphdGlvbiA9PSAndW5pZm9ybScpIHtcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uYWxwaGEgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmludGVycG9sYXRpb24ucGFyYW1ldHJpemF0aW9uID09ICdjaG9yZGFsJykge1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5hbHBoYSA9IDEuMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLnBhcmFtZXRyaXphdGlvbiA9ICdjZW50cmlwZXRhbCc7XG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmFscGhhID0gMC41O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogdGhpcyB1cGRhdGVzIHRoZSBjdXJyZW50IGdyb3VwIGNsYXNzIHdpdGggdGhlIGxhdGVzdCBncm91cCBkYXRhc2V0IGVudHJlZSwgdXNlZCBpbiBfdXBkYXRlR3JvdXAgaW4gbGluZWdyYXBoXG4gICAqIEBwYXJhbSBncm91cFxuICAgKi9cbiAgR3JhcGhHcm91cC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgdGhpcy5ncm91cCA9IGdyb3VwO1xuICAgIHRoaXMuY29udGVudCA9IGdyb3VwLmNvbnRlbnQgfHwgJ2dyYXBoJztcbiAgICB0aGlzLmNsYXNzTmFtZSA9IGdyb3VwLmNsYXNzTmFtZSB8fCB0aGlzLmNsYXNzTmFtZSB8fCAndmlzLWdyYXBoLWdyb3VwJyArIHRoaXMuZ3JvdXBzVXNpbmdEZWZhdWx0U3R5bGVzWzBdICUgMTA7XG4gICAgdGhpcy52aXNpYmxlID0gZ3JvdXAudmlzaWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGdyb3VwLnZpc2libGU7XG4gICAgdGhpcy5zdHlsZSA9IGdyb3VwLnN0eWxlO1xuICAgIHRoaXMuc2V0T3B0aW9ucyhncm91cC5vcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogcmV0dXJuIHRoZSBsZWdlbmQgZW50cmVlIGZvciB0aGlzIGdyb3VwLlxuICAgKlxuICAgKiBAcGFyYW0gaWNvbldpZHRoXG4gICAqIEBwYXJhbSBpY29uSGVpZ2h0XG4gICAqIEByZXR1cm5zIHt7aWNvbjogSFRNTEVsZW1lbnQsIGxhYmVsOiAoZ3JvdXAuY29udGVudHwqfHN0cmluZyksIG9yaWVudGF0aW9uOiAoLm9wdGlvbnMueUF4aXNPcmllbnRhdGlvbnwqKX19XG4gICAqL1xuICBHcmFwaEdyb3VwLnByb3RvdHlwZS5nZXRMZWdlbmQgPSBmdW5jdGlvbiAoaWNvbldpZHRoLCBpY29uSGVpZ2h0LCBmcmFtZXdvcmssIHgsIHkpIHtcbiAgICBpZiAoZnJhbWV3b3JrID09IHVuZGVmaW5lZCB8fCBmcmFtZXdvcmsgPT0gbnVsbCkge1xuICAgICAgdmFyIHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBcInN2Z1wiKTtcbiAgICAgIGZyYW1ld29yayA9IHsgc3ZnOiBzdmcsIHN2Z0VsZW1lbnRzOiB7fSwgb3B0aW9uczogdGhpcy5vcHRpb25zLCBncm91cHM6IFt0aGlzXSB9O1xuICAgIH1cbiAgICBpZiAoeCA9PSB1bmRlZmluZWQgfHwgeCA9PSBudWxsKSB7XG4gICAgICB4ID0gMDtcbiAgICB9XG4gICAgaWYgKHkgPT0gdW5kZWZpbmVkIHx8IHkgPT0gbnVsbCkge1xuICAgICAgeSA9IDAuNSAqIGljb25IZWlnaHQ7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLnN0eWxlKSB7XG4gICAgICBjYXNlIFwibGluZVwiOlxuICAgICAgICBMaW5lcy5kcmF3SWNvbih0aGlzLCB4LCB5LCBpY29uV2lkdGgsIGljb25IZWlnaHQsIGZyYW1ld29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInBvaW50c1wiOiAvL2V4cGxpY2l0IG5vIGJyZWFrXG4gICAgICBjYXNlIFwicG9pbnRcIjpcbiAgICAgICAgUG9pbnRzLmRyYXdJY29uKHRoaXMsIHgsIHksIGljb25XaWR0aCwgaWNvbkhlaWdodCwgZnJhbWV3b3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYmFyXCI6XG4gICAgICAgIEJhcnMuZHJhd0ljb24odGhpcywgeCwgeSwgaWNvbldpZHRoLCBpY29uSGVpZ2h0LCBmcmFtZXdvcmspO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHsgaWNvbjogZnJhbWV3b3JrLnN2ZywgbGFiZWw6IHRoaXMuY29udGVudCwgb3JpZW50YXRpb246IHRoaXMub3B0aW9ucy55QXhpc09yaWVudGF0aW9uIH07XG4gIH07XG5cbiAgR3JhcGhHcm91cC5wcm90b3R5cGUuZ2V0WVJhbmdlID0gZnVuY3Rpb24gKGdyb3VwRGF0YSkge1xuICAgIHZhciB5TWluID0gZ3JvdXBEYXRhWzBdLnk7XG4gICAgdmFyIHlNYXggPSBncm91cERhdGFbMF0ueTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdyb3VwRGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgeU1pbiA9IHlNaW4gPiBncm91cERhdGFbal0ueSA/IGdyb3VwRGF0YVtqXS55IDogeU1pbjtcbiAgICAgIHlNYXggPSB5TWF4IDwgZ3JvdXBEYXRhW2pdLnkgPyBncm91cERhdGFbal0ueSA6IHlNYXg7XG4gICAgfVxuICAgIHJldHVybiB7IG1pbjogeU1pbiwgbWF4OiB5TWF4LCB5QXhpc09yaWVudGF0aW9uOiB0aGlzLm9wdGlvbnMueUF4aXNPcmllbnRhdGlvbiB9O1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gR3JhcGhHcm91cDtcblxuLyoqKi8gfSxcbi8qIDU3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIERPTXV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuICB2YXIgUG9pbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XG5cbiAgZnVuY3Rpb24gQmFyZ3JhcGgoZ3JvdXBJZCwgb3B0aW9ucykge31cblxuICBCYXJncmFwaC5kcmF3SWNvbiA9IGZ1bmN0aW9uIChncm91cCwgeCwgeSwgaWNvbldpZHRoLCBpY29uSGVpZ2h0LCBmcmFtZXdvcmspIHtcbiAgICB2YXIgZmlsbEhlaWdodCA9IGljb25IZWlnaHQgKiAwLjU7XG4gICAgdmFyIHBhdGgsIGZpbGxQYXRoO1xuXG4gICAgdmFyIG91dGxpbmUgPSBET011dGlsLmdldFNWR0VsZW1lbnQoXCJyZWN0XCIsIGZyYW1ld29yay5zdmdFbGVtZW50cywgZnJhbWV3b3JrLnN2Zyk7XG4gICAgb3V0bGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgeCk7XG4gICAgb3V0bGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgeSAtIGZpbGxIZWlnaHQpO1xuICAgIG91dGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBpY29uV2lkdGgpO1xuICAgIG91dGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgMiAqIGZpbGxIZWlnaHQpO1xuICAgIG91dGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjbGFzc1wiLCBcInZpcy1vdXRsaW5lXCIpO1xuXG4gICAgdmFyIGJhcldpZHRoID0gTWF0aC5yb3VuZCgwLjMgKiBpY29uV2lkdGgpO1xuICAgIHZhciBvcmlnaW5hbFdpZHRoID0gZ3JvdXAub3B0aW9ucy5iYXJDaGFydC53aWR0aDtcbiAgICB2YXIgc2NhbGUgPSBvcmlnaW5hbFdpZHRoIC8gYmFyV2lkdGg7XG4gICAgdmFyIGJhcjFIZWlnaHQgPSBNYXRoLnJvdW5kKDAuNCAqIGljb25IZWlnaHQpO1xuICAgIHZhciBiYXIySGVpZ2h0ID0gTWF0aC5yb3VuZCgwLjc1ICogaWNvbkhlaWdodCk7XG5cbiAgICB2YXIgb2Zmc2V0ID0gTWF0aC5yb3VuZCgoaWNvbldpZHRoIC0gMiAqIGJhcldpZHRoKSAvIDMpO1xuXG4gICAgRE9NdXRpbC5kcmF3QmFyKHggKyAwLjUgKiBiYXJXaWR0aCArIG9mZnNldCwgeSArIGZpbGxIZWlnaHQgLSBiYXIxSGVpZ2h0IC0gMSwgYmFyV2lkdGgsIGJhcjFIZWlnaHQsIGdyb3VwLmNsYXNzTmFtZSArICcgdmlzLWJhcicsIGZyYW1ld29yay5zdmdFbGVtZW50cywgZnJhbWV3b3JrLnN2ZywgZ3JvdXAuc3R5bGUpO1xuICAgIERPTXV0aWwuZHJhd0Jhcih4ICsgMS41ICogYmFyV2lkdGggKyBvZmZzZXQgKyAyLCB5ICsgZmlsbEhlaWdodCAtIGJhcjJIZWlnaHQgLSAxLCBiYXJXaWR0aCwgYmFyMkhlaWdodCwgZ3JvdXAuY2xhc3NOYW1lICsgJyB2aXMtYmFyJywgZnJhbWV3b3JrLnN2Z0VsZW1lbnRzLCBmcmFtZXdvcmsuc3ZnLCBncm91cC5zdHlsZSk7XG5cbiAgICBpZiAoZ3JvdXAub3B0aW9ucy5kcmF3UG9pbnRzLmVuYWJsZWQgPT0gdHJ1ZSkge1xuICAgICAgdmFyIGdyb3VwVGVtcGxhdGUgPSB7XG4gICAgICAgIHN0eWxlOiBncm91cC5vcHRpb25zLmRyYXdQb2ludHMuc3R5bGUsXG4gICAgICAgIHN0eWxlczogZ3JvdXAub3B0aW9ucy5kcmF3UG9pbnRzLnN0eWxlcyxcbiAgICAgICAgc2l6ZTogZ3JvdXAub3B0aW9ucy5kcmF3UG9pbnRzLnNpemUgLyBzY2FsZSxcbiAgICAgICAgY2xhc3NOYW1lOiBncm91cC5jbGFzc05hbWVcbiAgICAgIH07XG4gICAgICBET011dGlsLmRyYXdQb2ludCh4ICsgMC41ICogYmFyV2lkdGggKyBvZmZzZXQsIHkgKyBmaWxsSGVpZ2h0IC0gYmFyMUhlaWdodCAtIDEsIGdyb3VwVGVtcGxhdGUsIGZyYW1ld29yay5zdmdFbGVtZW50cywgZnJhbWV3b3JrLnN2Zyk7XG4gICAgICBET011dGlsLmRyYXdQb2ludCh4ICsgMS41ICogYmFyV2lkdGggKyBvZmZzZXQgKyAyLCB5ICsgZmlsbEhlaWdodCAtIGJhcjJIZWlnaHQgLSAxLCBncm91cFRlbXBsYXRlLCBmcmFtZXdvcmsuc3ZnRWxlbWVudHMsIGZyYW1ld29yay5zdmcpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogZHJhdyBhIGJhciBncmFwaFxuICAgKlxuICAgKiBAcGFyYW0gZ3JvdXBJZHNcbiAgICogQHBhcmFtIHByb2Nlc3NlZEdyb3VwRGF0YVxuICAgKi9cbiAgQmFyZ3JhcGguZHJhdyA9IGZ1bmN0aW9uIChncm91cElkcywgcHJvY2Vzc2VkR3JvdXBEYXRhLCBmcmFtZXdvcmspIHtcbiAgICB2YXIgY29tYmluZWREYXRhID0gW107XG4gICAgdmFyIGludGVyc2VjdGlvbnMgPSB7fTtcbiAgICB2YXIgY29yZURpc3RhbmNlO1xuICAgIHZhciBrZXksIGRyYXdEYXRhO1xuICAgIHZhciBncm91cDtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgYmFyUG9pbnRzID0gMDtcblxuICAgIC8vIGNvbWJpbmUgYWxsIGJhcmNoYXJ0IGRhdGFcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGdyb3VwID0gZnJhbWV3b3JrLmdyb3Vwc1tncm91cElkc1tpXV07XG4gICAgICBpZiAoZ3JvdXAub3B0aW9ucy5zdHlsZSA9PT0gJ2JhcicpIHtcbiAgICAgICAgaWYgKGdyb3VwLnZpc2libGUgPT09IHRydWUgJiYgKGZyYW1ld29yay5vcHRpb25zLmdyb3Vwcy52aXNpYmlsaXR5W2dyb3VwSWRzW2ldXSA9PT0gdW5kZWZpbmVkIHx8IGZyYW1ld29yay5vcHRpb25zLmdyb3Vwcy52aXNpYmlsaXR5W2dyb3VwSWRzW2ldXSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcHJvY2Vzc2VkR3JvdXBEYXRhW2dyb3VwSWRzW2ldXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29tYmluZWREYXRhLnB1c2goe1xuICAgICAgICAgICAgICBzY3JlZW5feDogcHJvY2Vzc2VkR3JvdXBEYXRhW2dyb3VwSWRzW2ldXVtqXS5zY3JlZW5feCxcbiAgICAgICAgICAgICAgc2NyZWVuX3k6IHByb2Nlc3NlZEdyb3VwRGF0YVtncm91cElkc1tpXV1bal0uc2NyZWVuX3ksXG4gICAgICAgICAgICAgIHg6IHByb2Nlc3NlZEdyb3VwRGF0YVtncm91cElkc1tpXV1bal0ueCxcbiAgICAgICAgICAgICAgeTogcHJvY2Vzc2VkR3JvdXBEYXRhW2dyb3VwSWRzW2ldXVtqXS55LFxuICAgICAgICAgICAgICBncm91cElkOiBncm91cElkc1tpXSxcbiAgICAgICAgICAgICAgbGFiZWw6IHByb2Nlc3NlZEdyb3VwRGF0YVtncm91cElkc1tpXV1bal0ubGFiZWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYmFyUG9pbnRzICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJhclBvaW50cyA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNvcnQgYnkgdGltZSBhbmQgYnkgZ3JvdXBcbiAgICBjb21iaW5lZERhdGEuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgaWYgKGEuc2NyZWVuX3ggPT09IGIuc2NyZWVuX3gpIHtcbiAgICAgICAgcmV0dXJuIGEuZ3JvdXBJZCA8IGIuZ3JvdXBJZCA/IC0xIDogMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhLnNjcmVlbl94IC0gYi5zY3JlZW5feDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGdldCBpbnRlcnNlY3Rpb25zXG4gICAgQmFyZ3JhcGguX2dldERhdGFJbnRlcnNlY3Rpb25zKGludGVyc2VjdGlvbnMsIGNvbWJpbmVkRGF0YSk7XG5cbiAgICAvLyBwbG90IGJhcmNoYXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGNvbWJpbmVkRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgZ3JvdXAgPSBmcmFtZXdvcmsuZ3JvdXBzW2NvbWJpbmVkRGF0YVtpXS5ncm91cElkXTtcbiAgICAgIHZhciBtaW5XaWR0aCA9IGdyb3VwLm9wdGlvbnMuYmFyQ2hhcnQubWluV2lkdGggIT0gdW5kZWZpbmVkID8gZ3JvdXAub3B0aW9ucy5iYXJDaGFydC5taW5XaWR0aCA6IDAuMSAqIGdyb3VwLm9wdGlvbnMuYmFyQ2hhcnQud2lkdGg7XG5cbiAgICAgIGtleSA9IGNvbWJpbmVkRGF0YVtpXS5zY3JlZW5feDtcbiAgICAgIHZhciBoZWlnaHRPZmZzZXQgPSAwO1xuICAgICAgaWYgKGludGVyc2VjdGlvbnNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpICsgMSA8IGNvbWJpbmVkRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICBjb3JlRGlzdGFuY2UgPSBNYXRoLmFicyhjb21iaW5lZERhdGFbaSArIDFdLnNjcmVlbl94IC0ga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBkcmF3RGF0YSA9IEJhcmdyYXBoLl9nZXRTYWZlRHJhd0RhdGEoY29yZURpc3RhbmNlLCBncm91cCwgbWluV2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5leHRLZXkgPSBpICsgKGludGVyc2VjdGlvbnNba2V5XS5hbW91bnQgLSBpbnRlcnNlY3Rpb25zW2tleV0ucmVzb2x2ZWQpO1xuICAgICAgICB2YXIgcHJldktleSA9IGkgLSAoaW50ZXJzZWN0aW9uc1trZXldLnJlc29sdmVkICsgMSk7XG4gICAgICAgIGlmIChuZXh0S2V5IDwgY29tYmluZWREYXRhLmxlbmd0aCkge1xuICAgICAgICAgIGNvcmVEaXN0YW5jZSA9IE1hdGguYWJzKGNvbWJpbmVkRGF0YVtuZXh0S2V5XS5zY3JlZW5feCAtIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZHJhd0RhdGEgPSBCYXJncmFwaC5fZ2V0U2FmZURyYXdEYXRhKGNvcmVEaXN0YW5jZSwgZ3JvdXAsIG1pbldpZHRoKTtcbiAgICAgICAgaW50ZXJzZWN0aW9uc1trZXldLnJlc29sdmVkICs9IDE7XG5cbiAgICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuc3RhY2sgPT09IHRydWUgJiYgZ3JvdXAub3B0aW9ucy5leGNsdWRlRnJvbVN0YWNraW5nICE9PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKGNvbWJpbmVkRGF0YVtpXS5zY3JlZW5feSA8IGdyb3VwLnplcm9Qb3NpdGlvbikge1xuICAgICAgICAgICAgaGVpZ2h0T2Zmc2V0ID0gaW50ZXJzZWN0aW9uc1trZXldLmFjY3VtdWxhdGVkTmVnYXRpdmU7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25zW2tleV0uYWNjdW11bGF0ZWROZWdhdGl2ZSArPSBncm91cC56ZXJvUG9zaXRpb24gLSBjb21iaW5lZERhdGFbaV0uc2NyZWVuX3k7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlaWdodE9mZnNldCA9IGludGVyc2VjdGlvbnNba2V5XS5hY2N1bXVsYXRlZFBvc2l0aXZlO1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uc1trZXldLmFjY3VtdWxhdGVkUG9zaXRpdmUgKz0gZ3JvdXAuemVyb1Bvc2l0aW9uIC0gY29tYmluZWREYXRhW2ldLnNjcmVlbl95O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChncm91cC5vcHRpb25zLmJhckNoYXJ0LnNpZGVCeVNpZGUgPT09IHRydWUpIHtcbiAgICAgICAgICBkcmF3RGF0YS53aWR0aCA9IGRyYXdEYXRhLndpZHRoIC8gaW50ZXJzZWN0aW9uc1trZXldLmFtb3VudDtcbiAgICAgICAgICBkcmF3RGF0YS5vZmZzZXQgKz0gaW50ZXJzZWN0aW9uc1trZXldLnJlc29sdmVkICogZHJhd0RhdGEud2lkdGggLSAwLjUgKiBkcmF3RGF0YS53aWR0aCAqIChpbnRlcnNlY3Rpb25zW2tleV0uYW1vdW50ICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIERPTXV0aWwuZHJhd0Jhcihjb21iaW5lZERhdGFbaV0uc2NyZWVuX3ggKyBkcmF3RGF0YS5vZmZzZXQsIGNvbWJpbmVkRGF0YVtpXS5zY3JlZW5feSAtIGhlaWdodE9mZnNldCwgZHJhd0RhdGEud2lkdGgsIGdyb3VwLnplcm9Qb3NpdGlvbiAtIGNvbWJpbmVkRGF0YVtpXS5zY3JlZW5feSwgZ3JvdXAuY2xhc3NOYW1lICsgJyB2aXMtYmFyJywgZnJhbWV3b3JrLnN2Z0VsZW1lbnRzLCBmcmFtZXdvcmsuc3ZnLCBncm91cC5zdHlsZSk7XG4gICAgICAvLyBkcmF3IHBvaW50c1xuICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuZHJhd1BvaW50cy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBwb2ludERhdGEgPSB7XG4gICAgICAgICAgc2NyZWVuX3g6IGNvbWJpbmVkRGF0YVtpXS5zY3JlZW5feCxcbiAgICAgICAgICBzY3JlZW5feTogY29tYmluZWREYXRhW2ldLnNjcmVlbl95IC0gaGVpZ2h0T2Zmc2V0LFxuICAgICAgICAgIHg6IGNvbWJpbmVkRGF0YVtpXS54LFxuICAgICAgICAgIHk6IGNvbWJpbmVkRGF0YVtpXS55LFxuICAgICAgICAgIGdyb3VwSWQ6IGNvbWJpbmVkRGF0YVtpXS5ncm91cElkLFxuICAgICAgICAgIGxhYmVsOiBjb21iaW5lZERhdGFbaV0ubGFiZWxcbiAgICAgICAgfTtcbiAgICAgICAgUG9pbnRzLmRyYXcoW3BvaW50RGF0YV0sIGdyb3VwLCBmcmFtZXdvcmssIGRyYXdEYXRhLm9mZnNldCk7XG4gICAgICAgIC8vRE9NdXRpbC5kcmF3UG9pbnQoY29tYmluZWREYXRhW2ldLnggKyBkcmF3RGF0YS5vZmZzZXQsIGNvbWJpbmVkRGF0YVtpXS55LCBncm91cCwgZnJhbWV3b3JrLnN2Z0VsZW1lbnRzLCBmcmFtZXdvcmsuc3ZnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbGwgdGhlIGludGVyc2VjdGlvbnMgb2JqZWN0IHdpdGggY291bnRlcnMgb2YgaG93IG1hbnkgZGF0YXBvaW50cyBzaGFyZSB0aGUgc2FtZSB4IGNvb3JkaW5hdGVzXG4gICAqIEBwYXJhbSBpbnRlcnNlY3Rpb25zXG4gICAqIEBwYXJhbSBjb21iaW5lZERhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEJhcmdyYXBoLl9nZXREYXRhSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIChpbnRlcnNlY3Rpb25zLCBjb21iaW5lZERhdGEpIHtcbiAgICAvLyBnZXQgaW50ZXJzZWN0aW9uc1xuICAgIHZhciBjb3JlRGlzdGFuY2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21iaW5lZERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpICsgMSA8IGNvbWJpbmVkRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgY29yZURpc3RhbmNlID0gTWF0aC5hYnMoY29tYmluZWREYXRhW2kgKyAxXS5zY3JlZW5feCAtIGNvbWJpbmVkRGF0YVtpXS5zY3JlZW5feCk7XG4gICAgICB9XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgY29yZURpc3RhbmNlID0gTWF0aC5taW4oY29yZURpc3RhbmNlLCBNYXRoLmFicyhjb21iaW5lZERhdGFbaSAtIDFdLnNjcmVlbl94IC0gY29tYmluZWREYXRhW2ldLnNjcmVlbl94KSk7XG4gICAgICB9XG4gICAgICBpZiAoY29yZURpc3RhbmNlID09PSAwKSB7XG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb25zW2NvbWJpbmVkRGF0YVtpXS5zY3JlZW5feF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGludGVyc2VjdGlvbnNbY29tYmluZWREYXRhW2ldLnNjcmVlbl94XSA9IHtcbiAgICAgICAgICAgIGFtb3VudDogMCxcbiAgICAgICAgICAgIHJlc29sdmVkOiAwLFxuICAgICAgICAgICAgYWNjdW11bGF0ZWRQb3NpdGl2ZTogMCxcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkTmVnYXRpdmU6IDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGludGVyc2VjdGlvbnNbY29tYmluZWREYXRhW2ldLnNjcmVlbl94XS5hbW91bnQgKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2lkdGggYW5kIG9mZnNldCBmb3IgYmFyZ3JhcGhzIGJhc2VkIG9uIHRoZSBjb3JlZGlzdGFuY2UgYmV0d2VlbiBkYXRhcG9pbnRzXG4gICAqXG4gICAqIEBwYXJhbSBjb3JlRGlzdGFuY2VcbiAgICogQHBhcmFtIGdyb3VwXG4gICAqIEBwYXJhbSBtaW5XaWR0aFxuICAgKiBAcmV0dXJucyB7e3dpZHRoOiBOdW1iZXIsIG9mZnNldDogTnVtYmVyfX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEJhcmdyYXBoLl9nZXRTYWZlRHJhd0RhdGEgPSBmdW5jdGlvbiAoY29yZURpc3RhbmNlLCBncm91cCwgbWluV2lkdGgpIHtcbiAgICB2YXIgd2lkdGgsIG9mZnNldDtcbiAgICBpZiAoY29yZURpc3RhbmNlIDwgZ3JvdXAub3B0aW9ucy5iYXJDaGFydC53aWR0aCAmJiBjb3JlRGlzdGFuY2UgPiAwKSB7XG4gICAgICB3aWR0aCA9IGNvcmVEaXN0YW5jZSA8IG1pbldpZHRoID8gbWluV2lkdGggOiBjb3JlRGlzdGFuY2U7XG5cbiAgICAgIG9mZnNldCA9IDA7IC8vIHJlY2FsY3VsYXRlIG9mZnNldCB3aXRoIHRoZSBuZXcgd2lkdGg7XG4gICAgICBpZiAoZ3JvdXAub3B0aW9ucy5iYXJDaGFydC5hbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIG9mZnNldCAtPSAwLjUgKiBjb3JlRGlzdGFuY2U7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLm9wdGlvbnMuYmFyQ2hhcnQuYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgb2Zmc2V0ICs9IDAuNSAqIGNvcmVEaXN0YW5jZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZGVmYXVsdCBzZXR0aW5nc1xuICAgICAgd2lkdGggPSBncm91cC5vcHRpb25zLmJhckNoYXJ0LndpZHRoO1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIGlmIChncm91cC5vcHRpb25zLmJhckNoYXJ0LmFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgb2Zmc2V0IC09IDAuNSAqIGdyb3VwLm9wdGlvbnMuYmFyQ2hhcnQud2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLm9wdGlvbnMuYmFyQ2hhcnQuYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgb2Zmc2V0ICs9IDAuNSAqIGdyb3VwLm9wdGlvbnMuYmFyQ2hhcnQud2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgd2lkdGg6IHdpZHRoLCBvZmZzZXQ6IG9mZnNldCB9O1xuICB9O1xuXG4gIEJhcmdyYXBoLmdldFN0YWNrZWRZUmFuZ2UgPSBmdW5jdGlvbiAoY29tYmluZWREYXRhLCBncm91cFJhbmdlcywgZ3JvdXBJZHMsIGdyb3VwTGFiZWwsIG9yaWVudGF0aW9uKSB7XG4gICAgaWYgKGNvbWJpbmVkRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBzb3J0IGJ5IHRpbWUgYW5kIGJ5IGdyb3VwXG4gICAgICBjb21iaW5lZERhdGEuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBpZiAoYS5zY3JlZW5feCA9PT0gYi5zY3JlZW5feCkge1xuICAgICAgICAgIHJldHVybiBhLmdyb3VwSWQgPCBiLmdyb3VwSWQgPyAtMSA6IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGEuc2NyZWVuX3ggLSBiLnNjcmVlbl94O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBpbnRlcnNlY3Rpb25zID0ge307XG5cbiAgICAgIEJhcmdyYXBoLl9nZXREYXRhSW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zLCBjb21iaW5lZERhdGEpO1xuICAgICAgZ3JvdXBSYW5nZXNbZ3JvdXBMYWJlbF0gPSBCYXJncmFwaC5fZ2V0U3RhY2tlZFlSYW5nZShpbnRlcnNlY3Rpb25zLCBjb21iaW5lZERhdGEpO1xuICAgICAgZ3JvdXBSYW5nZXNbZ3JvdXBMYWJlbF0ueUF4aXNPcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xuICAgICAgZ3JvdXBJZHMucHVzaChncm91cExhYmVsKTtcbiAgICB9XG4gIH07XG5cbiAgQmFyZ3JhcGguX2dldFN0YWNrZWRZUmFuZ2UgPSBmdW5jdGlvbiAoaW50ZXJzZWN0aW9ucywgY29tYmluZWREYXRhKSB7XG4gICAgdmFyIGtleTtcbiAgICB2YXIgeU1pbiA9IGNvbWJpbmVkRGF0YVswXS5zY3JlZW5feTtcbiAgICB2YXIgeU1heCA9IGNvbWJpbmVkRGF0YVswXS5zY3JlZW5feTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbWJpbmVkRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gY29tYmluZWREYXRhW2ldLnNjcmVlbl94O1xuICAgICAgaWYgKGludGVyc2VjdGlvbnNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHlNaW4gPSB5TWluID4gY29tYmluZWREYXRhW2ldLnNjcmVlbl95ID8gY29tYmluZWREYXRhW2ldLnNjcmVlbl95IDogeU1pbjtcbiAgICAgICAgeU1heCA9IHlNYXggPCBjb21iaW5lZERhdGFbaV0uc2NyZWVuX3kgPyBjb21iaW5lZERhdGFbaV0uc2NyZWVuX3kgOiB5TWF4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvbWJpbmVkRGF0YVtpXS5zY3JlZW5feSA8IDApIHtcbiAgICAgICAgICBpbnRlcnNlY3Rpb25zW2tleV0uYWNjdW11bGF0ZWROZWdhdGl2ZSArPSBjb21iaW5lZERhdGFbaV0uc2NyZWVuX3k7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW50ZXJzZWN0aW9uc1trZXldLmFjY3VtdWxhdGVkUG9zaXRpdmUgKz0gY29tYmluZWREYXRhW2ldLnNjcmVlbl95O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIHhwb3MgaW4gaW50ZXJzZWN0aW9ucykge1xuICAgICAgaWYgKGludGVyc2VjdGlvbnMuaGFzT3duUHJvcGVydHkoeHBvcykpIHtcbiAgICAgICAgeU1pbiA9IHlNaW4gPiBpbnRlcnNlY3Rpb25zW3hwb3NdLmFjY3VtdWxhdGVkTmVnYXRpdmUgPyBpbnRlcnNlY3Rpb25zW3hwb3NdLmFjY3VtdWxhdGVkTmVnYXRpdmUgOiB5TWluO1xuICAgICAgICB5TWluID0geU1pbiA+IGludGVyc2VjdGlvbnNbeHBvc10uYWNjdW11bGF0ZWRQb3NpdGl2ZSA/IGludGVyc2VjdGlvbnNbeHBvc10uYWNjdW11bGF0ZWRQb3NpdGl2ZSA6IHlNaW47XG4gICAgICAgIHlNYXggPSB5TWF4IDwgaW50ZXJzZWN0aW9uc1t4cG9zXS5hY2N1bXVsYXRlZE5lZ2F0aXZlID8gaW50ZXJzZWN0aW9uc1t4cG9zXS5hY2N1bXVsYXRlZE5lZ2F0aXZlIDogeU1heDtcbiAgICAgICAgeU1heCA9IHlNYXggPCBpbnRlcnNlY3Rpb25zW3hwb3NdLmFjY3VtdWxhdGVkUG9zaXRpdmUgPyBpbnRlcnNlY3Rpb25zW3hwb3NdLmFjY3VtdWxhdGVkUG9zaXRpdmUgOiB5TWF4O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IG1pbjogeU1pbiwgbWF4OiB5TWF4IH07XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBCYXJncmFwaDtcblxuLyoqKi8gfSxcbi8qIDU4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4gIHZhciBET011dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxuICBmdW5jdGlvbiBQb2ludHMoZ3JvdXBJZCwgb3B0aW9ucykge31cblxuICAvKipcbiAgICogZHJhdyB0aGUgZGF0YSBwb2ludHNcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gZGF0YXNldFxuICAgKiBAcGFyYW0ge09iamVjdH0gSlNPTmNvbnRhaW5lclxuICAgKiBAcGFyYW0ge09iamVjdH0gc3ZnICAgICAgICAgICAgfCBTVkcgRE9NIGVsZW1lbnRcbiAgICogQHBhcmFtIHtHcmFwaEdyb3VwfSBncm91cFxuICAgKiBAcGFyYW0ge051bWJlcn0gW29mZnNldF1cbiAgICovXG4gIFBvaW50cy5kcmF3ID0gZnVuY3Rpb24gKGRhdGFzZXQsIGdyb3VwLCBmcmFtZXdvcmssIG9mZnNldCkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgIHZhciBjYWxsYmFjayA9IGdldENhbGxiYWNrKGZyYW1ld29yaywgZ3JvdXApO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIC8vIGRyYXcgdGhlIHBvaW50IHRoZSBzaW1wbGUgd2F5LlxuICAgICAgICBET011dGlsLmRyYXdQb2ludChkYXRhc2V0W2ldLnNjcmVlbl94ICsgb2Zmc2V0LCBkYXRhc2V0W2ldLnNjcmVlbl95LCBnZXRHcm91cFRlbXBsYXRlKGdyb3VwKSwgZnJhbWV3b3JrLnN2Z0VsZW1lbnRzLCBmcmFtZXdvcmsuc3ZnLCBkYXRhc2V0W2ldLmxhYmVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjYWxsYmFja1Jlc3VsdCA9IGNhbGxiYWNrKGRhdGFzZXRbaV0sIGdyb3VwKTsgLy8gcmVzdWx0IG1pZ2h0IGJlIHRydWUsIGZhbHNlIG9yIGFuIG9iamVjdFxuICAgICAgICBpZiAoY2FsbGJhY2tSZXN1bHQgPT09IHRydWUgfHwgKHR5cGVvZiBjYWxsYmFja1Jlc3VsdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY2FsbGJhY2tSZXN1bHQpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBET011dGlsLmRyYXdQb2ludChkYXRhc2V0W2ldLnNjcmVlbl94ICsgb2Zmc2V0LCBkYXRhc2V0W2ldLnNjcmVlbl95LCBnZXRHcm91cFRlbXBsYXRlKGdyb3VwLCBjYWxsYmFja1Jlc3VsdCksIGZyYW1ld29yay5zdmdFbGVtZW50cywgZnJhbWV3b3JrLnN2ZywgZGF0YXNldFtpXS5sYWJlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgUG9pbnRzLmRyYXdJY29uID0gZnVuY3Rpb24gKGdyb3VwLCB4LCB5LCBpY29uV2lkdGgsIGljb25IZWlnaHQsIGZyYW1ld29yaykge1xuICAgIHZhciBmaWxsSGVpZ2h0ID0gaWNvbkhlaWdodCAqIDAuNTtcbiAgICB2YXIgcGF0aCwgZmlsbFBhdGg7XG5cbiAgICB2YXIgb3V0bGluZSA9IERPTXV0aWwuZ2V0U1ZHRWxlbWVudChcInJlY3RcIiwgZnJhbWV3b3JrLnN2Z0VsZW1lbnRzLCBmcmFtZXdvcmsuc3ZnKTtcbiAgICBvdXRsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCB4KTtcbiAgICBvdXRsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCB5IC0gZmlsbEhlaWdodCk7XG4gICAgb3V0bGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIGljb25XaWR0aCk7XG4gICAgb3V0bGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCAyICogZmlsbEhlaWdodCk7XG4gICAgb3V0bGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsYXNzXCIsIFwidmlzLW91dGxpbmVcIik7XG5cbiAgICAvL0Rvbid0IGNhbGwgY2FsbGJhY2sgb24gaWNvblxuICAgIERPTXV0aWwuZHJhd1BvaW50KHggKyAwLjUgKiBpY29uV2lkdGgsIHksIGdldEdyb3VwVGVtcGxhdGUoZ3JvdXApLCBmcmFtZXdvcmsuc3ZnRWxlbWVudHMsIGZyYW1ld29yay5zdmcpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGdldEdyb3VwVGVtcGxhdGUoZ3JvdXAsIGNhbGxiYWNrUmVzdWx0KSB7XG4gICAgY2FsbGJhY2tSZXN1bHQgPSB0eXBlb2YgY2FsbGJhY2tSZXN1bHQgPT09ICd1bmRlZmluZWQnID8ge30gOiBjYWxsYmFja1Jlc3VsdDtcbiAgICByZXR1cm4ge1xuICAgICAgc3R5bGU6IGNhbGxiYWNrUmVzdWx0LnN0eWxlIHx8IGdyb3VwLm9wdGlvbnMuZHJhd1BvaW50cy5zdHlsZSxcbiAgICAgIHN0eWxlczogY2FsbGJhY2tSZXN1bHQuc3R5bGVzIHx8IGdyb3VwLm9wdGlvbnMuZHJhd1BvaW50cy5zdHlsZXMsXG4gICAgICBzaXplOiBjYWxsYmFja1Jlc3VsdC5zaXplIHx8IGdyb3VwLm9wdGlvbnMuZHJhd1BvaW50cy5zaXplLFxuICAgICAgY2xhc3NOYW1lOiBjYWxsYmFja1Jlc3VsdC5jbGFzc05hbWUgfHwgZ3JvdXAuY2xhc3NOYW1lXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENhbGxiYWNrKGZyYW1ld29yaywgZ3JvdXApIHtcbiAgICB2YXIgY2FsbGJhY2sgPSB1bmRlZmluZWQ7XG4gICAgLy8gY2hlY2sgZm9yIHRoZSBncmFwaDJkIG9uUmVuZGVyXG4gICAgaWYgKGZyYW1ld29yay5vcHRpb25zICYmIGZyYW1ld29yay5vcHRpb25zLmRyYXdQb2ludHMgJiYgZnJhbWV3b3JrLm9wdGlvbnMuZHJhd1BvaW50cy5vblJlbmRlciAmJiB0eXBlb2YgZnJhbWV3b3JrLm9wdGlvbnMuZHJhd1BvaW50cy5vblJlbmRlciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGZyYW1ld29yay5vcHRpb25zLmRyYXdQb2ludHMub25SZW5kZXI7XG4gICAgfVxuXG4gICAgLy8gb3ZlcnJpZGUgaXQgd2l0aCB0aGUgZ3JvdXAgb25SZW5kZXIgaWYgZGVmaW5lZFxuICAgIGlmIChncm91cC5ncm91cC5vcHRpb25zICYmIGdyb3VwLmdyb3VwLm9wdGlvbnMuZHJhd1BvaW50cyAmJiBncm91cC5ncm91cC5vcHRpb25zLmRyYXdQb2ludHMub25SZW5kZXIgJiYgdHlwZW9mIGdyb3VwLmdyb3VwLm9wdGlvbnMuZHJhd1BvaW50cy5vblJlbmRlciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGdyb3VwLmdyb3VwLm9wdGlvbnMuZHJhd1BvaW50cy5vblJlbmRlcjtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxiYWNrO1xuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBQb2ludHM7XG5cbi8qKiovIH0sXG4vKiA1OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIERPTXV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG4gIGZ1bmN0aW9uIExpbmUoZ3JvdXBJZCwgb3B0aW9ucykge31cblxuICBMaW5lLmNhbGNQYXRoID0gZnVuY3Rpb24gKGRhdGFzZXQsIGdyb3VwKSB7XG4gICAgICBpZiAoZGF0YXNldCAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGRhdGFzZXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB2YXIgZCA9IFtdO1xuXG4gICAgICAgICAgICAgIC8vIGNvbnN0cnVjdCBwYXRoIGZyb20gZGF0YXNldFxuICAgICAgICAgICAgICBpZiAoZ3JvdXAub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmVuYWJsZWQgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgZCA9IExpbmUuX2NhdG11bGxSb20oZGF0YXNldCwgZ3JvdXApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZCA9IExpbmUuX2xpbmVhcihkYXRhc2V0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH07XG5cbiAgTGluZS5kcmF3SWNvbiA9IGZ1bmN0aW9uIChncm91cCwgeCwgeSwgaWNvbldpZHRoLCBpY29uSGVpZ2h0LCBmcmFtZXdvcmspIHtcbiAgICAgIHZhciBmaWxsSGVpZ2h0ID0gaWNvbkhlaWdodCAqIDAuNTtcbiAgICAgIHZhciBwYXRoLCBmaWxsUGF0aDtcblxuICAgICAgdmFyIG91dGxpbmUgPSBET011dGlsLmdldFNWR0VsZW1lbnQoXCJyZWN0XCIsIGZyYW1ld29yay5zdmdFbGVtZW50cywgZnJhbWV3b3JrLnN2Zyk7XG4gICAgICBvdXRsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCB4KTtcbiAgICAgIG91dGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIHkgLSBmaWxsSGVpZ2h0KTtcbiAgICAgIG91dGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBpY29uV2lkdGgpO1xuICAgICAgb3V0bGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCAyICogZmlsbEhlaWdodCk7XG4gICAgICBvdXRsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY2xhc3NcIiwgXCJ2aXMtb3V0bGluZVwiKTtcblxuICAgICAgcGF0aCA9IERPTXV0aWwuZ2V0U1ZHRWxlbWVudChcInBhdGhcIiwgZnJhbWV3b3JrLnN2Z0VsZW1lbnRzLCBmcmFtZXdvcmsuc3ZnKTtcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjbGFzc1wiLCBncm91cC5jbGFzc05hbWUpO1xuICAgICAgaWYgKGdyb3VwLnN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3R5bGVcIiwgZ3JvdXAuc3R5bGUpO1xuICAgICAgfVxuXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZFwiLCBcIk1cIiArIHggKyBcIixcIiArIHkgKyBcIiBMXCIgKyAoeCArIGljb25XaWR0aCkgKyBcIixcIiArIHkgKyBcIlwiKTtcbiAgICAgIGlmIChncm91cC5vcHRpb25zLnNoYWRlZC5lbmFibGVkID09IHRydWUpIHtcbiAgICAgICAgICBmaWxsUGF0aCA9IERPTXV0aWwuZ2V0U1ZHRWxlbWVudChcInBhdGhcIiwgZnJhbWV3b3JrLnN2Z0VsZW1lbnRzLCBmcmFtZXdvcmsuc3ZnKTtcbiAgICAgICAgICBpZiAoZ3JvdXAub3B0aW9ucy5zaGFkZWQub3JpZW50YXRpb24gPT0gJ3RvcCcpIHtcbiAgICAgICAgICAgICAgZmlsbFBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJkXCIsIFwiTVwiICsgeCArIFwiLCBcIiArICh5IC0gZmlsbEhlaWdodCkgKyBcIkxcIiArIHggKyBcIixcIiArIHkgKyBcIiBMXCIgKyAoeCArIGljb25XaWR0aCkgKyBcIixcIiArIHkgKyBcIiBMXCIgKyAoeCArIGljb25XaWR0aCkgKyBcIixcIiArICh5IC0gZmlsbEhlaWdodCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpbGxQYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZFwiLCBcIk1cIiArIHggKyBcIixcIiArIHkgKyBcIiBcIiArIFwiTFwiICsgeCArIFwiLFwiICsgKHkgKyBmaWxsSGVpZ2h0KSArIFwiIFwiICsgXCJMXCIgKyAoeCArIGljb25XaWR0aCkgKyBcIixcIiArICh5ICsgZmlsbEhlaWdodCkgKyBcIkxcIiArICh4ICsgaWNvbldpZHRoKSArIFwiLFwiICsgeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbGxQYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY2xhc3NcIiwgZ3JvdXAuY2xhc3NOYW1lICsgXCIgdmlzLWljb24tZmlsbFwiKTtcbiAgICAgICAgICBpZiAoZ3JvdXAub3B0aW9ucy5zaGFkZWQuc3R5bGUgIT09IHVuZGVmaW5lZCAmJiBncm91cC5vcHRpb25zLnNoYWRlZC5zdHlsZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICBmaWxsUGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0eWxlXCIsIGdyb3VwLm9wdGlvbnMuc2hhZGVkLnN0eWxlKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChncm91cC5vcHRpb25zLmRyYXdQb2ludHMuZW5hYmxlZCA9PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGdyb3VwVGVtcGxhdGUgPSB7XG4gICAgICAgICAgICAgIHN0eWxlOiBncm91cC5vcHRpb25zLmRyYXdQb2ludHMuc3R5bGUsXG4gICAgICAgICAgICAgIHN0eWxlczogZ3JvdXAub3B0aW9ucy5kcmF3UG9pbnRzLnN0eWxlcyxcbiAgICAgICAgICAgICAgc2l6ZTogZ3JvdXAub3B0aW9ucy5kcmF3UG9pbnRzLnNpemUsXG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogZ3JvdXAuY2xhc3NOYW1lXG4gICAgICAgICAgfTtcbiAgICAgICAgICBET011dGlsLmRyYXdQb2ludCh4ICsgMC41ICogaWNvbldpZHRoLCB5LCBncm91cFRlbXBsYXRlLCBmcmFtZXdvcmsuc3ZnRWxlbWVudHMsIGZyYW1ld29yay5zdmcpO1xuICAgICAgfVxuICB9O1xuXG4gIExpbmUuZHJhd1NoYWRpbmcgPSBmdW5jdGlvbiAocGF0aEFycmF5LCBncm91cCwgc3ViUGF0aEFycmF5LCBmcmFtZXdvcmspIHtcbiAgICAgIC8vIGFwcGVuZCBzaGFkaW5nIHRvIHRoZSBwYXRoXG4gICAgICBpZiAoZ3JvdXAub3B0aW9ucy5zaGFkZWQuZW5hYmxlZCA9PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHN2Z0hlaWdodCA9IE51bWJlcihmcmFtZXdvcmsuc3ZnLnN0eWxlLmhlaWdodC5yZXBsYWNlKCdweCcsICcnKSk7XG4gICAgICAgICAgdmFyIGZpbGxQYXRoID0gRE9NdXRpbC5nZXRTVkdFbGVtZW50KCdwYXRoJywgZnJhbWV3b3JrLnN2Z0VsZW1lbnRzLCBmcmFtZXdvcmsuc3ZnKTtcbiAgICAgICAgICB2YXIgdHlwZSA9IFwiTFwiO1xuICAgICAgICAgIGlmIChncm91cC5vcHRpb25zLmludGVycG9sYXRpb24uZW5hYmxlZCA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHR5cGUgPSBcIkNcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRGaWxsO1xuICAgICAgICAgIHZhciB6ZXJvID0gMDtcbiAgICAgICAgICBpZiAoZ3JvdXAub3B0aW9ucy5zaGFkZWQub3JpZW50YXRpb24gPT0gJ3RvcCcpIHtcbiAgICAgICAgICAgICAgemVybyA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmIChncm91cC5vcHRpb25zLnNoYWRlZC5vcmllbnRhdGlvbiA9PSAnYm90dG9tJykge1xuICAgICAgICAgICAgICB6ZXJvID0gc3ZnSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHplcm8gPSBNYXRoLm1pbihNYXRoLm1heCgwLCBncm91cC56ZXJvUG9zaXRpb24pLCBzdmdIZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZ3JvdXAub3B0aW9ucy5zaGFkZWQub3JpZW50YXRpb24gPT0gJ2dyb3VwJyAmJiBzdWJQYXRoQXJyYXkgIT0gbnVsbCAmJiBzdWJQYXRoQXJyYXkgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGRGaWxsID0gJ00nICsgcGF0aEFycmF5WzBdWzBdICsgXCIsXCIgKyBwYXRoQXJyYXlbMF1bMV0gKyBcIiBcIiArIHRoaXMuc2VyaWFsaXplUGF0aChwYXRoQXJyYXksIHR5cGUsIGZhbHNlKSArICcgTCcgKyBzdWJQYXRoQXJyYXlbc3ViUGF0aEFycmF5Lmxlbmd0aCAtIDFdWzBdICsgXCIsXCIgKyBzdWJQYXRoQXJyYXlbc3ViUGF0aEFycmF5Lmxlbmd0aCAtIDFdWzFdICsgXCIgXCIgKyB0aGlzLnNlcmlhbGl6ZVBhdGgoc3ViUGF0aEFycmF5LCB0eXBlLCB0cnVlKSArIHN1YlBhdGhBcnJheVswXVswXSArIFwiLFwiICsgc3ViUGF0aEFycmF5WzBdWzFdICsgXCIgWlwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRGaWxsID0gJ00nICsgcGF0aEFycmF5WzBdWzBdICsgXCIsXCIgKyBwYXRoQXJyYXlbMF1bMV0gKyBcIiBcIiArIHRoaXMuc2VyaWFsaXplUGF0aChwYXRoQXJyYXksIHR5cGUsIGZhbHNlKSArICcgVicgKyB6ZXJvICsgJyBIJyArIHBhdGhBcnJheVswXVswXSArIFwiIFpcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaWxsUGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCBncm91cC5jbGFzc05hbWUgKyAnIHZpcy1maWxsJyk7XG4gICAgICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuc2hhZGVkLnN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZmlsbFBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgJ3N0eWxlJywgZ3JvdXAub3B0aW9ucy5zaGFkZWQuc3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaWxsUGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZCcsIGRGaWxsKTtcbiAgICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogZHJhdyBhIGxpbmUgZ3JhcGhcbiAgICpcbiAgICogQHBhcmFtIGRhdGFzZXRcbiAgICogQHBhcmFtIGdyb3VwXG4gICAqL1xuICBMaW5lLmRyYXcgPSBmdW5jdGlvbiAocGF0aEFycmF5LCBncm91cCwgZnJhbWV3b3JrKSB7XG4gICAgICBpZiAocGF0aEFycmF5ICE9IG51bGwgJiYgcGF0aEFycmF5ICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBwYXRoID0gRE9NdXRpbC5nZXRTVkdFbGVtZW50KCdwYXRoJywgZnJhbWV3b3JrLnN2Z0VsZW1lbnRzLCBmcmFtZXdvcmsuc3ZnKTtcbiAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY2xhc3NcIiwgZ3JvdXAuY2xhc3NOYW1lKTtcbiAgICAgICAgICBpZiAoZ3JvdXAuc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3R5bGVcIiwgZ3JvdXAuc3R5bGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB0eXBlID0gXCJMXCI7XG4gICAgICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5lbmFibGVkID09IHRydWUpIHtcbiAgICAgICAgICAgICAgdHlwZSA9IFwiQ1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjb3B5IHByb3BlcnRpZXMgdG8gcGF0aCBmb3IgZHJhd2luZy5cbiAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgJ00nICsgcGF0aEFycmF5WzBdWzBdICsgXCIsXCIgKyBwYXRoQXJyYXlbMF1bMV0gKyBcIiBcIiArIHRoaXMuc2VyaWFsaXplUGF0aChwYXRoQXJyYXksIHR5cGUsIGZhbHNlKSk7XG4gICAgICB9XG4gIH07XG5cbiAgTGluZS5zZXJpYWxpemVQYXRoID0gZnVuY3Rpb24gKHBhdGhBcnJheSwgdHlwZSwgaW52ZXJzZSkge1xuICAgICAgaWYgKHBhdGhBcnJheS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgLy9Ub28gbGl0dGxlIGRhdGEgdG8gY3JlYXRlIGEgcGF0aC5cbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIHZhciBkID0gdHlwZTtcbiAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHBhdGhBcnJheS5sZW5ndGggLSAyOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgIGQgKz0gcGF0aEFycmF5W2ldWzBdICsgXCIsXCIgKyBwYXRoQXJyYXlbaV1bMV0gKyBcIiBcIjtcbiAgICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcGF0aEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGQgKz0gcGF0aEFycmF5W2ldWzBdICsgXCIsXCIgKyBwYXRoQXJyYXlbaV1bMV0gKyBcIiBcIjtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZDtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyB1c2VzIGFuIHVuaWZvcm0gcGFyYW1ldHJpemF0aW9uIG9mIHRoZSBpbnRlcnBvbGF0aW9uIGFsZ29yaXRobTpcbiAgICogJ09uIHRoZSBQYXJhbWV0ZXJpemF0aW9uIG9mIENhdG11bGwtUm9tIEN1cnZlcycgYnkgQ2VtIFl1a3NlbCBldCBhbC5cbiAgICogQHBhcmFtIGRhdGFcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIExpbmUuX2NhdG11bGxSb21Vbmlmb3JtID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIC8vIGNhdG11bGwgcm9tXG4gICAgICB2YXIgcDAsIHAxLCBwMiwgcDMsIGJwMSwgYnAyO1xuICAgICAgdmFyIGQgPSBbXTtcbiAgICAgIGQucHVzaChbTWF0aC5yb3VuZChkYXRhWzBdLnNjcmVlbl94KSwgTWF0aC5yb3VuZChkYXRhWzBdLnNjcmVlbl95KV0pO1xuICAgICAgdmFyIG5vcm1hbGl6YXRpb24gPSAxIC8gNjtcbiAgICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoIC0gMTsgaSsrKSB7XG5cbiAgICAgICAgICBwMCA9IGkgPT0gMCA/IGRhdGFbMF0gOiBkYXRhW2kgLSAxXTtcbiAgICAgICAgICBwMSA9IGRhdGFbaV07XG4gICAgICAgICAgcDIgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICBwMyA9IGkgKyAyIDwgbGVuZ3RoID8gZGF0YVtpICsgMl0gOiBwMjtcblxuICAgICAgICAgIC8vIENhdG11bGwtUm9tIHRvIEN1YmljIEJlemllciBjb252ZXJzaW9uIG1hdHJpeFxuICAgICAgICAgIC8vICAgIDAgICAgICAgMSAgICAgICAwICAgICAgIDBcbiAgICAgICAgICAvLyAgLTEvNiAgICAgIDEgICAgICAxLzYgICAgICAwXG4gICAgICAgICAgLy8gICAgMCAgICAgIDEvNiAgICAgIDEgICAgIC0xLzZcbiAgICAgICAgICAvLyAgICAwICAgICAgIDAgICAgICAgMSAgICAgICAwXG5cbiAgICAgICAgICAvLyAgICBicDAgPSB7IHg6IHAxLngsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHAxLnkgfTtcbiAgICAgICAgICBicDEgPSB7XG4gICAgICAgICAgICAgIHNjcmVlbl94OiAoLXAwLnNjcmVlbl94ICsgNiAqIHAxLnNjcmVlbl94ICsgcDIuc2NyZWVuX3gpICogbm9ybWFsaXphdGlvbixcbiAgICAgICAgICAgICAgc2NyZWVuX3k6ICgtcDAuc2NyZWVuX3kgKyA2ICogcDEuc2NyZWVuX3kgKyBwMi5zY3JlZW5feSkgKiBub3JtYWxpemF0aW9uXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicDIgPSB7XG4gICAgICAgICAgICAgIHNjcmVlbl94OiAocDEuc2NyZWVuX3ggKyA2ICogcDIuc2NyZWVuX3ggLSBwMy5zY3JlZW5feCkgKiBub3JtYWxpemF0aW9uLFxuICAgICAgICAgICAgICBzY3JlZW5feTogKHAxLnNjcmVlbl95ICsgNiAqIHAyLnNjcmVlbl95IC0gcDMuc2NyZWVuX3kpICogbm9ybWFsaXphdGlvblxuICAgICAgICAgIH07XG4gICAgICAgICAgLy8gICAgYnAwID0geyB4OiBwMi54LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBwMi55IH07XG5cbiAgICAgICAgICBkLnB1c2goW2JwMS5zY3JlZW5feCwgYnAxLnNjcmVlbl95XSk7XG4gICAgICAgICAgZC5wdXNoKFticDIuc2NyZWVuX3gsIGJwMi5zY3JlZW5feV0pO1xuICAgICAgICAgIGQucHVzaChbcDIuc2NyZWVuX3gsIHAyLnNjcmVlbl95XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIHVzZXMgZWl0aGVyIHRoZSBjaG9yZGFsIG9yIGNlbnRyaXBldGFsIHBhcmFtZXRlcml6YXRpb24gb2YgdGhlIGNhdG11bGwtcm9tIGFsZ29yaXRobS5cbiAgICogQnkgZGVmYXVsdCwgdGhlIGNlbnRyaXBldGFsIHBhcmFtZXRlcml6YXRpb24gaXMgdXNlZCBiZWNhdXNlIHRoaXMgZ2l2ZXMgdGhlIG5pY2VzdCByZXN1bHRzLlxuICAgKiBUaGVzZSBwYXJhbWV0ZXJpemF0aW9ucyBhcmUgcmVsYXRpdmVseSBoZWF2eSBiZWNhdXNlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIDQgcG9pbnRzIGhhdmUgdG8gYmUgY2FsY3VsYXRlZC5cbiAgICpcbiAgICogT25lIG9wdGltaXphdGlvbiBjYW4gYmUgdXNlZCB0byByZXVzZSBkaXN0YW5jZXMgc2luY2UgdGhpcyBpcyBhIHNsaWRpbmcgd2luZG93IGFwcHJvYWNoLlxuICAgKiBAcGFyYW0gZGF0YVxuICAgKiBAcGFyYW0gZ3JvdXBcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIExpbmUuX2NhdG11bGxSb20gPSBmdW5jdGlvbiAoZGF0YSwgZ3JvdXApIHtcbiAgICAgIHZhciBhbHBoYSA9IGdyb3VwLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5hbHBoYTtcbiAgICAgIGlmIChhbHBoYSA9PSAwIHx8IGFscGhhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY2F0bXVsbFJvbVVuaWZvcm0oZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwMCwgcDEsIHAyLCBwMywgYnAxLCBicDIsIGQxLCBkMiwgZDMsIEEsIEIsIE4sIE07XG4gICAgICAgICAgdmFyIGQzcG93QSwgZDJwb3dBLCBkM3BvdzJBLCBkMnBvdzJBLCBkMXBvdzJBLCBkMXBvd0E7XG4gICAgICAgICAgdmFyIGQgPSBbXTtcbiAgICAgICAgICBkLnB1c2goW01hdGgucm91bmQoZGF0YVswXS5zY3JlZW5feCksIE1hdGgucm91bmQoZGF0YVswXS5zY3JlZW5feSldKTtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGggLSAxOyBpKyspIHtcblxuICAgICAgICAgICAgICBwMCA9IGkgPT0gMCA/IGRhdGFbMF0gOiBkYXRhW2kgLSAxXTtcbiAgICAgICAgICAgICAgcDEgPSBkYXRhW2ldO1xuICAgICAgICAgICAgICBwMiA9IGRhdGFbaSArIDFdO1xuICAgICAgICAgICAgICBwMyA9IGkgKyAyIDwgbGVuZ3RoID8gZGF0YVtpICsgMl0gOiBwMjtcblxuICAgICAgICAgICAgICBkMSA9IE1hdGguc3FydChNYXRoLnBvdyhwMC5zY3JlZW5feCAtIHAxLnNjcmVlbl94LCAyKSArIE1hdGgucG93KHAwLnNjcmVlbl95IC0gcDEuc2NyZWVuX3ksIDIpKTtcbiAgICAgICAgICAgICAgZDIgPSBNYXRoLnNxcnQoTWF0aC5wb3cocDEuc2NyZWVuX3ggLSBwMi5zY3JlZW5feCwgMikgKyBNYXRoLnBvdyhwMS5zY3JlZW5feSAtIHAyLnNjcmVlbl95LCAyKSk7XG4gICAgICAgICAgICAgIGQzID0gTWF0aC5zcXJ0KE1hdGgucG93KHAyLnNjcmVlbl94IC0gcDMuc2NyZWVuX3gsIDIpICsgTWF0aC5wb3cocDIuc2NyZWVuX3kgLSBwMy5zY3JlZW5feSwgMikpO1xuXG4gICAgICAgICAgICAgIC8vIENhdG11bGwtUm9tIHRvIEN1YmljIEJlemllciBjb252ZXJzaW9uIG1hdHJpeFxuXG4gICAgICAgICAgICAgIC8vIEEgPSAyZDFeMmEgKyAzZDFeYSAqIGQyXmEgKyBkM14yYVxuICAgICAgICAgICAgICAvLyBCID0gMmQzXjJhICsgM2QzXmEgKiBkMl5hICsgZDJeMmFcblxuICAgICAgICAgICAgICAvLyBbICAgMCAgICAgICAgICAgICAxICAgICAgICAgICAgMCAgICAgICAgICAwICAgICAgICAgIF1cbiAgICAgICAgICAgICAgLy8gWyAgIC1kMl4yYSAvTiAgICAgQS9OICAgICAgICAgIGQxXjJhIC9OICAgMCAgICAgICAgICBdXG4gICAgICAgICAgICAgIC8vIFsgICAwICAgICAgICAgICAgIGQzXjJhIC9NICAgICBCL00gICAgICAgIC1kMl4yYSAvTSAgXVxuICAgICAgICAgICAgICAvLyBbICAgMCAgICAgICAgICAgICAwICAgICAgICAgICAgMSAgICAgICAgICAwICAgICAgICAgIF1cblxuICAgICAgICAgICAgICBkM3Bvd0EgPSBNYXRoLnBvdyhkMywgYWxwaGEpO1xuICAgICAgICAgICAgICBkM3BvdzJBID0gTWF0aC5wb3coZDMsIDIgKiBhbHBoYSk7XG4gICAgICAgICAgICAgIGQycG93QSA9IE1hdGgucG93KGQyLCBhbHBoYSk7XG4gICAgICAgICAgICAgIGQycG93MkEgPSBNYXRoLnBvdyhkMiwgMiAqIGFscGhhKTtcbiAgICAgICAgICAgICAgZDFwb3dBID0gTWF0aC5wb3coZDEsIGFscGhhKTtcbiAgICAgICAgICAgICAgZDFwb3cyQSA9IE1hdGgucG93KGQxLCAyICogYWxwaGEpO1xuXG4gICAgICAgICAgICAgIEEgPSAyICogZDFwb3cyQSArIDMgKiBkMXBvd0EgKiBkMnBvd0EgKyBkMnBvdzJBO1xuICAgICAgICAgICAgICBCID0gMiAqIGQzcG93MkEgKyAzICogZDNwb3dBICogZDJwb3dBICsgZDJwb3cyQTtcbiAgICAgICAgICAgICAgTiA9IDMgKiBkMXBvd0EgKiAoZDFwb3dBICsgZDJwb3dBKTtcbiAgICAgICAgICAgICAgaWYgKE4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICBOID0gMSAvIE47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgTSA9IDMgKiBkM3Bvd0EgKiAoZDNwb3dBICsgZDJwb3dBKTtcbiAgICAgICAgICAgICAgaWYgKE0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICBNID0gMSAvIE07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicDEgPSB7XG4gICAgICAgICAgICAgICAgICBzY3JlZW5feDogKC1kMnBvdzJBICogcDAuc2NyZWVuX3ggKyBBICogcDEuc2NyZWVuX3ggKyBkMXBvdzJBICogcDIuc2NyZWVuX3gpICogTixcbiAgICAgICAgICAgICAgICAgIHNjcmVlbl95OiAoLWQycG93MkEgKiBwMC5zY3JlZW5feSArIEEgKiBwMS5zY3JlZW5feSArIGQxcG93MkEgKiBwMi5zY3JlZW5feSkgKiBOXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgYnAyID0ge1xuICAgICAgICAgICAgICAgICAgc2NyZWVuX3g6IChkM3BvdzJBICogcDEuc2NyZWVuX3ggKyBCICogcDIuc2NyZWVuX3ggLSBkMnBvdzJBICogcDMuc2NyZWVuX3gpICogTSxcbiAgICAgICAgICAgICAgICAgIHNjcmVlbl95OiAoZDNwb3cyQSAqIHAxLnNjcmVlbl95ICsgQiAqIHAyLnNjcmVlbl95IC0gZDJwb3cyQSAqIHAzLnNjcmVlbl95KSAqIE1cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBpZiAoYnAxLnNjcmVlbl94ID09IDAgJiYgYnAxLnNjcmVlbl95ID09IDApIHtcbiAgICAgICAgICAgICAgICAgIGJwMSA9IHAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChicDIuc2NyZWVuX3ggPT0gMCAmJiBicDIuc2NyZWVuX3kgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgYnAyID0gcDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZC5wdXNoKFticDEuc2NyZWVuX3gsIGJwMS5zY3JlZW5feV0pO1xuICAgICAgICAgICAgICBkLnB1c2goW2JwMi5zY3JlZW5feCwgYnAyLnNjcmVlbl95XSk7XG4gICAgICAgICAgICAgIGQucHVzaChbcDIuc2NyZWVuX3gsIHAyLnNjcmVlbl95XSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIHRoaXMgZ2VuZXJhdGVzIHRoZSBTVkcgcGF0aCBmb3IgYSBsaW5lYXIgZHJhd2luZyBiZXR3ZWVuIGRhdGFwb2ludHMuXG4gICAqIEBwYXJhbSBkYXRhXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBMaW5lLl9saW5lYXIgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgLy8gbGluZWFyXG4gICAgICB2YXIgZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZC5wdXNoKFtkYXRhW2ldLnNjcmVlbl94LCBkYXRhW2ldLnNjcmVlbl95XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZDtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IExpbmU7XG5cbi8qKiovIH0sXG4vKiA2MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIERPTXV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuICB2YXIgQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG5cbiAgLyoqXG4gICAqIExlZ2VuZCBmb3IgR3JhcGgyZFxuICAgKi9cbiAgZnVuY3Rpb24gTGVnZW5kKGJvZHksIG9wdGlvbnMsIHNpZGUsIGxpbmVncmFwaE9wdGlvbnMpIHtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGljb25zOiB0cnVlLFxuICAgICAgaWNvblNpemU6IDIwLFxuICAgICAgaWNvblNwYWNpbmc6IDYsXG4gICAgICBsZWZ0OiB7XG4gICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgIHBvc2l0aW9uOiAndG9wLWxlZnQnIC8vIHRvcC9ib3R0b20gLSBsZWZ0LGNlbnRlcixyaWdodFxuICAgICAgfSxcbiAgICAgIHJpZ2h0OiB7XG4gICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgIHBvc2l0aW9uOiAndG9wLXJpZ2h0JyAvLyB0b3AvYm90dG9tIC0gbGVmdCxjZW50ZXIscmlnaHRcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5zaWRlID0gc2lkZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgdGhpcy5saW5lZ3JhcGhPcHRpb25zID0gbGluZWdyYXBoT3B0aW9ucztcblxuICAgIHRoaXMuc3ZnRWxlbWVudHMgPSB7fTtcbiAgICB0aGlzLmRvbSA9IHt9O1xuICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgdGhpcy5hbW91bnRPZkdyb3VwcyA9IDA7XG4gICAgdGhpcy5fY3JlYXRlKCk7XG4gICAgdGhpcy5mcmFtZXdvcmsgPSB7IHN2ZzogdGhpcy5zdmcsIHN2Z0VsZW1lbnRzOiB0aGlzLnN2Z0VsZW1lbnRzLCBvcHRpb25zOiB0aGlzLm9wdGlvbnMsIGdyb3VwczogdGhpcy5ncm91cHMgfTtcblxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIExlZ2VuZC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cbiAgTGVnZW5kLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgIHRoaXMuYW1vdW50T2ZHcm91cHMgPSAwO1xuICB9O1xuXG4gIExlZ2VuZC5wcm90b3R5cGUuYWRkR3JvdXAgPSBmdW5jdGlvbiAobGFiZWwsIGdyYXBoT3B0aW9ucykge1xuXG4gICAgLy8gSW5jbHVkZSBhIGdyb3VwIG9ubHkgaWYgdGhlIGdyb3VwIG9wdGlvbiAnZXhjbHVkZUZyb21MZWdlbmQ6IGZhbHNlJyBpcyBub3Qgc2V0LlxuICAgIGlmIChncmFwaE9wdGlvbnMub3B0aW9ucy5leGNsdWRlRnJvbUxlZ2VuZCAhPSB0cnVlKSB7XG4gICAgICBpZiAoIXRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KGxhYmVsKSkge1xuICAgICAgICB0aGlzLmdyb3Vwc1tsYWJlbF0gPSBncmFwaE9wdGlvbnM7XG4gICAgICB9XG4gICAgICB0aGlzLmFtb3VudE9mR3JvdXBzICs9IDE7XG4gICAgfVxuICB9O1xuXG4gIExlZ2VuZC5wcm90b3R5cGUudXBkYXRlR3JvdXAgPSBmdW5jdGlvbiAobGFiZWwsIGdyYXBoT3B0aW9ucykge1xuICAgIHRoaXMuZ3JvdXBzW2xhYmVsXSA9IGdyYXBoT3B0aW9ucztcbiAgfTtcblxuICBMZWdlbmQucHJvdG90eXBlLnJlbW92ZUdyb3VwID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgaWYgKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KGxhYmVsKSkge1xuICAgICAgZGVsZXRlIHRoaXMuZ3JvdXBzW2xhYmVsXTtcbiAgICAgIHRoaXMuYW1vdW50T2ZHcm91cHMgLT0gMTtcbiAgICB9XG4gIH07XG5cbiAgTGVnZW5kLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZG9tLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uZnJhbWUuY2xhc3NOYW1lID0gJ3Zpcy1sZWdlbmQnO1xuICAgIHRoaXMuZG9tLmZyYW1lLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIHRoaXMuZG9tLmZyYW1lLnN0eWxlLnRvcCA9IFwiMTBweFwiO1xuICAgIHRoaXMuZG9tLmZyYW1lLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cbiAgICB0aGlzLmRvbS50ZXh0QXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tLnRleHRBcmVhLmNsYXNzTmFtZSA9ICd2aXMtbGVnZW5kLXRleHQnO1xuICAgIHRoaXMuZG9tLnRleHRBcmVhLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgIHRoaXMuZG9tLnRleHRBcmVhLnN0eWxlLnRvcCA9IFwiMHB4XCI7XG5cbiAgICB0aGlzLnN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBcInN2Z1wiKTtcbiAgICB0aGlzLnN2Zy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgdGhpcy5zdmcuc3R5bGUudG9wID0gMCArICdweCc7XG4gICAgdGhpcy5zdmcuc3R5bGUud2lkdGggPSB0aGlzLm9wdGlvbnMuaWNvblNpemUgKyA1ICsgJ3B4JztcbiAgICB0aGlzLnN2Zy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG5cbiAgICB0aGlzLmRvbS5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLnN2Zyk7XG4gICAgdGhpcy5kb20uZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5kb20udGV4dEFyZWEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBjb21wb25lbnQgZnJvbSB0aGUgRE9NXG4gICAqL1xuICBMZWdlbmQucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcmVtb3ZlIHRoZSBmcmFtZSBjb250YWluaW5nIHRoZSBpdGVtc1xuICAgIGlmICh0aGlzLmRvbS5mcmFtZS5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmRvbS5mcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmZyYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIGNvbXBvbmVudCBpbiB0aGUgRE9NICh3aGVuIG5vdCBhbHJlYWR5IHZpc2libGUpLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBjaGFuZ2VkXG4gICAqL1xuICBMZWdlbmQucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gc2hvdyBmcmFtZSBjb250YWluaW5nIHRoZSBpdGVtc1xuICAgIGlmICghdGhpcy5kb20uZnJhbWUucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5ib2R5LmRvbS5jZW50ZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uZnJhbWUpO1xuICAgIH1cbiAgfTtcblxuICBMZWdlbmQucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBmaWVsZHMgPSBbJ2VuYWJsZWQnLCAnb3JpZW50YXRpb24nLCAnaWNvbnMnLCAnbGVmdCcsICdyaWdodCddO1xuICAgIHV0aWwuc2VsZWN0aXZlRGVlcEV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gIH07XG5cbiAgTGVnZW5kLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFjdGl2ZUdyb3VwcyA9IDA7XG4gICAgdmFyIGdyb3VwQXJyYXkgPSBPYmplY3Qua2V5cyh0aGlzLmdyb3Vwcyk7XG4gICAgZ3JvdXBBcnJheS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IDE7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBncm91cElkID0gZ3JvdXBBcnJheVtpXTtcbiAgICAgIGlmICh0aGlzLmdyb3Vwc1tncm91cElkXS52aXNpYmxlID09IHRydWUgJiYgKHRoaXMubGluZWdyYXBoT3B0aW9ucy52aXNpYmlsaXR5W2dyb3VwSWRdID09PSB1bmRlZmluZWQgfHwgdGhpcy5saW5lZ3JhcGhPcHRpb25zLnZpc2liaWxpdHlbZ3JvdXBJZF0gPT0gdHJ1ZSkpIHtcbiAgICAgICAgYWN0aXZlR3JvdXBzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9uc1t0aGlzLnNpZGVdLnZpc2libGUgPT0gZmFsc2UgfHwgdGhpcy5hbW91bnRPZkdyb3VwcyA9PSAwIHx8IHRoaXMub3B0aW9ucy5lbmFibGVkID09IGZhbHNlIHx8IGFjdGl2ZUdyb3VwcyA9PSAwKSB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zW3RoaXMuc2lkZV0ucG9zaXRpb24gPT0gJ3RvcC1sZWZ0JyB8fCB0aGlzLm9wdGlvbnNbdGhpcy5zaWRlXS5wb3NpdGlvbiA9PSAnYm90dG9tLWxlZnQnKSB7XG4gICAgICAgIHRoaXMuZG9tLmZyYW1lLnN0eWxlLmxlZnQgPSAnNHB4JztcbiAgICAgICAgdGhpcy5kb20uZnJhbWUuc3R5bGUudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgIHRoaXMuZG9tLnRleHRBcmVhLnN0eWxlLnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgICB0aGlzLmRvbS50ZXh0QXJlYS5zdHlsZS5sZWZ0ID0gdGhpcy5vcHRpb25zLmljb25TaXplICsgMTUgKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS50ZXh0QXJlYS5zdHlsZS5yaWdodCA9ICcnO1xuICAgICAgICB0aGlzLnN2Zy5zdHlsZS5sZWZ0ID0gMCArICdweCc7XG4gICAgICAgIHRoaXMuc3ZnLnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRvbS5mcmFtZS5zdHlsZS5yaWdodCA9ICc0cHgnO1xuICAgICAgICB0aGlzLmRvbS5mcmFtZS5zdHlsZS50ZXh0QWxpZ24gPSBcInJpZ2h0XCI7XG4gICAgICAgIHRoaXMuZG9tLnRleHRBcmVhLnN0eWxlLnRleHRBbGlnbiA9IFwicmlnaHRcIjtcbiAgICAgICAgdGhpcy5kb20udGV4dEFyZWEuc3R5bGUucmlnaHQgPSB0aGlzLm9wdGlvbnMuaWNvblNpemUgKyAxNSArICdweCc7XG4gICAgICAgIHRoaXMuZG9tLnRleHRBcmVhLnN0eWxlLmxlZnQgPSAnJztcbiAgICAgICAgdGhpcy5zdmcuc3R5bGUucmlnaHQgPSAwICsgJ3B4JztcbiAgICAgICAgdGhpcy5zdmcuc3R5bGUubGVmdCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zW3RoaXMuc2lkZV0ucG9zaXRpb24gPT0gJ3RvcC1sZWZ0JyB8fCB0aGlzLm9wdGlvbnNbdGhpcy5zaWRlXS5wb3NpdGlvbiA9PSAndG9wLXJpZ2h0Jykge1xuICAgICAgICB0aGlzLmRvbS5mcmFtZS5zdHlsZS50b3AgPSA0IC0gTnVtYmVyKHRoaXMuYm9keS5kb20uY2VudGVyLnN0eWxlLnRvcC5yZXBsYWNlKFwicHhcIiwgXCJcIikpICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb20uZnJhbWUuc3R5bGUuYm90dG9tID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2Nyb2xsYWJsZUhlaWdodCA9IHRoaXMuYm9keS5kb21Qcm9wcy5jZW50ZXIuaGVpZ2h0IC0gdGhpcy5ib2R5LmRvbVByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQ7XG4gICAgICAgIHRoaXMuZG9tLmZyYW1lLnN0eWxlLmJvdHRvbSA9IDQgKyBzY3JvbGxhYmxlSGVpZ2h0ICsgTnVtYmVyKHRoaXMuYm9keS5kb20uY2VudGVyLnN0eWxlLnRvcC5yZXBsYWNlKFwicHhcIiwgXCJcIikpICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb20uZnJhbWUuc3R5bGUudG9wID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWNvbnMgPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5kb20uZnJhbWUuc3R5bGUud2lkdGggPSB0aGlzLmRvbS50ZXh0QXJlYS5vZmZzZXRXaWR0aCArIDEwICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb20udGV4dEFyZWEuc3R5bGUucmlnaHQgPSAnJztcbiAgICAgICAgdGhpcy5kb20udGV4dEFyZWEuc3R5bGUubGVmdCA9ICcnO1xuICAgICAgICB0aGlzLnN2Zy5zdHlsZS53aWR0aCA9ICcwcHgnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kb20uZnJhbWUuc3R5bGUud2lkdGggPSB0aGlzLm9wdGlvbnMuaWNvblNpemUgKyAxNSArIHRoaXMuZG9tLnRleHRBcmVhLm9mZnNldFdpZHRoICsgMTAgKyAncHgnO1xuICAgICAgICB0aGlzLmRyYXdMZWdlbmRJY29ucygpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGVudCA9ICcnO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBncm91cElkID0gZ3JvdXBBcnJheVtpXTtcbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBzW2dyb3VwSWRdLnZpc2libGUgPT0gdHJ1ZSAmJiAodGhpcy5saW5lZ3JhcGhPcHRpb25zLnZpc2liaWxpdHlbZ3JvdXBJZF0gPT09IHVuZGVmaW5lZCB8fCB0aGlzLmxpbmVncmFwaE9wdGlvbnMudmlzaWJpbGl0eVtncm91cElkXSA9PSB0cnVlKSkge1xuICAgICAgICAgIGNvbnRlbnQgKz0gdGhpcy5ncm91cHNbZ3JvdXBJZF0uY29udGVudCArICc8YnIgLz4nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmRvbS50ZXh0QXJlYS5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgICAgdGhpcy5kb20udGV4dEFyZWEuc3R5bGUubGluZUhlaWdodCA9IDAuNzUgKiB0aGlzLm9wdGlvbnMuaWNvblNpemUgKyB0aGlzLm9wdGlvbnMuaWNvblNwYWNpbmcgKyAncHgnO1xuICAgIH1cbiAgfTtcblxuICBMZWdlbmQucHJvdG90eXBlLmRyYXdMZWdlbmRJY29ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kb20uZnJhbWUucGFyZW50Tm9kZSkge1xuICAgICAgdmFyIGdyb3VwQXJyYXkgPSBPYmplY3Qua2V5cyh0aGlzLmdyb3Vwcyk7XG4gICAgICBncm91cEFycmF5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiAxO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHRoaXMgcmVzZXRzIHRoZSBlbGVtZW50cyBzbyB0aGUgb3JkZXIgaXMgbWFpbnRhaW5lZFxuICAgICAgRE9NdXRpbC5yZXNldEVsZW1lbnRzKHRoaXMuc3ZnRWxlbWVudHMpO1xuXG4gICAgICB2YXIgcGFkZGluZyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZG9tLmZyYW1lKS5wYWRkaW5nVG9wO1xuICAgICAgdmFyIGljb25PZmZzZXQgPSBOdW1iZXIocGFkZGluZy5yZXBsYWNlKCdweCcsICcnKSk7XG4gICAgICB2YXIgeCA9IGljb25PZmZzZXQ7XG4gICAgICB2YXIgaWNvbldpZHRoID0gdGhpcy5vcHRpb25zLmljb25TaXplO1xuICAgICAgdmFyIGljb25IZWlnaHQgPSAwLjc1ICogdGhpcy5vcHRpb25zLmljb25TaXplO1xuICAgICAgdmFyIHkgPSBpY29uT2Zmc2V0ICsgMC41ICogaWNvbkhlaWdodCArIDM7XG5cbiAgICAgIHRoaXMuc3ZnLnN0eWxlLndpZHRoID0gaWNvbldpZHRoICsgNSArIGljb25PZmZzZXQgKyAncHgnO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGdyb3VwSWQgPSBncm91cEFycmF5W2ldO1xuICAgICAgICBpZiAodGhpcy5ncm91cHNbZ3JvdXBJZF0udmlzaWJsZSA9PSB0cnVlICYmICh0aGlzLmxpbmVncmFwaE9wdGlvbnMudmlzaWJpbGl0eVtncm91cElkXSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMubGluZWdyYXBoT3B0aW9ucy52aXNpYmlsaXR5W2dyb3VwSWRdID09IHRydWUpKSB7XG4gICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBJZF0uZ2V0TGVnZW5kKGljb25XaWR0aCwgaWNvbkhlaWdodCwgdGhpcy5mcmFtZXdvcmssIHgsIHkpO1xuICAgICAgICAgIHkgKz0gaWNvbkhlaWdodCArIHRoaXMub3B0aW9ucy5pY29uU3BhY2luZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IExlZ2VuZDtcblxuLyoqKi8gfSxcbi8qIDYxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIC8qKlxuICAgKiBUaGlzIG9iamVjdCBjb250YWlucyBhbGwgcG9zc2libGUgb3B0aW9ucy4gSXQgd2lsbCBjaGVjayBpZiB0aGUgdHlwZXMgYXJlIGNvcnJlY3QsIGlmIHJlcXVpcmVkIGlmIHRoZSBvcHRpb24gaXMgb25lXG4gICAqIG9mIHRoZSBhbGxvd2VkIHZhbHVlcy5cbiAgICpcbiAgICogX19hbnlfXyBtZWFucyB0aGF0IHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBkb2VzIG5vdCBtYXR0ZXIuXG4gICAqIF9fdHlwZV9fIGlzIGEgcmVxdWlyZWQgZmllbGQgZm9yIGFsbCBvYmplY3RzIGFuZCBjb250YWlucyB0aGUgYWxsb3dlZCB0eXBlcyBvZiBhbGwgb2JqZWN0c1xuICAgKi9cbiAgdmFyIHN0cmluZyA9ICdzdHJpbmcnO1xuICB2YXIgYm9vbGVhbiA9ICdib29sZWFuJztcbiAgdmFyIG51bWJlciA9ICdudW1iZXInO1xuICB2YXIgYXJyYXkgPSAnYXJyYXknO1xuICB2YXIgZGF0ZSA9ICdkYXRlJztcbiAgdmFyIG9iamVjdCA9ICdvYmplY3QnOyAvLyBzaG91bGQgb25seSBiZSBpbiBhIF9fdHlwZV9fIHByb3BlcnR5XG4gIHZhciBkb20gPSAnZG9tJztcbiAgdmFyIG1vbWVudCA9ICdtb21lbnQnO1xuICB2YXIgYW55ID0gJ2FueSc7XG5cbiAgdmFyIGFsbE9wdGlvbnMgPSB7XG4gICAgY29uZmlndXJlOiB7XG4gICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIGZpbHRlcjogeyBib29sZWFuOiBib29sZWFuLCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgICBjb250YWluZXI6IHsgZG9tOiBkb20gfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sZWFuLCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH1cbiAgICB9LFxuXG4gICAgLy9nbG9iYWxzIDpcbiAgICB5QXhpc09yaWVudGF0aW9uOiB7IHN0cmluZzogWydsZWZ0JywgJ3JpZ2h0J10gfSxcbiAgICBkZWZhdWx0R3JvdXA6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICBzb3J0OiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICBzYW1wbGluZzogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgc3RhY2s6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgIGdyYXBoSGVpZ2h0OiB7IHN0cmluZzogc3RyaW5nLCBudW1iZXI6IG51bWJlciB9LFxuICAgIHNoYWRlZDoge1xuICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBvcmllbnRhdGlvbjogeyBzdHJpbmc6IFsnYm90dG9tJywgJ3RvcCcsICd6ZXJvJywgJ2dyb3VwJ10gfSwgLy8gdG9wLCBib3R0b20sIHplcm8sIGdyb3VwXG4gICAgICBncm91cElkOiB7IG9iamVjdDogb2JqZWN0IH0sXG4gICAgICBfX3R5cGVfXzogeyBib29sZWFuOiBib29sZWFuLCBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcbiAgICBzdHlsZTogeyBzdHJpbmc6IFsnbGluZScsICdiYXInLCAncG9pbnRzJ10gfSwgLy8gbGluZSwgYmFyXG4gICAgYmFyQ2hhcnQ6IHtcbiAgICAgIHdpZHRoOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBtaW5XaWR0aDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgc2lkZUJ5U2lkZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBhbGlnbjogeyBzdHJpbmc6IFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXSB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgaW50ZXJwb2xhdGlvbjoge1xuICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBwYXJhbWV0cml6YXRpb246IHsgc3RyaW5nOiBbJ2NlbnRyaXBldGFsJywgJ2Nob3JkYWwnLCAndW5pZm9ybSddIH0sIC8vIHVuaWZvcm0gKGFscGhhID0gMC4wKSwgY2hvcmRhbCAoYWxwaGEgPSAxLjApLCBjZW50cmlwZXRhbCAoYWxwaGEgPSAwLjUpXG4gICAgICBhbHBoYTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2xlYW4gfVxuICAgIH0sXG4gICAgZHJhd1BvaW50czoge1xuICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBvblJlbmRlcjogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgICBzaXplOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBzdHlsZTogeyBzdHJpbmc6IFsnc3F1YXJlJywgJ2NpcmNsZSddIH0sIC8vIHNxdWFyZSwgY2lyY2xlXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbGVhbiwgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9XG4gICAgfSxcbiAgICBkYXRhQXhpczoge1xuICAgICAgc2hvd01pbm9yTGFiZWxzOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIHNob3dNYWpvckxhYmVsczogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBpY29uczogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICB3aWR0aDogeyBzdHJpbmc6IHN0cmluZywgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIHZpc2libGU6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgYWxpZ25aZXJvczogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBsZWZ0OiB7XG4gICAgICAgIHJhbmdlOiB7IG1pbjogeyBudW1iZXI6IG51bWJlciB9LCBtYXg6IHsgbnVtYmVyOiBudW1iZXIgfSwgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfSB9LFxuICAgICAgICBmb3JtYXQ6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgICB0aXRsZTogeyB0ZXh0OiB7IHN0cmluZzogc3RyaW5nLCBudW1iZXI6IG51bWJlciB9LCBzdHlsZTogeyBzdHJpbmc6IHN0cmluZyB9LCBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9IH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICAgIH0sXG4gICAgICByaWdodDoge1xuICAgICAgICByYW5nZTogeyBtaW46IHsgbnVtYmVyOiBudW1iZXIgfSwgbWF4OiB7IG51bWJlcjogbnVtYmVyIH0sIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH0gfSxcbiAgICAgICAgZm9ybWF0OiB7ICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICAgICAgdGl0bGU6IHsgdGV4dDogeyBzdHJpbmc6IHN0cmluZywgbnVtYmVyOiBudW1iZXIgfSwgc3R5bGU6IHsgc3RyaW5nOiBzdHJpbmcgfSwgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfSB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgICB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgbGVnZW5kOiB7XG4gICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIGljb25zOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIGxlZnQ6IHtcbiAgICAgICAgdmlzaWJsZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgIHBvc2l0aW9uOiB7IHN0cmluZzogWyd0b3AtcmlnaHQnLCAnYm90dG9tLXJpZ2h0JywgJ3RvcC1sZWZ0JywgJ2JvdHRvbS1sZWZ0J10gfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgICAgfSxcbiAgICAgIHJpZ2h0OiB7XG4gICAgICAgIHZpc2libGU6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgICBwb3NpdGlvbjogeyBzdHJpbmc6IFsndG9wLXJpZ2h0JywgJ2JvdHRvbS1yaWdodCcsICd0b3AtbGVmdCcsICdib3R0b20tbGVmdCddIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbGVhbiB9XG4gICAgfSxcbiAgICBncm91cHM6IHtcbiAgICAgIHZpc2liaWxpdHk6IHsgYW55OiBhbnkgfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICB9LFxuXG4gICAgYXV0b1Jlc2l6ZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgY2xpY2tUb1VzZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgZW5kOiB7IG51bWJlcjogbnVtYmVyLCBkYXRlOiBkYXRlLCBzdHJpbmc6IHN0cmluZywgbW9tZW50OiBtb21lbnQgfSxcbiAgICBmb3JtYXQ6IHtcbiAgICAgIG1pbm9yTGFiZWxzOiB7XG4gICAgICAgIG1pbGxpc2Vjb25kOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgc2Vjb25kOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgbWludXRlOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgaG91cjogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIHdlZWtkYXk6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICBkYXk6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICBtb250aDogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIHllYXI6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgICB9LFxuICAgICAgbWFqb3JMYWJlbHM6IHtcbiAgICAgICAgbWlsbGlzZWNvbmQ6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICBzZWNvbmQ6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICBtaW51dGU6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICBob3VyOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgd2Vla2RheTogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIGRheTogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIG1vbnRoOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgeWVhcjogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcbiAgICBtb21lbnQ6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgIGhlaWdodDogeyBzdHJpbmc6IHN0cmluZywgbnVtYmVyOiBudW1iZXIgfSxcbiAgICBoaWRkZW5EYXRlczoge1xuICAgICAgc3RhcnQ6IHsgZGF0ZTogZGF0ZSwgbnVtYmVyOiBudW1iZXIsIHN0cmluZzogc3RyaW5nLCBtb21lbnQ6IG1vbWVudCB9LFxuICAgICAgZW5kOiB7IGRhdGU6IGRhdGUsIG51bWJlcjogbnVtYmVyLCBzdHJpbmc6IHN0cmluZywgbW9tZW50OiBtb21lbnQgfSxcbiAgICAgIHJlcGVhdDogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGFycmF5OiBhcnJheSB9XG4gICAgfSxcbiAgICBsb2NhbGU6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICBsb2NhbGVzOiB7XG4gICAgICBfX2FueV9fOiB7IGFueTogYW55IH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcbiAgICBtYXg6IHsgZGF0ZTogZGF0ZSwgbnVtYmVyOiBudW1iZXIsIHN0cmluZzogc3RyaW5nLCBtb21lbnQ6IG1vbWVudCB9LFxuICAgIG1heEhlaWdodDogeyBudW1iZXI6IG51bWJlciwgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICBtYXhNaW5vckNoYXJzOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgbWluOiB7IGRhdGU6IGRhdGUsIG51bWJlcjogbnVtYmVyLCBzdHJpbmc6IHN0cmluZywgbW9tZW50OiBtb21lbnQgfSxcbiAgICBtaW5IZWlnaHQ6IHsgbnVtYmVyOiBudW1iZXIsIHN0cmluZzogc3RyaW5nIH0sXG4gICAgbW92ZWFibGU6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgIG11bHRpc2VsZWN0OiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICBvcmllbnRhdGlvbjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgIHNob3dDdXJyZW50VGltZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgc2hvd01ham9yTGFiZWxzOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICBzaG93TWlub3JMYWJlbHM6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgIHN0YXJ0OiB7IGRhdGU6IGRhdGUsIG51bWJlcjogbnVtYmVyLCBzdHJpbmc6IHN0cmluZywgbW9tZW50OiBtb21lbnQgfSxcbiAgICB0aW1lQXhpczoge1xuICAgICAgc2NhbGU6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgc3RlcDogeyBudW1iZXI6IG51bWJlciwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcbiAgICB3aWR0aDogeyBzdHJpbmc6IHN0cmluZywgbnVtYmVyOiBudW1iZXIgfSxcbiAgICB6b29tYWJsZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgem9vbUtleTogeyBzdHJpbmc6IFsnY3RybEtleScsICdhbHRLZXknLCAnbWV0YUtleScsICcnXSB9LFxuICAgIHpvb21NYXg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICB6b29tTWluOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgekluZGV4OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICB9O1xuXG4gIHZhciBjb25maWd1cmVPcHRpb25zID0ge1xuICAgIGdsb2JhbDoge1xuICAgICAgLy95QXhpc09yaWVudGF0aW9uOiBbJ2xlZnQnLCdyaWdodCddLCAvLyBURE9POiBlbmFibGUgYXMgc29vbiBhcyBHcmFocDJkIGRvZXNuJ3QgY3Jhc2ggd2hlbiBjaGFuZ2luZyB0aGlzIG9uIHRoZSBmbHlcbiAgICAgIHNvcnQ6IHRydWUsXG4gICAgICBzYW1wbGluZzogdHJ1ZSxcbiAgICAgIHN0YWNrOiBmYWxzZSxcbiAgICAgIHNoYWRlZDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgb3JpZW50YXRpb246IFsnemVybycsICd0b3AnLCAnYm90dG9tJywgJ2dyb3VwJ10gLy8gemVybywgdG9wLCBib3R0b21cbiAgICAgIH0sXG4gICAgICBzdHlsZTogWydsaW5lJywgJ2JhcicsICdwb2ludHMnXSwgLy8gbGluZSwgYmFyXG4gICAgICBiYXJDaGFydDoge1xuICAgICAgICB3aWR0aDogWzUwLCA1LCAxMDAsIDVdLFxuICAgICAgICBtaW5XaWR0aDogWzUwLCA1LCAxMDAsIDVdLFxuICAgICAgICBzaWRlQnlTaWRlOiBmYWxzZSxcbiAgICAgICAgYWxpZ246IFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXSAvLyBsZWZ0LCBjZW50ZXIsIHJpZ2h0XG4gICAgICB9LFxuICAgICAgaW50ZXJwb2xhdGlvbjoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBwYXJhbWV0cml6YXRpb246IFsnY2VudHJpcGV0YWwnLCAnY2hvcmRhbCcsICd1bmlmb3JtJ10gLy8gdW5pZm9ybSAoYWxwaGEgPSAwLjApLCBjaG9yZGFsIChhbHBoYSA9IDEuMCksIGNlbnRyaXBldGFsIChhbHBoYSA9IDAuNSlcbiAgICAgIH0sXG4gICAgICBkcmF3UG9pbnRzOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIHNpemU6IFs2LCAyLCAzMCwgMV0sXG4gICAgICAgIHN0eWxlOiBbJ3NxdWFyZScsICdjaXJjbGUnXSAvLyBzcXVhcmUsIGNpcmNsZVxuICAgICAgfSxcbiAgICAgIGRhdGFBeGlzOiB7XG4gICAgICAgIHNob3dNaW5vckxhYmVsczogdHJ1ZSxcbiAgICAgICAgc2hvd01ham9yTGFiZWxzOiB0cnVlLFxuICAgICAgICBpY29uczogZmFsc2UsXG4gICAgICAgIHdpZHRoOiBbNDAsIDAsIDIwMCwgMV0sXG4gICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgIGFsaWduWmVyb3M6IHRydWUsXG4gICAgICAgIGxlZnQ6IHtcbiAgICAgICAgICAvL3JhbmdlOiB7bWluOid1bmRlZmluZWQnOiAndW5kZWZpbmVkJ2luZWQsbWF4Oid1bmRlZmluZWQnOiAndW5kZWZpbmVkJ2luZWR9LFxuICAgICAgICAgIC8vZm9ybWF0OiBmdW5jdGlvbiAodmFsdWUpIHtyZXR1cm4gdmFsdWU7fSxcbiAgICAgICAgICB0aXRsZTogeyB0ZXh0OiAnJywgc3R5bGU6ICcnIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmlnaHQ6IHtcbiAgICAgICAgICAvL3JhbmdlOiB7bWluOid1bmRlZmluZWQnOiAndW5kZWZpbmVkJ2luZWQsbWF4Oid1bmRlZmluZWQnOiAndW5kZWZpbmVkJ2luZWR9LFxuICAgICAgICAgIC8vZm9ybWF0OiBmdW5jdGlvbiAodmFsdWUpIHtyZXR1cm4gdmFsdWU7fSxcbiAgICAgICAgICB0aXRsZTogeyB0ZXh0OiAnJywgc3R5bGU6ICcnIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgaWNvbnM6IHRydWUsXG4gICAgICAgIGxlZnQ6IHtcbiAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgICAgIHBvc2l0aW9uOiBbJ3RvcC1yaWdodCcsICdib3R0b20tcmlnaHQnLCAndG9wLWxlZnQnLCAnYm90dG9tLWxlZnQnXSAvLyB0b3AvYm90dG9tIC0gbGVmdCxyaWdodFxuICAgICAgICB9LFxuICAgICAgICByaWdodDoge1xuICAgICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgICAgcG9zaXRpb246IFsndG9wLXJpZ2h0JywgJ2JvdHRvbS1yaWdodCcsICd0b3AtbGVmdCcsICdib3R0b20tbGVmdCddIC8vIHRvcC9ib3R0b20gLSBsZWZ0LHJpZ2h0XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGF1dG9SZXNpemU6IHRydWUsXG4gICAgICBjbGlja1RvVXNlOiBmYWxzZSxcbiAgICAgIGVuZDogJycsXG4gICAgICBmb3JtYXQ6IHtcbiAgICAgICAgbWlub3JMYWJlbHM6IHtcbiAgICAgICAgICBtaWxsaXNlY29uZDogJ1NTUycsXG4gICAgICAgICAgc2Vjb25kOiAncycsXG4gICAgICAgICAgbWludXRlOiAnSEg6bW0nLFxuICAgICAgICAgIGhvdXI6ICdISDptbScsXG4gICAgICAgICAgd2Vla2RheTogJ2RkZCBEJyxcbiAgICAgICAgICBkYXk6ICdEJyxcbiAgICAgICAgICBtb250aDogJ01NTScsXG4gICAgICAgICAgeWVhcjogJ1lZWVknXG4gICAgICAgIH0sXG4gICAgICAgIG1ham9yTGFiZWxzOiB7XG4gICAgICAgICAgbWlsbGlzZWNvbmQ6ICdISDptbTpzcycsXG4gICAgICAgICAgc2Vjb25kOiAnRCBNTU1NIEhIOm1tJyxcbiAgICAgICAgICBtaW51dGU6ICdkZGQgRCBNTU1NJyxcbiAgICAgICAgICBob3VyOiAnZGRkIEQgTU1NTScsXG4gICAgICAgICAgd2Vla2RheTogJ01NTU0gWVlZWScsXG4gICAgICAgICAgZGF5OiAnTU1NTSBZWVlZJyxcbiAgICAgICAgICBtb250aDogJ1lZWVknLFxuICAgICAgICAgIHllYXI6ICcnXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGhlaWdodDogJycsXG4gICAgICBsb2NhbGU6ICcnLFxuICAgICAgbWF4OiAnJyxcbiAgICAgIG1heEhlaWdodDogJycsXG4gICAgICBtYXhNaW5vckNoYXJzOiBbNywgMCwgMjAsIDFdLFxuICAgICAgbWluOiAnJyxcbiAgICAgIG1pbkhlaWdodDogJycsXG4gICAgICBtb3ZlYWJsZTogdHJ1ZSxcbiAgICAgIG9yaWVudGF0aW9uOiBbJ2JvdGgnLCAnYm90dG9tJywgJ3RvcCddLFxuICAgICAgc2hvd0N1cnJlbnRUaW1lOiBmYWxzZSxcbiAgICAgIHNob3dNYWpvckxhYmVsczogdHJ1ZSxcbiAgICAgIHNob3dNaW5vckxhYmVsczogdHJ1ZSxcbiAgICAgIHN0YXJ0OiAnJyxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICB6b29tYWJsZTogdHJ1ZSxcbiAgICAgIHpvb21LZXk6IFsnY3RybEtleScsICdhbHRLZXknLCAnbWV0YUtleScsICcnXSxcbiAgICAgIHpvb21NYXg6IFszMTUzNjAwMDAwMDAwMDAsIDEwLCAzMTUzNjAwMDAwMDAwMDAsIDFdLFxuICAgICAgem9vbU1pbjogWzEwLCAxMCwgMzE1MzYwMDAwMDAwMDAwLCAxXSxcbiAgICAgIHpJbmRleDogMFxuICAgIH1cbiAgfTtcblxuICBleHBvcnRzLmFsbE9wdGlvbnMgPSBhbGxPcHRpb25zO1xuICBleHBvcnRzLmNvbmZpZ3VyZU9wdGlvbnMgPSBjb25maWd1cmVPcHRpb25zO1xuXG4vKioqLyB9LFxuLyogNjIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyB1dGlsc1xuICBleHBvcnRzLnV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuICBleHBvcnRzLkRPTXV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG4gIC8vIGRhdGFcbiAgZXhwb3J0cy5EYXRhU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbiAgZXhwb3J0cy5EYXRhVmlldyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuICBleHBvcnRzLlF1ZXVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbiAgLy8gTmV0d29ya1xuICBleHBvcnRzLk5ldHdvcmsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKTtcbiAgZXhwb3J0cy5uZXR3b3JrID0ge1xuICAgIEltYWdlczogX193ZWJwYWNrX3JlcXVpcmVfXyg2NCksXG4gICAgZG90cGFyc2VyOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMCksXG4gICAgZ2VwaGlQYXJzZXI6IF9fd2VicGFja19yZXF1aXJlX18oMTIxKSxcbiAgICBhbGxPcHRpb25zOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNilcbiAgfTtcbiAgZXhwb3J0cy5uZXR3b3JrLmNvbnZlcnREb3QgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5uZXR3b3JrLmRvdHBhcnNlci5ET1RUb0dyYXBoKGlucHV0KTtcbiAgfTtcbiAgZXhwb3J0cy5uZXR3b3JrLmNvbnZlcnRHZXBoaSA9IGZ1bmN0aW9uIChpbnB1dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBleHBvcnRzLm5ldHdvcmsuZ2VwaGlQYXJzZXIucGFyc2VHZXBoaShpbnB1dCwgb3B0aW9ucyk7XG4gIH07XG5cbiAgLy8gYnVuZGxlZCBleHRlcm5hbCBsaWJyYXJpZXNcbiAgZXhwb3J0cy5tb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuICBleHBvcnRzLkhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuICBleHBvcnRzLmtleWNoYXJtID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cbi8qKiovIH0sXG4vKiA2MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfSW1hZ2VzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NCk7XG5cbiAgdmFyIF9JbWFnZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSW1hZ2VzKTtcblxuICB2YXIgX0dyb3VwcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjUpO1xuXG4gIHZhciBfR3JvdXBzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0dyb3Vwcyk7XG5cbiAgdmFyIF9Ob2Rlc0hhbmRsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KTtcblxuICB2YXIgX05vZGVzSGFuZGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Ob2Rlc0hhbmRsZXIpO1xuXG4gIHZhciBfRWRnZXNIYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Nik7XG5cbiAgdmFyIF9FZGdlc0hhbmRsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRWRnZXNIYW5kbGVyKTtcblxuICB2YXIgX1BoeXNpY3NFbmdpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1KTtcblxuICB2YXIgX1BoeXNpY3NFbmdpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUGh5c2ljc0VuZ2luZSk7XG5cbiAgdmFyIF9DbHVzdGVyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDQpO1xuXG4gIHZhciBfQ2x1c3RlcmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DbHVzdGVyaW5nKTtcblxuICB2YXIgX0NhbnZhc1JlbmRlcmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDcpO1xuXG4gIHZhciBfQ2FudmFzUmVuZGVyZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2FudmFzUmVuZGVyZXIpO1xuXG4gIHZhciBfQ2FudmFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDgpO1xuXG4gIHZhciBfQ2FudmFzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NhbnZhcyk7XG5cbiAgdmFyIF9WaWV3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDkpO1xuXG4gIHZhciBfVmlldzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9WaWV3KTtcblxuICB2YXIgX0ludGVyYWN0aW9uSGFuZGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTEwKTtcblxuICB2YXIgX0ludGVyYWN0aW9uSGFuZGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbnRlcmFjdGlvbkhhbmRsZXIpO1xuXG4gIHZhciBfU2VsZWN0aW9uSGFuZGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTEzKTtcblxuICB2YXIgX1NlbGVjdGlvbkhhbmRsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2VsZWN0aW9uSGFuZGxlcik7XG5cbiAgdmFyIF9MYXlvdXRFbmdpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNCk7XG5cbiAgdmFyIF9MYXlvdXRFbmdpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGF5b3V0RW5naW5lKTtcblxuICB2YXIgX01hbmlwdWxhdGlvblN5c3RlbSA9IF9fd2VicGFja19yZXF1aXJlX18oMTE1KTtcblxuICB2YXIgX01hbmlwdWxhdGlvblN5c3RlbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NYW5pcHVsYXRpb25TeXN0ZW0pO1xuXG4gIHZhciBfQ29uZmlndXJhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cbiAgdmFyIF9Db25maWd1cmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29uZmlndXJhdG9yKTtcblxuICB2YXIgX1ZhbGlkYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuXG4gIHZhciBfVmFsaWRhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1ZhbGlkYXRvcik7XG5cbiAgdmFyIF9vcHRpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTYpO1xuXG4gIHZhciBfS2FtYWRhS2F3YWkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNyk7XG5cbiAgdmFyIF9LYW1hZGFLYXdhaTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9LYW1hZGFLYXdhaSk7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICAvLyBMb2FkIGN1c3RvbSBzaGFwZXMgaW50byBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcbiAgX193ZWJwYWNrX3JlcXVpcmVfXygxMTkpO1xuXG4gIHZhciBFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIERhdGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuICB2YXIgRGF0YVZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbiAgdmFyIGRvdHBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTIwKTtcbiAgdmFyIGdlcGhpUGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjEpO1xuICB2YXIgQWN0aXZhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nyk7XG4gIHZhciBsb2NhbGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjIpO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3IgTmV0d29ya1xuICAgKiBDcmVhdGUgYSBuZXR3b3JrIHZpc3VhbGl6YXRpb24sIGRpc3BsYXlpbmcgbm9kZXMgYW5kIGVkZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lciAgIFRoZSBET00gZWxlbWVudCBpbiB3aGljaCB0aGUgTmV0d29yayB3aWxsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGNyZWF0ZWQuIE5vcm1hbGx5IGEgZGl2IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheX0gbm9kZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QXJyYXl9IGVkZ2VzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICAgICAgT3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gTmV0d29yayhjb250YWluZXIsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5ldHdvcmspKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIH1cblxuICAgIC8vIHNldCBjb25zdGFudCB2YWx1ZXNcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgbG9jYWxlOiAnZW4nLFxuICAgICAgbG9jYWxlczogbG9jYWxlcyxcbiAgICAgIGNsaWNrVG9Vc2U6IGZhbHNlXG4gICAgfTtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgLy8gY29udGFpbmVycyBmb3Igbm9kZXMgYW5kIGVkZ2VzXG4gICAgdGhpcy5ib2R5ID0ge1xuICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICBub2Rlczoge30sXG4gICAgICBub2RlSW5kaWNlczogW10sXG4gICAgICBlZGdlczoge30sXG4gICAgICBlZGdlSW5kaWNlczogW10sXG4gICAgICBlbWl0dGVyOiB7XG4gICAgICAgIG9uOiB0aGlzLm9uLmJpbmQodGhpcyksXG4gICAgICAgIG9mZjogdGhpcy5vZmYuYmluZCh0aGlzKSxcbiAgICAgICAgZW1pdDogdGhpcy5lbWl0LmJpbmQodGhpcyksXG4gICAgICAgIG9uY2U6IHRoaXMub25jZS5iaW5kKHRoaXMpXG4gICAgICB9LFxuICAgICAgZXZlbnRMaXN0ZW5lcnM6IHtcbiAgICAgICAgb25UYXA6IGZ1bmN0aW9uIG9uVGFwKCkge30sXG4gICAgICAgIG9uVG91Y2g6IGZ1bmN0aW9uIG9uVG91Y2goKSB7fSxcbiAgICAgICAgb25Eb3VibGVUYXA6IGZ1bmN0aW9uIG9uRG91YmxlVGFwKCkge30sXG4gICAgICAgIG9uSG9sZDogZnVuY3Rpb24gb25Ib2xkKCkge30sXG4gICAgICAgIG9uRHJhZ1N0YXJ0OiBmdW5jdGlvbiBvbkRyYWdTdGFydCgpIHt9LFxuICAgICAgICBvbkRyYWc6IGZ1bmN0aW9uIG9uRHJhZygpIHt9LFxuICAgICAgICBvbkRyYWdFbmQ6IGZ1bmN0aW9uIG9uRHJhZ0VuZCgpIHt9LFxuICAgICAgICBvbk1vdXNlV2hlZWw6IGZ1bmN0aW9uIG9uTW91c2VXaGVlbCgpIHt9LFxuICAgICAgICBvblBpbmNoOiBmdW5jdGlvbiBvblBpbmNoKCkge30sXG4gICAgICAgIG9uTW91c2VNb3ZlOiBmdW5jdGlvbiBvbk1vdXNlTW92ZSgpIHt9LFxuICAgICAgICBvblJlbGVhc2U6IGZ1bmN0aW9uIG9uUmVsZWFzZSgpIHt9LFxuICAgICAgICBvbkNvbnRleHQ6IGZ1bmN0aW9uIG9uQ29udGV4dCgpIHt9XG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICBub2RlczogbnVsbCwgLy8gQSBEYXRhU2V0IG9yIERhdGFWaWV3XG4gICAgICAgIGVkZ2VzOiBudWxsIC8vIEEgRGF0YVNldCBvciBEYXRhVmlld1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uczoge1xuICAgICAgICBjcmVhdGVOb2RlOiBmdW5jdGlvbiBjcmVhdGVOb2RlKCkge30sXG4gICAgICAgIGNyZWF0ZUVkZ2U6IGZ1bmN0aW9uIGNyZWF0ZUVkZ2UoKSB7fSxcbiAgICAgICAgZ2V0UG9pbnRlcjogZnVuY3Rpb24gZ2V0UG9pbnRlcigpIHt9XG4gICAgICB9LFxuICAgICAgbW9kdWxlczoge30sXG4gICAgICB2aWV3OiB7XG4gICAgICAgIHNjYWxlOiAxLFxuICAgICAgICB0cmFuc2xhdGlvbjogeyB4OiAwLCB5OiAwIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gYmluZCB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgIC8vIHNldHRpbmcgdXAgYWxsIG1vZHVsZXNcbiAgICB0aGlzLmltYWdlcyA9IG5ldyBfSW1hZ2VzMi5kZWZhdWx0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgIH0pOyAvLyBvYmplY3Qgd2l0aCBpbWFnZXNcbiAgICB0aGlzLmdyb3VwcyA9IG5ldyBfR3JvdXBzMi5kZWZhdWx0KCk7IC8vIG9iamVjdCB3aXRoIGdyb3Vwc1xuICAgIHRoaXMuY2FudmFzID0gbmV3IF9DYW52YXMyLmRlZmF1bHQodGhpcy5ib2R5KTsgLy8gRE9NIGhhbmRsZXJcbiAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIgPSBuZXcgX1NlbGVjdGlvbkhhbmRsZXIyLmRlZmF1bHQodGhpcy5ib2R5LCB0aGlzLmNhbnZhcyk7IC8vIFNlbGVjdGlvbiBoYW5kbGVyXG4gICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIgPSBuZXcgX0ludGVyYWN0aW9uSGFuZGxlcjIuZGVmYXVsdCh0aGlzLmJvZHksIHRoaXMuY2FudmFzLCB0aGlzLnNlbGVjdGlvbkhhbmRsZXIpOyAvLyBJbnRlcmFjdGlvbiBoYW5kbGVyIGhhbmRsZXMgYWxsIHRoZSBoYW1tZXIgYmluZGluZ3MgKHRoYXQgYXJlIGJvdW5kIGJ5IGNhbnZhcyksIGtleVxuICAgIHRoaXMudmlldyA9IG5ldyBfVmlldzIuZGVmYXVsdCh0aGlzLmJvZHksIHRoaXMuY2FudmFzKTsgLy8gY2FtZXJhIGhhbmRsZXIsIGRvZXMgYW5pbWF0aW9ucyBhbmQgem9vbXNcbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IF9DYW52YXNSZW5kZXJlcjIuZGVmYXVsdCh0aGlzLmJvZHksIHRoaXMuY2FudmFzKTsgLy8gcmVuZGVyZXIsIHN0YXJ0cyByZW5kZXJsb29wLCBoYXMgZXZlbnRzIHRoYXQgbW9kdWxlcyBjYW4gaG9vayBpbnRvXG4gICAgdGhpcy5waHlzaWNzID0gbmV3IF9QaHlzaWNzRW5naW5lMi5kZWZhdWx0KHRoaXMuYm9keSk7IC8vIHBoeXNpY3MgZW5naW5lLCBkb2VzIGFsbCB0aGUgc2ltdWxhdGlvbnNcbiAgICB0aGlzLmxheW91dEVuZ2luZSA9IG5ldyBfTGF5b3V0RW5naW5lMi5kZWZhdWx0KHRoaXMuYm9keSk7IC8vIGxheW91dCBlbmdpbmUgZm9yIGluaXRhbCBsYXlvdXQgYW5kIGhpZXJhcmNoaWNhbCBsYXlvdXRcbiAgICB0aGlzLmNsdXN0ZXJpbmcgPSBuZXcgX0NsdXN0ZXJpbmcyLmRlZmF1bHQodGhpcy5ib2R5KTsgLy8gY2x1c3RlcmluZyBhcGlcbiAgICB0aGlzLm1hbmlwdWxhdGlvbiA9IG5ldyBfTWFuaXB1bGF0aW9uU3lzdGVtMi5kZWZhdWx0KHRoaXMuYm9keSwgdGhpcy5jYW52YXMsIHRoaXMuc2VsZWN0aW9uSGFuZGxlcik7IC8vIGRhdGEgbWFuaXB1bGF0aW9uIHN5c3RlbVxuXG4gICAgdGhpcy5ub2Rlc0hhbmRsZXIgPSBuZXcgX05vZGVzSGFuZGxlcjIuZGVmYXVsdCh0aGlzLmJvZHksIHRoaXMuaW1hZ2VzLCB0aGlzLmdyb3VwcywgdGhpcy5sYXlvdXRFbmdpbmUpOyAvLyBIYW5kbGUgYWRkaW5nLCBkZWxldGluZyBhbmQgdXBkYXRpbmcgb2Ygbm9kZXMgYXMgd2VsbCBhcyBnbG9iYWwgb3B0aW9uc1xuICAgIHRoaXMuZWRnZXNIYW5kbGVyID0gbmV3IF9FZGdlc0hhbmRsZXIyLmRlZmF1bHQodGhpcy5ib2R5LCB0aGlzLmltYWdlcywgdGhpcy5ncm91cHMpOyAvLyBIYW5kbGUgYWRkaW5nLCBkZWxldGluZyBhbmQgdXBkYXRpbmcgb2YgZWRnZXMgYXMgd2VsbCBhcyBnbG9iYWwgb3B0aW9uc1xuXG4gICAgdGhpcy5ib2R5Lm1vZHVsZXNbXCJrYW1hZGFLYXdhaVwiXSA9IG5ldyBfS2FtYWRhS2F3YWkyLmRlZmF1bHQodGhpcy5ib2R5LCAxNTAsIDAuMDUpOyAvLyBMYXlvdXRpbmcgYWxnb3JpdGhtLlxuICAgIHRoaXMuYm9keS5tb2R1bGVzW1wiY2x1c3RlcmluZ1wiXSA9IHRoaXMuY2x1c3RlcmluZztcblxuICAgIC8vIGNyZWF0ZSB0aGUgRE9NIGVsZW1lbnRzXG4gICAgdGhpcy5jYW52YXMuX2NyZWF0ZSgpO1xuXG4gICAgLy8gYXBwbHkgb3B0aW9uc1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgIC8vIGxvYWQgZGF0YSAodGhlIGRpc2FibGUgc3RhcnQgdmFyaWFibGUgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgZW5hYmxlZCBjbHVzdGVyaW5nKVxuICAgIHRoaXMuc2V0RGF0YShkYXRhKTtcbiAgfVxuXG4gIC8vIEV4dGVuZCBOZXR3b3JrIHdpdGggYW4gRW1pdHRlciBtaXhpblxuICBFbWl0dGVyKE5ldHdvcmsucHJvdG90eXBlKTtcblxuICAvKipcbiAgICogU2V0IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIE5ldHdvcmsucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGVycm9yRm91bmQgPSBfVmFsaWRhdG9yMi5kZWZhdWx0LnZhbGlkYXRlKG9wdGlvbnMsIF9vcHRpb25zLmFsbE9wdGlvbnMpO1xuICAgICAgaWYgKGVycm9yRm91bmQgPT09IHRydWUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJyVjRXJyb3JzIGhhdmUgYmVlbiBmb3VuZCBpbiB0aGUgc3VwcGxpZWQgb3B0aW9ucyBvYmplY3QuJywgX1ZhbGlkYXRvci5wcmludFN0eWxlKTtcbiAgICAgIH1cblxuICAgICAgLy8gY29weSB0aGUgZ2xvYmFsIGZpZWxkcyBvdmVyXG4gICAgICB2YXIgZmllbGRzID0gWydsb2NhbGUnLCAnbG9jYWxlcycsICdjbGlja1RvVXNlJ107XG4gICAgICB1dGlsLnNlbGVjdGl2ZURlZXBFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAvLyB0aGUgaGllcmFyY2hpY2FsIHN5c3RlbSBjYW4gYWRhcHQgdGhlIGVkZ2VzIGFuZCB0aGUgcGh5c2ljcyB0byBpdCdzIG93biBvcHRpb25zIGJlY2F1c2Ugbm90IGFsbCBjb21iaW5hdGlvbnMgd29yayB3aXRoIHRoZSBoaWVyYXJpY2hpY2FsIHN5c3RlbS5cbiAgICAgIG9wdGlvbnMgPSB0aGlzLmxheW91dEVuZ2luZS5zZXRPcHRpb25zKG9wdGlvbnMubGF5b3V0LCBvcHRpb25zKTtcblxuICAgICAgdGhpcy5jYW52YXMuc2V0T3B0aW9ucyhvcHRpb25zKTsgLy8gb3B0aW9ucyBmb3IgY2FudmFzIGFyZSBpbiBnbG9iYWxzXG5cbiAgICAgIC8vIHBhc3MgdGhlIG9wdGlvbnMgdG8gdGhlIG1vZHVsZXNcbiAgICAgIHRoaXMuZ3JvdXBzLnNldE9wdGlvbnMob3B0aW9ucy5ncm91cHMpO1xuICAgICAgdGhpcy5ub2Rlc0hhbmRsZXIuc2V0T3B0aW9ucyhvcHRpb25zLm5vZGVzKTtcbiAgICAgIHRoaXMuZWRnZXNIYW5kbGVyLnNldE9wdGlvbnMob3B0aW9ucy5lZGdlcyk7XG4gICAgICB0aGlzLnBoeXNpY3Muc2V0T3B0aW9ucyhvcHRpb25zLnBoeXNpY3MpO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb24uc2V0T3B0aW9ucyhvcHRpb25zLm1hbmlwdWxhdGlvbiwgb3B0aW9ucywgdGhpcy5vcHRpb25zKTsgLy8gbWFuaXB1bGF0aW9uIHVzZXMgdGhlIGxvY2FsZXMgaW4gdGhlIGdsb2JhbHNcblxuICAgICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIuc2V0T3B0aW9ucyhvcHRpb25zLmludGVyYWN0aW9uKTtcbiAgICAgIHRoaXMucmVuZGVyZXIuc2V0T3B0aW9ucyhvcHRpb25zLmludGVyYWN0aW9uKTsgLy8gb3B0aW9ucyBmb3IgcmVuZGVyaW5nIGFyZSBpbiBpbnRlcmFjdGlvblxuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNldE9wdGlvbnMob3B0aW9ucy5pbnRlcmFjdGlvbik7IC8vIG9wdGlvbnMgZm9yIHNlbGVjdGlvbiBhcmUgaW4gaW50ZXJhY3Rpb25cblxuICAgICAgLy8gcmVsb2FkIHRoZSBzZXR0aW5ncyBvZiB0aGUgbm9kZXMgdG8gYXBwbHkgY2hhbmdlcyBpbiBncm91cHMgdGhhdCBhcmUgbm90IHJlZmVyZW5jZWQgYnkgcG9pbnRlci5cbiAgICAgIGlmIChvcHRpb25zLmdyb3VwcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJyZWZyZXNoTm9kZXNcIik7XG4gICAgICB9XG4gICAgICAvLyB0aGVzZSB0d28gZG8gbm90IGhhdmUgb3B0aW9ucyBhdCB0aGUgbW9tZW50LCBoZXJlIGZvciBjb21wbGV0ZW5lc3NcbiAgICAgIC8vdGhpcy52aWV3LnNldE9wdGlvbnMob3B0aW9ucy52aWV3KTtcbiAgICAgIC8vdGhpcy5jbHVzdGVyaW5nLnNldE9wdGlvbnMob3B0aW9ucy5jbHVzdGVyaW5nKTtcblxuICAgICAgaWYgKCdjb25maWd1cmUnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZ3VyYXRvcikge1xuICAgICAgICAgIHRoaXMuY29uZmlndXJhdG9yID0gbmV3IF9Db25maWd1cmF0b3IyLmRlZmF1bHQodGhpcywgdGhpcy5ib2R5LmNvbnRhaW5lciwgX29wdGlvbnMuY29uZmlndXJlT3B0aW9ucywgdGhpcy5jYW52YXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRvci5zZXRPcHRpb25zKG9wdGlvbnMuY29uZmlndXJlKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlIGNvbmZpZ3VyYXRpb24gc3lzdGVtIGlzIGVuYWJsZWQsIGNvcHkgYWxsIG9wdGlvbnMgYW5kIHB1dCB0aGVtIGludG8gdGhlIGNvbmZpZyBzeXN0ZW1cbiAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRvciAmJiB0aGlzLmNvbmZpZ3VyYXRvci5vcHRpb25zLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIG5ldHdvcmtPcHRpb25zID0geyBub2Rlczoge30sIGVkZ2VzOiB7fSwgbGF5b3V0OiB7fSwgaW50ZXJhY3Rpb246IHt9LCBtYW5pcHVsYXRpb246IHt9LCBwaHlzaWNzOiB7fSwgZ2xvYmFsOiB7fSB9O1xuICAgICAgICB1dGlsLmRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMubm9kZXMsIHRoaXMubm9kZXNIYW5kbGVyLm9wdGlvbnMpO1xuICAgICAgICB1dGlsLmRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMuZWRnZXMsIHRoaXMuZWRnZXNIYW5kbGVyLm9wdGlvbnMpO1xuICAgICAgICB1dGlsLmRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMubGF5b3V0LCB0aGlzLmxheW91dEVuZ2luZS5vcHRpb25zKTtcbiAgICAgICAgLy8gbG9hZCB0aGUgc2VsZWN0aW9uSGFuZGxlciBhbmQgcmVuZGVyIGRlZmF1bHQgb3B0aW9ucyBpbiB0byB0aGUgaW50ZXJhY3Rpb24gZ3JvdXBcbiAgICAgICAgdXRpbC5kZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLmludGVyYWN0aW9uLCB0aGlzLnNlbGVjdGlvbkhhbmRsZXIub3B0aW9ucyk7XG4gICAgICAgIHV0aWwuZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5pbnRlcmFjdGlvbiwgdGhpcy5yZW5kZXJlci5vcHRpb25zKTtcblxuICAgICAgICB1dGlsLmRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMuaW50ZXJhY3Rpb24sIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyLm9wdGlvbnMpO1xuICAgICAgICB1dGlsLmRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMubWFuaXB1bGF0aW9uLCB0aGlzLm1hbmlwdWxhdGlvbi5vcHRpb25zKTtcbiAgICAgICAgdXRpbC5kZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLnBoeXNpY3MsIHRoaXMucGh5c2ljcy5vcHRpb25zKTtcblxuICAgICAgICAvLyBsb2FkIGdsb2JhbHMgaW50byB0aGUgZ2xvYmFsIG9iamVjdFxuICAgICAgICB1dGlsLmRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMuZ2xvYmFsLCB0aGlzLmNhbnZhcy5vcHRpb25zKTtcbiAgICAgICAgdXRpbC5kZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLmdsb2JhbCwgdGhpcy5vcHRpb25zKTtcblxuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRvci5zZXRNb2R1bGVPcHRpb25zKG5ldHdvcmtPcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLy8gaGFuZGxlIG5ldHdvcmsgZ2xvYmFsIG9wdGlvbnNcbiAgICAgIGlmIChvcHRpb25zLmNsaWNrVG9Vc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob3B0aW9ucy5jbGlja1RvVXNlID09PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYWN0aXZhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdG9yID0gbmV3IEFjdGl2YXRvcih0aGlzLmNhbnZhcy5mcmFtZSk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRvci5vbignY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczIuYm9keS5lbWl0dGVyLmVtaXQoXCJhY3RpdmF0ZVwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5hY3RpdmF0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0b3IuZGVzdHJveSgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYWN0aXZhdG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYWN0aXZhdGVcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJhY3RpdmF0ZVwiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYW52YXMuc2V0U2l6ZSgpO1xuICAgICAgLy8gc3RhcnQgdGhlIHBoeXNpY3Mgc2ltdWxhdGlvbi4gQ2FuIGJlIHNhZmVseSBjYWxsZWQgbXVsdGlwbGUgdGltZXMuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB0aGlzLmJvZHkubm9kZUluZGljZXMgd2l0aCB0aGUgbW9zdCByZWNlbnQgbm9kZSBpbmRleCBsaXN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBOZXR3b3JrLnByb3RvdHlwZS5fdXBkYXRlVmlzaWJsZUluZGljZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICB0aGlzLmJvZHkubm9kZUluZGljZXMgPSBbXTtcbiAgICB0aGlzLmJvZHkuZWRnZUluZGljZXMgPSBbXTtcblxuICAgIGZvciAodmFyIG5vZGVJZCBpbiBub2Rlcykge1xuICAgICAgaWYgKG5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgaWYgKG5vZGVzW25vZGVJZF0ub3B0aW9ucy5oaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLnB1c2gobm9kZXNbbm9kZUlkXS5pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBlZGdlSWQgaW4gZWRnZXMpIHtcbiAgICAgIGlmIChlZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgIGlmIChlZGdlc1tlZGdlSWRdLm9wdGlvbnMuaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lZGdlSW5kaWNlcy5wdXNoKGVkZ2VzW2VkZ2VJZF0uaWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBCaW5kIGFsbCBldmVudHNcbiAgICovXG4gIE5ldHdvcmsucHJvdG90eXBlLmJpbmRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIC8vIHRoaXMgZXZlbnQgd2lsbCB0cmlnZ2VyIGEgcmVidWlsZGluZyBvZiB0aGUgY2FjaGUgZXZlcnl0aGluZy4gVXNlZCB3aGVuIG5vZGVzIG9yIGVkZ2VzIGhhdmUgYmVlbiBhZGRlZCBvciByZW1vdmVkLlxuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFDaGFuZ2VkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHVwZGF0ZSBzaG9ydGN1dCBsaXN0c1xuICAgICAgX3RoaXMzLl91cGRhdGVWaXNpYmxlSW5kaWNlcygpO1xuICAgICAgX3RoaXMzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICAvLyBjYWxsIHRoZSBkYXRhVXBkYXRlZCBldmVudCBiZWNhdXNlIHRoZSBvbmx5IGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgdHdvIGlzIHRoZSB1cGRhdGluZyBvZiB0aGUgaW5kaWNlc1xuICAgICAgX3RoaXMzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFVcGRhdGVkXCIpO1xuICAgIH0pO1xuXG4gICAgLy8gdGhpcyBpcyBjYWxsZWQgd2hlbiBvcHRpb25zIG9mIEVYSVNUSU5HIG5vZGVzIG9yIGVkZ2VzIGhhdmUgY2hhbmdlZC5cbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhVXBkYXRlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyB1cGRhdGUgdmFsdWVzXG4gICAgICBfdGhpczMuX3VwZGF0ZVZhbHVlUmFuZ2UoX3RoaXMzLmJvZHkubm9kZXMpO1xuICAgICAgX3RoaXMzLl91cGRhdGVWYWx1ZVJhbmdlKF90aGlzMy5ib2R5LmVkZ2VzKTtcbiAgICAgIC8vIHN0YXJ0IHNpbXVsYXRpb24gKGNhbiBiZSBjYWxsZWQgc2FmZWx5LCBldmVuIGlmIGFscmVhZHkgcnVubmluZylcbiAgICAgIF90aGlzMy5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKTtcbiAgICAgIF90aGlzMy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgbm9kZXMgYW5kIGVkZ2VzLCBhbmQgb3B0aW9uYWxseSBvcHRpb25zIGFzIHdlbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0FycmF5IHwgRGF0YVNldCB8IERhdGFWaWV3fSBbbm9kZXNdIEFycmF5IHdpdGggbm9kZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheSB8IERhdGFTZXQgfCBEYXRhVmlld30gW2VkZ2VzXSBBcnJheSB3aXRoIGVkZ2VzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBbZG90XSBTdHJpbmcgY29udGFpbmluZyBkYXRhIGluIERPVCBmb3JtYXRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IFtnZXBoaV0gU3RyaW5nIGNvbnRhaW5pbmcgZGF0YSBpbiBnZXBoaSBKU09OIGZvcm1hdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09wdGlvbnN9IFtvcHRpb25zXSBPYmplY3Qgd2l0aCBvcHRpb25zXG4gICAqL1xuICBOZXR3b3JrLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAvLyByZXNldCB0aGUgcGh5c2ljcyBlbmdpbmUuXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInJlc2V0UGh5c2ljc1wiKTtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3Jlc2V0RGF0YVwiKTtcblxuICAgIC8vIHVuc2VsZWN0IGFsbCB0byBlbnN1cmUgbm8gc2VsZWN0aW9ucyBmcm9tIG9sZCBkYXRhIGFyZSBjYXJyaWVkIG92ZXIuXG4gICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7XG5cbiAgICBpZiAoZGF0YSAmJiBkYXRhLmRvdCAmJiAoZGF0YS5ub2RlcyB8fCBkYXRhLmVkZ2VzKSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdEYXRhIG11c3QgY29udGFpbiBlaXRoZXIgcGFyYW1ldGVyIFwiZG90XCIgb3IgJyArICcgcGFyYW1ldGVyIHBhaXIgXCJub2Rlc1wiIGFuZCBcImVkZ2VzXCIsIGJ1dCBub3QgYm90aC4nKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgb3B0aW9uc1xuICAgIHRoaXMuc2V0T3B0aW9ucyhkYXRhICYmIGRhdGEub3B0aW9ucyk7XG4gICAgLy8gc2V0IGFsbCBkYXRhXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5kb3QpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdUaGUgZG90IHByb3BlcnR5IGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdGhlIHN0YXRpYyBjb252ZXJ0RG90IG1ldGhvZCB0byBjb252ZXJ0IERPVCBpbnRvIHZpcy5uZXR3b3JrIGZvcm1hdCBhbmQgdXNlIHRoZSBub3JtYWwgZGF0YSBmb3JtYXQgd2l0aCBub2RlcyBhbmQgZWRnZXMuIFRoaXMgY29udmVydGVyIGlzIHVzZWQgbGlrZSB0aGlzOiB2YXIgZGF0YSA9IHZpcy5uZXR3b3JrLmNvbnZlcnREb3QoZG90U3RyaW5nKTsnKTtcbiAgICAgIC8vIHBhcnNlIERPVCBmaWxlXG4gICAgICB2YXIgZG90RGF0YSA9IGRvdHBhcnNlci5ET1RUb0dyYXBoKGRhdGEuZG90KTtcbiAgICAgIHRoaXMuc2V0RGF0YShkb3REYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGRhdGEgJiYgZGF0YS5nZXBoaSkge1xuICAgICAgLy8gcGFyc2UgRE9UIGZpbGVcbiAgICAgIGNvbnNvbGUubG9nKCdUaGUgZ2VwaGkgcHJvcGVydHkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0aGUgc3RhdGljIGNvbnZlcnRHZXBoaSBtZXRob2QgdG8gY29udmVydCBnZXBoaSBpbnRvIHZpcy5uZXR3b3JrIGZvcm1hdCBhbmQgdXNlIHRoZSBub3JtYWwgZGF0YSBmb3JtYXQgd2l0aCBub2RlcyBhbmQgZWRnZXMuIFRoaXMgY29udmVydGVyIGlzIHVzZWQgbGlrZSB0aGlzOiB2YXIgZGF0YSA9IHZpcy5uZXR3b3JrLmNvbnZlcnRHZXBoaShnZXBoaUpzb24pOycpO1xuICAgICAgdmFyIGdlcGhpRGF0YSA9IGdlcGhpUGFyc2VyLnBhcnNlR2VwaGkoZGF0YS5nZXBoaSk7XG4gICAgICB0aGlzLnNldERhdGEoZ2VwaGlEYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub2Rlc0hhbmRsZXIuc2V0RGF0YShkYXRhICYmIGRhdGEubm9kZXMsIHRydWUpO1xuICAgICAgdGhpcy5lZGdlc0hhbmRsZXIuc2V0RGF0YShkYXRhICYmIGRhdGEuZWRnZXMsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIGVtaXQgY2hhbmdlIGluIGRhdGFcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuXG4gICAgLy8gZW1pdCBkYXRhIGxvYWRlZFxuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUxvYWRlZFwiKTtcblxuICAgIC8vIGZpbmQgYSBzdGFibGUgcG9zaXRpb24gb3Igc3RhcnQgYW5pbWF0aW5nIHRvIGEgc3RhYmxlIHBvc2l0aW9uXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImluaXRQaHlzaWNzXCIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhbnMgdXAgYWxsIGJpbmRpbmdzIG9mIHRoZSBuZXR3b3JrLCByZW1vdmluZyBpdCBmdWxseSBmcm9tIHRoZSBtZW1vcnkgSUYgdGhlIHZhcmlhYmxlIGlzIHNldCB0byBudWxsIGFmdGVyIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICogdmFyIG5ldHdvcmsgPSBuZXcgdmlzLk5ldHdvcmsoLi4pO1xuICAgKiBuZXR3b3JrLmRlc3Ryb3koKTtcbiAgICogbmV0d29yayA9IG51bGw7XG4gICAqL1xuICBOZXR3b3JrLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJkZXN0cm95XCIpO1xuICAgIC8vIGNsZWFyIGV2ZW50c1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZigpO1xuICAgIHRoaXMub2ZmKCk7XG5cbiAgICAvLyBkZWxldGUgbW9kdWxlc1xuICAgIGRlbGV0ZSB0aGlzLmdyb3VwcztcbiAgICBkZWxldGUgdGhpcy5jYW52YXM7XG4gICAgZGVsZXRlIHRoaXMuc2VsZWN0aW9uSGFuZGxlcjtcbiAgICBkZWxldGUgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXI7XG4gICAgZGVsZXRlIHRoaXMudmlldztcbiAgICBkZWxldGUgdGhpcy5yZW5kZXJlcjtcbiAgICBkZWxldGUgdGhpcy5waHlzaWNzO1xuICAgIGRlbGV0ZSB0aGlzLmxheW91dEVuZ2luZTtcbiAgICBkZWxldGUgdGhpcy5jbHVzdGVyaW5nO1xuICAgIGRlbGV0ZSB0aGlzLm1hbmlwdWxhdGlvbjtcbiAgICBkZWxldGUgdGhpcy5ub2Rlc0hhbmRsZXI7XG4gICAgZGVsZXRlIHRoaXMuZWRnZXNIYW5kbGVyO1xuICAgIGRlbGV0ZSB0aGlzLmNvbmZpZ3VyYXRvcjtcbiAgICBkZWxldGUgdGhpcy5pbWFnZXM7XG5cbiAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgICBkZWxldGUgdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgfVxuICAgIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLmJvZHkuZWRnZXMpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgdGhlIGNvbnRhaW5lciBhbmQgZXZlcnl0aGluZyBpbnNpZGUgaXQgcmVjdXJzaXZlbHlcbiAgICB1dGlsLnJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLmJvZHkuY29udGFpbmVyKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB2YWx1ZXMgb2YgYWxsIG9iamVjdCBpbiB0aGUgZ2l2ZW4gYXJyYXkgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50XG4gICAqIHZhbHVlIHJhbmdlIG9mIHRoZSBvYmplY3RzIGluIHRoZSBhcnJheS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAgICBBbiBvYmplY3QgY29udGFpbmluZyBhIHNldCBvZiBFZGdlcyBvciBOb2Rlc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvYmplY3RzIG11c3QgaGF2ZSBhIG1ldGhvZCBnZXRWYWx1ZSgpIGFuZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlUmFuZ2UobWluLCBtYXgpLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTmV0d29yay5wcm90b3R5cGUuX3VwZGF0ZVZhbHVlUmFuZ2UgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGlkO1xuXG4gICAgLy8gZGV0ZXJtaW5lIHRoZSByYW5nZSBvZiB0aGUgb2JqZWN0c1xuICAgIHZhciB2YWx1ZU1pbiA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsdWVNYXggPSB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbHVlVG90YWwgPSAwO1xuICAgIGZvciAoaWQgaW4gb2JqKSB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmpbaWRdLmdldFZhbHVlKCk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFsdWVNaW4gPSB2YWx1ZU1pbiA9PT0gdW5kZWZpbmVkID8gdmFsdWUgOiBNYXRoLm1pbih2YWx1ZSwgdmFsdWVNaW4pO1xuICAgICAgICAgIHZhbHVlTWF4ID0gdmFsdWVNYXggPT09IHVuZGVmaW5lZCA/IHZhbHVlIDogTWF0aC5tYXgodmFsdWUsIHZhbHVlTWF4KTtcbiAgICAgICAgICB2YWx1ZVRvdGFsICs9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IHRoZSByYW5nZSBvZiBhbGwgb2JqZWN0c1xuICAgIGlmICh2YWx1ZU1pbiAhPT0gdW5kZWZpbmVkICYmIHZhbHVlTWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAoaWQgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgb2JqW2lkXS5zZXRWYWx1ZVJhbmdlKHZhbHVlTWluLCB2YWx1ZU1heCwgdmFsdWVUb3RhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBOZXR3b3JrIGlzIGFjdGl2ZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBOZXR3b3JrLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIXRoaXMuYWN0aXZhdG9yIHx8IHRoaXMuYWN0aXZhdG9yLmFjdGl2ZTtcbiAgfTtcblxuICBOZXR3b3JrLnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy5zZXRTaXplLmFwcGx5KHRoaXMuY2FudmFzLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5jYW52YXNUb0RPTSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXMuY2FudmFzVG9ET00uYXBwbHkodGhpcy5jYW52YXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLkRPTXRvQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy5ET010b0NhbnZhcy5hcHBseSh0aGlzLmNhbnZhcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuZmluZE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5maW5kTm9kZS5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmlzQ2x1c3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmlzQ2x1c3Rlci5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLm9wZW5DbHVzdGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcub3BlbkNsdXN0ZXIuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5jbHVzdGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuY2x1c3Rlci5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmdldE5vZGVzSW5DbHVzdGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuZ2V0Tm9kZXNJbkNsdXN0ZXIuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5jbHVzdGVyQnlDb25uZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuY2x1c3RlckJ5Q29ubmVjdGlvbi5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmNsdXN0ZXJCeUh1YnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5jbHVzdGVyQnlIdWJzaXplLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuY2x1c3Rlck91dGxpZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuY2x1c3Rlck91dGxpZXJzLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuZ2V0U2VlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXlvdXRFbmdpbmUuZ2V0U2VlZC5hcHBseSh0aGlzLmxheW91dEVuZ2luZSwgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuZW5hYmxlRWRpdE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmVuYWJsZUVkaXRNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5kaXNhYmxlRWRpdE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmRpc2FibGVFZGl0TW9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuYWRkTm9kZU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmFkZE5vZGVNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5lZGl0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uZWRpdE5vZGUuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmVkaXROb2RlTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zb2xlLmxvZyhcIkRlcHJlY2F0ZWQ6IFBsZWFzZSB1c2UgZWRpdE5vZGUgaW5zdGVhZCBvZiBlZGl0Tm9kZU1vZGUuXCIpO3JldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5lZGl0Tm9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuYWRkRWRnZU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmFkZEVkZ2VNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5lZGl0RWRnZU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmVkaXRFZGdlTW9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuZGVsZXRlU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmRlbGV0ZVNlbGVjdGVkLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5nZXRQb3NpdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLmdldFBvc2l0aW9ucy5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuc3RvcmVQb3NpdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLnN0b3JlUG9zaXRpb25zLmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5tb3ZlTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIubW92ZU5vZGUuYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzSGFuZGxlci5nZXRCb3VuZGluZ0JveC5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuZ2V0Q29ubmVjdGVkTm9kZXMgPSBmdW5jdGlvbiAob2JqZWN0SWQpIHtcbiAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW29iamVjdElkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIuZ2V0Q29ubmVjdGVkTm9kZXMuYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmVkZ2VzSGFuZGxlci5nZXRDb25uZWN0ZWROb2Rlcy5hcHBseSh0aGlzLmVkZ2VzSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmdldENvbm5lY3RlZEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzSGFuZGxlci5nZXRDb25uZWN0ZWRFZGdlcy5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuc3RhcnRTaW11bGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBoeXNpY3Muc3RhcnRTaW11bGF0aW9uLmFwcGx5KHRoaXMucGh5c2ljcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuc3RvcFNpbXVsYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucGh5c2ljcy5zdG9wU2ltdWxhdGlvbi5hcHBseSh0aGlzLnBoeXNpY3MsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLnN0YWJpbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5waHlzaWNzLnN0YWJpbGl6ZS5hcHBseSh0aGlzLnBoeXNpY3MsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGlvbi5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNldFNlbGVjdGlvbi5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmdldFNlbGVjdGVkTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZE5vZGVzLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuZ2V0U2VsZWN0ZWRFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkRWRnZXMuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5nZXROb2RlQXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0Tm9kZUF0LmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmIG5vZGUuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5vZGUuaWQ7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5nZXRFZGdlQXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVkZ2UgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0RWRnZUF0LmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgICBpZiAoZWRnZSAhPT0gdW5kZWZpbmVkICYmIGVkZ2UuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGVkZ2UuaWQ7XG4gICAgfVxuICAgIHJldHVybiBlZGdlO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5zZWxlY3ROb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdE5vZGVzLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuc2VsZWN0RWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RFZGdlcy5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLnVuc2VsZWN0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbC5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5yZWRyYXcoKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnJlZHJhdy5hcHBseSh0aGlzLnJlbmRlcmVyLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5nZXRTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LmdldFNjYWxlLmFwcGx5KHRoaXMudmlldywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuZ2V0Vmlld1Bvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0Vmlld1Bvc2l0aW9uLmFwcGx5KHRoaXMudmlldywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuZml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcuZml0LmFwcGx5KHRoaXMudmlldywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcubW92ZVRvLmFwcGx5KHRoaXMudmlldywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5mb2N1cy5hcHBseSh0aGlzLnZpZXcsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLnJlbGVhc2VOb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcucmVsZWFzZU5vZGUuYXBwbHkodGhpcy52aWV3LCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5nZXRPcHRpb25zRnJvbUNvbmZpZ3VyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRvcikge1xuICAgICAgb3B0aW9ucyA9IHRoaXMuY29uZmlndXJhdG9yLmdldE9wdGlvbnMuYXBwbHkodGhpcy5jb25maWd1cmF0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IE5ldHdvcms7XG5cbi8qKiovIH0sXG4vKiA2NCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBJbWFnZXNcbiAgICogVGhpcyBjbGFzcyBsb2FkcyBpbWFnZXMgYW5kIGtlZXBzIHRoZW0gc3RvcmVkLlxuICAgKi9cbiAgdmFyIEltYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEltYWdlcyhjYWxsYmFjaykge1xuICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbWFnZXMpO1xuXG4gICAgICAgICAgdGhpcy5pbWFnZXMgPSB7fTtcbiAgICAgICAgICB0aGlzLmltYWdlQnJva2VuID0ge307XG4gICAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgICAgICAgICAgICAgICAgICAgICAgVGhlIFVybCB0byBjYWNoZSB0aGUgaW1hZ2UgYXMgXG4gICAgICAgICogQHJldHVybiB7SW1hZ2V9IGltYWdlVG9Mb2FkQnJva2VuVXJsT24gIFRoZSBpbWFnZSBvYmplY3RcbiAgICAgICAqL1xuXG5cbiAgICAgIF9jcmVhdGVDbGFzcyhJbWFnZXMsIFt7XG4gICAgICAgICAga2V5OiBcIl9hZGRJbWFnZVRvQ2FjaGVcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEltYWdlVG9DYWNoZSh1cmwsIGltYWdlVG9DYWNoZSkge1xuICAgICAgICAgICAgICAvLyBJRTExIGZpeCAtLSB0aGFua3MgZHBvbmNoIVxuICAgICAgICAgICAgICBpZiAoaW1hZ2VUb0NhY2hlLndpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGltYWdlVG9DYWNoZSk7XG4gICAgICAgICAgICAgICAgICBpbWFnZVRvQ2FjaGUud2lkdGggPSBpbWFnZVRvQ2FjaGUub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgICBpbWFnZVRvQ2FjaGUuaGVpZ2h0ID0gaW1hZ2VUb0NhY2hlLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaW1hZ2VUb0NhY2hlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuaW1hZ2VzW3VybF0gPSBpbWFnZVRvQ2FjaGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAgICAgICAgICAgICAgICAgICAgICBUaGUgb3JpZ2luYWwgVXJsIHRoYXQgZmFpbGVkIHRvIGxvYWQsIGlmIHRoZSBicm9rZW4gaW1hZ2UgaXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZCBpdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBjYWNoZSB1c2luZyB0aGlzIFVybCBhcyB0aGUga2V5IHNvIHRoYXQgc3Vic2VxdWVudCByZXF1ZXN0cyBmb3IgdGhpcyBVcmwgd2lsbCByZXR1cm4gdGhlIGJyb2tlbiBpbWFnZVxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBicm9rZW5VcmwgICAgICAgICAgICAgICAgVXJsIHRoZSBicm9rZW4gaW1hZ2UgdG8gdHJ5IGFuZCBsb2FkXG4gICAgICAgICAgICogQHJldHVybiB7SW1hZ2V9IGltYWdlVG9Mb2FkQnJva2VuVXJsT24gICBUaGUgaW1hZ2Ugb2JqZWN0XG4gICAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiX3RyeWxvYWRCcm9rZW5VcmxcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3RyeWxvYWRCcm9rZW5VcmwodXJsLCBicm9rZW5VcmwsIGltYWdlVG9Mb2FkQnJva2VuVXJsT24pIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgICAgICAvL0lmIGFueSBvZiB0aGUgcGFyYW1ldGVycyBhcmVuJ3Qgc3BlY2lmaWVkIHRoZW4gZXhpdCB0aGUgZnVuY3Rpb24gYmVjYXVzZSBub3RoaW5nIGNvbnN0cnVjdGl2ZSBjYW4gYmUgZG9uZVxuICAgICAgICAgICAgICBpZiAodXJsID09PSB1bmRlZmluZWQgfHwgYnJva2VuVXJsID09PSB1bmRlZmluZWQgfHwgaW1hZ2VUb0xvYWRCcm9rZW5VcmxPbiA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgLy9DbGVhciB0aGUgb2xkIHN1YnNjcmlwdGlvbiB0byB0aGUgZXJyb3IgZXZlbnQgYW5kIHB1dCBhIG5ldyBpbiBwbGFjZSB0aGF0IG9ubHkgaGFuZGxlIGVycm9ycyBpbiBsb2FkaW5nIHRoZSBicm9rZW5JbWFnZVVybFxuICAgICAgICAgICAgICBpbWFnZVRvTG9hZEJyb2tlblVybE9uLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ291bGQgbm90IGxvYWQgYnJva2VuSW1hZ2U6XCIsIGJyb2tlblVybCk7XG4gICAgICAgICAgICAgICAgICAvL0FkZCBhbiBlbXB0eSBpbWFnZSB0byB0aGUgY2FjaGUgc28gdGhhdCB3aGVuIHN1YnNlcXVlbnQgbG9hZCBjYWxscyBhcmUgbWFkZSBmb3IgdGhlIHVybCB3ZSBkb24ndCB0cnkgbG9hZCB0aGUgaW1hZ2UgYW5kIGJyb2tlbiBpbWFnZSBhZ2FpblxuICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZEltYWdlVG9DYWNoZSh1cmwsIG5ldyBJbWFnZSgpKTtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAvL1NldCB0aGUgc291cmNlIG9mIHRoZSBpbWFnZSB0byB0aGUgYnJva2VuVXJsLCB0aGlzIGlzIGFjdHVhbGx5IHdoYXQga2lja3Mgb2ZmIHRoZSBsb2FkaW5nIG9mIHRoZSBicm9rZW4gaW1hZ2VcbiAgICAgICAgICAgICAgaW1hZ2VUb0xvYWRCcm9rZW5VcmxPbi5zcmMgPSBicm9rZW5Vcmw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQHJldHVybiB7SW1hZ2V9IGltYWdlVG9SZWRyYXdXaXRoIFRoZSBpbWFnZXMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgd2hlbiBpdCBpcyBpbnZva2VkXG4gICAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiX3JlZHJhd1dpdGhJbWFnZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVkcmF3V2l0aEltYWdlKGltYWdlVG9SZWRyYXdXaXRoKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKGltYWdlVG9SZWRyYXdXaXRoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgICAgICAgICAgVXJsIG9mIHRoZSBpbWFnZVxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBicm9rZW5VcmwgICAgVXJsIG9mIGFuIGltYWdlIHRvIHVzZSBpZiB0aGUgdXJsIGltYWdlIGlzIG5vdCBmb3VuZFxuICAgICAgICAgICAqIEByZXR1cm4ge0ltYWdlfSBpbWcgICAgICAgICAgVGhlIGltYWdlIG9iamVjdFxuICAgICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImxvYWRcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZCh1cmwsIGJyb2tlblVybCwgaWQpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgLy9UcnkgYW5kIGdldCB0aGUgaW1hZ2UgZnJvbSB0aGUgY2FjaGUsIGlmIHN1Y2Nlc3NmdWwgdGhlbiByZXR1cm4gdGhlIGNhY2hlZCBpbWFnZSAgIFxuICAgICAgICAgICAgICB2YXIgY2FjaGVkSW1hZ2UgPSB0aGlzLmltYWdlc1t1cmxdO1xuICAgICAgICAgICAgICBpZiAoY2FjaGVkSW1hZ2UpIHJldHVybiBjYWNoZWRJbWFnZTtcblxuICAgICAgICAgICAgICAvL0NyZWF0ZSBhIG5ldyBpbWFnZVxuICAgICAgICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG5cbiAgICAgICAgICAgICAgLy9TdWJzY3JpYmUgdG8gdGhlIGV2ZW50IHRoYXQgaXMgcmFpc2VkIGlmIHRoZSBpbWFnZSBsb2FkcyBzdWNjZXNzZnVsbHkgXG4gICAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAvL0FkZCB0aGUgaW1hZ2UgdG8gdGhlIGNhY2hlIGFuZCB0aGVuIHJlcXVlc3QgYSByZWRyYXdcbiAgICAgICAgICAgICAgICAgIF90aGlzMi5fYWRkSW1hZ2VUb0NhY2hlKHVybCwgaW1nKTtcbiAgICAgICAgICAgICAgICAgIF90aGlzMi5fcmVkcmF3V2l0aEltYWdlKGltZyk7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgLy9TdWJzY3JpYmUgdG8gdGhlIGV2ZW50IHRoYXQgaXMgcmFpc2VkIGlmIHRoZSBpbWFnZSBmYWlscyB0byBsb2FkXG4gICAgICAgICAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBsb2FkIGltYWdlOlwiLCB1cmwpO1xuICAgICAgICAgICAgICAgICAgLy9UcnkgYW5kIGxvYWQgdGhlIGltYWdlIHNwZWNpZmllZCBieSB0aGUgYnJva2VuVXJsIHVzaW5nXG4gICAgICAgICAgICAgICAgICBfdGhpczIuX3RyeWxvYWRCcm9rZW5VcmwodXJsLCBicm9rZW5VcmwsIGltZyk7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgLy9TZXQgdGhlIHNvdXJjZSBvZiB0aGUgaW1hZ2UgdG8gdGhlIHVybCwgdGhpcyBpcyBhY3R1YWxsIHdoYXQga2lja3Mgb2ZmIHRoZSBsb2FkaW5nIG9mIHRoZSBpbWFnZVxuICAgICAgICAgICAgICBpbWcuc3JjID0gdXJsO1xuXG4gICAgICAgICAgICAgIC8vUmV0dXJuIHRoZSBuZXcgaW1hZ2VcbiAgICAgICAgICAgICAgcmV0dXJuIGltZztcbiAgICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBJbWFnZXM7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBJbWFnZXM7XG5cbi8qKiovIH0sXG4vKiA2NSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICAvKipcbiAgICogQGNsYXNzIEdyb3Vwc1xuICAgKiBUaGlzIGNsYXNzIGNhbiBzdG9yZSBncm91cHMgYW5kIG9wdGlvbnMgc3BlY2lmaWMgZm9yIGdyb3Vwcy5cbiAgICovXG5cbiAgdmFyIEdyb3VwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcm91cHMoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR3JvdXBzKTtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgdGhpcy5kZWZhdWx0SW5kZXggPSAwO1xuICAgICAgdGhpcy5ncm91cHNBcnJheSA9IFtdO1xuICAgICAgdGhpcy5ncm91cEluZGV4ID0gMDtcblxuICAgICAgdGhpcy5kZWZhdWx0R3JvdXBzID0gW3sgYm9yZGVyOiBcIiMyQjdDRTlcIiwgYmFja2dyb3VuZDogXCIjOTdDMkZDXCIsIGhpZ2hsaWdodDogeyBib3JkZXI6IFwiIzJCN0NFOVwiLCBiYWNrZ3JvdW5kOiBcIiNEMkU1RkZcIiB9LCBob3ZlcjogeyBib3JkZXI6IFwiIzJCN0NFOVwiLCBiYWNrZ3JvdW5kOiBcIiNEMkU1RkZcIiB9IH0sIC8vIDA6IGJsdWVcbiAgICAgIHsgYm9yZGVyOiBcIiNGRkE1MDBcIiwgYmFja2dyb3VuZDogXCIjRkZGRjAwXCIsIGhpZ2hsaWdodDogeyBib3JkZXI6IFwiI0ZGQTUwMFwiLCBiYWNrZ3JvdW5kOiBcIiNGRkZGQTNcIiB9LCBob3ZlcjogeyBib3JkZXI6IFwiI0ZGQTUwMFwiLCBiYWNrZ3JvdW5kOiBcIiNGRkZGQTNcIiB9IH0sIC8vIDE6IHllbGxvd1xuICAgICAgeyBib3JkZXI6IFwiI0ZBMEExMFwiLCBiYWNrZ3JvdW5kOiBcIiNGQjdFODFcIiwgaGlnaGxpZ2h0OiB7IGJvcmRlcjogXCIjRkEwQTEwXCIsIGJhY2tncm91bmQ6IFwiI0ZGQUZCMVwiIH0sIGhvdmVyOiB7IGJvcmRlcjogXCIjRkEwQTEwXCIsIGJhY2tncm91bmQ6IFwiI0ZGQUZCMVwiIH0gfSwgLy8gMjogcmVkXG4gICAgICB7IGJvcmRlcjogXCIjNDFBOTA2XCIsIGJhY2tncm91bmQ6IFwiIzdCRTE0MVwiLCBoaWdobGlnaHQ6IHsgYm9yZGVyOiBcIiM0MUE5MDZcIiwgYmFja2dyb3VuZDogXCIjQTFFQzc2XCIgfSwgaG92ZXI6IHsgYm9yZGVyOiBcIiM0MUE5MDZcIiwgYmFja2dyb3VuZDogXCIjQTFFQzc2XCIgfSB9LCAvLyAzOiBncmVlblxuICAgICAgeyBib3JkZXI6IFwiI0UxMjlGMFwiLCBiYWNrZ3JvdW5kOiBcIiNFQjdERjRcIiwgaGlnaGxpZ2h0OiB7IGJvcmRlcjogXCIjRTEyOUYwXCIsIGJhY2tncm91bmQ6IFwiI0YwQjNGNVwiIH0sIGhvdmVyOiB7IGJvcmRlcjogXCIjRTEyOUYwXCIsIGJhY2tncm91bmQ6IFwiI0YwQjNGNVwiIH0gfSwgLy8gNDogbWFnZW50YVxuICAgICAgeyBib3JkZXI6IFwiIzdDMjlGMFwiLCBiYWNrZ3JvdW5kOiBcIiNBRDg1RTRcIiwgaGlnaGxpZ2h0OiB7IGJvcmRlcjogXCIjN0MyOUYwXCIsIGJhY2tncm91bmQ6IFwiI0QzQkRGMFwiIH0sIGhvdmVyOiB7IGJvcmRlcjogXCIjN0MyOUYwXCIsIGJhY2tncm91bmQ6IFwiI0QzQkRGMFwiIH0gfSwgLy8gNTogcHVycGxlXG4gICAgICB7IGJvcmRlcjogXCIjQzM3RjAwXCIsIGJhY2tncm91bmQ6IFwiI0ZGQTgwN1wiLCBoaWdobGlnaHQ6IHsgYm9yZGVyOiBcIiNDMzdGMDBcIiwgYmFja2dyb3VuZDogXCIjRkZDQTY2XCIgfSwgaG92ZXI6IHsgYm9yZGVyOiBcIiNDMzdGMDBcIiwgYmFja2dyb3VuZDogXCIjRkZDQTY2XCIgfSB9LCAvLyA2OiBvcmFuZ2VcbiAgICAgIHsgYm9yZGVyOiBcIiM0MjIwRkJcIiwgYmFja2dyb3VuZDogXCIjNkU2RUZEXCIsIGhpZ2hsaWdodDogeyBib3JkZXI6IFwiIzQyMjBGQlwiLCBiYWNrZ3JvdW5kOiBcIiM5QjlCRkRcIiB9LCBob3ZlcjogeyBib3JkZXI6IFwiIzQyMjBGQlwiLCBiYWNrZ3JvdW5kOiBcIiM5QjlCRkRcIiB9IH0sIC8vIDc6IGRhcmtibHVlXG4gICAgICB7IGJvcmRlcjogXCIjRkQ1QTc3XCIsIGJhY2tncm91bmQ6IFwiI0ZGQzBDQlwiLCBoaWdobGlnaHQ6IHsgYm9yZGVyOiBcIiNGRDVBNzdcIiwgYmFja2dyb3VuZDogXCIjRkZEMUQ5XCIgfSwgaG92ZXI6IHsgYm9yZGVyOiBcIiNGRDVBNzdcIiwgYmFja2dyb3VuZDogXCIjRkZEMUQ5XCIgfSB9LCAvLyA4OiBwaW5rXG4gICAgICB7IGJvcmRlcjogXCIjNEFENjNBXCIsIGJhY2tncm91bmQ6IFwiI0MyRkFCQ1wiLCBoaWdobGlnaHQ6IHsgYm9yZGVyOiBcIiM0QUQ2M0FcIiwgYmFja2dyb3VuZDogXCIjRTZGRkUzXCIgfSwgaG92ZXI6IHsgYm9yZGVyOiBcIiM0QUQ2M0FcIiwgYmFja2dyb3VuZDogXCIjRTZGRkUzXCIgfSB9LCAvLyA5OiBtaW50XG5cbiAgICAgIHsgYm9yZGVyOiBcIiM5OTAwMDBcIiwgYmFja2dyb3VuZDogXCIjRUUwMDAwXCIsIGhpZ2hsaWdodDogeyBib3JkZXI6IFwiI0JCMDAwMFwiLCBiYWNrZ3JvdW5kOiBcIiNGRjMzMzNcIiB9LCBob3ZlcjogeyBib3JkZXI6IFwiI0JCMDAwMFwiLCBiYWNrZ3JvdW5kOiBcIiNGRjMzMzNcIiB9IH0sIC8vIDEwOmJyaWdodCByZWRcblxuICAgICAgeyBib3JkZXI6IFwiI0ZGNjAwMFwiLCBiYWNrZ3JvdW5kOiBcIiNGRjYwMDBcIiwgaGlnaGxpZ2h0OiB7IGJvcmRlcjogXCIjRkY2MDAwXCIsIGJhY2tncm91bmQ6IFwiI0ZGNjAwMFwiIH0sIGhvdmVyOiB7IGJvcmRlcjogXCIjRkY2MDAwXCIsIGJhY2tncm91bmQ6IFwiI0ZGNjAwMFwiIH0gfSwgLy8gMTI6IHJlYWwgb3JhbmdlXG4gICAgICB7IGJvcmRlcjogXCIjOTdDMkZDXCIsIGJhY2tncm91bmQ6IFwiIzJCN0NFOVwiLCBoaWdobGlnaHQ6IHsgYm9yZGVyOiBcIiNEMkU1RkZcIiwgYmFja2dyb3VuZDogXCIjMkI3Q0U5XCIgfSwgaG92ZXI6IHsgYm9yZGVyOiBcIiNEMkU1RkZcIiwgYmFja2dyb3VuZDogXCIjMkI3Q0U5XCIgfSB9LCAvLyAxMzogYmx1ZVxuICAgICAgeyBib3JkZXI6IFwiIzM5OTYwNVwiLCBiYWNrZ3JvdW5kOiBcIiMyNTVDMDNcIiwgaGlnaGxpZ2h0OiB7IGJvcmRlcjogXCIjMzk5NjA1XCIsIGJhY2tncm91bmQ6IFwiIzI1NUMwM1wiIH0sIGhvdmVyOiB7IGJvcmRlcjogXCIjMzk5NjA1XCIsIGJhY2tncm91bmQ6IFwiIzI1NUMwM1wiIH0gfSwgLy8gMTQ6IGdyZWVuXG4gICAgICB7IGJvcmRlcjogXCIjQjcwMDU0XCIsIGJhY2tncm91bmQ6IFwiI0ZGMDA3RVwiLCBoaWdobGlnaHQ6IHsgYm9yZGVyOiBcIiNCNzAwNTRcIiwgYmFja2dyb3VuZDogXCIjRkYwMDdFXCIgfSwgaG92ZXI6IHsgYm9yZGVyOiBcIiNCNzAwNTRcIiwgYmFja2dyb3VuZDogXCIjRkYwMDdFXCIgfSB9LCAvLyAxNTogbWFnZW50YVxuICAgICAgeyBib3JkZXI6IFwiI0FEODVFNFwiLCBiYWNrZ3JvdW5kOiBcIiM3QzI5RjBcIiwgaGlnaGxpZ2h0OiB7IGJvcmRlcjogXCIjRDNCREYwXCIsIGJhY2tncm91bmQ6IFwiIzdDMjlGMFwiIH0sIGhvdmVyOiB7IGJvcmRlcjogXCIjRDNCREYwXCIsIGJhY2tncm91bmQ6IFwiIzdDMjlGMFwiIH0gfSwgLy8gMTY6IHB1cnBsZVxuICAgICAgeyBib3JkZXI6IFwiIzQ1NTdGQVwiLCBiYWNrZ3JvdW5kOiBcIiMwMDBFQTFcIiwgaGlnaGxpZ2h0OiB7IGJvcmRlcjogXCIjNkU2RUZEXCIsIGJhY2tncm91bmQ6IFwiIzAwMEVBMVwiIH0sIGhvdmVyOiB7IGJvcmRlcjogXCIjNkU2RUZEXCIsIGJhY2tncm91bmQ6IFwiIzAwMEVBMVwiIH0gfSwgLy8gMTc6IGRhcmtibHVlXG4gICAgICB7IGJvcmRlcjogXCIjRkZDMENCXCIsIGJhY2tncm91bmQ6IFwiI0ZENUE3N1wiLCBoaWdobGlnaHQ6IHsgYm9yZGVyOiBcIiNGRkQxRDlcIiwgYmFja2dyb3VuZDogXCIjRkQ1QTc3XCIgfSwgaG92ZXI6IHsgYm9yZGVyOiBcIiNGRkQxRDlcIiwgYmFja2dyb3VuZDogXCIjRkQ1QTc3XCIgfSB9LCAvLyAxODogcGlua1xuICAgICAgeyBib3JkZXI6IFwiI0MyRkFCQ1wiLCBiYWNrZ3JvdW5kOiBcIiM3NEQ2NkFcIiwgaGlnaGxpZ2h0OiB7IGJvcmRlcjogXCIjRTZGRkUzXCIsIGJhY2tncm91bmQ6IFwiIzc0RDY2QVwiIH0sIGhvdmVyOiB7IGJvcmRlcjogXCIjRTZGRkUzXCIsIGJhY2tncm91bmQ6IFwiIzc0RDY2QVwiIH0gfSwgLy8gMTk6IG1pbnRcblxuICAgICAgeyBib3JkZXI6IFwiI0VFMDAwMFwiLCBiYWNrZ3JvdW5kOiBcIiM5OTAwMDBcIiwgaGlnaGxpZ2h0OiB7IGJvcmRlcjogXCIjRkYzMzMzXCIsIGJhY2tncm91bmQ6IFwiI0JCMDAwMFwiIH0sIGhvdmVyOiB7IGJvcmRlcjogXCIjRkYzMzMzXCIsIGJhY2tncm91bmQ6IFwiI0JCMDAwMFwiIH0gfSAvLyAyMDpicmlnaHQgcmVkXG4gICAgICBdO1xuXG4gICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIHVzZURlZmF1bHRHcm91cHM6IHRydWVcbiAgICAgIH07XG4gICAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhHcm91cHMsIFt7XG4gICAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0aW9uRmllbGRzID0gWyd1c2VEZWZhdWx0R3JvdXBzJ107XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIGdyb3VwTmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShncm91cE5hbWUpKSB7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25GaWVsZHMuaW5kZXhPZihncm91cE5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IG9wdGlvbnNbZ3JvdXBOYW1lXTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChncm91cE5hbWUsIGdyb3VwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENsZWFyIGFsbCBncm91cHNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImNsZWFyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzQXJyYXkgPSBbXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBnZXQgZ3JvdXAgb3B0aW9ucyBvZiBhIGdyb3VwbmFtZS4gSWYgZ3JvdXBuYW1lIGlzIG5vdCBmb3VuZCwgYSBuZXcgZ3JvdXBcbiAgICAgICAqIGlzIGFkZGVkLlxuICAgICAgICogQHBhcmFtIHsqfSBncm91cG5hbWUgICAgICAgIENhbiBiZSBhIG51bWJlciwgc3RyaW5nLCBEYXRlLCBldGMuXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGdyb3VwICAgICAgVGhlIGNyZWF0ZWQgZ3JvdXAsIGNvbnRhaW5pbmcgYWxsIGdyb3VwIG9wdGlvbnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldChncm91cG5hbWUpIHtcbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBuYW1lXTtcbiAgICAgICAgaWYgKGdyb3VwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVzZURlZmF1bHRHcm91cHMgPT09IGZhbHNlICYmIHRoaXMuZ3JvdXBzQXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIG5ldyBncm91cFxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5ncm91cEluZGV4ICUgdGhpcy5ncm91cHNBcnJheS5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmdyb3VwSW5kZXgrKztcbiAgICAgICAgICAgIGdyb3VwID0ge307XG4gICAgICAgICAgICBncm91cC5jb2xvciA9IHRoaXMuZ3JvdXBzW3RoaXMuZ3JvdXBzQXJyYXlbaW5kZXhdXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwbmFtZV0gPSBncm91cDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY3JlYXRlIG5ldyBncm91cFxuICAgICAgICAgICAgdmFyIF9pbmRleCA9IHRoaXMuZGVmYXVsdEluZGV4ICUgdGhpcy5kZWZhdWx0R3JvdXBzLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdEluZGV4Kys7XG4gICAgICAgICAgICBncm91cCA9IHt9O1xuICAgICAgICAgICAgZ3JvdXAuY29sb3IgPSB0aGlzLmRlZmF1bHRHcm91cHNbX2luZGV4XTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwbmFtZV0gPSBncm91cDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkIGEgY3VzdG9tIGdyb3VwIHN0eWxlXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBOYW1lXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGUgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYm9yZGVyQ29sb3IsXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yLCBldGMuXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGdyb3VwICAgICAgVGhlIGNyZWF0ZWQgZ3JvdXAgb2JqZWN0XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhZGRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoZ3JvdXBOYW1lLCBzdHlsZSkge1xuICAgICAgICB0aGlzLmdyb3Vwc1tncm91cE5hbWVdID0gc3R5bGU7XG4gICAgICAgIHRoaXMuZ3JvdXBzQXJyYXkucHVzaChncm91cE5hbWUpO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEdyb3VwcztcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IEdyb3VwcztcblxuLyoqKi8gfSxcbi8qIDY2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX05vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KTtcblxuICB2YXIgX05vZGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTm9kZSk7XG5cbiAgdmFyIF9MYWJlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNjgpO1xuXG4gIHZhciBfTGFiZWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGFiZWwpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBEYXRhU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbiAgdmFyIERhdGFWaWV3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbiAgdmFyIE5vZGVzSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb2Rlc0hhbmRsZXIoYm9keSwgaW1hZ2VzLCBncm91cHMsIGxheW91dEVuZ2luZSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVzSGFuZGxlcik7XG5cbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICB0aGlzLmltYWdlcyA9IGltYWdlcztcbiAgICAgIHRoaXMuZ3JvdXBzID0gZ3JvdXBzO1xuICAgICAgdGhpcy5sYXlvdXRFbmdpbmUgPSBsYXlvdXRFbmdpbmU7XG5cbiAgICAgIC8vIGNyZWF0ZSB0aGUgbm9kZSBBUEkgaW4gdGhlIGJvZHkgY29udGFpbmVyXG4gICAgICB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZU5vZGUgPSB0aGlzLmNyZWF0ZS5iaW5kKHRoaXMpO1xuXG4gICAgICB0aGlzLm5vZGVzTGlzdGVuZXJzID0ge1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIGFkZChldmVudCwgcGFyYW1zKSB7XG4gICAgICAgICAgX3RoaXMuYWRkKHBhcmFtcy5pdGVtcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgICBfdGhpcy51cGRhdGUocGFyYW1zLml0ZW1zLCBwYXJhbXMuZGF0YSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgICBfdGhpcy5yZW1vdmUocGFyYW1zLml0ZW1zKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgICAgYm9yZGVyV2lkdGhTZWxlY3RlZDogMixcbiAgICAgICAgYnJva2VuSW1hZ2U6IHVuZGVmaW5lZCxcbiAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICBib3JkZXI6ICcjMkI3Q0U5JyxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAnIzk3QzJGQycsXG4gICAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgICBib3JkZXI6ICcjMkI3Q0U5JyxcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICcjRDJFNUZGJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICAgIGJvcmRlcjogJyMyQjdDRTknLFxuICAgICAgICAgICAgYmFja2dyb3VuZDogJyNEMkU1RkYnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaXhlZDoge1xuICAgICAgICAgIHg6IGZhbHNlLFxuICAgICAgICAgIHk6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICBjb2xvcjogJyMzNDM0MzQnLFxuICAgICAgICAgIHNpemU6IDE0LCAvLyBweFxuICAgICAgICAgIGZhY2U6ICdhcmlhbCcsXG4gICAgICAgICAgYmFja2dyb3VuZDogJ25vbmUnLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAwLCAvLyBweFxuICAgICAgICAgIHN0cm9rZUNvbG9yOiAnI2ZmZmZmZicsXG4gICAgICAgICAgYWxpZ246ICdjZW50ZXInXG4gICAgICAgIH0sXG4gICAgICAgIGdyb3VwOiB1bmRlZmluZWQsXG4gICAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICAgIGljb246IHtcbiAgICAgICAgICBmYWNlOiAnRm9udEF3ZXNvbWUnLCAvLydGb250QXdlc29tZScsXG4gICAgICAgICAgY29kZTogdW5kZWZpbmVkLCAvLydcXHVmMDA3JyxcbiAgICAgICAgICBzaXplOiA1MCwgLy81MCxcbiAgICAgICAgICBjb2xvcjogJyMyQjdDRTknIC8vJyNhYTAwZmYnXG4gICAgICAgIH0sXG4gICAgICAgIGltYWdlOiB1bmRlZmluZWQsIC8vIC0tPiBVUkxcbiAgICAgICAgbGFiZWw6IHVuZGVmaW5lZCxcbiAgICAgICAgbGFiZWxIaWdobGlnaHRCb2xkOiB0cnVlLFxuICAgICAgICBsZXZlbDogdW5kZWZpbmVkLFxuICAgICAgICBtYXNzOiAxLFxuICAgICAgICBwaHlzaWNzOiB0cnVlLFxuICAgICAgICBzY2FsaW5nOiB7XG4gICAgICAgICAgbWluOiAxMCxcbiAgICAgICAgICBtYXg6IDMwLFxuICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIG1pbjogMTQsXG4gICAgICAgICAgICBtYXg6IDMwLFxuICAgICAgICAgICAgbWF4VmlzaWJsZTogMzAsXG4gICAgICAgICAgICBkcmF3VGhyZXNob2xkOiA1XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjdXN0b21TY2FsaW5nRnVuY3Rpb246IGZ1bmN0aW9uIGN1c3RvbVNjYWxpbmdGdW5jdGlvbihtaW4sIG1heCwgdG90YWwsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBzY2FsZSA9IDEgLyAobWF4IC0gbWluKTtcbiAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsICh2YWx1ZSAtIG1pbikgKiBzY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaGFkb3c6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBjb2xvcjogJ3JnYmEoMCwwLDAsMC41KScsXG4gICAgICAgICAgc2l6ZTogMTAsXG4gICAgICAgICAgeDogNSxcbiAgICAgICAgICB5OiA1XG4gICAgICAgIH0sXG4gICAgICAgIHNoYXBlOiAnZWxsaXBzZScsXG4gICAgICAgIHNoYXBlUHJvcGVydGllczoge1xuICAgICAgICAgIGJvcmRlckRhc2hlczogZmFsc2UsIC8vIG9ubHkgZm9yIGJvcmRlcnNcbiAgICAgICAgICBib3JkZXJSYWRpdXM6IDYsIC8vIG9ubHkgZm9yIGJveCBzaGFwZVxuICAgICAgICAgIGludGVycG9sYXRpb246IHRydWUsIC8vIG9ubHkgZm9yIGltYWdlIGFuZCBjaXJjdWxhckltYWdlIHNoYXBlc1xuICAgICAgICAgIHVzZUltYWdlU2l6ZTogZmFsc2UsIC8vIG9ubHkgZm9yIGltYWdlIGFuZCBjaXJjdWxhckltYWdlIHNoYXBlc1xuICAgICAgICAgIHVzZUJvcmRlcldpdGhJbWFnZTogZmFsc2UgLy8gb25seSBmb3IgaW1hZ2Ugc2hhcGVcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZTogMjUsXG4gICAgICAgIHRpdGxlOiB1bmRlZmluZWQsXG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIHg6IHVuZGVmaW5lZCxcbiAgICAgICAgeTogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgICAgdXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoTm9kZXNIYW5kbGVyLCBbe1xuICAgICAga2V5OiAnYmluZEV2ZW50TGlzdGVuZXJzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIC8vIHJlZnJlc2ggdGhlIG5vZGVzLiBVc2VkIHdoZW4gcmV2ZXJ0aW5nIGZyb20gaGllcmFyY2hpY2FsIGxheW91dFxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbigncmVmcmVzaE5vZGVzJywgdGhpcy5yZWZyZXNoLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbigncmVmcmVzaCcsIHRoaXMucmVmcmVzaC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdXRpbC5mb3JFYWNoKF90aGlzMi5ub2Rlc0xpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICAgICAgaWYgKF90aGlzMi5ib2R5LmRhdGEubm9kZXMpIF90aGlzMi5ib2R5LmRhdGEubm9kZXMub2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGVsZXRlIF90aGlzMi5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVOb2RlO1xuICAgICAgICAgIGRlbGV0ZSBfdGhpczIubm9kZXNMaXN0ZW5lcnMuYWRkO1xuICAgICAgICAgIGRlbGV0ZSBfdGhpczIubm9kZXNMaXN0ZW5lcnMudXBkYXRlO1xuICAgICAgICAgIGRlbGV0ZSBfdGhpczIubm9kZXNMaXN0ZW5lcnMucmVtb3ZlO1xuICAgICAgICAgIGRlbGV0ZSBfdGhpczIubm9kZXNMaXN0ZW5lcnM7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgX05vZGUyLmRlZmF1bHQucGFyc2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAvLyB1cGRhdGUgdGhlIHNoYXBlIGluIGFsbCBub2Rlc1xuICAgICAgICAgIGlmIChvcHRpb25zLnNoYXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0udXBkYXRlU2hhcGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgZm9udCBpbiBhbGwgbm9kZXNcbiAgICAgICAgICBpZiAob3B0aW9ucy5mb250ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF9MYWJlbDIuZGVmYXVsdC5wYXJzZU9wdGlvbnModGhpcy5vcHRpb25zLmZvbnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgZm9yICh2YXIgX25vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShfbm9kZUlkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkXS51cGRhdGVMYWJlbE1vZHVsZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkXS5fcmVzZXQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgc2hhcGUgc2l6ZSBpbiBhbGwgbm9kZXNcbiAgICAgICAgICBpZiAob3B0aW9ucy5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9ub2RlSWQyIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzLmhhc093blByb3BlcnR5KF9ub2RlSWQyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkMl0uX3Jlc2V0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB1cGRhdGUgdGhlIHN0YXRlIG9mIHRoZSBsZXRpYWJsZXMgaWYgbmVlZGVkXG4gICAgICAgICAgaWYgKG9wdGlvbnMuaGlkZGVuICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5waHlzaWNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19kYXRhQ2hhbmdlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCBhIGRhdGEgc2V0IHdpdGggbm9kZXMgZm9yIHRoZSBuZXR3b3JrXG4gICAgICAgKiBAcGFyYW0ge0FycmF5IHwgRGF0YVNldCB8IERhdGFWaWV3fSBub2RlcyAgICAgICAgIFRoZSBkYXRhIGNvbnRhaW5pbmcgdGhlIG5vZGVzLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0RGF0YScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGF0YShub2Rlcykge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICB2YXIgZG9Ob3RFbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgICB2YXIgb2xkTm9kZXNEYXRhID0gdGhpcy5ib2R5LmRhdGEubm9kZXM7XG5cbiAgICAgICAgaWYgKG5vZGVzIGluc3RhbmNlb2YgRGF0YVNldCB8fCBub2RlcyBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmRhdGEubm9kZXMgPSBub2RlcztcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgICAgICAgIHRoaXMuYm9keS5kYXRhLm5vZGVzID0gbmV3IERhdGFTZXQoKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZGF0YS5ub2Rlcy5hZGQobm9kZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKCFub2Rlcykge1xuICAgICAgICAgIHRoaXMuYm9keS5kYXRhLm5vZGVzID0gbmV3IERhdGFTZXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheSBvciBEYXRhU2V0IGV4cGVjdGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2xkTm9kZXNEYXRhKSB7XG4gICAgICAgICAgLy8gdW5zdWJzY3JpYmUgZnJvbSBvbGQgZGF0YXNldFxuICAgICAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLm5vZGVzTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgICBvbGROb2Rlc0RhdGEub2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgZHJhd24gbm9kZXNcbiAgICAgICAgdGhpcy5ib2R5Lm5vZGVzID0ge307XG5cbiAgICAgICAgaWYgKHRoaXMuYm9keS5kYXRhLm5vZGVzKSB7XG4gICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHN1YnNjcmliZSB0byBuZXcgZGF0YXNldFxuICAgICAgICAgICAgdmFyIG1lID0gX3RoaXMzO1xuICAgICAgICAgICAgdXRpbC5mb3JFYWNoKF90aGlzMy5ub2Rlc0xpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICAgICAgICBtZS5ib2R5LmRhdGEubm9kZXMub24oZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBkcmF3IGFsbCBuZXcgbm9kZXNcbiAgICAgICAgICAgIHZhciBpZHMgPSBfdGhpczMuYm9keS5kYXRhLm5vZGVzLmdldElkcygpO1xuICAgICAgICAgICAgX3RoaXMzLmFkZChpZHMsIHRydWUpO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9Ob3RFbWl0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGQgbm9kZXNcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyW10gfCBTdHJpbmdbXX0gaWRzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdhZGQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChpZHMpIHtcbiAgICAgICAgdmFyIGRvTm90RW1pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgICAgdmFyIGlkID0gdm9pZCAwO1xuICAgICAgICB2YXIgbmV3Tm9kZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZCA9IGlkc1tpXTtcbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuYm9keS5kYXRhLm5vZGVzLmdldChpZCk7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZShwcm9wZXJ0aWVzKTtcbiAgICAgICAgICBuZXdOb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1tpZF0gPSBub2RlOyAvLyBub3RlOiB0aGlzIG1heSByZXBsYWNlIGFuIGV4aXN0aW5nIG5vZGVcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGF5b3V0RW5naW5lLnBvc2l0aW9uSW5pdGlhbGx5KG5ld05vZGVzKTtcblxuICAgICAgICBpZiAoZG9Ob3RFbWl0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBVcGRhdGUgZXhpc3Rpbmcgbm9kZXMsIG9yIGNyZWF0ZSB0aGVtIHdoZW4gbm90IHlldCBleGlzdGluZ1xuICAgICAgICogQHBhcmFtIHtOdW1iZXJbXSB8IFN0cmluZ1tdfSBpZHNcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3VwZGF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKGlkcywgY2hhbmdlZERhdGEpIHtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgICB2YXIgZGF0YUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpZF07XG4gICAgICAgICAgdmFyIGRhdGEgPSBjaGFuZ2VkRGF0YVtpXTtcbiAgICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgbm9kZVxuICAgICAgICAgICAgZGF0YUNoYW5nZWQgPSBub2RlLnNldE9wdGlvbnMoZGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBub2RlXG4gICAgICAgICAgICBub2RlID0gdGhpcy5jcmVhdGUoZGF0YSk7XG4gICAgICAgICAgICBub2Rlc1tpZF0gPSBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YUNoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YVVwZGF0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgZXhpc3Rpbmcgbm9kZXMuIElmIG5vZGVzIGRvIG5vdCBleGlzdCwgdGhlIG1ldGhvZCB3aWxsIGp1c3QgaWdub3JlIGl0LlxuICAgICAgICogQHBhcmFtIHtOdW1iZXJbXSB8IFN0cmluZ1tdfSBpZHNcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlbW92ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGlkcykge1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICAgICAgZGVsZXRlIG5vZGVzW2lkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogY3JlYXRlIGEgbm9kZVxuICAgICAgICogQHBhcmFtIHByb3BlcnRpZXNcbiAgICAgICAqIEBwYXJhbSBjb25zdHJ1Y3RvckNsYXNzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NyZWF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgdmFyIGNvbnN0cnVjdG9yQ2xhc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IF9Ob2RlMi5kZWZhdWx0O1xuXG4gICAgICAgIHJldHVybiBuZXcgY29uc3RydWN0b3JDbGFzcyhwcm9wZXJ0aWVzLCB0aGlzLmJvZHksIHRoaXMuaW1hZ2VzLCB0aGlzLmdyb3VwcywgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZWZyZXNoJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgICAgICB2YXIgY2xlYXJQb3NpdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIG5vZGVzKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKG5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1tub2RlSWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuYm9keS5kYXRhLm5vZGVzLl9kYXRhW25vZGVJZF07XG4gICAgICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChjbGVhclBvc2l0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBub2RlLnNldE9wdGlvbnMoeyB4OiBudWxsLCB5OiBudWxsIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5zZXRPcHRpb25zKHsgZml4ZWQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgbm9kZS5zZXRPcHRpb25zKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIHBvc2l0aW9ucyBvZiB0aGUgbm9kZXMuXG4gICAgICAgKiBAcGFyYW0gaWRzICAtLT4gb3B0aW9uYWwsIGNhbiBiZSBhcnJheSBvZiBub2RlSWRzLCBjYW4gYmUgc3RyaW5nXG4gICAgICAgKiBAcmV0dXJucyB7e319XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldFBvc2l0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9zaXRpb25zKGlkcykge1xuICAgICAgICB2YXIgZGF0YUFycmF5ID0ge307XG4gICAgICAgIGlmIChpZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlkcykgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbaWRzW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbaWRzW2ldXTtcbiAgICAgICAgICAgICAgICBkYXRhQXJyYXlbaWRzW2ldXSA9IHsgeDogTWF0aC5yb3VuZChub2RlLngpLCB5OiBNYXRoLnJvdW5kKG5vZGUueSkgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2lkc10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgX25vZGUgPSB0aGlzLmJvZHkubm9kZXNbaWRzXTtcbiAgICAgICAgICAgICAgZGF0YUFycmF5W2lkc10gPSB7IHg6IE1hdGgucm91bmQoX25vZGUueCksIHk6IE1hdGgucm91bmQoX25vZGUueSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBfbm9kZTIgPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW19pXV07XG4gICAgICAgICAgICBkYXRhQXJyYXlbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW19pXV0gPSB7IHg6IE1hdGgucm91bmQoX25vZGUyLngpLCB5OiBNYXRoLnJvdW5kKF9ub2RlMi55KSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YUFycmF5O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIExvYWQgdGhlIFhZIHBvc2l0aW9ucyBvZiB0aGUgbm9kZXMgaW50byB0aGUgZGF0YXNldC5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc3RvcmVQb3NpdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3JlUG9zaXRpb25zKCkge1xuICAgICAgICAvLyB0b2RvOiBhZGQgc3VwcG9ydCBmb3IgY2x1c3RlcnMgYW5kIGhpZXJhcmNoaWNhbC5cbiAgICAgICAgdmFyIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICB2YXIgZGF0YXNldCA9IHRoaXMuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKTtcblxuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gZGF0YXNldC5fZGF0YSkge1xuICAgICAgICAgIGlmIChkYXRhc2V0Ll9kYXRhLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgICBpZiAoZGF0YXNldC5fZGF0YVtub2RlSWRdLnggIT0gTWF0aC5yb3VuZChub2RlLngpIHx8IGRhdGFzZXQuX2RhdGFbbm9kZUlkXS55ICE9IE1hdGgucm91bmQobm9kZS55KSkge1xuICAgICAgICAgICAgICBkYXRhQXJyYXkucHVzaCh7IGlkOiBub2RlLmlkLCB4OiBNYXRoLnJvdW5kKG5vZGUueCksIHk6IE1hdGgucm91bmQobm9kZS55KSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGF0YXNldC51cGRhdGUoZGF0YUFycmF5KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBnZXQgdGhlIGJvdW5kaW5nIGJveCBvZiBhIG5vZGUuXG4gICAgICAgKiBAcGFyYW0gbm9kZUlkXG4gICAgICAgKiBAcmV0dXJucyB7anwqfVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRCb3VuZGluZ0JveCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm91bmRpbmdCb3gobm9kZUlkKSB7XG4gICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLnNoYXBlLmJvdW5kaW5nQm94O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHRoZSBJZHMgb2Ygbm9kZXMgY29ubmVjdGVkIHRvIHRoaXMgbm9kZS5cbiAgICAgICAqIEBwYXJhbSBub2RlSWRcbiAgICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0Q29ubmVjdGVkTm9kZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbm5lY3RlZE5vZGVzKG5vZGVJZCkge1xuICAgICAgICB2YXIgbm9kZUxpc3QgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgIHZhciBub2RlT2JqID0ge307IC8vIHVzZWQgdG8gcXVpY2tseSBjaGVjayBpZiBub2RlIGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWRnZSA9IG5vZGUuZWRnZXNbaV07XG4gICAgICAgICAgICBpZiAoZWRnZS50b0lkID09IG5vZGUuaWQpIHtcbiAgICAgICAgICAgICAgLy8gdGhlc2UgYXJlIGRvdWJsZSBlcXVhbHMgc2luY2UgaWRzIGNhbiBiZSBudW1lcmljIG9yIHN0cmluZ1xuICAgICAgICAgICAgICBpZiAobm9kZU9ialtlZGdlLmZyb21JZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG5vZGVMaXN0LnB1c2goZWRnZS5mcm9tSWQpO1xuICAgICAgICAgICAgICAgIG5vZGVPYmpbZWRnZS5mcm9tSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChlZGdlLmZyb21JZCA9PSBub2RlLmlkKSB7XG4gICAgICAgICAgICAgIC8vIHRoZXNlIGFyZSBkb3VibGUgZXF1YWxzIHNpbmNlIGlkcyBjYW4gYmUgbnVtZXJpYyBvciBzdHJpbmdcbiAgICAgICAgICAgICAgaWYgKG5vZGVPYmpbZWRnZS50b0lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbm9kZUxpc3QucHVzaChlZGdlLnRvSWQpO1xuICAgICAgICAgICAgICAgIG5vZGVPYmpbZWRnZS50b0lkXSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVMaXN0O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCB0aGUgaWRzIG9mIHRoZSBlZGdlcyBjb25uZWN0ZWQgdG8gdGhpcyBub2RlLlxuICAgICAgICogQHBhcmFtIG5vZGVJZFxuICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldENvbm5lY3RlZEVkZ2VzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb25uZWN0ZWRFZGdlcyhub2RlSWQpIHtcbiAgICAgICAgdmFyIGVkZ2VMaXN0ID0gW107XG4gICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGVkZ2VMaXN0LnB1c2gobm9kZS5lZGdlc1tpXS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm9kZUlkIHByb3ZpZGVkIGZvciBnZXRDb25uZWN0ZWRFZGdlcyBkb2VzIG5vdCBleGlzdC4gUHJvdmlkZWQ6IFwiLCBub2RlSWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlZGdlTGlzdDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBNb3ZlIGEgbm9kZS5cbiAgICAgICAqIEBwYXJhbSBTdHJpbmcgbm9kZUlkXG4gICAgICAgKiBAcGFyYW0gTnVtYmVyIHhcbiAgICAgICAqIEBwYXJhbSBOdW1iZXIgeVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdtb3ZlTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZU5vZGUobm9kZUlkLCB4LCB5KSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0ueCA9IE51bWJlcih4KTtcbiAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS55ID0gTnVtYmVyKHkpO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXM0LmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm9kZSBpZCBzdXBwbGllZCB0byBtb3ZlTm9kZSBkb2VzIG5vdCBleGlzdC4gUHJvdmlkZWQ6IFwiLCBub2RlSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIE5vZGVzSGFuZGxlcjtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IE5vZGVzSGFuZGxlcjtcblxuLyoqKi8gfSxcbi8qIDY3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX0xhYmVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OCk7XG5cbiAgdmFyIF9MYWJlbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MYWJlbCk7XG5cbiAgdmFyIF9Cb3ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KTtcblxuICB2YXIgX0JveDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Cb3gpO1xuXG4gIHZhciBfQ2lyY2xlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cbiAgdmFyIF9DaXJjbGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2lyY2xlKTtcblxuICB2YXIgX0NpcmN1bGFySW1hZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKTtcblxuICB2YXIgX0NpcmN1bGFySW1hZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2lyY3VsYXJJbWFnZSk7XG5cbiAgdmFyIF9EYXRhYmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xuXG4gIHZhciBfRGF0YWJhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRGF0YWJhc2UpO1xuXG4gIHZhciBfRGlhbW9uZCA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpO1xuXG4gIHZhciBfRGlhbW9uZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EaWFtb25kKTtcblxuICB2YXIgX0RvdCA9IF9fd2VicGFja19yZXF1aXJlX18oNzcpO1xuXG4gIHZhciBfRG90MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RvdCk7XG5cbiAgdmFyIF9FbGxpcHNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OCk7XG5cbiAgdmFyIF9FbGxpcHNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0VsbGlwc2UpO1xuXG4gIHZhciBfSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNzkpO1xuXG4gIHZhciBfSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JY29uKTtcblxuICB2YXIgX0ltYWdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MCk7XG5cbiAgdmFyIF9JbWFnZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbWFnZSk7XG5cbiAgdmFyIF9TcXVhcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxKTtcblxuICB2YXIgX1NxdWFyZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TcXVhcmUpO1xuXG4gIHZhciBfU3RhciA9IF9fd2VicGFja19yZXF1aXJlX18oODIpO1xuXG4gIHZhciBfU3RhcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TdGFyKTtcblxuICB2YXIgX1RleHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgzKTtcblxuICB2YXIgX1RleHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVGV4dCk7XG5cbiAgdmFyIF9UcmlhbmdsZSA9IF9fd2VicGFja19yZXF1aXJlX18oODQpO1xuXG4gIHZhciBfVHJpYW5nbGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVHJpYW5nbGUpO1xuXG4gIHZhciBfVHJpYW5nbGVEb3duID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NSk7XG5cbiAgdmFyIF9UcmlhbmdsZURvd24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVHJpYW5nbGVEb3duKTtcblxuICB2YXIgX1ZhbGlkYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuXG4gIHZhciBfVmFsaWRhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1ZhbGlkYXRvcik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICAvKipcbiAgICogQGNsYXNzIE5vZGVcbiAgICogQSBub2RlLiBBIG5vZGUgY2FuIGJlIGNvbm5lY3RlZCB0byBvdGhlciBub2RlcyB2aWEgb25lIG9yIG11bHRpcGxlIGVkZ2VzLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyBvcHRpb25zIGZvciB0aGUgbm9kZS4gQWxsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgYXJlIG9wdGlvbmFsLCBleGNlcHQgZm9yIHRoZSBpZC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bnVtYmVyfSBpZCAgICAgSWQgb2YgdGhlIG5vZGUuIFJlcXVpcmVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gbGFiZWwgIFRleHQgbGFiZWwgZm9yIHRoZSBub2RlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlcn0geCAgICAgIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIG5vZGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bnVtYmVyfSB5ICAgICAgVmVydGljYWwgcG9zaXRpb24gb2YgdGhlIG5vZGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBzaGFwZSAgTm9kZSBzaGFwZSwgYXZhaWxhYmxlOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRhdGFiYXNlXCIsIFwiY2lyY2xlXCIsIFwiZWxsaXBzZVwiLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJveFwiLCBcImltYWdlXCIsIFwidGV4dFwiLCBcImRvdFwiLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInN0YXJcIiwgXCJ0cmlhbmdsZVwiLCBcInRyaWFuZ2xlRG93blwiLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNxdWFyZVwiLCBcImljb25cIlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IGltYWdlICBBbiBpbWFnZSB1cmxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSB0aXRsZSAgQW4gdGl0bGUgdGV4dCwgY2FuIGJlIEhUTUxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7YW55dHlwZX0gZ3JvdXAgQSBncm91cCBuYW1lIG9yIG51bWJlclxuICAgKiBAcGFyYW0ge05ldHdvcmsuSW1hZ2VzfSBpbWFnZWxpc3QgICAgQSBsaXN0IHdpdGggaW1hZ2VzLiBPbmx5IG5lZWRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiB0aGUgbm9kZSBoYXMgYW4gaW1hZ2VcbiAgICogQHBhcmFtIHtOZXR3b3JrLkdyb3Vwc30gZ3JvdXBsaXN0ICAgIEEgbGlzdCB3aXRoIGdyb3Vwcy4gTmVlZGVkIGZvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cmlldmluZyBncm91cCBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgIGNvbnN0YW50cyAgICBBbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHZhbHVlcyBmb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YW1wbGUgZm9yIHRoZSBjb2xvclxuICAgKlxuICAgKi9cbiAgdmFyIE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9kZShvcHRpb25zLCBib2R5LCBpbWFnZWxpc3QsIGdyb3VwbGlzdCwgZ2xvYmFsT3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGUpO1xuXG4gICAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmJyaWRnZU9iamVjdChnbG9iYWxPcHRpb25zKTtcbiAgICAgIHRoaXMuZ2xvYmFsT3B0aW9ucyA9IGdsb2JhbE9wdGlvbnM7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gICAgICB0aGlzLmVkZ2VzID0gW107IC8vIGFsbCBlZGdlcyBjb25uZWN0ZWQgdG8gdGhpcyBub2RlXG5cbiAgICAgIC8vIHNldCBkZWZhdWx0cyBmb3IgdGhlIG9wdGlvbnNcbiAgICAgIHRoaXMuaWQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmltYWdlbGlzdCA9IGltYWdlbGlzdDtcbiAgICAgIHRoaXMuZ3JvdXBsaXN0ID0gZ3JvdXBsaXN0O1xuXG4gICAgICAvLyBzdGF0ZSBvcHRpb25zXG4gICAgICB0aGlzLnggPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmJhc2VTaXplID0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICB0aGlzLmJhc2VGb250U2l6ZSA9IHRoaXMub3B0aW9ucy5mb250LnNpemU7XG4gICAgICB0aGlzLnByZWRlZmluZWRQb3NpdGlvbiA9IGZhbHNlOyAvLyB1c2VkIHRvIGNoZWNrIGlmIGluaXRpYWwgZml0IHNob3VsZCBqdXN0IHRha2UgdGhlIHJhbmdlIG9yIGFwcHJveGltYXRlXG4gICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmhvdmVyID0gZmFsc2U7XG5cbiAgICAgIHRoaXMubGFiZWxNb2R1bGUgPSBuZXcgX0xhYmVsMi5kZWZhdWx0KHRoaXMuYm9keSwgdGhpcy5vcHRpb25zLCBmYWxzZSAvKiBOb3QgZWRnZSBsYWJlbCAqLyk7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIGEgZWRnZSB0byB0aGUgbm9kZVxuICAgICAqIEBwYXJhbSB7RWRnZX0gZWRnZVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoTm9kZSwgW3tcbiAgICAgIGtleTogJ2F0dGFjaEVkZ2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaEVkZ2UoZWRnZSkge1xuICAgICAgICBpZiAodGhpcy5lZGdlcy5pbmRleE9mKGVkZ2UpID09PSAtMSkge1xuICAgICAgICAgIHRoaXMuZWRnZXMucHVzaChlZGdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERldGFjaCBhIGVkZ2UgZnJvbSB0aGUgbm9kZVxuICAgICAgICogQHBhcmFtIHtFZGdlfSBlZGdlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RldGFjaEVkZ2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaEVkZ2UoZWRnZSkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmVkZ2VzLmluZGV4T2YoZWRnZSk7XG4gICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xuICAgICAgICAgIHRoaXMuZWRnZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCBvciBvdmVyd3JpdGUgb3B0aW9ucyBmb3IgdGhlIG5vZGVcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGFuIG9iamVjdCB3aXRoIG9wdGlvbnNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25zdGFudHMgIGFuZCBvYmplY3Qgd2l0aCBkZWZhdWx0LCBnbG9iYWwgb3B0aW9uc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTaGFwZSA9IHRoaXMub3B0aW9ucy5zaGFwZTtcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJhc2ljIG9wdGlvbnNcbiAgICAgICAgaWYgKG9wdGlvbnMuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuaWQgPSBvcHRpb25zLmlkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IFwiTm9kZSBtdXN0IGhhdmUgYW4gaWRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB0aGVzZSBvcHRpb25zIGxvY2FsbHlcbiAgICAgICAgLy8gY2xlYXIgeCBhbmQgeSBwb3NpdGlvbnNcbiAgICAgICAgaWYgKG9wdGlvbnMueCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMueCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy54ID0gdW5kZWZpbmVkO3RoaXMucHJlZGVmaW5lZFBvc2l0aW9uID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMueCA9IHBhcnNlSW50KG9wdGlvbnMueCk7dGhpcy5wcmVkZWZpbmVkUG9zaXRpb24gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy55ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy55ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnkgPSB1bmRlZmluZWQ7dGhpcy5wcmVkZWZpbmVkUG9zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy55ID0gcGFyc2VJbnQob3B0aW9ucy55KTt0aGlzLnByZWRlZmluZWRQb3NpdGlvbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuYmFzZVNpemUgPSBvcHRpb25zLnNpemU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG9wdGlvbnMudmFsdWUgPSBwYXJzZUZsb2F0KG9wdGlvbnMudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29weSBncm91cCBvcHRpb25zXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5ncm91cCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIG9wdGlvbnMuZ3JvdXAgPT09ICdzdHJpbmcnICYmIG9wdGlvbnMuZ3JvdXAgIT0gJycpIHtcbiAgICAgICAgICB2YXIgZ3JvdXBPYmogPSB0aGlzLmdyb3VwbGlzdC5nZXQob3B0aW9ucy5ncm91cCk7XG4gICAgICAgICAgdXRpbC5kZWVwRXh0ZW5kKHRoaXMub3B0aW9ucywgZ3JvdXBPYmopO1xuICAgICAgICAgIC8vIHRoZSBjb2xvciBvYmplY3QgbmVlZHMgdG8gYmUgY29tcGxldGVseSBkZWZpbmVkLiBTaW5jZSBncm91cHMgY2FuIHBhcnRpYWxseSBvdmVyd3JpdGUgdGhlIGNvbG9ycywgd2UgcGFyc2UgaXQgYWdhaW4sIGp1c3QgaW4gY2FzZS5cbiAgICAgICAgICB0aGlzLm9wdGlvbnMuY29sb3IgPSB1dGlsLnBhcnNlQ29sb3IodGhpcy5vcHRpb25zLmNvbG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoaXMgdHJhbnNmb3JtcyBhbGwgc2hvcnRoYW5kcyBpbnRvIGZ1bGx5IGRlZmluZWQgb3B0aW9uc1xuICAgICAgICBOb2RlLnBhcnNlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsIHRydWUsIHRoaXMuZ2xvYmFsT3B0aW9ucyk7XG5cbiAgICAgICAgLy8gbG9hZCB0aGUgaW1hZ2VzXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW1hZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0aGlzLmltYWdlbGlzdCkge1xuICAgICAgICAgICAgdGhpcy5pbWFnZU9iaiA9IHRoaXMuaW1hZ2VsaXN0LmxvYWQodGhpcy5vcHRpb25zLmltYWdlLCB0aGlzLm9wdGlvbnMuYnJva2VuSW1hZ2UsIHRoaXMuaWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBcIk5vIGltYWdlbGlzdCBwcm92aWRlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlTGFiZWxNb2R1bGUoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTaGFwZShjdXJyZW50U2hhcGUpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmhpZGRlbiAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucGh5c2ljcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgcHJvY2VzcyBhbGwgcG9zc2libGUgc2hvcnRoYW5kcyBpbiB0aGUgbmV3IG9wdGlvbnMgYW5kIG1ha2VzIHN1cmUgdGhhdCB0aGUgcGFyZW50T3B0aW9ucyBhcmUgZnVsbHkgZGVmaW5lZC5cbiAgICAgICAqIFN0YXRpYyBzbyBpdCBjYW4gYWxzbyBiZSB1c2VkIGJ5IHRoZSBoYW5kbGVyLlxuICAgICAgICogQHBhcmFtIHBhcmVudE9wdGlvbnNcbiAgICAgICAqIEBwYXJhbSBuZXdPcHRpb25zXG4gICAgICAgKiBAcGFyYW0gYWxsb3dEZWxldGlvblxuICAgICAgICogQHBhcmFtIGdsb2JhbE9wdGlvbnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndXBkYXRlTGFiZWxNb2R1bGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUxhYmVsTW9kdWxlKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsID09PSB1bmRlZmluZWQgfHwgdGhpcy5vcHRpb25zLmxhYmVsID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmxhYmVsID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5zZXRPcHRpb25zKHRoaXMub3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsTW9kdWxlLmJhc2VTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmJhc2VGb250U2l6ZSA9IHRoaXMubGFiZWxNb2R1bGUuYmFzZVNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVTaGFwZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU2hhcGUoY3VycmVudFNoYXBlKSB7XG4gICAgICAgIGlmIChjdXJyZW50U2hhcGUgPT09IHRoaXMub3B0aW9ucy5zaGFwZSAmJiB0aGlzLnNoYXBlKSB7XG4gICAgICAgICAgdGhpcy5zaGFwZS5zZXRPcHRpb25zKHRoaXMub3B0aW9ucywgdGhpcy5pbWFnZU9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY2hvb3NlIGRyYXcgbWV0aG9kIGRlcGVuZGluZyBvbiB0aGUgc2hhcGVcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5zaGFwZSkge1xuICAgICAgICAgICAgY2FzZSAnYm94JzpcbiAgICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBfQm94Mi5kZWZhdWx0KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjaXJjbGUnOlxuICAgICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IF9DaXJjbGUyLmRlZmF1bHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NpcmN1bGFySW1hZ2UnOlxuICAgICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IF9DaXJjdWxhckltYWdlMi5kZWZhdWx0KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlLCB0aGlzLmltYWdlT2JqKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXRhYmFzZSc6XG4gICAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgX0RhdGFiYXNlMi5kZWZhdWx0KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkaWFtb25kJzpcbiAgICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBfRGlhbW9uZDIuZGVmYXVsdCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZG90JzpcbiAgICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBfRG90Mi5kZWZhdWx0KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdlbGxpcHNlJzpcbiAgICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBfRWxsaXBzZTIuZGVmYXVsdCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaWNvbic6XG4gICAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgX0ljb24yLmRlZmF1bHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBfSW1hZ2UyLmRlZmF1bHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUsIHRoaXMuaW1hZ2VPYmopO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NxdWFyZSc6XG4gICAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgX1NxdWFyZTIuZGVmYXVsdCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc3Rhcic6XG4gICAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgX1N0YXIyLmRlZmF1bHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IF9UZXh0Mi5kZWZhdWx0KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0cmlhbmdsZSc6XG4gICAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgX1RyaWFuZ2xlMi5kZWZhdWx0KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0cmlhbmdsZURvd24nOlxuICAgICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IF9UcmlhbmdsZURvd24yLmRlZmF1bHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgX0VsbGlwc2UyLmRlZmF1bHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBzZWxlY3QgdGhpcyBub2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NlbGVjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0KCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB1bnNlbGVjdCB0aGlzIG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndW5zZWxlY3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2VsZWN0KCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVzZXQgdGhlIGNhbGN1bGF0ZWQgc2l6ZSBvZiB0aGUgbm9kZSwgZm9yY2VzIGl0IHRvIHJlY2FsY3VsYXRlIGl0cyBzaXplXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcmVzZXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNldCgpIHtcbiAgICAgICAgdGhpcy5zaGFwZS53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zaGFwZS5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogZ2V0IHRoZSB0aXRsZSBvZiB0aGlzIG5vZGUuXG4gICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRpdGxlICAgIFRoZSB0aXRsZSBvZiB0aGUgbm9kZSwgb3IgdW5kZWZpbmVkIHdoZW4gbm8gdGl0bGVcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzIGJlZW4gc2V0LlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRUaXRsZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGl0bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudGl0bGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSB0byB0aGUgYm9yZGVyIG9mIHRoZSBOb2RlXG4gICAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gICBjdHhcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSAgICAgICAgQW5nbGUgaW4gcmFkaWFuc1xuICAgICAgICogQHJldHVybnMge251bWJlcn0gZGlzdGFuY2UgICBEaXN0YW5jZSB0byB0aGUgYm9yZGVyIGluIHBpeGVsc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcGUuZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDaGVjayBpZiB0aGlzIG5vZGUgaGFzIGEgZml4ZWQgeCBhbmQgeSBwb3NpdGlvblxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgICB0cnVlIGlmIGZpeGVkLCBmYWxzZSBpZiBub3RcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnaXNGaXhlZCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaXNGaXhlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5maXhlZC54ICYmIHRoaXMub3B0aW9ucy5maXhlZC55O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGNoZWNrIGlmIHRoaXMgbm9kZSBpcyBzZWxlY3RlXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBzZWxlY3RlZCAgIFRydWUgaWYgbm9kZSBpcyBzZWxlY3RlZCwgZWxzZSBmYWxzZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdpc1NlbGVjdGVkJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1NlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXRyaWV2ZSB0aGUgdmFsdWUgb2YgdGhlIG5vZGUuIENhbiBiZSB1bmRlZmluZWRcbiAgICAgICAqIEByZXR1cm4ge051bWJlcn0gdmFsdWVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0VmFsdWUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkanVzdCB0aGUgdmFsdWUgcmFuZ2Ugb2YgdGhlIG5vZGUuIFRoZSBub2RlIHdpbGwgYWRqdXN0IGl0J3Mgc2l6ZVxuICAgICAgICogYmFzZWQgb24gaXRzIHZhbHVlLlxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pblxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRWYWx1ZVJhbmdlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZVJhbmdlKG1pbiwgbWF4LCB0b3RhbCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5jdXN0b21TY2FsaW5nRnVuY3Rpb24obWluLCBtYXgsIHRvdGFsLCB0aGlzLm9wdGlvbnMudmFsdWUpO1xuICAgICAgICAgIHZhciBzaXplRGlmZiA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLm1heCAtIHRoaXMub3B0aW9ucy5zY2FsaW5nLm1pbjtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGZvbnREaWZmID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWF4IC0gdGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWluO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZvbnQuc2l6ZSA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1pbiArIHNjYWxlICogZm9udERpZmY7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMub3B0aW9ucy5zaXplID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubWluICsgc2NhbGUgKiBzaXplRGlmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuc2l6ZSA9IHRoaXMuYmFzZVNpemU7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmZvbnQuc2l6ZSA9IHRoaXMuYmFzZUZvbnRTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVMYWJlbE1vZHVsZSgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERyYXcgdGhpcyBub2RlIGluIHRoZSBnaXZlbiBjYW52YXNcbiAgICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RyYXcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICAgIHRoaXMuc2hhcGUuZHJhdyhjdHgsIHRoaXMueCwgdGhpcy55LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBVcGRhdGUgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgc2hhcGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndXBkYXRlQm91bmRpbmdCb3gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KGN0eCkge1xuICAgICAgICB0aGlzLnNoYXBlLnVwZGF0ZUJvdW5kaW5nQm94KHRoaXMueCwgdGhpcy55LCBjdHgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlY2FsY3VsYXRlIHRoZSBzaXplIG9mIHRoaXMgbm9kZSBpbiB0aGUgZ2l2ZW4gY2FudmFzXG4gICAgICAgKiBUaGUgMmQgY29udGV4dCBvZiBhIEhUTUwgY2FudmFzIGNhbiBiZSByZXRyaWV2ZWQgYnkgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZXNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgICAgdGhpcy5zaGFwZS5yZXNpemUoY3R4LCB0aGlzLnNlbGVjdGVkKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDaGVjayBpZiB0aGlzIG9iamVjdCBpcyBvdmVybGFwcGluZyB3aXRoIHRoZSBwcm92aWRlZCBvYmplY3RcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogICBhbiBvYmplY3Qgd2l0aCBwYXJhbWV0ZXJzIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgIFRydWUgaWYgbG9jYXRpb24gaXMgbG9jYXRlZCBvbiBub2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2lzT3ZlcmxhcHBpbmdXaXRoJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc092ZXJsYXBwaW5nV2l0aChvYmopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcGUubGVmdCA8IG9iai5yaWdodCAmJiB0aGlzLnNoYXBlLmxlZnQgKyB0aGlzLnNoYXBlLndpZHRoID4gb2JqLmxlZnQgJiYgdGhpcy5zaGFwZS50b3AgPCBvYmouYm90dG9tICYmIHRoaXMuc2hhcGUudG9wICsgdGhpcy5zaGFwZS5oZWlnaHQgPiBvYmoudG9wO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENoZWNrIGlmIHRoaXMgb2JqZWN0IGlzIG92ZXJsYXBwaW5nIHdpdGggdGhlIHByb3ZpZGVkIG9iamVjdFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAgIGFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgVHJ1ZSBpZiBsb2NhdGlvbiBpcyBsb2NhdGVkIG9uIG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnaXNCb3VuZGluZ0JveE92ZXJsYXBwaW5nV2l0aCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaXNCb3VuZGluZ0JveE92ZXJsYXBwaW5nV2l0aChvYmopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcGUuYm91bmRpbmdCb3gubGVmdCA8IG9iai5yaWdodCAmJiB0aGlzLnNoYXBlLmJvdW5kaW5nQm94LnJpZ2h0ID4gb2JqLmxlZnQgJiYgdGhpcy5zaGFwZS5ib3VuZGluZ0JveC50b3AgPCBvYmouYm90dG9tICYmIHRoaXMuc2hhcGUuYm91bmRpbmdCb3guYm90dG9tID4gb2JqLnRvcDtcbiAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgIGtleTogJ3BhcnNlT3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMpIHtcbiAgICAgICAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgICB2YXIgZ2xvYmFsT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG5cbiAgICAgICAgdmFyIGZpZWxkcyA9IFsnY29sb3InLCAnZm9udCcsICdmaXhlZCcsICdzaGFkb3cnXTtcbiAgICAgICAgdXRpbC5zZWxlY3RpdmVOb3REZWVwRXh0ZW5kKGZpZWxkcywgcGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucywgYWxsb3dEZWxldGlvbik7XG5cbiAgICAgICAgLy8gbWVyZ2UgdGhlIHNoYWRvdyBvcHRpb25zIGludG8gdGhlIHBhcmVudC5cbiAgICAgICAgdXRpbC5tZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucywgJ3NoYWRvdycsIGFsbG93RGVsZXRpb24sIGdsb2JhbE9wdGlvbnMpO1xuXG4gICAgICAgIC8vIGluZGl2aWR1YWwgc2hhcGUgbmV3T3B0aW9uc1xuICAgICAgICBpZiAobmV3T3B0aW9ucy5jb2xvciAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuY29sb3IgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgcGFyc2VkQ29sb3IgPSB1dGlsLnBhcnNlQ29sb3IobmV3T3B0aW9ucy5jb2xvcik7XG4gICAgICAgICAgdXRpbC5maWxsSWZEZWZpbmVkKHBhcmVudE9wdGlvbnMuY29sb3IsIHBhcnNlZENvbG9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlICYmIG5ld09wdGlvbnMuY29sb3IgPT09IG51bGwpIHtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmNvbG9yID0gdXRpbC5icmlkZ2VPYmplY3QoZ2xvYmFsT3B0aW9ucy5jb2xvcik7IC8vIHNldCB0aGUgb2JqZWN0IGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb25zXG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgdGhlIGZpeGVkIG9wdGlvbnNcbiAgICAgICAgaWYgKG5ld09wdGlvbnMuZml4ZWQgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmZpeGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuZXdPcHRpb25zLmZpeGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuZml4ZWQueCA9IG5ld09wdGlvbnMuZml4ZWQ7XG4gICAgICAgICAgICBwYXJlbnRPcHRpb25zLmZpeGVkLnkgPSBuZXdPcHRpb25zLmZpeGVkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobmV3T3B0aW9ucy5maXhlZC54ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG5ld09wdGlvbnMuZml4ZWQueCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuZml4ZWQueCA9IG5ld09wdGlvbnMuZml4ZWQueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdPcHRpb25zLmZpeGVkLnkgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgbmV3T3B0aW9ucy5maXhlZC55ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgcGFyZW50T3B0aW9ucy5maXhlZC55ID0gbmV3T3B0aW9ucy5maXhlZC55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSB0aGUgZm9udCBvcHRpb25zXG4gICAgICAgIGlmIChuZXdPcHRpb25zLmZvbnQgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmZvbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBfTGFiZWwyLmRlZmF1bHQucGFyc2VPcHRpb25zKHBhcmVudE9wdGlvbnMuZm9udCwgbmV3T3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLmZvbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmZvbnQgPSB1dGlsLmJyaWRnZU9iamVjdChnbG9iYWxPcHRpb25zLmZvbnQpOyAvLyBzZXQgdGhlIG9iamVjdCBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uc1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIHRoZSBzY2FsaW5nIG9wdGlvbnMsIHNwZWNpZmljYWxseSB0aGUgbGFiZWwgcGFydFxuICAgICAgICBpZiAobmV3T3B0aW9ucy5zY2FsaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB1dGlsLm1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLnNjYWxpbmcsIG5ld09wdGlvbnMuc2NhbGluZywgJ2xhYmVsJywgYWxsb3dEZWxldGlvbiwgZ2xvYmFsT3B0aW9ucy5zY2FsaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBOb2RlO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gTm9kZTtcblxuLyoqKi8gfSxcbi8qIDY4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG4gIHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIHZhciBMYWJlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMYWJlbChib2R5LCBvcHRpb25zKSB7XG4gICAgICB2YXIgZWRnZWxhYmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExhYmVsKTtcblxuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcblxuICAgICAgdGhpcy5wb2ludFRvU2VsZiA9IGZhbHNlO1xuICAgICAgdGhpcy5iYXNlU2l6ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZm9udE9wdGlvbnMgPSB7fTtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHRoaXMuc2l6ZSA9IHsgdG9wOiAwLCBsZWZ0OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwLCB5TGluZTogMCB9OyAvLyBjb3VsZCBiZSBjYWNoZWRcbiAgICAgIHRoaXMuaXNFZGdlTGFiZWwgPSBlZGdlbGFiZWw7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKExhYmVsLCBbe1xuICAgICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBhbGxvd0RlbGV0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgICB0aGlzLm5vZGVPcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgICAvLyBXZSB3YW50IHRvIGtlZXAgdGhlIGZvbnQgb3B0aW9ucyBzZXBlcmF0ZWQgZnJvbSB0aGUgbm9kZSBvcHRpb25zLlxuICAgICAgICAvLyBUaGUgbm9kZSBvcHRpb25zIGhhdmUgdG8gbWlycm9yIHRoZSBnbG9iYWxzIHdoZW4gdGhleSBhcmUgbm90IG92ZXJydWxlZC5cbiAgICAgICAgdGhpcy5mb250T3B0aW9ucyA9IHV0aWwuZGVlcEV4dGVuZCh7fSwgb3B0aW9ucy5mb250LCB0cnVlKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5sYWJlbERpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmZvbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIExhYmVsLnBhcnNlT3B0aW9ucyh0aGlzLmZvbnRPcHRpb25zLCBvcHRpb25zLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZm9udCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZVNpemUgPSB0aGlzLmZvbnRPcHRpb25zLnNpemU7XG4gICAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKG9wdGlvbnMuZm9udCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5mb250LnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLmJhc2VTaXplID0gb3B0aW9ucy5mb250LnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZHJhdycsXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBNYWluIGZ1bmN0aW9uLiBUaGlzIGlzIGNhbGxlZCBmcm9tIGFueXRoaW5nIHRoYXQgd2FudHMgdG8gZHJhdyBhIGxhYmVsLlxuICAgICAgICogQHBhcmFtIGN0eFxuICAgICAgICogQHBhcmFtIHhcbiAgICAgICAqIEBwYXJhbSB5XG4gICAgICAgKiBAcGFyYW0gc2VsZWN0ZWRcbiAgICAgICAqIEBwYXJhbSBiYXNlbGluZVxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkKSB7XG4gICAgICAgIHZhciBiYXNlbGluZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogJ21pZGRsZSc7XG5cbiAgICAgICAgLy8gaWYgbm8gbGFiZWwsIHJldHVyblxuICAgICAgICBpZiAodGhpcy5ub2RlT3B0aW9ucy5sYWJlbCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSB0byByZW5kZXIgdGhlIGxhYmVsXG4gICAgICAgIHZhciB2aWV3Rm9udFNpemUgPSB0aGlzLmZvbnRPcHRpb25zLnNpemUgKiB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgaWYgKHRoaXMubm9kZU9wdGlvbnMubGFiZWwgJiYgdmlld0ZvbnRTaXplIDwgdGhpcy5ub2RlT3B0aW9ucy5zY2FsaW5nLmxhYmVsLmRyYXdUaHJlc2hvbGQgLSAxKSByZXR1cm47XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBzaXplIGNhY2hlIGlmIHJlcXVpcmVkXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlTGFiZWxTaXplKGN0eCwgc2VsZWN0ZWQsIHgsIHksIGJhc2VsaW5lKTtcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGZvbnRmaWxsIGJhY2tncm91bmRcbiAgICAgICAgdGhpcy5fZHJhd0JhY2tncm91bmQoY3R4KTtcbiAgICAgICAgLy8gZHJhdyB0ZXh0XG4gICAgICAgIHRoaXMuX2RyYXdUZXh0KGN0eCwgc2VsZWN0ZWQsIHgsIHksIGJhc2VsaW5lKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEcmF3cyB0aGUgbGFiZWwgYmFja2dyb3VuZFxuICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2RyYXdCYWNrZ3JvdW5kJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0JhY2tncm91bmQoY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLmJhY2tncm91bmQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZvbnRPcHRpb25zLmJhY2tncm91bmQgIT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuZm9udE9wdGlvbnMuYmFja2dyb3VuZDtcblxuICAgICAgICAgIHZhciBsaW5lTWFyZ2luID0gMjtcblxuICAgICAgICAgIGlmICh0aGlzLmlzRWRnZUxhYmVsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZm9udE9wdGlvbnMuYWxpZ24pIHtcbiAgICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoLXRoaXMuc2l6ZS53aWR0aCAqIDAuNSwgLXRoaXMuc2l6ZS5oZWlnaHQgKiAwLjUsIHRoaXMuc2l6ZS53aWR0aCwgdGhpcy5zaXplLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KC10aGlzLnNpemUud2lkdGggKiAwLjUsIC0odGhpcy5zaXplLmhlaWdodCArIGxpbmVNYXJnaW4pLCB0aGlzLnNpemUud2lkdGgsIHRoaXMuc2l6ZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgtdGhpcy5zaXplLndpZHRoICogMC41LCBsaW5lTWFyZ2luLCB0aGlzLnNpemUud2lkdGgsIHRoaXMuc2l6ZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCh0aGlzLnNpemUubGVmdCwgdGhpcy5zaXplLnRvcCAtIDAuNSAqIGxpbmVNYXJnaW4sIHRoaXMuc2l6ZS53aWR0aCwgdGhpcy5zaXplLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCh0aGlzLnNpemUubGVmdCwgdGhpcy5zaXplLnRvcCAtIDAuNSAqIGxpbmVNYXJnaW4sIHRoaXMuc2l6ZS53aWR0aCwgdGhpcy5zaXplLmhlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBjdHhcbiAgICAgICAqIEBwYXJhbSB4XG4gICAgICAgKiBAcGFyYW0gYmFzZWxpbmVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19kcmF3VGV4dCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdUZXh0KGN0eCwgc2VsZWN0ZWQsIHgsIHkpIHtcbiAgICAgICAgdmFyIGJhc2VsaW5lID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAnbWlkZGxlJztcblxuICAgICAgICB2YXIgZm9udFNpemUgPSB0aGlzLmZvbnRPcHRpb25zLnNpemU7XG4gICAgICAgIHZhciB2aWV3Rm9udFNpemUgPSBmb250U2l6ZSAqIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICAvLyB0aGlzIGVuc3VyZXMgdGhhdCB0aGVyZSB3aWxsIG5vdCBiZSBIVUdFIGxldHRlcnMgb24gc2NyZWVuIGJ5IHNldHRpbmcgYW4gdXBwZXIgbGltaXQgb24gdGhlIHZpc2libGUgdGV4dCBzaXplIChyZWdhcmRsZXNzIG9mIHpvb21MZXZlbClcbiAgICAgICAgaWYgKHZpZXdGb250U2l6ZSA+PSB0aGlzLm5vZGVPcHRpb25zLnNjYWxpbmcubGFiZWwubWF4VmlzaWJsZSkge1xuICAgICAgICAgIGZvbnRTaXplID0gTnVtYmVyKHRoaXMubm9kZU9wdGlvbnMuc2NhbGluZy5sYWJlbC5tYXhWaXNpYmxlKSAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHlMaW5lID0gdGhpcy5zaXplLnlMaW5lO1xuXG4gICAgICAgIHZhciBfZ2V0Q29sb3IyID0gdGhpcy5fZ2V0Q29sb3Iodmlld0ZvbnRTaXplKSxcbiAgICAgICAgICAgIF9nZXRDb2xvcjMgPSBfc2xpY2VkVG9BcnJheShfZ2V0Q29sb3IyLCAyKSxcbiAgICAgICAgICAgIGZvbnRDb2xvciA9IF9nZXRDb2xvcjNbMF0sXG4gICAgICAgICAgICBzdHJva2VDb2xvciA9IF9nZXRDb2xvcjNbMV07XG5cbiAgICAgICAgLy8gY29uZmlndXJlIGNvbnRleHQgZm9yIGRyYXdpbmcgdGhlIHRleHRcbiAgICAgICAgdmFyIF9zZXRBbGlnbm1lbnQyID0gdGhpcy5fc2V0QWxpZ25tZW50KGN0eCwgeCwgeUxpbmUsIGJhc2VsaW5lKTtcblxuICAgICAgICB2YXIgX3NldEFsaWdubWVudDMgPSBfc2xpY2VkVG9BcnJheShfc2V0QWxpZ25tZW50MiwgMik7XG5cbiAgICAgICAgeCA9IF9zZXRBbGlnbm1lbnQzWzBdO1xuICAgICAgICB5TGluZSA9IF9zZXRBbGlnbm1lbnQzWzFdO1xuICAgICAgICBjdHguZm9udCA9IChzZWxlY3RlZCAmJiB0aGlzLm5vZGVPcHRpb25zLmxhYmVsSGlnaGxpZ2h0Qm9sZCA/ICdib2xkICcgOiAnJykgKyBmb250U2l6ZSArIFwicHggXCIgKyB0aGlzLmZvbnRPcHRpb25zLmZhY2U7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBmb250Q29sb3I7XG4gICAgICAgIC8vIFdoZW4gdGhlIHRleHRBbGlnbiBwcm9wZXJ0eSBpcyAnbGVmdCcsIG1ha2UgbGFiZWwgbGVmdC1qdXN0aWZpZWRcbiAgICAgICAgaWYgKCF0aGlzLmlzRWRnZUxhYmVsICYmIHRoaXMuZm9udE9wdGlvbnMuYWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSB0aGlzLmZvbnRPcHRpb25zLmFsaWduO1xuICAgICAgICAgIHggPSB4IC0gMC41ICogdGhpcy5zaXplLndpZHRoOyAvLyBTaGlmdCBsYWJlbCAxLzItZGlzdGFuY2UgdG8gdGhlIGxlZnRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdGhlIHN0cm9rZVdpZHRoXG4gICAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLnN0cm9rZVdpZHRoID4gMCkge1xuICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmZvbnRPcHRpb25zLnN0cm9rZVdpZHRoO1xuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yO1xuICAgICAgICAgIGN0eC5saW5lSm9pbiA9ICdyb3VuZCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkcmF3IHRoZSB0ZXh0XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lQ291bnQ7IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLnN0cm9rZVdpZHRoID4gMCkge1xuICAgICAgICAgICAgY3R4LnN0cm9rZVRleHQodGhpcy5saW5lc1tpXSwgeCwgeUxpbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHguZmlsbFRleHQodGhpcy5saW5lc1tpXSwgeCwgeUxpbmUpO1xuICAgICAgICAgIHlMaW5lICs9IGZvbnRTaXplO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3NldEFsaWdubWVudCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEFsaWdubWVudChjdHgsIHgsIHlMaW5lLCBiYXNlbGluZSkge1xuICAgICAgICAvLyBjaGVjayBmb3IgbGFiZWwgYWxpZ25tZW50IChmb3IgZWRnZXMpXG4gICAgICAgIC8vIFRPRE86IG1ha2UgYWxpZ25tZW50IGZvciBub2Rlc1xuICAgICAgICBpZiAodGhpcy5pc0VkZ2VMYWJlbCAmJiB0aGlzLmZvbnRPcHRpb25zLmFsaWduICE9PSAnaG9yaXpvbnRhbCcgJiYgdGhpcy5wb2ludFRvU2VsZiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICB5TGluZSA9IDA7XG5cbiAgICAgICAgICB2YXIgbGluZU1hcmdpbiA9IDI7XG4gICAgICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMuYWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ2FscGhhYmV0aWMnO1xuICAgICAgICAgICAgeUxpbmUgLT0gMiAqIGxpbmVNYXJnaW47IC8vIGRpc3RhbmNlIGZyb20gZWRnZSwgcmVxdWlyZWQgYmVjYXVzZSB3ZSB1c2UgYWxwaGFiZXRpYy4gQWxwaGFiZXRpYyBoYXMgbGVzcyBkaWZmZXJlbmNlIGJldHdlZW4gYnJvd3NlcnNcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZm9udE9wdGlvbnMuYWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ2hhbmdpbmcnO1xuICAgICAgICAgICAgeUxpbmUgKz0gMiAqIGxpbmVNYXJnaW47IC8vIGRpc3RhbmNlIGZyb20gZWRnZSwgcmVxdWlyZWQgYmVjYXVzZSB3ZSB1c2UgaGFuZ2luZy4gSGFuZ2luZyBoYXMgbGVzcyBkaWZmZXJlbmNlIGJldHdlZW4gYnJvd3NlcnNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gYmFzZWxpbmU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW3gsIHlMaW5lXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBmYWRlIGluIHdoZW4gcmVsYXRpdmUgc2NhbGUgaXMgYmV0d2VlbiB0aHJlc2hvbGQgYW5kIHRocmVzaG9sZCAtIDEuXG4gICAgICAgKiBJZiB0aGUgcmVsYXRpdmUgc2NhbGUgd291bGQgYmUgc21hbGxlciB0aGFuIHRocmVzaG9sZCAtMSB0aGUgZHJhdyBmdW5jdGlvbiB3b3VsZCBoYXZlIHJldHVybmVkIGJlZm9yZSBjb21pbmcgaGVyZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gdmlld0ZvbnRTaXplXG4gICAgICAgKiBAcmV0dXJucyB7KltdfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldENvbG9yJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q29sb3Iodmlld0ZvbnRTaXplKSB7XG4gICAgICAgIHZhciBmb250Q29sb3IgPSB0aGlzLmZvbnRPcHRpb25zLmNvbG9yIHx8ICcjMDAwMDAwJztcbiAgICAgICAgdmFyIHN0cm9rZUNvbG9yID0gdGhpcy5mb250T3B0aW9ucy5zdHJva2VDb2xvciB8fCAnI2ZmZmZmZic7XG4gICAgICAgIGlmICh2aWV3Rm9udFNpemUgPD0gdGhpcy5ub2RlT3B0aW9ucy5zY2FsaW5nLmxhYmVsLmRyYXdUaHJlc2hvbGQpIHtcbiAgICAgICAgICB2YXIgb3BhY2l0eSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIDEgLSAodGhpcy5ub2RlT3B0aW9ucy5zY2FsaW5nLmxhYmVsLmRyYXdUaHJlc2hvbGQgLSB2aWV3Rm9udFNpemUpKSk7XG4gICAgICAgICAgZm9udENvbG9yID0gdXRpbC5vdmVycmlkZU9wYWNpdHkoZm9udENvbG9yLCBvcGFjaXR5KTtcbiAgICAgICAgICBzdHJva2VDb2xvciA9IHV0aWwub3ZlcnJpZGVPcGFjaXR5KHN0cm9rZUNvbG9yLCBvcGFjaXR5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2ZvbnRDb2xvciwgc3Ryb2tlQ29sb3JdO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gY3R4XG4gICAgICAgKiBAcGFyYW0gc2VsZWN0ZWRcbiAgICAgICAqIEByZXR1cm5zIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRUZXh0U2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGV4dFNpemUoY3R4KSB7XG4gICAgICAgIHZhciBzZWxlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgICAgdmFyIHNpemUgPSB7XG4gICAgICAgICAgd2lkdGg6IHRoaXMuX3Byb2Nlc3NMYWJlbChjdHgsIHNlbGVjdGVkKSxcbiAgICAgICAgICBoZWlnaHQ6IHRoaXMuZm9udE9wdGlvbnMuc2l6ZSAqIHRoaXMubGluZUNvdW50LFxuICAgICAgICAgIGxpbmVDb3VudDogdGhpcy5saW5lQ291bnRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBjdHhcbiAgICAgICAqIEBwYXJhbSBzZWxlY3RlZFxuICAgICAgICogQHBhcmFtIHhcbiAgICAgICAqIEBwYXJhbSB5XG4gICAgICAgKiBAcGFyYW0gYmFzZWxpbmVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnY2FsY3VsYXRlTGFiZWxTaXplJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVMYWJlbFNpemUoY3R4LCBzZWxlY3RlZCkge1xuICAgICAgICB2YXIgeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgICAgIHZhciBiYXNlbGluZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogJ21pZGRsZSc7XG5cbiAgICAgICAgaWYgKHRoaXMubGFiZWxEaXJ0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuc2l6ZS53aWR0aCA9IHRoaXMuX3Byb2Nlc3NMYWJlbChjdHgsIHNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpemUuaGVpZ2h0ID0gdGhpcy5mb250T3B0aW9ucy5zaXplICogdGhpcy5saW5lQ291bnQ7XG4gICAgICAgIHRoaXMuc2l6ZS5sZWZ0ID0geCAtIHRoaXMuc2l6ZS53aWR0aCAqIDAuNTtcbiAgICAgICAgdGhpcy5zaXplLnRvcCA9IHkgLSB0aGlzLnNpemUuaGVpZ2h0ICogMC41O1xuICAgICAgICB0aGlzLnNpemUueUxpbmUgPSB5ICsgKDEgLSB0aGlzLmxpbmVDb3VudCkgKiAwLjUgKiB0aGlzLmZvbnRPcHRpb25zLnNpemU7XG4gICAgICAgIGlmIChiYXNlbGluZSA9PT0gXCJoYW5naW5nXCIpIHtcbiAgICAgICAgICB0aGlzLnNpemUudG9wICs9IDAuNSAqIHRoaXMuZm9udE9wdGlvbnMuc2l6ZTtcbiAgICAgICAgICB0aGlzLnNpemUudG9wICs9IDQ7IC8vIGRpc3RhbmNlIGZyb20gbm9kZSwgcmVxdWlyZWQgYmVjYXVzZSB3ZSB1c2UgaGFuZ2luZy4gSGFuZ2luZyBoYXMgbGVzcyBkaWZmZXJlbmNlIGJldHdlZW4gYnJvd3NlcnNcbiAgICAgICAgICB0aGlzLnNpemUueUxpbmUgKz0gNDsgLy8gZGlzdGFuY2UgZnJvbSBub2RlXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhYmVsRGlydHkgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGNhbGN1bGF0ZXMgdGhlIHdpZHRoIGFzIHdlbGwgYXMgZXhwbG9kZXMgdGhlIGxhYmVsIHN0cmluZyBhbmQgY2FsY3VsYXRlcyB0aGUgYW1vdW50IG9mIGxpbmVzLlxuICAgICAgICogQHBhcmFtIGN0eFxuICAgICAgICogQHBhcmFtIHNlbGVjdGVkXG4gICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3Byb2Nlc3NMYWJlbCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Byb2Nlc3NMYWJlbChjdHgsIHNlbGVjdGVkKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IDA7XG4gICAgICAgIHZhciBsaW5lcyA9IFsnJ107XG4gICAgICAgIHZhciBsaW5lQ291bnQgPSAwO1xuICAgICAgICBpZiAodGhpcy5ub2RlT3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGluZXMgPSBTdHJpbmcodGhpcy5ub2RlT3B0aW9ucy5sYWJlbCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIGxpbmVDb3VudCA9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgICBjdHguZm9udCA9IChzZWxlY3RlZCAmJiB0aGlzLm5vZGVPcHRpb25zLmxhYmVsSGlnaGxpZ2h0Qm9sZCA/ICdib2xkICcgOiAnJykgKyB0aGlzLmZvbnRPcHRpb25zLnNpemUgKyBcInB4IFwiICsgdGhpcy5mb250T3B0aW9ucy5mYWNlO1xuICAgICAgICAgIHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxpbmVzWzBdKS53aWR0aDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxpbmVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxpbmVzW2ldKS53aWR0aDtcbiAgICAgICAgICAgIHdpZHRoID0gbGluZVdpZHRoID4gd2lkdGggPyBsaW5lV2lkdGggOiB3aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgICAgICB0aGlzLmxpbmVDb3VudCA9IGxpbmVDb3VudDtcblxuICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICB9XG4gICAgfV0sIFt7XG4gICAgICBrZXk6ICdwYXJzZU9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zKSB7XG4gICAgICAgIHZhciBhbGxvd0RlbGV0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgICBpZiAodHlwZW9mIG5ld09wdGlvbnMuZm9udCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgbmV3T3B0aW9uc0FycmF5ID0gbmV3T3B0aW9ucy5mb250LnNwbGl0KFwiIFwiKTtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLnNpemUgPSBuZXdPcHRpb25zQXJyYXlbMF0ucmVwbGFjZShcInB4XCIsICcnKTtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmZhY2UgPSBuZXdPcHRpb25zQXJyYXlbMV07XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5jb2xvciA9IG5ld09wdGlvbnNBcnJheVsyXTtcbiAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKG5ld09wdGlvbnMuZm9udCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdXRpbC5maWxsSWZEZWZpbmVkKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMuZm9udCwgYWxsb3dEZWxldGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50T3B0aW9ucy5zaXplID0gTnVtYmVyKHBhcmVudE9wdGlvbnMuc2l6ZSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIExhYmVsO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gTGFiZWw7XG5cbi8qKiovIH0sXG4vKiA2OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9Ob2RlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcblxuICB2YXIgX05vZGVCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05vZGVCYXNlMik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4gIHZhciBCb3ggPSBmdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gICAgX2luaGVyaXRzKEJveCwgX05vZGVCYXNlKTtcblxuICAgIGZ1bmN0aW9uIEJveChvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJveCk7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQm94Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQm94KSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhCb3gsIFt7XG4gICAgICBrZXk6ICdyZXNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgsIHNlbGVjdGVkKSB7XG4gICAgICAgIGlmICh0aGlzLndpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgbWFyZ2luID0gNTtcbiAgICAgICAgICB2YXIgdGV4dFNpemUgPSB0aGlzLmxhYmVsTW9kdWxlLmdldFRleHRTaXplKGN0eCwgc2VsZWN0ZWQpO1xuICAgICAgICAgIHRoaXMud2lkdGggPSB0ZXh0U2l6ZS53aWR0aCArIDIgKiBtYXJnaW47XG4gICAgICAgICAgdGhpcy5oZWlnaHQgPSB0ZXh0U2l6ZS5oZWlnaHQgKyAyICogbWFyZ2luO1xuICAgICAgICAgIHRoaXMucmFkaXVzID0gMC41ICogdGhpcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RyYXcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCk7XG4gICAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgICAgIHZhciBib3JkZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkxpbmVXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aFNlbGVjdGVkIHx8IDIgKiB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG5cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc2VsZWN0ZWQgPyB0aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlciA6IGhvdmVyID8gdGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyLmJvcmRlciA6IHRoaXMub3B0aW9ucy5jb2xvci5ib3JkZXI7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBzZWxlY3RlZCA/IHNlbGVjdGlvbkxpbmVXaWR0aCA6IGJvcmRlcldpZHRoO1xuICAgICAgICBjdHgubGluZVdpZHRoIC89IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gTWF0aC5taW4odGhpcy53aWR0aCwgY3R4LmxpbmVXaWR0aCk7XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHNlbGVjdGVkID8gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5iYWNrZ3JvdW5kIDogaG92ZXIgPyB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYmFja2dyb3VuZCA6IHRoaXMub3B0aW9ucy5jb2xvci5iYWNrZ3JvdW5kO1xuXG4gICAgICAgIHZhciBib3JkZXJSYWRpdXMgPSB0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlclJhZGl1czsgLy8gb25seSBlZmZlY3RpdmUgZm9yIGJveFxuICAgICAgICBjdHgucm91bmRSZWN0KHRoaXMubGVmdCwgdGhpcy50b3AsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBib3JkZXJSYWRpdXMpO1xuXG4gICAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4KTtcbiAgICAgICAgLy8gZHJhdyB0aGUgYmFja2dyb3VuZFxuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuICAgICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4KTtcblxuICAgICAgICAvL2RyYXcgZGFzaGVkIGJvcmRlciBpZiBlbmFibGVkLCBzYXZlIGFuZCByZXN0b3JlIGlzIHJlcXVpcmVkIGZvciBmaXJlZm94IG5vdCB0byBjcmFzaCBvbiB1bml4LlxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAvLyBpZiBib3JkZXJzIGFyZSB6ZXJvIHdpZHRoLCB0aGV5IHdpbGwgYmUgZHJhd24gd2l0aCB3aWR0aCAxIGJ5IGRlZmF1bHQuIFRoaXMgcHJldmVudHMgdGhhdFxuICAgICAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5lbmFibGVCb3JkZXJEYXNoZXMoY3R4KTtcbiAgICAgICAgICAvL2RyYXcgdGhlIGJvcmRlclxuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAvL2Rpc2FibGUgZGFzaGVkIGJvcmRlciBmb3Igb3RoZXIgZWxlbWVudHNcbiAgICAgICAgICB0aGlzLmRpc2FibGVCb3JkZXJEYXNoZXMoY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCk7XG4gICAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVCb3VuZGluZ0JveCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggKiAwLjU7XG4gICAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0ICogMC41O1xuXG4gICAgICAgIHZhciBib3JkZXJSYWRpdXMgPSB0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlclJhZGl1czsgLy8gb25seSBlZmZlY3RpdmUgZm9yIGJveFxuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB0aGlzLmxlZnQgLSBib3JkZXJSYWRpdXM7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0gdGhpcy50b3AgLSBib3JkZXJSYWRpdXM7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gdGhpcy50b3AgKyB0aGlzLmhlaWdodCArIGJvcmRlclJhZGl1cztcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IHRoaXMubGVmdCArIHRoaXMud2lkdGggKyBib3JkZXJSYWRpdXM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGlzdGFuY2VUb0JvcmRlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICAgIHZhciBib3JkZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcblxuICAgICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5hYnModGhpcy53aWR0aCAvIDIgLyBNYXRoLmNvcyhhbmdsZSkpLCBNYXRoLmFicyh0aGlzLmhlaWdodCAvIDIgLyBNYXRoLnNpbihhbmdsZSkpKSArIGJvcmRlcldpZHRoO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBCb3g7XG4gIH0oX05vZGVCYXNlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBCb3g7XG5cbi8qKiovIH0sXG4vKiA3MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciBOb2RlQmFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb2RlQmFzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVCYXNlKTtcblxuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMubGFiZWxNb2R1bGUgPSBsYWJlbE1vZHVsZTtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94ID0geyB0b3A6IDAsIGxlZnQ6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAgfTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoTm9kZUJhc2UsIFt7XG4gICAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgICAgdmFyIGJvcmRlcldpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgpO1xuICAgICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5hYnModGhpcy53aWR0aCAvIDIgLyBNYXRoLmNvcyhhbmdsZSkpLCBNYXRoLmFicyh0aGlzLmhlaWdodCAvIDIgLyBNYXRoLnNpbihhbmdsZSkpKSArIGJvcmRlcldpZHRoO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJlbmFibGVTaGFkb3dcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVTaGFkb3coY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSB0aGlzLm9wdGlvbnMuc2hhZG93LmNvbG9yO1xuICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gdGhpcy5vcHRpb25zLnNoYWRvdy5zaXplO1xuICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gdGhpcy5vcHRpb25zLnNoYWRvdy54O1xuICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gdGhpcy5vcHRpb25zLnNoYWRvdy55O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRpc2FibGVTaGFkb3dcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlU2hhZG93KGN0eCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gMDtcbiAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IDA7XG4gICAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImVuYWJsZUJvcmRlckRhc2hlc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZUJvcmRlckRhc2hlcyhjdHgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyRGFzaGVzICE9PSBmYWxzZSkge1xuICAgICAgICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGRhc2hlcyA9IHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyRGFzaGVzO1xuICAgICAgICAgICAgaWYgKGRhc2hlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBkYXNoZXMgPSBbNSwgMTVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hlcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcInNldExpbmVEYXNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLiBUaGUgZGFzaGVkIGJvcmRlcnMgY2Fubm90IGJlIHVzZWQuXCIpO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJEYXNoZXMgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGlzYWJsZUJvcmRlckRhc2hlc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVCb3JkZXJEYXNoZXMoY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlckRhc2hlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChbMF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJzZXRMaW5lRGFzaCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4gVGhlIGRhc2hlZCBib3JkZXJzIGNhbm5vdCBiZSB1c2VkLlwiKTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyRGFzaGVzID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIE5vZGVCYXNlO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gTm9kZUJhc2U7XG5cbi8qKiovIH0sXG4vKiA3MSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9DaXJjbGVJbWFnZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Mik7XG5cbiAgdmFyIF9DaXJjbGVJbWFnZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2lyY2xlSW1hZ2VCYXNlMik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4gIHZhciBDaXJjbGUgPSBmdW5jdGlvbiAoX0NpcmNsZUltYWdlQmFzZSkge1xuICAgIF9pbmhlcml0cyhDaXJjbGUsIF9DaXJjbGVJbWFnZUJhc2UpO1xuXG4gICAgZnVuY3Rpb24gQ2lyY2xlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2lyY2xlKTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDaXJjbGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDaXJjbGUpKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKENpcmNsZSwgW3tcbiAgICAgIGtleTogJ3Jlc2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCwgc2VsZWN0ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBtYXJnaW4gPSA1O1xuICAgICAgICAgIHZhciB0ZXh0U2l6ZSA9IHRoaXMubGFiZWxNb2R1bGUuZ2V0VGV4dFNpemUoY3R4LCBzZWxlY3RlZCk7XG4gICAgICAgICAgdmFyIGRpYW1ldGVyID0gTWF0aC5tYXgodGV4dFNpemUud2lkdGgsIHRleHRTaXplLmhlaWdodCkgKyAyICogbWFyZ2luO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5zaXplID0gZGlhbWV0ZXIgLyAyO1xuXG4gICAgICAgICAgdGhpcy53aWR0aCA9IGRpYW1ldGVyO1xuICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gZGlhbWV0ZXI7XG4gICAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgICAgdGhpcy5fZHJhd1Jhd0NpcmNsZShjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdGhpcy5vcHRpb25zLnNpemUpO1xuXG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0geSAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB4IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB4ICsgdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0geSArIHRoaXMub3B0aW9ucy5zaXplO1xuXG4gICAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSk7XG4gICAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVCb3VuZGluZ0JveCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSkge1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCA9IHkgLSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0geCAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0geCArIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IHkgKyB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggKiAwLjU7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENpcmNsZTtcbiAgfShfQ2lyY2xlSW1hZ2VCYXNlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBDaXJjbGU7XG5cbi8qKiovIH0sXG4vKiA3MiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9Ob2RlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcblxuICB2YXIgX05vZGVCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05vZGVCYXNlMik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4gIHZhciBDaXJjbGVJbWFnZUJhc2UgPSBmdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gICAgX2luaGVyaXRzKENpcmNsZUltYWdlQmFzZSwgX05vZGVCYXNlKTtcblxuICAgIGZ1bmN0aW9uIENpcmNsZUltYWdlQmFzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENpcmNsZUltYWdlQmFzZSk7XG5cbiAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDaXJjbGVJbWFnZUJhc2UuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDaXJjbGVJbWFnZUJhc2UpKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG5cbiAgICAgIF90aGlzLmxhYmVsT2Zmc2V0ID0gMDtcbiAgICAgIF90aGlzLmltYWdlTG9hZGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKENpcmNsZUltYWdlQmFzZSwgW3tcbiAgICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucywgaW1hZ2VPYmopIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgaWYgKGltYWdlT2JqKSB7XG4gICAgICAgICAgdGhpcy5pbWFnZU9iaiA9IGltYWdlT2JqO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBmdW5jdGlvbiByZXNpemVzIHRoZSBpbWFnZSBieSB0aGUgb3B0aW9ucyBzaXplIHdoZW4gdGhlIGltYWdlIGhhcyBub3QgeWV0IGxvYWRlZC4gSWYgdGhlIGltYWdlIGhhcyBsb2FkZWQsIHdlXG4gICAgICAgKiBmb3JjZSB0aGUgdXBkYXRlIG9mIHRoZSBzaXplIGFnYWluLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19yZXNpemVJbWFnZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2l6ZUltYWdlKCkge1xuICAgICAgICB2YXIgZm9yY2UgPSBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLmltYWdlT2JqLndpZHRoIHx8ICF0aGlzLmltYWdlT2JqLmhlaWdodCkge1xuICAgICAgICAgIC8vIHVuZGVmaW5lZCBvciAwXG4gICAgICAgICAgdGhpcy5pbWFnZUxvYWRlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaW1hZ2VMb2FkZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5pbWFnZUxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLndpZHRoIHx8ICF0aGlzLmhlaWdodCB8fCBmb3JjZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIHVuZGVmaW5lZCBvciAwXG4gICAgICAgICAgdmFyIHdpZHRoLCBoZWlnaHQsIHJhdGlvO1xuICAgICAgICAgIGlmICh0aGlzLmltYWdlT2JqLndpZHRoICYmIHRoaXMuaW1hZ2VPYmouaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBub3QgdW5kZWZpbmVkIG9yIDBcbiAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgICAgIGhlaWdodCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLnVzZUltYWdlU2l6ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmltYWdlT2JqLndpZHRoID4gdGhpcy5pbWFnZU9iai5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgcmF0aW8gPSB0aGlzLmltYWdlT2JqLndpZHRoIC8gdGhpcy5pbWFnZU9iai5oZWlnaHQ7XG4gICAgICAgICAgICAgIHdpZHRoID0gdGhpcy5vcHRpb25zLnNpemUgKiAyICogcmF0aW8gfHwgdGhpcy5pbWFnZU9iai53aWR0aDtcbiAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5vcHRpb25zLnNpemUgKiAyIHx8IHRoaXMuaW1hZ2VPYmouaGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaW1hZ2VPYmoud2lkdGggJiYgdGhpcy5pbWFnZU9iai5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAvLyBub3QgdW5kZWZpbmVkIG9yIDBcbiAgICAgICAgICAgICAgICByYXRpbyA9IHRoaXMuaW1hZ2VPYmouaGVpZ2h0IC8gdGhpcy5pbWFnZU9iai53aWR0aDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByYXRpbyA9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd2lkdGggPSB0aGlzLm9wdGlvbnMuc2l6ZSAqIDI7XG4gICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMub3B0aW9ucy5zaXplICogMiAqIHJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3aGVuIG5vdCB1c2luZyB0aGUgc2l6ZSBwcm9wZXJ0eSwgd2UgdXNlIHRoZSBpbWFnZSBzaXplXG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMuaW1hZ2VPYmoud2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmltYWdlT2JqLmhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgIHRoaXMucmFkaXVzID0gMC41ICogdGhpcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19kcmF3UmF3Q2lyY2xlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd1Jhd0NpcmNsZShjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlciwgc2l6ZSkge1xuICAgICAgICB2YXIgbmV1dHJhbGJvcmRlcldpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgICB2YXIgc2VsZWN0aW9uTGluZVdpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoU2VsZWN0ZWQgfHwgMiAqIHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICAgICAgdmFyIGJvcmRlcldpZHRoID0gKHNlbGVjdGVkID8gc2VsZWN0aW9uTGluZVdpZHRoIDogbmV1dHJhbGJvcmRlcldpZHRoKSAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gTWF0aC5taW4odGhpcy53aWR0aCwgYm9yZGVyV2lkdGgpO1xuXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHNlbGVjdGVkID8gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5ib3JkZXIgOiBob3ZlciA/IHRoaXMub3B0aW9ucy5jb2xvci5ob3Zlci5ib3JkZXIgOiB0aGlzLm9wdGlvbnMuY29sb3IuYm9yZGVyO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gc2VsZWN0ZWQgPyB0aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQgOiBob3ZlciA/IHRoaXMub3B0aW9ucy5jb2xvci5ob3Zlci5iYWNrZ3JvdW5kIDogdGhpcy5vcHRpb25zLmNvbG9yLmJhY2tncm91bmQ7XG4gICAgICAgIGN0eC5jaXJjbGUoeCwgeSwgc2l6ZSk7XG5cbiAgICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgpO1xuICAgICAgICAvLyBkcmF3IHRoZSBiYWNrZ3JvdW5kXG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG4gICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgpO1xuXG4gICAgICAgIC8vZHJhdyBkYXNoZWQgYm9yZGVyIGlmIGVuYWJsZWQsIHNhdmUgYW5kIHJlc3RvcmUgaXMgcmVxdWlyZWQgZm9yIGZpcmVmb3ggbm90IHRvIGNyYXNoIG9uIHVuaXguXG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIC8vIGlmIGJvcmRlcnMgYXJlIHplcm8gd2lkdGgsIHRoZXkgd2lsbCBiZSBkcmF3biB3aXRoIHdpZHRoIDEgYnkgZGVmYXVsdC4gVGhpcyBwcmV2ZW50cyB0aGF0XG4gICAgICAgIGlmIChib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLmVuYWJsZUJvcmRlckRhc2hlcyhjdHgpO1xuICAgICAgICAgIC8vZHJhdyB0aGUgYm9yZGVyXG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIC8vZGlzYWJsZSBkYXNoZWQgYm9yZGVyIGZvciBvdGhlciBlbGVtZW50c1xuICAgICAgICAgIHRoaXMuZGlzYWJsZUJvcmRlckRhc2hlcyhjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2RyYXdJbWFnZUF0UG9zaXRpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3SW1hZ2VBdFBvc2l0aW9uKGN0eCkge1xuICAgICAgICBpZiAodGhpcy5pbWFnZU9iai53aWR0aCAhPSAwKSB7XG4gICAgICAgICAgLy8gZHJhdyB0aGUgaW1hZ2VcbiAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxLjA7XG5cbiAgICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4KTtcblxuICAgICAgICAgIHZhciBmYWN0b3IgPSB0aGlzLmltYWdlT2JqLndpZHRoIC8gdGhpcy53aWR0aCAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICAgIGlmIChmYWN0b3IgPiAyICYmIHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuaW50ZXJwb2xhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHcgPSB0aGlzLmltYWdlT2JqLndpZHRoO1xuICAgICAgICAgICAgdmFyIGggPSB0aGlzLmltYWdlT2JqLmhlaWdodDtcbiAgICAgICAgICAgIHZhciBjYW4yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBjYW4yLndpZHRoID0gdztcbiAgICAgICAgICAgIGNhbjIuaGVpZ2h0ID0gdztcbiAgICAgICAgICAgIHZhciBjdHgyID0gY2FuMi5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICBmYWN0b3IgKj0gMC41O1xuICAgICAgICAgICAgdyAqPSAwLjU7XG4gICAgICAgICAgICBoICo9IDAuNTtcbiAgICAgICAgICAgIGN0eDIuZHJhd0ltYWdlKHRoaXMuaW1hZ2VPYmosIDAsIDAsIHcsIGgpO1xuXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSAwO1xuICAgICAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAxO1xuICAgICAgICAgICAgd2hpbGUgKGZhY3RvciA+IDIgJiYgaXRlcmF0aW9ucyA8IDQpIHtcbiAgICAgICAgICAgICAgY3R4Mi5kcmF3SW1hZ2UoY2FuMiwgZGlzdGFuY2UsIDAsIHcsIGgsIGRpc3RhbmNlICsgdywgMCwgdyAvIDIsIGggLyAyKTtcbiAgICAgICAgICAgICAgZGlzdGFuY2UgKz0gdztcbiAgICAgICAgICAgICAgZmFjdG9yICo9IDAuNTtcbiAgICAgICAgICAgICAgdyAqPSAwLjU7XG4gICAgICAgICAgICAgIGggKj0gMC41O1xuICAgICAgICAgICAgICBpdGVyYXRpb25zICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGNhbjIsIGRpc3RhbmNlLCAwLCB3LCBoLCB0aGlzLmxlZnQsIHRoaXMudG9wLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRyYXcgaW1hZ2VcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5pbWFnZU9iaiwgdGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG4gICAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZHJhd0ltYWdlTGFiZWwnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3SW1hZ2VMYWJlbChjdHgsIHgsIHksIHNlbGVjdGVkKSB7XG4gICAgICAgIHZhciB5TGFiZWw7XG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLmhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gdGhpcy5oZWlnaHQgKiAwLjU7XG4gICAgICAgICAgdmFyIGxhYmVsRGltZW5zaW9ucyA9IHRoaXMubGFiZWxNb2R1bGUuZ2V0VGV4dFNpemUoY3R4KTtcbiAgICAgICAgICBpZiAobGFiZWxEaW1lbnNpb25zLmxpbmVDb3VudCA+PSAxKSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gbGFiZWxEaW1lbnNpb25zLmhlaWdodCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgeUxhYmVsID0geSArIG9mZnNldDtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsKSB7XG4gICAgICAgICAgdGhpcy5sYWJlbE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB4LCB5TGFiZWwsIHNlbGVjdGVkLCAnaGFuZ2luZycpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDaXJjbGVJbWFnZUJhc2U7XG4gIH0oX05vZGVCYXNlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBDaXJjbGVJbWFnZUJhc2U7XG5cbi8qKiovIH0sXG4vKiA3MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9DaXJjbGVJbWFnZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Mik7XG5cbiAgdmFyIF9DaXJjbGVJbWFnZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2lyY2xlSW1hZ2VCYXNlMik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4gIHZhciBDaXJjdWxhckltYWdlID0gZnVuY3Rpb24gKF9DaXJjbGVJbWFnZUJhc2UpIHtcbiAgICBfaW5oZXJpdHMoQ2lyY3VsYXJJbWFnZSwgX0NpcmNsZUltYWdlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBDaXJjdWxhckltYWdlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlLCBpbWFnZU9iaikge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENpcmN1bGFySW1hZ2UpO1xuXG4gICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ2lyY3VsYXJJbWFnZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENpcmN1bGFySW1hZ2UpKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG5cbiAgICAgIF90aGlzLmltYWdlT2JqID0gaW1hZ2VPYmo7XG4gICAgICBfdGhpcy5fc3dhcFRvSW1hZ2VSZXNpemVXaGVuSW1hZ2VMb2FkZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDaXJjdWxhckltYWdlLCBbe1xuICAgICAga2V5OiAncmVzaXplJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmltYWdlT2JqLnNyYyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuaW1hZ2VPYmoud2lkdGggPT09IHVuZGVmaW5lZCB8fCB0aGlzLmltYWdlT2JqLmhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLndpZHRoKSB7XG4gICAgICAgICAgICB2YXIgZGlhbWV0ZXIgPSB0aGlzLm9wdGlvbnMuc2l6ZSAqIDI7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gZGlhbWV0ZXI7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGRpYW1ldGVyO1xuICAgICAgICAgICAgdGhpcy5fc3dhcFRvSW1hZ2VSZXNpemVXaGVuSW1hZ2VMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5fc3dhcFRvSW1hZ2VSZXNpemVXaGVuSW1hZ2VMb2FkZWQpIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX3N3YXBUb0ltYWdlUmVzaXplV2hlbkltYWdlTG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3Jlc2l6ZUltYWdlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkcmF3JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbigwLjUgKiB0aGlzLmhlaWdodCwgMC41ICogdGhpcy53aWR0aCk7XG5cbiAgICAgICAgLy8gZHJhdyB0aGUgYmFja2dyb3VuZCBjaXJjbGUuIElNUE9SVEFOVDogdGhlIHN0cm9rZSBpbiB0aGlzIG1ldGhvZCBpcyB1c2VkIGJ5IHRoZSBjbGlwIG1ldGhvZCBiZWxvdy5cbiAgICAgICAgdGhpcy5fZHJhd1Jhd0NpcmNsZShjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlciwgc2l6ZSk7XG5cbiAgICAgICAgLy8gbm93IHdlIGRyYXcgaW4gdGhlIGNpcmNsZSwgd2Ugc2F2ZSBzbyB3ZSBjYW4gcmV2ZXJ0IHRoZSBjbGlwIG9wZXJhdGlvbiBhZnRlciBkcmF3aW5nLlxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAvLyBjbGlwIGlzIHVzZWQgdG8gdXNlIHRoZSBzdHJva2UgaW4gZHJhd1Jhd0NpcmNsZSBhcyBhbiBhcmVhIHRoYXQgd2UgY2FuIGRyYXcgaW4uXG4gICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgIC8vIGRyYXcgdGhlIGltYWdlXG4gICAgICAgIHRoaXMuX2RyYXdJbWFnZUF0UG9zaXRpb24oY3R4KTtcbiAgICAgICAgLy8gcmVzdG9yZSBzbyB3ZSBjYW4gYWdhaW4gZHJhdyBvbiB0aGUgZnVsbCBjYW52YXNcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICB0aGlzLl9kcmF3SW1hZ2VMYWJlbChjdHgsIHgsIHksIHNlbGVjdGVkKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3VwZGF0ZUJvdW5kaW5nQm94JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5KSB7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0geSAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB4IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB4ICsgdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0geSArIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSBNYXRoLm1pbih0aGlzLmJvdW5kaW5nQm94LmxlZnQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0KTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3gucmlnaHQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0ICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoKTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSwgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gKyB0aGlzLmxhYmVsT2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggKiAwLjU7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENpcmN1bGFySW1hZ2U7XG4gIH0oX0NpcmNsZUltYWdlQmFzZTMuZGVmYXVsdCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gQ2lyY3VsYXJJbWFnZTtcblxuLyoqKi8gfSxcbi8qIDc0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX05vZGVCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzApO1xuXG4gIHZhciBfTm9kZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTm9kZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIERhdGFiYXNlID0gZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICAgIF9pbmhlcml0cyhEYXRhYmFzZSwgX05vZGVCYXNlKTtcblxuICAgIGZ1bmN0aW9uIERhdGFiYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YWJhc2UpO1xuXG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKERhdGFiYXNlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRGF0YWJhc2UpKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKERhdGFiYXNlLCBbe1xuICAgICAga2V5OiAncmVzaXplJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4LCBzZWxlY3RlZCkge1xuICAgICAgICBpZiAodGhpcy53aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIG1hcmdpbiA9IDU7XG4gICAgICAgICAgdmFyIHRleHRTaXplID0gdGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZShjdHgsIHNlbGVjdGVkKTtcbiAgICAgICAgICB2YXIgc2l6ZSA9IHRleHRTaXplLndpZHRoICsgMiAqIG1hcmdpbjtcbiAgICAgICAgICB0aGlzLndpZHRoID0gc2l6ZTtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IHNpemU7XG4gICAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgICAgdmFyIG5ldXRyYWxib3JkZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkxpbmVXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aFNlbGVjdGVkIHx8IDIgKiB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICAgIHZhciBib3JkZXJXaWR0aCA9IChzZWxlY3RlZCA/IHNlbGVjdGlvbkxpbmVXaWR0aCA6IG5ldXRyYWxib3JkZXJXaWR0aCkgLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IE1hdGgubWluKHRoaXMud2lkdGgsIGJvcmRlcldpZHRoKTtcblxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzZWxlY3RlZCA/IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYm9yZGVyIDogaG92ZXIgPyB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYm9yZGVyIDogdGhpcy5vcHRpb25zLmNvbG9yLmJvcmRlcjtcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gc2VsZWN0ZWQgPyB0aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQgOiBob3ZlciA/IHRoaXMub3B0aW9ucy5jb2xvci5ob3Zlci5iYWNrZ3JvdW5kIDogdGhpcy5vcHRpb25zLmNvbG9yLmJhY2tncm91bmQ7XG4gICAgICAgIGN0eC5kYXRhYmFzZSh4IC0gdGhpcy53aWR0aCAvIDIsIHkgLSB0aGlzLmhlaWdodCAqIDAuNSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG4gICAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4KTtcbiAgICAgICAgLy8gZHJhdyB0aGUgYmFja2dyb3VuZFxuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuICAgICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4KTtcblxuICAgICAgICAvL2RyYXcgZGFzaGVkIGJvcmRlciBpZiBlbmFibGVkLCBzYXZlIGFuZCByZXN0b3JlIGlzIHJlcXVpcmVkIGZvciBmaXJlZm94IG5vdCB0byBjcmFzaCBvbiB1bml4LlxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAvLyBpZiBib3JkZXJzIGFyZSB6ZXJvIHdpZHRoLCB0aGV5IHdpbGwgYmUgZHJhd24gd2l0aCB3aWR0aCAxIGJ5IGRlZmF1bHQuIFRoaXMgcHJldmVudHMgdGhhdFxuICAgICAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5lbmFibGVCb3JkZXJEYXNoZXMoY3R4KTtcbiAgICAgICAgICAvL2RyYXcgdGhlIGJvcmRlclxuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAvL2Rpc2FibGUgZGFzaGVkIGJvcmRlciBmb3Igb3RoZXIgZWxlbWVudHNcbiAgICAgICAgICB0aGlzLmRpc2FibGVCb3JkZXJEYXNoZXMoY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCk7XG4gICAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVCb3VuZGluZ0JveCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkKTtcblxuICAgICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAqIDAuNTtcbiAgICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgKiAwLjU7XG5cbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gdGhpcy5sZWZ0O1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCA9IHRoaXMudG9wO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IHRoaXMudG9wICsgdGhpcy5oZWlnaHQ7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB0aGlzLmxlZnQgKyB0aGlzLndpZHRoO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRGF0YWJhc2U7XG4gIH0oX05vZGVCYXNlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBEYXRhYmFzZTtcblxuLyoqKi8gfSxcbi8qIDc1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX1NoYXBlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KTtcblxuICB2YXIgX1NoYXBlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaGFwZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIERpYW1vbmQgPSBmdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICAgIF9pbmhlcml0cyhEaWFtb25kLCBfU2hhcGVCYXNlKTtcblxuICAgIGZ1bmN0aW9uIERpYW1vbmQob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaWFtb25kKTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChEaWFtb25kLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRGlhbW9uZCkpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRGlhbW9uZCwgW3tcbiAgICAgIGtleTogJ3Jlc2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCkge1xuICAgICAgICB0aGlzLl9yZXNpemVTaGFwZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RyYXcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgICAgdGhpcy5fZHJhd1NoYXBlKGN0eCwgJ2RpYW1vbmQnLCA0LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRGlhbW9uZDtcbiAgfShfU2hhcGVCYXNlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBEaWFtb25kO1xuXG4vKioqLyB9LFxuLyogNzYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfTm9kZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MCk7XG5cbiAgdmFyIF9Ob2RlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Ob2RlQmFzZTIpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuICB2YXIgU2hhcGVCYXNlID0gZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICAgIF9pbmhlcml0cyhTaGFwZUJhc2UsIF9Ob2RlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBTaGFwZUJhc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaGFwZUJhc2UpO1xuXG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFNoYXBlQmFzZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNoYXBlQmFzZSkpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU2hhcGVCYXNlLCBbe1xuICAgICAga2V5OiAnX3Jlc2l6ZVNoYXBlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplU2hhcGUoKSB7XG4gICAgICAgIGlmICh0aGlzLndpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgc2l6ZSA9IDIgKiB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgICAgICB0aGlzLndpZHRoID0gc2l6ZTtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IHNpemU7XG4gICAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2RyYXdTaGFwZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdTaGFwZShjdHgsIHNoYXBlLCBzaXplTXVsdGlwbGllciwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZVNoYXBlKCk7XG5cbiAgICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgICAgdmFyIG5ldXRyYWxib3JkZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkxpbmVXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aFNlbGVjdGVkIHx8IDIgKiB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICAgIHZhciBib3JkZXJXaWR0aCA9IChzZWxlY3RlZCA/IHNlbGVjdGlvbkxpbmVXaWR0aCA6IG5ldXRyYWxib3JkZXJXaWR0aCkgLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IE1hdGgubWluKHRoaXMud2lkdGgsIGJvcmRlcldpZHRoKTtcblxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzZWxlY3RlZCA/IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYm9yZGVyIDogaG92ZXIgPyB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYm9yZGVyIDogdGhpcy5vcHRpb25zLmNvbG9yLmJvcmRlcjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHNlbGVjdGVkID8gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5iYWNrZ3JvdW5kIDogaG92ZXIgPyB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYmFja2dyb3VuZCA6IHRoaXMub3B0aW9ucy5jb2xvci5iYWNrZ3JvdW5kO1xuICAgICAgICBjdHhbc2hhcGVdKHgsIHksIHRoaXMub3B0aW9ucy5zaXplKTtcblxuICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCk7XG4gICAgICAgIC8vIGRyYXcgdGhlIGJhY2tncm91bmRcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCk7XG5cbiAgICAgICAgLy9kcmF3IGRhc2hlZCBib3JkZXIgaWYgZW5hYmxlZCwgc2F2ZSBhbmQgcmVzdG9yZSBpcyByZXF1aXJlZCBmb3IgZmlyZWZveCBub3QgdG8gY3Jhc2ggb24gdW5peC5cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgLy8gaWYgYm9yZGVycyBhcmUgemVybyB3aWR0aCwgdGhleSB3aWxsIGJlIGRyYXduIHdpdGggd2lkdGggMSBieSBkZWZhdWx0LiBUaGlzIHByZXZlbnRzIHRoYXRcbiAgICAgICAgaWYgKGJvcmRlcldpZHRoID4gMCkge1xuICAgICAgICAgIHRoaXMuZW5hYmxlQm9yZGVyRGFzaGVzKGN0eCk7XG4gICAgICAgICAgLy9kcmF3IHRoZSBib3JkZXJcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgLy9kaXNhYmxlIGRhc2hlZCBib3JkZXIgZm9yIG90aGVyIGVsZW1lbnRzXG4gICAgICAgICAgdGhpcy5kaXNhYmxlQm9yZGVyRGFzaGVzKGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgeUxhYmVsID0geSArIDAuNSAqIHRoaXMuaGVpZ2h0ICsgMzsgLy8gdGhlICsgMyBpcyB0byBvZmZzZXQgaXQgYSBiaXQgYmVsb3cgdGhlIG5vZGUuXG4gICAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgeCwgeUxhYmVsLCBzZWxlY3RlZCwgJ2hhbmdpbmcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAndXBkYXRlQm91bmRpbmdCb3gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpIHtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB5IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IHggLSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IHggKyB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB5ICsgdGhpcy5vcHRpb25zLnNpemU7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkICYmIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSBNYXRoLm1pbih0aGlzLmJvdW5kaW5nQm94LmxlZnQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0KTtcbiAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5yaWdodCwgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQgKyB0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGgpO1xuICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5ib3R0b20sIHRoaXMuYm91bmRpbmdCb3guYm90dG9tICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmhlaWdodCArIDMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFNoYXBlQmFzZTtcbiAgfShfTm9kZUJhc2UzLmRlZmF1bHQpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IFNoYXBlQmFzZTtcblxuLyoqKi8gfSxcbi8qIDc3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX1NoYXBlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KTtcblxuICB2YXIgX1NoYXBlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaGFwZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIERvdCA9IGZ1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gICAgX2luaGVyaXRzKERvdCwgX1NoYXBlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBEb3Qob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEb3QpO1xuXG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKERvdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERvdCkpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRG90LCBbe1xuICAgICAga2V5OiAncmVzaXplJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZVNoYXBlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgICB0aGlzLl9kcmF3U2hhcGUoY3R4LCAnY2lyY2xlJywgMiwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBEb3Q7XG4gIH0oX1NoYXBlQmFzZTMuZGVmYXVsdCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gRG90O1xuXG4vKioqLyB9LFxuLyogNzggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfTm9kZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MCk7XG5cbiAgdmFyIF9Ob2RlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Ob2RlQmFzZTIpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuICB2YXIgRWxsaXBzZSA9IGZ1bmN0aW9uIChfTm9kZUJhc2UpIHtcbiAgICBfaW5oZXJpdHMoRWxsaXBzZSwgX05vZGVCYXNlKTtcblxuICAgIGZ1bmN0aW9uIEVsbGlwc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbGxpcHNlKTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChFbGxpcHNlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRWxsaXBzZSkpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRWxsaXBzZSwgW3tcbiAgICAgIGtleTogJ3Jlc2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCwgc2VsZWN0ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciB0ZXh0U2l6ZSA9IHRoaXMubGFiZWxNb2R1bGUuZ2V0VGV4dFNpemUoY3R4LCBzZWxlY3RlZCk7XG5cbiAgICAgICAgICB0aGlzLmhlaWdodCA9IHRleHRTaXplLmhlaWdodCAqIDI7XG4gICAgICAgICAgdGhpcy53aWR0aCA9IHRleHRTaXplLndpZHRoICsgdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggKiAwLjU7XG4gICAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0ICogMC41O1xuXG4gICAgICAgIHZhciBuZXV0cmFsYm9yZGVyV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICAgIHZhciBzZWxlY3Rpb25MaW5lV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGhTZWxlY3RlZCB8fCAyICogdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgICB2YXIgYm9yZGVyV2lkdGggPSAoc2VsZWN0ZWQgPyBzZWxlY3Rpb25MaW5lV2lkdGggOiBuZXV0cmFsYm9yZGVyV2lkdGgpIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBNYXRoLm1pbih0aGlzLndpZHRoLCBib3JkZXJXaWR0aCk7XG5cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc2VsZWN0ZWQgPyB0aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlciA6IGhvdmVyID8gdGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyLmJvcmRlciA6IHRoaXMub3B0aW9ucy5jb2xvci5ib3JkZXI7XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHNlbGVjdGVkID8gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5iYWNrZ3JvdW5kIDogaG92ZXIgPyB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYmFja2dyb3VuZCA6IHRoaXMub3B0aW9ucy5jb2xvci5iYWNrZ3JvdW5kO1xuICAgICAgICBjdHguZWxsaXBzZSh0aGlzLmxlZnQsIHRoaXMudG9wLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cbiAgICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgpO1xuICAgICAgICAvLyBkcmF3IHRoZSBiYWNrZ3JvdW5kXG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG4gICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgpO1xuXG4gICAgICAgIC8vZHJhdyBkYXNoZWQgYm9yZGVyIGlmIGVuYWJsZWQsIHNhdmUgYW5kIHJlc3RvcmUgaXMgcmVxdWlyZWQgZm9yIGZpcmVmb3ggbm90IHRvIGNyYXNoIG9uIHVuaXguXG4gICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgLy8gaWYgYm9yZGVycyBhcmUgemVybyB3aWR0aCwgdGhleSB3aWxsIGJlIGRyYXduIHdpdGggd2lkdGggMSBieSBkZWZhdWx0LiBUaGlzIHByZXZlbnRzIHRoYXRcbiAgICAgICAgaWYgKGJvcmRlcldpZHRoID4gMCkge1xuICAgICAgICAgIHRoaXMuZW5hYmxlQm9yZGVyRGFzaGVzKGN0eCk7XG4gICAgICAgICAgLy9kcmF3IHRoZSBib3JkZXJcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgLy9kaXNhYmxlIGRhc2hlZCBib3JkZXIgZm9yIG90aGVyIGVsZW1lbnRzXG4gICAgICAgICAgdGhpcy5kaXNhYmxlQm9yZGVyRGFzaGVzKGN0eCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCk7XG4gICAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVCb3VuZGluZ0JveCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkKTsgLy8ganVzdCBpbiBjYXNlXG5cbiAgICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggKiAwLjU7XG4gICAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0ICogMC41O1xuXG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IHRoaXMubGVmdDtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0gdGhpcy5sZWZ0ICsgdGhpcy53aWR0aDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4KTtcbiAgICAgICAgdmFyIGEgPSB0aGlzLndpZHRoICogMC41O1xuICAgICAgICB2YXIgYiA9IHRoaXMuaGVpZ2h0ICogMC41O1xuICAgICAgICB2YXIgdyA9IE1hdGguc2luKGFuZ2xlKSAqIGE7XG4gICAgICAgIHZhciBoID0gTWF0aC5jb3MoYW5nbGUpICogYjtcbiAgICAgICAgcmV0dXJuIGEgKiBiIC8gTWF0aC5zcXJ0KHcgKiB3ICsgaCAqIGgpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBFbGxpcHNlO1xuICB9KF9Ob2RlQmFzZTMuZGVmYXVsdCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gRWxsaXBzZTtcblxuLyoqKi8gfSxcbi8qIDc5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX05vZGVCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzApO1xuXG4gIHZhciBfTm9kZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTm9kZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIEljb24gPSBmdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gICAgX2luaGVyaXRzKEljb24sIF9Ob2RlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBJY29uKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSWNvbik7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoSWNvbi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEljb24pKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEljb24sIFt7XG4gICAgICBrZXk6ICdyZXNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBtYXJnaW4gPSA1O1xuICAgICAgICAgIHZhciBpY29uU2l6ZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBOdW1iZXIodGhpcy5vcHRpb25zLmljb24uc2l6ZSksXG4gICAgICAgICAgICBoZWlnaHQ6IE51bWJlcih0aGlzLm9wdGlvbnMuaWNvbi5zaXplKVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy53aWR0aCA9IGljb25TaXplLndpZHRoICsgMiAqIG1hcmdpbjtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IGljb25TaXplLmhlaWdodCArIDIgKiBtYXJnaW47XG4gICAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgpO1xuICAgICAgICB0aGlzLm9wdGlvbnMuaWNvbi5zaXplID0gdGhpcy5vcHRpb25zLmljb24uc2l6ZSB8fCA1MDtcblxuICAgICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAqIDAuNTtcbiAgICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgKiAwLjU7XG4gICAgICAgIHRoaXMuX2ljb24oY3R4LCB4LCB5LCBzZWxlY3RlZCk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGljb25UZXh0U3BhY2luZyA9IDU7XG4gICAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgeCwgeSArIHRoaXMuaGVpZ2h0ICogMC41ICsgaWNvblRleHRTcGFjaW5nLCBzZWxlY3RlZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3VwZGF0ZUJvdW5kaW5nQm94JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5KSB7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0geSAtIHRoaXMub3B0aW9ucy5pY29uLnNpemUgKiAwLjU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IHggLSB0aGlzLm9wdGlvbnMuaWNvbi5zaXplICogMC41O1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0geCArIHRoaXMub3B0aW9ucy5pY29uLnNpemUgKiAwLjU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0geSArIHRoaXMub3B0aW9ucy5pY29uLnNpemUgKiAwLjU7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkICYmIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCA+IDApIHtcbiAgICAgICAgICB2YXIgaWNvblRleHRTcGFjaW5nID0gNTtcbiAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSBNYXRoLm1pbih0aGlzLmJvdW5kaW5nQm94LmxlZnQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0KTtcbiAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5yaWdodCwgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQgKyB0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGgpO1xuICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5ib3R0b20sIHRoaXMuYm91bmRpbmdCb3guYm90dG9tICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmhlaWdodCArIGljb25UZXh0U3BhY2luZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfaWNvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ljb24oY3R4LCB4LCB5LCBzZWxlY3RlZCkge1xuICAgICAgICB2YXIgaWNvblNpemUgPSBOdW1iZXIodGhpcy5vcHRpb25zLmljb24uc2l6ZSk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pY29uLmNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGN0eC5mb250ID0gKHNlbGVjdGVkID8gXCJib2xkIFwiIDogXCJcIikgKyBpY29uU2l6ZSArIFwicHggXCIgKyB0aGlzLm9wdGlvbnMuaWNvbi5mYWNlO1xuXG4gICAgICAgICAgLy8gZHJhdyBpY29uXG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMub3B0aW9ucy5pY29uLmNvbG9yIHx8IFwiYmxhY2tcIjtcbiAgICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcblxuICAgICAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgpO1xuICAgICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLm9wdGlvbnMuaWNvbi5jb2RlLCB4LCB5KTtcblxuICAgICAgICAgIC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG4gICAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignV2hlbiB1c2luZyB0aGUgaWNvbiBzaGFwZSwgeW91IG5lZWQgdG8gZGVmaW5lIHRoZSBjb2RlIGluIHRoZSBpY29uIG9wdGlvbnMgb2JqZWN0LiBUaGlzIGNhbiBiZSBkb25lIHBlciBub2RlIG9yIGdsb2JhbGx5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGlzdGFuY2VUb0JvcmRlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBJY29uO1xuICB9KF9Ob2RlQmFzZTMuZGVmYXVsdCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gSWNvbjtcblxuLyoqKi8gfSxcbi8qIDgwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX0NpcmNsZUltYWdlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcblxuICB2YXIgX0NpcmNsZUltYWdlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DaXJjbGVJbWFnZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIEltYWdlID0gZnVuY3Rpb24gKF9DaXJjbGVJbWFnZUJhc2UpIHtcbiAgICBfaW5oZXJpdHMoSW1hZ2UsIF9DaXJjbGVJbWFnZUJhc2UpO1xuXG4gICAgZnVuY3Rpb24gSW1hZ2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUsIGltYWdlT2JqKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW1hZ2UpO1xuXG4gICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoSW1hZ2UuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJbWFnZSkpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcblxuICAgICAgX3RoaXMuaW1hZ2VPYmogPSBpbWFnZU9iajtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoSW1hZ2UsIFt7XG4gICAgICBrZXk6ICdyZXNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZSgpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplSW1hZ2UoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkcmF3JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLnVzZUJvcmRlcldpdGhJbWFnZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBuZXV0cmFsYm9yZGVyV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICAgICAgdmFyIHNlbGVjdGlvbkxpbmVXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aFNlbGVjdGVkIHx8IDIgKiB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICAgICAgdmFyIGJvcmRlcldpZHRoID0gKHNlbGVjdGVkID8gc2VsZWN0aW9uTGluZVdpZHRoIDogbmV1dHJhbGJvcmRlcldpZHRoKSAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBNYXRoLm1pbih0aGlzLndpZHRoLCBib3JkZXJXaWR0aCk7XG5cbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAvLyBzZXR1cCB0aGUgbGluZSBwcm9wZXJ0aWVzLlxuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHNlbGVjdGVkID8gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5ib3JkZXIgOiBob3ZlciA/IHRoaXMub3B0aW9ucy5jb2xvci5ob3Zlci5ib3JkZXIgOiB0aGlzLm9wdGlvbnMuY29sb3IuYm9yZGVyO1xuXG4gICAgICAgICAgLy8gc2V0IGEgZmlsbHN0eWxlXG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHNlbGVjdGVkID8gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5iYWNrZ3JvdW5kIDogaG92ZXIgPyB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYmFja2dyb3VuZCA6IHRoaXMub3B0aW9ucy5jb2xvci5iYWNrZ3JvdW5kO1xuXG4gICAgICAgICAgLy8gZHJhdyBhIHJlY3RhbmdsZSB0byBmb3JtIHRoZSBib3JkZXIgYXJvdW5kLiBUaGlzIHJlY3RhbmdsZSBpcyBmaWxsZWQgc28gdGhlIG9wYWNpdHkgb2YgYSBwaWN0dXJlIChpbiBmdXR1cmUgdmlzIHJlbGVhc2VzPykgY2FuIGJlIHVzZWQgdG8gdGludCB0aGUgaW1hZ2VcbiAgICAgICAgICBjdHgucmVjdCh0aGlzLmxlZnQgLSAwLjUgKiBjdHgubGluZVdpZHRoLCB0aGlzLnRvcCAtIDAuNSAqIGN0eC5saW5lV2lkdGgsIHRoaXMud2lkdGggKyBjdHgubGluZVdpZHRoLCB0aGlzLmhlaWdodCArIGN0eC5saW5lV2lkdGgpO1xuICAgICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgICAvL2RyYXcgZGFzaGVkIGJvcmRlciBpZiBlbmFibGVkLCBzYXZlIGFuZCByZXN0b3JlIGlzIHJlcXVpcmVkIGZvciBmaXJlZm94IG5vdCB0byBjcmFzaCBvbiB1bml4LlxuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgLy8gaWYgYm9yZGVycyBhcmUgemVybyB3aWR0aCwgdGhleSB3aWxsIGJlIGRyYXduIHdpdGggd2lkdGggMSBieSBkZWZhdWx0LiBUaGlzIHByZXZlbnRzIHRoYXRcbiAgICAgICAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZUJvcmRlckRhc2hlcyhjdHgpO1xuICAgICAgICAgICAgLy9kcmF3IHRoZSBib3JkZXJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIC8vZGlzYWJsZSBkYXNoZWQgYm9yZGVyIGZvciBvdGhlciBlbGVtZW50c1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlQm9yZGVyRGFzaGVzKGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kcmF3SW1hZ2VBdFBvc2l0aW9uKGN0eCk7XG5cbiAgICAgICAgdGhpcy5fZHJhd0ltYWdlTGFiZWwoY3R4LCB4LCB5LCBzZWxlY3RlZCB8fCBob3Zlcik7XG5cbiAgICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVCb3VuZGluZ0JveCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSkge1xuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCA9IHRoaXMudG9wO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB0aGlzLmxlZnQgKyB0aGlzLndpZHRoO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IHRoaXMudG9wICsgdGhpcy5oZWlnaHQ7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkICYmIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSBNYXRoLm1pbih0aGlzLmJvdW5kaW5nQm94LmxlZnQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0KTtcbiAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5yaWdodCwgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQgKyB0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGgpO1xuICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5ib3R0b20sIHRoaXMuYm91bmRpbmdCb3guYm90dG9tICsgdGhpcy5sYWJlbE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEltYWdlO1xuICB9KF9DaXJjbGVJbWFnZUJhc2UzLmRlZmF1bHQpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IEltYWdlO1xuXG4vKioqLyB9LFxuLyogODEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfU2hhcGVCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzYpO1xuXG4gIHZhciBfU2hhcGVCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NoYXBlQmFzZTIpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuICB2YXIgU3F1YXJlID0gZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgICBfaW5oZXJpdHMoU3F1YXJlLCBfU2hhcGVCYXNlKTtcblxuICAgIGZ1bmN0aW9uIFNxdWFyZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNxdWFyZSk7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU3F1YXJlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3F1YXJlKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhTcXVhcmUsIFt7XG4gICAgICBrZXk6ICdyZXNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZSgpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplU2hhcGUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkcmF3JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICAgIHRoaXMuX2RyYXdTaGFwZShjdHgsICdzcXVhcmUnLCAyLCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gU3F1YXJlO1xuICB9KF9TaGFwZUJhc2UzLmRlZmF1bHQpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IFNxdWFyZTtcblxuLyoqKi8gfSxcbi8qIDgyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX1NoYXBlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KTtcblxuICB2YXIgX1NoYXBlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaGFwZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIFN0YXIgPSBmdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICAgIF9pbmhlcml0cyhTdGFyLCBfU2hhcGVCYXNlKTtcblxuICAgIGZ1bmN0aW9uIFN0YXIob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGFyKTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTdGFyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3RhcikpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU3RhciwgW3tcbiAgICAgIGtleTogJ3Jlc2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCkge1xuICAgICAgICB0aGlzLl9yZXNpemVTaGFwZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RyYXcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgICAgdGhpcy5fZHJhd1NoYXBlKGN0eCwgJ3N0YXInLCA0LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gU3RhcjtcbiAgfShfU2hhcGVCYXNlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBTdGFyO1xuXG4vKioqLyB9LFxuLyogODMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfTm9kZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MCk7XG5cbiAgdmFyIF9Ob2RlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Ob2RlQmFzZTIpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuICB2YXIgVGV4dCA9IGZ1bmN0aW9uIChfTm9kZUJhc2UpIHtcbiAgICBfaW5oZXJpdHMoVGV4dCwgX05vZGVCYXNlKTtcblxuICAgIGZ1bmN0aW9uIFRleHQob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0KTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChUZXh0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGV4dCkpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoVGV4dCwgW3tcbiAgICAgIGtleTogJ3Jlc2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCwgc2VsZWN0ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBtYXJnaW4gPSA1O1xuICAgICAgICAgIHZhciB0ZXh0U2l6ZSA9IHRoaXMubGFiZWxNb2R1bGUuZ2V0VGV4dFNpemUoY3R4LCBzZWxlY3RlZCk7XG4gICAgICAgICAgdGhpcy53aWR0aCA9IHRleHRTaXplLndpZHRoICsgMiAqIG1hcmdpbjtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IHRleHRTaXplLmhlaWdodCArIDIgKiBtYXJnaW47XG4gICAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkIHx8IGhvdmVyKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgpO1xuICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCB8fCBob3Zlcik7XG5cbiAgICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVCb3VuZGluZ0JveCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkKTtcblxuICAgICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCA9IHRoaXMudG9wO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB0aGlzLmxlZnQgKyB0aGlzLndpZHRoO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IHRoaXMudG9wICsgdGhpcy5oZWlnaHQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGlzdGFuY2VUb0JvcmRlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUZXh0O1xuICB9KF9Ob2RlQmFzZTMuZGVmYXVsdCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gVGV4dDtcblxuLyoqKi8gfSxcbi8qIDg0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX1NoYXBlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KTtcblxuICB2YXIgX1NoYXBlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaGFwZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIFRyaWFuZ2xlID0gZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgICBfaW5oZXJpdHMoVHJpYW5nbGUsIF9TaGFwZUJhc2UpO1xuXG4gICAgZnVuY3Rpb24gVHJpYW5nbGUob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmlhbmdsZSk7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVHJpYW5nbGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUcmlhbmdsZSkpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoVHJpYW5nbGUsIFt7XG4gICAgICBrZXk6ICdyZXNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplU2hhcGUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkcmF3JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICAgIHRoaXMuX2RyYXdTaGFwZShjdHgsICd0cmlhbmdsZScsIDMsIHgsIHksIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGlzdGFuY2VUb0JvcmRlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUcmlhbmdsZTtcbiAgfShfU2hhcGVCYXNlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBUcmlhbmdsZTtcblxuLyoqKi8gfSxcbi8qIDg1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX1NoYXBlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KTtcblxuICB2YXIgX1NoYXBlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaGFwZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIFRyaWFuZ2xlRG93biA9IGZ1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gICAgX2luaGVyaXRzKFRyaWFuZ2xlRG93biwgX1NoYXBlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBUcmlhbmdsZURvd24ob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmlhbmdsZURvd24pO1xuXG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFRyaWFuZ2xlRG93bi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRyaWFuZ2xlRG93bikpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoVHJpYW5nbGVEb3duLCBbe1xuICAgICAga2V5OiAncmVzaXplJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZVNoYXBlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgICB0aGlzLl9kcmF3U2hhcGUoY3R4LCAndHJpYW5nbGVEb3duJywgMywgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRyaWFuZ2xlRG93bjtcbiAgfShfU2hhcGVCYXNlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBUcmlhbmdsZURvd247XG5cbi8qKiovIH0sXG4vKiA4NiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9FZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Nyk7XG5cbiAgdmFyIF9FZGdlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0VkZ2UpO1xuXG4gIHZhciBfTGFiZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcblxuICB2YXIgX0xhYmVsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xhYmVsKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuICB2YXIgRGF0YVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG4gIHZhciBEYXRhVmlldyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG4gIHZhciBFZGdlc0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWRnZXNIYW5kbGVyKGJvZHksIGltYWdlcywgZ3JvdXBzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWRnZXNIYW5kbGVyKTtcblxuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMuaW1hZ2VzID0gaW1hZ2VzO1xuICAgICAgdGhpcy5ncm91cHMgPSBncm91cHM7XG5cbiAgICAgIC8vIGNyZWF0ZSB0aGUgZWRnZSBBUEkgaW4gdGhlIGJvZHkgY29udGFpbmVyXG4gICAgICB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZUVkZ2UgPSB0aGlzLmNyZWF0ZS5iaW5kKHRoaXMpO1xuXG4gICAgICB0aGlzLmVkZ2VzTGlzdGVuZXJzID0ge1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIGFkZChldmVudCwgcGFyYW1zKSB7XG4gICAgICAgICAgX3RoaXMuYWRkKHBhcmFtcy5pdGVtcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgICBfdGhpcy51cGRhdGUocGFyYW1zLml0ZW1zKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICAgIF90aGlzLnJlbW92ZShwYXJhbXMuaXRlbXMpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIGFycm93czoge1xuICAgICAgICAgIHRvOiB7IGVuYWJsZWQ6IGZhbHNlLCBzY2FsZUZhY3RvcjogMSwgdHlwZTogJ2Fycm93JyB9LCAvLyBib29sZWFuIC8ge2Fycm93U2NhbGVGYWN0b3I6MX0gLyB7ZW5hYmxlZDogZmFsc2UsIGFycm93U2NhbGVGYWN0b3I6MX1cbiAgICAgICAgICBtaWRkbGU6IHsgZW5hYmxlZDogZmFsc2UsIHNjYWxlRmFjdG9yOiAxLCB0eXBlOiAnYXJyb3cnIH0sXG4gICAgICAgICAgZnJvbTogeyBlbmFibGVkOiBmYWxzZSwgc2NhbGVGYWN0b3I6IDEsIHR5cGU6ICdhcnJvdycgfVxuICAgICAgICB9LFxuICAgICAgICBhcnJvd1N0cmlrZXRocm91Z2g6IHRydWUsXG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgY29sb3I6ICcjODQ4NDg0JyxcbiAgICAgICAgICBoaWdobGlnaHQ6ICcjODQ4NDg0JyxcbiAgICAgICAgICBob3ZlcjogJyM4NDg0ODQnLFxuICAgICAgICAgIGluaGVyaXQ6ICdmcm9tJyxcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSxcbiAgICAgICAgZGFzaGVzOiBmYWxzZSxcbiAgICAgICAgZm9udDoge1xuICAgICAgICAgIGNvbG9yOiAnIzM0MzQzNCcsXG4gICAgICAgICAgc2l6ZTogMTQsIC8vIHB4XG4gICAgICAgICAgZmFjZTogJ2FyaWFsJyxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAnbm9uZScsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDIsIC8vIHB4XG4gICAgICAgICAgc3Ryb2tlQ29sb3I6ICcjZmZmZmZmJyxcbiAgICAgICAgICBhbGlnbjogJ2hvcml6b250YWwnXG4gICAgICAgIH0sXG4gICAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICAgIGhvdmVyV2lkdGg6IDEuNSxcbiAgICAgICAgbGFiZWw6IHVuZGVmaW5lZCxcbiAgICAgICAgbGFiZWxIaWdobGlnaHRCb2xkOiB0cnVlLFxuICAgICAgICBsZW5ndGg6IHVuZGVmaW5lZCxcbiAgICAgICAgcGh5c2ljczogdHJ1ZSxcbiAgICAgICAgc2NhbGluZzoge1xuICAgICAgICAgIG1pbjogMSxcbiAgICAgICAgICBtYXg6IDE1LFxuICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgbWluOiAxNCxcbiAgICAgICAgICAgIG1heDogMzAsXG4gICAgICAgICAgICBtYXhWaXNpYmxlOiAzMCxcbiAgICAgICAgICAgIGRyYXdUaHJlc2hvbGQ6IDVcbiAgICAgICAgICB9LFxuICAgICAgICAgIGN1c3RvbVNjYWxpbmdGdW5jdGlvbjogZnVuY3Rpb24gY3VzdG9tU2NhbGluZ0Z1bmN0aW9uKG1pbiwgbWF4LCB0b3RhbCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgICAgICAgICByZXR1cm4gMC41O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHNjYWxlID0gMSAvIChtYXggLSBtaW4pO1xuICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgKHZhbHVlIC0gbWluKSAqIHNjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdGlvbldpZHRoOiAxLjUsXG4gICAgICAgIHNlbGZSZWZlcmVuY2VTaXplOiAyMCxcbiAgICAgICAgc2hhZG93OiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgY29sb3I6ICdyZ2JhKDAsMCwwLDAuNSknLFxuICAgICAgICAgIHNpemU6IDEwLFxuICAgICAgICAgIHg6IDUsXG4gICAgICAgICAgeTogNVxuICAgICAgICB9LFxuICAgICAgICBzbW9vdGg6IHtcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgIHR5cGU6IFwiZHluYW1pY1wiLFxuICAgICAgICAgIGZvcmNlRGlyZWN0aW9uOiAnbm9uZScsXG4gICAgICAgICAgcm91bmRuZXNzOiAwLjVcbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGU6IHVuZGVmaW5lZCxcbiAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgIH07XG5cbiAgICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEVkZ2VzSGFuZGxlciwgW3tcbiAgICAgIGtleTogJ2JpbmRFdmVudExpc3RlbmVycycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAvLyB0aGlzIGFsbG93cyBleHRlcm5hbCBtb2R1bGVzIHRvIGZvcmNlIGFsbCBkeW5hbWljIGN1cnZlcyB0byB0dXJuIHN0YXRpYy5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZm9yY2VEaXNhYmxlRHluYW1pY0N1cnZlc1wiLCBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSAnZHluYW1pYycpIHtcbiAgICAgICAgICAgIHR5cGUgPSAnY29udGludW91cyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbWl0Q2hhbmdlID0gZmFsc2U7XG4gICAgICAgICAgZm9yICh2YXIgZWRnZUlkIGluIF90aGlzMi5ib2R5LmVkZ2VzKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMyLmJvZHkuZWRnZXMuaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgICAgICB2YXIgZWRnZSA9IF90aGlzMi5ib2R5LmVkZ2VzW2VkZ2VJZF07XG4gICAgICAgICAgICAgIHZhciBlZGdlRGF0YSA9IF90aGlzMi5ib2R5LmRhdGEuZWRnZXMuX2RhdGFbZWRnZUlkXTtcblxuICAgICAgICAgICAgICAvLyBvbmx5IGZvcmNpYmx5IHJlbW92ZSB0aGUgc21vb3RoIGN1cnZlIGlmIHRoZSBkYXRhIGhhcyBiZWVuIHNldCBvZiB0aGUgZWRnZSBoYXMgdGhlIHNtb290aCBjdXJ2ZXMgZGVmaW5lZC5cbiAgICAgICAgICAgICAgLy8gdGhpcyBpcyBiZWNhdXNlIGEgY2hhbmdlIGluIHRoZSBnbG9iYWwgd291bGQgbm90IGFmZmVjdCB0aGVzZSBjdXJ2ZXMuXG4gICAgICAgICAgICAgIGlmIChlZGdlRGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVkZ2VPcHRpb25zID0gZWRnZURhdGEuc21vb3RoO1xuICAgICAgICAgICAgICAgIGlmIChlZGdlT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZWRnZU9wdGlvbnMuZW5hYmxlZCA9PT0gdHJ1ZSAmJiBlZGdlT3B0aW9ucy50eXBlID09PSAnZHluYW1pYycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgIGVkZ2Uuc2V0T3B0aW9ucyh7IHNtb290aDogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgZWRnZS5zZXRPcHRpb25zKHsgc21vb3RoOiB7IHR5cGU6IHR5cGUgfSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbWl0Q2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVtaXRDaGFuZ2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF90aGlzMi5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRoaXMgaXMgY2FsbGVkIHdoZW4gb3B0aW9ucyBvZiBFWElTVElORyBub2RlcyBvciBlZGdlcyBoYXZlIGNoYW5nZWQuXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFVcGRhdGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIucmVjb25uZWN0RWRnZXMoKTtcbiAgICAgICAgICBfdGhpczIubWFya0FsbEVkZ2VzQXNEaXJ0eSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyByZWZyZXNoIHRoZSBlZGdlcy4gVXNlZCB3aGVuIHJldmVydGluZyBmcm9tIGhpZXJhcmNoaWNhbCBsYXlvdXRcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJyZWZyZXNoRWRnZXNcIiwgdGhpcy5yZWZyZXNoLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInJlZnJlc2hcIiwgdGhpcy5yZWZyZXNoLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHV0aWwuZm9yRWFjaChfdGhpczIuZWRnZXNMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChfdGhpczIuYm9keS5kYXRhLmVkZ2VzKSBfdGhpczIuYm9keS5kYXRhLmVkZ2VzLm9mZihldmVudCwgY2FsbGJhY2spO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRlbGV0ZSBfdGhpczIuYm9keS5mdW5jdGlvbnMuY3JlYXRlRWRnZTtcbiAgICAgICAgICBkZWxldGUgX3RoaXMyLmVkZ2VzTGlzdGVuZXJzLmFkZDtcbiAgICAgICAgICBkZWxldGUgX3RoaXMyLmVkZ2VzTGlzdGVuZXJzLnVwZGF0ZTtcbiAgICAgICAgICBkZWxldGUgX3RoaXMyLmVkZ2VzTGlzdGVuZXJzLnJlbW92ZTtcbiAgICAgICAgICBkZWxldGUgX3RoaXMyLmVkZ2VzTGlzdGVuZXJzO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHVzZSB0aGUgcGFyc2VyIGZyb20gdGhlIEVkZ2UgY2xhc3MgdG8gZmlsbCBpbiBhbGwgc2hvcnRoYW5kIG5vdGF0aW9uc1xuICAgICAgICAgIF9FZGdlMi5kZWZhdWx0LnBhcnNlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgLy8gaGFuZGxlIG11bHRpcGxlIGlucHV0IGNhc2VzIGZvciBjb2xvclxuICAgICAgICAgIGlmIChvcHRpb25zLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubWFya0FsbEVkZ2VzQXNEaXJ0eSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHVwZGF0ZSBzbW9vdGggc2V0dGluZ3MgaW4gYWxsIGVkZ2VzXG4gICAgICAgICAgdmFyIGRhdGFDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuc21vb3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLmJvZHkuZWRnZXMpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5lZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgICAgICAgZGF0YUNoYW5nZWQgPSB0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXS51cGRhdGVFZGdlVHlwZSgpIHx8IGRhdGFDaGFuZ2VkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdXBkYXRlIGZvbnRzIGluIGFsbCBlZGdlc1xuICAgICAgICAgIGlmIChvcHRpb25zLmZvbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gdXNlIHRoZSBwYXJzZXIgZnJvbSB0aGUgTGFiZWwgY2xhc3MgdG8gZmlsbCBpbiBhbGwgc2hvcnRoYW5kIG5vdGF0aW9uc1xuICAgICAgICAgICAgX0xhYmVsMi5kZWZhdWx0LnBhcnNlT3B0aW9ucyh0aGlzLm9wdGlvbnMuZm9udCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBmb3IgKHZhciBfZWRnZUlkIGluIHRoaXMuYm9keS5lZGdlcykge1xuICAgICAgICAgICAgICBpZiAodGhpcy5ib2R5LmVkZ2VzLmhhc093blByb3BlcnR5KF9lZGdlSWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5LmVkZ2VzW19lZGdlSWRdLnVwZGF0ZUxhYmVsTW9kdWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB1cGRhdGUgdGhlIHN0YXRlIG9mIHRoZSB2YXJpYWJsZXMgaWYgbmVlZGVkXG4gICAgICAgICAgaWYgKG9wdGlvbnMuaGlkZGVuICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5waHlzaWNzICE9PSB1bmRlZmluZWQgfHwgZGF0YUNoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19kYXRhQ2hhbmdlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIExvYWQgZWRnZXMgYnkgcmVhZGluZyB0aGUgZGF0YSB0YWJsZVxuICAgICAgICogQHBhcmFtIHtBcnJheSB8IERhdGFTZXQgfCBEYXRhVmlld30gZWRnZXMgICAgVGhlIGRhdGEgY29udGFpbmluZyB0aGUgZWRnZXMuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0RGF0YScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGF0YShlZGdlcykge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICB2YXIgZG9Ob3RFbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgICB2YXIgb2xkRWRnZXNEYXRhID0gdGhpcy5ib2R5LmRhdGEuZWRnZXM7XG5cbiAgICAgICAgaWYgKGVkZ2VzIGluc3RhbmNlb2YgRGF0YVNldCB8fCBlZGdlcyBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMgPSBlZGdlcztcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGVkZ2VzKSkge1xuICAgICAgICAgIHRoaXMuYm9keS5kYXRhLmVkZ2VzID0gbmV3IERhdGFTZXQoKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZGF0YS5lZGdlcy5hZGQoZWRnZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKCFlZGdlcykge1xuICAgICAgICAgIHRoaXMuYm9keS5kYXRhLmVkZ2VzID0gbmV3IERhdGFTZXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheSBvciBEYXRhU2V0IGV4cGVjdGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBpcyB0aGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIGZhbHNlP1xuICAgICAgICBpZiAob2xkRWRnZXNEYXRhKSB7XG4gICAgICAgICAgLy8gdW5zdWJzY3JpYmUgZnJvbSBvbGQgZGF0YXNldFxuICAgICAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLmVkZ2VzTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgICBvbGRFZGdlc0RhdGEub2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgZHJhd24gZWRnZXNcbiAgICAgICAgdGhpcy5ib2R5LmVkZ2VzID0ge307XG5cbiAgICAgICAgLy8gVE9ETzogaXMgdGhpcyBudWxsIG9yIHVuZGVmaW5lZCBvciBmYWxzZT9cbiAgICAgICAgaWYgKHRoaXMuYm9keS5kYXRhLmVkZ2VzKSB7XG4gICAgICAgICAgLy8gc3Vic2NyaWJlIHRvIG5ldyBkYXRhc2V0XG4gICAgICAgICAgdXRpbC5mb3JFYWNoKHRoaXMuZWRnZXNMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzMy5ib2R5LmRhdGEuZWRnZXMub24oZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIGRyYXcgYWxsIG5ldyBub2Rlc1xuICAgICAgICAgIHZhciBpZHMgPSB0aGlzLmJvZHkuZGF0YS5lZGdlcy5nZXRJZHMoKTtcbiAgICAgICAgICB0aGlzLmFkZChpZHMsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvTm90RW1pdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkIGVkZ2VzXG4gICAgICAgKiBAcGFyYW0ge051bWJlcltdIHwgU3RyaW5nW119IGlkc1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnYWRkJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoaWRzKSB7XG4gICAgICAgIHZhciBkb05vdEVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgICAgdmFyIGVkZ2VzRGF0YSA9IHRoaXMuYm9keS5kYXRhLmVkZ2VzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGlkID0gaWRzW2ldO1xuXG4gICAgICAgICAgdmFyIG9sZEVkZ2UgPSBlZGdlc1tpZF07XG4gICAgICAgICAgaWYgKG9sZEVkZ2UpIHtcbiAgICAgICAgICAgIG9sZEVkZ2UuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkYXRhID0gZWRnZXNEYXRhLmdldChpZCwgeyBcInNob3dJbnRlcm5hbElkc1wiOiB0cnVlIH0pO1xuICAgICAgICAgIGVkZ2VzW2lkXSA9IHRoaXMuY3JlYXRlKGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvTm90RW1pdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVXBkYXRlIGV4aXN0aW5nIGVkZ2VzLCBvciBjcmVhdGUgdGhlbSB3aGVuIG5vdCB5ZXQgZXhpc3RpbmdcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyW10gfCBTdHJpbmdbXX0gaWRzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShpZHMpIHtcbiAgICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgICB2YXIgZWRnZXNEYXRhID0gdGhpcy5ib2R5LmRhdGEuZWRnZXM7XG4gICAgICAgIHZhciBkYXRhQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgICB2YXIgZGF0YSA9IGVkZ2VzRGF0YS5nZXQoaWQpO1xuICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNbaWRdO1xuICAgICAgICAgIGlmIChlZGdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBlZGdlXG4gICAgICAgICAgICBlZGdlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGRhdGFDaGFuZ2VkID0gZWRnZS5zZXRPcHRpb25zKGRhdGEpIHx8IGRhdGFDaGFuZ2VkOyAvLyBpZiBhIHN1cHBvcnQgbm9kZSBpcyBhZGRlZCwgZGF0YSBjYW4gYmUgY2hhbmdlZC5cbiAgICAgICAgICAgIGVkZ2UuY29ubmVjdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgZWRnZVxuICAgICAgICAgICAgdGhpcy5ib2R5LmVkZ2VzW2lkXSA9IHRoaXMuY3JlYXRlKGRhdGEpO1xuICAgICAgICAgICAgZGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhVXBkYXRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBleGlzdGluZyBlZGdlcy4gTm9uIGV4aXN0aW5nIGlkcyB3aWxsIGJlIGlnbm9yZWRcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyW10gfCBTdHJpbmdbXX0gaWRzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZW1vdmUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShpZHMpIHtcbiAgICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2lkXTtcbiAgICAgICAgICBpZiAoZWRnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlZGdlLmNsZWFudXAoKTtcbiAgICAgICAgICAgIGVkZ2UuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgZGVsZXRlIGVkZ2VzW2lkXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlZnJlc2gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgICAgZm9yICh2YXIgZWRnZUlkIGluIGVkZ2VzKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKGVkZ2VzLmhhc093blByb3BlcnR5KGVkZ2VJZCkpIHtcbiAgICAgICAgICAgIGVkZ2UgPSBlZGdlc1tlZGdlSWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuYm9keS5kYXRhLmVkZ2VzLl9kYXRhW2VkZ2VJZF07XG4gICAgICAgICAgaWYgKGVkZ2UgIT09IHVuZGVmaW5lZCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVkZ2Uuc2V0T3B0aW9ucyhkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjcmVhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgX0VkZ2UyLmRlZmF1bHQocHJvcGVydGllcywgdGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ21hcmtBbGxFZGdlc0FzRGlydHknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hcmtBbGxFZGdlc0FzRGlydHkoKSB7XG4gICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLmJvZHkuZWRnZXMpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXS5lZGdlVHlwZS5jb2xvckRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlY29ubmVjdCBhbGwgZWRnZXNcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlY29ubmVjdEVkZ2VzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWNvbm5lY3RFZGdlcygpIHtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcblxuICAgICAgICBmb3IgKGlkIGluIG5vZGVzKSB7XG4gICAgICAgICAgaWYgKG5vZGVzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgbm9kZXNbaWRdLmVkZ2VzID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpZCBpbiBlZGdlcykge1xuICAgICAgICAgIGlmIChlZGdlcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNbaWRdO1xuICAgICAgICAgICAgZWRnZS5mcm9tID0gbnVsbDtcbiAgICAgICAgICAgIGVkZ2UudG8gPSBudWxsO1xuICAgICAgICAgICAgZWRnZS5jb25uZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0Q29ubmVjdGVkTm9kZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbm5lY3RlZE5vZGVzKGVkZ2VJZCkge1xuICAgICAgICB2YXIgbm9kZUxpc3QgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdO1xuICAgICAgICAgIGlmIChlZGdlLmZyb21JZCkge1xuICAgICAgICAgICAgbm9kZUxpc3QucHVzaChlZGdlLmZyb21JZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlZGdlLnRvSWQpIHtcbiAgICAgICAgICAgIG5vZGVMaXN0LnB1c2goZWRnZS50b0lkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVMaXN0O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBFZGdlc0hhbmRsZXI7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBFZGdlc0hhbmRsZXI7XG5cbi8qKiovIH0sXG4vKiA4NyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfTGFiZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcblxuICB2YXIgX0xhYmVsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xhYmVsKTtcblxuICB2YXIgX0N1YmljQmV6aWVyRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oODgpO1xuXG4gIHZhciBfQ3ViaWNCZXppZXJFZGdlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0N1YmljQmV6aWVyRWRnZSk7XG5cbiAgdmFyIF9CZXppZXJFZGdlRHluYW1pYyA9IF9fd2VicGFja19yZXF1aXJlX18oOTIpO1xuXG4gIHZhciBfQmV6aWVyRWRnZUR5bmFtaWMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmV6aWVyRWRnZUR5bmFtaWMpO1xuXG4gIHZhciBfQmV6aWVyRWRnZVN0YXRpYyA9IF9fd2VicGFja19yZXF1aXJlX18oOTMpO1xuXG4gIHZhciBfQmV6aWVyRWRnZVN0YXRpYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CZXppZXJFZGdlU3RhdGljKTtcblxuICB2YXIgX1N0cmFpZ2h0RWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTQpO1xuXG4gIHZhciBfU3RyYWlnaHRFZGdlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N0cmFpZ2h0RWRnZSk7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICAvKipcbiAgICogQGNsYXNzIEVkZ2VcbiAgICpcbiAgICogQSBlZGdlIGNvbm5lY3RzIHR3byBub2Rlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAgICAgT2JqZWN0IHdpdGggb3B0aW9ucy4gTXVzdCBjb250YWluXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBdCBsZWFzdCBvcHRpb25zIGZyb20gYW5kIHRvLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXZhaWxhYmxlIG9wdGlvbnM6IGZyb20gKG51bWJlciksXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byAobnVtYmVyKSwgbGFiZWwgKHN0cmluZywgY29sb3IgKHN0cmluZyksXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCAobnVtYmVyKSwgc3R5bGUgKHN0cmluZyksXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggKG51bWJlciksIHRpdGxlIChzdHJpbmcpXG4gICAqIEBwYXJhbSB7TmV0d29ya30gbmV0d29yayAgICAgICBBIE5ldHdvcmsgb2JqZWN0LCB1c2VkIHRvIGZpbmQgYW5kIGVkZ2UgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uc3RhbnRzICAgICAgQW4gb2JqZWN0IHdpdGggZGVmYXVsdCB2YWx1ZXMgZm9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGFtcGxlIGZvciB0aGUgY29sb3JcbiAgICovXG4gIHZhciBFZGdlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVkZ2Uob3B0aW9ucywgYm9keSwgZ2xvYmFsT3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkZ2UpO1xuXG4gICAgICBpZiAoYm9keSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IFwiTm8gYm9keSBwcm92aWRlZFwiO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpb25zID0gdXRpbC5icmlkZ2VPYmplY3QoZ2xvYmFsT3B0aW9ucyk7XG4gICAgICB0aGlzLmdsb2JhbE9wdGlvbnMgPSBnbG9iYWxPcHRpb25zO1xuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcblxuICAgICAgLy8gaW5pdGlhbGl6ZSB2YXJpYWJsZXNcbiAgICAgIHRoaXMuaWQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmZyb21JZCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMudG9JZCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaG92ZXIgPSBmYWxzZTtcbiAgICAgIHRoaXMubGFiZWxEaXJ0eSA9IHRydWU7XG4gICAgICB0aGlzLmNvbG9yRGlydHkgPSB0cnVlO1xuXG4gICAgICB0aGlzLmJhc2VXaWR0aCA9IHRoaXMub3B0aW9ucy53aWR0aDtcbiAgICAgIHRoaXMuYmFzZUZvbnRTaXplID0gdGhpcy5vcHRpb25zLmZvbnQuc2l6ZTtcblxuICAgICAgdGhpcy5mcm9tID0gdW5kZWZpbmVkOyAvLyBhIG5vZGVcbiAgICAgIHRoaXMudG8gPSB1bmRlZmluZWQ7IC8vIGEgbm9kZVxuXG4gICAgICB0aGlzLmVkZ2VUeXBlID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuXG4gICAgICB0aGlzLmxhYmVsTW9kdWxlID0gbmV3IF9MYWJlbDIuZGVmYXVsdCh0aGlzLmJvZHksIHRoaXMub3B0aW9ucywgdHJ1ZSAvKiBJdCdzIGFuIGVkZ2UgbGFiZWwgKi8pO1xuXG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IG9yIG92ZXJ3cml0ZSBvcHRpb25zIGZvciB0aGUgZWRnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICBhbiBvYmplY3Qgd2l0aCBvcHRpb25zXG4gICAgICogQHBhcmFtIGRvTm90RW1pdFxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoRWRnZSwgW3tcbiAgICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2xvckRpcnR5ID0gdHJ1ZTtcblxuICAgICAgICBFZGdlLnBhcnNlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsIHRydWUsIHRoaXMuZ2xvYmFsT3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuaWQgPSBvcHRpb25zLmlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmZyb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuZnJvbUlkID0gb3B0aW9ucy5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnRvSWQgPSBvcHRpb25zLnRvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnRpdGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnRpdGxlID0gb3B0aW9ucy50aXRsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3B0aW9ucy52YWx1ZSA9IHBhcnNlRmxvYXQob3B0aW9ucy52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgbGFiZWwgTW9kdWxlXG4gICAgICAgIHRoaXMudXBkYXRlTGFiZWxNb2R1bGUoKTtcblxuICAgICAgICB2YXIgZGF0YUNoYW5nZWQgPSB0aGlzLnVwZGF0ZUVkZ2VUeXBlKCk7XG5cbiAgICAgICAgLy8gaWYgYW55dGhpbmcgaGFzIGJlZW4gdXBkYXRlcywgcmVzZXQgdGhlIHNlbGVjdGlvbiB3aWR0aCBhbmQgdGhlIGhvdmVyIHdpZHRoXG4gICAgICAgIHRoaXMuX3NldEludGVyYWN0aW9uV2lkdGhzKCk7XG5cbiAgICAgICAgLy8gQSBub2RlIGlzIGNvbm5lY3RlZCB3aGVuIGl0IGhhcyBhIGZyb20gYW5kIHRvIG5vZGUgdGhhdCBib3RoIGV4aXN0IGluIHRoZSBuZXR3b3JrLmJvZHkubm9kZXMuXG4gICAgICAgIHRoaXMuY29ubmVjdCgpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmhpZGRlbiAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucGh5c2ljcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGFDaGFuZ2VkO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3VwZGF0ZUxhYmVsTW9kdWxlJyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIHVwZGF0ZSB0aGUgb3B0aW9ucyBpbiB0aGUgbGFiZWwgbW9kdWxlXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVMYWJlbE1vZHVsZSgpIHtcbiAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5zZXRPcHRpb25zKHRoaXMub3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsTW9kdWxlLmJhc2VTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmJhc2VGb250U2l6ZSA9IHRoaXMubGFiZWxNb2R1bGUuYmFzZVNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB1cGRhdGUgdGhlIGVkZ2UgdHlwZSwgc2V0IHRoZSBvcHRpb25zXG4gICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndXBkYXRlRWRnZVR5cGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUVkZ2VUeXBlKCkge1xuICAgICAgICB2YXIgZGF0YUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGNoYW5nZUluVHlwZSA9IHRydWU7XG4gICAgICAgIHZhciBzbW9vdGggPSB0aGlzLm9wdGlvbnMuc21vb3RoO1xuICAgICAgICBpZiAodGhpcy5lZGdlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWRnZVR5cGUgaW5zdGFuY2VvZiBfQmV6aWVyRWRnZUR5bmFtaWMyLmRlZmF1bHQgJiYgc21vb3RoLmVuYWJsZWQgPT09IHRydWUgJiYgc21vb3RoLnR5cGUgPT09ICdkeW5hbWljJykge1xuICAgICAgICAgICAgY2hhbmdlSW5UeXBlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmVkZ2VUeXBlIGluc3RhbmNlb2YgX0N1YmljQmV6aWVyRWRnZTIuZGVmYXVsdCAmJiBzbW9vdGguZW5hYmxlZCA9PT0gdHJ1ZSAmJiBzbW9vdGgudHlwZSA9PT0gJ2N1YmljQmV6aWVyJykge1xuICAgICAgICAgICAgY2hhbmdlSW5UeXBlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmVkZ2VUeXBlIGluc3RhbmNlb2YgX0JlemllckVkZ2VTdGF0aWMyLmRlZmF1bHQgJiYgc21vb3RoLmVuYWJsZWQgPT09IHRydWUgJiYgc21vb3RoLnR5cGUgIT09ICdkeW5hbWljJyAmJiBzbW9vdGgudHlwZSAhPT0gJ2N1YmljQmV6aWVyJykge1xuICAgICAgICAgICAgY2hhbmdlSW5UeXBlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmVkZ2VUeXBlIGluc3RhbmNlb2YgX1N0cmFpZ2h0RWRnZTIuZGVmYXVsdCAmJiBzbW9vdGguZW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNoYW5nZUluVHlwZSA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjaGFuZ2VJblR5cGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGRhdGFDaGFuZ2VkID0gdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5nZUluVHlwZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc21vb3RoLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc21vb3RoLnR5cGUgPT09ICdkeW5hbWljJykge1xuICAgICAgICAgICAgICBkYXRhQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMuZWRnZVR5cGUgPSBuZXcgX0JlemllckVkZ2VEeW5hbWljMi5kZWZhdWx0KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnNtb290aC50eXBlID09PSAnY3ViaWNCZXppZXInKSB7XG4gICAgICAgICAgICAgIHRoaXMuZWRnZVR5cGUgPSBuZXcgX0N1YmljQmV6aWVyRWRnZTIuZGVmYXVsdCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmVkZ2VUeXBlID0gbmV3IF9CZXppZXJFZGdlU3RhdGljMi5kZWZhdWx0KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lZGdlVHlwZSA9IG5ldyBfU3RyYWlnaHRFZGdlMi5kZWZhdWx0KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgbm90aGluZyBjaGFuZ2VzLCB3ZSBqdXN0IHNldCB0aGUgb3B0aW9ucy5cbiAgICAgICAgICB0aGlzLmVkZ2VUeXBlLnNldE9wdGlvbnModGhpcy5vcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhQ2hhbmdlZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb25uZWN0IGFuIGVkZ2UgdG8gaXRzIG5vZGVzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Nvbm5lY3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuXG4gICAgICAgIHRoaXMuZnJvbSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmZyb21JZF0gfHwgdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnRvID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMudG9JZF0gfHwgdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IHRoaXMuZnJvbSAhPT0gdW5kZWZpbmVkICYmIHRoaXMudG8gIT09IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmZyb20uYXR0YWNoRWRnZSh0aGlzKTtcbiAgICAgICAgICB0aGlzLnRvLmF0dGFjaEVkZ2UodGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuZnJvbSkge1xuICAgICAgICAgICAgdGhpcy5mcm9tLmRldGFjaEVkZ2UodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnRvKSB7XG4gICAgICAgICAgICB0aGlzLnRvLmRldGFjaEVkZ2UodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lZGdlVHlwZS5jb25uZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGlzY29ubmVjdCBhbiBlZGdlIGZyb20gaXRzIG5vZGVzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rpc2Nvbm5lY3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmZyb20pIHtcbiAgICAgICAgICB0aGlzLmZyb20uZGV0YWNoRWRnZSh0aGlzKTtcbiAgICAgICAgICB0aGlzLmZyb20gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudG8pIHtcbiAgICAgICAgICB0aGlzLnRvLmRldGFjaEVkZ2UodGhpcyk7XG4gICAgICAgICAgdGhpcy50byA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogZ2V0IHRoZSB0aXRsZSBvZiB0aGlzIGVkZ2UuXG4gICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRpdGxlICAgIFRoZSB0aXRsZSBvZiB0aGUgZWRnZSwgb3IgdW5kZWZpbmVkIHdoZW4gbm8gdGl0bGVcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzIGJlZW4gc2V0LlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRUaXRsZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGl0bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGNoZWNrIGlmIHRoaXMgbm9kZSBpcyBzZWxlY3RlXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBzZWxlY3RlZCAgIFRydWUgaWYgbm9kZSBpcyBzZWxlY3RlZCwgZWxzZSBmYWxzZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdpc1NlbGVjdGVkJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1NlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXRyaWV2ZSB0aGUgdmFsdWUgb2YgdGhlIGVkZ2UuIENhbiBiZSB1bmRlZmluZWRcbiAgICAgICAqIEByZXR1cm4ge051bWJlcn0gdmFsdWVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0VmFsdWUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkanVzdCB0aGUgdmFsdWUgcmFuZ2Ugb2YgdGhlIGVkZ2UuIFRoZSBlZGdlIHdpbGwgYWRqdXN0IGl0J3Mgd2lkdGhcbiAgICAgICAqIGJhc2VkIG9uIGl0cyB2YWx1ZS5cbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtaW5cbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhcbiAgICAgICAqIEBwYXJhbSB0b3RhbFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRWYWx1ZVJhbmdlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZVJhbmdlKG1pbiwgbWF4LCB0b3RhbCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5jdXN0b21TY2FsaW5nRnVuY3Rpb24obWluLCBtYXgsIHRvdGFsLCB0aGlzLm9wdGlvbnMudmFsdWUpO1xuICAgICAgICAgIHZhciB3aWR0aERpZmYgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5tYXggLSB0aGlzLm9wdGlvbnMuc2NhbGluZy5taW47XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBmb250RGlmZiA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1heCAtIHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1pbjtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5mb250LnNpemUgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5taW4gKyBzY2FsZSAqIGZvbnREaWZmO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm9wdGlvbnMud2lkdGggPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5taW4gKyBzY2FsZSAqIHdpZHRoRGlmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMud2lkdGggPSB0aGlzLmJhc2VXaWR0aDtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZm9udC5zaXplID0gdGhpcy5iYXNlRm9udFNpemU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXRJbnRlcmFjdGlvbldpZHRocygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUxhYmVsTW9kdWxlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3NldEludGVyYWN0aW9uV2lkdGhzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0SW50ZXJhY3Rpb25XaWR0aHMoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmhvdmVyV2lkdGggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLmVkZ2VUeXBlLmhvdmVyV2lkdGggPSB0aGlzLm9wdGlvbnMuaG92ZXJXaWR0aCh0aGlzLm9wdGlvbnMud2lkdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZWRnZVR5cGUuaG92ZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ob3ZlcldpZHRoICsgdGhpcy5vcHRpb25zLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuc2VsZWN0aW9uV2lkdGggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLmVkZ2VUeXBlLnNlbGVjdGlvbldpZHRoID0gdGhpcy5vcHRpb25zLnNlbGVjdGlvbldpZHRoKHRoaXMub3B0aW9ucy53aWR0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lZGdlVHlwZS5zZWxlY3Rpb25XaWR0aCA9IHRoaXMub3B0aW9ucy5zZWxlY3Rpb25XaWR0aCArIHRoaXMub3B0aW9ucy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZHJhdyBhIGVkZ2VcbiAgICAgICAqIERyYXcgdGhpcyBlZGdlIGluIHRoZSBnaXZlbiBjYW52YXNcbiAgICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RyYXcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICAgIC8vIGdldCB0aGUgdmlhIG5vZGUgZnJvbSB0aGUgZWRnZSB0eXBlXG4gICAgICAgIHZhciB2aWFOb2RlID0gdGhpcy5lZGdlVHlwZS5nZXRWaWFOb2RlKCk7XG4gICAgICAgIHZhciBhcnJvd0RhdGEgPSB7fTtcblxuICAgICAgICAvLyByZXN0b3JlIGVkZ2UgdGFyZ2V0cyB0byBkZWZhdWx0c1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLmZyb21Qb2ludCA9IHRoaXMuZWRnZVR5cGUuZnJvbTtcbiAgICAgICAgdGhpcy5lZGdlVHlwZS50b1BvaW50ID0gdGhpcy5lZGdlVHlwZS50bztcblxuICAgICAgICAvLyBmcm9tIGFuZCB0byBhcnJvd3MgZ2l2ZSBhIGRpZmZlcmVudCBlbmQgcG9pbnQgZm9yIGVkZ2VzLiB3ZSBzZXQgdGhlbSBoZXJlXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20uZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGFycm93RGF0YS5mcm9tID0gdGhpcy5lZGdlVHlwZS5nZXRBcnJvd0RhdGEoY3R4LCAnZnJvbScsIHZpYU5vZGUsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXJyb3dTdHJpa2V0aHJvdWdoID09PSBmYWxzZSkgdGhpcy5lZGdlVHlwZS5mcm9tUG9pbnQgPSBhcnJvd0RhdGEuZnJvbS5jb3JlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXJyb3dzLnRvLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBhcnJvd0RhdGEudG8gPSB0aGlzLmVkZ2VUeXBlLmdldEFycm93RGF0YShjdHgsICd0bycsIHZpYU5vZGUsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXJyb3dTdHJpa2V0aHJvdWdoID09PSBmYWxzZSkgdGhpcy5lZGdlVHlwZS50b1BvaW50ID0gYXJyb3dEYXRhLnRvLmNvcmU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgbWlkZGxlIGFycm93IGRlcGVuZHMgb24gdGhlIGxpbmUsIHdoaWNoIGNhbiBkZXBlbmQgb24gdGhlIHRvIGFuZCBmcm9tIGFycm93cyBzbyB3ZSBkbyB0aGlzIG9uZSBsYXN0bHkuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXJyb3dzLm1pZGRsZS5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgYXJyb3dEYXRhLm1pZGRsZSA9IHRoaXMuZWRnZVR5cGUuZ2V0QXJyb3dEYXRhKGN0eCwgJ21pZGRsZScsIHZpYU5vZGUsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZHJhdyBldmVyeXRoaW5nXG4gICAgICAgIHRoaXMuZWRnZVR5cGUuZHJhd0xpbmUoY3R4LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCB2aWFOb2RlKTtcbiAgICAgICAgdGhpcy5kcmF3QXJyb3dzKGN0eCwgYXJyb3dEYXRhKTtcbiAgICAgICAgdGhpcy5kcmF3TGFiZWwoY3R4LCB2aWFOb2RlKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkcmF3QXJyb3dzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QXJyb3dzKGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20uZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuZWRnZVR5cGUuZHJhd0Fycm93SGVhZChjdHgsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIGFycm93RGF0YS5mcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFycm93cy5taWRkbGUuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuZWRnZVR5cGUuZHJhd0Fycm93SGVhZChjdHgsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIGFycm93RGF0YS5taWRkbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXJyb3dzLnRvLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmVkZ2VUeXBlLmRyYXdBcnJvd0hlYWQoY3R4LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCBhcnJvd0RhdGEudG8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZHJhd0xhYmVsJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3TGFiZWwoY3R4LCB2aWFOb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHNldCBzdHlsZVxuICAgICAgICAgIHZhciBub2RlMSA9IHRoaXMuZnJvbTtcbiAgICAgICAgICB2YXIgbm9kZTIgPSB0aGlzLnRvO1xuICAgICAgICAgIHZhciBzZWxlY3RlZCA9IHRoaXMuZnJvbS5zZWxlY3RlZCB8fCB0aGlzLnRvLnNlbGVjdGVkIHx8IHRoaXMuc2VsZWN0ZWQ7XG4gICAgICAgICAgaWYgKG5vZGUxLmlkICE9IG5vZGUyLmlkKSB7XG4gICAgICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLnBvaW50VG9TZWxmID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLmVkZ2VUeXBlLmdldFBvaW50KDAuNSwgdmlhTm9kZSk7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgbGFiZWwgaGFzIHRvIGJlIHJvdGF0ZWQ6XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZvbnQuYWxpZ24gIT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgICAgIHRoaXMubGFiZWxNb2R1bGUuY2FsY3VsYXRlTGFiZWxTaXplKGN0eCwgc2VsZWN0ZWQsIHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHBvaW50LngsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS55TGluZSk7XG4gICAgICAgICAgICAgIHRoaXMuX3JvdGF0ZUZvckxhYmVsQWxpZ25tZW50KGN0eCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRyYXcgdGhlIGxhYmVsXG4gICAgICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCBwb2ludC54LCBwb2ludC55LCBzZWxlY3RlZCk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgdGhlIG9yaWVudGF0aW9ucy5cbiAgICAgICAgICAgIHRoaXMubGFiZWxNb2R1bGUucG9pbnRUb1NlbGYgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHgsIHk7XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2VTaXplO1xuICAgICAgICAgICAgaWYgKG5vZGUxLnNoYXBlLndpZHRoID4gbm9kZTEuc2hhcGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgIHggPSBub2RlMS54ICsgbm9kZTEuc2hhcGUud2lkdGggKiAwLjU7XG4gICAgICAgICAgICAgIHkgPSBub2RlMS55IC0gcmFkaXVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgeCA9IG5vZGUxLnggKyByYWRpdXM7XG4gICAgICAgICAgICAgIHkgPSBub2RlMS55IC0gbm9kZTEuc2hhcGUuaGVpZ2h0ICogMC41O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnQgPSB0aGlzLl9wb2ludE9uQ2lyY2xlKHgsIHksIHJhZGl1cywgMC4xMjUpO1xuICAgICAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgc2VsZWN0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENoZWNrIGlmIHRoaXMgb2JqZWN0IGlzIG92ZXJsYXBwaW5nIHdpdGggdGhlIHByb3ZpZGVkIG9iamVjdFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAgIGFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgVHJ1ZSBpZiBsb2NhdGlvbiBpcyBsb2NhdGVkIG9uIHRoZSBlZGdlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2lzT3ZlcmxhcHBpbmdXaXRoJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc092ZXJsYXBwaW5nV2l0aChvYmopIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgdmFyIGRpc3RNYXggPSAxMDtcbiAgICAgICAgICB2YXIgeEZyb20gPSB0aGlzLmZyb20ueDtcbiAgICAgICAgICB2YXIgeUZyb20gPSB0aGlzLmZyb20ueTtcbiAgICAgICAgICB2YXIgeFRvID0gdGhpcy50by54O1xuICAgICAgICAgIHZhciB5VG8gPSB0aGlzLnRvLnk7XG4gICAgICAgICAgdmFyIHhPYmogPSBvYmoubGVmdDtcbiAgICAgICAgICB2YXIgeU9iaiA9IG9iai50b3A7XG5cbiAgICAgICAgICB2YXIgZGlzdCA9IHRoaXMuZWRnZVR5cGUuZ2V0RGlzdGFuY2VUb0VkZ2UoeEZyb20sIHlGcm9tLCB4VG8sIHlUbywgeE9iaiwgeU9iaik7XG5cbiAgICAgICAgICByZXR1cm4gZGlzdCA8IGRpc3RNYXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUm90YXRlcyB0aGUgY2FudmFzIHNvIHRoZSB0ZXh0IGlzIG1vc3QgcmVhZGFibGVcbiAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19yb3RhdGVGb3JMYWJlbEFsaWdubWVudCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JvdGF0ZUZvckxhYmVsQWxpZ25tZW50KGN0eCkge1xuICAgICAgICB2YXIgZHkgPSB0aGlzLmZyb20ueSAtIHRoaXMudG8ueTtcbiAgICAgICAgdmFyIGR4ID0gdGhpcy5mcm9tLnggLSB0aGlzLnRvLng7XG4gICAgICAgIHZhciBhbmdsZUluRGVncmVlcyA9IE1hdGguYXRhbjIoZHksIGR4KTtcblxuICAgICAgICAvLyByb3RhdGUgc28gbGFiZWwgaXQgaXMgcmVhZGFibGVcbiAgICAgICAgaWYgKGFuZ2xlSW5EZWdyZWVzIDwgLTEgJiYgZHggPCAwIHx8IGFuZ2xlSW5EZWdyZWVzID4gMCAmJiBkeCA8IDApIHtcbiAgICAgICAgICBhbmdsZUluRGVncmVlcyA9IGFuZ2xlSW5EZWdyZWVzICsgTWF0aC5QSTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5yb3RhdGUoYW5nbGVJbkRlZ3JlZXMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCBhIHBvaW50IG9uIGEgY2lyY2xlXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwZXJjZW50YWdlLiBWYWx1ZSBiZXR3ZWVuIDAgKGxpbmUgc3RhcnQpIGFuZCAxIChsaW5lIGVuZClcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gcG9pbnRcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19wb2ludE9uQ2lyY2xlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcG9pbnRPbkNpcmNsZSh4LCB5LCByYWRpdXMsIHBlcmNlbnRhZ2UpIHtcbiAgICAgICAgdmFyIGFuZ2xlID0gcGVyY2VudGFnZSAqIDIgKiBNYXRoLlBJO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHggKyByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgeTogeSAtIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NlbGVjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0KCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1bnNlbGVjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdW5zZWxlY3QoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBjbGVhbnMgYWxsIHJlcXVpcmVkIHRoaW5ncyBvbiBkZWxldGVcbiAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjbGVhbnVwJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGdlVHlwZS5jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfV0sIFt7XG4gICAgICBrZXk6ICdwYXJzZU9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zKSB7XG4gICAgICAgIHZhciBhbGxvd0RlbGV0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgICAgdmFyIGdsb2JhbE9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG4gICAgICAgIHZhciBmaWVsZHMgPSBbJ2Fycm93U3RyaWtldGhyb3VnaCcsICdpZCcsICdmcm9tJywgJ2hpZGRlbicsICdob3ZlcldpZHRoJywgJ2xhYmVsJywgJ2xhYmVsSGlnaGxpZ2h0Qm9sZCcsICdsZW5ndGgnLCAnbGluZScsICdvcGFjaXR5JywgJ3BoeXNpY3MnLCAnc2NhbGluZycsICdzZWxlY3Rpb25XaWR0aCcsICdzZWxmUmVmZXJlbmNlU2l6ZScsICd0bycsICd0aXRsZScsICd2YWx1ZScsICd3aWR0aCddO1xuXG4gICAgICAgIC8vIG9ubHkgZGVlcCBleHRlbmQgdGhlIGl0ZW1zIGluIHRoZSBmaWVsZCBhcnJheS4gVGhlc2UgZG8gbm90IGhhdmUgc2hvcnRoYW5kLlxuICAgICAgICB1dGlsLnNlbGVjdGl2ZURlZXBFeHRlbmQoZmllbGRzLCBwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCBhbGxvd0RlbGV0aW9uKTtcblxuICAgICAgICB1dGlsLm1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCAnc21vb3RoJywgYWxsb3dEZWxldGlvbiwgZ2xvYmFsT3B0aW9ucyk7XG4gICAgICAgIHV0aWwubWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsICdzaGFkb3cnLCBhbGxvd0RlbGV0aW9uLCBnbG9iYWxPcHRpb25zKTtcblxuICAgICAgICBpZiAobmV3T3B0aW9ucy5kYXNoZXMgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmRhc2hlcyAhPT0gbnVsbCkge1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuZGFzaGVzID0gbmV3T3B0aW9ucy5kYXNoZXM7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLmRhc2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuZGFzaGVzID0gT2JqZWN0LmNyZWF0ZShnbG9iYWxPcHRpb25zLmRhc2hlcyk7IC8vIHRoaXMgc2V0cyB0aGUgcG9pbnRlciBvZiB0aGUgb3B0aW9uIGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb24uXG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdGhlIHNjYWxpbmcgbmV3T3B0aW9uc1xuICAgICAgICBpZiAobmV3T3B0aW9ucy5zY2FsaW5nICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5zY2FsaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKG5ld09wdGlvbnMuc2NhbGluZy5taW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyZW50T3B0aW9ucy5zY2FsaW5nLm1pbiA9IG5ld09wdGlvbnMuc2NhbGluZy5taW47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXdPcHRpb25zLnNjYWxpbmcubWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuc2NhbGluZy5tYXggPSBuZXdPcHRpb25zLnNjYWxpbmcubWF4O1xuICAgICAgICAgIH1cbiAgICAgICAgICB1dGlsLm1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLnNjYWxpbmcsIG5ld09wdGlvbnMuc2NhbGluZywgJ2xhYmVsJywgYWxsb3dEZWxldGlvbiwgZ2xvYmFsT3B0aW9ucy5zY2FsaW5nKTtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlICYmIG5ld09wdGlvbnMuc2NhbGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuc2NhbGluZyA9IE9iamVjdC5jcmVhdGUoZ2xvYmFsT3B0aW9ucy5zY2FsaW5nKTsgLy8gdGhpcyBzZXRzIHRoZSBwb2ludGVyIG9mIHRoZSBvcHRpb24gYmFjayB0byB0aGUgZ2xvYmFsIG9wdGlvbi5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBtdWx0aXBsZSBpbnB1dCBjYXNlcyBmb3IgYXJyb3dzXG4gICAgICAgIGlmIChuZXdPcHRpb25zLmFycm93cyAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuYXJyb3dzICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuZXdPcHRpb25zLmFycm93cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciBhcnJvd3MgPSBuZXdPcHRpb25zLmFycm93cy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcGFyZW50T3B0aW9ucy5hcnJvd3MudG8uZW5hYmxlZCA9IGFycm93cy5pbmRleE9mKFwidG9cIikgIT0gLTE7XG4gICAgICAgICAgICBwYXJlbnRPcHRpb25zLmFycm93cy5taWRkbGUuZW5hYmxlZCA9IGFycm93cy5pbmRleE9mKFwibWlkZGxlXCIpICE9IC0xO1xuICAgICAgICAgICAgcGFyZW50T3B0aW9ucy5hcnJvd3MuZnJvbS5lbmFibGVkID0gYXJyb3dzLmluZGV4T2YoXCJmcm9tXCIpICE9IC0xO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihuZXdPcHRpb25zLmFycm93cykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB1dGlsLm1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLmFycm93cywgbmV3T3B0aW9ucy5hcnJvd3MsICd0bycsIGFsbG93RGVsZXRpb24sIGdsb2JhbE9wdGlvbnMuYXJyb3dzKTtcbiAgICAgICAgICAgIHV0aWwubWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMuYXJyb3dzLCBuZXdPcHRpb25zLmFycm93cywgJ21pZGRsZScsIGFsbG93RGVsZXRpb24sIGdsb2JhbE9wdGlvbnMuYXJyb3dzKTtcbiAgICAgICAgICAgIHV0aWwubWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMuYXJyb3dzLCBuZXdPcHRpb25zLmFycm93cywgJ2Zyb20nLCBhbGxvd0RlbGV0aW9uLCBnbG9iYWxPcHRpb25zLmFycm93cyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBhcnJvdyBuZXdPcHRpb25zIGNhbiBvbmx5IGJlIGFuIG9iamVjdCBvciBhIHN0cmluZy4gUmVmZXIgdG8gdGhlIGRvY3VtZW50YXRpb24uIFlvdSB1c2VkOlwiICsgSlNPTi5zdHJpbmdpZnkobmV3T3B0aW9ucy5hcnJvd3MpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLmFycm93cyA9PT0gbnVsbCkge1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuYXJyb3dzID0gT2JqZWN0LmNyZWF0ZShnbG9iYWxPcHRpb25zLmFycm93cyk7IC8vIHRoaXMgc2V0cyB0aGUgcG9pbnRlciBvZiB0aGUgb3B0aW9uIGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb24uXG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgbXVsdGlwbGUgaW5wdXQgY2FzZXMgZm9yIGNvbG9yXG4gICAgICAgIGlmIChuZXdPcHRpb25zLmNvbG9yICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5jb2xvciAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIG1ha2UgYSBjb3B5IG9mIHRoZSBwYXJlbnQgb2JqZWN0IGluIGNhc2UgdGhpcyBpcyByZWZlcnJpbmcgdG8gdGhlIGdsb2JhbCBvbmUgKGR1ZSB0byBvYmplY3QgY3JlYXRlIG9uY2UsIHRoZW4gdXBkYXRlKVxuICAgICAgICAgIHBhcmVudE9wdGlvbnMuY29sb3IgPSB1dGlsLmRlZXBFeHRlbmQoe30sIHBhcmVudE9wdGlvbnMuY29sb3IsIHRydWUpO1xuICAgICAgICAgIGlmICh1dGlsLmlzU3RyaW5nKG5ld09wdGlvbnMuY29sb3IpKSB7XG4gICAgICAgICAgICBwYXJlbnRPcHRpb25zLmNvbG9yLmNvbG9yID0gbmV3T3B0aW9ucy5jb2xvcjtcbiAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0ID0gbmV3T3B0aW9ucy5jb2xvcjtcbiAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuY29sb3IuaG92ZXIgPSBuZXdPcHRpb25zLmNvbG9yO1xuICAgICAgICAgICAgcGFyZW50T3B0aW9ucy5jb2xvci5pbmhlcml0ID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb2xvcnNEZWZpbmVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobmV3T3B0aW9ucy5jb2xvci5jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuY29sb3IuY29sb3IgPSBuZXdPcHRpb25zLmNvbG9yLmNvbG9yO2NvbG9yc0RlZmluZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld09wdGlvbnMuY29sb3IuaGlnaGxpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcGFyZW50T3B0aW9ucy5jb2xvci5oaWdobGlnaHQgPSBuZXdPcHRpb25zLmNvbG9yLmhpZ2hsaWdodDtjb2xvcnNEZWZpbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdPcHRpb25zLmNvbG9yLmhvdmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcGFyZW50T3B0aW9ucy5jb2xvci5ob3ZlciA9IG5ld09wdGlvbnMuY29sb3IuaG92ZXI7Y29sb3JzRGVmaW5lZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3T3B0aW9ucy5jb2xvci5pbmhlcml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcGFyZW50T3B0aW9ucy5jb2xvci5pbmhlcml0ID0gbmV3T3B0aW9ucy5jb2xvci5pbmhlcml0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld09wdGlvbnMuY29sb3Iub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuY29sb3Iub3BhY2l0eSA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIG5ld09wdGlvbnMuY29sb3Iub3BhY2l0eSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmV3T3B0aW9ucy5jb2xvci5pbmhlcml0ID09PSB1bmRlZmluZWQgJiYgY29sb3JzRGVmaW5lZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBwYXJlbnRPcHRpb25zLmNvbG9yLmluaGVyaXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLmNvbG9yID09PSBudWxsKSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5jb2xvciA9IHV0aWwuYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMuY29sb3IpOyAvLyBzZXQgdGhlIG9iamVjdCBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uc1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIHRoZSBmb250IHNldHRpbmdzXG4gICAgICAgIGlmIChuZXdPcHRpb25zLmZvbnQgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmZvbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBfTGFiZWwyLmRlZmF1bHQucGFyc2VPcHRpb25zKHBhcmVudE9wdGlvbnMuZm9udCwgbmV3T3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLmZvbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmZvbnQgPSB1dGlsLmJyaWRnZU9iamVjdChnbG9iYWxPcHRpb25zLmZvbnQpOyAvLyBzZXQgdGhlIG9iamVjdCBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEVkZ2U7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBFZGdlO1xuXG4vKioqLyB9LFxuLyogODggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX0N1YmljQmV6aWVyRWRnZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OSk7XG5cbiAgdmFyIF9DdWJpY0JlemllckVkZ2VCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0N1YmljQmV6aWVyRWRnZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIEN1YmljQmV6aWVyRWRnZSA9IGZ1bmN0aW9uIChfQ3ViaWNCZXppZXJFZGdlQmFzZSkge1xuICAgIF9pbmhlcml0cyhDdWJpY0JlemllckVkZ2UsIF9DdWJpY0JlemllckVkZ2VCYXNlKTtcblxuICAgIGZ1bmN0aW9uIEN1YmljQmV6aWVyRWRnZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1YmljQmV6aWVyRWRnZSk7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ3ViaWNCZXppZXJFZGdlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ3ViaWNCZXppZXJFZGdlKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXcgYSBsaW5lIGJldHdlZW4gdHdvIG5vZGVzXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhDdWJpY0JlemllckVkZ2UsIFt7XG4gICAgICBrZXk6ICdfbGluZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2xpbmUoY3R4LCB2aWFOb2Rlcykge1xuICAgICAgICAvLyBnZXQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBzdXBwb3J0IHBvaW50cy5cbiAgICAgICAgdmFyIHZpYTEgPSB2aWFOb2Rlc1swXTtcbiAgICAgICAgdmFyIHZpYTIgPSB2aWFOb2Rlc1sxXTtcblxuICAgICAgICAvLyBzdGFydCBkcmF3aW5nIHRoZSBsaW5lLlxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8odGhpcy5mcm9tUG9pbnQueCwgdGhpcy5mcm9tUG9pbnQueSk7XG5cbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gbm9ybWFsIHN0cmFpZ2h0IGVkZ2VzXG4gICAgICAgIGlmICh2aWFOb2RlcyA9PT0gdW5kZWZpbmVkIHx8IHZpYTEueCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLnRvUG9pbnQueCwgdGhpcy50b1BvaW50LnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHZpYTEueCwgdmlhMS55LCB2aWEyLngsIHZpYTIueSwgdGhpcy50b1BvaW50LngsIHRoaXMudG9Qb2ludC55KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldFZpYUNvb3JkaW5hdGVzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VmlhQ29vcmRpbmF0ZXMoKSB7XG4gICAgICAgIHZhciBkeCA9IHRoaXMuZnJvbS54IC0gdGhpcy50by54O1xuICAgICAgICB2YXIgZHkgPSB0aGlzLmZyb20ueSAtIHRoaXMudG8ueTtcblxuICAgICAgICB2YXIgeDEgPSB2b2lkIDAsXG4gICAgICAgICAgICB5MSA9IHZvaWQgMCxcbiAgICAgICAgICAgIHgyID0gdm9pZCAwLFxuICAgICAgICAgICAgeTIgPSB2b2lkIDA7XG4gICAgICAgIHZhciByb3VuZG5lc3MgPSB0aGlzLm9wdGlvbnMuc21vb3RoLnJvdW5kbmVzcztcblxuICAgICAgICAvLyBob3Jpem9udGFsIGlmIHggPiB5IG9yIGlmIGRpcmVjdGlvbiBpcyBmb3JjZWQgb3IgaWYgZGlyZWN0aW9uIGlzIGhvcml6b250YWxcbiAgICAgICAgaWYgKChNYXRoLmFicyhkeCkgPiBNYXRoLmFicyhkeSkgfHwgdGhpcy5vcHRpb25zLnNtb290aC5mb3JjZURpcmVjdGlvbiA9PT0gdHJ1ZSB8fCB0aGlzLm9wdGlvbnMuc21vb3RoLmZvcmNlRGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpICYmIHRoaXMub3B0aW9ucy5zbW9vdGguZm9yY2VEaXJlY3Rpb24gIT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICB5MSA9IHRoaXMuZnJvbS55O1xuICAgICAgICAgIHkyID0gdGhpcy50by55O1xuICAgICAgICAgIHgxID0gdGhpcy5mcm9tLnggLSByb3VuZG5lc3MgKiBkeDtcbiAgICAgICAgICB4MiA9IHRoaXMudG8ueCArIHJvdW5kbmVzcyAqIGR4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHkxID0gdGhpcy5mcm9tLnkgLSByb3VuZG5lc3MgKiBkeTtcbiAgICAgICAgICB5MiA9IHRoaXMudG8ueSArIHJvdW5kbmVzcyAqIGR5O1xuICAgICAgICAgIHgxID0gdGhpcy5mcm9tLng7XG4gICAgICAgICAgeDIgPSB0aGlzLnRvLng7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW3sgeDogeDEsIHk6IHkxIH0sIHsgeDogeDIsIHk6IHkyIH1dO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldFZpYU5vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpYU5vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19maW5kQm9yZGVyUG9zaXRpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb24obmVhck5vZGUsIGN0eCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQmV6aWVyKG5lYXJOb2RlLCBjdHgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXREaXN0YW5jZVRvRWRnZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9FZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCksXG4gICAgICAgICAgICBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgICAgdmlhMSA9IF9yZWYyWzBdLFxuICAgICAgICAgICAgdmlhMiA9IF9yZWYyWzFdO1xuXG4gICAgICAgIC8vIHgzLHkzIGlzIHRoZSBwb2ludFxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdmlhMSwgdmlhMik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29tYmluZWQgZnVuY3Rpb24gb2YgcG9pbnRPbkxpbmUgYW5kIHBvaW50T25CZXppZXIuIFRoaXMgZ2l2ZXMgdGhlIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnQgb24gdGhlIGxpbmUgYXQgYSBjZXJ0YWluIHBlcmNlbnRhZ2Ugb2YgdGhlIHdheVxuICAgICAgICogQHBhcmFtIHBlcmNlbnRhZ2VcbiAgICAgICAqIEBwYXJhbSB2aWFcbiAgICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0UG9pbnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50KHBlcmNlbnRhZ2UpIHtcbiAgICAgICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpLFxuICAgICAgICAgICAgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMiksXG4gICAgICAgICAgICB2aWExID0gX3JlZjRbMF0sXG4gICAgICAgICAgICB2aWEyID0gX3JlZjRbMV07XG5cbiAgICAgICAgdmFyIHQgPSBwZXJjZW50YWdlO1xuICAgICAgICB2YXIgdmVjID0gW107XG4gICAgICAgIHZlY1swXSA9IE1hdGgucG93KDEgLSB0LCAzKTtcbiAgICAgICAgdmVjWzFdID0gMyAqIHQgKiBNYXRoLnBvdygxIC0gdCwgMik7XG4gICAgICAgIHZlY1syXSA9IDMgKiBNYXRoLnBvdyh0LCAyKSAqICgxIC0gdCk7XG4gICAgICAgIHZlY1szXSA9IE1hdGgucG93KHQsIDMpO1xuICAgICAgICB2YXIgeCA9IHZlY1swXSAqIHRoaXMuZnJvbVBvaW50LnggKyB2ZWNbMV0gKiB2aWExLnggKyB2ZWNbMl0gKiB2aWEyLnggKyB2ZWNbM10gKiB0aGlzLnRvUG9pbnQueDtcbiAgICAgICAgdmFyIHkgPSB2ZWNbMF0gKiB0aGlzLmZyb21Qb2ludC55ICsgdmVjWzFdICogdmlhMS55ICsgdmVjWzJdICogdmlhMi55ICsgdmVjWzNdICogdGhpcy50b1BvaW50Lnk7XG5cbiAgICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDdWJpY0JlemllckVkZ2U7XG4gIH0oX0N1YmljQmV6aWVyRWRnZUJhc2UzLmRlZmF1bHQpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IEN1YmljQmV6aWVyRWRnZTtcblxuLyoqKi8gfSxcbi8qIDg5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX0JlemllckVkZ2VCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oOTApO1xuXG4gIHZhciBfQmV6aWVyRWRnZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmV6aWVyRWRnZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIEN1YmljQmV6aWVyRWRnZUJhc2UgPSBmdW5jdGlvbiAoX0JlemllckVkZ2VCYXNlKSB7XG4gICAgX2luaGVyaXRzKEN1YmljQmV6aWVyRWRnZUJhc2UsIF9CZXppZXJFZGdlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBDdWJpY0JlemllckVkZ2VCYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3ViaWNCZXppZXJFZGdlQmFzZSk7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ3ViaWNCZXppZXJFZGdlQmFzZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEN1YmljQmV6aWVyRWRnZUJhc2UpKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgcG9pbnQgKHgzLHkzKSBhbmQgYSBsaW5lIHNlZ21lbnQgZnJvbVxuICAgICAqICh4MSx5MSkgdG8gKHgyLHkyKS5cbiAgICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg0OTIxMS9zaG9ydGVzdC1kaXN0YW5jYWUtYmV0d2Vlbi1hLXBvaW50LWFuZC1hLWxpbmUtc2VnbWVudFxuICAgICAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0IlQzMlQTl6aWVyX2N1cnZlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxIGZyb20geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MSBmcm9tIHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDIgdG8geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MiB0byB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgzIHBvaW50IHRvIGNoZWNrIHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTMgcG9pbnQgdG8gY2hlY2sgeVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhDdWJpY0JlemllckVkZ2VCYXNlLCBbe1xuICAgICAga2V5OiAnX2dldERpc3RhbmNlVG9CZXppZXJFZGdlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdmlhMSwgdmlhMikge1xuICAgICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgICAgdmFyIG1pbkRpc3RhbmNlID0gMWU5O1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSB2b2lkIDA7XG4gICAgICAgIHZhciBpID0gdm9pZCAwLFxuICAgICAgICAgICAgdCA9IHZvaWQgMCxcbiAgICAgICAgICAgIHggPSB2b2lkIDAsXG4gICAgICAgICAgICB5ID0gdm9pZCAwO1xuICAgICAgICB2YXIgbGFzdFggPSB4MTtcbiAgICAgICAgdmFyIGxhc3RZID0geTE7XG4gICAgICAgIHZhciB2ZWMgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgdCA9IDAuMSAqIGk7XG4gICAgICAgICAgdmVjWzBdID0gTWF0aC5wb3coMSAtIHQsIDMpO1xuICAgICAgICAgIHZlY1sxXSA9IDMgKiB0ICogTWF0aC5wb3coMSAtIHQsIDIpO1xuICAgICAgICAgIHZlY1syXSA9IDMgKiBNYXRoLnBvdyh0LCAyKSAqICgxIC0gdCk7XG4gICAgICAgICAgdmVjWzNdID0gTWF0aC5wb3codCwgMyk7XG4gICAgICAgICAgeCA9IHZlY1swXSAqIHgxICsgdmVjWzFdICogdmlhMS54ICsgdmVjWzJdICogdmlhMi54ICsgdmVjWzNdICogeDI7XG4gICAgICAgICAgeSA9IHZlY1swXSAqIHkxICsgdmVjWzFdICogdmlhMS55ICsgdmVjWzJdICogdmlhMi55ICsgdmVjWzNdICogeTI7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IHRoaXMuX2dldERpc3RhbmNlVG9MaW5lKGxhc3RYLCBsYXN0WSwgeCwgeSwgeDMsIHkzKTtcbiAgICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSA/IGRpc3RhbmNlIDogbWluRGlzdGFuY2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhc3RYID0geDtcbiAgICAgICAgICBsYXN0WSA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWluRGlzdGFuY2U7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEN1YmljQmV6aWVyRWRnZUJhc2U7XG4gIH0oX0JlemllckVkZ2VCYXNlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBDdWJpY0JlemllckVkZ2VCYXNlO1xuXG4vKioqLyB9LFxuLyogOTAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfRWRnZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MSk7XG5cbiAgdmFyIF9FZGdlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FZGdlQmFzZTIpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuICB2YXIgQmV6aWVyRWRnZUJhc2UgPSBmdW5jdGlvbiAoX0VkZ2VCYXNlKSB7XG4gICAgX2luaGVyaXRzKEJlemllckVkZ2VCYXNlLCBfRWRnZUJhc2UpO1xuXG4gICAgZnVuY3Rpb24gQmV6aWVyRWRnZUJhc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCZXppZXJFZGdlQmFzZSk7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQmV6aWVyRWRnZUJhc2UuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCZXppZXJFZGdlQmFzZSkpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHVzZXMgYmluYXJ5IHNlYXJjaCB0byBsb29rIGZvciB0aGUgcG9pbnQgd2hlcmUgdGhlIGJlemllciBjdXJ2ZSBjcm9zc2VzIHRoZSBib3JkZXIgb2YgdGhlIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmVhck5vZGVcbiAgICAgKiBAcGFyYW0gY3R4XG4gICAgICogQHBhcmFtIHZpYU5vZGVcbiAgICAgKiBAcGFyYW0gbmVhck5vZGVcbiAgICAgKiBAcGFyYW0gY3R4XG4gICAgICogQHBhcmFtIHZpYU5vZGVcbiAgICAgKiBAcGFyYW0gbmVhck5vZGVcbiAgICAgKiBAcGFyYW0gY3R4XG4gICAgICogQHBhcmFtIHZpYU5vZGVcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKEJlemllckVkZ2VCYXNlLCBbe1xuICAgICAga2V5OiAnX2ZpbmRCb3JkZXJQb3NpdGlvbkJlemllcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbkJlemllcihuZWFyTm9kZSwgY3R4KSB7XG4gICAgICAgIHZhciB2aWFOb2RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpO1xuXG4gICAgICAgIHZhciBtYXhJdGVyYXRpb25zID0gMTA7XG4gICAgICAgIHZhciBpdGVyYXRpb24gPSAwO1xuICAgICAgICB2YXIgbG93ID0gMDtcbiAgICAgICAgdmFyIGhpZ2ggPSAxO1xuICAgICAgICB2YXIgcG9zLCBhbmdsZSwgZGlzdGFuY2VUb0JvcmRlciwgZGlzdGFuY2VUb1BvaW50LCBkaWZmZXJlbmNlO1xuICAgICAgICB2YXIgdGhyZXNob2xkID0gMC4yO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMudG87XG4gICAgICAgIHZhciBmcm9tID0gZmFsc2U7XG4gICAgICAgIGlmIChuZWFyTm9kZS5pZCA9PT0gdGhpcy5mcm9tLmlkKSB7XG4gICAgICAgICAgbm9kZSA9IHRoaXMuZnJvbTtcbiAgICAgICAgICBmcm9tID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChsb3cgPD0gaGlnaCAmJiBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zKSB7XG4gICAgICAgICAgdmFyIG1pZGRsZSA9IChsb3cgKyBoaWdoKSAqIDAuNTtcblxuICAgICAgICAgIHBvcyA9IHRoaXMuZ2V0UG9pbnQobWlkZGxlLCB2aWFOb2RlKTtcbiAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIobm9kZS55IC0gcG9zLnksIG5vZGUueCAtIHBvcy54KTtcbiAgICAgICAgICBkaXN0YW5jZVRvQm9yZGVyID0gbm9kZS5kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgICAgICAgIGRpc3RhbmNlVG9Qb2ludCA9IE1hdGguc3FydChNYXRoLnBvdyhwb3MueCAtIG5vZGUueCwgMikgKyBNYXRoLnBvdyhwb3MueSAtIG5vZGUueSwgMikpO1xuICAgICAgICAgIGRpZmZlcmVuY2UgPSBkaXN0YW5jZVRvQm9yZGVyIC0gZGlzdGFuY2VUb1BvaW50O1xuICAgICAgICAgIGlmIChNYXRoLmFicyhkaWZmZXJlbmNlKSA8IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgYnJlYWs7IC8vIGZvdW5kXG4gICAgICAgICAgfSBlbHNlIGlmIChkaWZmZXJlbmNlIDwgMCkge1xuICAgICAgICAgICAgLy8gZGlzdGFuY2UgdG8gbm9kZXMgaXMgbGFyZ2VyIHRoYW4gZGlzdGFuY2UgdG8gYm9yZGVyIC0tPiB0IG5lZWRzIHRvIGJlIGJpZ2dlciBpZiB3ZSdyZSBsb29raW5nIGF0IHRoZSB0byBub2RlLlxuICAgICAgICAgICAgaWYgKGZyb20gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGxvdyA9IG1pZGRsZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhpZ2ggPSBtaWRkbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmcm9tID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBoaWdoID0gbWlkZGxlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbG93ID0gbWlkZGxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGl0ZXJhdGlvbisrO1xuICAgICAgICB9XG4gICAgICAgIHBvcy50ID0gbWlkZGxlO1xuXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgcG9pbnQgKHgzLHkzKSBhbmQgYSBsaW5lIHNlZ21lbnQgZnJvbVxuICAgICAgICogKHgxLHkxKSB0byAoeDIseTIpLlxuICAgICAgICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NDkyMTEvc2hvcnRlc3QtZGlzdGFuY2FlLWJldHdlZW4tYS1wb2ludC1hbmQtYS1saW5lLXNlZ21lbnRcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MSBmcm9tIHhcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MSBmcm9tIHlcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MiB0byB4XG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0geTIgdG8geVxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHgzIHBvaW50IHRvIGNoZWNrIHhcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MyBwb2ludCB0byBjaGVjayB5XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0YW5jZVRvQmV6aWVyRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB2aWEpIHtcbiAgICAgICAgLy8geDMseTMgaXMgdGhlIHBvaW50XG4gICAgICAgIHZhciBtaW5EaXN0YW5jZSA9IDFlOTtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gdm9pZCAwO1xuICAgICAgICB2YXIgaSA9IHZvaWQgMCxcbiAgICAgICAgICAgIHQgPSB2b2lkIDAsXG4gICAgICAgICAgICB4ID0gdm9pZCAwLFxuICAgICAgICAgICAgeSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGxhc3RYID0geDE7XG4gICAgICAgIHZhciBsYXN0WSA9IHkxO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgIHQgPSAwLjEgKiBpO1xuICAgICAgICAgIHggPSBNYXRoLnBvdygxIC0gdCwgMikgKiB4MSArIDIgKiB0ICogKDEgLSB0KSAqIHZpYS54ICsgTWF0aC5wb3codCwgMikgKiB4MjtcbiAgICAgICAgICB5ID0gTWF0aC5wb3coMSAtIHQsIDIpICogeTEgKyAyICogdCAqICgxIC0gdCkgKiB2aWEueSArIE1hdGgucG93KHQsIDIpICogeTI7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IHRoaXMuX2dldERpc3RhbmNlVG9MaW5lKGxhc3RYLCBsYXN0WSwgeCwgeSwgeDMsIHkzKTtcbiAgICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSA/IGRpc3RhbmNlIDogbWluRGlzdGFuY2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhc3RYID0geDtcbiAgICAgICAgICBsYXN0WSA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWluRGlzdGFuY2U7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEJlemllckVkZ2VCYXNlO1xuICB9KF9FZGdlQmFzZTMuZGVmYXVsdCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gQmV6aWVyRWRnZUJhc2U7XG5cbi8qKiovIH0sXG4vKiA5MSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIHZhciBFZGdlQmFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFZGdlQmFzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkZ2VCYXNlKTtcblxuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMubGFiZWxNb2R1bGUgPSBsYWJlbE1vZHVsZTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdGhpcy5jb2xvckRpcnR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuY29sb3IgPSB7fTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uV2lkdGggPSAyO1xuICAgICAgdGhpcy5ob3ZlcldpZHRoID0gMS41O1xuICAgICAgdGhpcy5mcm9tUG9pbnQgPSB0aGlzLmZyb207XG4gICAgICB0aGlzLnRvUG9pbnQgPSB0aGlzLnRvO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhFZGdlQmFzZSwgW3tcbiAgICAgIGtleTogJ2Nvbm5lY3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMuZnJvbV07XG4gICAgICAgIHRoaXMudG8gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5vcHRpb25zLnRvXTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjbGVhbnVwJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuZnJvbSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMuZnJvbV07XG4gICAgICAgIHRoaXMudG8gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5vcHRpb25zLnRvXTtcbiAgICAgICAgdGhpcy5pZCA9IHRoaXMub3B0aW9ucy5pZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZWRyYXcgYSBlZGdlIGFzIGEgbGluZVxuICAgICAgICogRHJhdyB0aGlzIGVkZ2UgaW4gdGhlIGdpdmVuIGNhbnZhc1xuICAgICAgICogVGhlIDJkIGNvbnRleHQgb2YgYSBIVE1MIGNhbnZhcyBjYW4gYmUgcmV0cmlldmVkIGJ5IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gICBjdHhcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RyYXdMaW5lJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3TGluZShjdHgsIHNlbGVjdGVkLCBob3ZlciwgdmlhTm9kZSkge1xuICAgICAgICAvLyBzZXQgc3R5bGVcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5nZXRDb2xvcihjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmdldExpbmVXaWR0aChzZWxlY3RlZCwgaG92ZXIpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGFzaGVzICE9PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuX2RyYXdEYXNoZWRMaW5lKGN0eCwgdmlhTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZHJhd0xpbmUoY3R4LCB2aWFOb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19kcmF3TGluZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdMaW5lKGN0eCwgdmlhTm9kZSwgZnJvbVBvaW50LCB0b1BvaW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZyb20gIT0gdGhpcy50bykge1xuICAgICAgICAgIC8vIGRyYXcgbGluZVxuICAgICAgICAgIHRoaXMuX2xpbmUoY3R4LCB2aWFOb2RlLCBmcm9tUG9pbnQsIHRvUG9pbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfZ2V0Q2lyY2xlRGF0YTIgPSB0aGlzLl9nZXRDaXJjbGVEYXRhKGN0eCksXG4gICAgICAgICAgICAgIF9nZXRDaXJjbGVEYXRhMyA9IF9zbGljZWRUb0FycmF5KF9nZXRDaXJjbGVEYXRhMiwgMyksXG4gICAgICAgICAgICAgIHggPSBfZ2V0Q2lyY2xlRGF0YTNbMF0sXG4gICAgICAgICAgICAgIHkgPSBfZ2V0Q2lyY2xlRGF0YTNbMV0sXG4gICAgICAgICAgICAgIHJhZGl1cyA9IF9nZXRDaXJjbGVEYXRhM1syXTtcblxuICAgICAgICAgIHRoaXMuX2NpcmNsZShjdHgsIHgsIHksIHJhZGl1cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZHJhd0Rhc2hlZExpbmUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3RGFzaGVkTGluZShjdHgsIHZpYU5vZGUsIGZyb21Qb2ludCwgdG9Qb2ludCkge1xuICAgICAgICBjdHgubGluZUNhcCA9ICdyb3VuZCc7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gWzUsIDVdO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMuZGFzaGVzKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLm9wdGlvbnMuZGFzaGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb25seSBmaXJlZm94IGFuZCBjaHJvbWUgc3VwcG9ydCB0aGlzIG1ldGhvZCwgZWxzZSB3ZSB1c2UgdGhlIGxlZ2FjeSBvbmUuXG4gICAgICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgICAvLyBzZXQgZGFzaCBzZXR0aW5ncyBmb3IgY2hyb21lIG9yIGZpcmVmb3hcbiAgICAgICAgICBjdHguc2V0TGluZURhc2gocGF0dGVybik7XG4gICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gMDtcblxuICAgICAgICAgIC8vIGRyYXcgdGhlIGxpbmVcbiAgICAgICAgICBpZiAodGhpcy5mcm9tICE9IHRoaXMudG8pIHtcbiAgICAgICAgICAgIC8vIGRyYXcgbGluZVxuICAgICAgICAgICAgdGhpcy5fbGluZShjdHgsIHZpYU5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgX2dldENpcmNsZURhdGE0ID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YShjdHgpLFxuICAgICAgICAgICAgICAgIF9nZXRDaXJjbGVEYXRhNSA9IF9zbGljZWRUb0FycmF5KF9nZXRDaXJjbGVEYXRhNCwgMyksXG4gICAgICAgICAgICAgICAgeCA9IF9nZXRDaXJjbGVEYXRhNVswXSxcbiAgICAgICAgICAgICAgICB5ID0gX2dldENpcmNsZURhdGE1WzFdLFxuICAgICAgICAgICAgICAgIHJhZGl1cyA9IF9nZXRDaXJjbGVEYXRhNVsyXTtcblxuICAgICAgICAgICAgdGhpcy5fY2lyY2xlKGN0eCwgeCwgeSwgcmFkaXVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyByZXN0b3JlIHRoZSBkYXNoIHNldHRpbmdzLlxuICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChbMF0pO1xuICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IDA7XG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1bnN1cHBvcnRpbmcgc21vb3RoIGxpbmVzXG4gICAgICAgICAgaWYgKHRoaXMuZnJvbSAhPSB0aGlzLnRvKSB7XG4gICAgICAgICAgICAvLyBkcmF3IGxpbmVcbiAgICAgICAgICAgIGN0eC5kYXNoZWRMaW5lKHRoaXMuZnJvbS54LCB0aGlzLmZyb20ueSwgdGhpcy50by54LCB0aGlzLnRvLnksIHBhdHRlcm4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgX2dldENpcmNsZURhdGE2ID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YShjdHgpLFxuICAgICAgICAgICAgICAgIF9nZXRDaXJjbGVEYXRhNyA9IF9zbGljZWRUb0FycmF5KF9nZXRDaXJjbGVEYXRhNiwgMyksXG4gICAgICAgICAgICAgICAgX3ggPSBfZ2V0Q2lyY2xlRGF0YTdbMF0sXG4gICAgICAgICAgICAgICAgX3kgPSBfZ2V0Q2lyY2xlRGF0YTdbMV0sXG4gICAgICAgICAgICAgICAgX3JhZGl1cyA9IF9nZXRDaXJjbGVEYXRhN1syXTtcblxuICAgICAgICAgICAgdGhpcy5fY2lyY2xlKGN0eCwgX3gsIF95LCBfcmFkaXVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCk7XG5cbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgICAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuICAgICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZmluZEJvcmRlclBvc2l0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQm9yZGVyUG9zaXRpb24obmVhck5vZGUsIGN0eCwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5mcm9tICE9IHRoaXMudG8pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uKG5lYXJOb2RlLCBjdHgsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUobmVhck5vZGUsIGN0eCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdmaW5kQm9yZGVyUG9zaXRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQm9yZGVyUG9zaXRpb25zKGN0eCkge1xuICAgICAgICB2YXIgZnJvbSA9IHt9O1xuICAgICAgICB2YXIgdG8gPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuZnJvbSAhPSB0aGlzLnRvKSB7XG4gICAgICAgICAgZnJvbSA9IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbih0aGlzLmZyb20sIGN0eCk7XG4gICAgICAgICAgdG8gPSB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb24odGhpcy50bywgY3R4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2dldENpcmNsZURhdGE4ID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YShjdHgpLFxuICAgICAgICAgICAgICBfZ2V0Q2lyY2xlRGF0YTkgPSBfc2xpY2VkVG9BcnJheShfZ2V0Q2lyY2xlRGF0YTgsIDMpLFxuICAgICAgICAgICAgICB4ID0gX2dldENpcmNsZURhdGE5WzBdLFxuICAgICAgICAgICAgICB5ID0gX2dldENpcmNsZURhdGE5WzFdLFxuICAgICAgICAgICAgICByYWRpdXMgPSBfZ2V0Q2lyY2xlRGF0YTlbMl07XG5cbiAgICAgICAgICBmcm9tID0gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlKHRoaXMuZnJvbSwgY3R4LCB7IHg6IHgsIHk6IHksIGxvdzogMC4yNSwgaGlnaDogMC42LCBkaXJlY3Rpb246IC0xIH0pO1xuICAgICAgICAgIHRvID0gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlKHRoaXMuZnJvbSwgY3R4LCB7IHg6IHgsIHk6IHksIGxvdzogMC42LCBoaWdoOiAwLjgsIGRpcmVjdGlvbjogMSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmcm9tOiBmcm9tLCB0bzogdG8gfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0Q2lyY2xlRGF0YScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENpcmNsZURhdGEoY3R4KSB7XG4gICAgICAgIHZhciB4ID0gdm9pZCAwLFxuICAgICAgICAgICAgeSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmZyb207XG4gICAgICAgIHZhciByYWRpdXMgPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZVNpemU7XG5cbiAgICAgICAgaWYgKGN0eCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG5vZGUuc2hhcGUud2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9kZS5zaGFwZS5yZXNpemUoY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgY2lyY2xlIGNvb3JkaW5hdGVzXG4gICAgICAgIGlmIChub2RlLnNoYXBlLndpZHRoID4gbm9kZS5zaGFwZS5oZWlnaHQpIHtcbiAgICAgICAgICB4ID0gbm9kZS54ICsgbm9kZS5zaGFwZS53aWR0aCAqIDAuNTtcbiAgICAgICAgICB5ID0gbm9kZS55IC0gcmFkaXVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHggPSBub2RlLnggKyByYWRpdXM7XG4gICAgICAgICAgeSA9IG5vZGUueSAtIG5vZGUuc2hhcGUuaGVpZ2h0ICogMC41O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbeCwgeSwgcmFkaXVzXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgYSBwb2ludCBvbiBhIGNpcmNsZVxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gcGVyY2VudGFnZS4gVmFsdWUgYmV0d2VlbiAwIChsaW5lIHN0YXJ0KSBhbmQgMSAobGluZSBlbmQpXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHBvaW50XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcG9pbnRPbkNpcmNsZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3BvaW50T25DaXJjbGUoeCwgeSwgcmFkaXVzLCBwZXJjZW50YWdlKSB7XG4gICAgICAgIHZhciBhbmdsZSA9IHBlcmNlbnRhZ2UgKiAyICogTWF0aC5QSTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB4ICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgIHk6IHkgLSByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGZ1bmN0aW9uIHVzZXMgYmluYXJ5IHNlYXJjaCB0byBsb29rIGZvciB0aGUgcG9pbnQgd2hlcmUgdGhlIGNpcmNsZSBjcm9zc2VzIHRoZSBib3JkZXIgb2YgdGhlIG5vZGUuXG4gICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICogQHBhcmFtIGN0eFxuICAgICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZShub2RlLCBjdHgsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHggPSBvcHRpb25zLng7XG4gICAgICAgIHZhciB5ID0gb3B0aW9ucy55O1xuICAgICAgICB2YXIgbG93ID0gb3B0aW9ucy5sb3c7XG4gICAgICAgIHZhciBoaWdoID0gb3B0aW9ucy5oaWdoO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gb3B0aW9ucy5kaXJlY3Rpb247XG5cbiAgICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSAxMDtcbiAgICAgICAgdmFyIGl0ZXJhdGlvbiA9IDA7XG4gICAgICAgIHZhciByYWRpdXMgPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZVNpemU7XG4gICAgICAgIHZhciBwb3MgPSB2b2lkIDAsXG4gICAgICAgICAgICBhbmdsZSA9IHZvaWQgMCxcbiAgICAgICAgICAgIGRpc3RhbmNlVG9Cb3JkZXIgPSB2b2lkIDAsXG4gICAgICAgICAgICBkaXN0YW5jZVRvUG9pbnQgPSB2b2lkIDAsXG4gICAgICAgICAgICBkaWZmZXJlbmNlID0gdm9pZCAwO1xuICAgICAgICB2YXIgdGhyZXNob2xkID0gMC4wNTtcbiAgICAgICAgdmFyIG1pZGRsZSA9IChsb3cgKyBoaWdoKSAqIDAuNTtcblxuICAgICAgICB3aGlsZSAobG93IDw9IGhpZ2ggJiYgaXRlcmF0aW9uIDwgbWF4SXRlcmF0aW9ucykge1xuICAgICAgICAgIG1pZGRsZSA9IChsb3cgKyBoaWdoKSAqIDAuNTtcblxuICAgICAgICAgIHBvcyA9IHRoaXMuX3BvaW50T25DaXJjbGUoeCwgeSwgcmFkaXVzLCBtaWRkbGUpO1xuICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMihub2RlLnkgLSBwb3MueSwgbm9kZS54IC0gcG9zLngpO1xuICAgICAgICAgIGRpc3RhbmNlVG9Cb3JkZXIgPSBub2RlLmRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgICAgICAgZGlzdGFuY2VUb1BvaW50ID0gTWF0aC5zcXJ0KE1hdGgucG93KHBvcy54IC0gbm9kZS54LCAyKSArIE1hdGgucG93KHBvcy55IC0gbm9kZS55LCAyKSk7XG4gICAgICAgICAgZGlmZmVyZW5jZSA9IGRpc3RhbmNlVG9Cb3JkZXIgLSBkaXN0YW5jZVRvUG9pbnQ7XG4gICAgICAgICAgaWYgKE1hdGguYWJzKGRpZmZlcmVuY2UpIDwgdGhyZXNob2xkKSB7XG4gICAgICAgICAgICBicmVhazsgLy8gZm91bmRcbiAgICAgICAgICB9IGVsc2UgaWYgKGRpZmZlcmVuY2UgPiAwKSB7XG4gICAgICAgICAgICAvLyBkaXN0YW5jZSB0byBub2RlcyBpcyBsYXJnZXIgdGhhbiBkaXN0YW5jZSB0byBib3JkZXIgLS0+IHQgbmVlZHMgdG8gYmUgYmlnZ2VyIGlmIHdlJ3JlIGxvb2tpbmcgYXQgdGhlIHRvIG5vZGUuXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID4gMCkge1xuICAgICAgICAgICAgICBsb3cgPSBtaWRkbGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBoaWdoID0gbWlkZGxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID4gMCkge1xuICAgICAgICAgICAgICBoaWdoID0gbWlkZGxlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbG93ID0gbWlkZGxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVyYXRpb24rKztcbiAgICAgICAgfVxuICAgICAgICBwb3MudCA9IG1pZGRsZTtcblxuICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCB0aGUgbGluZSB3aWR0aCBvZiB0aGUgZWRnZS4gRGVwZW5kcyBvbiB3aWR0aCBhbmQgd2hldGhlciBvbmUgb2YgdGhlXG4gICAgICAgKiBjb25uZWN0ZWQgbm9kZXMgaXMgc2VsZWN0ZWQuXG4gICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHdpZHRoXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRMaW5lV2lkdGgnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldExpbmVXaWR0aChzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgICAgaWYgKHNlbGVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuc2VsZWN0aW9uV2lkdGgsIDAuMyAvIHRoaXMuYm9keS52aWV3LnNjYWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaG92ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmhvdmVyV2lkdGgsIDAuMyAvIHRoaXMuYm9keS52aWV3LnNjYWxlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMub3B0aW9ucy53aWR0aCwgMC4zIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldENvbG9yJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb2xvcihjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgICB2YXIgY29sb3JPcHRpb25zID0gdGhpcy5vcHRpb25zLmNvbG9yO1xuICAgICAgICBpZiAoY29sb3JPcHRpb25zLmluaGVyaXQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gd2hlbiB0aGlzIGlzIGEgbG9vcCBlZGdlLCBqdXN0IHVzZSB0aGUgJ2Zyb20nIG1ldGhvZFxuICAgICAgICAgIGlmIChjb2xvck9wdGlvbnMuaW5oZXJpdCA9PT0gJ2JvdGgnICYmIHRoaXMuZnJvbS5pZCAhPT0gdGhpcy50by5pZCkge1xuICAgICAgICAgICAgdmFyIGdyZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh0aGlzLmZyb20ueCwgdGhpcy5mcm9tLnksIHRoaXMudG8ueCwgdGhpcy50by55KTtcbiAgICAgICAgICAgIHZhciBmcm9tQ29sb3IgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgdG9Db2xvciA9IHZvaWQgMDtcbiAgICAgICAgICAgIGZyb21Db2xvciA9IHRoaXMuZnJvbS5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5ib3JkZXI7XG4gICAgICAgICAgICB0b0NvbG9yID0gdGhpcy50by5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5ib3JkZXI7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmZyb20uc2VsZWN0ZWQgPT09IGZhbHNlICYmIHRoaXMudG8uc2VsZWN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGZyb21Db2xvciA9IHV0aWwub3ZlcnJpZGVPcGFjaXR5KHRoaXMuZnJvbS5vcHRpb25zLmNvbG9yLmJvcmRlciwgdGhpcy5vcHRpb25zLmNvbG9yLm9wYWNpdHkpO1xuICAgICAgICAgICAgICB0b0NvbG9yID0gdXRpbC5vdmVycmlkZU9wYWNpdHkodGhpcy50by5vcHRpb25zLmNvbG9yLmJvcmRlciwgdGhpcy5vcHRpb25zLmNvbG9yLm9wYWNpdHkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZyb20uc2VsZWN0ZWQgPT09IHRydWUgJiYgdGhpcy50by5zZWxlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgdG9Db2xvciA9IHRoaXMudG8ub3B0aW9ucy5jb2xvci5ib3JkZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZnJvbS5zZWxlY3RlZCA9PT0gZmFsc2UgJiYgdGhpcy50by5zZWxlY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBmcm9tQ29sb3IgPSB0aGlzLmZyb20ub3B0aW9ucy5jb2xvci5ib3JkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmQuYWRkQ29sb3JTdG9wKDAsIGZyb21Db2xvcik7XG4gICAgICAgICAgICBncmQuYWRkQ29sb3JTdG9wKDEsIHRvQ29sb3IpO1xuXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLSB0aGlzIHJldHVybnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cbiAgICAgICAgICAgIHJldHVybiBncmQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuY29sb3JEaXJ0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGNvbG9yT3B0aW9ucy5pbmhlcml0ID09PSBcInRvXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5jb2xvci5oaWdobGlnaHQgPSB0aGlzLnRvLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlcjtcbiAgICAgICAgICAgICAgdGhpcy5jb2xvci5ob3ZlciA9IHRoaXMudG8ub3B0aW9ucy5jb2xvci5ob3Zlci5ib3JkZXI7XG4gICAgICAgICAgICAgIHRoaXMuY29sb3IuY29sb3IgPSB1dGlsLm92ZXJyaWRlT3BhY2l0eSh0aGlzLnRvLm9wdGlvbnMuY29sb3IuYm9yZGVyLCBjb2xvck9wdGlvbnMub3BhY2l0eSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyAodGhpcy5vcHRpb25zLmNvbG9yLmluaGVyaXQuc291cmNlID09PSBcImZyb21cIikge1xuICAgICAgICAgICAgICB0aGlzLmNvbG9yLmhpZ2hsaWdodCA9IHRoaXMuZnJvbS5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5ib3JkZXI7XG4gICAgICAgICAgICAgIHRoaXMuY29sb3IuaG92ZXIgPSB0aGlzLmZyb20ub3B0aW9ucy5jb2xvci5ob3Zlci5ib3JkZXI7XG4gICAgICAgICAgICAgIHRoaXMuY29sb3IuY29sb3IgPSB1dGlsLm92ZXJyaWRlT3BhY2l0eSh0aGlzLmZyb20ub3B0aW9ucy5jb2xvci5ib3JkZXIsIGNvbG9yT3B0aW9ucy5vcGFjaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb2xvckRpcnR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5jb2xvci5oaWdobGlnaHQgPSBjb2xvck9wdGlvbnMuaGlnaGxpZ2h0O1xuICAgICAgICAgIHRoaXMuY29sb3IuaG92ZXIgPSBjb2xvck9wdGlvbnMuaG92ZXI7XG4gICAgICAgICAgdGhpcy5jb2xvci5jb2xvciA9IHV0aWwub3ZlcnJpZGVPcGFjaXR5KGNvbG9yT3B0aW9ucy5jb2xvciwgY29sb3JPcHRpb25zLm9wYWNpdHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgY29sb3IgaW5oZXJpdCBpcyBvbiBhbmQgZ3JhZGllbnRzIGFyZSB1c2VkLCB0aGUgZnVuY3Rpb24gaGFzIGFscmVhZHkgcmV0dXJuZWQgYnkgbm93LlxuICAgICAgICB0aGlzLmNvbG9yRGlydHkgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc2VsZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb2xvci5oaWdobGlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaG92ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb2xvci5ob3ZlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb2xvci5jb2xvcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERyYXcgYSBsaW5lIGZyb20gYSBub2RlIHRvIGl0c2VsZiwgYSBjaXJjbGVcbiAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NpcmNsZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NpcmNsZShjdHgsIHgsIHksIHJhZGl1cykge1xuICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCk7XG5cbiAgICAgICAgLy8gZHJhdyBhIGNpcmNsZVxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgcG9pbnQgKHgzLHkzKSBhbmQgYSBsaW5lIHNlZ21lbnQgZnJvbVxuICAgICAgICogKHgxLHkxKSB0byAoeDIseTIpLlxuICAgICAgICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NDkyMTEvc2hvcnRlc3QtZGlzdGFuY2FlLWJldHdlZW4tYS1wb2ludC1hbmQtYS1saW5lLXNlZ21lbnRcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0geDJcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0geTNcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldERpc3RhbmNlVG9FZGdlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaXN0YW5jZVRvRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB2aWEpIHtcbiAgICAgICAgLy8geDMseTMgaXMgdGhlIHBvaW50XG4gICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IDA7XG4gICAgICAgIGlmICh0aGlzLmZyb20gIT0gdGhpcy50bykge1xuICAgICAgICAgIHJldHVyblZhbHVlID0gdGhpcy5fZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdmlhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2dldENpcmNsZURhdGExMCA9IHRoaXMuX2dldENpcmNsZURhdGEoKSxcbiAgICAgICAgICAgICAgX2dldENpcmNsZURhdGExMSA9IF9zbGljZWRUb0FycmF5KF9nZXRDaXJjbGVEYXRhMTAsIDMpLFxuICAgICAgICAgICAgICB4ID0gX2dldENpcmNsZURhdGExMVswXSxcbiAgICAgICAgICAgICAgeSA9IF9nZXRDaXJjbGVEYXRhMTFbMV0sXG4gICAgICAgICAgICAgIHJhZGl1cyA9IF9nZXRDaXJjbGVEYXRhMTFbMl07XG5cbiAgICAgICAgICB2YXIgZHggPSB4IC0geDM7XG4gICAgICAgICAgdmFyIGR5ID0geSAtIHkzO1xuICAgICAgICAgIHJldHVyblZhbHVlID0gTWF0aC5hYnMoTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSAtIHJhZGl1cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQgPCB4MyAmJiB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCA+IHgzICYmIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS50b3AgPCB5MyAmJiB0aGlzLmxhYmVsTW9kdWxlLnNpemUudG9wICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmhlaWdodCA+IHkzKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldERpc3RhbmNlVG9MaW5lJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0xpbmUoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgICB2YXIgcHggPSB4MiAtIHgxO1xuICAgICAgICB2YXIgcHkgPSB5MiAtIHkxO1xuICAgICAgICB2YXIgc29tZXRoaW5nID0gcHggKiBweCArIHB5ICogcHk7XG4gICAgICAgIHZhciB1ID0gKCh4MyAtIHgxKSAqIHB4ICsgKHkzIC0geTEpICogcHkpIC8gc29tZXRoaW5nO1xuXG4gICAgICAgIGlmICh1ID4gMSkge1xuICAgICAgICAgIHUgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHUgPCAwKSB7XG4gICAgICAgICAgdSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeCA9IHgxICsgdSAqIHB4O1xuICAgICAgICB2YXIgeSA9IHkxICsgdSAqIHB5O1xuICAgICAgICB2YXIgZHggPSB4IC0geDM7XG4gICAgICAgIHZhciBkeSA9IHkgLSB5MztcblxuICAgICAgICAvLyMgTm90ZTogSWYgdGhlIGFjdHVhbCBkaXN0YW5jZSBkb2VzIG5vdCBtYXR0ZXIsXG4gICAgICAgIC8vIyBpZiB5b3Ugb25seSB3YW50IHRvIGNvbXBhcmUgd2hhdCB0aGlzIGZ1bmN0aW9uXG4gICAgICAgIC8vIyByZXR1cm5zIHRvIG90aGVyIHJlc3VsdHMgb2YgdGhpcyBmdW5jdGlvbiwgeW91XG4gICAgICAgIC8vIyBjYW4ganVzdCByZXR1cm4gdGhlIHNxdWFyZWQgZGlzdGFuY2UgaW5zdGVhZFxuICAgICAgICAvLyMgKGkuZS4gcmVtb3ZlIHRoZSBzcXJ0KSB0byBnYWluIGEgbGl0dGxlIHBlcmZvcm1hbmNlXG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBjdHhcbiAgICAgICAqIEBwYXJhbSBwb3NpdGlvblxuICAgICAgICogQHBhcmFtIHZpYU5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0QXJyb3dEYXRhJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBcnJvd0RhdGEoY3R4LCBwb3NpdGlvbiwgdmlhTm9kZSwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICAgIC8vIHNldCBsZXRzXG4gICAgICAgIHZhciBhbmdsZSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGFycm93UG9pbnQgPSB2b2lkIDA7XG4gICAgICAgIHZhciBub2RlMSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIG5vZGUyID0gdm9pZCAwO1xuICAgICAgICB2YXIgZ3VpZGVPZmZzZXQgPSB2b2lkIDA7XG4gICAgICAgIHZhciBzY2FsZUZhY3RvciA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHR5cGUgPSB2b2lkIDA7XG4gICAgICAgIHZhciBsaW5lV2lkdGggPSB0aGlzLmdldExpbmVXaWR0aChzZWxlY3RlZCwgaG92ZXIpO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2Zyb20nKSB7XG4gICAgICAgICAgbm9kZTEgPSB0aGlzLmZyb207XG4gICAgICAgICAgbm9kZTIgPSB0aGlzLnRvO1xuICAgICAgICAgIGd1aWRlT2Zmc2V0ID0gMC4xO1xuICAgICAgICAgIHNjYWxlRmFjdG9yID0gdGhpcy5vcHRpb25zLmFycm93cy5mcm9tLnNjYWxlRmFjdG9yO1xuICAgICAgICAgIHR5cGUgPSB0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20udHlwZTtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3RvJykge1xuICAgICAgICAgIG5vZGUxID0gdGhpcy50bztcbiAgICAgICAgICBub2RlMiA9IHRoaXMuZnJvbTtcbiAgICAgICAgICBndWlkZU9mZnNldCA9IC0wLjE7XG4gICAgICAgICAgc2NhbGVGYWN0b3IgPSB0aGlzLm9wdGlvbnMuYXJyb3dzLnRvLnNjYWxlRmFjdG9yO1xuICAgICAgICAgIHR5cGUgPSB0aGlzLm9wdGlvbnMuYXJyb3dzLnRvLnR5cGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZTEgPSB0aGlzLnRvO1xuICAgICAgICAgIG5vZGUyID0gdGhpcy5mcm9tO1xuICAgICAgICAgIHNjYWxlRmFjdG9yID0gdGhpcy5vcHRpb25zLmFycm93cy5taWRkbGUuc2NhbGVGYWN0b3I7XG4gICAgICAgICAgdHlwZSA9IHRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlLnR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBub3QgY29ubmVjdGVkIHRvIGl0c2VsZlxuICAgICAgICBpZiAobm9kZTEgIT0gbm9kZTIpIHtcbiAgICAgICAgICBpZiAocG9zaXRpb24gIT09ICdtaWRkbGUnKSB7XG4gICAgICAgICAgICAvLyBkcmF3IGFycm93IGhlYWRcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc21vb3RoLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgYXJyb3dQb2ludCA9IHRoaXMuZmluZEJvcmRlclBvc2l0aW9uKG5vZGUxLCBjdHgsIHsgdmlhOiB2aWFOb2RlIH0pO1xuICAgICAgICAgICAgICB2YXIgZ3VpZGVQb3MgPSB0aGlzLmdldFBvaW50KE1hdGgubWF4KDAuMCwgTWF0aC5taW4oMS4wLCBhcnJvd1BvaW50LnQgKyBndWlkZU9mZnNldCkpLCB2aWFOb2RlKTtcbiAgICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKGFycm93UG9pbnQueSAtIGd1aWRlUG9zLnksIGFycm93UG9pbnQueCAtIGd1aWRlUG9zLngpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKG5vZGUxLnkgLSBub2RlMi55LCBub2RlMS54IC0gbm9kZTIueCk7XG4gICAgICAgICAgICAgIGFycm93UG9pbnQgPSB0aGlzLmZpbmRCb3JkZXJQb3NpdGlvbihub2RlMSwgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKG5vZGUxLnkgLSBub2RlMi55LCBub2RlMS54IC0gbm9kZTIueCk7XG4gICAgICAgICAgICBhcnJvd1BvaW50ID0gdGhpcy5nZXRQb2ludCgwLjUsIHZpYU5vZGUpOyAvLyB0aGlzIGlzIDAuNiB0byBhY2NvdW50IGZvciB0aGUgc2l6ZSBvZiB0aGUgYXJyb3cuXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRyYXcgY2lyY2xlXG4gICAgICAgICAgdmFyIF9nZXRDaXJjbGVEYXRhMTIgPSB0aGlzLl9nZXRDaXJjbGVEYXRhKGN0eCksXG4gICAgICAgICAgICAgIF9nZXRDaXJjbGVEYXRhMTMgPSBfc2xpY2VkVG9BcnJheShfZ2V0Q2lyY2xlRGF0YTEyLCAzKSxcbiAgICAgICAgICAgICAgeCA9IF9nZXRDaXJjbGVEYXRhMTNbMF0sXG4gICAgICAgICAgICAgIHkgPSBfZ2V0Q2lyY2xlRGF0YTEzWzFdLFxuICAgICAgICAgICAgICByYWRpdXMgPSBfZ2V0Q2lyY2xlRGF0YTEzWzJdO1xuXG4gICAgICAgICAgaWYgKHBvc2l0aW9uID09PSAnZnJvbScpIHtcbiAgICAgICAgICAgIGFycm93UG9pbnQgPSB0aGlzLmZpbmRCb3JkZXJQb3NpdGlvbih0aGlzLmZyb20sIGN0eCwgeyB4OiB4LCB5OiB5LCBsb3c6IDAuMjUsIGhpZ2g6IDAuNiwgZGlyZWN0aW9uOiAtMSB9KTtcbiAgICAgICAgICAgIGFuZ2xlID0gYXJyb3dQb2ludC50ICogLTIgKiBNYXRoLlBJICsgMS41ICogTWF0aC5QSSArIDAuMSAqIE1hdGguUEk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3RvJykge1xuICAgICAgICAgICAgYXJyb3dQb2ludCA9IHRoaXMuZmluZEJvcmRlclBvc2l0aW9uKHRoaXMuZnJvbSwgY3R4LCB7IHg6IHgsIHk6IHksIGxvdzogMC42LCBoaWdoOiAxLjAsIGRpcmVjdGlvbjogMSB9KTtcbiAgICAgICAgICAgIGFuZ2xlID0gYXJyb3dQb2ludC50ICogLTIgKiBNYXRoLlBJICsgMS41ICogTWF0aC5QSSAtIDEuMSAqIE1hdGguUEk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycm93UG9pbnQgPSB0aGlzLl9wb2ludE9uQ2lyY2xlKHgsIHksIHJhZGl1cywgMC4xNzUpO1xuICAgICAgICAgICAgYW5nbGUgPSAzLjkyNjk5MDgxNjk4NzI0MTQ7IC8vID09PSAwLjE3NSAqIC0yICogTWF0aC5QSSArIDEuNSAqIE1hdGguUEkgKyAwLjEgKiBNYXRoLlBJO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGggPSAxNSAqIHNjYWxlRmFjdG9yICsgMyAqIGxpbmVXaWR0aDsgLy8gMyogbGluZVdpZHRoIGlzIHRoZSB3aWR0aCBvZiB0aGUgZWRnZS5cblxuICAgICAgICB2YXIgeGkgPSBhcnJvd1BvaW50LnggLSBsZW5ndGggKiAwLjkgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIHZhciB5aSA9IGFycm93UG9pbnQueSAtIGxlbmd0aCAqIDAuOSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgdmFyIGFycm93Q29yZSA9IHsgeDogeGksIHk6IHlpIH07XG5cbiAgICAgICAgcmV0dXJuIHsgcG9pbnQ6IGFycm93UG9pbnQsIGNvcmU6IGFycm93Q29yZSwgYW5nbGU6IGFuZ2xlLCBsZW5ndGg6IGxlbmd0aCwgdHlwZTogdHlwZSB9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gY3R4XG4gICAgICAgKiBAcGFyYW0gc2VsZWN0ZWRcbiAgICAgICAqIEBwYXJhbSBob3ZlclxuICAgICAgICogQHBhcmFtIGFycm93RGF0YVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkcmF3QXJyb3dIZWFkJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QXJyb3dIZWFkKGN0eCwgc2VsZWN0ZWQsIGhvdmVyLCBhcnJvd0RhdGEpIHtcbiAgICAgICAgLy8gc2V0IHN0eWxlXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuZ2V0Q29sb3IoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gY3R4LnN0cm9rZVN0eWxlO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5nZXRMaW5lV2lkdGgoc2VsZWN0ZWQsIGhvdmVyKTtcblxuICAgICAgICBpZiAoYXJyb3dEYXRhLnR5cGUgJiYgYXJyb3dEYXRhLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2NpcmNsZScpIHtcbiAgICAgICAgICAvLyBkcmF3IGNpcmNsZSBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lXG4gICAgICAgICAgY3R4LmNpcmNsZUVuZHBvaW50KGFycm93RGF0YS5wb2ludC54LCBhcnJvd0RhdGEucG9pbnQueSwgYXJyb3dEYXRhLmFuZ2xlLCBhcnJvd0RhdGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkcmF3IGFycm93IGF0IHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICAgICAgICBjdHguYXJyb3dFbmRwb2ludChhcnJvd0RhdGEucG9pbnQueCwgYXJyb3dEYXRhLnBvaW50LnksIGFycm93RGF0YS5hbmdsZSwgYXJyb3dEYXRhLmxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG4gICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2VuYWJsZVNoYWRvdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlU2hhZG93KGN0eCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gdGhpcy5vcHRpb25zLnNoYWRvdy5jb2xvcjtcbiAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IHRoaXMub3B0aW9ucy5zaGFkb3cuc2l6ZTtcbiAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHRoaXMub3B0aW9ucy5zaGFkb3cueDtcbiAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHRoaXMub3B0aW9ucy5zaGFkb3cueTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rpc2FibGVTaGFkb3cnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVTaGFkb3coY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSAwO1xuICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRWRnZUJhc2U7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBFZGdlQmFzZTtcblxuLyoqKi8gfSxcbi8qIDkyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICBcInVzZSBzdHJpY3RcIjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX0JlemllckVkZ2VCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oOTApO1xuXG4gIHZhciBfQmV6aWVyRWRnZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmV6aWVyRWRnZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIEJlemllckVkZ2VEeW5hbWljID0gZnVuY3Rpb24gKF9CZXppZXJFZGdlQmFzZSkge1xuICAgIF9pbmhlcml0cyhCZXppZXJFZGdlRHluYW1pYywgX0JlemllckVkZ2VCYXNlKTtcblxuICAgIGZ1bmN0aW9uIEJlemllckVkZ2VEeW5hbWljKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmV6aWVyRWRnZUR5bmFtaWMpO1xuXG4gICAgICAvLyAtLT4gdGhpcyBjYWxscyB0aGUgc2V0T3B0aW9ucyBiZWxvd1xuICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJlemllckVkZ2VEeW5hbWljLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmV6aWVyRWRnZUR5bmFtaWMpKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG4gICAgICAvL3RoaXMudmlhID0gdW5kZWZpbmVkOyAvLyBIZXJlIGZvciBjb21wbGV0ZW5lc3MgYnV0IG5vdCBhbGxvd2VkIHRvIGRlZmluZWQgYmVmb3JlIHN1cGVyKCkgaXMgaW52b2tlZC5cblxuXG4gICAgICBfdGhpcy5fYm91bmRGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMucG9zaXRpb25CZXppZXJOb2RlKCk7XG4gICAgICB9O1xuICAgICAgX3RoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3JlcG9zaXRpb25CZXppZXJOb2Rlc1wiLCBfdGhpcy5fYm91bmRGdW5jdGlvbik7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEJlemllckVkZ2VEeW5hbWljLCBbe1xuICAgICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHBoeXNpY3MgaGFzIGNoYW5nZWQuXG4gICAgICAgIHZhciBwaHlzaWNzQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGh5c2ljcyAhPT0gb3B0aW9ucy5waHlzaWNzKSB7XG4gICAgICAgICAgcGh5c2ljc0NoYW5nZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdGhlIG9wdGlvbnMgYW5kIHRoZSB0byBhbmQgZnJvbSBub2Rlc1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmlkID0gdGhpcy5vcHRpb25zLmlkO1xuICAgICAgICB0aGlzLmZyb20gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5vcHRpb25zLmZyb21dO1xuICAgICAgICB0aGlzLnRvID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy50b107XG5cbiAgICAgICAgLy8gc2V0dXAgdGhlIHN1cHBvcnQgbm9kZSBhbmQgY29ubmVjdFxuICAgICAgICB0aGlzLnNldHVwU3VwcG9ydE5vZGUoKTtcbiAgICAgICAgdGhpcy5jb25uZWN0KCk7XG5cbiAgICAgICAgLy8gd2hlbiB3ZSBjaGFuZ2UgdGhlIHBoeXNpY3Mgc3RhdGUgb2YgdGhlIGVkZ2UsIHdlIHJlcG9zaXRpb24gdGhlIHN1cHBvcnQgbm9kZS5cbiAgICAgICAgaWYgKHBoeXNpY3NDaGFuZ2UgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnZpYS5zZXRPcHRpb25zKHsgcGh5c2ljczogdGhpcy5vcHRpb25zLnBoeXNpY3MgfSk7XG4gICAgICAgICAgdGhpcy5wb3NpdGlvbkJlemllck5vZGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjb25uZWN0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy5mcm9tXTtcbiAgICAgICAgdGhpcy50byA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMudG9dO1xuICAgICAgICBpZiAodGhpcy5mcm9tID09PSB1bmRlZmluZWQgfHwgdGhpcy50byA9PT0gdW5kZWZpbmVkIHx8IHRoaXMub3B0aW9ucy5waHlzaWNzID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMudmlhLnNldE9wdGlvbnMoeyBwaHlzaWNzOiBmYWxzZSB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmaXggd2VpcmQgYmVoYXZpb3VyIHdoZXJlIGEgc2VsZiByZWZlcmVuY2luZyBub2RlIGhhcyBwaHlzaWNzIGVuYWJsZWRcbiAgICAgICAgICBpZiAodGhpcy5mcm9tLmlkID09PSB0aGlzLnRvLmlkKSB7XG4gICAgICAgICAgICB0aGlzLnZpYS5zZXRPcHRpb25zKHsgcGh5c2ljczogZmFsc2UgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmlhLnNldE9wdGlvbnMoeyBwaHlzaWNzOiB0cnVlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHJlbW92ZSB0aGUgc3VwcG9ydCBub2Rlc1xuICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbGVhbnVwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKFwiX3JlcG9zaXRpb25CZXppZXJOb2Rlc1wiLCB0aGlzLl9ib3VuZEZ1bmN0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMudmlhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5ib2R5Lm5vZGVzW3RoaXMudmlhLmlkXTtcbiAgICAgICAgICB0aGlzLnZpYSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQmV6aWVyIGN1cnZlcyByZXF1aXJlIGFuIGFuY2hvciBwb2ludCB0byBjYWxjdWxhdGUgdGhlIHNtb290aCBmbG93LiBUaGVzZSBwb2ludHMgYXJlIG5vZGVzLiBUaGVzZSBub2RlcyBhcmUgaW52aXNpYmxlIGJ1dFxuICAgICAgICogYXJlIHVzZWQgZm9yIHRoZSBmb3JjZSBjYWxjdWxhdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgY2hhbmdlZCBkYXRhIGlzIG5vdCBjYWxsZWQsIGlmIG5lZWRlZCwgaXQgaXMgcmV0dXJuZWQgYnkgdGhlIG1haW4gZWRnZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXR1cFN1cHBvcnROb2RlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBTdXBwb3J0Tm9kZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmlhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgbm9kZUlkID0gXCJlZGdlSWQ6XCIgKyB0aGlzLmlkO1xuICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVOb2RlKHtcbiAgICAgICAgICAgIGlkOiBub2RlSWQsXG4gICAgICAgICAgICBzaGFwZTogJ2NpcmNsZScsXG4gICAgICAgICAgICBwaHlzaWNzOiB0cnVlLFxuICAgICAgICAgICAgaGlkZGVuOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gPSBub2RlO1xuICAgICAgICAgIHRoaXMudmlhID0gbm9kZTtcbiAgICAgICAgICB0aGlzLnZpYS5wYXJlbnRFZGdlSWQgPSB0aGlzLmlkO1xuICAgICAgICAgIHRoaXMucG9zaXRpb25CZXppZXJOb2RlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicG9zaXRpb25CZXppZXJOb2RlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcG9zaXRpb25CZXppZXJOb2RlKCkge1xuICAgICAgICBpZiAodGhpcy52aWEgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZyb20gIT09IHVuZGVmaW5lZCAmJiB0aGlzLnRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnZpYS54ID0gMC41ICogKHRoaXMuZnJvbS54ICsgdGhpcy50by54KTtcbiAgICAgICAgICB0aGlzLnZpYS55ID0gMC41ICogKHRoaXMuZnJvbS55ICsgdGhpcy50by55KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnZpYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy52aWEueCA9IDA7XG4gICAgICAgICAgdGhpcy52aWEueSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEcmF3IGEgbGluZSBiZXR3ZWVuIHR3byBub2Rlc1xuICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9saW5lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2xpbmUoY3R4LCB2aWFOb2RlKSB7XG4gICAgICAgIC8vIGRyYXcgYSBzdHJhaWdodCBsaW5lXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLmZyb21Qb2ludC54LCB0aGlzLmZyb21Qb2ludC55KTtcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gbm9ybWFsIHN0cmFpZ2h0IGVkZ2VzXG4gICAgICAgIGlmICh2aWFOb2RlLnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGN0eC5saW5lVG8odGhpcy50b1BvaW50LngsIHRoaXMudG9Qb2ludC55KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh2aWFOb2RlLngsIHZpYU5vZGUueSwgdGhpcy50b1BvaW50LngsIHRoaXMudG9Qb2ludC55KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFZpYU5vZGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWFOb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWE7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29tYmluZWQgZnVuY3Rpb24gb2YgcG9pbnRPbkxpbmUgYW5kIHBvaW50T25CZXppZXIuIFRoaXMgZ2l2ZXMgdGhlIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnQgb24gdGhlIGxpbmUgYXQgYSBjZXJ0YWluIHBlcmNlbnRhZ2Ugb2YgdGhlIHdheVxuICAgICAgICogQHBhcmFtIHBlcmNlbnRhZ2VcbiAgICAgICAqIEBwYXJhbSB2aWFOb2RlXG4gICAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRQb2ludFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50KHBlcmNlbnRhZ2UpIHtcbiAgICAgICAgdmFyIHZpYU5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMudmlhO1xuXG4gICAgICAgIHZhciB0ID0gcGVyY2VudGFnZTtcbiAgICAgICAgdmFyIHggPSB2b2lkIDAsXG4gICAgICAgICAgICB5ID0gdm9pZCAwO1xuICAgICAgICBpZiAodGhpcy5mcm9tID09PSB0aGlzLnRvKSB7XG4gICAgICAgICAgdmFyIF9nZXRDaXJjbGVEYXRhID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YSh0aGlzLmZyb20pLFxuICAgICAgICAgICAgICBfZ2V0Q2lyY2xlRGF0YTIgPSBfc2xpY2VkVG9BcnJheShfZ2V0Q2lyY2xlRGF0YSwgMyksXG4gICAgICAgICAgICAgIGN4ID0gX2dldENpcmNsZURhdGEyWzBdLFxuICAgICAgICAgICAgICBjeSA9IF9nZXRDaXJjbGVEYXRhMlsxXSxcbiAgICAgICAgICAgICAgY3IgPSBfZ2V0Q2lyY2xlRGF0YTJbMl07XG5cbiAgICAgICAgICB2YXIgYSA9IDIgKiBNYXRoLlBJICogKDEgLSB0KTtcbiAgICAgICAgICB4ID0gY3ggKyBjciAqIE1hdGguc2luKGEpO1xuICAgICAgICAgIHkgPSBjeSArIGNyIC0gY3IgKiAoMSAtIE1hdGguY29zKGEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4ID0gTWF0aC5wb3coMSAtIHQsIDIpICogdGhpcy5mcm9tUG9pbnQueCArIDIgKiB0ICogKDEgLSB0KSAqIHZpYU5vZGUueCArIE1hdGgucG93KHQsIDIpICogdGhpcy50b1BvaW50Lng7XG4gICAgICAgICAgeSA9IE1hdGgucG93KDEgLSB0LCAyKSAqIHRoaXMuZnJvbVBvaW50LnkgKyAyICogdCAqICgxIC0gdCkgKiB2aWFOb2RlLnkgKyBNYXRoLnBvdyh0LCAyKSAqIHRoaXMudG9Qb2ludC55O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZmluZEJvcmRlclBvc2l0aW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbihuZWFyTm9kZSwgY3R4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25CZXppZXIobmVhck5vZGUsIGN0eCwgdGhpcy52aWEpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZ2V0RGlzdGFuY2VUb0VkZ2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldERpc3RhbmNlVG9CZXppZXJFZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHRoaXMudmlhKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQmV6aWVyRWRnZUR5bmFtaWM7XG4gIH0oX0JlemllckVkZ2VCYXNlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBCZXppZXJFZGdlRHluYW1pYztcblxuLyoqKi8gfSxcbi8qIDkzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX0JlemllckVkZ2VCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oOTApO1xuXG4gIHZhciBfQmV6aWVyRWRnZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmV6aWVyRWRnZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIEJlemllckVkZ2VTdGF0aWMgPSBmdW5jdGlvbiAoX0JlemllckVkZ2VCYXNlKSB7XG4gICAgX2luaGVyaXRzKEJlemllckVkZ2VTdGF0aWMsIF9CZXppZXJFZGdlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBCZXppZXJFZGdlU3RhdGljKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmV6aWVyRWRnZVN0YXRpYyk7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQmV6aWVyRWRnZVN0YXRpYy5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJlemllckVkZ2VTdGF0aWMpKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyBhIGxpbmUgYmV0d2VlbiB0d28gbm9kZXNcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKEJlemllckVkZ2VTdGF0aWMsIFt7XG4gICAgICBrZXk6ICdfbGluZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2xpbmUoY3R4LCB2aWFOb2RlKSB7XG4gICAgICAgIC8vIGRyYXcgYSBzdHJhaWdodCBsaW5lXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLmZyb21Qb2ludC54LCB0aGlzLmZyb21Qb2ludC55KTtcblxuICAgICAgICAvLyBmYWxsYmFjayB0byBub3JtYWwgc3RyYWlnaHQgZWRnZXNcbiAgICAgICAgaWYgKHZpYU5vZGUueCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLnRvUG9pbnQueCwgdGhpcy50b1BvaW50LnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHZpYU5vZGUueCwgdmlhTm9kZS55LCB0aGlzLnRvUG9pbnQueCwgdGhpcy50b1BvaW50LnkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRWaWFOb2RlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWFOb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBXZSBkbyBub3QgdXNlIHRoZSB0byBhbmQgZnJvbVBvaW50cyBoZXJlIHRvIG1ha2UgdGhlIHZpYSBub2RlcyB0aGUgc2FtZSBhcyBlZGdlcyB3aXRob3V0IGFycm93cy5cbiAgICAgICAqIEByZXR1cm5zIHt7eDogdW5kZWZpbmVkLCB5OiB1bmRlZmluZWR9fVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldFZpYUNvb3JkaW5hdGVzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VmlhQ29vcmRpbmF0ZXMoKSB7XG4gICAgICAgIHZhciB4VmlhID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgeVZpYSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGZhY3RvciA9IHRoaXMub3B0aW9ucy5zbW9vdGgucm91bmRuZXNzO1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMub3B0aW9ucy5zbW9vdGgudHlwZTtcbiAgICAgICAgdmFyIGR4ID0gTWF0aC5hYnModGhpcy5mcm9tLnggLSB0aGlzLnRvLngpO1xuICAgICAgICB2YXIgZHkgPSBNYXRoLmFicyh0aGlzLmZyb20ueSAtIHRoaXMudG8ueSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlzY3JldGUnIHx8IHR5cGUgPT09ICdkaWFnb25hbENyb3NzJykge1xuICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLmZyb20ueCAtIHRoaXMudG8ueCkgPD0gTWF0aC5hYnModGhpcy5mcm9tLnkgLSB0aGlzLnRvLnkpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mcm9tLnkgPj0gdGhpcy50by55KSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmZyb20ueCA8PSB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgICAgICB4VmlhID0gdGhpcy5mcm9tLnggKyBmYWN0b3IgKiBkeTtcbiAgICAgICAgICAgICAgICB5VmlhID0gdGhpcy5mcm9tLnkgLSBmYWN0b3IgKiBkeTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZyb20ueCA+IHRoaXMudG8ueCkge1xuICAgICAgICAgICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueCAtIGZhY3RvciAqIGR5O1xuICAgICAgICAgICAgICAgIHlWaWEgPSB0aGlzLmZyb20ueSAtIGZhY3RvciAqIGR5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZnJvbS55IDwgdGhpcy50by55KSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmZyb20ueCA8PSB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgICAgICB4VmlhID0gdGhpcy5mcm9tLnggKyBmYWN0b3IgKiBkeTtcbiAgICAgICAgICAgICAgICB5VmlhID0gdGhpcy5mcm9tLnkgKyBmYWN0b3IgKiBkeTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZyb20ueCA+IHRoaXMudG8ueCkge1xuICAgICAgICAgICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueCAtIGZhY3RvciAqIGR5O1xuICAgICAgICAgICAgICAgIHlWaWEgPSB0aGlzLmZyb20ueSArIGZhY3RvciAqIGR5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJkaXNjcmV0ZVwiKSB7XG4gICAgICAgICAgICAgIHhWaWEgPSBkeCA8IGZhY3RvciAqIGR5ID8gdGhpcy5mcm9tLnggOiB4VmlhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnModGhpcy5mcm9tLnggLSB0aGlzLnRvLngpID4gTWF0aC5hYnModGhpcy5mcm9tLnkgLSB0aGlzLnRvLnkpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mcm9tLnkgPj0gdGhpcy50by55KSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmZyb20ueCA8PSB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgICAgICB4VmlhID0gdGhpcy5mcm9tLnggKyBmYWN0b3IgKiBkeDtcbiAgICAgICAgICAgICAgICB5VmlhID0gdGhpcy5mcm9tLnkgLSBmYWN0b3IgKiBkeDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZyb20ueCA+IHRoaXMudG8ueCkge1xuICAgICAgICAgICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueCAtIGZhY3RvciAqIGR4O1xuICAgICAgICAgICAgICAgIHlWaWEgPSB0aGlzLmZyb20ueSAtIGZhY3RvciAqIGR4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZnJvbS55IDwgdGhpcy50by55KSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmZyb20ueCA8PSB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgICAgICB4VmlhID0gdGhpcy5mcm9tLnggKyBmYWN0b3IgKiBkeDtcbiAgICAgICAgICAgICAgICB5VmlhID0gdGhpcy5mcm9tLnkgKyBmYWN0b3IgKiBkeDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZyb20ueCA+IHRoaXMudG8ueCkge1xuICAgICAgICAgICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueCAtIGZhY3RvciAqIGR4O1xuICAgICAgICAgICAgICAgIHlWaWEgPSB0aGlzLmZyb20ueSArIGZhY3RvciAqIGR4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJkaXNjcmV0ZVwiKSB7XG4gICAgICAgICAgICAgIHlWaWEgPSBkeSA8IGZhY3RvciAqIGR4ID8gdGhpcy5mcm9tLnkgOiB5VmlhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInN0cmFpZ2h0Q3Jvc3NcIikge1xuICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLmZyb20ueCAtIHRoaXMudG8ueCkgPD0gTWF0aC5hYnModGhpcy5mcm9tLnkgLSB0aGlzLnRvLnkpKSB7XG4gICAgICAgICAgICAvLyB1cCAtIGRvd25cbiAgICAgICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueDtcbiAgICAgICAgICAgIGlmICh0aGlzLmZyb20ueSA8IHRoaXMudG8ueSkge1xuICAgICAgICAgICAgICB5VmlhID0gdGhpcy50by55IC0gKDEgLSBmYWN0b3IpICogZHk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB5VmlhID0gdGhpcy50by55ICsgKDEgLSBmYWN0b3IpICogZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyh0aGlzLmZyb20ueCAtIHRoaXMudG8ueCkgPiBNYXRoLmFicyh0aGlzLmZyb20ueSAtIHRoaXMudG8ueSkpIHtcbiAgICAgICAgICAgIC8vIGxlZnQgLSByaWdodFxuICAgICAgICAgICAgaWYgKHRoaXMuZnJvbS54IDwgdGhpcy50by54KSB7XG4gICAgICAgICAgICAgIHhWaWEgPSB0aGlzLnRvLnggLSAoMSAtIGZhY3RvcikgKiBkeDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHhWaWEgPSB0aGlzLnRvLnggKyAoMSAtIGZhY3RvcikgKiBkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlWaWEgPSB0aGlzLmZyb20ueTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZnJvbS54IDwgdGhpcy50by54KSB7XG4gICAgICAgICAgICB4VmlhID0gdGhpcy50by54IC0gKDEgLSBmYWN0b3IpICogZHg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhWaWEgPSB0aGlzLnRvLnggKyAoMSAtIGZhY3RvcikgKiBkeDtcbiAgICAgICAgICB9XG4gICAgICAgICAgeVZpYSA9IHRoaXMuZnJvbS55O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICB4VmlhID0gdGhpcy5mcm9tLng7XG4gICAgICAgICAgaWYgKHRoaXMuZnJvbS55IDwgdGhpcy50by55KSB7XG4gICAgICAgICAgICB5VmlhID0gdGhpcy50by55IC0gKDEgLSBmYWN0b3IpICogZHk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHlWaWEgPSB0aGlzLnRvLnkgKyAoMSAtIGZhY3RvcikgKiBkeTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2N1cnZlZENXJykge1xuICAgICAgICAgIGR4ID0gdGhpcy50by54IC0gdGhpcy5mcm9tLng7XG4gICAgICAgICAgZHkgPSB0aGlzLmZyb20ueSAtIHRoaXMudG8ueTtcbiAgICAgICAgICB2YXIgcmFkaXVzID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICB2YXIgcGkgPSBNYXRoLlBJO1xuXG4gICAgICAgICAgdmFyIG9yaWdpbmFsQW5nbGUgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG4gICAgICAgICAgdmFyIG15QW5nbGUgPSAob3JpZ2luYWxBbmdsZSArIChmYWN0b3IgKiAwLjUgKyAwLjUpICogcGkpICUgKDIgKiBwaSk7XG5cbiAgICAgICAgICB4VmlhID0gdGhpcy5mcm9tLnggKyAoZmFjdG9yICogMC41ICsgMC41KSAqIHJhZGl1cyAqIE1hdGguc2luKG15QW5nbGUpO1xuICAgICAgICAgIHlWaWEgPSB0aGlzLmZyb20ueSArIChmYWN0b3IgKiAwLjUgKyAwLjUpICogcmFkaXVzICogTWF0aC5jb3MobXlBbmdsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2N1cnZlZENDVycpIHtcbiAgICAgICAgICBkeCA9IHRoaXMudG8ueCAtIHRoaXMuZnJvbS54O1xuICAgICAgICAgIGR5ID0gdGhpcy5mcm9tLnkgLSB0aGlzLnRvLnk7XG4gICAgICAgICAgdmFyIF9yYWRpdXMgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgIHZhciBfcGkgPSBNYXRoLlBJO1xuXG4gICAgICAgICAgdmFyIF9vcmlnaW5hbEFuZ2xlID0gTWF0aC5hdGFuMihkeSwgZHgpO1xuICAgICAgICAgIHZhciBfbXlBbmdsZSA9IChfb3JpZ2luYWxBbmdsZSArICgtZmFjdG9yICogMC41ICsgMC41KSAqIF9waSkgJSAoMiAqIF9waSk7XG5cbiAgICAgICAgICB4VmlhID0gdGhpcy5mcm9tLnggKyAoZmFjdG9yICogMC41ICsgMC41KSAqIF9yYWRpdXMgKiBNYXRoLnNpbihfbXlBbmdsZSk7XG4gICAgICAgICAgeVZpYSA9IHRoaXMuZnJvbS55ICsgKGZhY3RvciAqIDAuNSArIDAuNSkgKiBfcmFkaXVzICogTWF0aC5jb3MoX215QW5nbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNvbnRpbnVvdXNcbiAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5mcm9tLnggLSB0aGlzLnRvLngpIDw9IE1hdGguYWJzKHRoaXMuZnJvbS55IC0gdGhpcy50by55KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZnJvbS55ID49IHRoaXMudG8ueSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5mcm9tLnggPD0gdGhpcy50by54KSB7XG4gICAgICAgICAgICAgICAgeFZpYSA9IHRoaXMuZnJvbS54ICsgZmFjdG9yICogZHk7XG4gICAgICAgICAgICAgICAgeVZpYSA9IHRoaXMuZnJvbS55IC0gZmFjdG9yICogZHk7XG4gICAgICAgICAgICAgICAgeFZpYSA9IHRoaXMudG8ueCA8IHhWaWEgPyB0aGlzLnRvLnggOiB4VmlhO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZnJvbS54ID4gdGhpcy50by54KSB7XG4gICAgICAgICAgICAgICAgeFZpYSA9IHRoaXMuZnJvbS54IC0gZmFjdG9yICogZHk7XG4gICAgICAgICAgICAgICAgeVZpYSA9IHRoaXMuZnJvbS55IC0gZmFjdG9yICogZHk7XG4gICAgICAgICAgICAgICAgeFZpYSA9IHRoaXMudG8ueCA+IHhWaWEgPyB0aGlzLnRvLnggOiB4VmlhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZnJvbS55IDwgdGhpcy50by55KSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmZyb20ueCA8PSB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgICAgICB4VmlhID0gdGhpcy5mcm9tLnggKyBmYWN0b3IgKiBkeTtcbiAgICAgICAgICAgICAgICB5VmlhID0gdGhpcy5mcm9tLnkgKyBmYWN0b3IgKiBkeTtcbiAgICAgICAgICAgICAgICB4VmlhID0gdGhpcy50by54IDwgeFZpYSA/IHRoaXMudG8ueCA6IHhWaWE7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5mcm9tLnggPiB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgICAgICB4VmlhID0gdGhpcy5mcm9tLnggLSBmYWN0b3IgKiBkeTtcbiAgICAgICAgICAgICAgICB5VmlhID0gdGhpcy5mcm9tLnkgKyBmYWN0b3IgKiBkeTtcbiAgICAgICAgICAgICAgICB4VmlhID0gdGhpcy50by54ID4geFZpYSA/IHRoaXMudG8ueCA6IHhWaWE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKHRoaXMuZnJvbS54IC0gdGhpcy50by54KSA+IE1hdGguYWJzKHRoaXMuZnJvbS55IC0gdGhpcy50by55KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZnJvbS55ID49IHRoaXMudG8ueSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5mcm9tLnggPD0gdGhpcy50by54KSB7XG4gICAgICAgICAgICAgICAgeFZpYSA9IHRoaXMuZnJvbS54ICsgZmFjdG9yICogZHg7XG4gICAgICAgICAgICAgICAgeVZpYSA9IHRoaXMuZnJvbS55IC0gZmFjdG9yICogZHg7XG4gICAgICAgICAgICAgICAgeVZpYSA9IHRoaXMudG8ueSA+IHlWaWEgPyB0aGlzLnRvLnkgOiB5VmlhO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZnJvbS54ID4gdGhpcy50by54KSB7XG4gICAgICAgICAgICAgICAgeFZpYSA9IHRoaXMuZnJvbS54IC0gZmFjdG9yICogZHg7XG4gICAgICAgICAgICAgICAgeVZpYSA9IHRoaXMuZnJvbS55IC0gZmFjdG9yICogZHg7XG4gICAgICAgICAgICAgICAgeVZpYSA9IHRoaXMudG8ueSA+IHlWaWEgPyB0aGlzLnRvLnkgOiB5VmlhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZnJvbS55IDwgdGhpcy50by55KSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmZyb20ueCA8PSB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgICAgICB4VmlhID0gdGhpcy5mcm9tLnggKyBmYWN0b3IgKiBkeDtcbiAgICAgICAgICAgICAgICB5VmlhID0gdGhpcy5mcm9tLnkgKyBmYWN0b3IgKiBkeDtcbiAgICAgICAgICAgICAgICB5VmlhID0gdGhpcy50by55IDwgeVZpYSA/IHRoaXMudG8ueSA6IHlWaWE7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5mcm9tLnggPiB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgICAgICB4VmlhID0gdGhpcy5mcm9tLnggLSBmYWN0b3IgKiBkeDtcbiAgICAgICAgICAgICAgICB5VmlhID0gdGhpcy5mcm9tLnkgKyBmYWN0b3IgKiBkeDtcbiAgICAgICAgICAgICAgICB5VmlhID0gdGhpcy50by55IDwgeVZpYSA/IHRoaXMudG8ueSA6IHlWaWE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgeDogeFZpYSwgeTogeVZpYSB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19maW5kQm9yZGVyUG9zaXRpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb24obmVhck5vZGUsIGN0eCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkJlemllcihuZWFyTm9kZSwgY3R4LCBvcHRpb25zLnZpYSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldERpc3RhbmNlVG9FZGdlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgICB2YXIgdmlhTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogdGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKTtcbiAgICAgICAgLy8geDMseTMgaXMgdGhlIHBvaW50XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXREaXN0YW5jZVRvQmV6aWVyRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB2aWFOb2RlKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb21iaW5lZCBmdW5jdGlvbiBvZiBwb2ludE9uTGluZSBhbmQgcG9pbnRPbkJlemllci4gVGhpcyBnaXZlcyB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBvbiB0aGUgbGluZSBhdCBhIGNlcnRhaW4gcGVyY2VudGFnZSBvZiB0aGUgd2F5XG4gICAgICAgKiBAcGFyYW0gcGVyY2VudGFnZVxuICAgICAgICogQHBhcmFtIHZpYU5vZGVcbiAgICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0UG9pbnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50KHBlcmNlbnRhZ2UpIHtcbiAgICAgICAgdmFyIHZpYU5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG5cbiAgICAgICAgdmFyIHQgPSBwZXJjZW50YWdlO1xuICAgICAgICB2YXIgeCA9IE1hdGgucG93KDEgLSB0LCAyKSAqIHRoaXMuZnJvbVBvaW50LnggKyAyICogdCAqICgxIC0gdCkgKiB2aWFOb2RlLnggKyBNYXRoLnBvdyh0LCAyKSAqIHRoaXMudG9Qb2ludC54O1xuICAgICAgICB2YXIgeSA9IE1hdGgucG93KDEgLSB0LCAyKSAqIHRoaXMuZnJvbVBvaW50LnkgKyAyICogdCAqICgxIC0gdCkgKiB2aWFOb2RlLnkgKyBNYXRoLnBvdyh0LCAyKSAqIHRoaXMudG9Qb2ludC55O1xuXG4gICAgICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQmV6aWVyRWRnZVN0YXRpYztcbiAgfShfQmV6aWVyRWRnZUJhc2UzLmRlZmF1bHQpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IEJlemllckVkZ2VTdGF0aWM7XG5cbi8qKiovIH0sXG4vKiA5NCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9FZGdlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxKTtcblxuICB2YXIgX0VkZ2VCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0VkZ2VCYXNlMik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4gIHZhciBTdHJhaWdodEVkZ2UgPSBmdW5jdGlvbiAoX0VkZ2VCYXNlKSB7XG4gICAgX2luaGVyaXRzKFN0cmFpZ2h0RWRnZSwgX0VkZ2VCYXNlKTtcblxuICAgIGZ1bmN0aW9uIFN0cmFpZ2h0RWRnZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0cmFpZ2h0RWRnZSk7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU3RyYWlnaHRFZGdlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3RyYWlnaHRFZGdlKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXcgYSBsaW5lIGJldHdlZW4gdHdvIG5vZGVzXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhTdHJhaWdodEVkZ2UsIFt7XG4gICAgICBrZXk6ICdfbGluZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2xpbmUoY3R4KSB7XG4gICAgICAgIC8vIGRyYXcgYSBzdHJhaWdodCBsaW5lXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLmZyb21Qb2ludC54LCB0aGlzLmZyb21Qb2ludC55KTtcbiAgICAgICAgY3R4LmxpbmVUbyh0aGlzLnRvUG9pbnQueCwgdGhpcy50b1BvaW50LnkpO1xuICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0VmlhTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmlhTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb21iaW5lZCBmdW5jdGlvbiBvZiBwb2ludE9uTGluZSBhbmQgcG9pbnRPbkJlemllci4gVGhpcyBnaXZlcyB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBvbiB0aGUgbGluZSBhdCBhIGNlcnRhaW4gcGVyY2VudGFnZSBvZiB0aGUgd2F5XG4gICAgICAgKiBAcGFyYW0gcGVyY2VudGFnZVxuICAgICAgICogQHBhcmFtIHZpYVxuICAgICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRQb2ludCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnQocGVyY2VudGFnZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6ICgxIC0gcGVyY2VudGFnZSkgKiB0aGlzLmZyb21Qb2ludC54ICsgcGVyY2VudGFnZSAqIHRoaXMudG9Qb2ludC54LFxuICAgICAgICAgIHk6ICgxIC0gcGVyY2VudGFnZSkgKiB0aGlzLmZyb21Qb2ludC55ICsgcGVyY2VudGFnZSAqIHRoaXMudG9Qb2ludC55XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2ZpbmRCb3JkZXJQb3NpdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbihuZWFyTm9kZSwgY3R4KSB7XG4gICAgICAgIHZhciBub2RlMSA9IHRoaXMudG87XG4gICAgICAgIHZhciBub2RlMiA9IHRoaXMuZnJvbTtcbiAgICAgICAgaWYgKG5lYXJOb2RlLmlkID09PSB0aGlzLmZyb20uaWQpIHtcbiAgICAgICAgICBub2RlMSA9IHRoaXMuZnJvbTtcbiAgICAgICAgICBub2RlMiA9IHRoaXMudG87XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKG5vZGUxLnkgLSBub2RlMi55LCBub2RlMS54IC0gbm9kZTIueCk7XG4gICAgICAgIHZhciBkeCA9IG5vZGUxLnggLSBub2RlMi54O1xuICAgICAgICB2YXIgZHkgPSBub2RlMS55IC0gbm9kZTIueTtcbiAgICAgICAgdmFyIGVkZ2VTZWdtZW50TGVuZ3RoID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgdmFyIHRvQm9yZGVyRGlzdCA9IG5lYXJOb2RlLmRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgICAgIHZhciB0b0JvcmRlclBvaW50ID0gKGVkZ2VTZWdtZW50TGVuZ3RoIC0gdG9Cb3JkZXJEaXN0KSAvIGVkZ2VTZWdtZW50TGVuZ3RoO1xuXG4gICAgICAgIHZhciBib3JkZXJQb3MgPSB7fTtcbiAgICAgICAgYm9yZGVyUG9zLnggPSAoMSAtIHRvQm9yZGVyUG9pbnQpICogbm9kZTIueCArIHRvQm9yZGVyUG9pbnQgKiBub2RlMS54O1xuICAgICAgICBib3JkZXJQb3MueSA9ICgxIC0gdG9Cb3JkZXJQb2ludCkgKiBub2RlMi55ICsgdG9Cb3JkZXJQb2ludCAqIG5vZGUxLnk7XG5cbiAgICAgICAgcmV0dXJuIGJvcmRlclBvcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0RGlzdGFuY2VUb0VkZ2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0YW5jZVRvRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAgIC8vIHgzLHkzIGlzIHRoZSBwb2ludFxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RGlzdGFuY2VUb0xpbmUoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFN0cmFpZ2h0RWRnZTtcbiAgfShfRWRnZUJhc2UzLmRlZmF1bHQpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IFN0cmFpZ2h0RWRnZTtcblxuLyoqKi8gfSxcbi8qIDk1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX0Jhcm5lc0h1dFNvbHZlciA9IF9fd2VicGFja19yZXF1aXJlX18oOTYpO1xuXG4gIHZhciBfQmFybmVzSHV0U29sdmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhcm5lc0h1dFNvbHZlcik7XG5cbiAgdmFyIF9SZXB1bHNpb25Tb2x2ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk3KTtcblxuICB2YXIgX1JlcHVsc2lvblNvbHZlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZXB1bHNpb25Tb2x2ZXIpO1xuXG4gIHZhciBfSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OCk7XG5cbiAgdmFyIF9IaWVyYXJjaGljYWxSZXB1bHNpb25Tb2x2ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyKTtcblxuICB2YXIgX1NwcmluZ1NvbHZlciA9IF9fd2VicGFja19yZXF1aXJlX18oOTkpO1xuXG4gIHZhciBfU3ByaW5nU29sdmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NwcmluZ1NvbHZlcik7XG5cbiAgdmFyIF9IaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMCk7XG5cbiAgdmFyIF9IaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyKTtcblxuICB2YXIgX0NlbnRyYWxHcmF2aXR5U29sdmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDEpO1xuXG4gIHZhciBfQ2VudHJhbEdyYXZpdHlTb2x2ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2VudHJhbEdyYXZpdHlTb2x2ZXIpO1xuXG4gIHZhciBfRkEyQmFzZWRSZXB1bHNpb25Tb2x2ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMik7XG5cbiAgdmFyIF9GQTJCYXNlZFJlcHVsc2lvblNvbHZlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9GQTJCYXNlZFJlcHVsc2lvblNvbHZlcik7XG5cbiAgdmFyIF9GQTJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDMpO1xuXG4gIHZhciBfRkEyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9GQTJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIHZhciBQaHlzaWNzRW5naW5lID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBoeXNpY3NFbmdpbmUoYm9keSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBoeXNpY3NFbmdpbmUpO1xuXG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgdGhpcy5waHlzaWNzQm9keSA9IHsgcGh5c2ljc05vZGVJbmRpY2VzOiBbXSwgcGh5c2ljc0VkZ2VJbmRpY2VzOiBbXSwgZm9yY2VzOiB7fSwgdmVsb2NpdGllczoge30gfTtcblxuICAgICAgdGhpcy5waHlzaWNzRW5hYmxlZCA9IHRydWU7XG4gICAgICB0aGlzLnNpbXVsYXRpb25JbnRlcnZhbCA9IDEwMDAgLyA2MDtcbiAgICAgIHRoaXMucmVxdWlyZXNUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgIHRoaXMucHJldmlvdXNTdGF0ZXMgPSB7fTtcbiAgICAgIHRoaXMucmVmZXJlbmNlU3RhdGUgPSB7fTtcbiAgICAgIHRoaXMuZnJlZXplQ2FjaGUgPSB7fTtcbiAgICAgIHRoaXMucmVuZGVyVGltZXIgPSB1bmRlZmluZWQ7XG5cbiAgICAgIC8vIHBhcmFtZXRlcnMgZm9yIHRoZSBhZGFwdGl2ZSB0aW1lc3RlcFxuICAgICAgdGhpcy5hZGFwdGl2ZVRpbWVzdGVwID0gZmFsc2U7XG4gICAgICB0aGlzLmFkYXB0aXZlVGltZXN0ZXBFbmFibGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmFkYXB0aXZlQ291bnRlciA9IDA7XG4gICAgICB0aGlzLmFkYXB0aXZlSW50ZXJ2YWwgPSAzO1xuXG4gICAgICB0aGlzLnN0YWJpbGl6ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuc3RhcnRlZFN0YWJpbGl6YXRpb24gPSBmYWxzZTtcbiAgICAgIHRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdGhpcy5yZWFkeSA9IGZhbHNlOyAvLyB3aWxsIGJlIHNldCB0byB0cnVlIGlmIHRoZSBzdGFiaWxpemVcblxuICAgICAgLy8gZGVmYXVsdCBvcHRpb25zXG4gICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGJhcm5lc0h1dDoge1xuICAgICAgICAgIHRoZXRhOiAwLjUsXG4gICAgICAgICAgZ3Jhdml0YXRpb25hbENvbnN0YW50OiAtMjAwMCxcbiAgICAgICAgICBjZW50cmFsR3Jhdml0eTogMC4zLFxuICAgICAgICAgIHNwcmluZ0xlbmd0aDogOTUsXG4gICAgICAgICAgc3ByaW5nQ29uc3RhbnQ6IDAuMDQsXG4gICAgICAgICAgZGFtcGluZzogMC4wOSxcbiAgICAgICAgICBhdm9pZE92ZXJsYXA6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZm9yY2VBdGxhczJCYXNlZDoge1xuICAgICAgICAgIHRoZXRhOiAwLjUsXG4gICAgICAgICAgZ3Jhdml0YXRpb25hbENvbnN0YW50OiAtNTAsXG4gICAgICAgICAgY2VudHJhbEdyYXZpdHk6IDAuMDEsXG4gICAgICAgICAgc3ByaW5nQ29uc3RhbnQ6IDAuMDgsXG4gICAgICAgICAgc3ByaW5nTGVuZ3RoOiAxMDAsXG4gICAgICAgICAgZGFtcGluZzogMC40LFxuICAgICAgICAgIGF2b2lkT3ZlcmxhcDogMFxuICAgICAgICB9LFxuICAgICAgICByZXB1bHNpb246IHtcbiAgICAgICAgICBjZW50cmFsR3Jhdml0eTogMC4yLFxuICAgICAgICAgIHNwcmluZ0xlbmd0aDogMjAwLFxuICAgICAgICAgIHNwcmluZ0NvbnN0YW50OiAwLjA1LFxuICAgICAgICAgIG5vZGVEaXN0YW5jZTogMTAwLFxuICAgICAgICAgIGRhbXBpbmc6IDAuMDksXG4gICAgICAgICAgYXZvaWRPdmVybGFwOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGhpZXJhcmNoaWNhbFJlcHVsc2lvbjoge1xuICAgICAgICAgIGNlbnRyYWxHcmF2aXR5OiAwLjAsXG4gICAgICAgICAgc3ByaW5nTGVuZ3RoOiAxMDAsXG4gICAgICAgICAgc3ByaW5nQ29uc3RhbnQ6IDAuMDEsXG4gICAgICAgICAgbm9kZURpc3RhbmNlOiAxMjAsXG4gICAgICAgICAgZGFtcGluZzogMC4wOVxuICAgICAgICB9LFxuICAgICAgICBtYXhWZWxvY2l0eTogNTAsXG4gICAgICAgIG1pblZlbG9jaXR5OiAwLjc1LCAvLyBweC9zXG4gICAgICAgIHNvbHZlcjogJ2Jhcm5lc0h1dCcsXG4gICAgICAgIHN0YWJpbGl6YXRpb246IHtcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgIGl0ZXJhdGlvbnM6IDEwMDAsIC8vIG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbiB0byBzdGFiaWxpemVcbiAgICAgICAgICB1cGRhdGVJbnRlcnZhbDogNTAsXG4gICAgICAgICAgb25seUR5bmFtaWNFZGdlczogZmFsc2UsXG4gICAgICAgICAgZml0OiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVzdGVwOiAwLjUsXG4gICAgICAgIGFkYXB0aXZlVGltZXN0ZXA6IHRydWVcbiAgICAgIH07XG4gICAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgICAgdGhpcy50aW1lc3RlcCA9IDAuNTtcbiAgICAgIHRoaXMubGF5b3V0RmFpbGVkID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFBoeXNpY3NFbmdpbmUsIFt7XG4gICAgICBrZXk6ICdiaW5kRXZlbnRMaXN0ZW5lcnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignaW5pdFBoeXNpY3MnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuaW5pdFBoeXNpY3MoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdfbGF5b3V0RmFpbGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLmxheW91dEZhaWxlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbigncmVzZXRQaHlzaWNzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnN0b3BTaW11bGF0aW9uKCk7X3RoaXMucmVhZHkgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdkaXNhYmxlUGh5c2ljcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5waHlzaWNzRW5hYmxlZCA9IGZhbHNlO190aGlzLnN0b3BTaW11bGF0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbigncmVzdG9yZVBoeXNpY3MnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuc2V0T3B0aW9ucyhfdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICBpZiAoX3RoaXMucmVhZHkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF90aGlzLnN0YXJ0U2ltdWxhdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdzdGFydFNpbXVsYXRpb24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzLnJlYWR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfdGhpcy5zdGFydFNpbXVsYXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignc3RvcFNpbXVsYXRpb24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuc3RvcFNpbXVsYXRpb24oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnN0b3BTaW11bGF0aW9uKGZhbHNlKTtcbiAgICAgICAgICBfdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB0aGlzIGV2ZW50IHdpbGwgdHJpZ2dlciBhIHJlYnVpbGRpbmcgb2YgdGhlIGNhY2hlIGV2ZXJ5dGhpbmcuIFVzZWQgd2hlbiBub2RlcyBvciBlZGdlcyBoYXZlIGJlZW4gYWRkZWQgb3IgcmVtb3ZlZC5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZGF0YUNoYW5nZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIHVwZGF0ZSBzaG9ydGN1dCBsaXN0c1xuICAgICAgICAgIF90aGlzLnVwZGF0ZVBoeXNpY3NEYXRhKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGRlYnVnOiBzaG93IGZvcmNlc1xuICAgICAgICAvLyB0aGlzLmJvZHkuZW1pdHRlci5vbihcImFmdGVyRHJhd2luZ1wiLCAoY3R4KSA9PiB7dGhpcy5fZHJhd0ZvcmNlcyhjdHgpO30pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHNldCB0aGUgcGh5c2ljcyBvcHRpb25zXG4gICAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucGh5c2ljc0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc3RvcFNpbXVsYXRpb24oKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5waHlzaWNzRW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB1dGlsLnNlbGVjdGl2ZU5vdERlZXBFeHRlbmQoWydzdGFiaWxpemF0aW9uJ10sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgICAgICB1dGlsLm1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsICdzdGFiaWxpemF0aW9uJyk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5waHlzaWNzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB0aGlzLnN0b3BTaW11bGF0aW9uKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNldCB0aGUgdGltZXN0ZXBcbiAgICAgICAgICAgIHRoaXMudGltZXN0ZXAgPSB0aGlzLm9wdGlvbnMudGltZXN0ZXA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGNvbmZpZ3VyZSB0aGUgZW5naW5lLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdpbml0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICB2YXIgb3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zb2x2ZXIgPT09ICdmb3JjZUF0bGFzMkJhc2VkJykge1xuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuZm9yY2VBdGxhczJCYXNlZDtcbiAgICAgICAgICB0aGlzLm5vZGVzU29sdmVyID0gbmV3IF9GQTJCYXNlZFJlcHVsc2lvblNvbHZlcjIuZGVmYXVsdCh0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICAgIHRoaXMuZWRnZXNTb2x2ZXIgPSBuZXcgX1NwcmluZ1NvbHZlcjIuZGVmYXVsdCh0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICAgIHRoaXMuZ3Jhdml0eVNvbHZlciA9IG5ldyBfRkEyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlcjIuZGVmYXVsdCh0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zb2x2ZXIgPT09ICdyZXB1bHNpb24nKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5yZXB1bHNpb247XG4gICAgICAgICAgdGhpcy5ub2Rlc1NvbHZlciA9IG5ldyBfUmVwdWxzaW9uU29sdmVyMi5kZWZhdWx0KHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgICAgdGhpcy5lZGdlc1NvbHZlciA9IG5ldyBfU3ByaW5nU29sdmVyMi5kZWZhdWx0KHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgICAgdGhpcy5ncmF2aXR5U29sdmVyID0gbmV3IF9DZW50cmFsR3Jhdml0eVNvbHZlcjIuZGVmYXVsdCh0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zb2x2ZXIgPT09ICdoaWVyYXJjaGljYWxSZXB1bHNpb24nKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWxSZXB1bHNpb247XG4gICAgICAgICAgdGhpcy5ub2Rlc1NvbHZlciA9IG5ldyBfSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyMi5kZWZhdWx0KHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgICAgdGhpcy5lZGdlc1NvbHZlciA9IG5ldyBfSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyMi5kZWZhdWx0KHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgICAgdGhpcy5ncmF2aXR5U29sdmVyID0gbmV3IF9DZW50cmFsR3Jhdml0eVNvbHZlcjIuZGVmYXVsdCh0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGJhcm5lc0h1dFxuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuYmFybmVzSHV0O1xuICAgICAgICAgIHRoaXMubm9kZXNTb2x2ZXIgPSBuZXcgX0Jhcm5lc0h1dFNvbHZlcjIuZGVmYXVsdCh0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICAgIHRoaXMuZWRnZXNTb2x2ZXIgPSBuZXcgX1NwcmluZ1NvbHZlcjIuZGVmYXVsdCh0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICAgIHRoaXMuZ3Jhdml0eVNvbHZlciA9IG5ldyBfQ2VudHJhbEdyYXZpdHlTb2x2ZXIyLmRlZmF1bHQodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW9kZWxPcHRpb25zID0gb3B0aW9ucztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBpbml0aWFsaXplIHRoZSBlbmdpbmVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnaW5pdFBoeXNpY3MnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRQaHlzaWNzKCkge1xuICAgICAgICBpZiAodGhpcy5waHlzaWNzRW5hYmxlZCA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWJpbGl6ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YWJpbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnZml0Jywge30sIHRoaXMubGF5b3V0RmFpbGVkKTsgLy8gaWYgdGhlIGxheW91dCBmYWlsZWQsIHdlIHVzZSB0aGUgYXBwcm94aW1hdGlvbiBmb3IgdGhlIHpvb21cbiAgICAgICAgICAgIHRoaXMuc3RhcnRTaW11bGF0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2ZpdCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU3RhcnQgdGhlIHNpbXVsYXRpb25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc3RhcnRTaW11bGF0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydFNpbXVsYXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnBoeXNpY3NFbmFibGVkID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5zdGFiaWxpemVkID0gZmFsc2U7XG5cbiAgICAgICAgICAvLyB3aGVuIHZpc2libGUsIGFkYXB0aXZpdHkgaXMgZGlzYWJsZWQuXG4gICAgICAgICAgdGhpcy5hZGFwdGl2ZVRpbWVzdGVwID0gZmFsc2U7XG5cbiAgICAgICAgICAvLyB0aGlzIHNldHMgdGhlIHdpZHRoIG9mIGFsbCBub2RlcyBpbml0aWFsbHkgd2hpY2ggY291bGQgYmUgcmVxdWlyZWQgZm9yIHRoZSBhdm9pZE92ZXJsYXBcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3Jlc2l6ZU5vZGVzXCIpO1xuICAgICAgICAgIGlmICh0aGlzLnZpZXdGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdGdW5jdGlvbiA9IHRoaXMuc2ltdWxhdGlvblN0ZXAuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdpbml0UmVkcmF3JywgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3N0YXJ0UmVuZGVyaW5nJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZWRyYXcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFN0b3AgdGhlIHNpbXVsYXRpb24sIGZvcmNlIHN0YWJpbGl6YXRpb24uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3N0b3BTaW11bGF0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wU2ltdWxhdGlvbigpIHtcbiAgICAgICAgdmFyIGVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG5cbiAgICAgICAgdGhpcy5zdGFiaWxpemVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGVtaXQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLl9lbWl0U3RhYmlsaXplZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpZXdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKCdpbml0UmVkcmF3JywgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICAgIHRoaXMudmlld0Z1bmN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChlbWl0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfc3RvcFJlbmRlcmluZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSB2aWV3RnVuY3Rpb24gaW5zZXJ0cyB0aGlzIHN0ZXAgaW50byBlYWNoIHJlbmRlciBsb29wLiBJdCBjYWxscyB0aGUgcGh5c2ljcyB0aWNrIGFuZCBoYW5kbGVzIHRoZSBjbGVhbnVwIGF0IHN0YWJpbGl6ZWQuXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzaW11bGF0aW9uU3RlcCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2ltdWxhdGlvblN0ZXAoKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBwaHlzaWNzIGhhdmUgc2V0dGxlZFxuICAgICAgICB2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5waHlzaWNzVGljaygpO1xuICAgICAgICB2YXIgcGh5c2ljc1RpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgICAgIC8vIHJ1biBkb3VibGUgc3BlZWQgaWYgaXQgaXMgYSBsaXR0bGUgZ3JhcGhcbiAgICAgICAgaWYgKChwaHlzaWNzVGltZSA8IDAuNCAqIHRoaXMuc2ltdWxhdGlvbkludGVydmFsIHx8IHRoaXMucnVuRG91YmxlU3BlZWQgPT09IHRydWUpICYmIHRoaXMuc3RhYmlsaXplZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NUaWNrKCk7XG5cbiAgICAgICAgICAvLyB0aGlzIG1ha2VzIHN1cmUgdGhlcmUgaXMgbm8gaml0dGVyLiBUaGUgZGVjaXNpb24gaXMgdGFrZW4gb25jZSB0byBydW4gaXQgYXQgZG91YmxlIHNwZWVkLlxuICAgICAgICAgIHRoaXMucnVuRG91YmxlU3BlZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhYmlsaXplZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuc3RvcFNpbXVsYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHRyaWdnZXIgdGhlIHN0YWJpbGl6ZWQgZXZlbnQuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZW1pdFN0YWJpbGl6ZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9lbWl0U3RhYmlsaXplZCgpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGFtb3VudE9mSXRlcmF0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucztcblxuICAgICAgICBpZiAodGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA+IDEgfHwgdGhpcy5zdGFydGVkU3RhYmlsaXphdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMyLmJvZHkuZW1pdHRlci5lbWl0KCdzdGFiaWxpemVkJywgeyBpdGVyYXRpb25zOiBhbW91bnRPZkl0ZXJhdGlvbnMgfSk7XG4gICAgICAgICAgICBfdGhpczIuc3RhcnRlZFN0YWJpbGl6YXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzMi5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA9IDA7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBIHNpbmdsZSBzaW11bGF0aW9uIHN0ZXAgKG9yICd0aWNrJykgaW4gdGhlIHBoeXNpY3Mgc2ltdWxhdGlvblxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3BoeXNpY3NUaWNrJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwaHlzaWNzVGljaygpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBoZXJlIHRvIGVuc3VyZSB0aGF0IHRoZXJlIGlzIG5vIHN0YXJ0IGV2ZW50IHdoZW4gdGhlIG5ldHdvcmsgaXMgYWxyZWFkeSBzdGFibGUuXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWRTdGFiaWxpemF0aW9uID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3N0YXJ0U3RhYmlsaXppbmcnKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0ZWRTdGFiaWxpemF0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN0YWJpbGl6ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gYWRhcHRpdml0eSBtZWFucyB0aGUgdGltZXN0ZXAgYWRhcHRzIHRvIHRoZSBzaXR1YXRpb24sIG9ubHkgYXBwbGljYWJsZSBmb3Igc3RhYmlsaXphdGlvblxuICAgICAgICAgIGlmICh0aGlzLmFkYXB0aXZlVGltZXN0ZXAgPT09IHRydWUgJiYgdGhpcy5hZGFwdGl2ZVRpbWVzdGVwRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgZmFjdG9yIGZvciBpbmNyZWFzaW5nIHRoZSB0aW1lc3RlcCBvbiBzdWNjZXNzLlxuICAgICAgICAgICAgdmFyIGZhY3RvciA9IDEuMjtcblxuICAgICAgICAgICAgLy8gd2UgYXNzdW1lIHRoZSBhZGFwdGl2ZSBpbnRlcnZhbCBpc1xuICAgICAgICAgICAgaWYgKHRoaXMuYWRhcHRpdmVDb3VudGVyICUgdGhpcy5hZGFwdGl2ZUludGVydmFsID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIHdlIGxlYXZlIHRoZSB0aW1lc3RlcCBzdGFibGUgZm9yIFwiaW50ZXJ2YWxcIiBpdGVyYXRpb25zLlxuICAgICAgICAgICAgICAvLyBmaXJzdCB0aGUgYmlnIHN0ZXAgYW5kIHJldmVydC4gUmV2ZXJ0IHNhdmVzIHRoZSByZWZlcmVuY2Ugc3RhdGUuXG4gICAgICAgICAgICAgIHRoaXMudGltZXN0ZXAgPSAyICogdGhpcy50aW1lc3RlcDtcbiAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVGb3JjZXMoKTtcbiAgICAgICAgICAgICAgdGhpcy5tb3ZlTm9kZXMoKTtcbiAgICAgICAgICAgICAgdGhpcy5yZXZlcnQoKTtcblxuICAgICAgICAgICAgICAvLyBub3cgdGhlIG5vcm1hbCBzdGVwLiBTaW5jZSB0aGlzIGlzIHRoZSBsYXN0IHN0ZXAsIGl0IGlzIHRoZSBtb3JlIHN0YWJsZSBvbmUgYW5kIHdlIHdpbGwgdGFrZSB0aGlzLlxuICAgICAgICAgICAgICB0aGlzLnRpbWVzdGVwID0gMC41ICogdGhpcy50aW1lc3RlcDtcblxuICAgICAgICAgICAgICAvLyBzaW5jZSBpdCdzIGhhbGYgdGhlIHN0ZXAsIHdlIGRvIGl0IHR3aWNlLlxuICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUZvcmNlcygpO1xuICAgICAgICAgICAgICB0aGlzLm1vdmVOb2RlcygpO1xuICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUZvcmNlcygpO1xuICAgICAgICAgICAgICB0aGlzLm1vdmVOb2RlcygpO1xuXG4gICAgICAgICAgICAgIC8vIHdlIGNvbXBhcmUgdGhlIHR3byBzdGVwcy4gaWYgaXQgaXMgYWNjZXB0YWJsZSB3ZSBkb3VibGUgdGhlIHN0ZXAuXG4gICAgICAgICAgICAgIGlmICh0aGlzLl9ldmFsdWF0ZVN0ZXBRdWFsaXR5KCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVzdGVwID0gZmFjdG9yICogdGhpcy50aW1lc3RlcDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBub3QsIHdlIGRlY3JlYXNlIHRoZSBzdGVwIHRvIGEgbWluaW11bSBvZiB0aGUgb3B0aW9ucyB0aW1lc3RlcC5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZGVjcmVhc2VkIHRpbWVzdGVwIGlzIHNtYWxsZXIgdGhhbiB0aGUgb3B0aW9ucyBzdGVwLCB3ZSBkbyBub3QgcmVzZXQgdGhlIGNvdW50ZXJcbiAgICAgICAgICAgICAgICAvLyB3ZSBhc3N1bWUgdGhhdCB0aGUgb3B0aW9ucyB0aW1lc3RlcCBpcyBzdGFibGUgZW5vdWdoLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRpbWVzdGVwIC8gZmFjdG9yIDwgdGhpcy5vcHRpb25zLnRpbWVzdGVwKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnRpbWVzdGVwID0gdGhpcy5vcHRpb25zLnRpbWVzdGVwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdGltZXN0ZXAgd2FzIGxhcmdlciB0aGFuIDIgdGltZXMgdGhlIG9wdGlvbiBvbmUgd2UgY2hlY2sgdGhlIGFkYXB0aXZpdHkgYWdhaW4gdG8gZW5zdXJlXG4gICAgICAgICAgICAgICAgICAvLyB0aGF0IGxhcmdlIGluc3RhYmlsaXRpZXMgZG8gbm90IGZvcm0uXG4gICAgICAgICAgICAgICAgICB0aGlzLmFkYXB0aXZlQ291bnRlciA9IC0xOyAvLyBjaGVjayBhZ2FpbiBuZXh0IGl0ZXJhdGlvblxuICAgICAgICAgICAgICAgICAgdGhpcy50aW1lc3RlcCA9IE1hdGgubWF4KHRoaXMub3B0aW9ucy50aW1lc3RlcCwgdGhpcy50aW1lc3RlcCAvIGZhY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBub3JtYWwgc3RlcCwga2VlcGluZyB0aW1lc3RlcCBjb25zdGFudFxuICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUZvcmNlcygpO1xuICAgICAgICAgICAgICB0aGlzLm1vdmVOb2RlcygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIGNvdW50ZXJcbiAgICAgICAgICAgIHRoaXMuYWRhcHRpdmVDb3VudGVyICs9IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNhc2UgZm9yIHRoZSBzdGF0aWMgdGltZXN0ZXAsIHdlIHJlc2V0IGl0IHRvIHRoZSBvbmUgaW4gb3B0aW9ucyBhbmQgdGFrZSBhIG5vcm1hbCBzdGVwLlxuICAgICAgICAgICAgdGhpcy50aW1lc3RlcCA9IHRoaXMub3B0aW9ucy50aW1lc3RlcDtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlRm9yY2VzKCk7XG4gICAgICAgICAgICB0aGlzLm1vdmVOb2RlcygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGRldGVybWluZSBpZiB0aGUgbmV0d29yayBoYXMgc3RhYmlsemllZFxuICAgICAgICAgIGlmICh0aGlzLnN0YWJpbGl6ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMucmV2ZXJ0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucysrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTm9kZXMgYW5kIGVkZ2VzIGNhbiBoYXZlIHRoZSBwaHlzaWNzIHRvZ2dsZXMgb24gb3Igb2ZmLiBBIGNvbGxlY3Rpb24gb2YgaW5kaWNlcyBpcyBjcmVhdGVkIGhlcmUgc28gd2UgY2FuIHNraXAgdGhlIGNoZWNrIGFsbCB0aGUgdGltZS5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVQaHlzaWNzRGF0YScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlUGh5c2ljc0RhdGEoKSB7XG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzID0ge307XG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzID0gW107XG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc0VkZ2VJbmRpY2VzID0gW107XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuXG4gICAgICAgIC8vIGdldCBub2RlIGluZGljZXMgZm9yIHBoeXNpY3NcbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIG5vZGVzKSB7XG4gICAgICAgICAgaWYgKG5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgIGlmIChub2Rlc1tub2RlSWRdLm9wdGlvbnMucGh5c2ljcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcy5wdXNoKG5vZGVzW25vZGVJZF0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBlZGdlIGluZGljZXMgZm9yIHBoeXNpY3NcbiAgICAgICAgZm9yICh2YXIgZWRnZUlkIGluIGVkZ2VzKSB7XG4gICAgICAgICAgaWYgKGVkZ2VzLmhhc093blByb3BlcnR5KGVkZ2VJZCkpIHtcbiAgICAgICAgICAgIGlmIChlZGdlc1tlZGdlSWRdLm9wdGlvbnMucGh5c2ljcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NFZGdlSW5kaWNlcy5wdXNoKGVkZ2VzW2VkZ2VJZF0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCB0aGUgdmVsb2NpdHkgYW5kIHRoZSBmb3JjZXMgdmVjdG9yXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgX25vZGVJZCA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzW2ldO1xuICAgICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW19ub2RlSWRdID0geyB4OiAwLCB5OiAwIH07XG5cbiAgICAgICAgICAvLyBmb3JjZXMgY2FuIGJlIHJlc2V0IGJlY2F1c2UgdGhleSBhcmUgcmVjYWxjdWxhdGVkLiBWZWxvY2l0aWVzIGhhdmUgdG8gcGVyc2lzdC5cbiAgICAgICAgICBpZiAodGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzW19ub2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllc1tfbm9kZUlkXSA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFuIGRlbGV0ZWQgbm9kZXMgZnJvbSB0aGUgdmVsb2NpdHkgdmVjdG9yXG4gICAgICAgIGZvciAodmFyIF9ub2RlSWQyIGluIHRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllcykge1xuICAgICAgICAgIGlmIChub2Rlc1tfbm9kZUlkMl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllc1tfbm9kZUlkMl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV2ZXJ0IHRoZSBzaW11bGF0aW9uIG9uZSBzdGVwLiBUaGlzIGlzIGRvbmUgc28gYWZ0ZXIgc3RhYmlsaXphdGlvbiwgZXZlcnkgbmV3IHN0YXJ0IG9mIHRoZSBzaW11bGF0aW9uIHdpbGwgYWxzbyBzYXkgc3RhYmlsaXplZC5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmV2ZXJ0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXZlcnQoKSB7XG4gICAgICAgIHZhciBub2RlSWRzID0gT2JqZWN0LmtleXModGhpcy5wcmV2aW91c1N0YXRlcyk7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgdmFyIHZlbG9jaXRpZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXM7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlU3RhdGUgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZUlkID0gbm9kZUlkc1tpXTtcbiAgICAgICAgICBpZiAobm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAobm9kZXNbbm9kZUlkXS5vcHRpb25zLnBoeXNpY3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2VTdGF0ZVtub2RlSWRdID0ge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uczogeyB4OiBub2Rlc1tub2RlSWRdLngsIHk6IG5vZGVzW25vZGVJZF0ueSB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHZlbG9jaXRpZXNbbm9kZUlkXS54ID0gdGhpcy5wcmV2aW91c1N0YXRlc1tub2RlSWRdLnZ4O1xuICAgICAgICAgICAgICB2ZWxvY2l0aWVzW25vZGVJZF0ueSA9IHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXS52eTtcbiAgICAgICAgICAgICAgbm9kZXNbbm9kZUlkXS54ID0gdGhpcy5wcmV2aW91c1N0YXRlc1tub2RlSWRdLng7XG4gICAgICAgICAgICAgIG5vZGVzW25vZGVJZF0ueSA9IHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXS55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5wcmV2aW91c1N0YXRlc1tub2RlSWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgY29tcGFyZXMgdGhlIHJlZmVyZW5jZSBzdGF0ZSB0byB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZXZhbHVhdGVTdGVwUXVhbGl0eScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2V2YWx1YXRlU3RlcFF1YWxpdHkoKSB7XG4gICAgICAgIHZhciBkeCA9IHZvaWQgMCxcbiAgICAgICAgICAgIGR5ID0gdm9pZCAwLFxuICAgICAgICAgICAgZHBvcyA9IHZvaWQgMDtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgICB2YXIgcmVmZXJlbmNlID0gdGhpcy5yZWZlcmVuY2VTdGF0ZTtcbiAgICAgICAgdmFyIHBvc1RocmVzaG9sZCA9IDAuMztcblxuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5yZWZlcmVuY2VTdGF0ZSkge1xuICAgICAgICAgIGlmICh0aGlzLnJlZmVyZW5jZVN0YXRlLmhhc093blByb3BlcnR5KG5vZGVJZCkgJiYgbm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkeCA9IG5vZGVzW25vZGVJZF0ueCAtIHJlZmVyZW5jZVtub2RlSWRdLnBvc2l0aW9ucy54O1xuICAgICAgICAgICAgZHkgPSBub2Rlc1tub2RlSWRdLnkgLSByZWZlcmVuY2Vbbm9kZUlkXS5wb3NpdGlvbnMueTtcblxuICAgICAgICAgICAgZHBvcyA9IE1hdGguc3FydChNYXRoLnBvdyhkeCwgMikgKyBNYXRoLnBvdyhkeSwgMikpO1xuXG4gICAgICAgICAgICBpZiAoZHBvcyA+IHBvc1RocmVzaG9sZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIG1vdmUgdGhlIG5vZGVzIG9uZSB0aW1lc3RlcCBhbmQgY2hlY2sgaWYgdGhleSBhcmUgc3RhYmlsaXplZFxuICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ21vdmVOb2RlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZU5vZGVzKCkge1xuICAgICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcztcbiAgICAgICAgdmFyIG1heFZlbG9jaXR5ID0gdGhpcy5vcHRpb25zLm1heFZlbG9jaXR5ID8gdGhpcy5vcHRpb25zLm1heFZlbG9jaXR5IDogMWU5O1xuICAgICAgICB2YXIgbWF4Tm9kZVZlbG9jaXR5ID0gMDtcbiAgICAgICAgdmFyIGF2ZXJhZ2VOb2RlVmVsb2NpdHkgPSAwO1xuXG4gICAgICAgIC8vIHRoZSB2ZWxvY2l0eSB0aHJlc2hvbGQgKGVuZXJneSBpbiB0aGUgc3lzdGVtKSBmb3IgdGhlIGFkYXB0aXZpdHkgdG9nZ2xlXG4gICAgICAgIHZhciB2ZWxvY2l0eUFkYXB0aXZlVGhyZXNob2xkID0gNTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGVJbmRpY2VzW2ldO1xuICAgICAgICAgIHZhciBub2RlVmVsb2NpdHkgPSB0aGlzLl9wZXJmb3JtU3RlcChub2RlSWQsIG1heFZlbG9jaXR5KTtcbiAgICAgICAgICAvLyBzdGFiaWxpemVkIGlzIHRydWUgaWYgc3RhYmlsaXplZCBpcyB0cnVlIGFuZCB2ZWxvY2l0eSBpcyBzbWFsbGVyIHRoYW4gdm1pbiAtLT4gYWxsIG5vZGVzIG11c3QgYmUgc3RhYmlsaXplZFxuICAgICAgICAgIG1heE5vZGVWZWxvY2l0eSA9IE1hdGgubWF4KG1heE5vZGVWZWxvY2l0eSwgbm9kZVZlbG9jaXR5KTtcbiAgICAgICAgICBhdmVyYWdlTm9kZVZlbG9jaXR5ICs9IG5vZGVWZWxvY2l0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGV2YWx1YXRpbmcgdGhlIHN0YWJpbGl6ZWQgYW5kIGFkYXB0aXZlVGltZXN0ZXBFbmFibGVkIGNvbmRpdGlvbnNcbiAgICAgICAgdGhpcy5hZGFwdGl2ZVRpbWVzdGVwRW5hYmxlZCA9IGF2ZXJhZ2VOb2RlVmVsb2NpdHkgLyBub2RlSW5kaWNlcy5sZW5ndGggPCB2ZWxvY2l0eUFkYXB0aXZlVGhyZXNob2xkO1xuICAgICAgICB0aGlzLnN0YWJpbGl6ZWQgPSBtYXhOb2RlVmVsb2NpdHkgPCB0aGlzLm9wdGlvbnMubWluVmVsb2NpdHk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUGVyZm9ybSB0aGUgYWN0dWFsIHN0ZXBcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gbm9kZUlkXG4gICAgICAgKiBAcGFyYW0gbWF4VmVsb2NpdHlcbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcGVyZm9ybVN0ZXAnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wZXJmb3JtU3RlcChub2RlSWQsIG1heFZlbG9jaXR5KSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgIHZhciB0aW1lc3RlcCA9IHRoaXMudGltZXN0ZXA7XG4gICAgICAgIHZhciBmb3JjZXMgPSB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlcztcbiAgICAgICAgdmFyIHZlbG9jaXRpZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXM7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIHN0YXRlIHNvIHdlIGNhbiByZXZlcnRcbiAgICAgICAgdGhpcy5wcmV2aW91c1N0YXRlc1tub2RlSWRdID0geyB4OiBub2RlLngsIHk6IG5vZGUueSwgdng6IHZlbG9jaXRpZXNbbm9kZUlkXS54LCB2eTogdmVsb2NpdGllc1tub2RlSWRdLnkgfTtcblxuICAgICAgICBpZiAobm9kZS5vcHRpb25zLmZpeGVkLnggPT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIGR4ID0gdGhpcy5tb2RlbE9wdGlvbnMuZGFtcGluZyAqIHZlbG9jaXRpZXNbbm9kZUlkXS54OyAvLyBkYW1waW5nIGZvcmNlXG4gICAgICAgICAgdmFyIGF4ID0gKGZvcmNlc1tub2RlSWRdLnggLSBkeCkgLyBub2RlLm9wdGlvbnMubWFzczsgLy8gYWNjZWxlcmF0aW9uXG4gICAgICAgICAgdmVsb2NpdGllc1tub2RlSWRdLnggKz0gYXggKiB0aW1lc3RlcDsgLy8gdmVsb2NpdHlcbiAgICAgICAgICB2ZWxvY2l0aWVzW25vZGVJZF0ueCA9IE1hdGguYWJzKHZlbG9jaXRpZXNbbm9kZUlkXS54KSA+IG1heFZlbG9jaXR5ID8gdmVsb2NpdGllc1tub2RlSWRdLnggPiAwID8gbWF4VmVsb2NpdHkgOiAtbWF4VmVsb2NpdHkgOiB2ZWxvY2l0aWVzW25vZGVJZF0ueDtcbiAgICAgICAgICBub2RlLnggKz0gdmVsb2NpdGllc1tub2RlSWRdLnggKiB0aW1lc3RlcDsgLy8gcG9zaXRpb25cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3JjZXNbbm9kZUlkXS54ID0gMDtcbiAgICAgICAgICB2ZWxvY2l0aWVzW25vZGVJZF0ueCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5vcHRpb25zLmZpeGVkLnkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIGR5ID0gdGhpcy5tb2RlbE9wdGlvbnMuZGFtcGluZyAqIHZlbG9jaXRpZXNbbm9kZUlkXS55OyAvLyBkYW1waW5nIGZvcmNlXG4gICAgICAgICAgdmFyIGF5ID0gKGZvcmNlc1tub2RlSWRdLnkgLSBkeSkgLyBub2RlLm9wdGlvbnMubWFzczsgLy8gYWNjZWxlcmF0aW9uXG4gICAgICAgICAgdmVsb2NpdGllc1tub2RlSWRdLnkgKz0gYXkgKiB0aW1lc3RlcDsgLy8gdmVsb2NpdHlcbiAgICAgICAgICB2ZWxvY2l0aWVzW25vZGVJZF0ueSA9IE1hdGguYWJzKHZlbG9jaXRpZXNbbm9kZUlkXS55KSA+IG1heFZlbG9jaXR5ID8gdmVsb2NpdGllc1tub2RlSWRdLnkgPiAwID8gbWF4VmVsb2NpdHkgOiAtbWF4VmVsb2NpdHkgOiB2ZWxvY2l0aWVzW25vZGVJZF0ueTtcbiAgICAgICAgICBub2RlLnkgKz0gdmVsb2NpdGllc1tub2RlSWRdLnkgKiB0aW1lc3RlcDsgLy8gcG9zaXRpb25cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3JjZXNbbm9kZUlkXS55ID0gMDtcbiAgICAgICAgICB2ZWxvY2l0aWVzW25vZGVJZF0ueSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG90YWxWZWxvY2l0eSA9IE1hdGguc3FydChNYXRoLnBvdyh2ZWxvY2l0aWVzW25vZGVJZF0ueCwgMikgKyBNYXRoLnBvdyh2ZWxvY2l0aWVzW25vZGVJZF0ueSwgMikpO1xuICAgICAgICByZXR1cm4gdG90YWxWZWxvY2l0eTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBjYWxjdWxhdGUgdGhlIGZvcmNlcyBmb3Igb25lIHBoeXNpY3MgaXRlcmF0aW9uLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjYWxjdWxhdGVGb3JjZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUZvcmNlcygpIHtcbiAgICAgICAgdGhpcy5ncmF2aXR5U29sdmVyLnNvbHZlKCk7XG4gICAgICAgIHRoaXMubm9kZXNTb2x2ZXIuc29sdmUoKTtcbiAgICAgICAgdGhpcy5lZGdlc1NvbHZlci5zb2x2ZSgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gaW5pdGlhbGl6aW5nIGFuZCBzdGFiaWxpemluZywgd2UgY2FuIGZyZWV6ZSBub2RlcyB3aXRoIGEgcHJlZGVmaW5lZCBwb3NpdGlvbi4gVGhpcyBncmVhdGx5IHNwZWVkcyB1cCBzdGFiaWxpemF0aW9uXG4gICAgICAgKiBiZWNhdXNlIG9ubHkgdGhlIHN1cHBvcnRub2RlcyBmb3IgdGhlIHNtb290aEN1cnZlcyBoYXZlIHRvIHNldHRsZS5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZnJlZXplTm9kZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9mcmVlemVOb2RlcygpIHtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgICBmb3IgKHZhciBpZCBpbiBub2Rlcykge1xuICAgICAgICAgIGlmIChub2Rlcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgIGlmIChub2Rlc1tpZF0ueCAmJiBub2Rlc1tpZF0ueSkge1xuICAgICAgICAgICAgICB0aGlzLmZyZWV6ZUNhY2hlW2lkXSA9IHsgeDogbm9kZXNbaWRdLm9wdGlvbnMuZml4ZWQueCwgeTogbm9kZXNbaWRdLm9wdGlvbnMuZml4ZWQueSB9O1xuICAgICAgICAgICAgICBub2Rlc1tpZF0ub3B0aW9ucy5maXhlZC54ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgbm9kZXNbaWRdLm9wdGlvbnMuZml4ZWQueSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVW5mcmVlemVzIHRoZSBub2RlcyB0aGF0IGhhdmUgYmVlbiBmcm96ZW4gYnkgX2ZyZWV6ZURlZmluZWROb2Rlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcmVzdG9yZUZyb3plbk5vZGVzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzdG9yZUZyb3plbk5vZGVzKCkge1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICAgIGZvciAodmFyIGlkIGluIG5vZGVzKSB7XG4gICAgICAgICAgaWYgKG5vZGVzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZnJlZXplQ2FjaGVbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbm9kZXNbaWRdLm9wdGlvbnMuZml4ZWQueCA9IHRoaXMuZnJlZXplQ2FjaGVbaWRdLng7XG4gICAgICAgICAgICAgIG5vZGVzW2lkXS5vcHRpb25zLmZpeGVkLnkgPSB0aGlzLmZyZWV6ZUNhY2hlW2lkXS55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyZWV6ZUNhY2hlID0ge307XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRmluZCBhIHN0YWJsZSBwb3NpdGlvbiBmb3IgYWxsIG5vZGVzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3N0YWJpbGl6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3RhYmlsaXplKCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24uaXRlcmF0aW9ucztcblxuICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdGlvbnMgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1RoZSBzdGFiaWxpemUgbWV0aG9kIG5lZWRzIGEgbnVtZXJpYyBhbW91bnQgb2YgaXRlcmF0aW9ucy4gU3dpdGNoaW5nIHRvIGRlZmF1bHQ6ICcsIHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLml0ZXJhdGlvbnMpO1xuICAgICAgICAgIGl0ZXJhdGlvbnMgPSB0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5pdGVyYXRpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuYWJsZSBhZGFwdGl2ZSB0aW1lc3RlcHNcbiAgICAgICAgdGhpcy5hZGFwdGl2ZVRpbWVzdGVwID0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuYWRhcHRpdmVUaW1lc3RlcDtcblxuICAgICAgICAvLyB0aGlzIHNldHMgdGhlIHdpZHRoIG9mIGFsbCBub2RlcyBpbml0aWFsbHkgd2hpY2ggY291bGQgYmUgcmVxdWlyZWQgZm9yIHRoZSBhdm9pZE92ZXJsYXBcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXNpemVOb2Rlc1wiKTtcblxuICAgICAgICAvLyBzdG9wIHRoZSByZW5kZXIgbG9vcFxuICAgICAgICB0aGlzLnN0b3BTaW11bGF0aW9uKCk7XG5cbiAgICAgICAgLy8gc2V0IHN0YWJpbHplIHRvIGZhbHNlXG4gICAgICAgIHRoaXMuc3RhYmlsaXplZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGJsb2NrIHJlZHJhdyByZXF1ZXN0c1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfYmxvY2tSZWRyYXcnKTtcbiAgICAgICAgdGhpcy50YXJnZXRJdGVyYXRpb25zID0gaXRlcmF0aW9ucztcblxuICAgICAgICAvLyBzdGFydCB0aGUgc3RhYmlsaXphdGlvblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24ub25seUR5bmFtaWNFZGdlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuX2ZyZWV6ZU5vZGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA9IDA7XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5fc3RhYmlsaXphdGlvbkJhdGNoKCk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE9uZSBiYXRjaCBvZiBzdGFiaWxpemF0aW9uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc3RhYmlsaXphdGlvbkJhdGNoJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RhYmlsaXphdGlvbkJhdGNoKCkge1xuICAgICAgICAvLyB0aGlzIGlzIGhlcmUgdG8gZW5zdXJlIHRoYXQgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIHN0YXJ0IGV2ZW50LlxuICAgICAgICBpZiAodGhpcy5zdGFydGVkU3RhYmlsaXphdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzdGFydFN0YWJpbGl6aW5nJyk7XG4gICAgICAgICAgdGhpcy5zdGFydGVkU3RhYmlsaXphdGlvbiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICB3aGlsZSAodGhpcy5zdGFiaWxpemVkID09PSBmYWxzZSAmJiBjb3VudCA8IHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLnVwZGF0ZUludGVydmFsICYmIHRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMgPCB0aGlzLnRhcmdldEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NUaWNrKCk7XG4gICAgICAgICAgY291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN0YWJpbGl6ZWQgPT09IGZhbHNlICYmIHRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMgPCB0aGlzLnRhcmdldEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzdGFiaWxpemF0aW9uUHJvZ3Jlc3MnLCB7IGl0ZXJhdGlvbnM6IHRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMsIHRvdGFsOiB0aGlzLnRhcmdldEl0ZXJhdGlvbnMgfSk7XG4gICAgICAgICAgc2V0VGltZW91dCh0aGlzLl9zdGFiaWxpemF0aW9uQmF0Y2guYmluZCh0aGlzKSwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZmluYWxpemVTdGFiaWxpemF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBXcmFwIHVwIHRoZSBzdGFiaWxpemF0aW9uLCBmaXQgYW5kIGVtaXQgdGhlIGV2ZW50cy5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19maW5hbGl6ZVN0YWJpbGl6YXRpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5hbGl6ZVN0YWJpbGl6YXRpb24oKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19hbGxvd1JlZHJhdycpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24uZml0ID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnZml0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24ub25seUR5bmFtaWNFZGdlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuX3Jlc3RvcmVGcm96ZW5Ob2RlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnNEb25lJyk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhYmlsaXplZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuX2VtaXRTdGFiaWxpemVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGFydFNpbXVsYXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19kcmF3Rm9yY2VzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0ZvcmNlcyhjdHgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgICB2YXIgZm9yY2UgPSB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1t0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlc1tpXV07XG4gICAgICAgICAgdmFyIGZhY3RvciA9IDIwO1xuICAgICAgICAgIHZhciBjb2xvckZhY3RvciA9IDAuMDM7XG4gICAgICAgICAgdmFyIGZvcmNlU2l6ZSA9IE1hdGguc3FydChNYXRoLnBvdyhmb3JjZS54LCAyKSArIE1hdGgucG93KGZvcmNlLngsIDIpKTtcblxuICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oTWF0aC5tYXgoNSwgZm9yY2VTaXplKSwgMTUpO1xuICAgICAgICAgIHZhciBhcnJvd1NpemUgPSAzICogc2l6ZTtcblxuICAgICAgICAgIHZhciBjb2xvciA9IHV0aWwuSFNWVG9IZXgoKDE4MCAtIE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGNvbG9yRmFjdG9yICogZm9yY2VTaXplKSkgKiAxODApIC8gMzYwLCAxLCAxKTtcblxuICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBzaXplO1xuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHgubW92ZVRvKG5vZGUueCwgbm9kZS55KTtcbiAgICAgICAgICBjdHgubGluZVRvKG5vZGUueCArIGZhY3RvciAqIGZvcmNlLngsIG5vZGUueSArIGZhY3RvciAqIGZvcmNlLnkpO1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoZm9yY2UueSwgZm9yY2UueCk7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICAgIGN0eC5hcnJvd0VuZHBvaW50KG5vZGUueCArIGZhY3RvciAqIGZvcmNlLnggKyBNYXRoLmNvcyhhbmdsZSkgKiBhcnJvd1NpemUsIG5vZGUueSArIGZhY3RvciAqIGZvcmNlLnkgKyBNYXRoLnNpbihhbmdsZSkgKiBhcnJvd1NpemUsIGFuZ2xlLCBhcnJvd1NpemUpO1xuICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUGh5c2ljc0VuZ2luZTtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IFBoeXNpY3NFbmdpbmU7XG5cbi8qKiovIH0sXG4vKiA5NiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciBCYXJuZXNIdXRTb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFybmVzSHV0U29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFybmVzSHV0U29sdmVyKTtcblxuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkgPSBwaHlzaWNzQm9keTtcbiAgICAgIHRoaXMuYmFybmVzSHV0VHJlZTtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHRoaXMucmFuZG9tU2VlZCA9IDU7XG5cbiAgICAgIC8vIGRlYnVnOiBzaG93IGdyaWRcbiAgICAgIC8vdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJhZnRlckRyYXdpbmdcIiwgKGN0eCkgPT4ge3RoaXMuX2RlYnVnKGN0eCwnI2ZmMDAwMCcpfSlcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQmFybmVzSHV0U29sdmVyLCBbe1xuICAgICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy50aGV0YUludmVyc2VkID0gMSAvIHRoaXMub3B0aW9ucy50aGV0YTtcbiAgICAgICAgdGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yID0gMSAtIE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHRoaXMub3B0aW9ucy5hdm9pZE92ZXJsYXApKTsgLy8gaWYgMSB0aGVuIG1pbiBkaXN0YW5jZSA9IDAuNSwgaWYgMC41IHRoZW4gbWluIGRpc3RhbmNlID0gMC41ICsgMC41Km5vZGUuc2hhcGUucmFkaXVzXG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNlZWRlZFJhbmRvbVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlZWRlZFJhbmRvbSgpIHtcbiAgICAgICAgdmFyIHggPSBNYXRoLnNpbih0aGlzLnJhbmRvbVNlZWQrKykgKiAxMDAwMDtcbiAgICAgICAgcmV0dXJuIHggLSBNYXRoLmZsb29yKHgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgZm9yY2VzIHRoZSBub2RlcyBhcHBseSBvbiBlYWNoIG90aGVyIGJhc2VkIG9uIGEgZ3Jhdml0YXRpb25hbCBtb2RlbC5cbiAgICAgICAqIFRoZSBCYXJuZXMgSHV0IG1ldGhvZCBpcyB1c2VkIHRvIHNwZWVkIHVwIHRoaXMgTi1ib2R5IHNpbXVsYXRpb24uXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInNvbHZlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ3Jhdml0YXRpb25hbENvbnN0YW50ICE9PSAwICYmIHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHZvaWQgMDtcbiAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICAgICAgdmFyIG5vZGVDb3VudCA9IG5vZGVJbmRpY2VzLmxlbmd0aDtcblxuICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgdHJlZVxuICAgICAgICAgIHZhciBiYXJuZXNIdXRUcmVlID0gdGhpcy5fZm9ybUJhcm5lc0h1dFRyZWUobm9kZXMsIG5vZGVJbmRpY2VzKTtcblxuICAgICAgICAgIC8vIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgICB0aGlzLmJhcm5lc0h1dFRyZWUgPSBiYXJuZXNIdXRUcmVlO1xuXG4gICAgICAgICAgLy8gcGxhY2UgdGhlIG5vZGVzIG9uZSBieSBvbmUgcmVjdXJzaXZlbHlcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZXNbbm9kZUluZGljZXNbaV1dO1xuICAgICAgICAgICAgaWYgKG5vZGUub3B0aW9ucy5tYXNzID4gMCkge1xuICAgICAgICAgICAgICAvLyBzdGFydGluZyB3aXRoIHJvb3QgaXMgaXJyZWxldmFudCwgaXQgbmV2ZXIgcGFzc2VzIHRoZSBCYXJuZXNIdXRTb2x2ZXIgY29uZGl0aW9uXG4gICAgICAgICAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9uKGJhcm5lc0h1dFRyZWUucm9vdC5jaGlsZHJlbi5OVywgbm9kZSk7XG4gICAgICAgICAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9uKGJhcm5lc0h1dFRyZWUucm9vdC5jaGlsZHJlbi5ORSwgbm9kZSk7XG4gICAgICAgICAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9uKGJhcm5lc0h1dFRyZWUucm9vdC5jaGlsZHJlbi5TVywgbm9kZSk7XG4gICAgICAgICAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9uKGJhcm5lc0h1dFRyZWUucm9vdC5jaGlsZHJlbi5TRSwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBmdW5jdGlvbiB0cmF2ZXJzZXMgdGhlIGJhcm5lc0h1dFRyZWUuIEl0IGNoZWNrcyB3aGVuIGl0IGNhbiBhcHByb3hpbWF0ZSBkaXN0YW50IG5vZGVzIHdpdGggdGhlaXIgY2VudGVyIG9mIG1hc3MuXG4gICAgICAgKiBJZiBhIHJlZ2lvbiBjb250YWlucyBhIHNpbmdsZSBub2RlLCB3ZSBjaGVjayBpZiBpdCBpcyBub3QgaXRzZWxmLCB0aGVuIHdlIGFwcGx5IHRoZSBmb3JjZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gcGFyZW50QnJhbmNoXG4gICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9nZXRGb3JjZUNvbnRyaWJ1dGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRGb3JjZUNvbnRyaWJ1dGlvbihwYXJlbnRCcmFuY2gsIG5vZGUpIHtcbiAgICAgICAgLy8gd2UgZ2V0IG5vIGZvcmNlIGNvbnRyaWJ1dGlvbiBmcm9tIGFuIGVtcHR5IHJlZ2lvblxuICAgICAgICBpZiAocGFyZW50QnJhbmNoLmNoaWxkcmVuQ291bnQgPiAwKSB7XG4gICAgICAgICAgdmFyIGR4ID0gdm9pZCAwLFxuICAgICAgICAgICAgICBkeSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgZGlzdGFuY2UgPSB2b2lkIDA7XG5cbiAgICAgICAgICAvLyBnZXQgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciBvZiBtYXNzIHRvIHRoZSBub2RlLlxuICAgICAgICAgIGR4ID0gcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy54IC0gbm9kZS54O1xuICAgICAgICAgIGR5ID0gcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy55IC0gbm9kZS55O1xuICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICAgIC8vIEJhcm5lc0h1dFNvbHZlciBjb25kaXRpb25cbiAgICAgICAgICAvLyBvcmlnaW5hbCBjb25kaXRpb24gOiBzL2QgPCB0aGV0YSA9IHBhc3NlZCAgPT09ICBkL3MgPiAxL3RoZXRhID0gcGFzc2VkXG4gICAgICAgICAgLy8gY2FsY1NpemUgPSAxL3MgLS0+IGQgKiAxL3MgPiAxL3RoZXRhID0gcGFzc2VkXG4gICAgICAgICAgaWYgKGRpc3RhbmNlICogcGFyZW50QnJhbmNoLmNhbGNTaXplID4gdGhpcy50aGV0YUludmVyc2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgbm9kZSwgcGFyZW50QnJhbmNoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGlkIG5vdCBwYXNzIHRoZSBjb25kaXRpb24sIGdvIGludG8gY2hpbGRyZW4gaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICBpZiAocGFyZW50QnJhbmNoLmNoaWxkcmVuQ291bnQgPT09IDQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24ocGFyZW50QnJhbmNoLmNoaWxkcmVuLk5XLCBub2RlKTtcbiAgICAgICAgICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24ocGFyZW50QnJhbmNoLmNoaWxkcmVuLk5FLCBub2RlKTtcbiAgICAgICAgICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24ocGFyZW50QnJhbmNoLmNoaWxkcmVuLlNXLCBub2RlKTtcbiAgICAgICAgICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24ocGFyZW50QnJhbmNoLmNoaWxkcmVuLlNFLCBub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHBhcmVudEJyYW5jaCBtdXN0IGhhdmUgb25seSBvbmUgbm9kZSwgaWYgaXQgd2FzIGVtcHR5IHdlIHdvdWxkbnQgYmUgaGVyZVxuICAgICAgICAgICAgICBpZiAocGFyZW50QnJhbmNoLmNoaWxkcmVuLmRhdGEuaWQgIT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGl0IGlzIG5vdCBzZWxmXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIG5vZGUsIHBhcmVudEJyYW5jaCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyBiYXNlZCBvbiB0aGUgZGlzdGFuY2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIGRpc3RhbmNlXG4gICAgICAgKiBAcGFyYW0gZHhcbiAgICAgICAqIEBwYXJhbSBkeVxuICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAqIEBwYXJhbSBwYXJlbnRCcmFuY2hcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfY2FsY3VsYXRlRm9yY2VzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBub2RlLCBwYXJlbnRCcmFuY2gpIHtcbiAgICAgICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAgICAgZGlzdGFuY2UgPSAwLjE7XG4gICAgICAgICAgZHggPSBkaXN0YW5jZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IgPCAxICYmIG5vZGUuc2hhcGUucmFkaXVzKSB7XG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLm1heCgwLjEgKyB0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IgKiBub2RlLnNoYXBlLnJhZGl1cywgZGlzdGFuY2UgLSBub2RlLnNoYXBlLnJhZGl1cyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgZGl2aWRpbmcgYnkgdGhlIGRpc3RhbmNlIGN1YmVkIGluc3RlYWQgb2Ygc3F1YXJlZCBhbGxvd3MgdXMgdG8gZ2V0IHRoZSBmeCBhbmQgZnkgY29tcG9uZW50cyB3aXRob3V0IHNpbmVzIGFuZCBjb3NpbmVzXG4gICAgICAgIC8vIGl0IGlzIHNob3J0aGFuZCBmb3IgZ3Jhdml0eWZvcmNlIHdpdGggZGlzdGFuY2Ugc3F1YXJlZCBhbmQgZnggPSBkeC9kaXN0YW5jZSAqIGdyYXZpdHlGb3JjZVxuICAgICAgICB2YXIgZ3Jhdml0eUZvcmNlID0gdGhpcy5vcHRpb25zLmdyYXZpdGF0aW9uYWxDb25zdGFudCAqIHBhcmVudEJyYW5jaC5tYXNzICogbm9kZS5vcHRpb25zLm1hc3MgLyBNYXRoLnBvdyhkaXN0YW5jZSwgMyk7XG4gICAgICAgIHZhciBmeCA9IGR4ICogZ3Jhdml0eUZvcmNlO1xuICAgICAgICB2YXIgZnkgPSBkeSAqIGdyYXZpdHlGb3JjZTtcblxuICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlLmlkXS54ICs9IGZ4O1xuICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlLmlkXS55ICs9IGZ5O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gY29uc3RydWN0cyB0aGUgYmFybmVzSHV0IHRyZWUgcmVjdXJzaXZlbHkuIEl0IGNyZWF0ZXMgdGhlIHJvb3QsIHNwbGl0cyBpdCBhbmQgc3RhcnRzIHBsYWNpbmcgdGhlIG5vZGVzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBub2Rlc1xuICAgICAgICogQHBhcmFtIG5vZGVJbmRpY2VzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2Zvcm1CYXJuZXNIdXRUcmVlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2Zvcm1CYXJuZXNIdXRUcmVlKG5vZGVzLCBub2RlSW5kaWNlcykge1xuICAgICAgICB2YXIgbm9kZSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIG5vZGVDb3VudCA9IG5vZGVJbmRpY2VzLmxlbmd0aDtcblxuICAgICAgICB2YXIgbWluWCA9IG5vZGVzW25vZGVJbmRpY2VzWzBdXS54O1xuICAgICAgICB2YXIgbWluWSA9IG5vZGVzW25vZGVJbmRpY2VzWzBdXS55O1xuICAgICAgICB2YXIgbWF4WCA9IG5vZGVzW25vZGVJbmRpY2VzWzBdXS54O1xuICAgICAgICB2YXIgbWF4WSA9IG5vZGVzW25vZGVJbmRpY2VzWzBdXS55O1xuXG4gICAgICAgIC8vIGdldCB0aGUgcmFuZ2Ugb2YgdGhlIG5vZGVzXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbm9kZUNvdW50OyBpKyspIHtcbiAgICAgICAgICB2YXIgeCA9IG5vZGVzW25vZGVJbmRpY2VzW2ldXS54O1xuICAgICAgICAgIHZhciB5ID0gbm9kZXNbbm9kZUluZGljZXNbaV1dLnk7XG4gICAgICAgICAgaWYgKG5vZGVzW25vZGVJbmRpY2VzW2ldXS5vcHRpb25zLm1hc3MgPiAwKSB7XG4gICAgICAgICAgICBpZiAoeCA8IG1pblgpIHtcbiAgICAgICAgICAgICAgbWluWCA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeCA+IG1heFgpIHtcbiAgICAgICAgICAgICAgbWF4WCA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgICAgICAgbWluWSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgICAgICAgbWF4WSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG1ha2UgdGhlIHJhbmdlIGEgc3F1YXJlXG4gICAgICAgIHZhciBzaXplRGlmZiA9IE1hdGguYWJzKG1heFggLSBtaW5YKSAtIE1hdGguYWJzKG1heFkgLSBtaW5ZKTsgLy8gZGlmZmVyZW5jZSBiZXR3ZWVuIFggYW5kIFlcbiAgICAgICAgaWYgKHNpemVEaWZmID4gMCkge1xuICAgICAgICAgIG1pblkgLT0gMC41ICogc2l6ZURpZmY7XG4gICAgICAgICAgbWF4WSArPSAwLjUgKiBzaXplRGlmZjtcbiAgICAgICAgfSAvLyB4U2l6ZSA+IHlTaXplXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWluWCArPSAwLjUgKiBzaXplRGlmZjtcbiAgICAgICAgICAgIG1heFggLT0gMC41ICogc2l6ZURpZmY7XG4gICAgICAgICAgfSAvLyB4U2l6ZSA8IHlTaXplXG5cblxuICAgICAgICB2YXIgbWluaW11bVRyZWVTaXplID0gMWUtNTtcbiAgICAgICAgdmFyIHJvb3RTaXplID0gTWF0aC5tYXgobWluaW11bVRyZWVTaXplLCBNYXRoLmFicyhtYXhYIC0gbWluWCkpO1xuICAgICAgICB2YXIgaGFsZlJvb3RTaXplID0gMC41ICogcm9vdFNpemU7XG4gICAgICAgIHZhciBjZW50ZXJYID0gMC41ICogKG1pblggKyBtYXhYKSxcbiAgICAgICAgICAgIGNlbnRlclkgPSAwLjUgKiAobWluWSArIG1heFkpO1xuXG4gICAgICAgIC8vIGNvbnN0cnVjdCB0aGUgYmFybmVzSHV0VHJlZVxuICAgICAgICB2YXIgYmFybmVzSHV0VHJlZSA9IHtcbiAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICBjZW50ZXJPZk1hc3M6IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgICAgbWFzczogMCxcbiAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgIG1pblg6IGNlbnRlclggLSBoYWxmUm9vdFNpemUsIG1heFg6IGNlbnRlclggKyBoYWxmUm9vdFNpemUsXG4gICAgICAgICAgICAgIG1pblk6IGNlbnRlclkgLSBoYWxmUm9vdFNpemUsIG1heFk6IGNlbnRlclkgKyBoYWxmUm9vdFNpemVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaXplOiByb290U2l6ZSxcbiAgICAgICAgICAgIGNhbGNTaXplOiAxIC8gcm9vdFNpemUsXG4gICAgICAgICAgICBjaGlsZHJlbjogeyBkYXRhOiBudWxsIH0sXG4gICAgICAgICAgICBtYXhXaWR0aDogMCxcbiAgICAgICAgICAgIGxldmVsOiAwLFxuICAgICAgICAgICAgY2hpbGRyZW5Db3VudDogNFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc3BsaXRCcmFuY2goYmFybmVzSHV0VHJlZS5yb290KTtcblxuICAgICAgICAvLyBwbGFjZSB0aGUgbm9kZXMgb25lIGJ5IG9uZSByZWN1cnNpdmVseVxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbm9kZUNvdW50OyBfaSsrKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGVzW25vZGVJbmRpY2VzW19pXV07XG4gICAgICAgICAgaWYgKG5vZGUub3B0aW9ucy5tYXNzID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fcGxhY2VJblRyZWUoYmFybmVzSHV0VHJlZS5yb290LCBub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWtlIGdsb2JhbFxuICAgICAgICByZXR1cm4gYmFybmVzSHV0VHJlZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB0aGlzIHVwZGF0ZXMgdGhlIG1hc3Mgb2YgYSBicmFuY2guIHRoaXMgaXMgaW5jcmVhc2VkIGJ5IGFkZGluZyBhIG5vZGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHBhcmVudEJyYW5jaFxuICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfdXBkYXRlQnJhbmNoTWFzc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVCcmFuY2hNYXNzKHBhcmVudEJyYW5jaCwgbm9kZSkge1xuICAgICAgICB2YXIgdG90YWxNYXNzID0gcGFyZW50QnJhbmNoLm1hc3MgKyBub2RlLm9wdGlvbnMubWFzcztcbiAgICAgICAgdmFyIHRvdGFsTWFzc0ludiA9IDEgLyB0b3RhbE1hc3M7XG5cbiAgICAgICAgcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy54ID0gcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy54ICogcGFyZW50QnJhbmNoLm1hc3MgKyBub2RlLnggKiBub2RlLm9wdGlvbnMubWFzcztcbiAgICAgICAgcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy54ICo9IHRvdGFsTWFzc0ludjtcblxuICAgICAgICBwYXJlbnRCcmFuY2guY2VudGVyT2ZNYXNzLnkgPSBwYXJlbnRCcmFuY2guY2VudGVyT2ZNYXNzLnkgKiBwYXJlbnRCcmFuY2gubWFzcyArIG5vZGUueSAqIG5vZGUub3B0aW9ucy5tYXNzO1xuICAgICAgICBwYXJlbnRCcmFuY2guY2VudGVyT2ZNYXNzLnkgKj0gdG90YWxNYXNzSW52O1xuXG4gICAgICAgIHBhcmVudEJyYW5jaC5tYXNzID0gdG90YWxNYXNzO1xuICAgICAgICB2YXIgYmlnZ2VzdFNpemUgPSBNYXRoLm1heChNYXRoLm1heChub2RlLmhlaWdodCwgbm9kZS5yYWRpdXMpLCBub2RlLndpZHRoKTtcbiAgICAgICAgcGFyZW50QnJhbmNoLm1heFdpZHRoID0gcGFyZW50QnJhbmNoLm1heFdpZHRoIDwgYmlnZ2VzdFNpemUgPyBiaWdnZXN0U2l6ZSA6IHBhcmVudEJyYW5jaC5tYXhXaWR0aDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBkZXRlcm1pbmUgaW4gd2hpY2ggYnJhbmNoIHRoZSBub2RlIHdpbGwgYmUgcGxhY2VkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBwYXJlbnRCcmFuY2hcbiAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgKiBAcGFyYW0gc2tpcE1hc3NVcGRhdGVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcGxhY2VJblRyZWVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcGxhY2VJblRyZWUocGFyZW50QnJhbmNoLCBub2RlLCBza2lwTWFzc1VwZGF0ZSkge1xuICAgICAgICBpZiAoc2tpcE1hc3NVcGRhdGUgIT0gdHJ1ZSB8fCBza2lwTWFzc1VwZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gdXBkYXRlIHRoZSBtYXNzIG9mIHRoZSBicmFuY2guXG4gICAgICAgICAgdGhpcy5fdXBkYXRlQnJhbmNoTWFzcyhwYXJlbnRCcmFuY2gsIG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmVudEJyYW5jaC5jaGlsZHJlbi5OVy5yYW5nZS5tYXhYID4gbm9kZS54KSB7XG4gICAgICAgICAgLy8gaW4gTlcgb3IgU1dcbiAgICAgICAgICBpZiAocGFyZW50QnJhbmNoLmNoaWxkcmVuLk5XLnJhbmdlLm1heFkgPiBub2RlLnkpIHtcbiAgICAgICAgICAgIC8vIGluIE5XXG4gICAgICAgICAgICB0aGlzLl9wbGFjZUluUmVnaW9uKHBhcmVudEJyYW5jaCwgbm9kZSwgXCJOV1wiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaW4gU1dcbiAgICAgICAgICAgIHRoaXMuX3BsYWNlSW5SZWdpb24ocGFyZW50QnJhbmNoLCBub2RlLCBcIlNXXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpbiBORSBvciBTRVxuICAgICAgICAgIGlmIChwYXJlbnRCcmFuY2guY2hpbGRyZW4uTlcucmFuZ2UubWF4WSA+IG5vZGUueSkge1xuICAgICAgICAgICAgLy8gaW4gTkVcbiAgICAgICAgICAgIHRoaXMuX3BsYWNlSW5SZWdpb24ocGFyZW50QnJhbmNoLCBub2RlLCBcIk5FXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpbiBTRVxuICAgICAgICAgICAgdGhpcy5fcGxhY2VJblJlZ2lvbihwYXJlbnRCcmFuY2gsIG5vZGUsIFwiU0VcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogYWN0dWFsbHkgcGxhY2UgdGhlIG5vZGUgaW4gYSByZWdpb24gKG9yIGJyYW5jaClcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gcGFyZW50QnJhbmNoXG4gICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICogQHBhcmFtIHJlZ2lvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9wbGFjZUluUmVnaW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3BsYWNlSW5SZWdpb24ocGFyZW50QnJhbmNoLCBub2RlLCByZWdpb24pIHtcbiAgICAgICAgc3dpdGNoIChwYXJlbnRCcmFuY2guY2hpbGRyZW5bcmVnaW9uXS5jaGlsZHJlbkNvdW50KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgLy8gcGxhY2Ugbm9kZSBoZXJlXG4gICAgICAgICAgICBwYXJlbnRCcmFuY2guY2hpbGRyZW5bcmVnaW9uXS5jaGlsZHJlbi5kYXRhID0gbm9kZTtcbiAgICAgICAgICAgIHBhcmVudEJyYW5jaC5jaGlsZHJlbltyZWdpb25dLmNoaWxkcmVuQ291bnQgPSAxO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQnJhbmNoTWFzcyhwYXJlbnRCcmFuY2guY2hpbGRyZW5bcmVnaW9uXSwgbm9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAvLyBjb252ZXJ0IGludG8gY2hpbGRyZW5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSB0d28gbm9kZXMgZXhhY3RseSBvdmVybGFwcGluZyAob24gaW5pdCwgb24gb3BlbmluZyBvZiBjbHVzdGVyIGV0Yy4pXG4gICAgICAgICAgICAvLyB3ZSBtb3ZlIG9uZSBub2RlIGEgbGl0dGxlIGJpdCBhbmQgd2UgZG8gbm90IHB1dCBpdCBpbiB0aGUgdHJlZS5cbiAgICAgICAgICAgIGlmIChwYXJlbnRCcmFuY2guY2hpbGRyZW5bcmVnaW9uXS5jaGlsZHJlbi5kYXRhLnggPT09IG5vZGUueCAmJiBwYXJlbnRCcmFuY2guY2hpbGRyZW5bcmVnaW9uXS5jaGlsZHJlbi5kYXRhLnkgPT09IG5vZGUueSkge1xuICAgICAgICAgICAgICBub2RlLnggKz0gdGhpcy5zZWVkZWRSYW5kb20oKTtcbiAgICAgICAgICAgICAgbm9kZS55ICs9IHRoaXMuc2VlZGVkUmFuZG9tKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9zcGxpdEJyYW5jaChwYXJlbnRCcmFuY2guY2hpbGRyZW5bcmVnaW9uXSk7XG4gICAgICAgICAgICAgIHRoaXMuX3BsYWNlSW5UcmVlKHBhcmVudEJyYW5jaC5jaGlsZHJlbltyZWdpb25dLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIC8vIHBsYWNlIGluIGJyYW5jaFxuICAgICAgICAgICAgdGhpcy5fcGxhY2VJblRyZWUocGFyZW50QnJhbmNoLmNoaWxkcmVuW3JlZ2lvbl0sIG5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB0aGlzIGZ1bmN0aW9uIHNwbGl0cyBhIGJyYW5jaCBpbnRvIDQgc3ViIGJyYW5jaGVzLiBJZiB0aGUgYnJhbmNoIGNvbnRhaW5lZCBhIG5vZGUsIHdlIHBsYWNlIGl0IGluIHRoZSBzdWJicmFuY2hcbiAgICAgICAqIGFmdGVyIHRoZSBzcGxpdCBpcyBjb21wbGV0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gcGFyZW50QnJhbmNoXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NwbGl0QnJhbmNoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NwbGl0QnJhbmNoKHBhcmVudEJyYW5jaCkge1xuICAgICAgICAvLyBpZiB0aGUgYnJhbmNoIGlzIHNoYWRlZCB3aXRoIGEgbm9kZSwgcmVwbGFjZSB0aGUgbm9kZSBpbiB0aGUgbmV3IHN1YnNldC5cbiAgICAgICAgdmFyIGNvbnRhaW5lZE5vZGUgPSBudWxsO1xuICAgICAgICBpZiAocGFyZW50QnJhbmNoLmNoaWxkcmVuQ291bnQgPT09IDEpIHtcbiAgICAgICAgICBjb250YWluZWROb2RlID0gcGFyZW50QnJhbmNoLmNoaWxkcmVuLmRhdGE7XG4gICAgICAgICAgcGFyZW50QnJhbmNoLm1hc3MgPSAwO1xuICAgICAgICAgIHBhcmVudEJyYW5jaC5jZW50ZXJPZk1hc3MueCA9IDA7XG4gICAgICAgICAgcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy55ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnRCcmFuY2guY2hpbGRyZW5Db3VudCA9IDQ7XG4gICAgICAgIHBhcmVudEJyYW5jaC5jaGlsZHJlbi5kYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5faW5zZXJ0UmVnaW9uKHBhcmVudEJyYW5jaCwgXCJOV1wiKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0UmVnaW9uKHBhcmVudEJyYW5jaCwgXCJORVwiKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0UmVnaW9uKHBhcmVudEJyYW5jaCwgXCJTV1wiKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0UmVnaW9uKHBhcmVudEJyYW5jaCwgXCJTRVwiKTtcblxuICAgICAgICBpZiAoY29udGFpbmVkTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5fcGxhY2VJblRyZWUocGFyZW50QnJhbmNoLCBjb250YWluZWROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gc3ViZGl2aWRlcyB0aGUgcmVnaW9uIGludG8gZm91ciBuZXcgc2VnbWVudHMuXG4gICAgICAgKiBTcGVjaWZpY2FsbHksIHRoaXMgaW5zZXJ0cyBhIHNpbmdsZSBuZXcgc2VnbWVudC5cbiAgICAgICAqIEl0IGZpbGxzIHRoZSBjaGlsZHJlbiBzZWN0aW9uIG9mIHRoZSBwYXJlbnRCcmFuY2hcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gcGFyZW50QnJhbmNoXG4gICAgICAgKiBAcGFyYW0gcmVnaW9uXG4gICAgICAgKiBAcGFyYW0gcGFyZW50UmFuZ2VcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaW5zZXJ0UmVnaW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luc2VydFJlZ2lvbihwYXJlbnRCcmFuY2gsIHJlZ2lvbikge1xuICAgICAgICB2YXIgbWluWCA9IHZvaWQgMCxcbiAgICAgICAgICAgIG1heFggPSB2b2lkIDAsXG4gICAgICAgICAgICBtaW5ZID0gdm9pZCAwLFxuICAgICAgICAgICAgbWF4WSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGNoaWxkU2l6ZSA9IDAuNSAqIHBhcmVudEJyYW5jaC5zaXplO1xuICAgICAgICBzd2l0Y2ggKHJlZ2lvbikge1xuICAgICAgICAgIGNhc2UgXCJOV1wiOlxuICAgICAgICAgICAgbWluWCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YO1xuICAgICAgICAgICAgbWF4WCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YICsgY2hpbGRTaXplO1xuICAgICAgICAgICAgbWluWSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZO1xuICAgICAgICAgICAgbWF4WSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZICsgY2hpbGRTaXplO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIk5FXCI6XG4gICAgICAgICAgICBtaW5YID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblggKyBjaGlsZFNpemU7XG4gICAgICAgICAgICBtYXhYID0gcGFyZW50QnJhbmNoLnJhbmdlLm1heFg7XG4gICAgICAgICAgICBtaW5ZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblk7XG4gICAgICAgICAgICBtYXhZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblkgKyBjaGlsZFNpemU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiU1dcIjpcbiAgICAgICAgICAgIG1pblggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWDtcbiAgICAgICAgICAgIG1heFggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWCArIGNoaWxkU2l6ZTtcbiAgICAgICAgICAgIG1pblkgPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWSArIGNoaWxkU2l6ZTtcbiAgICAgICAgICAgIG1heFkgPSBwYXJlbnRCcmFuY2gucmFuZ2UubWF4WTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJTRVwiOlxuICAgICAgICAgICAgbWluWCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YICsgY2hpbGRTaXplO1xuICAgICAgICAgICAgbWF4WCA9IHBhcmVudEJyYW5jaC5yYW5nZS5tYXhYO1xuICAgICAgICAgICAgbWluWSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZICsgY2hpbGRTaXplO1xuICAgICAgICAgICAgbWF4WSA9IHBhcmVudEJyYW5jaC5yYW5nZS5tYXhZO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnRCcmFuY2guY2hpbGRyZW5bcmVnaW9uXSA9IHtcbiAgICAgICAgICBjZW50ZXJPZk1hc3M6IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgIG1hc3M6IDAsXG4gICAgICAgICAgcmFuZ2U6IHsgbWluWDogbWluWCwgbWF4WDogbWF4WCwgbWluWTogbWluWSwgbWF4WTogbWF4WSB9LFxuICAgICAgICAgIHNpemU6IDAuNSAqIHBhcmVudEJyYW5jaC5zaXplLFxuICAgICAgICAgIGNhbGNTaXplOiAyICogcGFyZW50QnJhbmNoLmNhbGNTaXplLFxuICAgICAgICAgIGNoaWxkcmVuOiB7IGRhdGE6IG51bGwgfSxcbiAgICAgICAgICBtYXhXaWR0aDogMCxcbiAgICAgICAgICBsZXZlbDogcGFyZW50QnJhbmNoLmxldmVsICsgMSxcbiAgICAgICAgICBjaGlsZHJlbkNvdW50OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICBERUJVR0dJTkcgQkVMT1cgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGZvciBkZWJ1Z2dpbmcgcHVycG9zZWQsIGl0IGRyYXdzIHRoZSB0cmVlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBjdHhcbiAgICAgICAqIEBwYXJhbSBjb2xvclxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9kZWJ1Z1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWJ1ZyhjdHgsIGNvbG9yKSB7XG4gICAgICAgIGlmICh0aGlzLmJhcm5lc0h1dFRyZWUgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG5cbiAgICAgICAgICB0aGlzLl9kcmF3QnJhbmNoKHRoaXMuYmFybmVzSHV0VHJlZS5yb290LCBjdHgsIGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy4gSXQgZHJhd3MgdGhlIGJyYW5jaGVzIHJlY3Vyc2l2ZWx5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBicmFuY2hcbiAgICAgICAqIEBwYXJhbSBjdHhcbiAgICAgICAqIEBwYXJhbSBjb2xvclxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9kcmF3QnJhbmNoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdCcmFuY2goYnJhbmNoLCBjdHgsIGNvbG9yKSB7XG4gICAgICAgIGlmIChjb2xvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29sb3IgPSBcIiNGRjAwMDBcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChicmFuY2guY2hpbGRyZW5Db3VudCA9PT0gNCkge1xuICAgICAgICAgIHRoaXMuX2RyYXdCcmFuY2goYnJhbmNoLmNoaWxkcmVuLk5XLCBjdHgpO1xuICAgICAgICAgIHRoaXMuX2RyYXdCcmFuY2goYnJhbmNoLmNoaWxkcmVuLk5FLCBjdHgpO1xuICAgICAgICAgIHRoaXMuX2RyYXdCcmFuY2goYnJhbmNoLmNoaWxkcmVuLlNFLCBjdHgpO1xuICAgICAgICAgIHRoaXMuX2RyYXdCcmFuY2goYnJhbmNoLmNoaWxkcmVuLlNXLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oYnJhbmNoLnJhbmdlLm1pblgsIGJyYW5jaC5yYW5nZS5taW5ZKTtcbiAgICAgICAgY3R4LmxpbmVUbyhicmFuY2gucmFuZ2UubWF4WCwgYnJhbmNoLnJhbmdlLm1pblkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKGJyYW5jaC5yYW5nZS5tYXhYLCBicmFuY2gucmFuZ2UubWluWSk7XG4gICAgICAgIGN0eC5saW5lVG8oYnJhbmNoLnJhbmdlLm1heFgsIGJyYW5jaC5yYW5nZS5tYXhZKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhicmFuY2gucmFuZ2UubWF4WCwgYnJhbmNoLnJhbmdlLm1heFkpO1xuICAgICAgICBjdHgubGluZVRvKGJyYW5jaC5yYW5nZS5taW5YLCBicmFuY2gucmFuZ2UubWF4WSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oYnJhbmNoLnJhbmdlLm1pblgsIGJyYW5jaC5yYW5nZS5tYXhZKTtcbiAgICAgICAgY3R4LmxpbmVUbyhicmFuY2gucmFuZ2UubWluWCwgYnJhbmNoLnJhbmdlLm1pblkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgLypcbiAgICAgICAgIGlmIChicmFuY2gubWFzcyA+IDApIHtcbiAgICAgICAgIGN0eC5jaXJjbGUoYnJhbmNoLmNlbnRlck9mTWFzcy54LCBicmFuY2guY2VudGVyT2ZNYXNzLnksIDMqYnJhbmNoLm1hc3MpO1xuICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgfVxuICAgICAgICAgKi9cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQmFybmVzSHV0U29sdmVyO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gQmFybmVzSHV0U29sdmVyO1xuXG4vKioqLyB9LFxuLyogOTcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICB2YXIgUmVwdWxzaW9uU29sdmVyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlcHVsc2lvblNvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlcHVsc2lvblNvbHZlcik7XG5cbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICB0aGlzLnBoeXNpY3NCb2R5ID0gcGh5c2ljc0JvZHk7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFJlcHVsc2lvblNvbHZlciwgW3tcbiAgICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIENhbGN1bGF0ZSB0aGUgZm9yY2VzIHRoZSBub2RlcyBhcHBseSBvbiBlYWNoIG90aGVyIGJhc2VkIG9uIGEgcmVwdWxzaW9uIGZpZWxkLlxuICAgICAgICogVGhpcyBmaWVsZCBpcyBsaW5lYXJseSBhcHByb3hpbWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInNvbHZlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICAgIHZhciBkeCwgZHksIGRpc3RhbmNlLCBmeCwgZnksIHJlcHVsc2luZ0ZvcmNlLCBub2RlMSwgbm9kZTI7XG5cbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcztcbiAgICAgICAgdmFyIGZvcmNlcyA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzO1xuXG4gICAgICAgIC8vIHJlcHVsc2luZyBmb3JjZXMgYmV0d2VlbiBub2Rlc1xuICAgICAgICB2YXIgbm9kZURpc3RhbmNlID0gdGhpcy5vcHRpb25zLm5vZGVEaXN0YW5jZTtcblxuICAgICAgICAvLyBhcHByb3hpbWF0aW9uIGNvbnN0YW50c1xuICAgICAgICB2YXIgYSA9IC0yIC8gMyAvIG5vZGVEaXN0YW5jZTtcbiAgICAgICAgdmFyIGIgPSA0IC8gMztcblxuICAgICAgICAvLyB3ZSBsb29wIGZyb20gaSBvdmVyIGFsbCBidXQgdGhlIGxhc3QgZW50cmVlIGluIHRoZSBhcnJheVxuICAgICAgICAvLyBqIGxvb3BzIGZyb20gaSsxIHRvIHRoZSBsYXN0LiBUaGlzIHdheSB3ZSBkbyBub3QgZG91YmxlIGNvdW50IGFueSBvZiB0aGUgaW5kaWNlcywgbm9yIGkgPT09IGpcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlSW5kaWNlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICBub2RlMSA9IG5vZGVzW25vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBub2RlSW5kaWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbm9kZTIgPSBub2Rlc1tub2RlSW5kaWNlc1tqXV07XG5cbiAgICAgICAgICAgIGR4ID0gbm9kZTIueCAtIG5vZGUxLng7XG4gICAgICAgICAgICBkeSA9IG5vZGUyLnkgLSBub2RlMS55O1xuICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgICAgICAvLyBzYW1lIGNvbmRpdGlvbiBhcyBCYXJuZXNIdXRTb2x2ZXIsIG1ha2luZyBzdXJlIG5vZGVzIGFyZSBuZXZlciAxMDAlIG92ZXJsYXBwaW5nLlxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAgICAgICAgIGRpc3RhbmNlID0gMC4xICogTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgICAgZHggPSBkaXN0YW5jZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgMiAqIG5vZGVEaXN0YW5jZSkge1xuICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCAwLjUgKiBub2RlRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICByZXB1bHNpbmdGb3JjZSA9IDEuMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXB1bHNpbmdGb3JjZSA9IGEgKiBkaXN0YW5jZSArIGI7IC8vIGxpbmVhciBhcHByb3ggb2YgIDEgLyAoMSArIE1hdGguZXhwKChkaXN0YW5jZSAvIG5vZGVEaXN0YW5jZSAtIDEpICogc3RlZXBuZXNzKSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXB1bHNpbmdGb3JjZSA9IHJlcHVsc2luZ0ZvcmNlIC8gZGlzdGFuY2U7XG5cbiAgICAgICAgICAgICAgZnggPSBkeCAqIHJlcHVsc2luZ0ZvcmNlO1xuICAgICAgICAgICAgICBmeSA9IGR5ICogcmVwdWxzaW5nRm9yY2U7XG5cbiAgICAgICAgICAgICAgZm9yY2VzW25vZGUxLmlkXS54IC09IGZ4O1xuICAgICAgICAgICAgICBmb3JjZXNbbm9kZTEuaWRdLnkgLT0gZnk7XG4gICAgICAgICAgICAgIGZvcmNlc1tub2RlMi5pZF0ueCArPSBmeDtcbiAgICAgICAgICAgICAgZm9yY2VzW25vZGUyLmlkXS55ICs9IGZ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBSZXB1bHNpb25Tb2x2ZXI7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBSZXB1bHNpb25Tb2x2ZXI7XG5cbi8qKiovIH0sXG4vKiA5OCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciBIaWVyYXJjaGljYWxSZXB1bHNpb25Tb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyKTtcblxuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkgPSBwaHlzaWNzQm9keTtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyLCBbe1xuICAgICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyB0aGUgbm9kZXMgYXBwbHkgb24gZWFjaCBvdGhlciBiYXNlZCBvbiBhIHJlcHVsc2lvbiBmaWVsZC5cbiAgICAgICAqIFRoaXMgZmllbGQgaXMgbGluZWFybHkgYXBwcm94aW1hdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzb2x2ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNvbHZlKCkge1xuICAgICAgICB2YXIgZHgsIGR5LCBkaXN0YW5jZSwgZngsIGZ5LCByZXB1bHNpbmdGb3JjZSwgbm9kZTEsIG5vZGUyLCBpLCBqO1xuXG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICAgIHZhciBmb3JjZXMgPSB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlcztcblxuICAgICAgICAvLyByZXB1bHNpbmcgZm9yY2VzIGJldHdlZW4gbm9kZXNcbiAgICAgICAgdmFyIG5vZGVEaXN0YW5jZSA9IHRoaXMub3B0aW9ucy5ub2RlRGlzdGFuY2U7XG5cbiAgICAgICAgLy8gd2UgbG9vcCBmcm9tIGkgb3ZlciBhbGwgYnV0IHRoZSBsYXN0IGVudHJlZSBpbiB0aGUgYXJyYXlcbiAgICAgICAgLy8gaiBsb29wcyBmcm9tIGkrMSB0byB0aGUgbGFzdC4gVGhpcyB3YXkgd2UgZG8gbm90IGRvdWJsZSBjb3VudCBhbnkgb2YgdGhlIGluZGljZXMsIG5vciBpID09PSBqXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBub2RlSW5kaWNlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICBub2RlMSA9IG5vZGVzW25vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBub2RlMiA9IG5vZGVzW25vZGVJbmRpY2VzW2pdXTtcblxuICAgICAgICAgICAgLy8gbm9kZXMgb25seSBhZmZlY3Qgbm9kZXMgb24gdGhlaXIgbGV2ZWxcbiAgICAgICAgICAgIGlmIChub2RlMS5sZXZlbCA9PT0gbm9kZTIubGV2ZWwpIHtcbiAgICAgICAgICAgICAgZHggPSBub2RlMi54IC0gbm9kZTEueDtcbiAgICAgICAgICAgICAgZHkgPSBub2RlMi55IC0gbm9kZTEueTtcbiAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgICAgICAgIHZhciBzdGVlcG5lc3MgPSAwLjA1O1xuICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBub2RlRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICByZXB1bHNpbmdGb3JjZSA9IC1NYXRoLnBvdyhzdGVlcG5lc3MgKiBkaXN0YW5jZSwgMikgKyBNYXRoLnBvdyhzdGVlcG5lc3MgKiBub2RlRGlzdGFuY2UsIDIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcHVsc2luZ0ZvcmNlID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBub3JtYWxpemUgZm9yY2Ugd2l0aFxuICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IDAuMDE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSByZXB1bHNpbmdGb3JjZSAvIGRpc3RhbmNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZ4ID0gZHggKiByZXB1bHNpbmdGb3JjZTtcbiAgICAgICAgICAgICAgZnkgPSBkeSAqIHJlcHVsc2luZ0ZvcmNlO1xuXG4gICAgICAgICAgICAgIGZvcmNlc1tub2RlMS5pZF0ueCAtPSBmeDtcbiAgICAgICAgICAgICAgZm9yY2VzW25vZGUxLmlkXS55IC09IGZ5O1xuICAgICAgICAgICAgICBmb3JjZXNbbm9kZTIuaWRdLnggKz0gZng7XG4gICAgICAgICAgICAgIGZvcmNlc1tub2RlMi5pZF0ueSArPSBmeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyO1xuXG4vKioqLyB9LFxuLyogOTkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICB2YXIgU3ByaW5nU29sdmVyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNwcmluZ1NvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwcmluZ1NvbHZlcik7XG5cbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICB0aGlzLnBoeXNpY3NCb2R5ID0gcGh5c2ljc0JvZHk7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFNwcmluZ1NvbHZlciwgW3tcbiAgICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBzcHJpbmdmb3JjZXMgb24gdGhlIG5vZGVzLCBhY2NvdW50aW5nIGZvciB0aGUgc3VwcG9ydCBub2Rlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic29sdmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZSgpIHtcbiAgICAgICAgdmFyIGVkZ2VMZW5ndGggPSB2b2lkIDAsXG4gICAgICAgICAgICBlZGdlID0gdm9pZCAwO1xuICAgICAgICB2YXIgZWRnZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NFZGdlSW5kaWNlcztcbiAgICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgICB2YXIgbm9kZTEgPSB2b2lkIDAsXG4gICAgICAgICAgICBub2RlMiA9IHZvaWQgMCxcbiAgICAgICAgICAgIG5vZGUzID0gdm9pZCAwO1xuXG4gICAgICAgIC8vIGZvcmNlcyBjYXVzZWQgYnkgdGhlIGVkZ2VzLCBtb2RlbGxlZCBhcyBzcHJpbmdzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlZGdlID0gZWRnZXNbZWRnZUluZGljZXNbaV1dO1xuICAgICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCA9PT0gdHJ1ZSAmJiBlZGdlLnRvSWQgIT09IGVkZ2UuZnJvbUlkKSB7XG4gICAgICAgICAgICAvLyBvbmx5IGNhbGN1bGF0ZSBmb3JjZXMgaWYgbm9kZXMgYXJlIGluIHRoZSBzYW1lIHNlY3RvclxuICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tlZGdlLnRvSWRdICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ib2R5Lm5vZGVzW2VkZ2UuZnJvbUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGlmIChlZGdlLmVkZ2VUeXBlLnZpYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZWRnZUxlbmd0aCA9IGVkZ2Uub3B0aW9ucy5sZW5ndGggPT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5zcHJpbmdMZW5ndGggOiBlZGdlLm9wdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIG5vZGUxID0gZWRnZS50bztcbiAgICAgICAgICAgICAgICBub2RlMiA9IGVkZ2UuZWRnZVR5cGUudmlhO1xuICAgICAgICAgICAgICAgIG5vZGUzID0gZWRnZS5mcm9tO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlU3ByaW5nRm9yY2Uobm9kZTEsIG5vZGUyLCAwLjUgKiBlZGdlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVTcHJpbmdGb3JjZShub2RlMiwgbm9kZTMsIDAuNSAqIGVkZ2VMZW5ndGgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRoZSAqIDEuNSBpcyBoZXJlIHNvIHRoZSBlZGdlIGxvb2tzIGFzIGxhcmdlIGFzIGEgc21vb3RoIGVkZ2UuIEl0IGRvZXMgbm90IGluaXRpYWxseSBiZWNhdXNlIHRoZSBzbW9vdGggZWRnZXMgdXNlXG4gICAgICAgICAgICAgICAgLy8gdGhlIHN1cHBvcnQgbm9kZXMgd2hpY2ggZXhlcnQgYSByZXB1bHNpdmUgZm9yY2Ugb24gdGhlIHRvIGFuZCBmcm9tIG5vZGVzLCBtYWtpbmcgdGhlIGVkZ2UgYXBwZWFyIGxhcmdlci5cbiAgICAgICAgICAgICAgICBlZGdlTGVuZ3RoID0gZWRnZS5vcHRpb25zLmxlbmd0aCA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLnNwcmluZ0xlbmd0aCAqIDEuNSA6IGVkZ2Uub3B0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlU3ByaW5nRm9yY2UoZWRnZS5mcm9tLCBlZGdlLnRvLCBlZGdlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgaXMgdGhlIGNvZGUgYWN0dWFsbHkgcGVyZm9ybWluZyB0aGUgY2FsY3VsYXRpb24gZm9yIHRoZSBmdW5jdGlvbiBhYm92ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gbm9kZTFcbiAgICAgICAqIEBwYXJhbSBub2RlMlxuICAgICAgICogQHBhcmFtIGVkZ2VMZW5ndGhcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfY2FsY3VsYXRlU3ByaW5nRm9yY2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlU3ByaW5nRm9yY2Uobm9kZTEsIG5vZGUyLCBlZGdlTGVuZ3RoKSB7XG4gICAgICAgIHZhciBkeCA9IG5vZGUxLnggLSBub2RlMi54O1xuICAgICAgICB2YXIgZHkgPSBub2RlMS55IC0gbm9kZTIueTtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5tYXgoTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSwgMC4wMSk7XG5cbiAgICAgICAgLy8gdGhlIDEvZGlzdGFuY2UgaXMgc28gdGhlIGZ4IGFuZCBmeSBjYW4gYmUgY2FsY3VsYXRlZCB3aXRob3V0IHNpbmUgb3IgY29zaW5lLlxuICAgICAgICB2YXIgc3ByaW5nRm9yY2UgPSB0aGlzLm9wdGlvbnMuc3ByaW5nQ29uc3RhbnQgKiAoZWRnZUxlbmd0aCAtIGRpc3RhbmNlKSAvIGRpc3RhbmNlO1xuXG4gICAgICAgIHZhciBmeCA9IGR4ICogc3ByaW5nRm9yY2U7XG4gICAgICAgIHZhciBmeSA9IGR5ICogc3ByaW5nRm9yY2U7XG5cbiAgICAgICAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIG9uZSBub2RlIGlzIG5vdCBwYXJ0IG9mIHRoZSBwaHlzY2lzXG4gICAgICAgIGlmICh0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlMS5pZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUxLmlkXS54ICs9IGZ4O1xuICAgICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUxLmlkXS55ICs9IGZ5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUyLmlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZTIuaWRdLnggLT0gZng7XG4gICAgICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZTIuaWRdLnkgLT0gZnk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gU3ByaW5nU29sdmVyO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gU3ByaW5nU29sdmVyO1xuXG4vKioqLyB9LFxuLyogMTAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICBcInVzZSBzdHJpY3RcIjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIEhpZXJhcmNoaWNhbFNwcmluZ1NvbHZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIpO1xuXG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIsIFt7XG4gICAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgc3ByaW5nZm9yY2VzIG9uIHRoZSBub2RlcywgYWNjb3VudGluZyBmb3IgdGhlIHN1cHBvcnQgbm9kZXMuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInNvbHZlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICAgIHZhciBlZGdlTGVuZ3RoLCBlZGdlO1xuICAgICAgICB2YXIgZHgsIGR5LCBmeCwgZnksIHNwcmluZ0ZvcmNlLCBkaXN0YW5jZTtcbiAgICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgICB2YXIgZmFjdG9yID0gMC41O1xuXG4gICAgICAgIHZhciBlZGdlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc0VkZ2VJbmRpY2VzO1xuICAgICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcztcbiAgICAgICAgdmFyIGZvcmNlcyA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzO1xuXG4gICAgICAgIC8vIGluaXRpYWxpemUgdGhlIHNwcmluZyBmb3JjZSBjb3VudGVyc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGVJbmRpY2VzW2ldO1xuICAgICAgICAgIGZvcmNlc1tub2RlSWRdLnNwcmluZ0Z4ID0gMDtcbiAgICAgICAgICBmb3JjZXNbbm9kZUlkXS5zcHJpbmdGeSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmb3JjZXMgY2F1c2VkIGJ5IHRoZSBlZGdlcywgbW9kZWxsZWQgYXMgc3ByaW5nc1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWRnZUluZGljZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgZWRnZSA9IGVkZ2VzW2VkZ2VJbmRpY2VzW19pXV07XG4gICAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICBlZGdlTGVuZ3RoID0gZWRnZS5vcHRpb25zLmxlbmd0aCA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLnNwcmluZ0xlbmd0aCA6IGVkZ2Uub3B0aW9ucy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGR4ID0gZWRnZS5mcm9tLnggLSBlZGdlLnRvLng7XG4gICAgICAgICAgICBkeSA9IGVkZ2UuZnJvbS55IC0gZWRnZS50by55O1xuICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgICAgZGlzdGFuY2UgPSBkaXN0YW5jZSA9PT0gMCA/IDAuMDEgOiBkaXN0YW5jZTtcblxuICAgICAgICAgICAgLy8gdGhlIDEvZGlzdGFuY2UgaXMgc28gdGhlIGZ4IGFuZCBmeSBjYW4gYmUgY2FsY3VsYXRlZCB3aXRob3V0IHNpbmUgb3IgY29zaW5lLlxuICAgICAgICAgICAgc3ByaW5nRm9yY2UgPSB0aGlzLm9wdGlvbnMuc3ByaW5nQ29uc3RhbnQgKiAoZWRnZUxlbmd0aCAtIGRpc3RhbmNlKSAvIGRpc3RhbmNlO1xuXG4gICAgICAgICAgICBmeCA9IGR4ICogc3ByaW5nRm9yY2U7XG4gICAgICAgICAgICBmeSA9IGR5ICogc3ByaW5nRm9yY2U7XG5cbiAgICAgICAgICAgIGlmIChlZGdlLnRvLmxldmVsICE9IGVkZ2UuZnJvbS5sZXZlbCkge1xuICAgICAgICAgICAgICBpZiAoZm9yY2VzW2VkZ2UudG9JZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvcmNlc1tlZGdlLnRvSWRdLnNwcmluZ0Z4IC09IGZ4O1xuICAgICAgICAgICAgICAgIGZvcmNlc1tlZGdlLnRvSWRdLnNwcmluZ0Z5IC09IGZ5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmb3JjZXNbZWRnZS5mcm9tSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3JjZXNbZWRnZS5mcm9tSWRdLnNwcmluZ0Z4ICs9IGZ4O1xuICAgICAgICAgICAgICAgIGZvcmNlc1tlZGdlLmZyb21JZF0uc3ByaW5nRnkgKz0gZnk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChmb3JjZXNbZWRnZS50b0lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UudG9JZF0ueCAtPSBmYWN0b3IgKiBmeDtcbiAgICAgICAgICAgICAgICBmb3JjZXNbZWRnZS50b0lkXS55IC09IGZhY3RvciAqIGZ5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmb3JjZXNbZWRnZS5mcm9tSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3JjZXNbZWRnZS5mcm9tSWRdLnggKz0gZmFjdG9yICogZng7XG4gICAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UuZnJvbUlkXS55ICs9IGZhY3RvciAqIGZ5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm9ybWFsaXplIHNwcmluZyBmb3JjZXNcbiAgICAgICAgdmFyIHNwcmluZ0ZvcmNlID0gMTtcbiAgICAgICAgdmFyIHNwcmluZ0Z4LCBzcHJpbmdGeTtcbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZUluZGljZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIHZhciBfbm9kZUlkID0gbm9kZUluZGljZXNbX2kyXTtcbiAgICAgICAgICBzcHJpbmdGeCA9IE1hdGgubWluKHNwcmluZ0ZvcmNlLCBNYXRoLm1heCgtc3ByaW5nRm9yY2UsIGZvcmNlc1tfbm9kZUlkXS5zcHJpbmdGeCkpO1xuICAgICAgICAgIHNwcmluZ0Z5ID0gTWF0aC5taW4oc3ByaW5nRm9yY2UsIE1hdGgubWF4KC1zcHJpbmdGb3JjZSwgZm9yY2VzW19ub2RlSWRdLnNwcmluZ0Z5KSk7XG5cbiAgICAgICAgICBmb3JjZXNbX25vZGVJZF0ueCArPSBzcHJpbmdGeDtcbiAgICAgICAgICBmb3JjZXNbX25vZGVJZF0ueSArPSBzcHJpbmdGeTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldGFpbiBlbmVyZ3kgYmFsYW5jZVxuICAgICAgICB2YXIgdG90YWxGeCA9IDA7XG4gICAgICAgIHZhciB0b3RhbEZ5ID0gMDtcbiAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbm9kZUluZGljZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICAgIHZhciBfbm9kZUlkMiA9IG5vZGVJbmRpY2VzW19pM107XG4gICAgICAgICAgdG90YWxGeCArPSBmb3JjZXNbX25vZGVJZDJdLng7XG4gICAgICAgICAgdG90YWxGeSArPSBmb3JjZXNbX25vZGVJZDJdLnk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvcnJlY3Rpb25GeCA9IHRvdGFsRnggLyBub2RlSW5kaWNlcy5sZW5ndGg7XG4gICAgICAgIHZhciBjb3JyZWN0aW9uRnkgPSB0b3RhbEZ5IC8gbm9kZUluZGljZXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgICB2YXIgX25vZGVJZDMgPSBub2RlSW5kaWNlc1tfaTRdO1xuICAgICAgICAgIGZvcmNlc1tfbm9kZUlkM10ueCAtPSBjb3JyZWN0aW9uRng7XG4gICAgICAgICAgZm9yY2VzW19ub2RlSWQzXS55IC09IGNvcnJlY3Rpb25GeTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXI7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXI7XG5cbi8qKiovIH0sXG4vKiAxMDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICB2YXIgQ2VudHJhbEdyYXZpdHlTb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2VudHJhbEdyYXZpdHlTb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDZW50cmFsR3Jhdml0eVNvbHZlcik7XG5cbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICB0aGlzLnBoeXNpY3NCb2R5ID0gcGh5c2ljc0JvZHk7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKENlbnRyYWxHcmF2aXR5U29sdmVyLCBbe1xuICAgICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic29sdmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZSgpIHtcbiAgICAgICAgdmFyIGR4ID0gdm9pZCAwLFxuICAgICAgICAgICAgZHkgPSB2b2lkIDAsXG4gICAgICAgICAgICBkaXN0YW5jZSA9IHZvaWQgMCxcbiAgICAgICAgICAgIG5vZGUgPSB2b2lkIDA7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICAgIHZhciBmb3JjZXMgPSB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGVJbmRpY2VzW2ldO1xuICAgICAgICAgIG5vZGUgPSBub2Rlc1tub2RlSWRdO1xuICAgICAgICAgIGR4ID0gLW5vZGUueDtcbiAgICAgICAgICBkeSA9IC1ub2RlLnk7XG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgICAgdGhpcy5fY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIGZvcmNlcywgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyBiYXNlZCBvbiB0aGUgZGlzdGFuY2UuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2NhbGN1bGF0ZUZvcmNlc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgZm9yY2VzLCBub2RlKSB7XG4gICAgICAgIHZhciBncmF2aXR5Rm9yY2UgPSBkaXN0YW5jZSA9PT0gMCA/IDAgOiB0aGlzLm9wdGlvbnMuY2VudHJhbEdyYXZpdHkgLyBkaXN0YW5jZTtcbiAgICAgICAgZm9yY2VzW25vZGUuaWRdLnggPSBkeCAqIGdyYXZpdHlGb3JjZTtcbiAgICAgICAgZm9yY2VzW25vZGUuaWRdLnkgPSBkeSAqIGdyYXZpdHlGb3JjZTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ2VudHJhbEdyYXZpdHlTb2x2ZXI7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBDZW50cmFsR3Jhdml0eVNvbHZlcjtcblxuLyoqKi8gfSxcbi8qIDEwMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX0Jhcm5lc0h1dFNvbHZlcjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2KTtcblxuICB2YXIgX0Jhcm5lc0h1dFNvbHZlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXJuZXNIdXRTb2x2ZXIyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXIgPSBmdW5jdGlvbiAoX0Jhcm5lc0h1dFNvbHZlcikge1xuICAgIF9pbmhlcml0cyhGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyLCBfQmFybmVzSHV0U29sdmVyKTtcblxuICAgIGZ1bmN0aW9uIEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyKTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlcikpLmNhbGwodGhpcywgYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyBiYXNlZCBvbiB0aGUgZGlzdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGlzdGFuY2VcbiAgICAgKiBAcGFyYW0gZHhcbiAgICAgKiBAcGFyYW0gZHlcbiAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAqIEBwYXJhbSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlciwgW3tcbiAgICAgIGtleTogXCJfY2FsY3VsYXRlRm9yY2VzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBub2RlLCBwYXJlbnRCcmFuY2gpIHtcbiAgICAgICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAgICAgZGlzdGFuY2UgPSAwLjEgKiBNYXRoLnJhbmRvbSgpO1xuICAgICAgICAgIGR4ID0gZGlzdGFuY2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yIDwgMSAmJiBub2RlLnNoYXBlLnJhZGl1cykge1xuICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5tYXgoMC4xICsgdGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yICogbm9kZS5zaGFwZS5yYWRpdXMsIGRpc3RhbmNlIC0gbm9kZS5zaGFwZS5yYWRpdXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlZ3JlZSA9IG5vZGUuZWRnZXMubGVuZ3RoICsgMTtcbiAgICAgICAgLy8gdGhlIGRpdmlkaW5nIGJ5IHRoZSBkaXN0YW5jZSBjdWJlZCBpbnN0ZWFkIG9mIHNxdWFyZWQgYWxsb3dzIHVzIHRvIGdldCB0aGUgZnggYW5kIGZ5IGNvbXBvbmVudHMgd2l0aG91dCBzaW5lcyBhbmQgY29zaW5lc1xuICAgICAgICAvLyBpdCBpcyBzaG9ydGhhbmQgZm9yIGdyYXZpdHlmb3JjZSB3aXRoIGRpc3RhbmNlIHNxdWFyZWQgYW5kIGZ4ID0gZHgvZGlzdGFuY2UgKiBncmF2aXR5Rm9yY2VcbiAgICAgICAgdmFyIGdyYXZpdHlGb3JjZSA9IHRoaXMub3B0aW9ucy5ncmF2aXRhdGlvbmFsQ29uc3RhbnQgKiBwYXJlbnRCcmFuY2gubWFzcyAqIG5vZGUub3B0aW9ucy5tYXNzICogZGVncmVlIC8gTWF0aC5wb3coZGlzdGFuY2UsIDIpO1xuICAgICAgICB2YXIgZnggPSBkeCAqIGdyYXZpdHlGb3JjZTtcbiAgICAgICAgdmFyIGZ5ID0gZHkgKiBncmF2aXR5Rm9yY2U7XG5cbiAgICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZS5pZF0ueCArPSBmeDtcbiAgICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZS5pZF0ueSArPSBmeTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlcjtcbiAgfShfQmFybmVzSHV0U29sdmVyMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyO1xuXG4vKioqLyB9LFxuLyogMTAzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICBcInVzZSBzdHJpY3RcIjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfQ2VudHJhbEdyYXZpdHlTb2x2ZXIyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDEpO1xuXG4gIHZhciBfQ2VudHJhbEdyYXZpdHlTb2x2ZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2VudHJhbEdyYXZpdHlTb2x2ZXIyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlciA9IGZ1bmN0aW9uIChfQ2VudHJhbEdyYXZpdHlTb2x2ZXIpIHtcbiAgICBfaW5oZXJpdHMoRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyLCBfQ2VudHJhbEdyYXZpdHlTb2x2ZXIpO1xuXG4gICAgZnVuY3Rpb24gRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyKTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIpKS5jYWxsKHRoaXMsIGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBmb3JjZXMgYmFzZWQgb24gdGhlIGRpc3RhbmNlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIsIFt7XG4gICAgICBrZXk6IFwiX2NhbGN1bGF0ZUZvcmNlc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgZm9yY2VzLCBub2RlKSB7XG4gICAgICAgIGlmIChkaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICB2YXIgZGVncmVlID0gbm9kZS5lZGdlcy5sZW5ndGggKyAxO1xuICAgICAgICAgIHZhciBncmF2aXR5Rm9yY2UgPSB0aGlzLm9wdGlvbnMuY2VudHJhbEdyYXZpdHkgKiBkZWdyZWUgKiBub2RlLm9wdGlvbnMubWFzcztcbiAgICAgICAgICBmb3JjZXNbbm9kZS5pZF0ueCA9IGR4ICogZ3Jhdml0eUZvcmNlO1xuICAgICAgICAgIGZvcmNlc1tub2RlLmlkXS55ID0gZHkgKiBncmF2aXR5Rm9yY2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyO1xuICB9KF9DZW50cmFsR3Jhdml0eVNvbHZlcjMuZGVmYXVsdCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyO1xuXG4vKioqLyB9LFxuLyogMTA0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9OZXR3b3JrVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTA1KTtcblxuICB2YXIgX05ldHdvcmtVdGlsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05ldHdvcmtVdGlsKTtcblxuICB2YXIgX0NsdXN0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNik7XG5cbiAgdmFyIF9DbHVzdGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NsdXN0ZXIpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIENsdXN0ZXJFbmdpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2x1c3RlckVuZ2luZShib2R5KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2x1c3RlckVuZ2luZSk7XG5cbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICB0aGlzLmNsdXN0ZXJlZE5vZGVzID0ge307XG4gICAgICB0aGlzLmNsdXN0ZXJlZEVkZ2VzID0ge307XG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHt9O1xuICAgICAgdXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19yZXNldERhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmNsdXN0ZXJlZE5vZGVzID0ge307X3RoaXMuY2x1c3RlcmVkRWRnZXMgPSB7fTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICpcbiAgICAqIEBwYXJhbSBodWJzaXplXG4gICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhDbHVzdGVyRW5naW5lLCBbe1xuICAgICAga2V5OiAnY2x1c3RlckJ5SHVic2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2x1c3RlckJ5SHVic2l6ZShodWJzaXplLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChodWJzaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBodWJzaXplID0gdGhpcy5fZ2V0SHViU2l6ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgaHVic2l6ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoaHVic2l6ZSkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMuX2NoZWNrT3B0aW9ucyhodWJzaXplKTtcbiAgICAgICAgICBodWJzaXplID0gdGhpcy5fZ2V0SHViU2l6ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vZGVzVG9DbHVzdGVyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgICBpZiAobm9kZS5lZGdlcy5sZW5ndGggPj0gaHVic2l6ZSkge1xuICAgICAgICAgICAgbm9kZXNUb0NsdXN0ZXIucHVzaChub2RlLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbm9kZXNUb0NsdXN0ZXIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdGhpcy5jbHVzdGVyQnlDb25uZWN0aW9uKG5vZGVzVG9DbHVzdGVyW19pXSwgb3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfZGF0YUNoYW5nZWQnKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAqIGxvb3Agb3ZlciBhbGwgbm9kZXMsIGNoZWNrIGlmIHRoZXkgYWRoZXJlIHRvIHRoZSBjb25kaXRpb24gYW5kIGNsdXN0ZXIgaWYgbmVlZGVkLlxuICAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAgKiBAcGFyYW0gcmVmcmVzaERhdGFcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjbHVzdGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgICBpZiAob3B0aW9ucy5qb2luQ29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBjbHVzdGVyQnlOb2RlRGF0YSB3aXRob3V0IGEgam9pbkNvbmRpdGlvbiBmdW5jdGlvbiBpbiB0aGUgb3B0aW9ucy5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgb3B0aW9ucyBvYmplY3QgaXMgZmluZSwgYXBwZW5kIGlmIG5lZWRlZFxuICAgICAgICBvcHRpb25zID0gdGhpcy5fY2hlY2tPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciBjaGlsZE5vZGVzT2JqID0ge307XG4gICAgICAgIHZhciBjaGlsZEVkZ2VzT2JqID0ge307XG5cbiAgICAgICAgLy8gY29sbGVjdCB0aGUgbm9kZXMgdGhhdCB3aWxsIGJlIGluIHRoZSBjbHVzdGVyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGVJZCA9IHRoaXMuYm9keS5ub2RlSW5kaWNlc1tpXTtcbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgIHZhciBjbG9uZWRPcHRpb25zID0gX05ldHdvcmtVdGlsMi5kZWZhdWx0LmNsb25lT3B0aW9ucyhub2RlKTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5qb2luQ29uZGl0aW9uKGNsb25lZE9wdGlvbnMpID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjaGlsZE5vZGVzT2JqW25vZGVJZF0gPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcblxuICAgICAgICAgICAgLy8gY29sbGVjdCB0aGUgbm9kZXMgdGhhdCB3aWxsIGJlIGluIHRoZSBjbHVzdGVyXG4gICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2RlLmVkZ2VzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgICAgdmFyIGVkZ2UgPSBub2RlLmVkZ2VzW19pMl07XG4gICAgICAgICAgICAgIGlmICh0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NsdXN0ZXIoY2hpbGROb2Rlc09iaiwgY2hpbGRFZGdlc09iaiwgb3B0aW9ucywgcmVmcmVzaERhdGEpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENsdXN0ZXIgYWxsIG5vZGVzIGluIHRoZSBuZXR3b3JrIHRoYXQgaGF2ZSBvbmx5IFggZWRnZXNcbiAgICAgICAqIEBwYXJhbSBlZGdlQ291bnRcbiAgICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICAgKiBAcGFyYW0gcmVmcmVzaERhdGFcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnY2x1c3RlckJ5RWRnZUNvdW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyQnlFZGdlQ291bnQoZWRnZUNvdW50LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcblxuICAgICAgICBvcHRpb25zID0gdGhpcy5fY2hlY2tPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB2YXIgY2x1c3RlcnMgPSBbXTtcbiAgICAgICAgdmFyIHVzZWROb2RlcyA9IHt9O1xuICAgICAgICB2YXIgZWRnZSA9IHZvaWQgMCxcbiAgICAgICAgICAgIGVkZ2VzID0gdm9pZCAwLFxuICAgICAgICAgICAgbm9kZSA9IHZvaWQgMCxcbiAgICAgICAgICAgIG5vZGVJZCA9IHZvaWQgMCxcbiAgICAgICAgICAgIHJlbGV2YW50RWRnZUNvdW50ID0gdm9pZCAwO1xuICAgICAgICAvLyBjb2xsZWN0IHRoZSBub2RlcyB0aGF0IHdpbGwgYmUgaW4gdGhlIGNsdXN0ZXJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2hpbGROb2Rlc09iaiA9IHt9O1xuICAgICAgICAgIHZhciBjaGlsZEVkZ2VzT2JqID0ge307XG4gICAgICAgICAgbm9kZUlkID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldO1xuXG4gICAgICAgICAgLy8gaWYgdGhpcyBub2RlIGlzIGFscmVhZHkgdXNlZCBpbiBhbm90aGVyIGNsdXN0ZXIgdGhpcyBzZXNzaW9uLCB3ZSBkbyBub3QgaGF2ZSB0byByZS1ldmFsdWF0ZSBpdC5cbiAgICAgICAgICBpZiAodXNlZE5vZGVzW25vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVsZXZhbnRFZGdlQ291bnQgPSAwO1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgZWRnZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZS5lZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBlZGdlID0gbm9kZS5lZGdlc1tqXTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChlZGdlLnRvSWQgIT09IGVkZ2UuZnJvbUlkKSB7XG4gICAgICAgICAgICAgICAgICByZWxldmFudEVkZ2VDb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRoaXMgbm9kZSBxdWFsaWZpZXMsIHdlIGNvbGxlY3QgaXRzIG5laWdoYm91cnMgdG8gc3RhcnQgdGhlIGNsdXN0ZXJpbmcgcHJvY2Vzcy5cbiAgICAgICAgICAgIGlmIChyZWxldmFudEVkZ2VDb3VudCA9PT0gZWRnZUNvdW50KSB7XG4gICAgICAgICAgICAgIHZhciBnYXRoZXJpbmdTdWNjZXNzZnVsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IGVkZ2VzLmxlbmd0aDsgX2orKykge1xuICAgICAgICAgICAgICAgIGVkZ2UgPSBlZGdlc1tfal07XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZUlkID0gdGhpcy5fZ2V0Q29ubmVjdGVkSWQoZWRnZSwgbm9kZUlkKTtcbiAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIG5vZGVzIHRvIHRoZSBsaXN0IGJ5IHRoZSBqb2luIGNvbmRpdGlvbi5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5qb2luQ29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgICAgICAgICAgY2hpbGROb2Rlc09ialtub2RlSWRdID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzT2JqW2NoaWxkTm9kZUlkXSA9IHRoaXMuYm9keS5ub2Rlc1tjaGlsZE5vZGVJZF07XG4gICAgICAgICAgICAgICAgICB1c2VkTm9kZXNbbm9kZUlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjbG9uZWRPcHRpb25zID0gX05ldHdvcmtVdGlsMi5kZWZhdWx0LmNsb25lT3B0aW9ucyh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXSk7XG4gICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5qb2luQ29uZGl0aW9uKGNsb25lZE9wdGlvbnMpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzT2JqW25vZGVJZF0gPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgICAgICAgICAgdXNlZE5vZGVzW25vZGVJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBub2RlIGRvZXMgbm90IHF1YWxpZnkgYWZ0ZXIgYWxsLlxuICAgICAgICAgICAgICAgICAgICBnYXRoZXJpbmdTdWNjZXNzZnVsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGFkZCB0byB0aGUgY2x1c3RlciBxdWV1ZVxuICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoY2hpbGROb2Rlc09iaikubGVuZ3RoID4gMCAmJiBPYmplY3Qua2V5cyhjaGlsZEVkZ2VzT2JqKS5sZW5ndGggPiAwICYmIGdhdGhlcmluZ1N1Y2Nlc3NmdWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjbHVzdGVycy5wdXNoKHsgbm9kZXM6IGNoaWxkTm9kZXNPYmosIGVkZ2VzOiBjaGlsZEVkZ2VzT2JqIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgY2x1c3RlcnMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICAgIHRoaXMuX2NsdXN0ZXIoY2x1c3RlcnNbX2kzXS5ub2RlcywgY2x1c3RlcnNbX2kzXS5lZGdlcywgb3B0aW9ucywgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlZnJlc2hEYXRhID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAqIENsdXN0ZXIgYWxsIG5vZGVzIGluIHRoZSBuZXR3b3JrIHRoYXQgaGF2ZSBvbmx5IDEgZWRnZVxuICAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAgKiBAcGFyYW0gcmVmcmVzaERhdGFcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjbHVzdGVyT3V0bGllcnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsdXN0ZXJPdXRsaWVycyhvcHRpb25zKSB7XG4gICAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgICB0aGlzLmNsdXN0ZXJCeUVkZ2VDb3VudCgxLCBvcHRpb25zLCByZWZyZXNoRGF0YSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2x1c3RlciBhbGwgbm9kZXMgaW4gdGhlIG5ldHdvcmsgdGhhdCBoYXZlIG9ubHkgMiBlZGdlXG4gICAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAgICogQHBhcmFtIHJlZnJlc2hEYXRhXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NsdXN0ZXJCcmlkZ2VzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyQnJpZGdlcyhvcHRpb25zKSB7XG4gICAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgICB0aGlzLmNsdXN0ZXJCeUVkZ2VDb3VudCgyLCBvcHRpb25zLCByZWZyZXNoRGF0YSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgKiBzdWNrIGFsbCBjb25uZWN0ZWQgbm9kZXMgb2YgYSBub2RlIGludG8gdGhlIG5vZGUuXG4gICAgICAqIEBwYXJhbSBub2RlSWRcbiAgICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgICogQHBhcmFtIHJlZnJlc2hEYXRhXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnY2x1c3RlckJ5Q29ubmVjdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2x1c3RlckJ5Q29ubmVjdGlvbihub2RlSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuXG4gICAgICAgIC8vIGtpbGwgY29uZGl0aW9uc1xuICAgICAgICBpZiAobm9kZUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBub2RlSWQgc3VwcGxpZWQgdG8gY2x1c3RlckJ5Q29ubmVjdGlvbiFcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbm9kZUlkIGdpdmVuIHRvIGNsdXN0ZXJCeUNvbm5lY3Rpb24gZG9lcyBub3QgZXhpc3QhXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMuX2NoZWNrT3B0aW9ucyhvcHRpb25zLCBub2RlKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnggPSBub2RlLng7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnkgPSBub2RlLnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmZpeGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy5maXhlZCA9IHt9O1xuICAgICAgICAgIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmZpeGVkLnggPSBub2RlLm9wdGlvbnMuZml4ZWQueDtcbiAgICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy5maXhlZC55ID0gbm9kZS5vcHRpb25zLmZpeGVkLnk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hpbGROb2Rlc09iaiA9IHt9O1xuICAgICAgICB2YXIgY2hpbGRFZGdlc09iaiA9IHt9O1xuICAgICAgICB2YXIgcGFyZW50Tm9kZUlkID0gbm9kZS5pZDtcbiAgICAgICAgdmFyIHBhcmVudENsb25lZE9wdGlvbnMgPSBfTmV0d29ya1V0aWwyLmRlZmF1bHQuY2xvbmVPcHRpb25zKG5vZGUpO1xuICAgICAgICBjaGlsZE5vZGVzT2JqW3BhcmVudE5vZGVJZF0gPSBub2RlO1xuXG4gICAgICAgIC8vIGNvbGxlY3QgdGhlIG5vZGVzIHRoYXQgd2lsbCBiZSBpbiB0aGUgY2x1c3RlclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IG5vZGUuZWRnZXNbaV07XG4gICAgICAgICAgaWYgKHRoaXMuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZUlkID0gdGhpcy5fZ2V0Q29ubmVjdGVkSWQoZWRnZSwgcGFyZW50Tm9kZUlkKTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlIGNoaWxkIG5vZGUgaXMgbm90IGluIGEgY2x1c3RlclxuICAgICAgICAgICAgaWYgKHRoaXMuY2x1c3RlcmVkTm9kZXNbY2hpbGROb2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZUlkICE9PSBwYXJlbnROb2RlSWQpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5qb2luQ29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgICAgICAgICAgY2hpbGROb2Rlc09ialtjaGlsZE5vZGVJZF0gPSB0aGlzLmJvZHkubm9kZXNbY2hpbGROb2RlSWRdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBjbG9uZSB0aGUgb3B0aW9ucyBhbmQgaW5zZXJ0IHNvbWUgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRoYXQgY291bGQgYmUgaW50ZXJlc3RpbmcuXG4gICAgICAgICAgICAgICAgICB2YXIgY2hpbGRDbG9uZWRPcHRpb25zID0gX05ldHdvcmtVdGlsMi5kZWZhdWx0LmNsb25lT3B0aW9ucyh0aGlzLmJvZHkubm9kZXNbY2hpbGROb2RlSWRdKTtcbiAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmpvaW5Db25kaXRpb24ocGFyZW50Q2xvbmVkT3B0aW9ucywgY2hpbGRDbG9uZWRPcHRpb25zKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2Rlc09ialtjaGlsZE5vZGVJZF0gPSB0aGlzLmJvZHkubm9kZXNbY2hpbGROb2RlSWRdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzd2FsbG93IHRoZSBlZGdlIGlmIGl0IGlzIHNlbGYtcmVmZXJlbmNpbmcuXG4gICAgICAgICAgICAgICAgY2hpbGRFZGdlc09ialtlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoaWxkTm9kZUlEcyA9IE9iamVjdC5rZXlzKGNoaWxkTm9kZXNPYmopLm1hcChmdW5jdGlvbiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZXNPYmpbY2hpbGROb2RlXS5pZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yIChjaGlsZE5vZGUgaW4gY2hpbGROb2Rlc09iaikge1xuICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzT2JqW2NoaWxkTm9kZV07XG4gICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjaGlsZE5vZGUuZWRnZXMubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZEVkZ2UgPSBjaGlsZE5vZGUuZWRnZXNbeV07XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlSURzLmluZGV4T2YodGhpcy5fZ2V0Q29ubmVjdGVkSWQoY2hpbGRFZGdlLCBjaGlsZE5vZGUuaWQpKSA+IC0xKSB7XG4gICAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbY2hpbGRFZGdlLmlkXSA9IGNoaWxkRWRnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2x1c3RlcihjaGlsZE5vZGVzT2JqLCBjaGlsZEVkZ2VzT2JqLCBvcHRpb25zLCByZWZyZXNoRGF0YSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgKiBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgdGhlIGVkZ2VzIHRoYXQgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGUgY2x1c3RlclxuICAgICAgKiBJdCBsb29rcyBmb3IgZWRnZXMgdGhhdCBhcmUgY29ubmVjdGVkIHRvIHRoZSBub2RlcyBmcm9tIHRoZSBcIm91dHNpZGUnIG9mIHRoZSBjbHVzdGVyLlxuICAgICAgKlxuICAgICAgKiBAcGFyYW0gY2hpbGROb2Rlc09ialxuICAgICAgKiBAcGFyYW0gY2hpbGRFZGdlc09ialxuICAgICAgKiBAcGFyYW0gY2x1c3Rlck5vZGVQcm9wZXJ0aWVzXG4gICAgICAqIEBwYXJhbSBjbHVzdGVyRWRnZVByb3BlcnRpZXNcbiAgICAgICogQHByaXZhdGVcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY3JlYXRlQ2x1c3RlckVkZ2VzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQ2x1c3RlckVkZ2VzKGNoaWxkTm9kZXNPYmosIGNoaWxkRWRnZXNPYmosIGNsdXN0ZXJOb2RlUHJvcGVydGllcywgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzKSB7XG4gICAgICAgIHZhciBlZGdlID0gdm9pZCAwLFxuICAgICAgICAgICAgY2hpbGROb2RlSWQgPSB2b2lkIDAsXG4gICAgICAgICAgICBjaGlsZE5vZGUgPSB2b2lkIDAsXG4gICAgICAgICAgICB0b0lkID0gdm9pZCAwLFxuICAgICAgICAgICAgZnJvbUlkID0gdm9pZCAwLFxuICAgICAgICAgICAgb3RoZXJOb2RlSWQgPSB2b2lkIDA7XG5cbiAgICAgICAgLy8gbG9vcCBvdmVyIGFsbCBjaGlsZCBub2RlcyBhbmQgdGhlaXIgZWRnZXMgdG8gZmluZCBlZGdlcyBnb2luZyBvdXQgb2YgdGhlIGNsdXN0ZXJcbiAgICAgICAgLy8gdGhlc2UgZWRnZXMgd2lsbCBiZSByZXBsYWNlZCBieSBjbHVzdGVyRWRnZXMuXG4gICAgICAgIHZhciBjaGlsZEtleXMgPSBPYmplY3Qua2V5cyhjaGlsZE5vZGVzT2JqKTtcbiAgICAgICAgdmFyIGNyZWF0ZUVkZ2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGROb2RlSWQgPSBjaGlsZEtleXNbaV07XG4gICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlc09ialtjaGlsZE5vZGVJZF07XG5cbiAgICAgICAgICAvLyBjb25zdHJ1Y3QgbmV3IGVkZ2VzIGZyb20gdGhlIGNsdXN0ZXIgdG8gb3RoZXJzXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGlsZE5vZGUuZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGVkZ2UgPSBjaGlsZE5vZGUuZWRnZXNbal07XG4gICAgICAgICAgICAvLyB3ZSBvbmx5IGhhbmRsZSBlZGdlcyB0aGF0IGFyZSB2aXNpYmxlIHRvIHRoZSBzeXN0ZW0sIG5vdCB0aGUgZGlzYWJsZWQgb25lcyBmcm9tIHRoZSBjbHVzdGVyaW5nIHByb2Nlc3MuXG4gICAgICAgICAgICBpZiAodGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIC8vIHNlbGYtcmVmZXJlbmNpbmcgZWRnZXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgXCJoaWRkZW5cIiBsaXN0XG4gICAgICAgICAgICAgIGlmIChlZGdlLnRvSWQgPT0gZWRnZS5mcm9tSWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgdXAgdGhlIGZyb20gYW5kIHRvLlxuICAgICAgICAgICAgICAgIGlmIChlZGdlLnRvSWQgPT0gY2hpbGROb2RlSWQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBkb3VibGUgZXF1YWxzIGJlY2F1c2UgaW50cyBhbmQgc3RyaW5ncyBjYW4gYmUgaW50ZXJjaGFuZ2VkIGhlcmUuXG4gICAgICAgICAgICAgICAgICB0b0lkID0gY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmlkO1xuICAgICAgICAgICAgICAgICAgZnJvbUlkID0gZWRnZS5mcm9tSWQ7XG4gICAgICAgICAgICAgICAgICBvdGhlck5vZGVJZCA9IGZyb21JZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdG9JZCA9IGVkZ2UudG9JZDtcbiAgICAgICAgICAgICAgICAgIGZyb21JZCA9IGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZDtcbiAgICAgICAgICAgICAgICAgIG90aGVyTm9kZUlkID0gdG9JZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBPbmx5IGVkZ2VzIGZyb20gdGhlIGNsdXN0ZXIgb3V0d2FyZHMgYXJlIGJlaW5nIHJlcGxhY2VkLlxuICAgICAgICAgICAgICBpZiAoY2hpbGROb2Rlc09ialtvdGhlck5vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUVkZ2VzLnB1c2goeyBlZGdlOiBlZGdlLCBmcm9tSWQ6IGZyb21JZCwgdG9JZDogdG9JZCB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhlcmUgd2UgYWN0dWFsbHkgY3JlYXRlIHRoZSByZXBsYWNlbWVudCBlZGdlcy4gV2UgY291bGQgbm90IGRvIHRoaXMgaW4gdGhlIGxvb3AgYWJvdmUgYXMgdGhlIGNyZWF0aW9uIHByb2Nlc3NcbiAgICAgICAgLy8gd291bGQgYWRkIGFuIGVkZ2UgdG8gdGhlIGVkZ2VzIGFycmF5IHdlIGFyZSBpdGVyYXRpbmcgb3Zlci5cbiAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgY3JlYXRlRWRnZXMubGVuZ3RoOyBfajIrKykge1xuICAgICAgICAgIHZhciBfZWRnZSA9IGNyZWF0ZUVkZ2VzW19qMl0uZWRnZTtcbiAgICAgICAgICAvLyBjb3B5IHRoZSBvcHRpb25zIG9mIHRoZSBlZGdlIHdlIHdpbGwgcmVwbGFjZVxuICAgICAgICAgIHZhciBjbG9uZWRPcHRpb25zID0gX05ldHdvcmtVdGlsMi5kZWZhdWx0LmNsb25lT3B0aW9ucyhfZWRnZSwgJ2VkZ2UnKTtcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIHByb3BlcnRpZXMgb2YgY2x1c3RlckVkZ2VzIGFyZSBzdXBlcmltcG9zZWQgb24gaXRcbiAgICAgICAgICB1dGlsLmRlZXBFeHRlbmQoY2xvbmVkT3B0aW9ucywgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzKTtcblxuICAgICAgICAgIC8vIHNldCB1cCB0aGUgZWRnZVxuICAgICAgICAgIGNsb25lZE9wdGlvbnMuZnJvbSA9IGNyZWF0ZUVkZ2VzW19qMl0uZnJvbUlkO1xuICAgICAgICAgIGNsb25lZE9wdGlvbnMudG8gPSBjcmVhdGVFZGdlc1tfajJdLnRvSWQ7XG4gICAgICAgICAgY2xvbmVkT3B0aW9ucy5pZCA9ICdjbHVzdGVyRWRnZTonICsgdXRpbC5yYW5kb21VVUlEKCk7XG4gICAgICAgICAgLy9jbG9uZWRPcHRpb25zLmlkID0gJyhjZjogJyArIGNyZWF0ZUVkZ2VzW2pdLmZyb21JZCArIFwiIHRvOiBcIiArIGNyZWF0ZUVkZ2VzW2pdLnRvSWQgKyBcIilcIiArIE1hdGgucmFuZG9tKCk7XG5cbiAgICAgICAgICAvLyBjcmVhdGUgdGhlIGVkZ2UgYW5kIGdpdmUgYSByZWZlcmVuY2UgdG8gdGhlIG9uZSBpdCByZXBsYWNlZC5cbiAgICAgICAgICB2YXIgbmV3RWRnZSA9IHRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlRWRnZShjbG9uZWRPcHRpb25zKTtcbiAgICAgICAgICBuZXdFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWQgPSBfZWRnZS5pZDtcblxuICAgICAgICAgIC8vIGFsc28gcmVmZXJlbmNlIHRoZSBuZXcgZWRnZSBpbiB0aGUgb2xkIGVkZ2VcbiAgICAgICAgICB0aGlzLmJvZHkuZWRnZXNbX2VkZ2UuaWRdLmVkZ2VSZXBsYWNlZEJ5SWQgPSBuZXdFZGdlLmlkO1xuXG4gICAgICAgICAgLy8gY29ubmVjdCB0aGUgZWRnZS5cbiAgICAgICAgICB0aGlzLmJvZHkuZWRnZXNbbmV3RWRnZS5pZF0gPSBuZXdFZGdlO1xuICAgICAgICAgIG5ld0VkZ2UuY29ubmVjdCgpO1xuXG4gICAgICAgICAgLy8gaGlkZSB0aGUgcmVwbGFjZWQgZWRnZVxuICAgICAgICAgIHRoaXMuX2JhY2t1cEVkZ2VPcHRpb25zKF9lZGdlKTtcbiAgICAgICAgICBfZWRnZS5zZXRPcHRpb25zKHsgcGh5c2ljczogZmFsc2UsIGhpZGRlbjogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICogVGhpcyBmdW5jdGlvbiBjaGVja3MgdGhlIG9wdGlvbnMgdGhhdCBjYW4gYmUgc3VwcGxpZWQgdG8gdGhlIGRpZmZlcmVudCBjbHVzdGVyIGZ1bmN0aW9uc1xuICAgICAgKiBmb3IgY2VydGFpbiBmaWVsZHMgYW5kIGluc2VydHMgZGVmYXVsdHMgaWYgbmVlZGVkXG4gICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgKiBAcHJpdmF0ZVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jaGVja09wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja09wdGlvbnMoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICBpZiAob3B0aW9ucy5jbHVzdGVyRWRnZVByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG9wdGlvbnMuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgKlxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgY2hpbGROb2Rlc09iaiAgICAgICAgIHwgb2JqZWN0IHdpdGggbm9kZSBvYmplY3RzLCBpZCBhcyBrZXlzLCBzYW1lIGFzIGNoaWxkTm9kZXMgZXhjZXB0IGl0IGFsc28gY29udGFpbnMgYSBzb3VyY2Ugbm9kZVxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgY2hpbGRFZGdlc09iaiAgICAgICAgIHwgb2JqZWN0IHdpdGggZWRnZSBvYmplY3RzLCBpZCBhcyBrZXlzXG4gICAgICAqIEBwYXJhbSB7QXJyYXl9ICAgICBvcHRpb25zICAgICAgICAgICAgICAgfCBvYmplY3Qgd2l0aCB7Y2x1c3Rlck5vZGVQcm9wZXJ0aWVzLCBjbHVzdGVyRWRnZVByb3BlcnRpZXMsIHByb2Nlc3NQcm9wZXJ0aWVzfVxuICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgcmVmcmVzaERhdGEgfCB3aGVuIHRydWUsIGRvIG5vdCB3cmFwIHVwXG4gICAgICAqIEBwcml2YXRlXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NsdXN0ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jbHVzdGVyKGNoaWxkTm9kZXNPYmosIGNoaWxkRWRnZXNPYmosIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuXG4gICAgICAgIC8vIGtpbGwgY29uZGl0aW9uOiBubyBub2RlcyBkb24ndCBib3RoZXJcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGNoaWxkTm9kZXNPYmopLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWxsb3cgY2x1c3RlcnMgb2YgMSBpZiBvcHRpb25zIGFsbG93XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhjaGlsZE5vZGVzT2JqKS5sZW5ndGggPT0gMSAmJiBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy5hbGxvd1NpbmdsZU5vZGVDbHVzdGVyICE9IHRydWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGNsdXN0ZXIgY2FsbCBpcyBub3QgdHJ5aW5nIHRvIGNsdXN0ZXIgYW55dGhpbmcgdGhhdCBpcyBpbiBhbm90aGVyIGNsdXN0ZXIuXG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBjaGlsZE5vZGVzT2JqKSB7XG4gICAgICAgICAgaWYgKGNoaWxkTm9kZXNPYmouaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzID0gdXRpbC5kZWVwRXh0ZW5kKHt9LCBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcyk7XG5cbiAgICAgICAgLy8gY29uc3RydWN0IHRoZSBjbHVzdGVyTm9kZVByb3BlcnRpZXNcbiAgICAgICAgaWYgKG9wdGlvbnMucHJvY2Vzc1Byb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGdldCB0aGUgY2hpbGROb2RlIG9wdGlvbnNcbiAgICAgICAgICB2YXIgY2hpbGROb2Rlc09wdGlvbnMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBfbm9kZUlkIGluIGNoaWxkTm9kZXNPYmopIHtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzT2JqLmhhc093blByb3BlcnR5KF9ub2RlSWQpKSB7XG4gICAgICAgICAgICAgIHZhciBjbG9uZWRPcHRpb25zID0gX05ldHdvcmtVdGlsMi5kZWZhdWx0LmNsb25lT3B0aW9ucyhjaGlsZE5vZGVzT2JqW19ub2RlSWRdKTtcbiAgICAgICAgICAgICAgY2hpbGROb2Rlc09wdGlvbnMucHVzaChjbG9uZWRPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBnZXQgY2x1c3RlciBwcm9wZXJ0aWVzIGJhc2VkIG9uIGNoaWxkTm9kZXNcbiAgICAgICAgICB2YXIgY2hpbGRFZGdlc09wdGlvbnMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBlZGdlSWQgaW4gY2hpbGRFZGdlc09iaikge1xuICAgICAgICAgICAgaWYgKGNoaWxkRWRnZXNPYmouaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgICAgICAvLyB0aGVzZSBjbHVzdGVyIGVkZ2VzIHdpbGwgYmUgcmVtb3ZlZCBvbiBjcmVhdGlvbiBvZiB0aGUgY2x1c3Rlci5cbiAgICAgICAgICAgICAgaWYgKGVkZ2VJZC5zdWJzdHIoMCwgMTIpICE9PSBcImNsdXN0ZXJFZGdlOlwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jbG9uZWRPcHRpb25zID0gX05ldHdvcmtVdGlsMi5kZWZhdWx0LmNsb25lT3B0aW9ucyhjaGlsZEVkZ2VzT2JqW2VkZ2VJZF0sICdlZGdlJyk7XG4gICAgICAgICAgICAgICAgY2hpbGRFZGdlc09wdGlvbnMucHVzaChfY2xvbmVkT3B0aW9ucyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXMgPSBvcHRpb25zLnByb2Nlc3NQcm9wZXJ0aWVzKGNsdXN0ZXJOb2RlUHJvcGVydGllcywgY2hpbGROb2Rlc09wdGlvbnMsIGNoaWxkRWRnZXNPcHRpb25zKTtcbiAgICAgICAgICBpZiAoIWNsdXN0ZXJOb2RlUHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHByb2Nlc3NQcm9wZXJ0aWVzIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBwcm9wZXJ0aWVzIVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGFuIHVuaXF1ZSBpZDtcbiAgICAgICAgaWYgKGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmlkID0gJ2NsdXN0ZXI6JyArIHV0aWwucmFuZG9tVVVJRCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjbHVzdGVySWQgPSBjbHVzdGVyTm9kZVByb3BlcnRpZXMuaWQ7XG5cbiAgICAgICAgaWYgKGNsdXN0ZXJOb2RlUHJvcGVydGllcy5sYWJlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmxhYmVsID0gJ2NsdXN0ZXInO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2l2ZSB0aGUgY2x1c3Rlck5vZGUgYSBwb3NpdGlvbiBpZiBpdCBkb2VzIG5vdCBoYXZlIG9uZS5cbiAgICAgICAgdmFyIHBvcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGNsdXN0ZXJOb2RlUHJvcGVydGllcy54ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwb3MgPSB0aGlzLl9nZXRDbHVzdGVyUG9zaXRpb24oY2hpbGROb2Rlc09iaik7XG4gICAgICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnggPSBwb3MueDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChwb3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcG9zID0gdGhpcy5fZ2V0Q2x1c3RlclBvc2l0aW9uKGNoaWxkTm9kZXNPYmopO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXMueSA9IHBvcy55O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZm9yY2UgdGhlIElEIHRvIHJlbWFpbiB0aGUgc2FtZVxuICAgICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXMuaWQgPSBjbHVzdGVySWQ7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBjbHVzdGVyTm9kZVxuICAgICAgICB2YXIgY2x1c3Rlck5vZGUgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZU5vZGUoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLCBfQ2x1c3RlcjIuZGVmYXVsdCk7XG4gICAgICAgIGNsdXN0ZXJOb2RlLmlzQ2x1c3RlciA9IHRydWU7XG4gICAgICAgIGNsdXN0ZXJOb2RlLmNvbnRhaW5lZE5vZGVzID0gY2hpbGROb2Rlc09iajtcbiAgICAgICAgY2x1c3Rlck5vZGUuY29udGFpbmVkRWRnZXMgPSBjaGlsZEVkZ2VzT2JqO1xuICAgICAgICAvLyBjYWNoZSBhIGNvcHkgZnJvbSB0aGUgY2x1c3RlciBlZGdlIHByb3BlcnRpZXMgaWYgd2UgaGF2ZSB0byByZWNvbm5lY3Qgb3RoZXJzIGxhdGVyIG9uXG4gICAgICAgIGNsdXN0ZXJOb2RlLmNsdXN0ZXJFZGdlUHJvcGVydGllcyA9IG9wdGlvbnMuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzO1xuXG4gICAgICAgIC8vIGZpbmFsbHkgcHV0IHRoZSBjbHVzdGVyIG5vZGUgaW50byBnbG9iYWxcbiAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJOb2RlUHJvcGVydGllcy5pZF0gPSBjbHVzdGVyTm9kZTtcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIG5ldyBlZGdlcyB0aGF0IHdpbGwgY29ubmVjdCB0byB0aGUgY2x1c3RlciwgYWxsIHNlbGYtcmVmZXJlbmNpbmcgZWRnZXMgd2lsbCBiZSBhZGRlZCB0byBjaGlsZEVkZ2VzT2JqZWN0IGhlcmUuXG4gICAgICAgIHRoaXMuX2NyZWF0ZUNsdXN0ZXJFZGdlcyhjaGlsZE5vZGVzT2JqLCBjaGlsZEVkZ2VzT2JqLCBjbHVzdGVyTm9kZVByb3BlcnRpZXMsIG9wdGlvbnMuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzKTtcblxuICAgICAgICAvLyBkaXNhYmxlIHRoZSBjaGlsZEVkZ2VzXG4gICAgICAgIGZvciAodmFyIF9lZGdlSWQgaW4gY2hpbGRFZGdlc09iaikge1xuICAgICAgICAgIGlmIChjaGlsZEVkZ2VzT2JqLmhhc093blByb3BlcnR5KF9lZGdlSWQpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ib2R5LmVkZ2VzW19lZGdlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbX2VkZ2VJZF07XG4gICAgICAgICAgICAgIC8vIGNhY2hlIHRoZSBvcHRpb25zIGJlZm9yZSBjaGFuZ2luZ1xuICAgICAgICAgICAgICB0aGlzLl9iYWNrdXBFZGdlT3B0aW9ucyhlZGdlKTtcbiAgICAgICAgICAgICAgLy8gZGlzYWJsZSBwaHlzaWNzIGFuZCBoaWRlIHRoZSBlZGdlXG4gICAgICAgICAgICAgIGVkZ2Uuc2V0T3B0aW9ucyh7IHBoeXNpY3M6IGZhbHNlLCBoaWRkZW46IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGlzYWJsZSB0aGUgY2hpbGROb2Rlc1xuICAgICAgICBmb3IgKHZhciBfbm9kZUlkMiBpbiBjaGlsZE5vZGVzT2JqKSB7XG4gICAgICAgICAgaWYgKGNoaWxkTm9kZXNPYmouaGFzT3duUHJvcGVydHkoX25vZGVJZDIpKSB7XG4gICAgICAgICAgICB0aGlzLmNsdXN0ZXJlZE5vZGVzW19ub2RlSWQyXSA9IHsgY2x1c3RlcklkOiBjbHVzdGVyTm9kZVByb3BlcnRpZXMuaWQsIG5vZGU6IHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkMl0gfTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkMl0uc2V0T3B0aW9ucyh7IGhpZGRlbjogdHJ1ZSwgcGh5c2ljczogZmFsc2UgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IElEIHRvIHVuZGVmaW5lZCBzbyBubyBkdXBsaWNhdGVzIGFyaXNlXG4gICAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyB3cmFwIHVwXG4gICAgICAgIGlmIChyZWZyZXNoRGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19kYXRhQ2hhbmdlZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2JhY2t1cEVkZ2VPcHRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYmFja3VwRWRnZU9wdGlvbnMoZWRnZSkge1xuICAgICAgICBpZiAodGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXSA9IHsgcGh5c2ljczogZWRnZS5vcHRpb25zLnBoeXNpY3MsIGhpZGRlbjogZWRnZS5vcHRpb25zLmhpZGRlbiB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3Jlc3RvcmVFZGdlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzdG9yZUVkZ2UoZWRnZSkge1xuICAgICAgICB2YXIgb3JpZ2luYWxPcHRpb25zID0gdGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXTtcbiAgICAgICAgaWYgKG9yaWdpbmFsT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZWRnZS5zZXRPcHRpb25zKHsgcGh5c2ljczogb3JpZ2luYWxPcHRpb25zLnBoeXNpY3MsIGhpZGRlbjogb3JpZ2luYWxPcHRpb25zLmhpZGRlbiB9KTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICogQ2hlY2sgaWYgYSBub2RlIGlzIGEgY2x1c3Rlci5cbiAgICAgICogQHBhcmFtIG5vZGVJZFxuICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdpc0NsdXN0ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzQ2x1c3Rlcihub2RlSWQpIHtcbiAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0uaXNDbHVzdGVyID09PSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm9kZSBkb2VzIG5vdCBleGlzdC5cIik7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgKiBnZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBjbHVzdGVyIG5vZGUgYmFzZWQgb24gd2hhdCdzIGluc2lkZVxuICAgICAgKiBAcGFyYW0ge29iamVjdH0gY2hpbGROb2Rlc09iaiAgICB8IG9iamVjdCB3aXRoIG5vZGUgb2JqZWN0cywgaWQgYXMga2V5c1xuICAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cbiAgICAgICogQHByaXZhdGVcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0Q2x1c3RlclBvc2l0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q2x1c3RlclBvc2l0aW9uKGNoaWxkTm9kZXNPYmopIHtcbiAgICAgICAgdmFyIGNoaWxkS2V5cyA9IE9iamVjdC5rZXlzKGNoaWxkTm9kZXNPYmopO1xuICAgICAgICB2YXIgbWluWCA9IGNoaWxkTm9kZXNPYmpbY2hpbGRLZXlzWzBdXS54O1xuICAgICAgICB2YXIgbWF4WCA9IGNoaWxkTm9kZXNPYmpbY2hpbGRLZXlzWzBdXS54O1xuICAgICAgICB2YXIgbWluWSA9IGNoaWxkTm9kZXNPYmpbY2hpbGRLZXlzWzBdXS55O1xuICAgICAgICB2YXIgbWF4WSA9IGNoaWxkTm9kZXNPYmpbY2hpbGRLZXlzWzBdXS55O1xuICAgICAgICB2YXIgbm9kZSA9IHZvaWQgMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjaGlsZEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlID0gY2hpbGROb2Rlc09ialtjaGlsZEtleXNbaV1dO1xuICAgICAgICAgIG1pblggPSBub2RlLnggPCBtaW5YID8gbm9kZS54IDogbWluWDtcbiAgICAgICAgICBtYXhYID0gbm9kZS54ID4gbWF4WCA/IG5vZGUueCA6IG1heFg7XG4gICAgICAgICAgbWluWSA9IG5vZGUueSA8IG1pblkgPyBub2RlLnkgOiBtaW5ZO1xuICAgICAgICAgIG1heFkgPSBub2RlLnkgPiBtYXhZID8gbm9kZS55IDogbWF4WTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHg6IDAuNSAqIChtaW5YICsgbWF4WCksIHk6IDAuNSAqIChtaW5ZICsgbWF4WSkgfTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAqIE9wZW4gYSBjbHVzdGVyIGJ5IGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgICogQHBhcmFtIHtTdHJpbmd9ICBjbHVzdGVyTm9kZUlkIHwgdGhlIElEIG9mIHRoZSBjbHVzdGVyIG5vZGVcbiAgICAgICogQHBhcmFtIHtCb29sZWFufSByZWZyZXNoRGF0YSB8IHdyYXAgdXAgYWZ0ZXJ3YXJkcyBpZiBub3QgdHJ1ZVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ29wZW5DbHVzdGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuQ2x1c3RlcihjbHVzdGVyTm9kZUlkLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcblxuICAgICAgICAvLyBraWxsIGNvbmRpdGlvbnNcbiAgICAgICAgaWYgKGNsdXN0ZXJOb2RlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNsdXN0ZXJOb2RlSWQgc3VwcGxpZWQgdG8gb3BlbkNsdXN0ZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbY2x1c3Rlck5vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjbHVzdGVyTm9kZUlkIHN1cHBsaWVkIHRvIG9wZW5DbHVzdGVyIGRvZXMgbm90IGV4aXN0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJOb2RlSWRdLmNvbnRhaW5lZE5vZGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlRoZSBub2RlOlwiICsgY2x1c3Rlck5vZGVJZCArIFwiIGlzIG5vdCBhIGNsdXN0ZXIuXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2x1c3Rlck5vZGUgPSB0aGlzLmJvZHkubm9kZXNbY2x1c3Rlck5vZGVJZF07XG4gICAgICAgIHZhciBjb250YWluZWROb2RlcyA9IGNsdXN0ZXJOb2RlLmNvbnRhaW5lZE5vZGVzO1xuICAgICAgICB2YXIgY29udGFpbmVkRWRnZXMgPSBjbHVzdGVyTm9kZS5jb250YWluZWRFZGdlcztcblxuICAgICAgICAvLyBhbGxvdyB0aGUgdXNlciB0byBwb3NpdGlvbiB0aGUgbm9kZXMgYWZ0ZXIgcmVsZWFzZS5cbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlbGVhc2VGdW5jdGlvbiAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zLnJlbGVhc2VGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgY2x1c3RlclBvc2l0aW9uID0geyB4OiBjbHVzdGVyTm9kZS54LCB5OiBjbHVzdGVyTm9kZS55IH07XG4gICAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIGNvbnRhaW5lZE5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVkTm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgICB2YXIgY29udGFpbmVkTm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgICBwb3NpdGlvbnNbbm9kZUlkXSA9IHsgeDogY29udGFpbmVkTm9kZS54LCB5OiBjb250YWluZWROb2RlLnkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5ld1Bvc2l0aW9ucyA9IG9wdGlvbnMucmVsZWFzZUZ1bmN0aW9uKGNsdXN0ZXJQb3NpdGlvbiwgcG9zaXRpb25zKTtcblxuICAgICAgICAgIGZvciAodmFyIF9ub2RlSWQzIGluIGNvbnRhaW5lZE5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVkTm9kZXMuaGFzT3duUHJvcGVydHkoX25vZGVJZDMpKSB7XG4gICAgICAgICAgICAgIHZhciBfY29udGFpbmVkTm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkM107XG4gICAgICAgICAgICAgIGlmIChuZXdQb3NpdGlvbnNbX25vZGVJZDNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBfY29udGFpbmVkTm9kZS54ID0gbmV3UG9zaXRpb25zW19ub2RlSWQzXS54ID09PSB1bmRlZmluZWQgPyBjbHVzdGVyTm9kZS54IDogbmV3UG9zaXRpb25zW19ub2RlSWQzXS54O1xuICAgICAgICAgICAgICAgIF9jb250YWluZWROb2RlLnkgPSBuZXdQb3NpdGlvbnNbX25vZGVJZDNdLnkgPT09IHVuZGVmaW5lZCA/IGNsdXN0ZXJOb2RlLnkgOiBuZXdQb3NpdGlvbnNbX25vZGVJZDNdLnk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29weSB0aGUgcG9zaXRpb24gZnJvbSB0aGUgY2x1c3RlclxuICAgICAgICAgIGZvciAodmFyIF9ub2RlSWQ0IGluIGNvbnRhaW5lZE5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVkTm9kZXMuaGFzT3duUHJvcGVydHkoX25vZGVJZDQpKSB7XG4gICAgICAgICAgICAgIHZhciBfY29udGFpbmVkTm9kZTIgPSB0aGlzLmJvZHkubm9kZXNbX25vZGVJZDRdO1xuICAgICAgICAgICAgICBfY29udGFpbmVkTm9kZTIgPSBjb250YWluZWROb2Rlc1tfbm9kZUlkNF07XG4gICAgICAgICAgICAgIC8vIGluaGVyaXQgcG9zaXRpb25cbiAgICAgICAgICAgICAgaWYgKF9jb250YWluZWROb2RlMi5vcHRpb25zLmZpeGVkLnggPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRhaW5lZE5vZGUyLnggPSBjbHVzdGVyTm9kZS54O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChfY29udGFpbmVkTm9kZTIub3B0aW9ucy5maXhlZC55ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIF9jb250YWluZWROb2RlMi55ID0gY2x1c3Rlck5vZGUueTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbGVhc2Ugbm9kZXNcbiAgICAgICAgZm9yICh2YXIgX25vZGVJZDUgaW4gY29udGFpbmVkTm9kZXMpIHtcbiAgICAgICAgICBpZiAoY29udGFpbmVkTm9kZXMuaGFzT3duUHJvcGVydHkoX25vZGVJZDUpKSB7XG4gICAgICAgICAgICB2YXIgX2NvbnRhaW5lZE5vZGUzID0gdGhpcy5ib2R5Lm5vZGVzW19ub2RlSWQ1XTtcblxuICAgICAgICAgICAgLy8gaW5oZXJpdCBzcGVlZFxuICAgICAgICAgICAgX2NvbnRhaW5lZE5vZGUzLnZ4ID0gY2x1c3Rlck5vZGUudng7XG4gICAgICAgICAgICBfY29udGFpbmVkTm9kZTMudnkgPSBjbHVzdGVyTm9kZS52eTtcblxuICAgICAgICAgICAgLy8gd2UgdXNlIHRoZXNlIG1ldGhvZHMgdG8gYXZvaWQgcmUtaW5zdGFudGlhdGluZyB0aGUgc2hhcGUsIHdoaWNoIGhhcHBlbnMgd2l0aCBzZXRPcHRpb25zLlxuICAgICAgICAgICAgX2NvbnRhaW5lZE5vZGUzLnNldE9wdGlvbnMoeyBoaWRkZW46IGZhbHNlLCBwaHlzaWNzOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jbHVzdGVyZWROb2Rlc1tfbm9kZUlkNV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29weSB0aGUgY2x1c3Rlck5vZGUgZWRnZXMgYmVjYXVzZSB3ZSBjYW5ub3QgaXRlcmF0ZSBvdmVyIGFuIG9iamVjdCB0aGF0IHdlIGFkZCBvciByZW1vdmUgZnJvbS5cbiAgICAgICAgdmFyIGVkZ2VzVG9CZURlbGV0ZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHVzdGVyTm9kZS5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGVkZ2VzVG9CZURlbGV0ZWQucHVzaChjbHVzdGVyTm9kZS5lZGdlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhY3R1YWxseSBoYW5kbGluZyB0aGUgZGVsZXRpbmcuXG4gICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGVkZ2VzVG9CZURlbGV0ZWQubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNUb0JlRGVsZXRlZFtfaTRdO1xuXG4gICAgICAgICAgdmFyIG90aGVyTm9kZUlkID0gdGhpcy5fZ2V0Q29ubmVjdGVkSWQoZWRnZSwgY2x1c3Rlck5vZGVJZCk7XG4gICAgICAgICAgLy8gaWYgdGhlIG90aGVyIG5vZGUgaXMgaW4gYW5vdGhlciBjbHVzdGVyLCB3ZSB0cmFuc2ZlciBvd25lcnNoaXAgb2YgdGhpcyBlZGdlIHRvIHRoZSBvdGhlciBjbHVzdGVyXG4gICAgICAgICAgaWYgKHRoaXMuY2x1c3RlcmVkTm9kZXNbb3RoZXJOb2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHRyYW5zZmVyIG93bmVyc2hpcDpcbiAgICAgICAgICAgIHZhciBvdGhlckNsdXN0ZXIgPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5jbHVzdGVyZWROb2Rlc1tvdGhlck5vZGVJZF0uY2x1c3RlcklkXTtcbiAgICAgICAgICAgIHZhciB0cmFuc2ZlckVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbZWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkXTtcbiAgICAgICAgICAgIGlmICh0cmFuc2ZlckVkZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBvdGhlckNsdXN0ZXIuY29udGFpbmVkRWRnZXNbdHJhbnNmZXJFZGdlLmlkXSA9IHRyYW5zZmVyRWRnZTtcblxuICAgICAgICAgICAgICAvLyBkZWxldGUgbG9jYWwgcmVmZXJlbmNlXG4gICAgICAgICAgICAgIGRlbGV0ZSBjb250YWluZWRFZGdlc1t0cmFuc2ZlckVkZ2UuaWRdO1xuXG4gICAgICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgY2x1c3RlciBlZGdlIGZyb20gdGhlIG90aGVyQ2x1c3RlcjpcbiAgICAgICAgICAgICAgLy8gZ2V0IHRvIGFuZCBmcm9tXG4gICAgICAgICAgICAgIHZhciBmcm9tSWQgPSB0cmFuc2ZlckVkZ2UuZnJvbUlkO1xuICAgICAgICAgICAgICB2YXIgdG9JZCA9IHRyYW5zZmVyRWRnZS50b0lkO1xuICAgICAgICAgICAgICBpZiAodHJhbnNmZXJFZGdlLnRvSWQgPT0gb3RoZXJOb2RlSWQpIHtcbiAgICAgICAgICAgICAgICB0b0lkID0gdGhpcy5jbHVzdGVyZWROb2Rlc1tvdGhlck5vZGVJZF0uY2x1c3RlcklkO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZyb21JZCA9IHRoaXMuY2x1c3RlcmVkTm9kZXNbb3RoZXJOb2RlSWRdLmNsdXN0ZXJJZDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGNsb25lIHRoZSBvcHRpb25zIGFuZCBhcHBseSB0aGUgY2x1c3RlciBvcHRpb25zIHRvIHRoZW1cbiAgICAgICAgICAgICAgdmFyIGNsb25lZE9wdGlvbnMgPSBfTmV0d29ya1V0aWwyLmRlZmF1bHQuY2xvbmVPcHRpb25zKHRyYW5zZmVyRWRnZSwgJ2VkZ2UnKTtcbiAgICAgICAgICAgICAgdXRpbC5kZWVwRXh0ZW5kKGNsb25lZE9wdGlvbnMsIG90aGVyQ2x1c3Rlci5jbHVzdGVyRWRnZVByb3BlcnRpZXMpO1xuXG4gICAgICAgICAgICAgIC8vIGFwcGx5IHRoZSBlZGdlIHNwZWNpZmljIG9wdGlvbnMgdG8gaXQuXG4gICAgICAgICAgICAgIHZhciBpZCA9ICdjbHVzdGVyRWRnZTonICsgdXRpbC5yYW5kb21VVUlEKCk7XG4gICAgICAgICAgICAgIHV0aWwuZGVlcEV4dGVuZChjbG9uZWRPcHRpb25zLCB7IGZyb206IGZyb21JZCwgdG86IHRvSWQsIGhpZGRlbjogZmFsc2UsIHBoeXNpY3M6IHRydWUsIGlkOiBpZCB9KTtcblxuICAgICAgICAgICAgICAvLyBjcmVhdGUgaXRcbiAgICAgICAgICAgICAgdmFyIG5ld0VkZ2UgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZUVkZ2UoY2xvbmVkT3B0aW9ucyk7XG4gICAgICAgICAgICAgIG5ld0VkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZCA9IHRyYW5zZmVyRWRnZS5pZDtcbiAgICAgICAgICAgICAgdGhpcy5ib2R5LmVkZ2VzW2lkXSA9IG5ld0VkZ2U7XG4gICAgICAgICAgICAgIHRoaXMuYm9keS5lZGdlc1tpZF0uY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVwbGFjZWRFZGdlID0gdGhpcy5ib2R5LmVkZ2VzW2VkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZF07XG4gICAgICAgICAgICBpZiAocmVwbGFjZWRFZGdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVzdG9yZUVkZ2UocmVwbGFjZWRFZGdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWRnZS5jbGVhbnVwKCk7XG4gICAgICAgICAgLy8gdGhpcyByZW1vdmVzIHRoZSBlZGdlIGZyb20gbm9kZS5lZGdlcywgd2hpY2ggaXMgd2h5IGVkZ2VJZHMgaXMgZm9ybWVkXG4gICAgICAgICAgZWRnZS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuYm9keS5lZGdlc1tlZGdlLmlkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSB0aGUgcmVsZWFzaW5nIG9mIHRoZSBlZGdlc1xuICAgICAgICBmb3IgKHZhciBlZGdlSWQgaW4gY29udGFpbmVkRWRnZXMpIHtcbiAgICAgICAgICBpZiAoY29udGFpbmVkRWRnZXMuaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzdG9yZUVkZ2UoY29udGFpbmVkRWRnZXNbZWRnZUlkXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGNsdXN0ZXJOb2RlXG4gICAgICAgIGRlbGV0ZSB0aGlzLmJvZHkubm9kZXNbY2x1c3Rlck5vZGVJZF07XG5cbiAgICAgICAgaWYgKHJlZnJlc2hEYXRhID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXROb2Rlc0luQ2x1c3RlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Tm9kZXNJbkNsdXN0ZXIoY2x1c3RlcklkKSB7XG4gICAgICAgIHZhciBub2Rlc0FycmF5ID0gW107XG4gICAgICAgIGlmICh0aGlzLmlzQ2x1c3RlcihjbHVzdGVySWQpID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lZE5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJJZF0uY29udGFpbmVkTm9kZXM7XG4gICAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIGNvbnRhaW5lZE5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVkTm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgICBub2Rlc0FycmF5LnB1c2godGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2Rlc0FycmF5O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICogR2V0IHRoZSBzdGFjayBjbHVzdGVySWQncyB0aGF0IGEgY2VydGFpbiBub2RlIHJlc2lkZXMgaW4uIGNsdXN0ZXIgQSAtPiBjbHVzdGVyIEIgLT4gY2x1c3RlciBDIC0+IG5vZGVcbiAgICAgICogQHBhcmFtIG5vZGVJZFxuICAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZmluZE5vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmROb2RlKG5vZGVJZCkge1xuICAgICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgICAgdmFyIG1heCA9IDEwMDtcbiAgICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuXG4gICAgICAgIHdoaWxlICh0aGlzLmNsdXN0ZXJlZE5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCAmJiBjb3VudGVyIDwgbWF4KSB7XG4gICAgICAgICAgc3RhY2sucHVzaCh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS5pZCk7XG4gICAgICAgICAgbm9kZUlkID0gdGhpcy5jbHVzdGVyZWROb2Rlc1tub2RlSWRdLmNsdXN0ZXJJZDtcbiAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucHVzaCh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS5pZCk7XG4gICAgICAgIHN0YWNrLnJldmVyc2UoKTtcblxuICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgKiBVc2luZyBhIGNsdXN0ZXJlZCBub2RlSWQsIHVwZGF0ZSB3aXRoIHRoZSBuZXcgb3B0aW9uc1xuICAgICAgKiBAcGFyYW0gY2x1c3RlcmVkTm9kZUlkXG4gICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdPcHRpb25zXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndXBkYXRlQ2x1c3RlcmVkTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQ2x1c3RlcmVkTm9kZShjbHVzdGVyZWROb2RlSWQsIG5ld09wdGlvbnMpIHtcbiAgICAgICAgaWYgKGNsdXN0ZXJlZE5vZGVJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2x1c3RlcmVkTm9kZUlkIHN1cHBsaWVkIHRvIHVwZGF0ZUNsdXN0ZXJlZE5vZGUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdPcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBuZXdPcHRpb25zIHN1cHBsaWVkIHRvIHVwZGF0ZUNsdXN0ZXJlZE5vZGUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbY2x1c3RlcmVkTm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNsdXN0ZXJlZE5vZGVJZCBzdXBwbGllZCB0byB1cGRhdGVDbHVzdGVyZWROb2RlIGRvZXMgbm90IGV4aXN0LlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm9keS5ub2Rlc1tjbHVzdGVyZWROb2RlSWRdLnNldE9wdGlvbnMobmV3T3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19kYXRhQ2hhbmdlZCcpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICogVXNpbmcgYSBiYXNlIGVkZ2VJZCwgdXBkYXRlIGFsbCByZWxhdGVkIGNsdXN0ZXJlZCBlZGdlcyB3aXRoIHRoZSBuZXcgb3B0aW9uc1xuICAgICAgKiBAcGFyYW0gc3RhcnRFZGdlSWRcbiAgICAgICogQHBhcmFtIHtvYmplY3R9IG5ld09wdGlvbnNcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVFZGdlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVFZGdlKHN0YXJ0RWRnZUlkLCBuZXdPcHRpb25zKSB7XG4gICAgICAgIGlmIChzdGFydEVkZ2VJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3RhcnRFZGdlSWQgc3VwcGxpZWQgdG8gdXBkYXRlRWRnZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld09wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG5ld09wdGlvbnMgc3VwcGxpZWQgdG8gdXBkYXRlRWRnZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYm9keS5lZGdlc1tzdGFydEVkZ2VJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdGFydEVkZ2VJZCBzdXBwbGllZCB0byB1cGRhdGVFZGdlIGRvZXMgbm90IGV4aXN0LlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbGxFZGdlSWRzID0gdGhpcy5nZXRDbHVzdGVyZWRFZGdlcyhzdGFydEVkZ2VJZCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsRWRnZUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlZGdlID0gdGhpcy5ib2R5LmVkZ2VzW2FsbEVkZ2VJZHNbaV1dO1xuICAgICAgICAgIGVkZ2Uuc2V0T3B0aW9ucyhuZXdPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfZGF0YUNoYW5nZWQnKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAqIEdldCBhIHN0YWNrIG9mIGNsdXN0ZXJFZGdlSWQncyAoK2Jhc2UgZWRnZWlkKSB0aGF0IGEgYmFzZSBlZGdlIGlzIHRoZSBzYW1lIGFzLiBjbHVzdGVyIGVkZ2UgQyAtPiBjbHVzdGVyIGVkZ2UgQiAtPiBjbHVzdGVyIGVkZ2UgQSAtPiBiYXNlIGVkZ2UoZWRnZUlkKVxuICAgICAgKiBAcGFyYW0gZWRnZUlkXG4gICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRDbHVzdGVyZWRFZGdlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2x1c3RlcmVkRWRnZXMoZWRnZUlkKSB7XG4gICAgICAgIHZhciBzdGFjayA9IFtdO1xuICAgICAgICB2YXIgbWF4ID0gMTAwO1xuICAgICAgICB2YXIgY291bnRlciA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGVkZ2VJZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdICE9PSB1bmRlZmluZWQgJiYgY291bnRlciA8IG1heCkge1xuICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF0uaWQpO1xuICAgICAgICAgIGVkZ2VJZCA9IHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdLmVkZ2VSZXBsYWNlZEJ5SWQ7XG4gICAgICAgICAgY291bnRlcisrO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICogR2V0IHRoZSBiYXNlIGVkZ2UgaWQgb2YgY2x1c3RlckVkZ2VJZC4gY2x1c3RlciBlZGdlIChjbHVzdGVyZWRFZGdlSWQpIC0+IGNsdXN0ZXIgZWRnZSBCIC0+IGNsdXN0ZXIgZWRnZSBDIC0+IGJhc2UgZWRnZVxuICAgICAgKiBAcGFyYW0gY2x1c3RlcmVkRWRnZUlkXG4gICAgICAqIEByZXR1cm5zIGJhc2VFZGdlSWRcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRCYXNlRWRnZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmFzZUVkZ2UoY2x1c3RlcmVkRWRnZUlkKSB7XG4gICAgICAgIHZhciBiYXNlRWRnZUlkID0gY2x1c3RlcmVkRWRnZUlkO1xuICAgICAgICB2YXIgbWF4ID0gMTAwO1xuICAgICAgICB2YXIgY291bnRlciA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGNsdXN0ZXJlZEVkZ2VJZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuYm9keS5lZGdlc1tjbHVzdGVyZWRFZGdlSWRdICE9PSB1bmRlZmluZWQgJiYgY291bnRlciA8IG1heCkge1xuICAgICAgICAgIGNsdXN0ZXJlZEVkZ2VJZCA9IHRoaXMuYm9keS5lZGdlc1tjbHVzdGVyZWRFZGdlSWRdLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWQ7XG4gICAgICAgICAgY291bnRlcisrO1xuICAgICAgICAgIGlmIChjbHVzdGVyZWRFZGdlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYmFzZUVkZ2VJZCA9IGNsdXN0ZXJlZEVkZ2VJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VFZGdlSWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgKiBHZXQgdGhlIElkIHRoZSBub2RlIGlzIGNvbm5lY3RlZCB0b1xuICAgICAgKiBAcGFyYW0gZWRnZVxuICAgICAgKiBAcGFyYW0gbm9kZUlkXG4gICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgKiBAcHJpdmF0ZVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXRDb25uZWN0ZWRJZCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENvbm5lY3RlZElkKGVkZ2UsIG5vZGVJZCkge1xuICAgICAgICBpZiAoZWRnZS50b0lkICE9IG5vZGVJZCkge1xuICAgICAgICAgIHJldHVybiBlZGdlLnRvSWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZWRnZS5mcm9tSWQgIT0gbm9kZUlkKSB7XG4gICAgICAgICAgcmV0dXJuIGVkZ2UuZnJvbUlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBlZGdlLmZyb21JZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICogV2UgZGV0ZXJtaW5lIGhvdyBtYW55IGNvbm5lY3Rpb25zIGRlbm90ZSBhbiBpbXBvcnRhbnQgaHViLlxuICAgICAgKiBXZSB0YWtlIHRoZSBtZWFuICsgMipzdGQgYXMgdGhlIGltcG9ydGFudCBodWIgc2l6ZS4gKEFzc3VtaW5nIGEgbm9ybWFsIGRpc3RyaWJ1dGlvbiBvZiBkYXRhLCB+Mi4yJSlcbiAgICAgICpcbiAgICAgICogQHByaXZhdGVcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0SHViU2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEh1YlNpemUoKSB7XG4gICAgICAgIHZhciBhdmVyYWdlID0gMDtcbiAgICAgICAgdmFyIGF2ZXJhZ2VTcXVhcmVkID0gMDtcbiAgICAgICAgdmFyIGh1YkNvdW50ZXIgPSAwO1xuICAgICAgICB2YXIgbGFyZ2VzdEh1YiA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbaV1dO1xuICAgICAgICAgIGlmIChub2RlLmVkZ2VzLmxlbmd0aCA+IGxhcmdlc3RIdWIpIHtcbiAgICAgICAgICAgIGxhcmdlc3RIdWIgPSBub2RlLmVkZ2VzLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXZlcmFnZSArPSBub2RlLmVkZ2VzLmxlbmd0aDtcbiAgICAgICAgICBhdmVyYWdlU3F1YXJlZCArPSBNYXRoLnBvdyhub2RlLmVkZ2VzLmxlbmd0aCwgMik7XG4gICAgICAgICAgaHViQ291bnRlciArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGF2ZXJhZ2UgPSBhdmVyYWdlIC8gaHViQ291bnRlcjtcbiAgICAgICAgYXZlcmFnZVNxdWFyZWQgPSBhdmVyYWdlU3F1YXJlZCAvIGh1YkNvdW50ZXI7XG5cbiAgICAgICAgdmFyIHZhcmlhbmNlID0gYXZlcmFnZVNxdWFyZWQgLSBNYXRoLnBvdyhhdmVyYWdlLCAyKTtcbiAgICAgICAgdmFyIHN0YW5kYXJkRGV2aWF0aW9uID0gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcblxuICAgICAgICB2YXIgaHViVGhyZXNob2xkID0gTWF0aC5mbG9vcihhdmVyYWdlICsgMiAqIHN0YW5kYXJkRGV2aWF0aW9uKTtcblxuICAgICAgICAvLyBhbHdheXMgaGF2ZSBhdCBsZWFzdCBvbmUgdG8gY2x1c3RlclxuICAgICAgICBpZiAoaHViVGhyZXNob2xkID4gbGFyZ2VzdEh1Yikge1xuICAgICAgICAgIGh1YlRocmVzaG9sZCA9IGxhcmdlc3RIdWI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaHViVGhyZXNob2xkO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDbHVzdGVyRW5naW5lO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gQ2x1c3RlckVuZ2luZTtcblxuLyoqKi8gfSxcbi8qIDEwNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICB2YXIgTmV0d29ya1V0aWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmV0d29ya1V0aWwoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTmV0d29ya1V0aWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGNlbnRlciBwb3NpdGlvbiBvZiB0aGUgbmV0d29yayBjb25zaWRlcmluZyB0aGUgYm91bmRpbmcgYm94ZXNcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKE5ldHdvcmtVdGlsLCBudWxsLCBbe1xuICAgICAga2V5OiBcImdldFJhbmdlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmFuZ2UoYWxsTm9kZXMpIHtcbiAgICAgICAgdmFyIHNwZWNpZmljTm9kZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuXG4gICAgICAgIHZhciBtaW5ZID0gMWU5LFxuICAgICAgICAgICAgbWF4WSA9IC0xZTksXG4gICAgICAgICAgICBtaW5YID0gMWU5LFxuICAgICAgICAgICAgbWF4WCA9IC0xZTksXG4gICAgICAgICAgICBub2RlO1xuICAgICAgICBpZiAoc3BlY2lmaWNOb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGVjaWZpY05vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBub2RlID0gYWxsTm9kZXNbc3BlY2lmaWNOb2Rlc1tpXV07XG4gICAgICAgICAgICBpZiAobWluWCA+IG5vZGUuc2hhcGUuYm91bmRpbmdCb3gubGVmdCkge1xuICAgICAgICAgICAgICBtaW5YID0gbm9kZS5zaGFwZS5ib3VuZGluZ0JveC5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1heFggPCBub2RlLnNoYXBlLmJvdW5kaW5nQm94LnJpZ2h0KSB7XG4gICAgICAgICAgICAgIG1heFggPSBub2RlLnNoYXBlLmJvdW5kaW5nQm94LnJpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1pblkgPiBub2RlLnNoYXBlLmJvdW5kaW5nQm94LnRvcCkge1xuICAgICAgICAgICAgICBtaW5ZID0gbm9kZS5zaGFwZS5ib3VuZGluZ0JveC50b3A7XG4gICAgICAgICAgICB9IC8vIHRvcCBpcyBuZWdhdGl2ZSwgYm90dG9tIGlzIHBvc2l0aXZlXG4gICAgICAgICAgICBpZiAobWF4WSA8IG5vZGUuc2hhcGUuYm91bmRpbmdCb3guYm90dG9tKSB7XG4gICAgICAgICAgICAgIG1heFkgPSBub2RlLnNoYXBlLmJvdW5kaW5nQm94LmJvdHRvbTtcbiAgICAgICAgICAgIH0gLy8gdG9wIGlzIG5lZ2F0aXZlLCBib3R0b20gaXMgcG9zaXRpdmVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWluWCA9PT0gMWU5ICYmIG1heFggPT09IC0xZTkgJiYgbWluWSA9PT0gMWU5ICYmIG1heFkgPT09IC0xZTkpIHtcbiAgICAgICAgICBtaW5ZID0gMCwgbWF4WSA9IDAsIG1pblggPSAwLCBtYXhYID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtaW5YOiBtaW5YLCBtYXhYOiBtYXhYLCBtaW5ZOiBtaW5ZLCBtYXhZOiBtYXhZIH07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRmluZCB0aGUgY2VudGVyIHBvc2l0aW9uIG9mIHRoZSBuZXR3b3JrXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRSYW5nZUNvcmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSYW5nZUNvcmUoYWxsTm9kZXMpIHtcbiAgICAgICAgdmFyIHNwZWNpZmljTm9kZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuXG4gICAgICAgIHZhciBtaW5ZID0gMWU5LFxuICAgICAgICAgICAgbWF4WSA9IC0xZTksXG4gICAgICAgICAgICBtaW5YID0gMWU5LFxuICAgICAgICAgICAgbWF4WCA9IC0xZTksXG4gICAgICAgICAgICBub2RlO1xuICAgICAgICBpZiAoc3BlY2lmaWNOb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGVjaWZpY05vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBub2RlID0gYWxsTm9kZXNbc3BlY2lmaWNOb2Rlc1tpXV07XG4gICAgICAgICAgICBpZiAobWluWCA+IG5vZGUueCkge1xuICAgICAgICAgICAgICBtaW5YID0gbm9kZS54O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1heFggPCBub2RlLngpIHtcbiAgICAgICAgICAgICAgbWF4WCA9IG5vZGUueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtaW5ZID4gbm9kZS55KSB7XG4gICAgICAgICAgICAgIG1pblkgPSBub2RlLnk7XG4gICAgICAgICAgICB9IC8vIHRvcCBpcyBuZWdhdGl2ZSwgYm90dG9tIGlzIHBvc2l0aXZlXG4gICAgICAgICAgICBpZiAobWF4WSA8IG5vZGUueSkge1xuICAgICAgICAgICAgICBtYXhZID0gbm9kZS55O1xuICAgICAgICAgICAgfSAvLyB0b3AgaXMgbmVnYXRpdmUsIGJvdHRvbSBpcyBwb3NpdGl2ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaW5YID09PSAxZTkgJiYgbWF4WCA9PT0gLTFlOSAmJiBtaW5ZID09PSAxZTkgJiYgbWF4WSA9PT0gLTFlOSkge1xuICAgICAgICAgIG1pblkgPSAwLCBtYXhZID0gMCwgbWluWCA9IDAsIG1heFggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1pblg6IG1pblgsIG1heFg6IG1heFgsIG1pblk6IG1pblksIG1heFk6IG1heFkgfTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gcmFuZ2UgPSB7bWluWDogbWluWCwgbWF4WDogbWF4WCwgbWluWTogbWluWSwgbWF4WTogbWF4WX07XG4gICAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImZpbmRDZW50ZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQ2VudGVyKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IHg6IDAuNSAqIChyYW5nZS5tYXhYICsgcmFuZ2UubWluWCksXG4gICAgICAgICAgeTogMC41ICogKHJhbmdlLm1heFkgKyByYW5nZS5taW5ZKSB9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgcmV0dXJucyBhIGNsb25lIG9mIHRoZSBvcHRpb25zIG9yIG9wdGlvbnMgb2YgdGhlIGVkZ2Ugb3Igbm9kZSB0byBiZSB1c2VkIGZvciBjb25zdHJ1Y3Rpb24gb2YgbmV3IGVkZ2VzIG9yIGNoZWNrIGZ1bmN0aW9ucyBmb3IgbmV3IG5vZGVzLlxuICAgICAgICogQHBhcmFtIGl0ZW1cbiAgICAgICAqIEBwYXJhbSB0eXBlXG4gICAgICAgKiBAcmV0dXJucyB7e319XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbG9uZU9wdGlvbnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZU9wdGlvbnMoaXRlbSwgdHlwZSkge1xuICAgICAgICB2YXIgY2xvbmVkT3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09ICdub2RlJykge1xuICAgICAgICAgIHV0aWwuZGVlcEV4dGVuZChjbG9uZWRPcHRpb25zLCBpdGVtLm9wdGlvbnMsIHRydWUpO1xuICAgICAgICAgIGNsb25lZE9wdGlvbnMueCA9IGl0ZW0ueDtcbiAgICAgICAgICBjbG9uZWRPcHRpb25zLnkgPSBpdGVtLnk7XG4gICAgICAgICAgY2xvbmVkT3B0aW9ucy5hbW91bnRPZkNvbm5lY3Rpb25zID0gaXRlbS5lZGdlcy5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXRpbC5kZWVwRXh0ZW5kKGNsb25lZE9wdGlvbnMsIGl0ZW0ub3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lZE9wdGlvbnM7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIE5ldHdvcmtVdGlsO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gTmV0d29ya1V0aWw7XG5cbi8qKiovIH0sXG4vKiAxMDYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX05vZGUyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nyk7XG5cbiAgdmFyIF9Ob2RlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05vZGUyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgLyoqXG4gICAqXG4gICAqL1xuICB2YXIgQ2x1c3RlciA9IGZ1bmN0aW9uIChfTm9kZSkge1xuICAgIF9pbmhlcml0cyhDbHVzdGVyLCBfTm9kZSk7XG5cbiAgICBmdW5jdGlvbiBDbHVzdGVyKG9wdGlvbnMsIGJvZHksIGltYWdlbGlzdCwgZ3JvdXBsaXN0LCBnbG9iYWxPcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2x1c3Rlcik7XG5cbiAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDbHVzdGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2x1c3RlcikpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgaW1hZ2VsaXN0LCBncm91cGxpc3QsIGdsb2JhbE9wdGlvbnMpKTtcblxuICAgICAgX3RoaXMuaXNDbHVzdGVyID0gdHJ1ZTtcbiAgICAgIF90aGlzLmNvbnRhaW5lZE5vZGVzID0ge307XG4gICAgICBfdGhpcy5jb250YWluZWRFZGdlcyA9IHt9O1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBDbHVzdGVyO1xuICB9KF9Ob2RlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBDbHVzdGVyO1xuXG4vKioqLyB9LFxuLyogMTA3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gIH1cblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIENhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKGJvZHksIGNhbnZhcykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhbnZhc1JlbmRlcmVyKTtcblxuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuXG4gICAgICB0aGlzLnJlZHJhd1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5yZW5kZXJUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMucmVxdWlyZXNUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVuZGVyaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLnJlbmRlclJlcXVlc3RzID0gMDtcbiAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuYWxsb3dSZWRyYXcgPSB0cnVlO1xuXG4gICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIGhpZGVFZGdlc09uRHJhZzogZmFsc2UsXG4gICAgICAgIGhpZGVOb2Rlc09uRHJhZzogZmFsc2VcbiAgICAgIH07XG4gICAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgICB0aGlzLl9kZXRlcm1pbmVCcm93c2VyTWV0aG9kKCk7XG4gICAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDYW52YXNSZW5kZXJlciwgW3tcbiAgICAgIGtleTogJ2JpbmRFdmVudExpc3RlbmVycycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZHJhZ1N0YXJ0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRyYWdFbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfcmVzaXplTm9kZXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVzaXplTm9kZXMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3JlZHJhd1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzLnJlbmRlcmluZ0FjdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIF90aGlzLl9yZWRyYXcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9ibG9ja1JlZHJhd1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuYWxsb3dSZWRyYXcgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2FsbG93UmVkcmF3XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5hbGxvd1JlZHJhdyA9IHRydWU7X3RoaXMucmVkcmF3UmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9yZXF1ZXN0UmVkcmF3XCIsIHRoaXMuX3JlcXVlc3RSZWRyYXcuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3N0YXJ0UmVuZGVyaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5yZW5kZXJSZXF1ZXN0cyArPSAxO1xuICAgICAgICAgIF90aGlzLnJlbmRlcmluZ0FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgX3RoaXMuX3N0YXJ0UmVuZGVyaW5nKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9zdG9wUmVuZGVyaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5yZW5kZXJSZXF1ZXN0cyAtPSAxO1xuICAgICAgICAgIF90aGlzLnJlbmRlcmluZ0FjdGl2ZSA9IF90aGlzLnJlbmRlclJlcXVlc3RzID4gMDtcbiAgICAgICAgICBfdGhpcy5yZW5kZXJUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnJlbmRlclJlcXVlc3RzID0gMDtcbiAgICAgICAgICBfdGhpcy5hbGxvd1JlZHJhdyA9IGZhbHNlO1xuICAgICAgICAgIF90aGlzLnJlbmRlcmluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgIGlmIChfdGhpcy5yZXF1aXJlc1RpbWVvdXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5yZW5kZXJUaW1lcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKF90aGlzLnJlbmRlclRpbWVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMuYm9keS5lbWl0dGVyLm9mZigpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBmaWVsZHMgPSBbJ2hpZGVFZGdlc09uRHJhZycsICdoaWRlTm9kZXNPbkRyYWcnXTtcbiAgICAgICAgICB1dGlsLnNlbGVjdGl2ZURlZXBFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3N0YXJ0UmVuZGVyaW5nJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RhcnRSZW5kZXJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmluZ0FjdGl2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmICh0aGlzLnJlbmRlclRpbWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlcXVpcmVzVGltZW91dCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB0aGlzLnJlbmRlclRpbWVyID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5fcmVuZGVyU3RlcC5iaW5kKHRoaXMpLCB0aGlzLnNpbXVsYXRpb25JbnRlcnZhbCk7IC8vIHdhaXQgdGhpcy5yZW5kZXJUaW1lU3RlcCBtaWxsaXNlY29uZHMgYW5kIHBlcmZvcm0gdGhlIGFuaW1hdGlvbiBzdGVwIGZ1bmN0aW9uXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnJlbmRlclRpbWVyID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9yZW5kZXJTdGVwLmJpbmQodGhpcykpOyAvLyB3YWl0IHRoaXMucmVuZGVyVGltZVN0ZXAgbWlsbGlzZWNvbmRzIGFuZCBwZXJmb3JtIHRoZSBhbmltYXRpb24gc3RlcCBmdW5jdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19yZW5kZXJTdGVwJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyU3RlcCgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyaW5nQWN0aXZlID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gcmVzZXQgdGhlIHJlbmRlclRpbWVyIHNvIGEgbmV3IHNjaGVkdWxlZCBhbmltYXRpb24gc3RlcCBjYW4gYmUgc2V0XG4gICAgICAgICAgdGhpcy5yZW5kZXJUaW1lciA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmICh0aGlzLnJlcXVpcmVzVGltZW91dCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBzY2hlZHVsZXMgYSBuZXcgc2ltdWxhdGlvbiBzdGVwXG4gICAgICAgICAgICB0aGlzLl9zdGFydFJlbmRlcmluZygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3JlZHJhdygpO1xuXG4gICAgICAgICAgaWYgKHRoaXMucmVxdWlyZXNUaW1lb3V0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBzY2hlZHVsZXMgYSBuZXcgc2ltdWxhdGlvbiBzdGVwXG4gICAgICAgICAgICB0aGlzLl9zdGFydFJlbmRlcmluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZHJhdyB0aGUgbmV0d29yayB3aXRoIHRoZSBjdXJyZW50IGRhdGFcbiAgICAgICAqIGNoYXJ0IHdpbGwgYmUgcmVzaXplZCB0b28uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVkcmF3KCkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzZXRTaXplJyk7XG4gICAgICAgIHRoaXMuX3JlZHJhdygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZHJhdyB0aGUgbmV0d29yayB3aXRoIHRoZSBjdXJyZW50IGRhdGFcbiAgICAgICAqIEBwYXJhbSBoaWRkZW4gfCB1c2VkIHRvIGdldCB0aGUgZmlyc3QgZXN0aW1hdGUgb2YgdGhlIG5vZGUgc2l6ZXMuIG9ubHkgdGhlIG5vZGVzIGFyZSBkcmF3biBhZnRlciB3aGljaCB0aGV5IGFyZSBxdWlja2x5IGRyYXduIG92ZXIuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcmVxdWVzdFJlZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlcXVlc3RSZWRyYXcoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLnJlZHJhd1JlcXVlc3RlZCAhPT0gdHJ1ZSAmJiB0aGlzLnJlbmRlcmluZ0FjdGl2ZSA9PT0gZmFsc2UgJiYgdGhpcy5hbGxvd1JlZHJhdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMucmVkcmF3UmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodGhpcy5yZXF1aXJlc1RpbWVvdXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLl9yZWRyYXcoZmFsc2UpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczIuX3JlZHJhdyhmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcmVkcmF3JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVkcmF3KCkge1xuICAgICAgICB2YXIgaGlkZGVuID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5hbGxvd1JlZHJhdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJpbml0UmVkcmF3XCIpO1xuXG4gICAgICAgICAgdGhpcy5yZWRyYXdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAvLyB3aGVuIHRoZSBjb250YWluZXIgZGl2IHdhcyBoaWRkZW4sIHRoaXMgZml4ZXMgaXQgYmFjayB1cCFcbiAgICAgICAgICBpZiAodGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLndpZHRoID09PSAwIHx8IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnNldFNpemUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyAoY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMSk7XG5cbiAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtKHRoaXMucGl4ZWxSYXRpbywgMCwgMCwgdGhpcy5waXhlbFJhdGlvLCAwLCAwKTtcblxuICAgICAgICAgIC8vIGNsZWFyIHRoZSBjYW52YXNcbiAgICAgICAgICB2YXIgdyA9IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgICAgICB2YXIgaCA9IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3LCBoKTtcblxuICAgICAgICAgIC8vIGlmIHRoZSBkaXYgaXMgaGlkZGVuLCB3ZSBzdG9wIHRoZSByZWRyYXcgaGVyZSBmb3IgcGVyZm9ybWFuY2UuXG4gICAgICAgICAgaWYgKHRoaXMuY2FudmFzLmZyYW1lLmNsaWVudFdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gc2V0IHNjYWxpbmcgYW5kIHRyYW5zbGF0aW9uXG4gICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLngsIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkpO1xuICAgICAgICAgIGN0eC5zY2FsZSh0aGlzLmJvZHkudmlldy5zY2FsZSwgdGhpcy5ib2R5LnZpZXcuc2NhbGUpO1xuXG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJiZWZvcmVEcmF3aW5nXCIsIGN0eCk7XG4gICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgICAgaWYgKGhpZGRlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRyYWdnaW5nID09PSBmYWxzZSB8fCB0aGlzLmRyYWdnaW5nID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5oaWRlRWRnZXNPbkRyYWcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2RyYXdFZGdlcyhjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLmRyYWdnaW5nID09PSBmYWxzZSB8fCB0aGlzLmRyYWdnaW5nID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5oaWRlTm9kZXNPbkRyYWcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3Tm9kZXMoY3R4LCBoaWRkZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYWZ0ZXJEcmF3aW5nXCIsIGN0eCk7XG4gICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCBzY2FsaW5nIGFuZCB0cmFuc2xhdGlvblxuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgaWYgKGhpZGRlbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3LCBoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZWRyYXcgYWxsIG5vZGVzXG4gICAgICAgKiBUaGUgMmQgY29udGV4dCBvZiBhIEhUTUwgY2FudmFzIGNhbiBiZSByZXRyaWV2ZWQgYnkgY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gICBjdHhcbiAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Fsd2F5c1Nob3ddXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcmVzaXplTm9kZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNpemVOb2RlcygpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBpZiAodGhpcy5waXhlbFJhdGlvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyAoY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCwgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSk7XG4gICAgICAgIGN0eC5zY2FsZSh0aGlzLmJvZHkudmlldy5zY2FsZSwgdGhpcy5ib2R5LnZpZXcuc2NhbGUpO1xuXG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgdmFyIG5vZGUgPSB2b2lkIDA7XG5cbiAgICAgICAgLy8gcmVzaXplIGFsbCBub2Rlc1xuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gbm9kZXMpIHtcbiAgICAgICAgICBpZiAobm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGVzW25vZGVJZF07XG4gICAgICAgICAgICBub2RlLnJlc2l6ZShjdHgpO1xuICAgICAgICAgICAgbm9kZS51cGRhdGVCb3VuZGluZ0JveChjdHgsIG5vZGUuc2VsZWN0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgc2NhbGluZyBhbmQgdHJhbnNsYXRpb25cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZWRyYXcgYWxsIG5vZGVzXG4gICAgICAgKiBUaGUgMmQgY29udGV4dCBvZiBhIEhUTUwgY2FudmFzIGNhbiBiZSByZXRyaWV2ZWQgYnkgY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gICBjdHhcbiAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Fsd2F5c1Nob3ddXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZHJhd05vZGVzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd05vZGVzKGN0eCkge1xuICAgICAgICB2YXIgYWx3YXlzU2hvdyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICAgIHZhciBub2RlID0gdm9pZCAwO1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSBbXTtcbiAgICAgICAgdmFyIG1hcmdpbiA9IDIwO1xuICAgICAgICB2YXIgdG9wTGVmdCA9IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHsgeDogLW1hcmdpbiwgeTogLW1hcmdpbiB9KTtcbiAgICAgICAgdmFyIGJvdHRvbVJpZ2h0ID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMoe1xuICAgICAgICAgIHg6IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCArIG1hcmdpbixcbiAgICAgICAgICB5OiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0ICsgbWFyZ2luXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdmlld2FibGVBcmVhID0geyB0b3A6IHRvcExlZnQueSwgbGVmdDogdG9wTGVmdC54LCBib3R0b206IGJvdHRvbVJpZ2h0LnksIHJpZ2h0OiBib3R0b21SaWdodC54IH07XG5cbiAgICAgICAgLy8gZHJhdyB1bnNlbGVjdGVkIG5vZGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGVzW25vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgICAvLyBzZXQgc2VsZWN0ZWQgbm9kZXMgYXNpZGVcbiAgICAgICAgICBpZiAobm9kZS5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkLnB1c2gobm9kZUluZGljZXNbaV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYWx3YXlzU2hvdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBub2RlLmRyYXcoY3R4KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5pc0JvdW5kaW5nQm94T3ZlcmxhcHBpbmdXaXRoKHZpZXdhYmxlQXJlYSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgbm9kZS5kcmF3KGN0eCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBub2RlLnVwZGF0ZUJvdW5kaW5nQm94KGN0eCwgbm9kZS5zZWxlY3RlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZHJhdyB0aGUgc2VsZWN0ZWQgbm9kZXMgb24gdG9wXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBzZWxlY3RlZC5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBub2RlID0gbm9kZXNbc2VsZWN0ZWRbX2ldXTtcbiAgICAgICAgICBub2RlLmRyYXcoY3R4KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZHJhdyBhbGwgZWRnZXNcbiAgICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2RyYXdFZGdlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdFZGdlcyhjdHgpIHtcbiAgICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgICB2YXIgZWRnZUluZGljZXMgPSB0aGlzLmJvZHkuZWRnZUluZGljZXM7XG4gICAgICAgIHZhciBlZGdlID0gdm9pZCAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlZGdlID0gZWRnZXNbZWRnZUluZGljZXNbaV1dO1xuICAgICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZWRnZS5kcmF3KGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGV0ZXJtaW5lIGlmIHRoZSBicm93c2VyIHJlcXVpcmVzIGEgc2V0VGltZW91dCBvciBhIHJlcXVlc3RBbmltYXRpb25GcmFtZS4gVGhpcyB3YXMgcmVxdWlyZWQgYmVjYXVzZVxuICAgICAgICogc29tZSBpbXBsZW1lbnRhdGlvbnMgKHNhZmFyaSBhbmQgSUU5KSBkaWQgbm90IHN1cHBvcnQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZGV0ZXJtaW5lQnJvd3Nlck1ldGhvZCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZUJyb3dzZXJNZXRob2QoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHZhciBicm93c2VyVHlwZSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChicm93c2VyVHlwZS5pbmRleE9mKCdtc2llIDkuMCcpICE9IC0xKSB7XG4gICAgICAgICAgICAvLyBJRSA5XG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChicm93c2VyVHlwZS5pbmRleE9mKCdzYWZhcmknKSAhPSAtMSkge1xuICAgICAgICAgICAgLy8gc2FmYXJpXG4gICAgICAgICAgICBpZiAoYnJvd3NlclR5cGUuaW5kZXhPZignY2hyb21lJykgPD0gLTEpIHtcbiAgICAgICAgICAgICAgdGhpcy5yZXF1aXJlc1RpbWVvdXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ2FudmFzUmVuZGVyZXI7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBDYW52YXNSZW5kZXJlcjtcblxuLyoqKi8gfSxcbi8qIDEwOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICB2YXIgSGFtbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG4gIHZhciBoYW1tZXJVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIG1haW4gZnJhbWUgZm9yIHRoZSBOZXR3b3JrLlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIG9uY2Ugd2hlbiBhIE5ldHdvcmsgb2JqZWN0IGlzIGNyZWF0ZWQuIFRoZSBmcmFtZVxuICAgKiBjb250YWlucyBhIGNhbnZhcywgYW5kIHRoaXMgY2FudmFzIGNvbnRhaW5zIGFsbCBvYmplY3RzIGxpa2UgdGhlIGF4aXMgYW5kXG4gICAqIG5vZGVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbnZhcyhib2R5KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FudmFzKTtcblxuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IDE7XG4gICAgICB0aGlzLnJlc2l6ZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yZXNpemVGdW5jdGlvbiA9IHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmNhbWVyYVN0YXRlID0ge307XG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICB0aGlzLmNhbnZhc1ZpZXdDZW50ZXIgPSB7fTtcblxuICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICBhdXRvUmVzaXplOiB0cnVlLFxuICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgd2lkdGg6ICcxMDAlJ1xuICAgICAgfTtcbiAgICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKENhbnZhcywgW3tcbiAgICAgIGtleTogJ2JpbmRFdmVudExpc3RlbmVycycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIC8vIGJpbmQgdGhlIGV2ZW50c1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbmNlKFwicmVzaXplXCIsIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICBpZiAob2JqLndpZHRoICE9PSAwKSB7XG4gICAgICAgICAgICBfdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCA9IG9iai53aWR0aCAqIDAuNTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iai5oZWlnaHQgIT09IDApIHtcbiAgICAgICAgICAgIF90aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55ID0gb2JqLmhlaWdodCAqIDAuNTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInNldFNpemVcIiwgdGhpcy5zZXRTaXplLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLmhhbW1lckZyYW1lLmRlc3Ryb3koKTtcbiAgICAgICAgICBfdGhpcy5oYW1tZXIuZGVzdHJveSgpO1xuICAgICAgICAgIF90aGlzLl9jbGVhblVwKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGZpZWxkcyA9IFsnd2lkdGgnLCAnaGVpZ2h0JywgJ2F1dG9SZXNpemUnXTtcbiAgICAgICAgICB1dGlsLnNlbGVjdGl2ZURlZXBFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUmVzaXplID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gYXV0b21hdGljYWxseSBhZGFwdCB0byBhIGNoYW5naW5nIHNpemUgb2YgdGhlIGJyb3dzZXIuXG4gICAgICAgICAgdGhpcy5fY2xlYW5VcCgpO1xuICAgICAgICAgIHRoaXMucmVzaXplVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlZCA9IF90aGlzMi5zZXRTaXplKCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBfdGhpczIuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgICB0aGlzLnJlc2l6ZUZ1bmN0aW9uID0gdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKTtcbiAgICAgICAgICB1dGlsLmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCAncmVzaXplJywgdGhpcy5yZXNpemVGdW5jdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY2xlYW5VcCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NsZWFuVXAoKSB7XG4gICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgYWRhcHQgdG8gYSBjaGFuZ2luZyBzaXplIG9mIHRoZSBicm93c2VyLlxuICAgICAgICBpZiAodGhpcy5yZXNpemVUaW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnJlc2l6ZVRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLnJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCAncmVzaXplJywgdGhpcy5yZXNpemVGdW5jdGlvbik7XG4gICAgICAgIHRoaXMucmVzaXplRnVuY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX29uUmVzaXplJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25SZXNpemUoKSB7XG4gICAgICAgIHRoaXMuc2V0U2l6ZSgpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgYW5kIHN0b3JlIHRoZSBjYW1lcmFTdGF0ZVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldENhbWVyYVN0YXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q2FtZXJhU3RhdGUoKSB7XG4gICAgICAgIHZhciBwaXhlbFJhdGlvID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLnBpeGVsUmF0aW87XG5cbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmNhbWVyYVN0YXRlLnByZXZpb3VzV2lkdGggPSB0aGlzLmZyYW1lLmNhbnZhcy53aWR0aCAvIHBpeGVsUmF0aW87XG4gICAgICAgICAgdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c0hlaWdodCA9IHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCAvIHBpeGVsUmF0aW87XG4gICAgICAgICAgdGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICAgIHRoaXMuY2FtZXJhU3RhdGUucG9zaXRpb24gPSB0aGlzLkRPTXRvQ2FudmFzKHtcbiAgICAgICAgICAgIHg6IDAuNSAqIHRoaXMuZnJhbWUuY2FudmFzLndpZHRoIC8gcGl4ZWxSYXRpbyxcbiAgICAgICAgICAgIHk6IDAuNSAqIHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCAvIHBpeGVsUmF0aW9cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCB0aGUgY2FtZXJhU3RhdGVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zZXRDYW1lcmFTdGF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldENhbWVyYVN0YXRlKCkge1xuICAgICAgICBpZiAodGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoICE9PSAwICYmIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCAhPT0gMCAmJiB0aGlzLnBpeGVsUmF0aW8gIT09IDAgJiYgdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c1dpZHRoID4gMCkge1xuXG4gICAgICAgICAgdmFyIHdpZHRoUmF0aW8gPSB0aGlzLmZyYW1lLmNhbnZhcy53aWR0aCAvIHRoaXMucGl4ZWxSYXRpbyAvIHRoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNXaWR0aDtcbiAgICAgICAgICB2YXIgaGVpZ2h0UmF0aW8gPSB0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgLyB0aGlzLnBpeGVsUmF0aW8gLyB0aGlzLmNhbWVyYVN0YXRlLnByZXZpb3VzSGVpZ2h0O1xuICAgICAgICAgIHZhciBuZXdTY2FsZSA9IHRoaXMuY2FtZXJhU3RhdGUuc2NhbGU7XG5cbiAgICAgICAgICBpZiAod2lkdGhSYXRpbyAhPSAxICYmIGhlaWdodFJhdGlvICE9IDEpIHtcbiAgICAgICAgICAgIG5ld1NjYWxlID0gdGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSAqIDAuNSAqICh3aWR0aFJhdGlvICsgaGVpZ2h0UmF0aW8pO1xuICAgICAgICAgIH0gZWxzZSBpZiAod2lkdGhSYXRpbyAhPSAxKSB7XG4gICAgICAgICAgICBuZXdTY2FsZSA9IHRoaXMuY2FtZXJhU3RhdGUuc2NhbGUgKiB3aWR0aFJhdGlvO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0UmF0aW8gIT0gMSkge1xuICAgICAgICAgICAgbmV3U2NhbGUgPSB0aGlzLmNhbWVyYVN0YXRlLnNjYWxlICogaGVpZ2h0UmF0aW87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSBuZXdTY2FsZTtcbiAgICAgICAgICAvLyB0aGlzIGNvbWVzIGZyb20gdGhlIHZpZXcgbW9kdWxlLlxuICAgICAgICAgIHZhciBjdXJyZW50Vmlld0NlbnRlciA9IHRoaXMuRE9NdG9DYW52YXMoe1xuICAgICAgICAgICAgeDogMC41ICogdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICB5OiAwLjUgKiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHRcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBkaXN0YW5jZUZyb21DZW50ZXIgPSB7IC8vIG9mZnNldCBmcm9tIHZpZXcsIGRpc3RhbmNlIHZpZXcgaGFzIHRvIGNoYW5nZSBieSB0aGVzZSB4IGFuZCB5IHRvIGNlbnRlciB0aGUgbm9kZVxuICAgICAgICAgICAgeDogY3VycmVudFZpZXdDZW50ZXIueCAtIHRoaXMuY2FtZXJhU3RhdGUucG9zaXRpb24ueCxcbiAgICAgICAgICAgIHk6IGN1cnJlbnRWaWV3Q2VudGVyLnkgLSB0aGlzLmNhbWVyYVN0YXRlLnBvc2l0aW9uLnlcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnggKz0gZGlzdGFuY2VGcm9tQ2VudGVyLnggKiB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55ICs9IGRpc3RhbmNlRnJvbUNlbnRlci55ICogdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcHJlcGFyZVZhbHVlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJlcGFyZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKHZhbHVlLmluZGV4T2YoJyUnKSAhPT0gLTEgfHwgdmFsdWUuaW5kZXhPZigncHgnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLmluZGV4T2YoJyUnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSArICdweCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHVzZSB0aGUgdmFsdWUgc3VwcGxpZWQgZm9yIHdpZHRoIG9yIGhlaWdodDonICsgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSB0aGUgSFRNTFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY3JlYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xuICAgICAgICAvLyByZW1vdmUgYWxsIGVsZW1lbnRzIGZyb20gdGhlIGNvbnRhaW5lciBlbGVtZW50LlxuICAgICAgICB3aGlsZSAodGhpcy5ib2R5LmNvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuYm9keS5jb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuZnJhbWUuY2xhc3NOYW1lID0gJ3Zpcy1uZXR3b3JrJztcbiAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgIHRoaXMuZnJhbWUuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgdGhpcy5mcmFtZS50YWJJbmRleCA9IDkwMDsgLy8gdGFiIGluZGV4IGlzIHJlcXVpcmVkIGZvciBrZXljaGFybSB0byBiaW5kIGtleXN0cm9rZXMgdG8gdGhlIGRpdiBpbnN0ZWFkIG9mIHRoZSB3aW5kb3dcblxuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lLmNhbnZhcyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmZyYW1lLmNhbnZhcy5nZXRDb250ZXh0KSB7XG4gICAgICAgICAgdmFyIG5vQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgICAgICAgbm9DYW52YXMuc3R5bGUuY29sb3IgPSAncmVkJztcbiAgICAgICAgICBub0NhbnZhcy5zdHlsZS5mb250V2VpZ2h0ID0gJ2JvbGQnO1xuICAgICAgICAgIG5vQ2FudmFzLnN0eWxlLnBhZGRpbmcgPSAnMTBweCc7XG4gICAgICAgICAgbm9DYW52YXMuaW5uZXJIVE1MID0gJ0Vycm9yOiB5b3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBIVE1MIGNhbnZhcyc7XG4gICAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMuYXBwZW5kQ2hpbGQobm9DYW52YXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjdHggPSB0aGlzLmZyYW1lLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgdGhpcy5waXhlbFJhdGlvID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gKGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDEpO1xuXG4gICAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdGhlIGZyYW1lIHRvIHRoZSBjb250YWluZXIgZWxlbWVudFxuICAgICAgICB0aGlzLmJvZHkuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZnJhbWUpO1xuXG4gICAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gMTtcbiAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7IHg6IDAuNSAqIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoLCB5OiAwLjUgKiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgfTtcblxuICAgICAgICB0aGlzLl9iaW5kSGFtbWVyKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBmdW5jdGlvbiBiaW5kcyBoYW1tZXIsIGl0IGNhbiBiZSByZXBlYXRlZCBvdmVyIGFuZCBvdmVyIGR1ZSB0byB0aGUgdW5pcXVlbmVzcyBjaGVjay5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19iaW5kSGFtbWVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluZEhhbW1lcigpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFtbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmhhbW1lci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmFnID0ge307XG4gICAgICAgIHRoaXMucGluY2ggPSB7fTtcblxuICAgICAgICAvLyBpbml0IGhhbW1lclxuICAgICAgICB0aGlzLmhhbW1lciA9IG5ldyBIYW1tZXIodGhpcy5mcmFtZS5jYW52YXMpO1xuICAgICAgICB0aGlzLmhhbW1lci5nZXQoJ3BpbmNoJykuc2V0KHsgZW5hYmxlOiB0cnVlIH0pO1xuICAgICAgICAvLyBlbmFibGUgdG8gZ2V0IGJldHRlciByZXNwb25zZSwgdG9kbzogdGVzdCBvbiBtb2JpbGUuXG4gICAgICAgIHRoaXMuaGFtbWVyLmdldCgncGFuJykuc2V0KHsgdGhyZXNob2xkOiA1LCBkaXJlY3Rpb246IEhhbW1lci5ESVJFQ1RJT05fQUxMIH0pO1xuXG4gICAgICAgIGhhbW1lclV0aWwub25Ub3VjaCh0aGlzLmhhbW1lciwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Ub3VjaChldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhbW1lci5vbigndGFwJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25UYXAoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW1tZXIub24oJ2RvdWJsZXRhcCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRG91YmxlVGFwKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCdwcmVzcycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uSG9sZChldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhbW1lci5vbigncGFuc3RhcnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbkRyYWdTdGFydChldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhbW1lci5vbigncGFubW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZyhldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhbW1lci5vbigncGFuZW5kJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnRW5kKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCdwaW5jaCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uUGluY2goZXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUT0RPOiBuZWF0bHkgY2xlYW51cCB0aGVzZSBoYW5kbGVycyB3aGVuIHJlLWNyZWF0aW5nIHRoZSBDYW52YXMsIElGIHRoZXNlIGFyZSBkb25lIHdpdGggaGFtbWVyLCBldmVudC5zdG9wUHJvcGFnYXRpb24gd2lsbCBub3Qgd29yaz9cbiAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uTW91c2VXaGVlbChldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uTW91c2VXaGVlbChldmVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uTW91c2VNb3ZlKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Db250ZXh0KGV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5oYW1tZXJGcmFtZSA9IG5ldyBIYW1tZXIodGhpcy5mcmFtZSk7XG4gICAgICAgIGhhbW1lclV0aWwub25SZWxlYXNlKHRoaXMuaGFtbWVyRnJhbWUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uUmVsZWFzZShldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCBhIG5ldyBzaXplIGZvciB0aGUgbmV0d29ya1xuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdpZHRoICAgV2lkdGggaW4gcGl4ZWxzIG9yIHBlcmNlbnRhZ2UgKGZvciBleGFtcGxlICc4MDBweCdcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIG9yICc1MCUnKVxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGhlaWdodCAgSGVpZ2h0IGluIHBpeGVscyBvciBwZXJjZW50YWdlICAoZm9yIGV4YW1wbGUgJzQwMHB4J1xuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgb3IgJzMwJScpXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldFNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNpemUoKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5vcHRpb25zLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLm9wdGlvbnMuaGVpZ2h0O1xuXG4gICAgICAgIHdpZHRoID0gdGhpcy5fcHJlcGFyZVZhbHVlKHdpZHRoKTtcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5fcHJlcGFyZVZhbHVlKGhlaWdodCk7XG5cbiAgICAgICAgdmFyIGVtaXRFdmVudCA9IGZhbHNlO1xuICAgICAgICB2YXIgb2xkV2lkdGggPSB0aGlzLmZyYW1lLmNhbnZhcy53aWR0aDtcbiAgICAgICAgdmFyIG9sZEhlaWdodCA9IHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodDtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHBpeGVsIHJhdGlvXG4gICAgICAgIHZhciBjdHggPSB0aGlzLmZyYW1lLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIHZhciBwcmV2aW91c1JhdGlvID0gdGhpcy5waXhlbFJhdGlvOyAvLyB3ZSBjYWNoZSB0aGlzIGJlY2F1c2UgdGhlIGNhbWVyYSBzdGF0ZSBzdG9yYWdlIG5lZWRzIHRoZSBvbGQgdmFsdWVcbiAgICAgICAgdGhpcy5waXhlbFJhdGlvID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gKGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDEpO1xuXG4gICAgICAgIGlmICh3aWR0aCAhPSB0aGlzLm9wdGlvbnMud2lkdGggfHwgaGVpZ2h0ICE9IHRoaXMub3B0aW9ucy5oZWlnaHQgfHwgdGhpcy5mcmFtZS5zdHlsZS53aWR0aCAhPSB3aWR0aCB8fCB0aGlzLmZyYW1lLnN0eWxlLmhlaWdodCAhPSBoZWlnaHQpIHtcbiAgICAgICAgICB0aGlzLl9nZXRDYW1lcmFTdGF0ZShwcmV2aW91c1JhdGlvKTtcblxuICAgICAgICAgIHRoaXMuZnJhbWUuc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcblxuICAgICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8pO1xuXG4gICAgICAgICAgdGhpcy5vcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgIHRoaXMuY2FudmFzVmlld0NlbnRlciA9IHtcbiAgICAgICAgICAgIHg6IDAuNSAqIHRoaXMuZnJhbWUuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICB5OiAwLjUgKiB0aGlzLmZyYW1lLmNsaWVudEhlaWdodFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBlbWl0RXZlbnQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoaXMgd291bGQgYWRhcHQgdGhlIHdpZHRoIG9mIHRoZSBjYW52YXMgdG8gdGhlIHdpZHRoIGZyb20gMTAwJSBpZiBhbmQgb25seSBpZlxuICAgICAgICAgIC8vIHRoZXJlIGlzIGEgY2hhbmdlLlxuXG4gICAgICAgICAgLy8gc3RvcmUgdGhlIGNhbWVyYSBpZiB0aGVyZSBpcyBhIGNoYW5nZSBpbiBzaXplLlxuICAgICAgICAgIGlmICh0aGlzLmZyYW1lLmNhbnZhcy53aWR0aCAhPSBNYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoICogdGhpcy5waXhlbFJhdGlvKSB8fCB0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgIT0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8pKSB7XG4gICAgICAgICAgICB0aGlzLl9nZXRDYW1lcmFTdGF0ZShwcmV2aW91c1JhdGlvKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5mcmFtZS5jYW52YXMud2lkdGggIT0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCAqIHRoaXMucGl4ZWxSYXRpbykpIHtcbiAgICAgICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBlbWl0RXZlbnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0ICE9IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvKSkge1xuICAgICAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgZW1pdEV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW1pdEV2ZW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgncmVzaXplJywge1xuICAgICAgICAgICAgd2lkdGg6IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMud2lkdGggLyB0aGlzLnBpeGVsUmF0aW8pLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCAvIHRoaXMucGl4ZWxSYXRpbyksXG4gICAgICAgICAgICBvbGRXaWR0aDogTWF0aC5yb3VuZChvbGRXaWR0aCAvIHRoaXMucGl4ZWxSYXRpbyksXG4gICAgICAgICAgICBvbGRIZWlnaHQ6IE1hdGgucm91bmQob2xkSGVpZ2h0IC8gdGhpcy5waXhlbFJhdGlvKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gcmVzdG9yZSB0aGUgY2FtZXJhIG9uIGNoYW5nZS5cbiAgICAgICAgICB0aGlzLl9zZXRDYW1lcmFTdGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IGluaXRpYWxpemVkIHNvIHRoZSBnZXQgYW5kIHNldCBjYW1lcmEgd2lsbCB3b3JrIGZyb20gbm93IG9uLlxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGVtaXRFdmVudDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfWGNvbnZlcnRET010b0NhbnZhcycsXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZXJ0IHRoZSBYIGNvb3JkaW5hdGUgaW4gRE9NLXNwYWNlIChjb29yZGluYXRlIHBvaW50IGluIGJyb3dzZXIgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lciBkaXYpIHRvXG4gICAgICAgKiB0aGUgWCBjb29yZGluYXRlIGluIGNhbnZhcy1zcGFjZSAodGhlIHNpbXVsYXRpb24gc2FuZGJveCwgd2hpY2ggdGhlIGNhbWVyYSBsb29rcyB1cG9uKVxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX1hjb252ZXJ0RE9NdG9DYW52YXMoeCkge1xuICAgICAgICByZXR1cm4gKHggLSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54KSAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnQgdGhlIFggY29vcmRpbmF0ZSBpbiBjYW52YXMtc3BhY2UgKHRoZSBzaW11bGF0aW9uIHNhbmRib3gsIHdoaWNoIHRoZSBjYW1lcmEgbG9va3MgdXBvbikgdG9cbiAgICAgICAqIHRoZSBYIGNvb3JkaW5hdGUgaW4gRE9NLXNwYWNlIChjb29yZGluYXRlIHBvaW50IGluIGJyb3dzZXIgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lciBkaXYpXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19YY29udmVydENhbnZhc1RvRE9NJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfWGNvbnZlcnRDYW52YXNUb0RPTSh4KSB7XG4gICAgICAgIHJldHVybiB4ICogdGhpcy5ib2R5LnZpZXcuc2NhbGUgKyB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnQgdGhlIFkgY29vcmRpbmF0ZSBpbiBET00tc3BhY2UgKGNvb3JkaW5hdGUgcG9pbnQgaW4gYnJvd3NlciByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIGRpdikgdG9cbiAgICAgICAqIHRoZSBZIGNvb3JkaW5hdGUgaW4gY2FudmFzLXNwYWNlICh0aGUgc2ltdWxhdGlvbiBzYW5kYm94LCB3aGljaCB0aGUgY2FtZXJhIGxvb2tzIHVwb24pXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19ZY29udmVydERPTXRvQ2FudmFzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfWWNvbnZlcnRET010b0NhbnZhcyh5KSB7XG4gICAgICAgIHJldHVybiAoeSAtIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkpIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydCB0aGUgWSBjb29yZGluYXRlIGluIGNhbnZhcy1zcGFjZSAodGhlIHNpbXVsYXRpb24gc2FuZGJveCwgd2hpY2ggdGhlIGNhbWVyYSBsb29rcyB1cG9uKSB0b1xuICAgICAgICogdGhlIFkgY29vcmRpbmF0ZSBpbiBET00tc3BhY2UgKGNvb3JkaW5hdGUgcG9pbnQgaW4gYnJvd3NlciByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIGRpdilcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX1ljb252ZXJ0Q2FudmFzVG9ET00nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9ZY29udmVydENhbnZhc1RvRE9NKHkpIHtcbiAgICAgICAgcmV0dXJuIHkgKiB0aGlzLmJvZHkudmlldy5zY2FsZSArIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwb3MgICA9IHt4OiBudW1iZXIsIHk6IG51bWJlcn1cbiAgICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NhbnZhc1RvRE9NJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYW52YXNUb0RPTShwb3MpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogdGhpcy5fWGNvbnZlcnRDYW52YXNUb0RPTShwb3MueCksIHk6IHRoaXMuX1ljb252ZXJ0Q2FudmFzVG9ET00ocG9zLnkpIH07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwb3MgICA9IHt4OiBudW1iZXIsIHk6IG51bWJlcn1cbiAgICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ0RPTXRvQ2FudmFzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBET010b0NhbnZhcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogdGhpcy5fWGNvbnZlcnRET010b0NhbnZhcyhwb3MueCksIHk6IHRoaXMuX1ljb252ZXJ0RE9NdG9DYW52YXMocG9zLnkpIH07XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENhbnZhcztcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IENhbnZhcztcblxuLyoqKi8gfSxcbi8qIDEwOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9OZXR3b3JrVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTA1KTtcblxuICB2YXIgX05ldHdvcmtVdGlsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05ldHdvcmtVdGlsKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIHZhciBWaWV3ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpZXcoYm9keSwgY2FudmFzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlldyk7XG5cbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcblxuICAgICAgdGhpcy5hbmltYXRpb25TcGVlZCA9IDEgLyB0aGlzLnJlbmRlclJlZnJlc2hSYXRlO1xuICAgICAgdGhpcy5hbmltYXRpb25FYXNpbmdGdW5jdGlvbiA9IFwiZWFzZUluT3V0UXVpbnRcIjtcbiAgICAgIHRoaXMuZWFzaW5nVGltZSA9IDA7XG4gICAgICB0aGlzLnNvdXJjZVNjYWxlID0gMDtcbiAgICAgIHRoaXMudGFyZ2V0U2NhbGUgPSAwO1xuICAgICAgdGhpcy5zb3VyY2VUcmFuc2xhdGlvbiA9IDA7XG4gICAgICB0aGlzLnRhcmdldFRyYW5zbGF0aW9uID0gMDtcbiAgICAgIHRoaXMubG9ja2VkT25Ob2RlSWQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmxvY2tlZE9uTm9kZU9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMudG91Y2hUaW1lID0gMDtcblxuICAgICAgdGhpcy52aWV3RnVuY3Rpb24gPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZml0XCIsIHRoaXMuZml0LmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJhbmltYXRpb25GaW5pc2hlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0b3BSZW5kZXJpbmdcIik7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwidW5sb2NrTm9kZVwiLCB0aGlzLnJlbGVhc2VOb2RlLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhWaWV3LCBbe1xuICAgICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucygpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBmdW5jdGlvbiB6b29tcyBvdXQgdG8gZml0IGFsbCBkYXRhIG9uIHNjcmVlbiBiYXNlZCBvbiBhbW91bnQgb2Ygbm9kZXNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25zXG4gICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbml0aWFsWm9vbV0gIHwgem9vbSBiYXNlZCBvbiBmaXR0ZWQgZm9ybXVsYSBvciByYW5nZSwgdHJ1ZSA9IGZpdHRlZCwgZGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdmaXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpdCgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHsgbm9kZXM6IFtdIH07XG4gICAgICAgIHZhciBpbml0aWFsWm9vbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgICAgdmFyIHJhbmdlID0gdm9pZCAwO1xuICAgICAgICB2YXIgem9vbUxldmVsID0gdm9pZCAwO1xuICAgICAgICBpZiAob3B0aW9ucy5ub2RlcyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMubm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgb3B0aW9ucy5ub2RlcyA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbml0aWFsWm9vbSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIGNoZWNrIGlmIG1vcmUgdGhhbiBoYWxmIG9mIHRoZSBub2RlcyBoYXZlIGEgcHJlZGVmaW5lZCBwb3NpdGlvbi4gSWYgc28sIHdlIHVzZSB0aGUgcmFuZ2UsIG5vdCB0aGUgYXBwcm94aW1hdGlvbi5cbiAgICAgICAgICB2YXIgcG9zaXRpb25EZWZpbmVkID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgICAgaWYgKG5vZGUucHJlZGVmaW5lZFBvc2l0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25EZWZpbmVkICs9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBvc2l0aW9uRGVmaW5lZCA+IDAuNSAqIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZml0KG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByYW5nZSA9IF9OZXR3b3JrVXRpbDIuZGVmYXVsdC5nZXRSYW5nZSh0aGlzLmJvZHkubm9kZXMsIG9wdGlvbnMubm9kZXMpO1xuXG4gICAgICAgICAgdmFyIG51bWJlck9mTm9kZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoO1xuICAgICAgICAgIHpvb21MZXZlbCA9IDEyLjY2MiAvIChudW1iZXJPZk5vZGVzICsgNy40MTQ3KSArIDAuMDk2NDgyMjsgLy8gdGhpcyBpcyBvYnRhaW5lZCBmcm9tIGZpdHRpbmcgYSBkYXRhc2V0IGZyb20gNSBwb2ludHMgd2l0aCBzY2FsZSBsZXZlbHMgdGhhdCBsb29rZWQgZ29vZC5cblxuICAgICAgICAgIC8vIGNvcnJlY3QgZm9yIGxhcmdlciBjYW52YXNzZXMuXG4gICAgICAgICAgdmFyIGZhY3RvciA9IE1hdGgubWluKHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCAvIDYwMCwgdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCAvIDYwMCk7XG4gICAgICAgICAgem9vbUxldmVsICo9IGZhY3RvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3Jlc2l6ZU5vZGVzXCIpO1xuICAgICAgICAgIHJhbmdlID0gX05ldHdvcmtVdGlsMi5kZWZhdWx0LmdldFJhbmdlKHRoaXMuYm9keS5ub2Rlcywgb3B0aW9ucy5ub2Rlcyk7XG5cbiAgICAgICAgICB2YXIgeERpc3RhbmNlID0gTWF0aC5hYnMocmFuZ2UubWF4WCAtIHJhbmdlLm1pblgpICogMS4xO1xuICAgICAgICAgIHZhciB5RGlzdGFuY2UgPSBNYXRoLmFicyhyYW5nZS5tYXhZIC0gcmFuZ2UubWluWSkgKiAxLjE7XG5cbiAgICAgICAgICB2YXIgeFpvb21MZXZlbCA9IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCAvIHhEaXN0YW5jZTtcbiAgICAgICAgICB2YXIgeVpvb21MZXZlbCA9IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgLyB5RGlzdGFuY2U7XG5cbiAgICAgICAgICB6b29tTGV2ZWwgPSB4Wm9vbUxldmVsIDw9IHlab29tTGV2ZWwgPyB4Wm9vbUxldmVsIDogeVpvb21MZXZlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh6b29tTGV2ZWwgPiAxLjApIHtcbiAgICAgICAgICB6b29tTGV2ZWwgPSAxLjA7XG4gICAgICAgIH0gZWxzZSBpZiAoem9vbUxldmVsID09PSAwKSB7XG4gICAgICAgICAgem9vbUxldmVsID0gMS4wO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNlbnRlciA9IF9OZXR3b3JrVXRpbDIuZGVmYXVsdC5maW5kQ2VudGVyKHJhbmdlKTtcbiAgICAgICAgdmFyIGFuaW1hdGlvbk9wdGlvbnMgPSB7IHBvc2l0aW9uOiBjZW50ZXIsIHNjYWxlOiB6b29tTGV2ZWwsIGFuaW1hdGlvbjogb3B0aW9ucy5hbmltYXRpb24gfTtcbiAgICAgICAgdGhpcy5tb3ZlVG8oYW5pbWF0aW9uT3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFuaW1hdGlvblxuXG4gICAgICAvKipcbiAgICAgICAqIENlbnRlciBhIG5vZGUgaW4gdmlldy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gbm9kZUlkXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnNdXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2ZvY3VzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmb2N1cyhub2RlSWQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIG5vZGVQb3NpdGlvbiA9IHsgeDogdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0ueCwgeTogdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0ueSB9O1xuICAgICAgICAgIG9wdGlvbnMucG9zaXRpb24gPSBub2RlUG9zaXRpb247XG4gICAgICAgICAgb3B0aW9ucy5sb2NrZWRPbk5vZGUgPSBub2RlSWQ7XG5cbiAgICAgICAgICB0aGlzLm1vdmVUbyhvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vZGU6IFwiICsgbm9kZUlkICsgXCIgY2Fubm90IGJlIGZvdW5kLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgfCAgb3B0aW9ucy5vZmZzZXQgICA9IHt4Ok51bWJlciwgeTpOdW1iZXJ9ICAgLy8gb2Zmc2V0IGZyb20gdGhlIGNlbnRlciBpbiBET00gcGl4ZWxzXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb3B0aW9ucy5zY2FsZSAgICA9IE51bWJlciAgICAgICAgICAgICAgICAgLy8gc2NhbGUgdG8gbW92ZSB0b1xuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMucG9zaXRpb24gPSB7eDpOdW1iZXIsIHk6TnVtYmVyfSAgIC8vIHBvc2l0aW9uIHRvIG1vdmUgdG9cbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLmFuaW1hdGlvbiA9IHtkdXJhdGlvbjpOdW1iZXIsIGVhc2luZ0Z1bmN0aW9uOlN0cmluZ30gfHwgQm9vbGVhbiAgIC8vIHBvc2l0aW9uIHRvIG1vdmUgdG9cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnbW92ZVRvJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlVG8ob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5vZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG9wdGlvbnMub2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0LnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG9wdGlvbnMub2Zmc2V0LnggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm9mZnNldC55ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRpb25zLm9mZnNldC55ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zY2FsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3B0aW9ucy5zY2FsZSA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uID0gdGhpcy5nZXRWaWV3UG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uID0geyBkdXJhdGlvbjogMCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBvcHRpb25zLmFuaW1hdGlvbiA9IHsgZHVyYXRpb246IDAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICBvcHRpb25zLmFuaW1hdGlvbiA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbi5kdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3B0aW9ucy5hbmltYXRpb24uZHVyYXRpb24gPSAxMDAwO1xuICAgICAgICB9IC8vIGRlZmF1bHQgZHVyYXRpb25cbiAgICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uLmVhc2luZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRpb25zLmFuaW1hdGlvbi5lYXNpbmdGdW5jdGlvbiA9IFwiZWFzZUluT3V0UXVhZFwiO1xuICAgICAgICB9IC8vIGRlZmF1bHQgZWFzaW5nIGZ1bmN0aW9uXG5cbiAgICAgICAgdGhpcy5hbmltYXRlVmlldyhvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgIHwgIG9wdGlvbnMub2Zmc2V0ICAgPSB7eDpOdW1iZXIsIHk6TnVtYmVyfSAgIC8vIG9mZnNldCBmcm9tIHRoZSBjZW50ZXIgaW4gRE9NIHBpeGVsc1xuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMudGltZSAgICAgPSBOdW1iZXIgICAgICAgICAgICAgICAgIC8vIGFuaW1hdGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kc1xuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMuc2NhbGUgICAgPSBOdW1iZXIgICAgICAgICAgICAgICAgIC8vIHNjYWxlIHRvIGFuaW1hdGUgdG9cbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLnBvc2l0aW9uID0ge3g6TnVtYmVyLCB5Ok51bWJlcn0gICAvLyBwb3NpdGlvbiB0byBhbmltYXRlIHRvXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb3B0aW9ucy5lYXNpbmdGdW5jdGlvbiA9IFN0cmluZyAgICAgICAgICAgLy8gbGluZWFyLCBlYXNlSW5RdWFkLCBlYXNlT3V0UXVhZCwgZWFzZUluT3V0UXVhZCxcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlYXNlSW5DdWJpYywgZWFzZU91dEN1YmljLCBlYXNlSW5PdXRDdWJpYyxcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlYXNlSW5RdWFydCwgZWFzZU91dFF1YXJ0LCBlYXNlSW5PdXRRdWFydCxcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlYXNlSW5RdWludCwgZWFzZU91dFF1aW50LCBlYXNlSW5PdXRRdWludFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdhbmltYXRlVmlldycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZVZpZXcob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRWFzaW5nRnVuY3Rpb24gPSBvcHRpb25zLmFuaW1hdGlvbi5lYXNpbmdGdW5jdGlvbjtcbiAgICAgICAgLy8gcmVsZWFzZSBpZiBzb21ldGhpbmcgZm9jdXNzZWQgb24gdGhlIG5vZGVcbiAgICAgICAgdGhpcy5yZWxlYXNlTm9kZSgpO1xuICAgICAgICBpZiAob3B0aW9ucy5sb2NrZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmxvY2tlZE9uTm9kZUlkID0gb3B0aW9ucy5sb2NrZWRPbk5vZGU7XG4gICAgICAgICAgdGhpcy5sb2NrZWRPbk5vZGVPZmZzZXQgPSBvcHRpb25zLm9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZvcmNlZnVsbHkgY29tcGxldGUgdGhlIG9sZCBhbmltYXRpb24gaWYgaXQgd2FzIHN0aWxsIHJ1bm5pbmdcbiAgICAgICAgaWYgKHRoaXMuZWFzaW5nVGltZSAhPSAwKSB7XG4gICAgICAgICAgdGhpcy5fdHJhbnNpdGlvblJlZHJhdyh0cnVlKTsgLy8gYnkgc2V0dGluZyBlYXNpbmd0aW1lIHRvIDEsIHdlIGZpbmlzaCB0aGUgYW5pbWF0aW9uLlxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zb3VyY2VTY2FsZSA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uID0gdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb247XG4gICAgICAgIHRoaXMudGFyZ2V0U2NhbGUgPSBvcHRpb25zLnNjYWxlO1xuXG4gICAgICAgIC8vIHNldCB0aGUgc2NhbGUgc28gdGhlIHZpZXdDZW50ZXIgaXMgYmFzZWQgb24gdGhlIGNvcnJlY3Qgem9vbSBsZXZlbC4gVGhpcyBpcyBvdmVycmlkZGVuIGluIHRoZSB0cmFuc2l0aW9uUmVkcmF3XG4gICAgICAgIC8vIGJ1dCBhdCBsZWFzdCB0aGVuIHdlJ2xsIGhhdmUgdGhlIHRhcmdldCB0cmFuc2l0aW9uXG4gICAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gdGhpcy50YXJnZXRTY2FsZTtcbiAgICAgICAgdmFyIHZpZXdDZW50ZXIgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7IHg6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCwgeTogMC41ICogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCB9KTtcblxuICAgICAgICB2YXIgZGlzdGFuY2VGcm9tQ2VudGVyID0geyAvLyBvZmZzZXQgZnJvbSB2aWV3LCBkaXN0YW5jZSB2aWV3IGhhcyB0byBjaGFuZ2UgYnkgdGhlc2UgeCBhbmQgeSB0byBjZW50ZXIgdGhlIG5vZGVcbiAgICAgICAgICB4OiB2aWV3Q2VudGVyLnggLSBvcHRpb25zLnBvc2l0aW9uLngsXG4gICAgICAgICAgeTogdmlld0NlbnRlci55IC0gb3B0aW9ucy5wb3NpdGlvbi55XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudGFyZ2V0VHJhbnNsYXRpb24gPSB7XG4gICAgICAgICAgeDogdGhpcy5zb3VyY2VUcmFuc2xhdGlvbi54ICsgZGlzdGFuY2VGcm9tQ2VudGVyLnggKiB0aGlzLnRhcmdldFNjYWxlICsgb3B0aW9ucy5vZmZzZXQueCxcbiAgICAgICAgICB5OiB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnkgKyBkaXN0YW5jZUZyb21DZW50ZXIueSAqIHRoaXMudGFyZ2V0U2NhbGUgKyBvcHRpb25zLm9mZnNldC55XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaWYgdGhlIHRpbWUgaXMgc2V0IHRvIDAsIGRvbid0IGRvIGFuIGFuaW1hdGlvblxuICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24uZHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgICBpZiAodGhpcy5sb2NrZWRPbk5vZGVJZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmlld0Z1bmN0aW9uID0gdGhpcy5fbG9ja2VkUmVkcmF3LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImluaXRSZWRyYXdcIiwgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IHRoaXMudGFyZ2V0U2NhbGU7XG4gICAgICAgICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHRoaXMudGFyZ2V0VHJhbnNsYXRpb247XG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYW5pbWF0aW9uU3BlZWQgPSAxIC8gKDYwICogb3B0aW9ucy5hbmltYXRpb24uZHVyYXRpb24gKiAwLjAwMSkgfHwgMSAvIDYwOyAvLyA2MCBmb3IgNjAgc2Vjb25kcywgMC4wMDEgZm9yIG1pbGxpJ3NcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvbkVhc2luZ0Z1bmN0aW9uID0gb3B0aW9ucy5hbmltYXRpb24uZWFzaW5nRnVuY3Rpb247XG5cbiAgICAgICAgICB0aGlzLnZpZXdGdW5jdGlvbiA9IHRoaXMuX3RyYW5zaXRpb25SZWRyYXcuYmluZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImluaXRSZWRyYXdcIiwgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfc3RhcnRSZW5kZXJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB1c2VkIHRvIGFuaW1hdGUgc21vb3RobHkgYnkgaGlqYWNraW5nIHRoZSByZWRyYXcgZnVuY3Rpb24uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbG9ja2VkUmVkcmF3JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9ja2VkUmVkcmF3KCkge1xuICAgICAgICB2YXIgbm9kZVBvc2l0aW9uID0geyB4OiB0aGlzLmJvZHkubm9kZXNbdGhpcy5sb2NrZWRPbk5vZGVJZF0ueCwgeTogdGhpcy5ib2R5Lm5vZGVzW3RoaXMubG9ja2VkT25Ob2RlSWRdLnkgfTtcbiAgICAgICAgdmFyIHZpZXdDZW50ZXIgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7IHg6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCwgeTogMC41ICogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCB9KTtcbiAgICAgICAgdmFyIGRpc3RhbmNlRnJvbUNlbnRlciA9IHsgLy8gb2Zmc2V0IGZyb20gdmlldywgZGlzdGFuY2UgdmlldyBoYXMgdG8gY2hhbmdlIGJ5IHRoZXNlIHggYW5kIHkgdG8gY2VudGVyIHRoZSBub2RlXG4gICAgICAgICAgeDogdmlld0NlbnRlci54IC0gbm9kZVBvc2l0aW9uLngsXG4gICAgICAgICAgeTogdmlld0NlbnRlci55IC0gbm9kZVBvc2l0aW9uLnlcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHNvdXJjZVRyYW5zbGF0aW9uID0gdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb247XG4gICAgICAgIHZhciB0YXJnZXRUcmFuc2xhdGlvbiA9IHtcbiAgICAgICAgICB4OiBzb3VyY2VUcmFuc2xhdGlvbi54ICsgZGlzdGFuY2VGcm9tQ2VudGVyLnggKiB0aGlzLmJvZHkudmlldy5zY2FsZSArIHRoaXMubG9ja2VkT25Ob2RlT2Zmc2V0LngsXG4gICAgICAgICAgeTogc291cmNlVHJhbnNsYXRpb24ueSArIGRpc3RhbmNlRnJvbUNlbnRlci55ICogdGhpcy5ib2R5LnZpZXcuc2NhbGUgKyB0aGlzLmxvY2tlZE9uTm9kZU9mZnNldC55XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB0YXJnZXRUcmFuc2xhdGlvbjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZWxlYXNlTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVsZWFzZU5vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmxvY2tlZE9uTm9kZUlkICE9PSB1bmRlZmluZWQgJiYgdGhpcy52aWV3RnVuY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZihcImluaXRSZWRyYXdcIiwgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICAgIHRoaXMubG9ja2VkT25Ob2RlSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5sb2NrZWRPbk5vZGVPZmZzZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIGVhc2luZ1RpbWVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ190cmFuc2l0aW9uUmVkcmF3JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdHJhbnNpdGlvblJlZHJhdygpIHtcbiAgICAgICAgdmFyIGZpbmlzaGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgICAgICB0aGlzLmVhc2luZ1RpbWUgKz0gdGhpcy5hbmltYXRpb25TcGVlZDtcbiAgICAgICAgdGhpcy5lYXNpbmdUaW1lID0gZmluaXNoZWQgPT09IHRydWUgPyAxLjAgOiB0aGlzLmVhc2luZ1RpbWU7XG5cbiAgICAgICAgdmFyIHByb2dyZXNzID0gdXRpbC5lYXNpbmdGdW5jdGlvbnNbdGhpcy5hbmltYXRpb25FYXNpbmdGdW5jdGlvbl0odGhpcy5lYXNpbmdUaW1lKTtcblxuICAgICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IHRoaXMuc291cmNlU2NhbGUgKyAodGhpcy50YXJnZXRTY2FsZSAtIHRoaXMuc291cmNlU2NhbGUpICogcHJvZ3Jlc3M7XG4gICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0ge1xuICAgICAgICAgIHg6IHRoaXMuc291cmNlVHJhbnNsYXRpb24ueCArICh0aGlzLnRhcmdldFRyYW5zbGF0aW9uLnggLSB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLngpICogcHJvZ3Jlc3MsXG4gICAgICAgICAgeTogdGhpcy5zb3VyY2VUcmFuc2xhdGlvbi55ICsgKHRoaXMudGFyZ2V0VHJhbnNsYXRpb24ueSAtIHRoaXMuc291cmNlVHJhbnNsYXRpb24ueSkgKiBwcm9ncmVzc1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGNsZWFudXBcbiAgICAgICAgaWYgKHRoaXMuZWFzaW5nVGltZSA+PSAxLjApIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vZmYoXCJpbml0UmVkcmF3XCIsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgICB0aGlzLmVhc2luZ1RpbWUgPSAwO1xuICAgICAgICAgIGlmICh0aGlzLmxvY2tlZE9uTm9kZUlkICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy52aWV3RnVuY3Rpb24gPSB0aGlzLl9sb2NrZWRSZWRyYXcuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiaW5pdFJlZHJhd1wiLCB0aGlzLnZpZXdGdW5jdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJhbmltYXRpb25GaW5pc2hlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldFNjYWxlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldFZpZXdQb3NpdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Vmlld1Bvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMoeyB4OiAwLjUgKiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgsIHk6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgfSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFZpZXc7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBWaWV3O1xuXG4vKioqLyB9LFxuLyogMTEwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX05hdmlnYXRpb25IYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTEpO1xuXG4gIHZhciBfTmF2aWdhdGlvbkhhbmRsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTmF2aWdhdGlvbkhhbmRsZXIpO1xuXG4gIHZhciBfUG9wdXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMik7XG5cbiAgdmFyIF9Qb3B1cDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qb3B1cCk7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICB2YXIgSW50ZXJhY3Rpb25IYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEludGVyYWN0aW9uSGFuZGxlcihib2R5LCBjYW52YXMsIHNlbGVjdGlvbkhhbmRsZXIpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnRlcmFjdGlvbkhhbmRsZXIpO1xuXG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIgPSBzZWxlY3Rpb25IYW5kbGVyO1xuICAgICAgdGhpcy5uYXZpZ2F0aW9uSGFuZGxlciA9IG5ldyBfTmF2aWdhdGlvbkhhbmRsZXIyLmRlZmF1bHQoYm9keSwgY2FudmFzKTtcblxuICAgICAgLy8gYmluZCB0aGUgZXZlbnRzIGZyb20gaGFtbWVyIHRvIGZ1bmN0aW9ucyBpbiB0aGlzIG9iamVjdFxuICAgICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uVGFwID0gdGhpcy5vblRhcC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uVG91Y2ggPSB0aGlzLm9uVG91Y2guYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbkRvdWJsZVRhcCA9IHRoaXMub25Eb3VibGVUYXAuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbkhvbGQgPSB0aGlzLm9uSG9sZC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZ1N0YXJ0ID0gdGhpcy5vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZyA9IHRoaXMub25EcmFnLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnRW5kID0gdGhpcy5vbkRyYWdFbmQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbk1vdXNlV2hlZWwgPSB0aGlzLm9uTW91c2VXaGVlbC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uUGluY2ggPSB0aGlzLm9uUGluY2guYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbk1vdXNlTW92ZSA9IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vblJlbGVhc2UgPSB0aGlzLm9uUmVsZWFzZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uQ29udGV4dCA9IHRoaXMub25Db250ZXh0LmJpbmQodGhpcyk7XG5cbiAgICAgIHRoaXMudG91Y2hUaW1lID0gMDtcbiAgICAgIHRoaXMuZHJhZyA9IHt9O1xuICAgICAgdGhpcy5waW5jaCA9IHt9O1xuICAgICAgdGhpcy5wb3B1cCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMucG9wdXBPYmogPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnBvcHVwVGltZXIgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlci5iaW5kKHRoaXMpO1xuXG4gICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIGRyYWdOb2RlczogdHJ1ZSxcbiAgICAgICAgZHJhZ1ZpZXc6IHRydWUsXG4gICAgICAgIGhvdmVyOiBmYWxzZSxcbiAgICAgICAga2V5Ym9hcmQ6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBzcGVlZDogeyB4OiAxMCwgeTogMTAsIHpvb206IDAuMDIgfSxcbiAgICAgICAgICBiaW5kVG9XaW5kb3c6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgbmF2aWdhdGlvbkJ1dHRvbnM6IGZhbHNlLFxuICAgICAgICB0b29sdGlwRGVsYXk6IDMwMCxcbiAgICAgICAgem9vbVZpZXc6IHRydWVcbiAgICAgIH07XG4gICAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhJbnRlcmFjdGlvbkhhbmRsZXIsIFt7XG4gICAgICBrZXk6ICdiaW5kRXZlbnRMaXN0ZW5lcnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMucG9wdXBUaW1lcik7XG4gICAgICAgICAgZGVsZXRlIF90aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXI7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gZXh0ZW5kIGFsbCBidXQgdGhlIHZhbHVlcyBpbiBmaWVsZHNcbiAgICAgICAgICB2YXIgZmllbGRzID0gWydoaWRlRWRnZXNPbkRyYWcnLCAnaGlkZU5vZGVzT25EcmFnJywgJ2tleWJvYXJkJywgJ211bHRpc2VsZWN0JywgJ3NlbGVjdGFibGUnLCAnc2VsZWN0Q29ubmVjdGVkRWRnZXMnXTtcbiAgICAgICAgICB1dGlsLnNlbGVjdGl2ZU5vdERlZXBFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgLy8gbWVyZ2UgdGhlIGtleWJvYXJkIG9wdGlvbnMgaW4uXG4gICAgICAgICAgdXRpbC5tZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zLCAna2V5Ym9hcmQnKTtcblxuICAgICAgICAgIGlmIChvcHRpb25zLnRvb2x0aXApIHtcbiAgICAgICAgICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucy50b29sdGlwLCBvcHRpb25zLnRvb2x0aXApO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMudG9vbHRpcC5jb2xvcikge1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudG9vbHRpcC5jb2xvciA9IHV0aWwucGFyc2VDb2xvcihvcHRpb25zLnRvb2x0aXAuY29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkhhbmRsZXIuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCB0aGUgcG9pbnRlciBsb2NhdGlvbiBmcm9tIGEgdG91Y2ggbG9jYXRpb25cbiAgICAgICAqIEBwYXJhbSB7e3g6IE51bWJlciwgeTogTnVtYmVyfX0gdG91Y2hcbiAgICAgICAqIEByZXR1cm4ge3t4OiBOdW1iZXIsIHk6IE51bWJlcn19IHBvaW50ZXJcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldFBvaW50ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50ZXIodG91Y2gpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB0b3VjaC54IC0gdXRpbC5nZXRBYnNvbHV0ZUxlZnQodGhpcy5jYW52YXMuZnJhbWUuY2FudmFzKSxcbiAgICAgICAgICB5OiB0b3VjaC55IC0gdXRpbC5nZXRBYnNvbHV0ZVRvcCh0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT24gc3RhcnQgb2YgYSB0b3VjaCBnZXN0dXJlLCBzdG9yZSB0aGUgcG9pbnRlclxuICAgICAgICogQHBhcmFtIGV2ZW50XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdvblRvdWNoJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblRvdWNoKGV2ZW50KSB7XG4gICAgICAgIGlmIChuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHRoaXMudG91Y2hUaW1lID4gNTApIHtcbiAgICAgICAgICB0aGlzLmRyYWcucG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgICAgIHRoaXMuZHJhZy5waW5jaGVkID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5waW5jaC5zY2FsZSA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICAgIC8vIHRvIGF2b2lkIGRvdWJsZSBmaXJlaW5nIG9mIHRoaXMgZXZlbnQgYmVjYXVzZSB3ZSBoYXZlIHR3byBoYW1tZXIgaW5zdGFuY2VzLiAob24gY2FudmFzIGFuZCBvbiBmcmFtZSlcbiAgICAgICAgICB0aGlzLnRvdWNoVGltZSA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogaGFuZGxlIHRhcC9jbGljayBldmVudDogc2VsZWN0L3Vuc2VsZWN0IGEgbm9kZVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnb25UYXAnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uVGFwKGV2ZW50KSB7XG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgIHZhciBtdWx0aXNlbGVjdCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5vcHRpb25zLm11bHRpc2VsZWN0ICYmIChldmVudC5jaGFuZ2VkUG9pbnRlcnNbMF0uY3RybEtleSB8fCBldmVudC5jaGFuZ2VkUG9pbnRlcnNbMF0ubWV0YUtleSk7XG5cbiAgICAgICAgdGhpcy5jaGVja1NlbGVjdGlvbkNoYW5nZXMocG9pbnRlciwgZXZlbnQsIG11bHRpc2VsZWN0KTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ2NsaWNrJywgZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGhhbmRsZSBkb3VibGV0YXAgZXZlbnRcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ29uRG91YmxlVGFwJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRvdWJsZVRhcChldmVudCkge1xuICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnZG91YmxlQ2xpY2snLCBldmVudCwgcG9pbnRlcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogaGFuZGxlIGxvbmcgdGFwIGV2ZW50OiBtdWx0aSBzZWxlY3Qgbm9kZXNcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ29uSG9sZCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb25Ib2xkKGV2ZW50KSB7XG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgIHZhciBtdWx0aXNlbGVjdCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5vcHRpb25zLm11bHRpc2VsZWN0O1xuXG4gICAgICAgIHRoaXMuY2hlY2tTZWxlY3Rpb25DaGFuZ2VzKHBvaW50ZXIsIGV2ZW50LCBtdWx0aXNlbGVjdCk7XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ2NsaWNrJywgZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnaG9sZCcsIGV2ZW50LCBwb2ludGVyKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBoYW5kbGUgdGhlIHJlbGVhc2Ugb2YgdGhlIHNjcmVlblxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ29uUmVsZWFzZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb25SZWxlYXNlKGV2ZW50KSB7XG4gICAgICAgIGlmIChuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHRoaXMudG91Y2hUaW1lID4gMTApIHtcbiAgICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdyZWxlYXNlJywgZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgICAgIC8vIHRvIGF2b2lkIGRvdWJsZSBmaXJlaW5nIG9mIHRoaXMgZXZlbnQgYmVjYXVzZSB3ZSBoYXZlIHR3byBoYW1tZXIgaW5zdGFuY2VzLiAob24gY2FudmFzIGFuZCBvbiBmcmFtZSlcbiAgICAgICAgICB0aGlzLnRvdWNoVGltZSA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnb25Db250ZXh0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNvbnRleHQoZXZlbnQpIHtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0pO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnb25jb250ZXh0JywgZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gcG9pbnRlclxuICAgICAgICogQHBhcmFtIGFkZFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjaGVja1NlbGVjdGlvbkNoYW5nZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrU2VsZWN0aW9uQ2hhbmdlcyhwb2ludGVyLCBldmVudCkge1xuICAgICAgICB2YXIgYWRkID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgICB2YXIgcHJldmlvdXNseVNlbGVjdGVkRWRnZUNvdW50ID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZXRTZWxlY3RlZEVkZ2VDb3VudCgpO1xuICAgICAgICB2YXIgcHJldmlvdXNseVNlbGVjdGVkTm9kZUNvdW50ID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZXRTZWxlY3RlZE5vZGVDb3VudCgpO1xuICAgICAgICB2YXIgcHJldmlvdXNTZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIHZhciBzZWxlY3RlZCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGFkZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHNlbGVjdGVkID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdEFkZGl0aW9uYWxPblBvaW50KHBvaW50ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGVjdGVkID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdE9uUG9pbnQocG9pbnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbGVjdGVkRWRnZXNDb3VudCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2V0U2VsZWN0ZWRFZGdlQ291bnQoKTtcbiAgICAgICAgdmFyIHNlbGVjdGVkTm9kZXNDb3VudCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2V0U2VsZWN0ZWROb2RlQ291bnQoKTtcbiAgICAgICAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgdmFyIF9kZXRlcm1pbmVJZkRpZmZlcmVudDIgPSB0aGlzLl9kZXRlcm1pbmVJZkRpZmZlcmVudChwcmV2aW91c1NlbGVjdGlvbiwgY3VycmVudFNlbGVjdGlvbiksXG4gICAgICAgICAgICBub2Rlc0NoYW5nZWQgPSBfZGV0ZXJtaW5lSWZEaWZmZXJlbnQyLm5vZGVzQ2hhbmdlZCxcbiAgICAgICAgICAgIGVkZ2VzQ2hhbmdlZCA9IF9kZXRlcm1pbmVJZkRpZmZlcmVudDIuZWRnZXNDaGFuZ2VkO1xuXG4gICAgICAgIHZhciBub2RlU2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc2VsZWN0ZWROb2Rlc0NvdW50IC0gcHJldmlvdXNseVNlbGVjdGVkTm9kZUNvdW50ID4gMCkge1xuICAgICAgICAgIC8vIG5vZGUgd2FzIHNlbGVjdGVkXG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ3NlbGVjdE5vZGUnLCBldmVudCwgcG9pbnRlcik7XG4gICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIG5vZGVTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZXNDaGFuZ2VkID09PSB0cnVlICYmIHNlbGVjdGVkTm9kZXNDb3VudCA+IDApIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnZGVzZWxlY3ROb2RlJywgZXZlbnQsIHBvaW50ZXIsIHByZXZpb3VzU2VsZWN0aW9uKTtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnc2VsZWN0Tm9kZScsIGV2ZW50LCBwb2ludGVyKTtcbiAgICAgICAgICBub2RlU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZE5vZGVzQ291bnQgLSBwcmV2aW91c2x5U2VsZWN0ZWROb2RlQ291bnQgPCAwKSB7XG4gICAgICAgICAgLy8gbm9kZSB3YXMgZGVzZWxlY3RlZFxuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdkZXNlbGVjdE5vZGUnLCBldmVudCwgcG9pbnRlciwgcHJldmlvdXNTZWxlY3Rpb24pO1xuICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSB0aGUgc2VsZWN0ZWQgZWRnZXNcbiAgICAgICAgaWYgKHNlbGVjdGVkRWRnZXNDb3VudCAtIHByZXZpb3VzbHlTZWxlY3RlZEVkZ2VDb3VudCA+IDAgJiYgbm9kZVNlbGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgIC8vIGVkZ2Ugd2FzIHNlbGVjdGVkXG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ3NlbGVjdEVkZ2UnLCBldmVudCwgcG9pbnRlcik7XG4gICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdGVkRWRnZXNDb3VudCA+IDAgJiYgZWRnZXNDaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ2Rlc2VsZWN0RWRnZScsIGV2ZW50LCBwb2ludGVyLCBwcmV2aW91c1NlbGVjdGlvbik7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ3NlbGVjdEVkZ2UnLCBldmVudCwgcG9pbnRlcik7XG4gICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdGVkRWRnZXNDb3VudCAtIHByZXZpb3VzbHlTZWxlY3RlZEVkZ2VDb3VudCA8IDApIHtcbiAgICAgICAgICAvLyBlZGdlIHdhcyBkZXNlbGVjdGVkXG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ2Rlc2VsZWN0RWRnZScsIGV2ZW50LCBwb2ludGVyLCBwcmV2aW91c1NlbGVjdGlvbik7XG4gICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlyZSB0aGUgc2VsZWN0IGV2ZW50IGlmIGFueXRoaW5nIGhhcyBiZWVuIHNlbGVjdGVkIG9yIGRlc2VsZWN0ZWRcbiAgICAgICAgaWYgKHNlbGVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gc2VsZWN0IG9yIHVuc2VsZWN0XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ3NlbGVjdCcsIGV2ZW50LCBwb2ludGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gY2hlY2tzIGlmIHRoZSBub2RlcyBhbmQgZWRnZXMgcHJldmlvdXNseSBzZWxlY3RlZCBoYXZlIGNoYW5nZWQuXG4gICAgICAgKiBAcGFyYW0gcHJldmlvdXNTZWxlY3Rpb25cbiAgICAgICAqIEBwYXJhbSBjdXJyZW50U2VsZWN0aW9uXG4gICAgICAgKiBAcmV0dXJucyB7e25vZGVzQ2hhbmdlZDogYm9vbGVhbiwgZWRnZXNDaGFuZ2VkOiBib29sZWFufX1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19kZXRlcm1pbmVJZkRpZmZlcmVudCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZUlmRGlmZmVyZW50KHByZXZpb3VzU2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciBub2Rlc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVkZ2VzQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldmlvdXNTZWxlY3Rpb24ubm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoY3VycmVudFNlbGVjdGlvbi5ub2Rlcy5pbmRleE9mKHByZXZpb3VzU2VsZWN0aW9uLm5vZGVzW2ldKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG5vZGVzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBjdXJyZW50U2VsZWN0aW9uLm5vZGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIGlmIChwcmV2aW91c1NlbGVjdGlvbi5ub2Rlcy5pbmRleE9mKHByZXZpb3VzU2VsZWN0aW9uLm5vZGVzW19pXSkgPT09IC0xKSB7XG4gICAgICAgICAgICBub2Rlc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwcmV2aW91c1NlbGVjdGlvbi5lZGdlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRTZWxlY3Rpb24uZWRnZXMuaW5kZXhPZihwcmV2aW91c1NlbGVjdGlvbi5lZGdlc1tfaTJdKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGVkZ2VzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGN1cnJlbnRTZWxlY3Rpb24uZWRnZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICAgIGlmIChwcmV2aW91c1NlbGVjdGlvbi5lZGdlcy5pbmRleE9mKHByZXZpb3VzU2VsZWN0aW9uLmVkZ2VzW19pM10pID09PSAtMSkge1xuICAgICAgICAgICAgZWRnZXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBub2Rlc0NoYW5nZWQ6IG5vZGVzQ2hhbmdlZCwgZWRnZXNDaGFuZ2VkOiBlZGdlc0NoYW5nZWQgfTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSBvbkRyYWdTdGFydC5cbiAgICAgICAqIEl0IGlzIHNlcGFyYXRlZCBvdXQgYmVjYXVzZSB3ZSBjYW4gdGhlbiBvdmVybG9hZCBpdCBmb3IgdGhlIGRhdGFtYW5pcHVsYXRpb24gc3lzdGVtLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ29uRHJhZ1N0YXJ0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRyYWdTdGFydChldmVudCkge1xuICAgICAgICAvL2luIGNhc2UgdGhlIHRvdWNoIGV2ZW50IHdhcyB0cmlnZ2VyZWQgb24gYW4gZXh0ZXJuYWwgZGl2LCBkbyB0aGUgaW5pdGlhbCB0b3VjaCBub3cuXG4gICAgICAgIGlmICh0aGlzLmRyYWcucG9pbnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vblRvdWNoKGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdGU6IGRyYWcucG9pbnRlciBpcyBzZXQgaW4gb25Ub3VjaCB0byBnZXQgdGhlIGluaXRpYWwgdG91Y2ggbG9jYXRpb25cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0Tm9kZUF0KHRoaXMuZHJhZy5wb2ludGVyKTtcblxuICAgICAgICB0aGlzLmRyYWcuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmRyYWcuc2VsZWN0aW9uID0gW107XG4gICAgICAgIHRoaXMuZHJhZy50cmFuc2xhdGlvbiA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbik7IC8vIGNvcHkgdGhlIG9iamVjdFxuICAgICAgICB0aGlzLmRyYWcubm9kZUlkID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zLmRyYWdOb2RlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuZHJhZy5ub2RlSWQgPSBub2RlLmlkO1xuICAgICAgICAgIC8vIHNlbGVjdCB0aGUgY2xpY2tlZCBub2RlIGlmIG5vdCB5ZXQgc2VsZWN0ZWRcbiAgICAgICAgICBpZiAobm9kZS5pc1NlbGVjdGVkKCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RPYmplY3Qobm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYWZ0ZXIgc2VsZWN0IHRvIGNvbnRhaW4gdGhlIG5vZGVcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnZHJhZ1N0YXJ0JywgZXZlbnQsIHRoaXMuZHJhZy5wb2ludGVyKTtcblxuICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0aW9uT2JqLm5vZGVzO1xuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBhcnJheSB3aXRoIHRoZSBzZWxlY3RlZCBub2RlcyBhbmQgdGhlaXIgb3JpZ2luYWwgbG9jYXRpb24gYW5kIHN0YXR1c1xuICAgICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgICB2YXIgb2JqZWN0ID0gc2VsZWN0aW9uW25vZGVJZF07XG4gICAgICAgICAgICAgIHZhciBzID0ge1xuICAgICAgICAgICAgICAgIGlkOiBvYmplY3QuaWQsXG4gICAgICAgICAgICAgICAgbm9kZTogb2JqZWN0LFxuXG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgb3JpZ2luYWwgeCwgeSwgeEZpeGVkIGFuZCB5Rml4ZWQsIG1ha2UgdGhlIG5vZGUgdGVtcG9yYXJpbHkgRml4ZWRcbiAgICAgICAgICAgICAgICB4OiBvYmplY3QueCxcbiAgICAgICAgICAgICAgICB5OiBvYmplY3QueSxcbiAgICAgICAgICAgICAgICB4Rml4ZWQ6IG9iamVjdC5vcHRpb25zLmZpeGVkLngsXG4gICAgICAgICAgICAgICAgeUZpeGVkOiBvYmplY3Qub3B0aW9ucy5maXhlZC55XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgb2JqZWN0Lm9wdGlvbnMuZml4ZWQueCA9IHRydWU7XG4gICAgICAgICAgICAgIG9iamVjdC5vcHRpb25zLmZpeGVkLnkgPSB0cnVlO1xuXG4gICAgICAgICAgICAgIHRoaXMuZHJhZy5zZWxlY3Rpb24ucHVzaChzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZmFsbGJhY2sgaWYgbm8gbm9kZSBpcyBzZWxlY3RlZCBhbmQgdGh1cyB0aGUgdmlldyBpcyBkcmFnZ2VkLlxuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdkcmFnU3RhcnQnLCBldmVudCwgdGhpcy5kcmFnLnBvaW50ZXIsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBoYW5kbGUgZHJhZyBldmVudFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnb25EcmFnJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRyYWcoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuZHJhZy5waW5jaGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBmb2N1cyBvbiBub2RlIGlmIGl0IGlzIGZvY3Vzc2VkIG9uIGJ5IHRoZSBmb2N1c09uTm9kZVxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCd1bmxvY2tOb2RlJyk7XG5cbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcblxuICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5kcmFnLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBzZWxlY3Rpb24ubGVuZ3RoICYmIHRoaXMub3B0aW9ucy5kcmFnTm9kZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMyLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnZHJhZ2dpbmcnLCBldmVudCwgcG9pbnRlcik7XG5cbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBkZWx0YSdzIGFuZCBuZXcgbG9jYXRpb25cbiAgICAgICAgICAgIHZhciBkZWx0YVggPSBwb2ludGVyLnggLSBfdGhpczIuZHJhZy5wb2ludGVyLng7XG4gICAgICAgICAgICB2YXIgZGVsdGFZID0gcG9pbnRlci55IC0gX3RoaXMyLmRyYWcucG9pbnRlci55O1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb24gb2YgYWxsIHNlbGVjdGVkIG5vZGVzXG4gICAgICAgICAgICBzZWxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgIHZhciBub2RlID0gc2VsZWN0aW9uLm5vZGU7XG4gICAgICAgICAgICAgIC8vIG9ubHkgbW92ZSB0aGUgbm9kZSBpZiBpdCB3YXMgbm90IGZpeGVkIGluaXRpYWxseVxuICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnhGaXhlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBub2RlLnggPSBfdGhpczIuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKF90aGlzMi5jYW52YXMuX1hjb252ZXJ0Q2FudmFzVG9ET00oc2VsZWN0aW9uLngpICsgZGVsdGFYKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBvbmx5IG1vdmUgdGhlIG5vZGUgaWYgaXQgd2FzIG5vdCBmaXhlZCBpbml0aWFsbHlcbiAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi55Rml4ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS55ID0gX3RoaXMyLmNhbnZhcy5fWWNvbnZlcnRET010b0NhbnZhcyhfdGhpczIuY2FudmFzLl9ZY29udmVydENhbnZhc1RvRE9NKHNlbGVjdGlvbi55KSArIGRlbHRhWSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBzdGFydCB0aGUgc2ltdWxhdGlvbiBvZiB0aGUgcGh5c2ljc1xuICAgICAgICAgICAgX3RoaXMyLmJvZHkuZW1pdHRlci5lbWl0KCdzdGFydFNpbXVsYXRpb24nKTtcbiAgICAgICAgICB9KSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG1vdmUgdGhlIG5ldHdvcmtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRyYWdWaWV3ID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnZHJhZ2dpbmcnLCBldmVudCwgcG9pbnRlciwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlIGRyYWcgd2FzIG5vdCBzdGFydGVkIHByb3Blcmx5IGJlY2F1c2UgdGhlIGNsaWNrIHN0YXJ0ZWQgb3V0c2lkZSB0aGUgbmV0d29yayBkaXYsIHN0YXJ0IGl0IG5vdy5cbiAgICAgICAgICAgIGlmICh0aGlzLmRyYWcucG9pbnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRoaXMub25EcmFnU3RhcnQoZXZlbnQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGlmZlggPSBwb2ludGVyLnggLSB0aGlzLmRyYWcucG9pbnRlci54O1xuICAgICAgICAgICAgdmFyIGRpZmZZID0gcG9pbnRlci55IC0gdGhpcy5kcmFnLnBvaW50ZXIueTtcblxuICAgICAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7IHg6IHRoaXMuZHJhZy50cmFuc2xhdGlvbi54ICsgZGlmZlgsIHk6IHRoaXMuZHJhZy50cmFuc2xhdGlvbi55ICsgZGlmZlkgfTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZWRyYXcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBoYW5kbGUgZHJhZyBzdGFydCBldmVudFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnb25EcmFnRW5kJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRyYWdFbmQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kcmFnLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmRyYWcuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoc2VsZWN0aW9uICYmIHNlbGVjdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgICBzZWxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCB4Rml4ZWQgYW5kIHlGaXhlZFxuICAgICAgICAgICAgcy5ub2RlLm9wdGlvbnMuZml4ZWQueCA9IHMueEZpeGVkO1xuICAgICAgICAgICAgcy5ub2RlLm9wdGlvbnMuZml4ZWQueSA9IHMueUZpeGVkO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdkcmFnRW5kJywgZXZlbnQsIHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzdGFydFNpbXVsYXRpb24nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnZHJhZ0VuZCcsIGV2ZW50LCB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVxdWVzdFJlZHJhdycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlIHBpbmNoIGV2ZW50XG4gICAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ29uUGluY2gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uUGluY2goZXZlbnQpIHtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcblxuICAgICAgICB0aGlzLmRyYWcucGluY2hlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnBpbmNoWydzY2FsZSddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnBpbmNoLnNjYWxlID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGVuYWJsZWQgbW92aW5nIHdoaWxlIHBpbmNoaW5nP1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnBpbmNoLnNjYWxlICogZXZlbnQuc2NhbGU7XG4gICAgICAgIHRoaXMuem9vbShzY2FsZSwgcG9pbnRlcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogWm9vbSB0aGUgbmV0d29yayBpbiBvciBvdXRcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSBhIG51bWJlciBhcm91bmQgMSwgYW5kIGJldHdlZW4gMC4wMSBhbmQgMTBcbiAgICAgICAqIEBwYXJhbSB7e3g6IE51bWJlciwgeTogTnVtYmVyfX0gcG9pbnRlciAgICBQb3NpdGlvbiBvbiBzY3JlZW5cbiAgICAgICAqIEByZXR1cm4ge051bWJlcn0gYXBwbGllZFNjYWxlICAgIHNjYWxlIGlzIGxpbWl0ZWQgd2l0aGluIHRoZSBib3VuZGFyaWVzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd6b29tJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB6b29tKHNjYWxlLCBwb2ludGVyKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuem9vbVZpZXcgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgc2NhbGVPbGQgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgICBpZiAoc2NhbGUgPCAwLjAwMDAxKSB7XG4gICAgICAgICAgICBzY2FsZSA9IDAuMDAwMDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzY2FsZSA+IDEwKSB7XG4gICAgICAgICAgICBzY2FsZSA9IDEwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwcmVTY2FsZURyYWdQb2ludGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmICh0aGlzLmRyYWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHJhZy5kcmFnZ2luZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBwcmVTY2FsZURyYWdQb2ludGVyID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXModGhpcy5kcmFnLnBvaW50ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyArIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgLyAyXG4gICAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb247XG5cbiAgICAgICAgICB2YXIgc2NhbGVGcmFjID0gc2NhbGUgLyBzY2FsZU9sZDtcbiAgICAgICAgICB2YXIgdHggPSAoMSAtIHNjYWxlRnJhYykgKiBwb2ludGVyLnggKyB0cmFuc2xhdGlvbi54ICogc2NhbGVGcmFjO1xuICAgICAgICAgIHZhciB0eSA9ICgxIC0gc2NhbGVGcmFjKSAqIHBvaW50ZXIueSArIHRyYW5zbGF0aW9uLnkgKiBzY2FsZUZyYWM7XG5cbiAgICAgICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IHNjYWxlO1xuICAgICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0geyB4OiB0eCwgeTogdHkgfTtcblxuICAgICAgICAgIGlmIChwcmVTY2FsZURyYWdQb2ludGVyICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHBvc3RTY2FsZURyYWdQb2ludGVyID0gdGhpcy5jYW52YXMuY2FudmFzVG9ET00ocHJlU2NhbGVEcmFnUG9pbnRlcik7XG4gICAgICAgICAgICB0aGlzLmRyYWcucG9pbnRlci54ID0gcG9zdFNjYWxlRHJhZ1BvaW50ZXIueDtcbiAgICAgICAgICAgIHRoaXMuZHJhZy5wb2ludGVyLnkgPSBwb3N0U2NhbGVEcmFnUG9pbnRlci55O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG5cbiAgICAgICAgICBpZiAoc2NhbGVPbGQgPCBzY2FsZSkge1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnem9vbScsIHsgZGlyZWN0aW9uOiAnKycsIHNjYWxlOiB0aGlzLmJvZHkudmlldy5zY2FsZSB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnem9vbScsIHsgZGlyZWN0aW9uOiAnLScsIHNjYWxlOiB0aGlzLmJvZHkudmlldy5zY2FsZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFdmVudCBoYW5kbGVyIGZvciBtb3VzZSB3aGVlbCBldmVudCwgdXNlZCB0byB6b29tIHRoZSB0aW1lbGluZVxuICAgICAgICogU2VlIGh0dHA6Ly9hZG9tYXMub3JnL2phdmFzY3JpcHQtbW91c2Utd2hlZWwvXG4gICAgICAgKiAgICAgaHR0cHM6Ly9naXRodWIuY29tL0VpZ2h0TWVkaWEvaGFtbWVyLmpzL2lzc3Vlcy8yNTZcbiAgICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gIGV2ZW50XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdvbk1vdXNlV2hlZWwnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uTW91c2VXaGVlbChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnpvb21WaWV3ID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gcmV0cmlldmUgZGVsdGFcbiAgICAgICAgICB2YXIgZGVsdGEgPSAwO1xuICAgICAgICAgIGlmIChldmVudC53aGVlbERlbHRhKSB7XG4gICAgICAgICAgICAvKiBJRS9PcGVyYS4gKi9cbiAgICAgICAgICAgIGRlbHRhID0gZXZlbnQud2hlZWxEZWx0YSAvIDEyMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmRldGFpbCkge1xuICAgICAgICAgICAgLyogTW96aWxsYSBjYXNlLiAqL1xuICAgICAgICAgICAgLy8gSW4gTW96aWxsYSwgc2lnbiBvZiBkZWx0YSBpcyBkaWZmZXJlbnQgdGhhbiBpbiBJRS5cbiAgICAgICAgICAgIC8vIEFsc28sIGRlbHRhIGlzIG11bHRpcGxlIG9mIDMuXG4gICAgICAgICAgICBkZWx0YSA9IC1ldmVudC5kZXRhaWwgLyAzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIGRlbHRhIGlzIG5vbnplcm8sIGhhbmRsZSBpdC5cbiAgICAgICAgICAvLyBCYXNpY2FsbHksIGRlbHRhIGlzIG5vdyBwb3NpdGl2ZSBpZiB3aGVlbCB3YXMgc2Nyb2xsZWQgdXAsXG4gICAgICAgICAgLy8gYW5kIG5lZ2F0aXZlLCBpZiB3aGVlbCB3YXMgc2Nyb2xsZWQgZG93bi5cbiAgICAgICAgICBpZiAoZGVsdGEgIT09IDApIHtcblxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBuZXcgc2NhbGVcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICAgICAgdmFyIHpvb20gPSBkZWx0YSAvIDEwO1xuICAgICAgICAgICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICAgICAgICB6b29tID0gem9vbSAvICgxIC0gem9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY2FsZSAqPSAxICsgem9vbTtcblxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBwb2ludGVyIGxvY2F0aW9uXG4gICAgICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcih7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSk7XG5cbiAgICAgICAgICAgIC8vIGFwcGx5IHRoZSBuZXcgc2NhbGVcbiAgICAgICAgICAgIHRoaXMuem9vbShzY2FsZSwgcG9pbnRlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUHJldmVudCBkZWZhdWx0IGFjdGlvbnMgY2F1c2VkIGJ5IG1vdXNlIHdoZWVsLlxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBNb3VzZSBtb3ZlIGhhbmRsZXIgZm9yIGNoZWNraW5nIHdoZXRoZXIgdGhlIHRpdGxlIG1vdmVzIG92ZXIgYSBub2RlIHdpdGggYSB0aXRsZS5cbiAgICAgICAqIEBwYXJhbSAge0V2ZW50fSBldmVudFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnb25Nb3VzZU1vdmUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9KTtcbiAgICAgICAgdmFyIHBvcHVwVmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBwcmV2aW91c2x5IHNlbGVjdGVkIG5vZGUgaXMgc3RpbGwgc2VsZWN0ZWRcbiAgICAgICAgaWYgKHRoaXMucG9wdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0aGlzLnBvcHVwLmhpZGRlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrSGlkZVBvcHVwKHBvaW50ZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIHRoZSBwb3B1cCB3YXMgbm90IGhpZGRlbiBhYm92ZVxuICAgICAgICAgIGlmICh0aGlzLnBvcHVwLmhpZGRlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHBvcHVwVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnBvcHVwLnNldFBvc2l0aW9uKHBvaW50ZXIueCArIDMsIHBvaW50ZXIueSAtIDUpO1xuICAgICAgICAgICAgdGhpcy5wb3B1cC5zaG93KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UgYmluZCB0aGUga2V5Ym9hcmQgdG8gdGhlIGRpdiwgd2UgaGF2ZSB0byBoaWdobGlnaHQgaXQgdG8gdXNlIGl0LiBUaGlzIGhpZ2hsaWdodHMgaXQgb24gbW91c2Ugb3Zlci5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZXlib2FyZC5iaW5kVG9XaW5kb3cgPT09IGZhbHNlICYmIHRoaXMub3B0aW9ucy5rZXlib2FyZC5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUuZm9jdXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0YXJ0IGEgdGltZW91dCB0aGF0IHdpbGwgY2hlY2sgaWYgdGhlIG1vdXNlIGlzIHBvc2l0aW9uZWQgYWJvdmUgYW4gZWxlbWVudFxuICAgICAgICBpZiAocG9wdXBWaXNpYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgIGlmICh0aGlzLnBvcHVwVGltZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnBvcHVwVGltZXIpOyAvLyBzdG9wIGFueSBydW5uaW5nIGNhbGN1bGF0aW9uVGltZXJcbiAgICAgICAgICAgIHRoaXMucG9wdXBUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLmRyYWcuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXBUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzLl9jaGVja1Nob3dQb3B1cChwb2ludGVyKTtcbiAgICAgICAgICAgIH0sIHRoaXMub3B0aW9ucy50b29sdGlwRGVsYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIEFkZGluZyBob3ZlciBoaWdobGlnaHRzXG4gICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaG92ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAvLyBhZGRpbmcgaG92ZXIgaGlnaGxpZ2h0c1xuICAgICAgICAgIHZhciBvYmogPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0Tm9kZUF0KHBvaW50ZXIpO1xuICAgICAgICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldEVkZ2VBdChwb2ludGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmhvdmVyT2JqZWN0KG9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDaGVjayBpZiB0aGVyZSBpcyBhbiBlbGVtZW50IG9uIHRoZSBnaXZlbiBwb3NpdGlvbiBpbiB0aGUgbmV0d29ya1xuICAgICAgICogKGEgbm9kZSBvciBlZGdlKS4gSWYgc28sIGFuZCBpZiB0aGlzIGVsZW1lbnQgaGFzIGEgdGl0bGUsXG4gICAgICAgKiBzaG93IGEgcG9wdXAgd2luZG93IHdpdGggaXRzIHRpdGxlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7e3g6TnVtYmVyLCB5Ok51bWJlcn19IHBvaW50ZXJcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jaGVja1Nob3dQb3B1cCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrU2hvd1BvcHVwKHBvaW50ZXIpIHtcbiAgICAgICAgdmFyIHggPSB0aGlzLmNhbnZhcy5fWGNvbnZlcnRET010b0NhbnZhcyhwb2ludGVyLngpO1xuICAgICAgICB2YXIgeSA9IHRoaXMuY2FudmFzLl9ZY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueSk7XG4gICAgICAgIHZhciBwb2ludGVyT2JqID0ge1xuICAgICAgICAgIGxlZnQ6IHgsXG4gICAgICAgICAgdG9wOiB5LFxuICAgICAgICAgIHJpZ2h0OiB4LFxuICAgICAgICAgIGJvdHRvbTogeVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwcmV2aW91c1BvcHVwT2JqSWQgPSB0aGlzLnBvcHVwT2JqID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB0aGlzLnBvcHVwT2JqLmlkO1xuICAgICAgICB2YXIgbm9kZVVuZGVyQ3Vyc29yID0gZmFsc2U7XG4gICAgICAgIHZhciBwb3B1cFR5cGUgPSAnbm9kZSc7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgYSBub2RlIGlzIHVuZGVyIHRoZSBjdXJzb3IuXG4gICAgICAgIGlmICh0aGlzLnBvcHVwT2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBzZWFyY2ggdGhlIG5vZGVzIGZvciBvdmVybGFwLCBzZWxlY3QgdGhlIHRvcCBvbmUgaW4gY2FzZSBvZiBtdWx0aXBsZSBub2Rlc1xuICAgICAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICAgICAgdmFyIG5vZGUgPSB2b2lkIDA7XG4gICAgICAgICAgdmFyIG92ZXJsYXBwaW5nTm9kZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZXNbbm9kZUluZGljZXNbaV1dO1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaikgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUuZ2V0VGl0bGUoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmxhcHBpbmdOb2Rlcy5wdXNoKG5vZGVJbmRpY2VzW2ldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvdmVybGFwcGluZ05vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBvdmVybGFwcGluZyBub2Rlcywgc2VsZWN0IHRoZSBsYXN0IG9uZSwgdGhpcyBpcyB0aGUgb25lIHdoaWNoIGlzIGRyYXduIG9uIHRvcCBvZiB0aGUgb3RoZXJzXG4gICAgICAgICAgICB0aGlzLnBvcHVwT2JqID0gbm9kZXNbb3ZlcmxhcHBpbmdOb2Rlc1tvdmVybGFwcGluZ05vZGVzLmxlbmd0aCAtIDFdXTtcbiAgICAgICAgICAgIC8vIGlmIHlvdSBob3ZlciBvdmVyIGEgbm9kZSwgdGhlIHRpdGxlIG9mIHRoZSBlZGdlIGlzIG5vdCBzdXBwb3NlZCB0byBiZSBzaG93bi5cbiAgICAgICAgICAgIG5vZGVVbmRlckN1cnNvciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucG9wdXBPYmogPT09IHVuZGVmaW5lZCAmJiBub2RlVW5kZXJDdXJzb3IgPT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gc2VhcmNoIHRoZSBlZGdlcyBmb3Igb3ZlcmxhcFxuICAgICAgICAgIHZhciBlZGdlSW5kaWNlcyA9IHRoaXMuYm9keS5lZGdlSW5kaWNlcztcbiAgICAgICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICAgICAgdmFyIGVkZ2UgPSB2b2lkIDA7XG4gICAgICAgICAgdmFyIG92ZXJsYXBwaW5nRWRnZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBlZGdlSW5kaWNlcy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgICAgICBlZGdlID0gZWRnZXNbZWRnZUluZGljZXNbX2k0XV07XG4gICAgICAgICAgICBpZiAoZWRnZS5pc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBpZiAoZWRnZS5jb25uZWN0ZWQgPT09IHRydWUgJiYgZWRnZS5nZXRUaXRsZSgpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvdmVybGFwcGluZ0VkZ2VzLnB1c2goZWRnZUluZGljZXNbX2k0XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3ZlcmxhcHBpbmdFZGdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVwT2JqID0gZWRnZXNbb3ZlcmxhcHBpbmdFZGdlc1tvdmVybGFwcGluZ0VkZ2VzLmxlbmd0aCAtIDFdXTtcbiAgICAgICAgICAgIHBvcHVwVHlwZSA9ICdlZGdlJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wb3B1cE9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gc2hvdyBwb3B1cCBtZXNzYWdlIHdpbmRvd1xuICAgICAgICAgIGlmICh0aGlzLnBvcHVwT2JqLmlkICE9PSBwcmV2aW91c1BvcHVwT2JqSWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcHVwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5wb3B1cCA9IG5ldyBfUG9wdXAyLmRlZmF1bHQodGhpcy5jYW52YXMuZnJhbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0VHlwZSA9IHBvcHVwVHlwZTtcbiAgICAgICAgICAgIHRoaXMucG9wdXAucG9wdXBUYXJnZXRJZCA9IHRoaXMucG9wdXBPYmouaWQ7XG5cbiAgICAgICAgICAgIC8vIGFkanVzdCBhIHNtYWxsIG9mZnNldCBzdWNoIHRoYXQgdGhlIG1vdXNlIGN1cnNvciBpcyBsb2NhdGVkIGluIHRoZVxuICAgICAgICAgICAgLy8gYm90dG9tIGxlZnQgbG9jYXRpb24gb2YgdGhlIHBvcHVwLCBhbmQgeW91IGNhbiBlYXNpbHkgbW92ZSBvdmVyIHRoZVxuICAgICAgICAgICAgLy8gcG9wdXAgYXJlYVxuICAgICAgICAgICAgdGhpcy5wb3B1cC5zZXRQb3NpdGlvbihwb2ludGVyLnggKyAzLCBwb2ludGVyLnkgLSA1KTtcbiAgICAgICAgICAgIHRoaXMucG9wdXAuc2V0VGV4dCh0aGlzLnBvcHVwT2JqLmdldFRpdGxlKCkpO1xuICAgICAgICAgICAgdGhpcy5wb3B1cC5zaG93KCk7XG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzaG93UG9wdXAnLCB0aGlzLnBvcHVwT2JqLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMucG9wdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wb3B1cC5oaWRlKCk7XG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdoaWRlUG9wdXAnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDaGVjayBpZiB0aGUgcG9wdXAgbXVzdCBiZSBoaWRkZW4sIHdoaWNoIGlzIHRoZSBjYXNlIHdoZW4gdGhlIG1vdXNlIGlzIG5vXG4gICAgICAgKiBsb25nZXIgaG92ZXJpbmcgb24gdGhlIG9iamVjdFxuICAgICAgICogQHBhcmFtIHt7eDpOdW1iZXIsIHk6TnVtYmVyfX0gcG9pbnRlclxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NoZWNrSGlkZVBvcHVwJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tIaWRlUG9wdXAocG9pbnRlcikge1xuICAgICAgICB2YXIgcG9pbnRlck9iaiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fcG9pbnRlclRvUG9zaXRpb25PYmplY3QocG9pbnRlcik7XG5cbiAgICAgICAgdmFyIHN0aWxsT25PYmogPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMucG9wdXAucG9wdXBUYXJnZXRUeXBlID09PSAnbm9kZScpIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW3RoaXMucG9wdXAucG9wdXBUYXJnZXRJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RpbGxPbk9iaiA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWRdLmlzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgbW91c2UgaXMgc3RpbGwgb25lIHRoZSBub2RlLCB3ZSBoYXZlIHRvIGNoZWNrIGlmIGl0IGlzIG5vdCBhbHNvIG9uIG9uZSB0aGF0IGlzIGRyYXduIG9uIHRvcCBvZiBpdC5cbiAgICAgICAgICAgIC8vIHdlIGluaXRpYWxseSBvbmx5IGNoZWNrIHN0aWxsT25PYmogYmVjYXVzZSB0aGlzIGlzIG11Y2ggZmFzdGVyLlxuICAgICAgICAgICAgaWYgKHN0aWxsT25PYmogPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdmFyIG92ZXJOb2RlID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdChwb2ludGVyKTtcbiAgICAgICAgICAgICAgc3RpbGxPbk9iaiA9IG92ZXJOb2RlLmlkID09PSB0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0Tm9kZUF0KHBvaW50ZXIpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkuZWRnZXNbdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHN0aWxsT25PYmogPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkXS5pc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RpbGxPbk9iaiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLnBvcHVwT2JqID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHRoaXMucG9wdXAuaGlkZSgpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2hpZGVQb3B1cCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEludGVyYWN0aW9uSGFuZGxlcjtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IEludGVyYWN0aW9uSGFuZGxlcjtcblxuLyoqKi8gfSxcbi8qIDExMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBIYW1tZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcbiAgdmFyIGhhbW1lclV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcbiAgdmFyIGtleWNoYXJtID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cbiAgdmFyIE5hdmlnYXRpb25IYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5hdmlnYXRpb25IYW5kbGVyKGJvZHksIGNhbnZhcykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5hdmlnYXRpb25IYW5kbGVyKTtcblxuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuXG4gICAgICB0aGlzLmljb25zQ3JlYXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5uYXZpZ2F0aW9uSGFtbWVycyA9IFtdO1xuICAgICAgdGhpcy5ib3VuZEZ1bmN0aW9ucyA9IHt9O1xuICAgICAgdGhpcy50b3VjaFRpbWUgPSAwO1xuICAgICAgdGhpcy5hY3RpdmF0ZWQgPSBmYWxzZTtcblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJhY3RpdmF0ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmFjdGl2YXRlZCA9IHRydWU7X3RoaXMuY29uZmlndXJlS2V5Ym9hcmRCaW5kaW5ncygpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlYWN0aXZhdGVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5hY3RpdmF0ZWQgPSBmYWxzZTtfdGhpcy5jb25maWd1cmVLZXlib2FyZEJpbmRpbmdzKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVzdHJveVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5rZXljaGFybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgX3RoaXMua2V5Y2hhcm0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKE5hdmlnYXRpb25IYW5kbGVyLCBbe1xuICAgICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgIHRoaXMuY3JlYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjcmVhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5uYXZpZ2F0aW9uQnV0dG9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmICh0aGlzLmljb25zQ3JlYXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZE5hdmlnYXRpb25FbGVtZW50cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmljb25zQ3JlYXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuY2xlYW5OYXZpZ2F0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbmZpZ3VyZUtleWJvYXJkQmluZGluZ3MoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjbGVhbk5hdmlnYXRpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFuTmF2aWdhdGlvbigpIHtcbiAgICAgICAgLy8gY2xlYW4gaGFtbWVyIGJpbmRpbmdzXG4gICAgICAgIGlmICh0aGlzLm5hdmlnYXRpb25IYW1tZXJzLmxlbmd0aCAhPSAwKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5hdmlnYXRpb25IYW1tZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25IYW1tZXJzW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uSGFtbWVycyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYW4gdXAgcHJldmlvdXMgbmF2aWdhdGlvbiBpdGVtc1xuICAgICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uRE9NICYmIHRoaXMubmF2aWdhdGlvbkRPTVsnd3JhcHBlciddICYmIHRoaXMubmF2aWdhdGlvbkRPTVsnd3JhcHBlciddLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICB0aGlzLm5hdmlnYXRpb25ET01bJ3dyYXBwZXInXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMubmF2aWdhdGlvbkRPTVsnd3JhcHBlciddKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaWNvbnNDcmVhdGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRpb24gb2YgdGhlIG5hdmlnYXRpb24gY29udHJvbHMgbm9kZXMuIFRoZXkgYXJlIGRyYXduIG92ZXIgdGhlIHJlc3Qgb2YgdGhlIG5vZGVzIGFuZCBhcmUgbm90IGFmZmVjdGVkIGJ5IHNjYWxlIGFuZCB0cmFuc2xhdGlvblxuICAgICAgICogdGhleSBoYXZlIGEgdHJpZ2dlckZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBvbiBjbGljay4gSWYgdGhlIHBvc2l0aW9uIG9mIHRoZSBuYXZpZ2F0aW9uIGNvbnRyb2xzIGlzIGRlcGVuZGVudFxuICAgICAgICogb24gdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGggb3IgdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0LCB3ZSBmbGFnIGhvcml6b250YWxBbGlnbkxlZnQgYW5kIHZlcnRpY2FsQWxpZ25Ub3AgZmFsc2UuXG4gICAgICAgKiBUaGlzIG1lYW5zIHRoYXQgdGhlIGxvY2F0aW9uIHdpbGwgYmUgY29ycmVjdGVkIGJ5IHRoZSBfcmVsb2NhdGVOYXZpZ2F0aW9uIGZ1bmN0aW9uIG9uIGEgc2l6ZSBjaGFuZ2Ugb2YgdGhlIGNhbnZhcy5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdsb2FkTmF2aWdhdGlvbkVsZW1lbnRzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkTmF2aWdhdGlvbkVsZW1lbnRzKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB0aGlzLmNsZWFuTmF2aWdhdGlvbigpO1xuXG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkRPTSA9IHt9O1xuICAgICAgICB2YXIgbmF2aWdhdGlvbkRpdnMgPSBbJ3VwJywgJ2Rvd24nLCAnbGVmdCcsICdyaWdodCcsICd6b29tSW4nLCAnem9vbU91dCcsICd6b29tRXh0ZW5kcyddO1xuICAgICAgICB2YXIgbmF2aWdhdGlvbkRpdkFjdGlvbnMgPSBbJ19tb3ZlVXAnLCAnX21vdmVEb3duJywgJ19tb3ZlTGVmdCcsICdfbW92ZVJpZ2h0JywgJ196b29tSW4nLCAnX3pvb21PdXQnLCAnX2ZpdCddO1xuXG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkRPTVsnd3JhcHBlciddID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkRPTVsnd3JhcHBlciddLmNsYXNzTmFtZSA9ICd2aXMtbmF2aWdhdGlvbic7XG4gICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMubmF2aWdhdGlvbkRPTVsnd3JhcHBlciddKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hdmlnYXRpb25EaXZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NW25hdmlnYXRpb25EaXZzW2ldXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHRoaXMubmF2aWdhdGlvbkRPTVtuYXZpZ2F0aW9uRGl2c1tpXV0uY2xhc3NOYW1lID0gJ3Zpcy1idXR0b24gdmlzLScgKyBuYXZpZ2F0aW9uRGl2c1tpXTtcbiAgICAgICAgICB0aGlzLm5hdmlnYXRpb25ET01bJ3dyYXBwZXInXS5hcHBlbmRDaGlsZCh0aGlzLm5hdmlnYXRpb25ET01bbmF2aWdhdGlvbkRpdnNbaV1dKTtcblxuICAgICAgICAgIHZhciBoYW1tZXIgPSBuZXcgSGFtbWVyKHRoaXMubmF2aWdhdGlvbkRPTVtuYXZpZ2F0aW9uRGl2c1tpXV0pO1xuICAgICAgICAgIGlmIChuYXZpZ2F0aW9uRGl2QWN0aW9uc1tpXSA9PT0gXCJfZml0XCIpIHtcbiAgICAgICAgICAgIGhhbW1lclV0aWwub25Ub3VjaChoYW1tZXIsIHRoaXMuX2ZpdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFtbWVyVXRpbC5vblRvdWNoKGhhbW1lciwgdGhpcy5iaW5kVG9SZWRyYXcuYmluZCh0aGlzLCBuYXZpZ2F0aW9uRGl2QWN0aW9uc1tpXSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubmF2aWdhdGlvbkhhbW1lcnMucHVzaChoYW1tZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXNlIGEgaGFtbWVyIGZvciB0aGUgcmVsZWFzZSBzbyB3ZSBkbyBub3QgcmVxdWlyZSB0aGUgb25lIHVzZWQgaW4gdGhlIHJlc3Qgb2YgdGhlIG5ldHdvcmtcbiAgICAgICAgLy8gdGhlIG9uZSB0aGUgcmVzdCB1c2VzIGNhbiBiZSBvdmVybG9hZGVkIGJ5IHRoZSBtYW5pcHVsYXRpb24gc3lzdGVtLlxuICAgICAgICB2YXIgaGFtbWVyRnJhbWUgPSBuZXcgSGFtbWVyKHRoaXMuY2FudmFzLmZyYW1lKTtcbiAgICAgICAgaGFtbWVyVXRpbC5vblJlbGVhc2UoaGFtbWVyRnJhbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIuX3N0b3BNb3ZlbWVudCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uSGFtbWVycy5wdXNoKGhhbW1lckZyYW1lKTtcblxuICAgICAgICB0aGlzLmljb25zQ3JlYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnYmluZFRvUmVkcmF3JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kVG9SZWRyYXcoYWN0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmJvdW5kRnVuY3Rpb25zW2FjdGlvbl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuYm91bmRGdW5jdGlvbnNbYWN0aW9uXSA9IHRoaXNbYWN0aW9uXS5iaW5kKHRoaXMpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiaW5pdFJlZHJhd1wiLCB0aGlzLmJvdW5kRnVuY3Rpb25zW2FjdGlvbl0pO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfc3RhcnRSZW5kZXJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1bmJpbmRGcm9tUmVkcmF3JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJpbmRGcm9tUmVkcmF3KGFjdGlvbikge1xuICAgICAgICBpZiAodGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vZmYoXCJpbml0UmVkcmF3XCIsIHRoaXMuYm91bmRGdW5jdGlvbnNbYWN0aW9uXSk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9zdG9wUmVuZGVyaW5nXCIpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmJvdW5kRnVuY3Rpb25zW2FjdGlvbl07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB0aGlzIHN0b3BzIGFsbCBtb3ZlbWVudCBpbmR1Y2VkIGJ5IHRoZSBuYXZpZ2F0aW9uIGJ1dHRvbnNcbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZml0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZml0KCkge1xuICAgICAgICBpZiAobmV3IERhdGUoKS52YWx1ZU9mKCkgLSB0aGlzLnRvdWNoVGltZSA+IDcwMCkge1xuICAgICAgICAgIC8vIFRPRE86IGZpeCB1Z2x5IGhhY2sgdG8gYXZvaWQgaGFtbWVyJ3MgZG91YmxlIGZpcmVpbmcgb2YgZXZlbnQgKGJlY2F1c2Ugd2UgdXNlIHJlbGVhc2U/KVxuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJmaXRcIiwgeyBkdXJhdGlvbjogNzAwIH0pO1xuICAgICAgICAgIHRoaXMudG91Y2hUaW1lID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB0aGlzIHN0b3BzIGFsbCBtb3ZlbWVudCBpbmR1Y2VkIGJ5IHRoZSBuYXZpZ2F0aW9uIGJ1dHRvbnNcbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc3RvcE1vdmVtZW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RvcE1vdmVtZW50KCkge1xuICAgICAgICBmb3IgKHZhciBib3VuZEFjdGlvbiBpbiB0aGlzLmJvdW5kRnVuY3Rpb25zKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYm91bmRGdW5jdGlvbnMuaGFzT3duUHJvcGVydHkoYm91bmRBY3Rpb24pKSB7XG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vZmYoXCJpbml0UmVkcmF3XCIsIHRoaXMuYm91bmRGdW5jdGlvbnNbYm91bmRBY3Rpb25dKTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfc3RvcFJlbmRlcmluZ1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib3VuZEZ1bmN0aW9ucyA9IHt9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19tb3ZlVXAnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlVXAoKSB7XG4gICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkgKz0gdGhpcy5vcHRpb25zLmtleWJvYXJkLnNwZWVkLnk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX21vdmVEb3duJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZURvd24oKSB7XG4gICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkgLT0gdGhpcy5vcHRpb25zLmtleWJvYXJkLnNwZWVkLnk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX21vdmVMZWZ0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZUxlZnQoKSB7XG4gICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnggKz0gdGhpcy5vcHRpb25zLmtleWJvYXJkLnNwZWVkLng7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX21vdmVSaWdodCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVSaWdodCgpIHtcbiAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCAtPSB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQueDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfem9vbUluJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfem9vbUluKCkge1xuICAgICAgICB2YXIgc2NhbGVPbGQgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5ib2R5LnZpZXcuc2NhbGUgKiAoMSArIHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC56b29tKTtcbiAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb247XG4gICAgICAgIHZhciBzY2FsZUZyYWMgPSBzY2FsZSAvIHNjYWxlT2xkO1xuICAgICAgICB2YXIgdHggPSAoMSAtIHNjYWxlRnJhYykgKiB0aGlzLmNhbnZhcy5jYW52YXNWaWV3Q2VudGVyLnggKyB0cmFuc2xhdGlvbi54ICogc2NhbGVGcmFjO1xuICAgICAgICB2YXIgdHkgPSAoMSAtIHNjYWxlRnJhYykgKiB0aGlzLmNhbnZhcy5jYW52YXNWaWV3Q2VudGVyLnkgKyB0cmFuc2xhdGlvbi55ICogc2NhbGVGcmFjO1xuXG4gICAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gc2NhbGU7XG4gICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0geyB4OiB0eCwgeTogdHkgfTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnem9vbScsIHsgZGlyZWN0aW9uOiAnKycsIHNjYWxlOiB0aGlzLmJvZHkudmlldy5zY2FsZSB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfem9vbU91dCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3pvb21PdXQoKSB7XG4gICAgICAgIHZhciBzY2FsZU9sZCA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZSAvICgxICsgdGhpcy5vcHRpb25zLmtleWJvYXJkLnNwZWVkLnpvb20pO1xuICAgICAgICB2YXIgdHJhbnNsYXRpb24gPSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbjtcbiAgICAgICAgdmFyIHNjYWxlRnJhYyA9IHNjYWxlIC8gc2NhbGVPbGQ7XG4gICAgICAgIHZhciB0eCA9ICgxIC0gc2NhbGVGcmFjKSAqIHRoaXMuY2FudmFzLmNhbnZhc1ZpZXdDZW50ZXIueCArIHRyYW5zbGF0aW9uLnggKiBzY2FsZUZyYWM7XG4gICAgICAgIHZhciB0eSA9ICgxIC0gc2NhbGVGcmFjKSAqIHRoaXMuY2FudmFzLmNhbnZhc1ZpZXdDZW50ZXIueSArIHRyYW5zbGF0aW9uLnkgKiBzY2FsZUZyYWM7XG5cbiAgICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7IHg6IHR4LCB5OiB0eSB9O1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCd6b29tJywgeyBkaXJlY3Rpb246ICctJywgc2NhbGU6IHRoaXMuYm9keS52aWV3LnNjYWxlIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGJpbmQgYWxsIGtleXMgdXNpbmcga2V5Y2hhcm0uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NvbmZpZ3VyZUtleWJvYXJkQmluZGluZ3MnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbmZpZ3VyZUtleWJvYXJkQmluZGluZ3MoKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLmtleWNoYXJtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmtleWNoYXJtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2V5Ym9hcmQuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2V5Ym9hcmQuYmluZFRvV2luZG93ID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmtleWNoYXJtID0ga2V5Y2hhcm0oeyBjb250YWluZXI6IHdpbmRvdywgcHJldmVudERlZmF1bHQ6IHRydWUgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMua2V5Y2hhcm0gPSBrZXljaGFybSh7IGNvbnRhaW5lcjogdGhpcy5jYW52YXMuZnJhbWUsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMua2V5Y2hhcm0ucmVzZXQoKTtcblxuICAgICAgICAgIGlmICh0aGlzLmFjdGl2YXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwidXBcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX21vdmVVcFwiKTtcbiAgICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcbiAgICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZChcImRvd25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX21vdmVEb3duXCIpO1xuICAgICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwibGVmdFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfbW92ZUxlZnRcIik7XG4gICAgICAgICAgICB9LCBcImtleWRvd25cIik7XG4gICAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoXCJyaWdodFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfbW92ZVJpZ2h0XCIpO1xuICAgICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwiPVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwibnVtK1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwibnVtLVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbU91dFwiKTtcbiAgICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcbiAgICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZChcIi1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX3pvb21PdXRcIik7XG4gICAgICAgICAgICB9LCBcImtleWRvd25cIik7XG4gICAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoXCJbXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwiXVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwicGFnZXVwXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl96b29tSW5cIik7XG4gICAgICAgICAgICB9LCBcImtleWRvd25cIik7XG4gICAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoXCJwYWdlZG93blwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbU91dFwiKTtcbiAgICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcblxuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwidXBcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl9tb3ZlVXBcIik7XG4gICAgICAgICAgICB9LCBcImtleXVwXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwiZG93blwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX21vdmVEb3duXCIpO1xuICAgICAgICAgICAgfSwgXCJrZXl1cFwiKTtcbiAgICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZChcImxlZnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl9tb3ZlTGVmdFwiKTtcbiAgICAgICAgICAgIH0sIFwia2V5dXBcIik7XG4gICAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoXCJyaWdodFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX21vdmVSaWdodFwiKTtcbiAgICAgICAgICAgIH0sIFwia2V5dXBcIik7XG4gICAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoXCI9XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgICAgfSwgXCJrZXl1cFwiKTtcbiAgICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZChcIm51bStcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tSW5cIik7XG4gICAgICAgICAgICB9LCBcImtleXVwXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwibnVtLVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21PdXRcIik7XG4gICAgICAgICAgICB9LCBcImtleXVwXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwiLVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21PdXRcIik7XG4gICAgICAgICAgICB9LCBcImtleXVwXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwiW1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21PdXRcIik7XG4gICAgICAgICAgICB9LCBcImtleXVwXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwiXVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21JblwiKTtcbiAgICAgICAgICAgIH0sIFwia2V5dXBcIik7XG4gICAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoXCJwYWdldXBcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tSW5cIik7XG4gICAgICAgICAgICB9LCBcImtleXVwXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwicGFnZWRvd25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgICAgfSwgXCJrZXl1cFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTmF2aWdhdGlvbkhhbmRsZXI7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBOYXZpZ2F0aW9uSGFuZGxlcjtcblxuLyoqKi8gfSxcbi8qIDExMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICAvKipcbiAgICogUG9wdXAgaXMgYSBjbGFzcyB0byBjcmVhdGUgYSBwb3B1cCB3aW5kb3cgd2l0aCBzb21lIHRleHRcbiAgICogQHBhcmFtIHtFbGVtZW50fSAgY29udGFpbmVyICAgICBUaGUgY29udGFpbmVyIG9iamVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt4XVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3ldXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdGV4dF1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZV0gICAgIEFuIG9iamVjdCBjb250YWluaW5nIGJvcmRlckNvbG9yLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yLCBldGMuXG4gICAqL1xuICB2YXIgUG9wdXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUG9wdXAoY29udGFpbmVyKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wdXApO1xuXG4gICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuICAgICAgdGhpcy54ID0gMDtcbiAgICAgIHRoaXMueSA9IDA7XG4gICAgICB0aGlzLnBhZGRpbmcgPSA1O1xuICAgICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcblxuICAgICAgLy8gY3JlYXRlIHRoZSBmcmFtZVxuICAgICAgdGhpcy5mcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5mcmFtZS5jbGFzc05hbWUgPSAndmlzLW5ldHdvcmstdG9vbHRpcCc7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAgIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIHBvcHVwIHdpbmRvd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5ICAgVmVydGljYWwgcG9zaXRpb24gb2YgdGhlIHBvcHVwIHdpbmRvd1xuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoUG9wdXAsIFt7XG4gICAgICBrZXk6ICdzZXRQb3NpdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UG9zaXRpb24oeCwgeSkge1xuICAgICAgICB0aGlzLnggPSBwYXJzZUludCh4KTtcbiAgICAgICAgdGhpcy55ID0gcGFyc2VJbnQoeSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHRoZSBjb250ZW50IGZvciB0aGUgcG9wdXAgd2luZG93LiBUaGlzIGNhbiBiZSBIVE1MIGNvZGUgb3IgdGV4dC5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgRWxlbWVudH0gY29udGVudFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRUZXh0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUZXh0KGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy5mcmFtZS5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZnJhbWUuaW5uZXJIVE1MID0gY29udGVudDsgLy8gc3RyaW5nIGNvbnRhaW5pbmcgdGV4dCBvciBIVE1MXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTaG93IHRoZSBwb3B1cCB3aW5kb3dcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RvU2hvd10gICAgU2hvdyBvciBoaWRlIHRoZSB3aW5kb3dcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2hvdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdyhkb1Nob3cpIHtcbiAgICAgICAgaWYgKGRvU2hvdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZG9TaG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb1Nob3cgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5mcmFtZS5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5mcmFtZS5jbGllbnRXaWR0aDtcbiAgICAgICAgICB2YXIgbWF4SGVpZ2h0ID0gdGhpcy5mcmFtZS5wYXJlbnROb2RlLmNsaWVudEhlaWdodDtcbiAgICAgICAgICB2YXIgbWF4V2lkdGggPSB0aGlzLmZyYW1lLnBhcmVudE5vZGUuY2xpZW50V2lkdGg7XG5cbiAgICAgICAgICB2YXIgdG9wID0gdGhpcy55IC0gaGVpZ2h0O1xuICAgICAgICAgIGlmICh0b3AgKyBoZWlnaHQgKyB0aGlzLnBhZGRpbmcgPiBtYXhIZWlnaHQpIHtcbiAgICAgICAgICAgIHRvcCA9IG1heEhlaWdodCAtIGhlaWdodCAtIHRoaXMucGFkZGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRvcCA8IHRoaXMucGFkZGluZykge1xuICAgICAgICAgICAgdG9wID0gdGhpcy5wYWRkaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy54O1xuICAgICAgICAgIGlmIChsZWZ0ICsgd2lkdGggKyB0aGlzLnBhZGRpbmcgPiBtYXhXaWR0aCkge1xuICAgICAgICAgICAgbGVmdCA9IG1heFdpZHRoIC0gd2lkdGggLSB0aGlzLnBhZGRpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsZWZ0IDwgdGhpcy5wYWRkaW5nKSB7XG4gICAgICAgICAgICBsZWZ0ID0gdGhpcy5wYWRkaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZnJhbWUuc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XG4gICAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG4gICAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG4gICAgICAgICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhpZGUgdGhlIHBvcHVwIHdpbmRvd1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdoaWRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgICB0aGlzLmhpZGRlbiA9IHRydWU7XG4gICAgICAgIHRoaXMuZnJhbWUuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFBvcHVwO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gUG9wdXA7XG5cbi8qKiovIH0sXG4vKiAxMTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjcpO1xuXG4gIHZhciBfTm9kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Ob2RlKTtcblxuICB2YXIgX0VkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg3KTtcblxuICB2YXIgX0VkZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRWRnZSk7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICB2YXIgU2VsZWN0aW9uSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWxlY3Rpb25IYW5kbGVyKGJvZHksIGNhbnZhcykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlbGVjdGlvbkhhbmRsZXIpO1xuXG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgICB0aGlzLnNlbGVjdGlvbk9iaiA9IHsgbm9kZXM6IFtdLCBlZGdlczogW10gfTtcbiAgICAgIHRoaXMuaG92ZXJPYmogPSB7IG5vZGVzOiB7fSwgZWRnZXM6IHt9IH07XG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgbXVsdGlzZWxlY3Q6IGZhbHNlLFxuICAgICAgICBzZWxlY3RhYmxlOiB0cnVlLFxuICAgICAgICBzZWxlY3RDb25uZWN0ZWRFZGdlczogdHJ1ZSxcbiAgICAgICAgaG92ZXJDb25uZWN0ZWRFZGdlczogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFDaGFuZ2VkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMudXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU2VsZWN0aW9uSGFuZGxlciwgW3tcbiAgICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGZpZWxkcyA9IFsnbXVsdGlzZWxlY3QnLCAnaG92ZXJDb25uZWN0ZWRFZGdlcycsICdzZWxlY3RhYmxlJywgJ3NlbGVjdENvbm5lY3RlZEVkZ2VzJ107XG4gICAgICAgICAgdXRpbC5zZWxlY3RpdmVEZWVwRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGhhbmRsZXMgdGhlIHNlbGVjdGlvbiBwYXJ0IG9mIHRoZSB0YXA7XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NlbGVjdE9uUG9pbnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdE9uUG9pbnQocG9pbnRlcikge1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zZWxlY3RhYmxlID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIG9iaiA9IHRoaXMuZ2V0Tm9kZUF0KHBvaW50ZXIpIHx8IHRoaXMuZ2V0RWRnZUF0KHBvaW50ZXIpO1xuXG4gICAgICAgICAgLy8gdW5zZWxlY3QgYWZ0ZXIgZ2V0dGluZyB0aGUgb2JqZWN0cyBpbiBvcmRlciB0byByZXN0b3JlIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICAgICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuXG4gICAgICAgICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0T2JqZWN0KG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnc2VsZWN0QWRkaXRpb25hbE9uUG9pbnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdEFkZGl0aW9uYWxPblBvaW50KHBvaW50ZXIpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zZWxlY3RhYmxlID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIG9iaiA9IHRoaXMuZ2V0Tm9kZUF0KHBvaW50ZXIpIHx8IHRoaXMuZ2V0RWRnZUF0KHBvaW50ZXIpO1xuXG4gICAgICAgICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChvYmouaXNTZWxlY3RlZCgpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGVzZWxlY3RPYmplY3Qob2JqKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuc2VsZWN0T2JqZWN0KG9iaik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbkNoYW5nZWQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2dlbmVyYXRlQ2xpY2tFdmVudCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dlbmVyYXRlQ2xpY2tFdmVudChldmVudFR5cGUsIGV2ZW50LCBwb2ludGVyLCBvbGRTZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGVtcHR5U2VsZWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGVtcHR5U2VsZWN0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgcHJvcGVydGllcyA9IHsgbm9kZXM6IFtdLCBlZGdlczogW10gfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wZXJ0aWVzWydwb2ludGVyJ10gPSB7XG4gICAgICAgICAgRE9NOiB7IHg6IHBvaW50ZXIueCwgeTogcG9pbnRlci55IH0sXG4gICAgICAgICAgY2FudmFzOiB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyhwb2ludGVyKVxuICAgICAgICB9O1xuICAgICAgICBwcm9wZXJ0aWVzWydldmVudCddID0gZXZlbnQ7XG5cbiAgICAgICAgaWYgKG9sZFNlbGVjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcGVydGllc1sncHJldmlvdXNTZWxlY3Rpb24nXSA9IG9sZFNlbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KGV2ZW50VHlwZSwgcHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnc2VsZWN0T2JqZWN0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RPYmplY3Qob2JqKSB7XG4gICAgICAgIHZhciBoaWdobGlnaHRFZGdlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5vcHRpb25zLnNlbGVjdENvbm5lY3RlZEVkZ2VzO1xuXG4gICAgICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBfTm9kZTIuZGVmYXVsdCkge1xuICAgICAgICAgICAgaWYgKGhpZ2hsaWdodEVkZ2VzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3NlbGVjdENvbm5lY3RlZEVkZ2VzKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iai5zZWxlY3QoKTtcbiAgICAgICAgICB0aGlzLl9hZGRUb1NlbGVjdGlvbihvYmopO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkZXNlbGVjdE9iamVjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzZWxlY3RPYmplY3Qob2JqKSB7XG4gICAgICAgIGlmIChvYmouaXNTZWxlY3RlZCgpID09PSB0cnVlKSB7XG4gICAgICAgICAgb2JqLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlRnJvbVNlbGVjdGlvbihvYmopO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogcmV0cmlldmUgYWxsIG5vZGVzIG92ZXJsYXBwaW5nIHdpdGggZ2l2ZW4gb2JqZWN0XG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0ICBBbiBvYmplY3Qgd2l0aCBwYXJhbWV0ZXJzIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbVxuICAgICAgICogQHJldHVybiB7TnVtYmVyW119ICAgQW4gYXJyYXkgd2l0aCBpZCdzIG9mIHRoZSBvdmVybGFwcGluZyBub2Rlc1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QWxsTm9kZXNPdmVybGFwcGluZ1dpdGgob2JqZWN0KSB7XG4gICAgICAgIHZhciBvdmVybGFwcGluZ05vZGVzID0gW107XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZUlkID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldO1xuICAgICAgICAgIGlmIChub2Rlc1tub2RlSWRdLmlzT3ZlcmxhcHBpbmdXaXRoKG9iamVjdCkpIHtcbiAgICAgICAgICAgIG92ZXJsYXBwaW5nTm9kZXMucHVzaChub2RlSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3ZlcmxhcHBpbmdOb2RlcztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm4gYSBwb3NpdGlvbiBvYmplY3QgaW4gY2FudmFzc3BhY2UgZnJvbSBhIHNpbmdsZSBwb2ludCBpbiBzY3JlZW5zcGFjZVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBwb2ludGVyXG4gICAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyfX1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19wb2ludGVyVG9Qb3NpdGlvbk9iamVjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpIHtcbiAgICAgICAgdmFyIGNhbnZhc1BvcyA9IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHBvaW50ZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxlZnQ6IGNhbnZhc1Bvcy54IC0gMSxcbiAgICAgICAgICB0b3A6IGNhbnZhc1Bvcy55ICsgMSxcbiAgICAgICAgICByaWdodDogY2FudmFzUG9zLnggKyAxLFxuICAgICAgICAgIGJvdHRvbTogY2FudmFzUG9zLnkgLSAxXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHRoZSB0b3Agbm9kZSBhdCB0aGUgYSBzcGVjaWZpYyBwb2ludCAobGlrZSBhIGNsaWNrKVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7e3g6IE51bWJlciwgeTogTnVtYmVyfX0gcG9pbnRlclxuICAgICAgICogQHJldHVybiB7Tm9kZSB8IHVuZGVmaW5lZH0gbm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXROb2RlQXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vZGVBdChwb2ludGVyKSB7XG4gICAgICAgIHZhciByZXR1cm5Ob2RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICAgIC8vIHdlIGZpcnN0IGNoZWNrIGlmIHRoaXMgaXMgYW4gbmF2aWdhdGlvbiBjb250cm9scyBlbGVtZW50XG4gICAgICAgIHZhciBwb3NpdGlvbk9iamVjdCA9IHRoaXMuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpO1xuICAgICAgICB2YXIgb3ZlcmxhcHBpbmdOb2RlcyA9IHRoaXMuX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoKHBvc2l0aW9uT2JqZWN0KTtcbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG92ZXJsYXBwaW5nIG5vZGVzLCBzZWxlY3QgdGhlIGxhc3Qgb25lLCB0aGlzIGlzIHRoZVxuICAgICAgICAvLyBvbmUgd2hpY2ggaXMgZHJhd24gb24gdG9wIG9mIHRoZSBvdGhlcnNcbiAgICAgICAgaWYgKG92ZXJsYXBwaW5nTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmIChyZXR1cm5Ob2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm5vZGVzW292ZXJsYXBwaW5nTm9kZXNbb3ZlcmxhcHBpbmdOb2Rlcy5sZW5ndGggLSAxXV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvdmVybGFwcGluZ05vZGVzW292ZXJsYXBwaW5nTm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiByZXRyaWV2ZSBhbGwgZWRnZXMgb3ZlcmxhcHBpbmcgd2l0aCBnaXZlbiBvYmplY3QsIHNlbGVjdG9yIGlzIGFyb3VuZCBjZW50ZXJcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgIEFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tXG4gICAgICAgKiBAcmV0dXJuIHtOdW1iZXJbXX0gICBBbiBhcnJheSB3aXRoIGlkJ3Mgb2YgdGhlIG92ZXJsYXBwaW5nIG5vZGVzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0RWRnZXNPdmVybGFwcGluZ1dpdGgnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRFZGdlc092ZXJsYXBwaW5nV2l0aChvYmplY3QsIG92ZXJsYXBwaW5nRWRnZXMpIHtcbiAgICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5lZGdlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlZGdlSWQgPSB0aGlzLmJvZHkuZWRnZUluZGljZXNbaV07XG4gICAgICAgICAgaWYgKGVkZ2VzW2VkZ2VJZF0uaXNPdmVybGFwcGluZ1dpdGgob2JqZWN0KSkge1xuICAgICAgICAgICAgb3ZlcmxhcHBpbmdFZGdlcy5wdXNoKGVkZ2VJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogcmV0cmlldmUgYWxsIG5vZGVzIG92ZXJsYXBwaW5nIHdpdGggZ2l2ZW4gb2JqZWN0XG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0ICBBbiBvYmplY3Qgd2l0aCBwYXJhbWV0ZXJzIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbVxuICAgICAgICogQHJldHVybiB7TnVtYmVyW119ICAgQW4gYXJyYXkgd2l0aCBpZCdzIG9mIHRoZSBvdmVybGFwcGluZyBub2Rlc1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldEFsbEVkZ2VzT3ZlcmxhcHBpbmdXaXRoJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QWxsRWRnZXNPdmVybGFwcGluZ1dpdGgob2JqZWN0KSB7XG4gICAgICAgIHZhciBvdmVybGFwcGluZ0VkZ2VzID0gW107XG4gICAgICAgIHRoaXMuX2dldEVkZ2VzT3ZlcmxhcHBpbmdXaXRoKG9iamVjdCwgb3ZlcmxhcHBpbmdFZGdlcyk7XG4gICAgICAgIHJldHVybiBvdmVybGFwcGluZ0VkZ2VzO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFBsYWNlIGhvbGRlci4gVG8gaW1wbGVtZW50IGNoYW5nZSB0aGUgZ2V0Tm9kZUF0IHRvIGEgX2dldE9iamVjdEF0LiBIYXZlIHRoZSBfZ2V0T2JqZWN0QXQgY2FsbFxuICAgICAgICogZ2V0Tm9kZUF0IGFuZCBfZ2V0RWRnZXNBdCwgdGhlbiBwcmlvcnRpemUgdGhlIHNlbGVjdGlvbiB0byB1c2VyIHByZWZlcmVuY2VzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBwb2ludGVyXG4gICAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRFZGdlQXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVkZ2VBdChwb2ludGVyKSB7XG4gICAgICAgIHZhciByZXR1cm5FZGdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBlZGdlcywgcGljayBjbG9zZXN0IHdpdGhpbiAxMFxuICAgICAgICB2YXIgY2FudmFzUG9zID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMocG9pbnRlcik7XG4gICAgICAgIHZhciBtaW5kaXN0ID0gMTA7XG4gICAgICAgIHZhciBvdmVybGFwcGluZ0VkZ2UgPSBudWxsO1xuICAgICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVkZ2VJZCA9IHRoaXMuYm9keS5lZGdlSW5kaWNlc1tpXTtcbiAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VkZ2VJZF07XG4gICAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB2YXIgeEZyb20gPSBlZGdlLmZyb20ueDtcbiAgICAgICAgICAgIHZhciB5RnJvbSA9IGVkZ2UuZnJvbS55O1xuICAgICAgICAgICAgdmFyIHhUbyA9IGVkZ2UudG8ueDtcbiAgICAgICAgICAgIHZhciB5VG8gPSBlZGdlLnRvLnk7XG4gICAgICAgICAgICB2YXIgZGlzdCA9IGVkZ2UuZWRnZVR5cGUuZ2V0RGlzdGFuY2VUb0VkZ2UoeEZyb20sIHlGcm9tLCB4VG8sIHlUbywgY2FudmFzUG9zLngsIGNhbnZhc1Bvcy55KTtcbiAgICAgICAgICAgIGlmIChkaXN0IDwgbWluZGlzdCkge1xuICAgICAgICAgICAgICBvdmVybGFwcGluZ0VkZ2UgPSBlZGdlSWQ7XG4gICAgICAgICAgICAgIG1pbmRpc3QgPSBkaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3ZlcmxhcHBpbmdFZGdlKSB7XG4gICAgICAgICAgaWYgKHJldHVybkVkZ2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkuZWRnZXNbb3ZlcmxhcHBpbmdFZGdlXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG92ZXJsYXBwaW5nRWRnZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZCBvYmplY3QgdG8gdGhlIHNlbGVjdGlvbiBhcnJheS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gb2JqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYWRkVG9TZWxlY3Rpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRUb1NlbGVjdGlvbihvYmopIHtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIF9Ob2RlMi5kZWZhdWx0KSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25PYmoubm9kZXNbb2JqLmlkXSA9IG9iajtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbk9iai5lZGdlc1tvYmouaWRdID0gb2JqO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkIG9iamVjdCB0byB0aGUgc2VsZWN0aW9uIGFycmF5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBvYmpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19hZGRUb0hvdmVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkVG9Ib3ZlcihvYmopIHtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIF9Ob2RlMi5kZWZhdWx0KSB7XG4gICAgICAgICAgdGhpcy5ob3Zlck9iai5ub2Rlc1tvYmouaWRdID0gb2JqO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaG92ZXJPYmouZWRnZXNbb2JqLmlkXSA9IG9iajtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBhIHNpbmdsZSBvcHRpb24gZnJvbSBzZWxlY3Rpb24uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3JlbW92ZUZyb21TZWxlY3Rpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVGcm9tU2VsZWN0aW9uKG9iaikge1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgX05vZGUyLmRlZmF1bHQpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zZWxlY3Rpb25PYmoubm9kZXNbb2JqLmlkXTtcbiAgICAgICAgICB0aGlzLl91bnNlbGVjdENvbm5lY3RlZEVkZ2VzKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzW29iai5pZF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBVbnNlbGVjdCBhbGwuIFRoZSBzZWxlY3Rpb25PYmogaXMgdXNlZnVsIGZvciB0aGlzLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1bnNlbGVjdEFsbCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdW5zZWxlY3RBbGwoKSB7XG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcykge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlc1tub2RlSWRdLnVuc2VsZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5lZGdlcykge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5lZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbk9iai5lZGdlc1tlZGdlSWRdLnVuc2VsZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25PYmogPSB7IG5vZGVzOiB7fSwgZWRnZXM6IHt9IH07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogcmV0dXJuIHRoZSBudW1iZXIgb2Ygc2VsZWN0ZWQgbm9kZXNcbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldFNlbGVjdGVkTm9kZUNvdW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U2VsZWN0ZWROb2RlQ291bnQoKSB7XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcykge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogcmV0dXJuIHRoZSBzZWxlY3RlZCBub2RlXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXRTZWxlY3RlZE5vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTZWxlY3RlZE5vZGUoKSB7XG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcykge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25PYmoubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiByZXR1cm4gdGhlIHNlbGVjdGVkIGVkZ2VcbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldFNlbGVjdGVkRWRnZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFNlbGVjdGVkRWRnZSgpIHtcbiAgICAgICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzLmhhc093blByb3BlcnR5KGVkZ2VJZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk9iai5lZGdlc1tlZGdlSWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHJldHVybiB0aGUgbnVtYmVyIG9mIHNlbGVjdGVkIGVkZ2VzXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXRTZWxlY3RlZEVkZ2VDb3VudCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFNlbGVjdGVkRWRnZUNvdW50KCkge1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICBmb3IgKHZhciBlZGdlSWQgaW4gdGhpcy5zZWxlY3Rpb25PYmouZWRnZXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmouZWRnZXMuaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHJldHVybiB0aGUgbnVtYmVyIG9mIHNlbGVjdGVkIG9iamVjdHMuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXRTZWxlY3RlZE9iamVjdENvdW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U2VsZWN0ZWRPYmplY3RDb3VudCgpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5lZGdlcykge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5lZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2sgaWYgYW55dGhpbmcgaXMgc2VsZWN0ZWRcbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zZWxlY3Rpb25Jc0VtcHR5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2VsZWN0aW9uSXNFbXB0eSgpIHtcbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzLmhhc093blByb3BlcnR5KGVkZ2VJZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogY2hlY2sgaWYgb25lIG9mIHRoZSBzZWxlY3RlZCBub2RlcyBpcyBhIGNsdXN0ZXIuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY2x1c3RlckluU2VsZWN0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2x1c3RlckluU2VsZWN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5zZWxlY3Rpb25PYmoubm9kZXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmoubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzW25vZGVJZF0uY2x1c3RlclNpemUgPiAxKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogc2VsZWN0IHRoZSBlZGdlcyBjb25uZWN0ZWQgdG8gdGhlIG5vZGUgdGhhdCBpcyBiZWluZyBzZWxlY3RlZFxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3NlbGVjdENvbm5lY3RlZEVkZ2VzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2VsZWN0Q29ubmVjdGVkRWRnZXMobm9kZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IG5vZGUuZWRnZXNbaV07XG4gICAgICAgICAgZWRnZS5zZWxlY3QoKTtcbiAgICAgICAgICB0aGlzLl9hZGRUb1NlbGVjdGlvbihlZGdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHNlbGVjdCB0aGUgZWRnZXMgY29ubmVjdGVkIHRvIHRoZSBub2RlIHRoYXQgaXMgYmVpbmcgc2VsZWN0ZWRcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19ob3ZlckNvbm5lY3RlZEVkZ2VzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaG92ZXJDb25uZWN0ZWRFZGdlcyhub2RlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlZGdlID0gbm9kZS5lZGdlc1tpXTtcbiAgICAgICAgICBlZGdlLmhvdmVyID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLl9hZGRUb0hvdmVyKGVkZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdW5zZWxlY3QgdGhlIGVkZ2VzIGNvbm5lY3RlZCB0byB0aGUgbm9kZSB0aGF0IGlzIGJlaW5nIHNlbGVjdGVkXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdW5zZWxlY3RDb25uZWN0ZWRFZGdlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Vuc2VsZWN0Q29ubmVjdGVkRWRnZXMobm9kZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IG5vZGUuZWRnZXNbaV07XG4gICAgICAgICAgZWRnZS51bnNlbGVjdCgpO1xuICAgICAgICAgIHRoaXMuX3JlbW92ZUZyb21TZWxlY3Rpb24oZWRnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHNvbWVvbmUgY2xpY2tzIG9uIGEgbm9kZS4gZWl0aGVyIHNlbGVjdCBvciBkZXNlbGVjdCBpdC5cbiAgICAgICAqIElmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIHNlbGVjdGlvbiBhbmQgd2UgZG9uJ3Qgd2FudCB0byBhcHBlbmQgdG8gaXQsIGNsZWFyIHRoZSBleGlzdGluZyBzZWxlY3Rpb25cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge05vZGUgfHwgRWRnZX0gb2JqZWN0XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdibHVyT2JqZWN0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBibHVyT2JqZWN0KG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0LmhvdmVyID09PSB0cnVlKSB7XG4gICAgICAgICAgb2JqZWN0LmhvdmVyID0gZmFsc2U7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIF9Ob2RlMi5kZWZhdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYmx1ck5vZGVcIiwgeyBub2RlOiBvYmplY3QuaWQgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJibHVyRWRnZVwiLCB7IGVkZ2U6IG9iamVjdC5pZCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHNvbWVvbmUgY2xpY2tzIG9uIGEgbm9kZS4gZWl0aGVyIHNlbGVjdCBvciBkZXNlbGVjdCBpdC5cbiAgICAgICAqIElmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIHNlbGVjdGlvbiBhbmQgd2UgZG9uJ3Qgd2FudCB0byBhcHBlbmQgdG8gaXQsIGNsZWFyIHRoZSBleGlzdGluZyBzZWxlY3Rpb25cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge05vZGUgfHwgRWRnZX0gb2JqZWN0XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdob3Zlck9iamVjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaG92ZXJPYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBob3ZlckNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBub2RlIGhvdmVyIGhpZ2hsaWdodHNcbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuaG92ZXJPYmoubm9kZXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5ob3Zlck9iai5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQgfHwgb2JqZWN0IGluc3RhbmNlb2YgX05vZGUyLmRlZmF1bHQgJiYgb2JqZWN0LmlkICE9IG5vZGVJZCB8fCBvYmplY3QgaW5zdGFuY2VvZiBfRWRnZTIuZGVmYXVsdCkge1xuICAgICAgICAgICAgICB0aGlzLmJsdXJPYmplY3QodGhpcy5ob3Zlck9iai5ub2Rlc1tub2RlSWRdKTtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaG92ZXJPYmoubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgICAgaG92ZXJDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmluZyBhbGwgZWRnZSBob3ZlciBoaWdobGlnaHRzXG4gICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLmhvdmVyT2JqLmVkZ2VzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaG92ZXJPYmouZWRnZXMuaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGhvdmVyIGhhcyBiZWVuIGNoYW5nZWQgaGVyZSBpdCBtZWFucyB0aGF0IHRoZSBub2RlIGhhcyBiZWVuIGhvdmVyZWQgb3ZlciBvciBvZmZcbiAgICAgICAgICAgIC8vIHdlIHRoZW4gZG8gbm90IHVzZSB0aGUgYmx1ck9iamVjdCBtZXRob2QgaGVyZS5cbiAgICAgICAgICAgIGlmIChob3ZlckNoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5ob3Zlck9iai5lZGdlc1tlZGdlSWRdLmhvdmVyID0gZmFsc2U7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmhvdmVyT2JqLmVkZ2VzW2VkZ2VJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB0aGUgYmx1ciByZW1haW5zIHRoZSBzYW1lIGFuZCB0aGUgb2JqZWN0IGlzIHVuZGVmaW5lZCAobW91c2Ugb2ZmKSBvciBhbm90aGVyXG4gICAgICAgICAgICAvLyBlZGdlIGhhcyBiZWVuIGhvdmVyZWQsIHdlIGJsdXIgdGhlIGVkZ2VcbiAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkIHx8IG9iamVjdCBpbnN0YW5jZW9mIF9FZGdlMi5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ibHVyT2JqZWN0KHRoaXMuaG92ZXJPYmouZWRnZXNbZWRnZUlkXSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaG92ZXJPYmouZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgICAgICAgICBob3ZlckNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iamVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG9iamVjdC5ob3ZlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG9iamVjdC5ob3ZlciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9hZGRUb0hvdmVyKG9iamVjdCk7XG4gICAgICAgICAgICBob3ZlckNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIF9Ob2RlMi5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJob3Zlck5vZGVcIiwgeyBub2RlOiBvYmplY3QuaWQgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiaG92ZXJFZGdlXCIsIHsgZWRnZTogb2JqZWN0LmlkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgX05vZGUyLmRlZmF1bHQgJiYgdGhpcy5vcHRpb25zLmhvdmVyQ29ubmVjdGVkRWRnZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2hvdmVyQ29ubmVjdGVkRWRnZXMob2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaG92ZXJDaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlcXVlc3RSZWRyYXcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiByZXRyaWV2ZSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG9iamVjdHNcbiAgICAgICAqIEByZXR1cm4ge3tub2RlczogQXJyYXkuPFN0cmluZz4sIGVkZ2VzOiBBcnJheS48U3RyaW5nPn19IHNlbGVjdGlvblxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRTZWxlY3Rpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGlvbigpIHtcbiAgICAgICAgdmFyIG5vZGVJZHMgPSB0aGlzLmdldFNlbGVjdGVkTm9kZXMoKTtcbiAgICAgICAgdmFyIGVkZ2VJZHMgPSB0aGlzLmdldFNlbGVjdGVkRWRnZXMoKTtcbiAgICAgICAgcmV0dXJuIHsgbm9kZXM6IG5vZGVJZHMsIGVkZ2VzOiBlZGdlSWRzIH07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIHJldHJpZXZlIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbm9kZXNcbiAgICAgICAqIEByZXR1cm4ge1N0cmluZ1tdfSBzZWxlY3Rpb24gICAgQW4gYXJyYXkgd2l0aCB0aGUgaWRzIG9mIHRoZVxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkIG5vZGVzLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRTZWxlY3RlZE5vZGVzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWxlY3RlZE5vZGVzKCkge1xuICAgICAgICB2YXIgaWRBcnJheSA9IFtdO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNlbGVjdGFibGUgPT09IHRydWUpIHtcbiAgICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5zZWxlY3Rpb25PYmoubm9kZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICAgIGlkQXJyYXkucHVzaCh0aGlzLnNlbGVjdGlvbk9iai5ub2Rlc1tub2RlSWRdLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkQXJyYXk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIHJldHJpZXZlIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZWRnZXNcbiAgICAgICAqIEByZXR1cm4ge0FycmF5fSBzZWxlY3Rpb24gICAgQW4gYXJyYXkgd2l0aCB0aGUgaWRzIG9mIHRoZVxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkIG5vZGVzLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRTZWxlY3RlZEVkZ2VzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWxlY3RlZEVkZ2VzKCkge1xuICAgICAgICB2YXIgaWRBcnJheSA9IFtdO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNlbGVjdGFibGUgPT09IHRydWUpIHtcbiAgICAgICAgICBmb3IgKHZhciBlZGdlSWQgaW4gdGhpcy5zZWxlY3Rpb25PYmouZWRnZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5lZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgICAgIGlkQXJyYXkucHVzaCh0aGlzLnNlbGVjdGlvbk9iai5lZGdlc1tlZGdlSWRdLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkQXJyYXk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVXBkYXRlcyB0aGUgY3VycmVudCBzZWxlY3Rpb25cbiAgICAgICAqIEBwYXJhbSB7e25vZGVzOiBBcnJheS48U3RyaW5nPiwgZWRnZXM6IEFycmF5LjxTdHJpbmc+fX0gU2VsZWN0aW9uXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0U2VsZWN0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICB2YXIgaSA9IHZvaWQgMCxcbiAgICAgICAgICAgIGlkID0gdm9pZCAwO1xuXG4gICAgICAgIGlmICghc2VsZWN0aW9uIHx8ICFzZWxlY3Rpb24ubm9kZXMgJiYgIXNlbGVjdGlvbi5lZGdlcykgdGhyb3cgJ1NlbGVjdGlvbiBtdXN0IGJlIGFuIG9iamVjdCB3aXRoIG5vZGVzIGFuZC9vciBlZGdlcyBwcm9wZXJ0aWVzJztcbiAgICAgICAgLy8gZmlyc3QgdW5zZWxlY3QgYW55IHNlbGVjdGVkIG5vZGUsIGlmIG9wdGlvbiBpcyB0cnVlIG9yIHVuZGVmaW5lZFxuICAgICAgICBpZiAob3B0aW9ucy51bnNlbGVjdEFsbCB8fCBvcHRpb25zLnVuc2VsZWN0QWxsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdGlvbi5ub2Rlcykge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxlY3Rpb24ubm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlkID0gc2VsZWN0aW9uLm5vZGVzW2ldO1xuXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tpZF07XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ05vZGUgd2l0aCBpZCBcIicgKyBpZCArICdcIiBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRvbid0IHNlbGVjdCBlZGdlcyB3aXRoIGl0XG4gICAgICAgICAgICB0aGlzLnNlbGVjdE9iamVjdChub2RlLCBvcHRpb25zLmhpZ2hsaWdodEVkZ2VzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZWN0aW9uLmVkZ2VzKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGVjdGlvbi5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWQgPSBzZWxlY3Rpb24uZWRnZXNbaV07XG5cbiAgICAgICAgICAgIHZhciBlZGdlID0gdGhpcy5ib2R5LmVkZ2VzW2lkXTtcbiAgICAgICAgICAgIGlmICghZWRnZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRWRnZSB3aXRoIGlkIFwiJyArIGlkICsgJ1wiIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWxlY3RPYmplY3QoZWRnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogc2VsZWN0IHplcm8gb3IgbW9yZSBub2RlcyB3aXRoIHRoZSBvcHRpb24gdG8gaGlnaGxpZ2h0IGVkZ2VzXG4gICAgICAgKiBAcGFyYW0ge051bWJlcltdIHwgU3RyaW5nW119IHNlbGVjdGlvbiAgICAgQW4gYXJyYXkgd2l0aCB0aGUgaWRzIG9mIHRoZVxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkIG5vZGVzLlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBbaGlnaGxpZ2h0RWRnZXNdXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NlbGVjdE5vZGVzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3ROb2RlcyhzZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGhpZ2hsaWdodEVkZ2VzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICAgIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5sZW5ndGggPT09IHVuZGVmaW5lZCkgdGhyb3cgJ1NlbGVjdGlvbiBtdXN0IGJlIGFuIGFycmF5IHdpdGggaWRzJztcblxuICAgICAgICB0aGlzLnNldFNlbGVjdGlvbih7IG5vZGVzOiBzZWxlY3Rpb24gfSwgeyBoaWdobGlnaHRFZGdlczogaGlnaGxpZ2h0RWRnZXMgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogc2VsZWN0IHplcm8gb3IgbW9yZSBlZGdlc1xuICAgICAgICogQHBhcmFtIHtOdW1iZXJbXSB8IFN0cmluZ1tdfSBzZWxlY3Rpb24gICAgIEFuIGFycmF5IHdpdGggdGhlIGlkcyBvZiB0aGVcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCBub2Rlcy5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2VsZWN0RWRnZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdEVkZ2VzKHNlbGVjdGlvbikge1xuICAgICAgICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ubGVuZ3RoID09PSB1bmRlZmluZWQpIHRocm93ICdTZWxlY3Rpb24gbXVzdCBiZSBhbiBhcnJheSB3aXRoIGlkcyc7XG5cbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oeyBlZGdlczogc2VsZWN0aW9uIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFZhbGlkYXRlIHRoZSBzZWxlY3Rpb246IHJlbW92ZSBpZHMgb2Ygbm9kZXMgd2hpY2ggbm8gbG9uZ2VyIGV4aXN0XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVTZWxlY3Rpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5ib2R5Lm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5lZGdlcykge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5lZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYm9keS5lZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNlbGVjdGlvbk9iai5lZGdlc1tlZGdlSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBTZWxlY3Rpb25IYW5kbGVyO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gU2VsZWN0aW9uSGFuZGxlcjtcblxuLyoqKi8gfSxcbi8qIDExNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX05ldHdvcmtVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDUpO1xuXG4gIHZhciBfTmV0d29ya1V0aWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTmV0d29ya1V0aWwpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIExheW91dEVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMYXlvdXRFbmdpbmUoYm9keSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExheW91dEVuZ2luZSk7XG5cbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cbiAgICAgIHRoaXMuaW5pdGlhbFJhbmRvbVNlZWQgPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwKTtcbiAgICAgIHRoaXMucmFuZG9tU2VlZCA9IHRoaXMuaW5pdGlhbFJhbmRvbVNlZWQ7XG4gICAgICB0aGlzLnNldFBoeXNpY3MgPSBmYWxzZTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgdGhpcy5vcHRpb25zQmFja3VwID0geyBwaHlzaWNzOiB7fSB9O1xuXG4gICAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICByYW5kb21TZWVkOiB1bmRlZmluZWQsXG4gICAgICAgIGltcHJvdmVkTGF5b3V0OiB0cnVlLFxuICAgICAgICBoaWVyYXJjaGljYWw6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBsZXZlbFNlcGFyYXRpb246IDE1MCxcbiAgICAgICAgICBub2RlU3BhY2luZzogMTAwLFxuICAgICAgICAgIHRyZWVTcGFjaW5nOiAyMDAsXG4gICAgICAgICAgYmxvY2tTaGlmdGluZzogdHJ1ZSxcbiAgICAgICAgICBlZGdlTWluaW1pemF0aW9uOiB0cnVlLFxuICAgICAgICAgIHBhcmVudENlbnRyYWxpemF0aW9uOiB0cnVlLFxuICAgICAgICAgIGRpcmVjdGlvbjogJ1VEJywgLy8gVUQsIERVLCBMUiwgUkxcbiAgICAgICAgICBzb3J0TWV0aG9kOiAnaHVic2l6ZScgLy8gaHVic2l6ZSwgZGlyZWN0ZWRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhMYXlvdXRFbmdpbmUsIFt7XG4gICAgICBrZXk6ICdiaW5kRXZlbnRMaXN0ZW5lcnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignX2RhdGFDaGFuZ2VkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnNldHVwSGllcmFyY2hpY2FsTGF5b3V0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignX2RhdGFMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMubGF5b3V0TmV0d29yaygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19yZXNldEhpZXJhcmNoaWNhbExheW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5zZXR1cEhpZXJhcmNoaWNhbExheW91dCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMsIGFsbE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBwcmV2SGllcmFyY2hpY2FsU3RhdGUgPSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVuYWJsZWQ7XG4gICAgICAgICAgdXRpbC5zZWxlY3RpdmVEZWVwRXh0ZW5kKFtcInJhbmRvbVNlZWRcIiwgXCJpbXByb3ZlZExheW91dFwiXSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgICB1dGlsLm1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsICdoaWVyYXJjaGljYWwnKTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5yYW5kb21TZWVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbFJhbmRvbVNlZWQgPSBvcHRpb25zLnJhbmRvbVNlZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHByZXZIaWVyYXJjaGljYWxTdGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAvLyByZWZyZXNoIHRoZSBvdmVycmlkZGVuIG9wdGlvbnMgZm9yIG5vZGVzIGFuZCBlZGdlcy5cbiAgICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgncmVmcmVzaCcsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGxldmVsIHNlcGFyYXRpb24gaXMgdGhlIHJpZ2h0IHdheSB1cFxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSAnUkwnIHx8IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSAnRFUnKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiAqPSAtMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uICo9IC0xO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXNldEhpZXJhcmNoaWNhbExheW91dCcpO1xuICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgaGllcmFyY2hpY2FsIHN5c3RlbSBuZWVkcyBpdCdzIG93biBwaHlzaWNzIGFuZCBzbW9vdGggY3VydmUgc2V0dGluZ3MsIHdlIGFkYXB0IHRoZSBvdGhlciBvcHRpb25zIGlmIG5lZWRlZC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkYXB0QWxsT3B0aW9uc0ZvckhpZXJhcmNoaWNhbExheW91dChhbGxPcHRpb25zKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByZXZIaWVyYXJjaGljYWxTdGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAvLyByZWZyZXNoIHRoZSBvdmVycmlkZGVuIG9wdGlvbnMgZm9yIG5vZGVzIGFuZCBlZGdlcy5cbiAgICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgncmVmcmVzaCcpO1xuICAgICAgICAgICAgICByZXR1cm4gdXRpbC5kZWVwRXh0ZW5kKGFsbE9wdGlvbnMsIHRoaXMub3B0aW9uc0JhY2t1cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGxPcHRpb25zO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2FkYXB0QWxsT3B0aW9uc0ZvckhpZXJhcmNoaWNhbExheW91dCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRhcHRBbGxPcHRpb25zRm9ySGllcmFyY2hpY2FsTGF5b3V0KGFsbE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIHNldCB0aGUgcGh5c2ljc1xuICAgICAgICAgIGlmIChhbGxPcHRpb25zLnBoeXNpY3MgPT09IHVuZGVmaW5lZCB8fCBhbGxPcHRpb25zLnBoeXNpY3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGFsbE9wdGlvbnMucGh5c2ljcyA9IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdGhpcy5vcHRpb25zQmFja3VwLnBoeXNpY3MuZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHRoaXMub3B0aW9uc0JhY2t1cC5waHlzaWNzLmVuYWJsZWQsXG4gICAgICAgICAgICAgIHNvbHZlcjogJ2hpZXJhcmNoaWNhbFJlcHVsc2lvbidcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNCYWNrdXAucGh5c2ljcy5lbmFibGVkID0gdGhpcy5vcHRpb25zQmFja3VwLnBoeXNpY3MuZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHRoaXMub3B0aW9uc0JhY2t1cC5waHlzaWNzLmVuYWJsZWQ7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNCYWNrdXAucGh5c2ljcy5zb2x2ZXIgPSB0aGlzLm9wdGlvbnNCYWNrdXAucGh5c2ljcy5zb2x2ZXIgfHwgJ2Jhcm5lc0h1dCc7XG4gICAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKGFsbE9wdGlvbnMucGh5c2ljcykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNCYWNrdXAucGh5c2ljcy5lbmFibGVkID0gYWxsT3B0aW9ucy5waHlzaWNzLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhbGxPcHRpb25zLnBoeXNpY3MuZW5hYmxlZDtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc0JhY2t1cC5waHlzaWNzLnNvbHZlciA9IGFsbE9wdGlvbnMucGh5c2ljcy5zb2x2ZXIgfHwgJ2Jhcm5lc0h1dCc7XG4gICAgICAgICAgICBhbGxPcHRpb25zLnBoeXNpY3Muc29sdmVyID0gJ2hpZXJhcmNoaWNhbFJlcHVsc2lvbic7XG4gICAgICAgICAgfSBlbHNlIGlmIChhbGxPcHRpb25zLnBoeXNpY3MgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNCYWNrdXAucGh5c2ljcy5zb2x2ZXIgPSAnYmFybmVzSHV0JztcbiAgICAgICAgICAgIGFsbE9wdGlvbnMucGh5c2ljcyA9IHsgc29sdmVyOiAnaGllcmFyY2hpY2FsUmVwdWxzaW9uJyB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGdldCB0aGUgdHlwZSBvZiBzdGF0aWMgc21vb3RoIGN1cnZlIGluIGNhc2UgaXQgaXMgcmVxdWlyZWRcbiAgICAgICAgICB2YXIgdHlwZSA9ICdob3Jpem9udGFsJztcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5kaXJlY3Rpb24gPT09ICdSTCcgfHwgdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5kaXJlY3Rpb24gPT09ICdMUicpIHtcbiAgICAgICAgICAgIHR5cGUgPSAndmVydGljYWwnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGRpc2FibGUgc21vb3RoIGN1cnZlcyBpZiBub3RoaW5nIGlzIGRlZmluZWQuIElmIHNtb290aCBjdXJ2ZXMgaGF2ZSBiZWVuIHR1cm5lZCBvbiwgdHVybiB0aGVtIGludG8gc3RhdGljIHNtb290aCBjdXJ2ZXMuXG4gICAgICAgICAgaWYgKGFsbE9wdGlvbnMuZWRnZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zQmFja3VwLmVkZ2VzID0geyBzbW9vdGg6IHsgZW5hYmxlZDogdHJ1ZSwgdHlwZTogJ2R5bmFtaWMnIH0gfTtcbiAgICAgICAgICAgIGFsbE9wdGlvbnMuZWRnZXMgPSB7IHNtb290aDogZmFsc2UgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc0JhY2t1cC5lZGdlcyA9IHsgc21vb3RoOiB7IGVuYWJsZWQ6IHRydWUsIHR5cGU6ICdkeW5hbWljJyB9IH07XG4gICAgICAgICAgICBhbGxPcHRpb25zLmVkZ2VzLnNtb290aCA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zQmFja3VwLmVkZ2VzID0geyBzbW9vdGg6IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoIH07XG4gICAgICAgICAgICAgIGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoID0geyBlbmFibGVkOiBhbGxPcHRpb25zLmVkZ2VzLnNtb290aCwgdHlwZTogdHlwZSB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gYWxsb3cgY3VzdG9tIHR5cGVzIGV4Y2VwdCBmb3IgZHluYW1pY1xuICAgICAgICAgICAgICBpZiAoYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGgudHlwZSAhPT0gdW5kZWZpbmVkICYmIGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoLnR5cGUgIT09ICdkeW5hbWljJykge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBhbGxPcHRpb25zLmVkZ2VzLnNtb290aC50eXBlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zQmFja3VwLmVkZ2VzID0ge1xuICAgICAgICAgICAgICAgIHNtb290aDogYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGguZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoLmVuYWJsZWQsXG4gICAgICAgICAgICAgICAgdHlwZTogYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGgudHlwZSA9PT0gdW5kZWZpbmVkID8gJ2R5bmFtaWMnIDogYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGgudHlwZSxcbiAgICAgICAgICAgICAgICByb3VuZG5lc3M6IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoLnJvdW5kbmVzcyA9PT0gdW5kZWZpbmVkID8gMC41IDogYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGgucm91bmRuZXNzLFxuICAgICAgICAgICAgICAgIGZvcmNlRGlyZWN0aW9uOiBhbGxPcHRpb25zLmVkZ2VzLnNtb290aC5mb3JjZURpcmVjdGlvbiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhbGxPcHRpb25zLmVkZ2VzLnNtb290aC5mb3JjZURpcmVjdGlvblxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBhbGxPcHRpb25zLmVkZ2VzLnNtb290aCA9IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBhbGxPcHRpb25zLmVkZ2VzLnNtb290aC5lbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGguZW5hYmxlZCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIHJvdW5kbmVzczogYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGgucm91bmRuZXNzID09PSB1bmRlZmluZWQgPyAwLjUgOiBhbGxPcHRpb25zLmVkZ2VzLnNtb290aC5yb3VuZG5lc3MsXG4gICAgICAgICAgICAgICAgZm9yY2VEaXJlY3Rpb246IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoLmZvcmNlRGlyZWN0aW9uID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoLmZvcmNlRGlyZWN0aW9uXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZm9yY2UgYWxsIGVkZ2VzIGludG8gc3RhdGljIHNtb290aCBjdXJ2ZXMuIE9ubHkgYXBwbGllcyB0byBlZGdlcyB0aGF0IGRvIG5vdCB1c2UgdGhlIGdsb2JhbCBvcHRpb25zIGZvciBzbW9vdGguXG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2ZvcmNlRGlzYWJsZUR5bmFtaWNDdXJ2ZXMnLCB0eXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhbGxPcHRpb25zO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NlZWRlZFJhbmRvbScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2VlZGVkUmFuZG9tKCkge1xuICAgICAgICB2YXIgeCA9IE1hdGguc2luKHRoaXMucmFuZG9tU2VlZCsrKSAqIDEwMDAwO1xuICAgICAgICByZXR1cm4geCAtIE1hdGguZmxvb3IoeCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAncG9zaXRpb25Jbml0aWFsbHknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBvc2l0aW9uSW5pdGlhbGx5KG5vZGVzQXJyYXkpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMucmFuZG9tU2VlZCA9IHRoaXMuaW5pdGlhbFJhbmRvbVNlZWQ7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlc0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzQXJyYXlbaV07XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gMTAgKiAwLjEgKiBub2Rlc0FycmF5Lmxlbmd0aCArIDEwO1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gMiAqIE1hdGguUEkgKiB0aGlzLnNlZWRlZFJhbmRvbSgpO1xuICAgICAgICAgICAgaWYgKG5vZGUueCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIG5vZGUueCA9IHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBub2RlLnkgPSByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlIEthbWFkYSBLYXdhaSB0byBwb3NpdGlvbiBub2Rlcy4gVGhpcyBpcyBxdWl0ZSBhIGhlYXZ5IGFsZ29yaXRobSBzbyBpZiB0aGVyZSBhcmUgYSBsb3Qgb2Ygbm9kZXMgd2VcbiAgICAgICAqIGNsdXN0ZXIgdGhlbSBmaXJzdCB0byByZWR1Y2UgdGhlIGFtb3VudC5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnbGF5b3V0TmV0d29yaycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbGF5b3V0TmV0d29yaygpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCAhPT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuaW1wcm92ZWRMYXlvdXQgPT09IHRydWUpIHtcbiAgICAgICAgICAvLyBmaXJzdCBjaGVjayBpZiB3ZSBzaG91bGQgS2FtYWRhIEthd2FpIHRvIGxheW91dC4gVGhlIHRocmVzaG9sZCBpcyBpZiBsZXNzIHRoYW4gaGFsZiBvZiB0aGUgdmlzaWJsZVxuICAgICAgICAgIC8vIG5vZGVzIGhhdmUgcHJlZGVmaW5lZCBwb3NpdGlvbnMgd2UgdXNlIHRoaXMuXG4gICAgICAgICAgdmFyIHBvc2l0aW9uRGVmaW5lZCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tpXV07XG4gICAgICAgICAgICBpZiAobm9kZS5wcmVkZWZpbmVkUG9zaXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgcG9zaXRpb25EZWZpbmVkICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgbGVzcyB0aGFuIGhhbGYgb2YgdGhlIG5vZGVzIGhhdmUgYSBwcmVkZWZpbmVkIHBvc2l0aW9uIHdlIGNvbnRpbnVlXG4gICAgICAgICAgaWYgKHBvc2l0aW9uRGVmaW5lZCA8IDAuNSAqIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBNQVhfTEVWRUxTID0gMTA7XG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSAwO1xuICAgICAgICAgICAgdmFyIGNsdXN0ZXJUaHJlc2hvbGQgPSAxMDA7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgYSBsb3Qgb2Ygbm9kZXMsIHdlIGNsdXN0ZXIgYmVmb3JlIHdlIHJ1biB0aGUgYWxnb3JpdGhtLlxuICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGggPiBjbHVzdGVyVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgIHZhciBzdGFydExlbmd0aCA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgIHdoaWxlICh0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoID4gY2x1c3RlclRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS50aW1lKFwiY2x1c3RlcmluZ1wiKVxuICAgICAgICAgICAgICAgIGxldmVsICs9IDE7XG4gICAgICAgICAgICAgICAgdmFyIGJlZm9yZSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG1hbnkgbm9kZXMgd2UgZG8gYSBodWJzaXplIGNsdXN0ZXJcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgJSAzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmJvZHkubW9kdWxlcy5jbHVzdGVyaW5nLmNsdXN0ZXJCcmlkZ2VzKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYm9keS5tb2R1bGVzLmNsdXN0ZXJpbmcuY2x1c3Rlck91dGxpZXJzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBhZnRlciA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZSA9PSBhZnRlciAmJiBsZXZlbCAlIDMgIT09IDAgfHwgbGV2ZWwgPiBNQVhfTEVWRUxTKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9kZWNsdXN0ZXJBbGwoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfbGF5b3V0RmFpbGVkXCIpO1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVGhpcyBuZXR3b3JrIGNvdWxkIG5vdCBiZSBwb3NpdGlvbmVkIGJ5IHRoaXMgdmVyc2lvbiBvZiB0aGUgaW1wcm92ZWQgbGF5b3V0IGFsZ29yaXRobS4gUGxlYXNlIGRpc2FibGUgaW1wcm92ZWRMYXlvdXQgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cIik7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vY29uc29sZS50aW1lRW5kKFwiY2x1c3RlcmluZ1wiKVxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cobGV2ZWwsYWZ0ZXIpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gaW5jcmVhc2UgdGhlIHNpemUgb2YgdGhlIGVkZ2VzXG4gICAgICAgICAgICAgIHRoaXMuYm9keS5tb2R1bGVzLmthbWFkYUthd2FpLnNldE9wdGlvbnMoeyBzcHJpbmdMZW5ndGg6IE1hdGgubWF4KDE1MCwgMiAqIHN0YXJ0TGVuZ3RoKSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcG9zaXRpb24gdGhlIHN5c3RlbSBmb3IgdGhlc2Ugbm9kZXMgYW5kIGVkZ2VzXG4gICAgICAgICAgICB0aGlzLmJvZHkubW9kdWxlcy5rYW1hZGFLYXdhaS5zb2x2ZSh0aGlzLmJvZHkubm9kZUluZGljZXMsIHRoaXMuYm9keS5lZGdlSW5kaWNlcywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIHNoaWZ0IHRvIGNlbnRlciBwb2ludFxuICAgICAgICAgICAgdGhpcy5fc2hpZnRUb0NlbnRlcigpO1xuXG4gICAgICAgICAgICAvLyBwZXJ0dXJiIHRoZSBub2RlcyBhIGxpdHRsZSBiaXQgdG8gZm9yY2UgdGhlIHBoeXNpY3MgdG8ga2ljayBpblxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDcwO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgLy8gT25seSBwZXJ0dXJiIHRoZSBub2RlcyB0aGF0IGFyZW4ndCBmaXhlZFxuICAgICAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tfaV1dLnByZWRlZmluZWRQb3NpdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW19pXV0ueCArPSAoMC41IC0gdGhpcy5zZWVkZWRSYW5kb20oKSkgKiBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tfaV1dLnkgKz0gKDAuNSAtIHRoaXMuc2VlZGVkUmFuZG9tKCkpICogb2Zmc2V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHVuY2x1c3RlciBhbGwgY2x1c3RlcnNcbiAgICAgICAgICAgIHRoaXMuX2RlY2x1c3RlckFsbCgpO1xuXG4gICAgICAgICAgICAvLyByZXBvc2l0aW9uIGFsbCBiZXppZXIgbm9kZXMuXG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcG9zaXRpb25CZXppZXJOb2Rlc1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBNb3ZlIGFsbCB0aGUgbm9kZXMgdG93YXJkcyB0byB0aGUgY2VudGVyIHNvIGdyYXZpdGF0aW9uYWwgcHVsbCB3aWwgbm90IG1vdmUgdGhlIG5vZGVzIGF3YXkgZnJvbSB2aWV3XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2hpZnRUb0NlbnRlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NoaWZ0VG9DZW50ZXIoKSB7XG4gICAgICAgIHZhciByYW5nZSA9IF9OZXR3b3JrVXRpbDIuZGVmYXVsdC5nZXRSYW5nZUNvcmUodGhpcy5ib2R5Lm5vZGVzLCB0aGlzLmJvZHkubm9kZUluZGljZXMpO1xuICAgICAgICB2YXIgY2VudGVyID0gX05ldHdvcmtVdGlsMi5kZWZhdWx0LmZpbmRDZW50ZXIocmFuZ2UpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbaV1dLnggLT0gY2VudGVyLng7XG4gICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tpXV0ueSAtPSBjZW50ZXIueTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19kZWNsdXN0ZXJBbGwnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWNsdXN0ZXJBbGwoKSB7XG4gICAgICAgIHZhciBjbHVzdGVyc1ByZXNlbnQgPSB0cnVlO1xuICAgICAgICB3aGlsZSAoY2x1c3RlcnNQcmVzZW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgY2x1c3RlcnNQcmVzZW50ID0gZmFsc2U7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldXS5pc0NsdXN0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgY2x1c3RlcnNQcmVzZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy5ib2R5Lm1vZHVsZXMuY2x1c3RlcmluZy5vcGVuQ2x1c3Rlcih0aGlzLmJvZHkubm9kZUluZGljZXNbaV0sIHt9LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjbHVzdGVyc1ByZXNlbnQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19kYXRhQ2hhbmdlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldFNlZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxSYW5kb21TZWVkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgaXMgdGhlIG1haW4gZnVuY3Rpb24gdG8gbGF5b3V0IHRoZSBub2RlcyBpbiBhIGhpZXJhcmNoaWNhbCB3YXkuXG4gICAgICAgKiBJdCBjaGVja3MgaWYgdGhlIG5vZGUgZGV0YWlscyBhcmUgc3VwcGxpZWQgY29ycmVjdGx5XG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0dXBIaWVyYXJjaGljYWxMYXlvdXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwSGllcmFyY2hpY2FsTGF5b3V0KCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5lbmFibGVkID09PSB0cnVlICYmIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gZ2V0IHRoZSBzaXplIG9mIHRoZSBsYXJnZXN0IGh1YnMgYW5kIGNoZWNrIGlmIHRoZSB1c2VyIGhhcyBkZWZpbmVkIGEgbGV2ZWwgZm9yIGEgbm9kZS5cbiAgICAgICAgICB2YXIgbm9kZSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgbm9kZUlkID0gdm9pZCAwO1xuICAgICAgICAgIHZhciBkZWZpbmVkTGV2ZWwgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgZGVmaW5lZFBvc2l0aW9ucyA9IHRydWU7XG4gICAgICAgICAgdmFyIHVuZGVmaW5lZExldmVsID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5oaWVyYXJjaGljYWxMZXZlbHMgPSB7fTtcbiAgICAgICAgICB0aGlzLmxhc3ROb2RlT25MZXZlbCA9IHt9O1xuICAgICAgICAgIHRoaXMuaGllcmFyY2hpY2FsQ2hpbGRyZW5SZWZlcmVuY2UgPSB7fTtcbiAgICAgICAgICB0aGlzLmhpZXJhcmNoaWNhbFBhcmVudFJlZmVyZW5jZSA9IHt9O1xuICAgICAgICAgIHRoaXMuaGllcmFyY2hpY2FsVHJlZXMgPSB7fTtcbiAgICAgICAgICB0aGlzLnRyZWVJbmRleCA9IC0xO1xuXG4gICAgICAgICAgdGhpcy5kaXN0cmlidXRpb25PcmRlcmluZyA9IHt9O1xuICAgICAgICAgIHRoaXMuZGlzdHJpYnV0aW9uSW5kZXggPSB7fTtcbiAgICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nUHJlc2VuY2UgPSB7fTtcblxuICAgICAgICAgIGZvciAobm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgICAgaWYgKG5vZGUub3B0aW9ucy54ID09PSB1bmRlZmluZWQgJiYgbm9kZS5vcHRpb25zLnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlZmluZWRQb3NpdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobm9kZS5vcHRpb25zLmxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVkTGV2ZWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGllcmFyY2hpY2FsTGV2ZWxzW25vZGVJZF0gPSBub2RlLm9wdGlvbnMubGV2ZWw7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkTGV2ZWwgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgdGhlIHVzZXIgZGVmaW5lZCBzb21lIGxldmVscyBidXQgbm90IGFsbCwgYWxlcnQgYW5kIHJ1biB3aXRob3V0IGhpZXJhcmNoaWNhbCBsYXlvdXRcbiAgICAgICAgICBpZiAodW5kZWZpbmVkTGV2ZWwgPT09IHRydWUgJiYgZGVmaW5lZExldmVsID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvIHVzZSB0aGUgaGllcmFyY2hpY2FsIGxheW91dCwgbm9kZXMgcmVxdWlyZSBlaXRoZXIgbm8gcHJlZGVmaW5lZCBsZXZlbHMgb3IgbGV2ZWxzIGhhdmUgdG8gYmUgZGVmaW5lZCBmb3IgYWxsIG5vZGVzLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkZWZpbmUgbGV2ZWxzIGlmIHVuZGVmaW5lZCBieSB0aGUgdXNlcnMuIEJhc2VkIG9uIGh1YnNpemUuXG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkTGV2ZWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuc29ydE1ldGhvZCA9PT0gJ2h1YnNpemUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGV0ZXJtaW5lTGV2ZWxzQnlIdWJzaXplKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5zb3J0TWV0aG9kID09PSAnZGlyZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGV0ZXJtaW5lTGV2ZWxzRGlyZWN0ZWQoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLnNvcnRNZXRob2QgPT09ICdjdXN0b20nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGV0ZXJtaW5lTGV2ZWxzQ3VzdG9tQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmYWxsYmFjayBmb3IgY2FzZXMgd2hlcmUgdGhlcmUgYXJlIG5vZGVzIGJ1dCBubyBlZGdlc1xuICAgICAgICAgICAgZm9yICh2YXIgX25vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShfbm9kZUlkKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhpZXJhcmNoaWNhbExldmVsc1tfbm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmhpZXJhcmNoaWNhbExldmVsc1tfbm9kZUlkXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayB0aGUgZGlzdHJpYnV0aW9uIG9mIHRoZSBub2RlcyBwZXIgbGV2ZWwuXG4gICAgICAgICAgICB2YXIgZGlzdHJpYnV0aW9uID0gdGhpcy5fZ2V0RGlzdHJpYnV0aW9uKCk7XG5cbiAgICAgICAgICAgIC8vIGdldCB0aGUgcGFyZW50IGNoaWxkcmVuIHJlbGF0aW9ucy5cbiAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlTWFwKCk7XG5cbiAgICAgICAgICAgIC8vIHBsYWNlIHRoZSBub2RlcyBvbiB0aGUgY2FudmFzLlxuICAgICAgICAgICAgdGhpcy5fcGxhY2VOb2Rlc0J5SGllcmFyY2h5KGRpc3RyaWJ1dGlvbik7XG5cbiAgICAgICAgICAgIC8vIGNvbmRlbnNlIHRoZSB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgdGhpcy5fY29uZGVuc2VIaWVyYXJjaHkoKTtcblxuICAgICAgICAgICAgLy8gc2hpZnQgdG8gY2VudGVyIHNvIGdyYXZpdHkgZG9lcyBub3QgaGF2ZSB0byBkbyBtdWNoXG4gICAgICAgICAgICB0aGlzLl9zaGlmdFRvQ2VudGVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NvbmRlbnNlSGllcmFyY2h5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY29uZGVuc2VIaWVyYXJjaHkoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIC8vIEdsb2JhbCB2YXIgaW4gdGhpcyBzY29wZSB0byBkZWZpbmUgd2hlbiB0aGUgbW92ZW1lbnQgaGFzIHN0b3BwZWQuXG4gICAgICAgIHZhciBzdGlsbFNoaWZ0aW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBicmFuY2hlcyA9IHt9O1xuICAgICAgICAvLyBmaXJzdCB3ZSBoYXZlIHNvbWUgbWV0aG9kcyB0byBoZWxwIHNoaWZ0aW5nIHRyZWVzIGFyb3VuZC5cbiAgICAgICAgLy8gdGhlIG1haW4gbWV0aG9kIHRvIHNoaWZ0IHRoZSB0cmVlc1xuICAgICAgICB2YXIgc2hpZnRUcmVlcyA9IGZ1bmN0aW9uIHNoaWZ0VHJlZXMoKSB7XG4gICAgICAgICAgdmFyIHRyZWVTaXplcyA9IGdldFRyZWVTaXplcygpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZVNpemVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSB0cmVlU2l6ZXNbaV0ubWF4IC0gdHJlZVNpemVzW2kgKyAxXS5taW47XG4gICAgICAgICAgICBzaGlmdFRyZWUoaSArIDEsIGRpZmYgKyBfdGhpczIub3B0aW9ucy5oaWVyYXJjaGljYWwudHJlZVNwYWNpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzaGlmdCBhIHNpbmdsZSB0cmVlIGJ5IGFuIG9mZnNldFxuICAgICAgICB2YXIgc2hpZnRUcmVlID0gZnVuY3Rpb24gc2hpZnRUcmVlKGluZGV4LCBvZmZzZXQpIHtcbiAgICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gX3RoaXMyLmhpZXJhcmNoaWNhbFRyZWVzKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMyLmhpZXJhcmNoaWNhbFRyZWVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgaWYgKF90aGlzMi5oaWVyYXJjaGljYWxUcmVlc1tub2RlSWRdID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gX3RoaXMyLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gX3RoaXMyLl9nZXRQb3NpdGlvbkZvckhpZXJhcmNoeShub2RlKTtcbiAgICAgICAgICAgICAgICBfdGhpczIuX3NldFBvc2l0aW9uRm9ySGllcmFyY2h5KG5vZGUsIHBvcyArIG9mZnNldCwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBnZXQgdGhlIHdpZHRoIG9mIGEgdHJlZVxuICAgICAgICB2YXIgZ2V0VHJlZVNpemUgPSBmdW5jdGlvbiBnZXRUcmVlU2l6ZShpbmRleCkge1xuICAgICAgICAgIHZhciBtaW4gPSAxZTk7XG4gICAgICAgICAgdmFyIG1heCA9IC0xZTk7XG4gICAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIF90aGlzMi5oaWVyYXJjaGljYWxUcmVlcykge1xuICAgICAgICAgICAgaWYgKF90aGlzMi5oaWVyYXJjaGljYWxUcmVlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpczIuaGllcmFyY2hpY2FsVHJlZXNbbm9kZUlkXSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gX3RoaXMyLl9nZXRQb3NpdGlvbkZvckhpZXJhcmNoeShfdGhpczIuYm9keS5ub2Rlc1tub2RlSWRdKTtcbiAgICAgICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihwb3MsIG1pbik7XG4gICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgocG9zLCBtYXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IG1pbjogbWluLCBtYXg6IG1heCB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGdldCB0aGUgd2lkdGggb2YgYWxsIHRyZWVzXG4gICAgICAgIHZhciBnZXRUcmVlU2l6ZXMgPSBmdW5jdGlvbiBnZXRUcmVlU2l6ZXMoKSB7XG4gICAgICAgICAgdmFyIHRyZWVXaWR0aHMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBfdGhpczIudHJlZUluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIHRyZWVXaWR0aHMucHVzaChnZXRUcmVlU2l6ZShpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cmVlV2lkdGhzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGdldCBhIG1hcCBvZiBhbGwgbm9kZXMgaW4gdGhpcyBicmFuY2hcbiAgICAgICAgdmFyIGdldEJyYW5jaE5vZGVzID0gZnVuY3Rpb24gZ2V0QnJhbmNoTm9kZXMoc291cmNlLCBtYXApIHtcbiAgICAgICAgICBtYXBbc291cmNlLmlkXSA9IHRydWU7XG4gICAgICAgICAgaWYgKF90aGlzMi5oaWVyYXJjaGljYWxDaGlsZHJlblJlZmVyZW5jZVtzb3VyY2UuaWRdKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBfdGhpczIuaGllcmFyY2hpY2FsQ2hpbGRyZW5SZWZlcmVuY2Vbc291cmNlLmlkXTtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBnZXRCcmFuY2hOb2RlcyhfdGhpczIuYm9keS5ub2Rlc1tjaGlsZHJlbltpXV0sIG1hcCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZ2V0IGEgbWluIG1heCB3aWR0aCBhcyB3ZWxsIGFzIHRoZSBtYXhpbXVtIG1vdmVtZW50IHNwYWNlIGl0IGhhcyBvbiBlaXRoZXIgc2lkZXNcbiAgICAgICAgLy8gd2UgdXNlIG1pbiBtYXggdGVybWlub2xvZ3kgYmVjYXVzZSB3aWR0aCBhbmQgaGVpZ2h0IGNhbiBpbnRlcmNoYW5nZSBkZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbGF5b3V0XG4gICAgICAgIHZhciBnZXRCcmFuY2hCb3VuZGFyeSA9IGZ1bmN0aW9uIGdldEJyYW5jaEJvdW5kYXJ5KGJyYW5jaE1hcCkge1xuICAgICAgICAgIHZhciBtYXhMZXZlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMWU5O1xuXG4gICAgICAgICAgdmFyIG1pblNwYWNlID0gMWU5O1xuICAgICAgICAgIHZhciBtYXhTcGFjZSA9IDFlOTtcbiAgICAgICAgICB2YXIgbWluID0gMWU5O1xuICAgICAgICAgIHZhciBtYXggPSAtMWU5O1xuICAgICAgICAgIGZvciAodmFyIGJyYW5jaE5vZGUgaW4gYnJhbmNoTWFwKSB7XG4gICAgICAgICAgICBpZiAoYnJhbmNoTWFwLmhhc093blByb3BlcnR5KGJyYW5jaE5vZGUpKSB7XG4gICAgICAgICAgICAgIHZhciBub2RlID0gX3RoaXMyLmJvZHkubm9kZXNbYnJhbmNoTm9kZV07XG4gICAgICAgICAgICAgIHZhciBsZXZlbCA9IF90aGlzMi5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZS5pZF07XG4gICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IF90aGlzMi5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkobm9kZSk7XG5cbiAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBzcGFjZSBhcm91bmQgdGhlIG5vZGUuXG5cbiAgICAgICAgICAgICAgdmFyIF9nZXRTcGFjZUFyb3VuZE5vZGUyID0gX3RoaXMyLl9nZXRTcGFjZUFyb3VuZE5vZGUobm9kZSwgYnJhbmNoTWFwKSxcbiAgICAgICAgICAgICAgICAgIF9nZXRTcGFjZUFyb3VuZE5vZGUzID0gX3NsaWNlZFRvQXJyYXkoX2dldFNwYWNlQXJvdW5kTm9kZTIsIDIpLFxuICAgICAgICAgICAgICAgICAgbWluU3BhY2VOb2RlID0gX2dldFNwYWNlQXJvdW5kTm9kZTNbMF0sXG4gICAgICAgICAgICAgICAgICBtYXhTcGFjZU5vZGUgPSBfZ2V0U3BhY2VBcm91bmROb2RlM1sxXTtcblxuICAgICAgICAgICAgICBtaW5TcGFjZSA9IE1hdGgubWluKG1pblNwYWNlTm9kZSwgbWluU3BhY2UpO1xuICAgICAgICAgICAgICBtYXhTcGFjZSA9IE1hdGgubWluKG1heFNwYWNlTm9kZSwgbWF4U3BhY2UpO1xuXG4gICAgICAgICAgICAgIC8vIHRoZSB3aWR0aCBpcyBvbmx5IHJlbGV2YW50IGZvciB0aGUgbGV2ZWxzIHR3byBub2RlcyBoYXZlIGluIGNvbW1vbi4gVGhpcyBpcyB3aHkgd2UgZmlsdGVyIG9uIHRoaXMuXG4gICAgICAgICAgICAgIGlmIChsZXZlbCA8PSBtYXhMZXZlbCkge1xuICAgICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKHBvc2l0aW9uLCBtaW4pO1xuICAgICAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KHBvc2l0aW9uLCBtYXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFttaW4sIG1heCwgbWluU3BhY2UsIG1heFNwYWNlXTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBnZXQgdGhlIG1heGltdW0gbGV2ZWwgb2YgYSBicmFuY2guXG4gICAgICAgIHZhciBnZXRNYXhMZXZlbCA9IGZ1bmN0aW9uIGdldE1heExldmVsKG5vZGVJZCkge1xuICAgICAgICAgIHZhciBsZXZlbCA9IF90aGlzMi5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZUlkXTtcbiAgICAgICAgICBpZiAoX3RoaXMyLmhpZXJhcmNoaWNhbENoaWxkcmVuUmVmZXJlbmNlW25vZGVJZF0pIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IF90aGlzMi5oaWVyYXJjaGljYWxDaGlsZHJlblJlZmVyZW5jZVtub2RlSWRdO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldmVsID0gTWF0aC5tYXgobGV2ZWwsIGdldE1heExldmVsKGNoaWxkcmVuW2ldKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxldmVsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGNoZWNrIHdoYXQgdGhlIG1heGltdW0gbGV2ZWwgaXMgdGhlc2Ugbm9kZXMgaGF2ZSBpbiBjb21tb24uXG4gICAgICAgIHZhciBnZXRDb2xsaXNpb25MZXZlbCA9IGZ1bmN0aW9uIGdldENvbGxpc2lvbkxldmVsKG5vZGUxLCBub2RlMikge1xuICAgICAgICAgIHZhciBtYXhMZXZlbDEgPSBnZXRNYXhMZXZlbChub2RlMS5pZCk7XG4gICAgICAgICAgdmFyIG1heExldmVsMiA9IGdldE1heExldmVsKG5vZGUyLmlkKTtcbiAgICAgICAgICByZXR1cm4gTWF0aC5taW4obWF4TGV2ZWwxLCBtYXhMZXZlbDIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHR3byBub2RlcyBoYXZlIHRoZSBzYW1lIHBhcmVudChzKVxuICAgICAgICB2YXIgaGFzU2FtZVBhcmVudCA9IGZ1bmN0aW9uIGhhc1NhbWVQYXJlbnQobm9kZTEsIG5vZGUyKSB7XG4gICAgICAgICAgdmFyIHBhcmVudHMxID0gX3RoaXMyLmhpZXJhcmNoaWNhbFBhcmVudFJlZmVyZW5jZVtub2RlMS5pZF07XG4gICAgICAgICAgdmFyIHBhcmVudHMyID0gX3RoaXMyLmhpZXJhcmNoaWNhbFBhcmVudFJlZmVyZW5jZVtub2RlMi5pZF07XG4gICAgICAgICAgaWYgKHBhcmVudHMxID09PSB1bmRlZmluZWQgfHwgcGFyZW50czIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50czEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFyZW50czIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgaWYgKHBhcmVudHMxW2ldID09IHBhcmVudHMyW2pdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGNvbmRlbnNlIGVsZW1lbnRzLiBUaGVzZSBjYW4gYmUgbm9kZXMgb3IgYnJhbmNoZXMgZGVwZW5kaW5nIG9uIHRoZSBjYWxsYmFjay5cbiAgICAgICAgdmFyIHNoaWZ0RWxlbWVudHNDbG9zZXIgPSBmdW5jdGlvbiBzaGlmdEVsZW1lbnRzQ2xvc2VyKGNhbGxiYWNrLCBsZXZlbHMsIGNlbnRlclBhcmVudHMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxldmVsID0gbGV2ZWxzW2ldO1xuICAgICAgICAgICAgdmFyIGxldmVsTm9kZXMgPSBfdGhpczIuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdO1xuICAgICAgICAgICAgaWYgKGxldmVsTm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxldmVsTm9kZXMubGVuZ3RoIC0gMTsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1NhbWVQYXJlbnQobGV2ZWxOb2Rlc1tqXSwgbGV2ZWxOb2Rlc1tqICsgMV0pID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoX3RoaXMyLmhpZXJhcmNoaWNhbFRyZWVzW2xldmVsTm9kZXNbal0uaWRdID09PSBfdGhpczIuaGllcmFyY2hpY2FsVHJlZXNbbGV2ZWxOb2Rlc1tqICsgMV0uaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGxldmVsTm9kZXNbal0sIGxldmVsTm9kZXNbaiArIDFdLCBjZW50ZXJQYXJlbnRzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gY2FsbGJhY2sgZm9yIHNoaWZ0aW5nIGJyYW5jaGVzXG4gICAgICAgIHZhciBicmFuY2hTaGlmdENhbGxiYWNrID0gZnVuY3Rpb24gYnJhbmNoU2hpZnRDYWxsYmFjayhub2RlMSwgbm9kZTIpIHtcbiAgICAgICAgICB2YXIgY2VudGVyUGFyZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgICAgIC8vd2luZG93LkNBTExCQUNLUy5wdXNoKCgpID0+IHtcbiAgICAgICAgICB2YXIgcG9zMSA9IF90aGlzMi5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkobm9kZTEpO1xuICAgICAgICAgIHZhciBwb3MyID0gX3RoaXMyLl9nZXRQb3NpdGlvbkZvckhpZXJhcmNoeShub2RlMik7XG4gICAgICAgICAgdmFyIGRpZmZBYnMgPSBNYXRoLmFicyhwb3MyIC0gcG9zMSk7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcIk5PVyBDSEVjS0lORzpcIiwgbm9kZTEuaWQsIG5vZGUyLmlkLCBkaWZmQWJzKTtcbiAgICAgICAgICBpZiAoZGlmZkFicyA+IF90aGlzMi5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZykge1xuICAgICAgICAgICAgdmFyIGJyYW5jaE5vZGVzMSA9IHt9O2JyYW5jaE5vZGVzMVtub2RlMS5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGJyYW5jaE5vZGVzMiA9IHt9O2JyYW5jaE5vZGVzMltub2RlMi5pZF0gPSB0cnVlO1xuXG4gICAgICAgICAgICBnZXRCcmFuY2hOb2Rlcyhub2RlMSwgYnJhbmNoTm9kZXMxKTtcbiAgICAgICAgICAgIGdldEJyYW5jaE5vZGVzKG5vZGUyLCBicmFuY2hOb2RlczIpO1xuXG4gICAgICAgICAgICAvLyBjaGVjayB0aGUgbGFyZ2VzdCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBicmFuY2hlc1xuICAgICAgICAgICAgdmFyIG1heExldmVsID0gZ2V0Q29sbGlzaW9uTGV2ZWwobm9kZTEsIG5vZGUyKTtcblxuICAgICAgICAgICAgdmFyIF9nZXRCcmFuY2hCb3VuZGFyeSA9IGdldEJyYW5jaEJvdW5kYXJ5KGJyYW5jaE5vZGVzMSwgbWF4TGV2ZWwpLFxuICAgICAgICAgICAgICAgIF9nZXRCcmFuY2hCb3VuZGFyeTIgPSBfc2xpY2VkVG9BcnJheShfZ2V0QnJhbmNoQm91bmRhcnksIDQpLFxuICAgICAgICAgICAgICAgIG1pbjEgPSBfZ2V0QnJhbmNoQm91bmRhcnkyWzBdLFxuICAgICAgICAgICAgICAgIG1heDEgPSBfZ2V0QnJhbmNoQm91bmRhcnkyWzFdLFxuICAgICAgICAgICAgICAgIG1pblNwYWNlMSA9IF9nZXRCcmFuY2hCb3VuZGFyeTJbMl0sXG4gICAgICAgICAgICAgICAgbWF4U3BhY2UxID0gX2dldEJyYW5jaEJvdW5kYXJ5MlszXTtcblxuICAgICAgICAgICAgdmFyIF9nZXRCcmFuY2hCb3VuZGFyeTMgPSBnZXRCcmFuY2hCb3VuZGFyeShicmFuY2hOb2RlczIsIG1heExldmVsKSxcbiAgICAgICAgICAgICAgICBfZ2V0QnJhbmNoQm91bmRhcnk0ID0gX3NsaWNlZFRvQXJyYXkoX2dldEJyYW5jaEJvdW5kYXJ5MywgNCksXG4gICAgICAgICAgICAgICAgbWluMiA9IF9nZXRCcmFuY2hCb3VuZGFyeTRbMF0sXG4gICAgICAgICAgICAgICAgbWF4MiA9IF9nZXRCcmFuY2hCb3VuZGFyeTRbMV0sXG4gICAgICAgICAgICAgICAgbWluU3BhY2UyID0gX2dldEJyYW5jaEJvdW5kYXJ5NFsyXSxcbiAgICAgICAgICAgICAgICBtYXhTcGFjZTIgPSBfZ2V0QnJhbmNoQm91bmRhcnk0WzNdO1xuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKG5vZGUxLmlkLCBnZXRCcmFuY2hCb3VuZGFyeShicmFuY2hOb2RlczEsIG1heExldmVsKSwgbm9kZTIuaWQsIGdldEJyYW5jaEJvdW5kYXJ5KGJyYW5jaE5vZGVzMiwgbWF4TGV2ZWwpLCBtYXhMZXZlbCk7XG5cblxuICAgICAgICAgICAgdmFyIGRpZmZCcmFuY2ggPSBNYXRoLmFicyhtYXgxIC0gbWluMik7XG4gICAgICAgICAgICBpZiAoZGlmZkJyYW5jaCA+IF90aGlzMi5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZykge1xuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gbWF4MSAtIG1pbjIgKyBfdGhpczIub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmc7XG4gICAgICAgICAgICAgIGlmIChvZmZzZXQgPCAtbWluU3BhY2UyICsgX3RoaXMyLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gLW1pblNwYWNlMiArIF90aGlzMi5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZztcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiUkVTRVRUSU5HIE9GRlNFVFwiLCBtYXgxIC0gbWluMiArIHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcsIC1taW5TcGFjZTIsIG9mZnNldCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiU0hJRlRJTkdcIiwgbm9kZTIuaWQsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgX3RoaXMyLl9zaGlmdEJsb2NrKG5vZGUyLmlkLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIHN0aWxsU2hpZnRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNlbnRlclBhcmVudCA9PT0gdHJ1ZSkgX3RoaXMyLl9jZW50ZXJQYXJlbnQobm9kZTIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7fSlcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbWluaW1pemVFZGdlTGVuZ3RoID0gZnVuY3Rpb24gbWluaW1pemVFZGdlTGVuZ3RoKGl0ZXJhdGlvbnMsIG5vZGUpIHtcbiAgICAgICAgICAvL3dpbmRvdy5DQUxMQkFDS1MucHVzaCgoKSA9PiB7XG4gICAgICAgICAgLy8gIGNvbnNvbGUubG9nKFwidHNcIixub2RlLmlkKTtcbiAgICAgICAgICB2YXIgbm9kZUlkID0gbm9kZS5pZDtcbiAgICAgICAgICB2YXIgYWxsRWRnZXMgPSBub2RlLmVkZ2VzO1xuICAgICAgICAgIHZhciBub2RlTGV2ZWwgPSBfdGhpczIuaGllcmFyY2hpY2FsTGV2ZWxzW25vZGUuaWRdO1xuXG4gICAgICAgICAgLy8gZ2F0aGVyIGNvbnN0YW50c1xuICAgICAgICAgIHZhciBDMiA9IF90aGlzMi5vcHRpb25zLmhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24gKiBfdGhpczIub3B0aW9ucy5oaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uO1xuICAgICAgICAgIHZhciByZWZlcmVuY2VOb2RlcyA9IHt9O1xuICAgICAgICAgIHZhciBhYm92ZUVkZ2VzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVkZ2UgPSBhbGxFZGdlc1tpXTtcbiAgICAgICAgICAgIGlmIChlZGdlLnRvSWQgIT0gZWRnZS5mcm9tSWQpIHtcbiAgICAgICAgICAgICAgdmFyIG90aGVyTm9kZSA9IGVkZ2UudG9JZCA9PSBub2RlSWQgPyBlZGdlLmZyb20gOiBlZGdlLnRvO1xuICAgICAgICAgICAgICByZWZlcmVuY2VOb2Rlc1thbGxFZGdlc1tpXS5pZF0gPSBvdGhlck5vZGU7XG4gICAgICAgICAgICAgIGlmIChfdGhpczIuaGllcmFyY2hpY2FsTGV2ZWxzW290aGVyTm9kZS5pZF0gPCBub2RlTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBhYm92ZUVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBkaWZmZXJlbnRpYXRlZCBzdW0gb2YgbGVuZ3RocyBiYXNlZCBvbiBvbmx5IG1vdmluZyBvbmUgbm9kZSBvdmVyIG9uZSBheGlzXG4gICAgICAgICAgdmFyIGdldEZ4ID0gZnVuY3Rpb24gZ2V0RngocG9pbnQsIGVkZ2VzKSB7XG4gICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGVkZ2VzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgICAgaWYgKHJlZmVyZW5jZU5vZGVzW2VkZ2VzW19pMl0uaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IF90aGlzMi5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkocmVmZXJlbmNlTm9kZXNbZWRnZXNbX2kyXS5pZF0pIC0gcG9pbnQ7XG4gICAgICAgICAgICAgICAgc3VtICs9IGEgLyBNYXRoLnNxcnQoYSAqIGEgKyBDMik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIGRvdWJseSBkaWZmZXJlbnRpYXRlZCBzdW0gb2YgbGVuZ3RocyBiYXNlZCBvbiBvbmx5IG1vdmluZyBvbmUgbm9kZSBvdmVyIG9uZSBheGlzXG4gICAgICAgICAgdmFyIGdldERGeCA9IGZ1bmN0aW9uIGdldERGeChwb2ludCwgZWRnZXMpIHtcbiAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgZWRnZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICAgICAgICBpZiAocmVmZXJlbmNlTm9kZXNbZWRnZXNbX2kzXS5pZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBhID0gX3RoaXMyLl9nZXRQb3NpdGlvbkZvckhpZXJhcmNoeShyZWZlcmVuY2VOb2Rlc1tlZGdlc1tfaTNdLmlkXSkgLSBwb2ludDtcbiAgICAgICAgICAgICAgICBzdW0gLT0gQzIgKiBNYXRoLnBvdyhhICogYSArIEMyLCAtMS41KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIGdldEd1ZXNzID0gZnVuY3Rpb24gZ2V0R3Vlc3MoaXRlcmF0aW9ucywgZWRnZXMpIHtcbiAgICAgICAgICAgIHZhciBndWVzcyA9IF90aGlzMi5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkobm9kZSk7XG4gICAgICAgICAgICAvLyBOZXd0b24ncyBtZXRob2QgZm9yIG9wdGltaXphdGlvblxuICAgICAgICAgICAgdmFyIGd1ZXNzTWFwID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBpdGVyYXRpb25zOyBfaTQrKykge1xuICAgICAgICAgICAgICB2YXIgZnggPSBnZXRGeChndWVzcywgZWRnZXMpO1xuICAgICAgICAgICAgICB2YXIgZGZ4ID0gZ2V0REZ4KGd1ZXNzLCBlZGdlcyk7XG5cbiAgICAgICAgICAgICAgLy8gd2UgbGltaXQgdGhlIG1vdmVtZW50IHRvIGF2b2lkIGluc3RhYmlsaXR5LlxuICAgICAgICAgICAgICB2YXIgbGltaXQgPSA0MDtcbiAgICAgICAgICAgICAgdmFyIHJhdGlvID0gTWF0aC5tYXgoLWxpbWl0LCBNYXRoLm1pbihsaW1pdCwgTWF0aC5yb3VuZChmeCAvIGRmeCkpKTtcbiAgICAgICAgICAgICAgZ3Vlc3MgPSBndWVzcyAtIHJhdGlvO1xuICAgICAgICAgICAgICAvLyByZWR1Y2UgZHVwbGljYXRlc1xuICAgICAgICAgICAgICBpZiAoZ3Vlc3NNYXBbZ3Vlc3NdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBndWVzc01hcFtndWVzc10gPSBfaTQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ3Vlc3M7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBtb3ZlQnJhbmNoID0gZnVuY3Rpb24gbW92ZUJyYW5jaChndWVzcykge1xuICAgICAgICAgICAgLy8gcG9zaXRpb24gbm9kZSBpZiB0aGVyZSBpcyBzcGFjZVxuICAgICAgICAgICAgdmFyIG5vZGVQb3NpdGlvbiA9IF90aGlzMi5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkobm9kZSk7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIG1vdmFibGUgYXJlYSBvZiB0aGUgYnJhbmNoXG4gICAgICAgICAgICBpZiAoYnJhbmNoZXNbbm9kZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgYnJhbmNoTm9kZXMgPSB7fTtcbiAgICAgICAgICAgICAgYnJhbmNoTm9kZXNbbm9kZS5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICBnZXRCcmFuY2hOb2Rlcyhub2RlLCBicmFuY2hOb2Rlcyk7XG4gICAgICAgICAgICAgIGJyYW5jaGVzW25vZGUuaWRdID0gYnJhbmNoTm9kZXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfZ2V0QnJhbmNoQm91bmRhcnk1ID0gZ2V0QnJhbmNoQm91bmRhcnkoYnJhbmNoZXNbbm9kZS5pZF0pLFxuICAgICAgICAgICAgICAgIF9nZXRCcmFuY2hCb3VuZGFyeTYgPSBfc2xpY2VkVG9BcnJheShfZ2V0QnJhbmNoQm91bmRhcnk1LCA0KSxcbiAgICAgICAgICAgICAgICBtaW5CcmFuY2ggPSBfZ2V0QnJhbmNoQm91bmRhcnk2WzBdLFxuICAgICAgICAgICAgICAgIG1heEJyYW5jaCA9IF9nZXRCcmFuY2hCb3VuZGFyeTZbMV0sXG4gICAgICAgICAgICAgICAgbWluU3BhY2VCcmFuY2ggPSBfZ2V0QnJhbmNoQm91bmRhcnk2WzJdLFxuICAgICAgICAgICAgICAgIG1heFNwYWNlQnJhbmNoID0gX2dldEJyYW5jaEJvdW5kYXJ5NlszXTtcblxuICAgICAgICAgICAgdmFyIGRpZmYgPSBndWVzcyAtIG5vZGVQb3NpdGlvbjtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgYXJlIGFsbG93ZWQgdG8gbW92ZSB0aGUgbm9kZTpcbiAgICAgICAgICAgIHZhciBicmFuY2hPZmZzZXQgPSAwO1xuICAgICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICAgIGJyYW5jaE9mZnNldCA9IE1hdGgubWluKGRpZmYsIG1heFNwYWNlQnJhbmNoIC0gX3RoaXMyLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlmZiA8IDApIHtcbiAgICAgICAgICAgICAgYnJhbmNoT2Zmc2V0ID0gLU1hdGgubWluKC1kaWZmLCBtaW5TcGFjZUJyYW5jaCAtIF90aGlzMi5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChicmFuY2hPZmZzZXQgIT0gMCkge1xuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwibW92aW5nIGJyYW5jaDpcIixicmFuY2hPZmZzZXQsIG1heFNwYWNlQnJhbmNoLCBtaW5TcGFjZUJyYW5jaClcbiAgICAgICAgICAgICAgX3RoaXMyLl9zaGlmdEJsb2NrKG5vZGUuaWQsIGJyYW5jaE9mZnNldCk7XG4gICAgICAgICAgICAgIC8vdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG4gICAgICAgICAgICAgIHN0aWxsU2hpZnRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgbW92ZU5vZGUgPSBmdW5jdGlvbiBtb3ZlTm9kZShndWVzcykge1xuICAgICAgICAgICAgdmFyIG5vZGVQb3NpdGlvbiA9IF90aGlzMi5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkobm9kZSk7XG5cbiAgICAgICAgICAgIC8vIHBvc2l0aW9uIG5vZGUgaWYgdGhlcmUgaXMgc3BhY2VcblxuICAgICAgICAgICAgdmFyIF9nZXRTcGFjZUFyb3VuZE5vZGU0ID0gX3RoaXMyLl9nZXRTcGFjZUFyb3VuZE5vZGUobm9kZSksXG4gICAgICAgICAgICAgICAgX2dldFNwYWNlQXJvdW5kTm9kZTUgPSBfc2xpY2VkVG9BcnJheShfZ2V0U3BhY2VBcm91bmROb2RlNCwgMiksXG4gICAgICAgICAgICAgICAgbWluU3BhY2UgPSBfZ2V0U3BhY2VBcm91bmROb2RlNVswXSxcbiAgICAgICAgICAgICAgICBtYXhTcGFjZSA9IF9nZXRTcGFjZUFyb3VuZE5vZGU1WzFdO1xuXG4gICAgICAgICAgICB2YXIgZGlmZiA9IGd1ZXNzIC0gbm9kZVBvc2l0aW9uO1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgYXJlIGFsbG93ZWQgdG8gbW92ZSB0aGUgbm9kZTpcbiAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvbiA9IG5vZGVQb3NpdGlvbjtcbiAgICAgICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgICBuZXdQb3NpdGlvbiA9IE1hdGgubWluKG5vZGVQb3NpdGlvbiArIChtYXhTcGFjZSAtIF90aGlzMi5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyksIGd1ZXNzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlmZiA8IDApIHtcbiAgICAgICAgICAgICAgbmV3UG9zaXRpb24gPSBNYXRoLm1heChub2RlUG9zaXRpb24gLSAobWluU3BhY2UgLSBfdGhpczIub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpLCBndWVzcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZXdQb3NpdGlvbiAhPT0gbm9kZVBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJtb3ZpbmcgTm9kZTpcIixkaWZmLCBtaW5TcGFjZSwgbWF4U3BhY2UpO1xuICAgICAgICAgICAgICBfdGhpczIuX3NldFBvc2l0aW9uRm9ySGllcmFyY2h5KG5vZGUsIG5ld1Bvc2l0aW9uLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICAgICAgICAvL3RoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgICAgICAgICAgICBzdGlsbFNoaWZ0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIGd1ZXNzID0gZ2V0R3Vlc3MoaXRlcmF0aW9ucywgYWJvdmVFZGdlcyk7XG4gICAgICAgICAgbW92ZUJyYW5jaChndWVzcyk7XG4gICAgICAgICAgZ3Vlc3MgPSBnZXRHdWVzcyhpdGVyYXRpb25zLCBhbGxFZGdlcyk7XG4gICAgICAgICAgbW92ZU5vZGUoZ3Vlc3MpO1xuICAgICAgICAgIC8vfSlcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBtZXRob2QgdG8gcmVtb3ZlIHdoaXRlc3BhY2UgYmV0d2VlbiBicmFuY2hlcy4gQmVjYXVzZSB3ZSBkbyBib3R0b20gdXAsIHdlIGNhbiBjZW50ZXIgdGhlIHBhcmVudHMuXG4gICAgICAgIHZhciBtaW5pbWl6ZUVkZ2VMZW5ndGhCb3R0b21VcCA9IGZ1bmN0aW9uIG1pbmltaXplRWRnZUxlbmd0aEJvdHRvbVVwKGl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICB2YXIgbGV2ZWxzID0gT2JqZWN0LmtleXMoX3RoaXMyLmRpc3RyaWJ1dGlvbk9yZGVyaW5nKTtcbiAgICAgICAgICBsZXZlbHMgPSBsZXZlbHMucmV2ZXJzZSgpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICBzdGlsbFNoaWZ0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbal07XG4gICAgICAgICAgICAgIHZhciBsZXZlbE5vZGVzID0gX3RoaXMyLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsZXZlbE5vZGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgbWluaW1pemVFZGdlTGVuZ3RoKDEwMDAsIGxldmVsTm9kZXNba10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RpbGxTaGlmdGluZyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiRklOSVNIRUQgbWluaW1pemVFZGdlTGVuZ3RoQm90dG9tVXAgSU4gXCIgKyBpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIG1ldGhvZCB0byByZW1vdmUgd2hpdGVzcGFjZSBiZXR3ZWVuIGJyYW5jaGVzLiBCZWNhdXNlIHdlIGRvIGJvdHRvbSB1cCwgd2UgY2FuIGNlbnRlciB0aGUgcGFyZW50cy5cbiAgICAgICAgdmFyIHNoaWZ0QnJhbmNoZXNDbG9zZXJCb3R0b21VcCA9IGZ1bmN0aW9uIHNoaWZ0QnJhbmNoZXNDbG9zZXJCb3R0b21VcChpdGVyYXRpb25zKSB7XG4gICAgICAgICAgdmFyIGxldmVscyA9IE9iamVjdC5rZXlzKF90aGlzMi5kaXN0cmlidXRpb25PcmRlcmluZyk7XG4gICAgICAgICAgbGV2ZWxzID0gbGV2ZWxzLnJldmVyc2UoKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgc3RpbGxTaGlmdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgc2hpZnRFbGVtZW50c0Nsb3NlcihicmFuY2hTaGlmdENhbGxiYWNrLCBsZXZlbHMsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHN0aWxsU2hpZnRpbmcgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkZJTklTSEVEIHNoaWZ0QnJhbmNoZXNDbG9zZXJCb3R0b21VcCBJTiBcIiArIChpKzEpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGNlbnRlciBhbGwgcGFyZW50c1xuICAgICAgICB2YXIgY2VudGVyQWxsUGFyZW50cyA9IGZ1bmN0aW9uIGNlbnRlckFsbFBhcmVudHMoKSB7XG4gICAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIF90aGlzMi5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMyLmJvZHkubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkgX3RoaXMyLl9jZW50ZXJQYXJlbnQoX3RoaXMyLmJvZHkubm9kZXNbbm9kZUlkXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGNlbnRlciBhbGwgcGFyZW50c1xuICAgICAgICB2YXIgY2VudGVyQWxsUGFyZW50c0JvdHRvbVVwID0gZnVuY3Rpb24gY2VudGVyQWxsUGFyZW50c0JvdHRvbVVwKCkge1xuICAgICAgICAgIHZhciBsZXZlbHMgPSBPYmplY3Qua2V5cyhfdGhpczIuZGlzdHJpYnV0aW9uT3JkZXJpbmcpO1xuICAgICAgICAgIGxldmVscyA9IGxldmVscy5yZXZlcnNlKCk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tpXTtcbiAgICAgICAgICAgIHZhciBsZXZlbE5vZGVzID0gX3RoaXMyLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGV2ZWxOb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBfdGhpczIuX2NlbnRlclBhcmVudChsZXZlbE5vZGVzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gdGhlIGFjdHVhbCB3b3JrIGlzIGRvbmUgaGVyZS5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuYmxvY2tTaGlmdGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHNoaWZ0QnJhbmNoZXNDbG9zZXJCb3R0b21VcCg1KTtcbiAgICAgICAgICBjZW50ZXJBbGxQYXJlbnRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtaW5pbWl6ZSBlZGdlIGxlbmd0aFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5lZGdlTWluaW1pemF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgbWluaW1pemVFZGdlTGVuZ3RoQm90dG9tVXAoMjApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwucGFyZW50Q2VudHJhbGl6YXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICBjZW50ZXJBbGxQYXJlbnRzQm90dG9tVXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNoaWZ0VHJlZXMoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGdpdmVzIHRoZSBzcGFjZSBhcm91bmQgdGhlIG5vZGUuIElGIGEgbWFwIGlzIHN1cHBsaWVkLCBpdCB3aWxsIG9ubHkgY2hlY2sgYWdhaW5zdCBub2RlcyBOT1QgaW4gdGhlIG1hcC5cbiAgICAgICAqIFRoaXMgaXMgdXNlZCB0byBvbmx5IGdldCB0aGUgZGlzdGFuY2VzIHRvIG5vZGVzIG91dHNpZGUgb2YgYSBicmFuY2guXG4gICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICogQHBhcmFtIG1hcFxuICAgICAgICogQHJldHVybnMgeypbXX1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXRTcGFjZUFyb3VuZE5vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTcGFjZUFyb3VuZE5vZGUobm9kZSwgbWFwKSB7XG4gICAgICAgIHZhciB1c2VNYXAgPSB0cnVlO1xuICAgICAgICBpZiAobWFwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB1c2VNYXAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmhpZXJhcmNoaWNhbExldmVsc1tub2RlLmlkXTtcbiAgICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmRpc3RyaWJ1dGlvbkluZGV4W25vZGUuaWRdO1xuICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX2dldFBvc2l0aW9uRm9ySGllcmFyY2h5KG5vZGUpO1xuICAgICAgICAgIHZhciBtaW5TcGFjZSA9IDFlOTtcbiAgICAgICAgICB2YXIgbWF4U3BhY2UgPSAxZTk7XG4gICAgICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICB2YXIgcHJldk5vZGUgPSB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXVtpbmRleCAtIDFdO1xuICAgICAgICAgICAgaWYgKHVzZU1hcCA9PT0gdHJ1ZSAmJiBtYXBbcHJldk5vZGUuaWRdID09PSB1bmRlZmluZWQgfHwgdXNlTWFwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICB2YXIgcHJldlBvcyA9IHRoaXMuX2dldFBvc2l0aW9uRm9ySGllcmFyY2h5KHByZXZOb2RlKTtcbiAgICAgICAgICAgICAgbWluU3BhY2UgPSBwb3NpdGlvbiAtIHByZXZQb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGluZGV4ICE9IHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHZhciBuZXh0Tm9kZSA9IHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdW2luZGV4ICsgMV07XG4gICAgICAgICAgICBpZiAodXNlTWFwID09PSB0cnVlICYmIG1hcFtuZXh0Tm9kZS5pZF0gPT09IHVuZGVmaW5lZCB8fCB1c2VNYXAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHZhciBuZXh0UG9zID0gdGhpcy5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkobmV4dE5vZGUpO1xuICAgICAgICAgICAgICBtYXhTcGFjZSA9IE1hdGgubWluKG1heFNwYWNlLCBuZXh0UG9zIC0gcG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbbWluU3BhY2UsIG1heFNwYWNlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogV2UgdXNlIHRoaXMgbWV0aG9kIHRvIGNlbnRlciBhIHBhcmVudCBub2RlIGFuZCBjaGVjayBpZiBpdCBkb2VzIG5vdCBjcm9zcyBvdGhlciBub2RlcyB3aGVuIGl0IGRvZXMuXG4gICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NlbnRlclBhcmVudCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NlbnRlclBhcmVudChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLmhpZXJhcmNoaWNhbFBhcmVudFJlZmVyZW5jZVtub2RlLmlkXSkge1xuICAgICAgICAgIHZhciBwYXJlbnRzID0gdGhpcy5oaWVyYXJjaGljYWxQYXJlbnRSZWZlcmVuY2Vbbm9kZS5pZF07XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50SWQgPSBwYXJlbnRzW2ldO1xuICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSB0aGlzLmJvZHkubm9kZXNbcGFyZW50SWRdO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGllcmFyY2hpY2FsQ2hpbGRyZW5SZWZlcmVuY2VbcGFyZW50SWRdKSB7XG4gICAgICAgICAgICAgIC8vIGdldCB0aGUgcmFuZ2Ugb2YgdGhlIGNoaWxkcmVuXG4gICAgICAgICAgICAgIHZhciBtaW5Qb3MgPSAxZTk7XG4gICAgICAgICAgICAgIHZhciBtYXhQb3MgPSAtMWU5O1xuICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmhpZXJhcmNoaWNhbENoaWxkcmVuUmVmZXJlbmNlW3BhcmVudElkXTtcbiAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBjaGlsZHJlbi5sZW5ndGg7IF9pNSsrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gdGhpcy5ib2R5Lm5vZGVzW2NoaWxkcmVuW19pNV1dO1xuICAgICAgICAgICAgICAgICAgbWluUG9zID0gTWF0aC5taW4obWluUG9zLCB0aGlzLl9nZXRQb3NpdGlvbkZvckhpZXJhcmNoeShjaGlsZE5vZGUpKTtcbiAgICAgICAgICAgICAgICAgIG1heFBvcyA9IE1hdGgubWF4KG1heFBvcywgdGhpcy5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkoY2hpbGROb2RlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkocGFyZW50Tm9kZSk7XG5cbiAgICAgICAgICAgICAgdmFyIF9nZXRTcGFjZUFyb3VuZE5vZGU2ID0gdGhpcy5fZ2V0U3BhY2VBcm91bmROb2RlKHBhcmVudE5vZGUpLFxuICAgICAgICAgICAgICAgICAgX2dldFNwYWNlQXJvdW5kTm9kZTcgPSBfc2xpY2VkVG9BcnJheShfZ2V0U3BhY2VBcm91bmROb2RlNiwgMiksXG4gICAgICAgICAgICAgICAgICBtaW5TcGFjZSA9IF9nZXRTcGFjZUFyb3VuZE5vZGU3WzBdLFxuICAgICAgICAgICAgICAgICAgbWF4U3BhY2UgPSBfZ2V0U3BhY2VBcm91bmROb2RlN1sxXTtcblxuICAgICAgICAgICAgICB2YXIgbmV3UG9zaXRpb24gPSAwLjUgKiAobWluUG9zICsgbWF4UG9zKTtcbiAgICAgICAgICAgICAgdmFyIGRpZmYgPSBwb3NpdGlvbiAtIG5ld1Bvc2l0aW9uO1xuICAgICAgICAgICAgICBpZiAoZGlmZiA8IDAgJiYgTWF0aC5hYnMoZGlmZikgPCBtYXhTcGFjZSAtIHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcgfHwgZGlmZiA+IDAgJiYgTWF0aC5hYnMoZGlmZikgPCBtaW5TcGFjZSAtIHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQb3NpdGlvbkZvckhpZXJhcmNoeShwYXJlbnROb2RlLCBuZXdQb3NpdGlvbiwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gcGxhY2VzIHRoZSBub2RlcyBvbiB0aGUgY2FudmFzIGJhc2VkIG9uIHRoZSBoaWVyYXJjaGlhbCBkaXN0cmlidXRpb24uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRpc3RyaWJ1dGlvbiB8IG9idGFpbmVkIGJ5IHRoZSBmdW5jdGlvbiB0aGlzLl9nZXREaXN0cmlidXRpb24oKVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3BsYWNlTm9kZXNCeUhpZXJhcmNoeScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3BsYWNlTm9kZXNCeUhpZXJhcmNoeShkaXN0cmlidXRpb24pIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbmVkTm9kZXMgPSB7fTtcbiAgICAgICAgLy8gc3RhcnQgcGxhY2luZyBhbGwgdGhlIGxldmVsIDAgbm9kZXMgZmlyc3QuIFRoZW4gcmVjdXJzaXZlbHkgcG9zaXRpb24gdGhlaXIgYnJhbmNoZXMuXG4gICAgICAgIGZvciAodmFyIGxldmVsIGluIGRpc3RyaWJ1dGlvbikge1xuICAgICAgICAgIGlmIChkaXN0cmlidXRpb24uaGFzT3duUHJvcGVydHkobGV2ZWwpKSB7XG4gICAgICAgICAgICAvLyBzb3J0IG5vZGVzIGluIGxldmVsIGJ5IHBvc2l0aW9uOlxuICAgICAgICAgICAgdmFyIG5vZGVBcnJheSA9IE9iamVjdC5rZXlzKGRpc3RyaWJ1dGlvbltsZXZlbF0pO1xuICAgICAgICAgICAgbm9kZUFycmF5ID0gdGhpcy5faW5kZXhBcnJheVRvTm9kZXMobm9kZUFycmF5KTtcbiAgICAgICAgICAgIHRoaXMuX3NvcnROb2RlQXJyYXkobm9kZUFycmF5KTtcbiAgICAgICAgICAgIHZhciBoYW5kbGVkTm9kZUNvdW50ID0gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBub2RlQXJyYXlbaV07XG4gICAgICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9uZWROb2Rlc1tub2RlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcgKiBoYW5kbGVkTm9kZUNvdW50O1xuICAgICAgICAgICAgICAgIC8vIHdlIGdldCB0aGUgWCBvciBZIHZhbHVlcyB3ZSBuZWVkIGFuZCBzdG9yZSB0aGVtIGluIHBvcyBhbmQgcHJldmlvdXNQb3MuIFRoZSBnZXQgYW5kIHNldCBtYWtlIHN1cmUgd2UgZ2V0IFggb3IgWVxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVkTm9kZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgcG9zID0gdGhpcy5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkobm9kZUFycmF5W2kgLSAxXSkgKyB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQb3NpdGlvbkZvckhpZXJhcmNoeShub2RlLCBwb3MsIGxldmVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWxpZGF0YVBvc2l0aW9uQW5kQ29udGludWUobm9kZSwgbGV2ZWwsIHBvcyk7XG5cbiAgICAgICAgICAgICAgICBoYW5kbGVkTm9kZUNvdW50Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGlzIGEgcmVjdXJzaXZlbHkgY2FsbGVkIGZ1bmN0aW9uIHRvIGVudW1lcmF0ZSB0aGUgYnJhbmNoZXMgZnJvbSB0aGUgbGFyZ2VzdCBodWJzIGFuZCBwbGFjZSB0aGUgbm9kZXNcbiAgICAgICAqIG9uIGEgWCBwb3NpdGlvbiB0aGF0IGVuc3VyZXMgdGhlcmUgd2lsbCBiZSBubyBvdmVybGFwLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBwYXJlbnRJZFxuICAgICAgICogQHBhcmFtIHBhcmVudExldmVsXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcGxhY2VCcmFuY2hOb2RlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3BsYWNlQnJhbmNoTm9kZXMocGFyZW50SWQsIHBhcmVudExldmVsKSB7XG4gICAgICAgIC8vIGlmIHRoaXMgaXMgbm90IGEgcGFyZW50LCBjYW5jZWwgdGhlIHBsYWNpbmcuIFRoaXMgY2FuIGhhcHBlbiB3aXRoIG11bHRpcGxlIHBhcmVudHMgdG8gb25lIGNoaWxkLlxuICAgICAgICBpZiAodGhpcy5oaWVyYXJjaGljYWxDaGlsZHJlblJlZmVyZW5jZVtwYXJlbnRJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBhIGxpc3Qgb2YgY2hpbGROb2Rlc1xuICAgICAgICB2YXIgY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaGllcmFyY2hpY2FsQ2hpbGRyZW5SZWZlcmVuY2VbcGFyZW50SWRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGROb2Rlcy5wdXNoKHRoaXMuYm9keS5ub2Rlc1t0aGlzLmhpZXJhcmNoaWNhbENoaWxkcmVuUmVmZXJlbmNlW3BhcmVudElkXVtpXV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXNlIHRoZSBwb3NpdGlvbnMgdG8gb3JkZXIgdGhlIG5vZGVzLlxuICAgICAgICB0aGlzLl9zb3J0Tm9kZUFycmF5KGNoaWxkTm9kZXMpO1xuXG4gICAgICAgIC8vIHBvc2l0aW9uIHRoZSBjaGlsZE5vZGVzXG4gICAgICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IGNoaWxkTm9kZXMubGVuZ3RoOyBfaTYrKykge1xuICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW19pNl07XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZUxldmVsID0gdGhpcy5oaWVyYXJjaGljYWxMZXZlbHNbY2hpbGROb2RlLmlkXTtcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgY2hpbGQgbm9kZSBpcyBiZWxvdyB0aGUgcGFyZW50IG5vZGUgYW5kIGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gcG9zaXRpb25lZC5cbiAgICAgICAgICBpZiAoY2hpbGROb2RlTGV2ZWwgPiBwYXJlbnRMZXZlbCAmJiB0aGlzLnBvc2l0aW9uZWROb2Rlc1tjaGlsZE5vZGUuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgYW1vdW50IG9mIHNwYWNlIHJlcXVpcmVkIGZvciB0aGlzIG5vZGUuIElmIHBhcmVudCB0aGUgd2lkdGggaXMgYmFzZWQgb24gdGhlIGFtb3VudCBvZiBjaGlsZHJlbi5cbiAgICAgICAgICAgIHZhciBwb3MgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIC8vIHdlIGdldCB0aGUgWCBvciBZIHZhbHVlcyB3ZSBuZWVkIGFuZCBzdG9yZSB0aGVtIGluIHBvcyBhbmQgcHJldmlvdXNQb3MuIFRoZSBnZXQgYW5kIHNldCBtYWtlIHN1cmUgd2UgZ2V0IFggb3IgWVxuICAgICAgICAgICAgaWYgKF9pNiA9PT0gMCkge1xuICAgICAgICAgICAgICBwb3MgPSB0aGlzLl9nZXRQb3NpdGlvbkZvckhpZXJhcmNoeSh0aGlzLmJvZHkubm9kZXNbcGFyZW50SWRdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBvcyA9IHRoaXMuX2dldFBvc2l0aW9uRm9ySGllcmFyY2h5KGNoaWxkTm9kZXNbX2k2IC0gMV0pICsgdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldFBvc2l0aW9uRm9ySGllcmFyY2h5KGNoaWxkTm9kZSwgcG9zLCBjaGlsZE5vZGVMZXZlbCk7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0YVBvc2l0aW9uQW5kQ29udGludWUoY2hpbGROb2RlLCBjaGlsZE5vZGVMZXZlbCwgcG9zKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNlbnRlciB0aGUgcGFyZW50IG5vZGVzLlxuICAgICAgICB2YXIgbWluUG9zID0gMWU5O1xuICAgICAgICB2YXIgbWF4UG9zID0gLTFlOTtcbiAgICAgICAgZm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgY2hpbGROb2Rlcy5sZW5ndGg7IF9pNysrKSB7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZUlkID0gY2hpbGROb2Rlc1tfaTddLmlkO1xuICAgICAgICAgIG1pblBvcyA9IE1hdGgubWluKG1pblBvcywgdGhpcy5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkodGhpcy5ib2R5Lm5vZGVzW2NoaWxkTm9kZUlkXSkpO1xuICAgICAgICAgIG1heFBvcyA9IE1hdGgubWF4KG1heFBvcywgdGhpcy5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkodGhpcy5ib2R5Lm5vZGVzW2NoaWxkTm9kZUlkXSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldFBvc2l0aW9uRm9ySGllcmFyY2h5KHRoaXMuYm9keS5ub2Rlc1twYXJlbnRJZF0sIDAuNSAqIChtaW5Qb3MgKyBtYXhQb3MpLCBwYXJlbnRMZXZlbCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBtZXRob2QgY2hlY2tzIGZvciBvdmVybGFwIGFuZCBpZiByZXF1aXJlZCBzaGlmdHMgdGhlIGJyYW5jaC4gSXQgYWxzbyBrZWVwcyByZWNvcmRzIG9mIHBvc2l0aW9uZWQgbm9kZXMuXG4gICAgICAgKiBGaW5hbGx5IGl0IHdpbGwgY2FsbCBfcGxhY2VCcmFuY2hOb2RlcyB0byBwbGFjZSB0aGUgYnJhbmNoIG5vZGVzLlxuICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAqIEBwYXJhbSBsZXZlbFxuICAgICAgICogQHBhcmFtIHBvc1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3ZhbGlkYXRhUG9zaXRpb25BbmRDb250aW51ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3ZhbGlkYXRhUG9zaXRpb25BbmRDb250aW51ZShub2RlLCBsZXZlbCwgcG9zKSB7XG4gICAgICAgIC8vIGlmIG92ZXJsYXAgaGFzIGJlZW4gZGV0ZWN0ZWQsIHdlIHNoaWZ0IHRoZSBicmFuY2hcbiAgICAgICAgaWYgKHRoaXMubGFzdE5vZGVPbkxldmVsW2xldmVsXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzUG9zID0gdGhpcy5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkodGhpcy5ib2R5Lm5vZGVzW3RoaXMubGFzdE5vZGVPbkxldmVsW2xldmVsXV0pO1xuICAgICAgICAgIGlmIChwb3MgLSBwcmV2aW91c1BvcyA8IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpIHtcbiAgICAgICAgICAgIHZhciBkaWZmID0gcHJldmlvdXNQb3MgKyB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nIC0gcG9zO1xuICAgICAgICAgICAgdmFyIHNoYXJlZFBhcmVudCA9IHRoaXMuX2ZpbmRDb21tb25QYXJlbnQodGhpcy5sYXN0Tm9kZU9uTGV2ZWxbbGV2ZWxdLCBub2RlLmlkKTtcbiAgICAgICAgICAgIHRoaXMuX3NoaWZ0QmxvY2soc2hhcmVkUGFyZW50LndpdGhDaGlsZCwgZGlmZik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RvcmUgY2hhbmdlIGluIHBvc2l0aW9uLlxuICAgICAgICB0aGlzLmxhc3ROb2RlT25MZXZlbFtsZXZlbF0gPSBub2RlLmlkO1xuXG4gICAgICAgIHRoaXMucG9zaXRpb25lZE5vZGVzW25vZGUuaWRdID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9wbGFjZUJyYW5jaE5vZGVzKG5vZGUuaWQsIGxldmVsKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZWNlaXZlcyBhbiBhcnJheSB3aXRoIG5vZGUgaW5kaWNlcyBhbmQgcmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSBhY3R1YWwgbm9kZSByZWZlcmVuY2VzLiBVc2VkIGZvciBzb3J0aW5nIGJhc2VkIG9uXG4gICAgICAgKiBub2RlIHByb3BlcnRpZXMuXG4gICAgICAgKiBAcGFyYW0gaWRBcnJheVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfaW5kZXhBcnJheVRvTm9kZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbmRleEFycmF5VG9Ob2RlcyhpZEFycmF5KSB7XG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcnJheS5wdXNoKHRoaXMuYm9keS5ub2Rlc1tpZEFycmF5W2ldXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gZ2V0IHRoZSBkaXN0cmlidXRpb24gb2YgbGV2ZWxzIGJhc2VkIG9uIGh1YnNpemVcbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldERpc3RyaWJ1dGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RyaWJ1dGlvbigpIHtcbiAgICAgICAgdmFyIGRpc3RyaWJ1dGlvbiA9IHt9O1xuICAgICAgICB2YXIgbm9kZUlkID0gdm9pZCAwLFxuICAgICAgICAgICAgbm9kZSA9IHZvaWQgMDtcblxuICAgICAgICAvLyB3ZSBmaXggWSBiZWNhdXNlIHRoZSBoaWVyYXJjaHkgaXMgdmVydGljYWwsIHdlIGZpeCBYIHNvIHdlIGRvIG5vdCBnaXZlIGEgbm9kZSBhbiB4IHBvc2l0aW9uIGZvciBhIHNlY29uZCB0aW1lLlxuICAgICAgICAvLyB0aGUgZml4IG9mIFggaXMgcmVtb3ZlZCBhZnRlciB0aGUgeCB2YWx1ZSBoYXMgYmVlbiBzZXQuXG4gICAgICAgIGZvciAobm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgdmFyIGxldmVsID0gdGhpcy5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZUlkXSA9PT0gdW5kZWZpbmVkID8gMCA6IHRoaXMuaGllcmFyY2hpY2FsTGV2ZWxzW25vZGVJZF07XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5kaXJlY3Rpb24gPT09ICdVRCcgfHwgdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5kaXJlY3Rpb24gPT09ICdEVScpIHtcbiAgICAgICAgICAgICAgbm9kZS55ID0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24gKiBsZXZlbDtcbiAgICAgICAgICAgICAgbm9kZS5vcHRpb25zLmZpeGVkLnkgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9kZS54ID0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24gKiBsZXZlbDtcbiAgICAgICAgICAgICAgbm9kZS5vcHRpb25zLmZpeGVkLnggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpc3RyaWJ1dGlvbltsZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBkaXN0cmlidXRpb25bbGV2ZWxdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXN0cmlidXRpb25bbGV2ZWxdW25vZGVJZF0gPSBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlzdHJpYnV0aW9uO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCB0aGUgaHVic2l6ZSBmcm9tIGFsbCByZW1haW5pbmcgdW5sZXZlbGxlZCBub2Rlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldEh1YlNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRIdWJTaXplKCkge1xuICAgICAgICB2YXIgaHViU2l6ZSA9IDA7XG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgICBpZiAodGhpcy5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGh1YlNpemUgPSBub2RlLmVkZ2VzLmxlbmd0aCA8IGh1YlNpemUgPyBodWJTaXplIDogbm9kZS5lZGdlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBodWJTaXplO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHRoaXMgZnVuY3Rpb24gYWxsb2NhdGVzIG5vZGVzIGluIGxldmVscyBiYXNlZCBvbiB0aGUgcmVjdXJzaXZlIGJyYW5jaGluZyBmcm9tIHRoZSBsYXJnZXN0IGh1YnMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIGh1YnNpemVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19kZXRlcm1pbmVMZXZlbHNCeUh1YnNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRlcm1pbmVMZXZlbHNCeUh1YnNpemUoKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBodWJTaXplID0gMTtcblxuICAgICAgICB2YXIgbGV2ZWxEb3duc3RyZWFtID0gZnVuY3Rpb24gbGV2ZWxEb3duc3RyZWFtKG5vZGVBLCBub2RlQikge1xuICAgICAgICAgIGlmIChfdGhpczMuaGllcmFyY2hpY2FsTGV2ZWxzW25vZGVCLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBzZXQgaW5pdGlhbCBsZXZlbFxuICAgICAgICAgICAgaWYgKF90aGlzMy5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZUEuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLmhpZXJhcmNoaWNhbExldmVsc1tub2RlQS5pZF0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IGxldmVsXG4gICAgICAgICAgICBfdGhpczMuaGllcmFyY2hpY2FsTGV2ZWxzW25vZGVCLmlkXSA9IF90aGlzMy5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZUEuaWRdICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgd2hpbGUgKGh1YlNpemUgPiAwKSB7XG4gICAgICAgICAgLy8gZGV0ZXJtaW5lIGh1YnNcbiAgICAgICAgICBodWJTaXplID0gdGhpcy5fZ2V0SHViU2l6ZSgpO1xuICAgICAgICAgIGlmIChodWJTaXplID09PSAwKSBicmVhaztcblxuICAgICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgICBpZiAobm9kZS5lZGdlcy5sZW5ndGggPT09IGh1YlNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmF3bE5ldHdvcmsobGV2ZWxEb3duc3RyZWFtLCBub2RlSWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVE9ETzogcmVsZWFzZSBmZWF0dXJlXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZGV0ZXJtaW5lTGV2ZWxzQ3VzdG9tQ2FsbGJhY2snLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRlcm1pbmVMZXZlbHNDdXN0b21DYWxsYmFjaygpIHtcbiAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIG1pbkxldmVsID0gMTAwMDAwO1xuXG4gICAgICAgIC8vIFRPRE86IHRoaXMgc2hvdWxkIGNvbWUgZnJvbSBvcHRpb25zLlxuICAgICAgICB2YXIgY3VzdG9tQ2FsbGJhY2sgPSBmdW5jdGlvbiBjdXN0b21DYWxsYmFjayhub2RlQSwgbm9kZUIsIGVkZ2UpIHt9O1xuXG4gICAgICAgIHZhciBsZXZlbEJ5RGlyZWN0aW9uID0gZnVuY3Rpb24gbGV2ZWxCeURpcmVjdGlvbihub2RlQSwgbm9kZUIsIGVkZ2UpIHtcbiAgICAgICAgICB2YXIgbGV2ZWxBID0gX3RoaXM0LmhpZXJhcmNoaWNhbExldmVsc1tub2RlQS5pZF07XG4gICAgICAgICAgLy8gc2V0IGluaXRpYWwgbGV2ZWxcbiAgICAgICAgICBpZiAobGV2ZWxBID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF90aGlzNC5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZUEuaWRdID0gbWluTGV2ZWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRpZmYgPSBjdXN0b21DYWxsYmFjayhfTmV0d29ya1V0aWwyLmRlZmF1bHQuY2xvbmVPcHRpb25zKG5vZGVBLCAnbm9kZScpLCBfTmV0d29ya1V0aWwyLmRlZmF1bHQuY2xvbmVPcHRpb25zKG5vZGVCLCAnbm9kZScpLCBfTmV0d29ya1V0aWwyLmRlZmF1bHQuY2xvbmVPcHRpb25zKGVkZ2UsICdlZGdlJykpO1xuXG4gICAgICAgICAgX3RoaXM0LmhpZXJhcmNoaWNhbExldmVsc1tub2RlQi5pZF0gPSBfdGhpczQuaGllcmFyY2hpY2FsTGV2ZWxzW25vZGVBLmlkXSArIGRpZmY7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fY3Jhd2xOZXR3b3JrKGxldmVsQnlEaXJlY3Rpb24pO1xuICAgICAgICB0aGlzLl9zZXRNaW5MZXZlbFRvWmVybygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHRoaXMgZnVuY3Rpb24gYWxsb2NhdGVzIG5vZGVzIGluIGxldmVscyBiYXNlZCBvbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBlZGdlc1xuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBodWJzaXplXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZGV0ZXJtaW5lTGV2ZWxzRGlyZWN0ZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRlcm1pbmVMZXZlbHNEaXJlY3RlZCgpIHtcbiAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIG1pbkxldmVsID0gMTAwMDA7XG4gICAgICAgIHZhciBsZXZlbEJ5RGlyZWN0aW9uID0gZnVuY3Rpb24gbGV2ZWxCeURpcmVjdGlvbihub2RlQSwgbm9kZUIsIGVkZ2UpIHtcbiAgICAgICAgICB2YXIgbGV2ZWxBID0gX3RoaXM1LmhpZXJhcmNoaWNhbExldmVsc1tub2RlQS5pZF07XG4gICAgICAgICAgLy8gc2V0IGluaXRpYWwgbGV2ZWxcbiAgICAgICAgICBpZiAobGV2ZWxBID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF90aGlzNS5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZUEuaWRdID0gbWluTGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlZGdlLnRvSWQgPT0gbm9kZUIuaWQpIHtcbiAgICAgICAgICAgIF90aGlzNS5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZUIuaWRdID0gX3RoaXM1LmhpZXJhcmNoaWNhbExldmVsc1tub2RlQS5pZF0gKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpczUuaGllcmFyY2hpY2FsTGV2ZWxzW25vZGVCLmlkXSA9IF90aGlzNS5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZUEuaWRdIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2NyYXdsTmV0d29yayhsZXZlbEJ5RGlyZWN0aW9uKTtcbiAgICAgICAgdGhpcy5fc2V0TWluTGV2ZWxUb1plcm8oKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTbWFsbCB1dGlsIG1ldGhvZCB0byBzZXQgdGhlIG1pbmltdW0gbGV2ZWxzIG9mIHRoZSBub2RlcyB0byB6ZXJvLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3NldE1pbkxldmVsVG9aZXJvJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0TWluTGV2ZWxUb1plcm8oKSB7XG4gICAgICAgIHZhciBtaW5MZXZlbCA9IDFlOTtcbiAgICAgICAgLy8gZ2V0IHRoZSBtaW5pbXVtIGxldmVsXG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhpZXJhcmNoaWNhbExldmVsc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbWluTGV2ZWwgPSBNYXRoLm1pbih0aGlzLmhpZXJhcmNoaWNhbExldmVsc1tub2RlSWRdLCBtaW5MZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3VidHJhY3QgdGhlIG1pbmltdW0gZnJvbSB0aGUgc2V0IHNvIHdlIGhhdmUgYSByYW5nZSBzdGFydGluZyBmcm9tIDBcbiAgICAgICAgZm9yICh2YXIgX25vZGVJZDIgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShfbm9kZUlkMikpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhpZXJhcmNoaWNhbExldmVsc1tfbm9kZUlkMl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLmhpZXJhcmNoaWNhbExldmVsc1tfbm9kZUlkMl0gLT0gbWluTGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVXBkYXRlIHRoZSBib29ra2VlcGluZyBvZiBwYXJlbnQgYW5kIGNoaWxkLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dlbmVyYXRlTWFwJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2VuZXJhdGVNYXAoKSB7XG4gICAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAgIHZhciBmaWxsSW5SZWxhdGlvbnMgPSBmdW5jdGlvbiBmaWxsSW5SZWxhdGlvbnMocGFyZW50Tm9kZSwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgaWYgKF90aGlzNi5oaWVyYXJjaGljYWxMZXZlbHNbY2hpbGROb2RlLmlkXSA+IF90aGlzNi5oaWVyYXJjaGljYWxMZXZlbHNbcGFyZW50Tm9kZS5pZF0pIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnROb2RlSWQgPSBwYXJlbnROb2RlLmlkO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZUlkID0gY2hpbGROb2RlLmlkO1xuICAgICAgICAgICAgaWYgKF90aGlzNi5oaWVyYXJjaGljYWxDaGlsZHJlblJlZmVyZW5jZVtwYXJlbnROb2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgX3RoaXM2LmhpZXJhcmNoaWNhbENoaWxkcmVuUmVmZXJlbmNlW3BhcmVudE5vZGVJZF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzNi5oaWVyYXJjaGljYWxDaGlsZHJlblJlZmVyZW5jZVtwYXJlbnROb2RlSWRdLnB1c2goY2hpbGROb2RlSWQpO1xuICAgICAgICAgICAgaWYgKF90aGlzNi5oaWVyYXJjaGljYWxQYXJlbnRSZWZlcmVuY2VbY2hpbGROb2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgX3RoaXM2LmhpZXJhcmNoaWNhbFBhcmVudFJlZmVyZW5jZVtjaGlsZE5vZGVJZF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzNi5oaWVyYXJjaGljYWxQYXJlbnRSZWZlcmVuY2VbY2hpbGROb2RlSWRdLnB1c2gocGFyZW50Tm9kZUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fY3Jhd2xOZXR3b3JrKGZpbGxJblJlbGF0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3Jhd2wgb3ZlciB0aGUgZW50aXJlIG5ldHdvcmsgYW5kIHVzZSBhIGNhbGxiYWNrIG9uIGVhY2ggbm9kZSBjb3VwbGUgdGhhdCBpcyBjb25uZWN0ZWQgdG8gZWFjaCBvdGhlci5cbiAgICAgICAqIEBwYXJhbSBjYWxsYmFjayAgICAgICAgICB8IHdpbGwgcmVjZWl2ZSBub2RlQSBub2RlQiBhbmQgdGhlIGNvbm5lY3RpbmcgZWRnZS4gQSBhbmQgQiBhcmUgdW5pcXVlLlxuICAgICAgICogQHBhcmFtIHN0YXJ0aW5nTm9kZUlkXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY3Jhd2xOZXR3b3JrJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3Jhd2xOZXR3b3JrKCkge1xuICAgICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICB2YXIgc3RhcnRpbmdOb2RlSWQgPSBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgdmFyIHByb2dyZXNzID0ge307XG4gICAgICAgIHZhciB0cmVlSW5kZXggPSAwO1xuXG4gICAgICAgIHZhciBjcmF3bGVyID0gZnVuY3Rpb24gY3Jhd2xlcihub2RlLCB0cmVlKSB7XG4gICAgICAgICAgaWYgKHByb2dyZXNzW25vZGUuaWRdID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgaWYgKF90aGlzNy5oaWVyYXJjaGljYWxUcmVlc1tub2RlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIF90aGlzNy5oaWVyYXJjaGljYWxUcmVlc1tub2RlLmlkXSA9IHRyZWU7XG4gICAgICAgICAgICAgIF90aGlzNy50cmVlSW5kZXggPSBNYXRoLm1heCh0cmVlLCBfdGhpczcudHJlZUluZGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvZ3Jlc3Nbbm9kZS5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAobm9kZS5lZGdlc1tpXS5jb25uZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5lZGdlc1tpXS50b0lkID09PSBub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBub2RlLmVkZ2VzW2ldLmZyb207XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IG5vZGUuZWRnZXNbaV0udG87XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgIT09IGNoaWxkTm9kZS5pZCkge1xuICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobm9kZSwgY2hpbGROb2RlLCBub2RlLmVkZ2VzW2ldKTtcbiAgICAgICAgICAgICAgICAgIGNyYXdsZXIoY2hpbGROb2RlLCB0cmVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gd2UgY2FuIGNyYXdsIGZyb20gYSBzcGVjaWZpYyBub2RlIG9yIG92ZXIgYWxsIG5vZGVzLlxuICAgICAgICBpZiAoc3RhcnRpbmdOb2RlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbaV1dO1xuICAgICAgICAgICAgaWYgKHByb2dyZXNzW25vZGUuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY3Jhd2xlcihub2RlLCB0cmVlSW5kZXgpO1xuICAgICAgICAgICAgICB0cmVlSW5kZXggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9ub2RlID0gdGhpcy5ib2R5Lm5vZGVzW3N0YXJ0aW5nTm9kZUlkXTtcbiAgICAgICAgICBpZiAoX25vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk5vZGUgbm90IGZvdW5kOlwiLCBzdGFydGluZ05vZGVJZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNyYXdsZXIoX25vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2hpZnQgYSBicmFuY2ggYSBjZXJ0YWluIGRpc3RhbmNlXG4gICAgICAgKiBAcGFyYW0gcGFyZW50SWRcbiAgICAgICAqIEBwYXJhbSBkaWZmXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2hpZnRCbG9jaycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NoaWZ0QmxvY2socGFyZW50SWQsIGRpZmYpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSAnVUQnIHx8IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSAnRFUnKSB7XG4gICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW3BhcmVudElkXS54ICs9IGRpZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW3BhcmVudElkXS55ICs9IGRpZmY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGllcmFyY2hpY2FsQ2hpbGRyZW5SZWZlcmVuY2VbcGFyZW50SWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaGllcmFyY2hpY2FsQ2hpbGRyZW5SZWZlcmVuY2VbcGFyZW50SWRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9zaGlmdEJsb2NrKHRoaXMuaGllcmFyY2hpY2FsQ2hpbGRyZW5SZWZlcmVuY2VbcGFyZW50SWRdW2ldLCBkaWZmKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBGaW5kIGEgY29tbW9uIHBhcmVudCBiZXR3ZWVuIGJyYW5jaGVzLlxuICAgICAgICogQHBhcmFtIGNoaWxkQVxuICAgICAgICogQHBhcmFtIGNoaWxkQlxuICAgICAgICogQHJldHVybnMge3tmb3VuZFBhcmVudCwgd2l0aENoaWxkfX1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19maW5kQ29tbW9uUGFyZW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZENvbW1vblBhcmVudChjaGlsZEEsIGNoaWxkQikge1xuICAgICAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICAgICAgICB2YXIgcGFyZW50cyA9IHt9O1xuICAgICAgICB2YXIgaXRlcmF0ZVBhcmVudHMgPSBmdW5jdGlvbiBpdGVyYXRlUGFyZW50cyhwYXJlbnRzLCBjaGlsZCkge1xuICAgICAgICAgIGlmIChfdGhpczguaGllcmFyY2hpY2FsUGFyZW50UmVmZXJlbmNlW2NoaWxkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzOC5oaWVyYXJjaGljYWxQYXJlbnRSZWZlcmVuY2VbY2hpbGRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBfdGhpczguaGllcmFyY2hpY2FsUGFyZW50UmVmZXJlbmNlW2NoaWxkXVtpXTtcbiAgICAgICAgICAgICAgcGFyZW50c1twYXJlbnRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaXRlcmF0ZVBhcmVudHMocGFyZW50cywgcGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBmaW5kUGFyZW50ID0gZnVuY3Rpb24gZmluZFBhcmVudChwYXJlbnRzLCBjaGlsZCkge1xuICAgICAgICAgIGlmIChfdGhpczguaGllcmFyY2hpY2FsUGFyZW50UmVmZXJlbmNlW2NoaWxkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzOC5oaWVyYXJjaGljYWxQYXJlbnRSZWZlcmVuY2VbY2hpbGRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBfdGhpczguaGllcmFyY2hpY2FsUGFyZW50UmVmZXJlbmNlW2NoaWxkXVtpXTtcbiAgICAgICAgICAgICAgaWYgKHBhcmVudHNbcGFyZW50XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZm91bmRQYXJlbnQ6IHBhcmVudCwgd2l0aENoaWxkOiBjaGlsZCB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBicmFuY2ggPSBmaW5kUGFyZW50KHBhcmVudHMsIHBhcmVudCk7XG4gICAgICAgICAgICAgIGlmIChicmFuY2guZm91bmRQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IGZvdW5kUGFyZW50OiBudWxsLCB3aXRoQ2hpbGQ6IGNoaWxkIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgaXRlcmF0ZVBhcmVudHMocGFyZW50cywgY2hpbGRBKTtcbiAgICAgICAgcmV0dXJuIGZpbmRQYXJlbnQocGFyZW50cywgY2hpbGRCKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBYnN0cmFjdCB0aGUgZ2V0dGluZyBvZiB0aGUgcG9zaXRpb24gc28gd2Ugd29uJ3QgaGF2ZSB0byByZXBlYXQgdGhlIGNoZWNrIGZvciBkaXJlY3Rpb24gYWxsIHRoZSB0aW1lXG4gICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICogQHBhcmFtIHBvc2l0aW9uXG4gICAgICAgKiBAcGFyYW0gbGV2ZWxcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zZXRQb3NpdGlvbkZvckhpZXJhcmNoeScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFBvc2l0aW9uRm9ySGllcmFyY2h5KG5vZGUsIHBvc2l0aW9uLCBsZXZlbCkge1xuICAgICAgICB2YXIgZG9Ob3RVcGRhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuXG4gICAgICAgIC8vY29uc29sZS5sb2coJ19zZXRQb3NpdGlvbkZvckhpZXJhcmNoeScsbm9kZS5pZCwgcG9zaXRpb24pXG4gICAgICAgIGlmIChkb05vdFVwZGF0ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgIGlmICh0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1ByZXNlbmNlW2xldmVsXSA9IHt9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nUHJlc2VuY2VbbGV2ZWxdW25vZGUuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbkluZGV4W25vZGUuaWRdID0gdGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF0ubGVuZ3RoIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1ByZXNlbmNlW2xldmVsXVtub2RlLmlkXSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5kaXJlY3Rpb24gPT09ICdVRCcgfHwgdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5kaXJlY3Rpb24gPT09ICdEVScpIHtcbiAgICAgICAgICBub2RlLnggPSBwb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnkgPSBwb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFic3RyYWN0IHRoZSBnZXR0aW5nIG9mIHRoZSBwb3NpdGlvbiBvZiBhIG5vZGUgc28gd2UgZG8gbm90IGhhdmUgdG8gcmVwZWF0IHRoZSBkaXJlY3Rpb24gY2hlY2sgYWxsIHRoZSB0aW1lLlxuICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ8Kn1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXRQb3NpdGlvbkZvckhpZXJhcmNoeScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFBvc2l0aW9uRm9ySGllcmFyY2h5KG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSAnVUQnIHx8IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSAnRFUnKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUueDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS55O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlIHRoZSB4IG9yIHkgdmFsdWUgdG8gc29ydCB0aGUgYXJyYXksIGFsbG93aW5nIHVzZXJzIHRvIHNwZWNpZnkgb3JkZXIuXG4gICAgICAgKiBAcGFyYW0gbm9kZUFycmF5XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc29ydE5vZGVBcnJheScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NvcnROb2RlQXJyYXkobm9kZUFycmF5KSB7XG4gICAgICAgIGlmIChub2RlQXJyYXkubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmRpcmVjdGlvbiA9PT0gJ1VEJyB8fCB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmRpcmVjdGlvbiA9PT0gJ0RVJykge1xuICAgICAgICAgICAgbm9kZUFycmF5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGEueCAtIGIueDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlQXJyYXkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICByZXR1cm4gYS55IC0gYi55O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIExheW91dEVuZ2luZTtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IExheW91dEVuZ2luZTtcblxuLyoqKi8gfSxcbi8qIDExNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBIYW1tZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcbiAgdmFyIGhhbW1lclV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcblxuICAvKipcbiAgICogY2xlYXJzIHRoZSB0b29sYmFyIGRpdiBlbGVtZW50IG9mIGNoaWxkcmVuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHZhciBNYW5pcHVsYXRpb25TeXN0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFuaXB1bGF0aW9uU3lzdGVtKGJvZHksIGNhbnZhcywgc2VsZWN0aW9uSGFuZGxlcikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hbmlwdWxhdGlvblN5c3RlbSk7XG5cbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlciA9IHNlbGVjdGlvbkhhbmRsZXI7XG5cbiAgICAgIHRoaXMuZWRpdE1vZGUgPSBmYWxzZTtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5lZGl0TW9kZURpdiA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuY2xvc2VEaXYgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uSGFtbWVycyA9IFtdO1xuICAgICAgdGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9ucyA9IHt9O1xuICAgICAgdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9ucyA9IFtdO1xuXG4gICAgICB0aGlzLnRvdWNoVGltZSA9IDA7XG4gICAgICB0aGlzLnRlbXBvcmFyeUlkcyA9IHsgbm9kZXM6IFtdLCBlZGdlczogW10gfTtcbiAgICAgIHRoaXMuZ3VpRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5pbk1vZGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgaW5pdGlhbGx5QWN0aXZlOiBmYWxzZSxcbiAgICAgICAgYWRkTm9kZTogdHJ1ZSxcbiAgICAgICAgYWRkRWRnZTogdHJ1ZSxcbiAgICAgICAgZWRpdE5vZGU6IHVuZGVmaW5lZCxcbiAgICAgICAgZWRpdEVkZ2U6IHRydWUsXG4gICAgICAgIGRlbGV0ZU5vZGU6IHRydWUsXG4gICAgICAgIGRlbGV0ZUVkZ2U6IHRydWUsXG4gICAgICAgIGNvbnRyb2xOb2RlU3R5bGU6IHtcbiAgICAgICAgICBzaGFwZTogJ2RvdCcsXG4gICAgICAgICAgc2l6ZTogNixcbiAgICAgICAgICBjb2xvcjogeyBiYWNrZ3JvdW5kOiAnI2ZmMDAwMCcsIGJvcmRlcjogJyMzYzNjM2MnLCBoaWdobGlnaHQ6IHsgYmFja2dyb3VuZDogJyMwN2Y5NjgnLCBib3JkZXI6ICcjM2MzYzNjJyB9IH0sXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IDIsXG4gICAgICAgICAgYm9yZGVyV2lkdGhTZWxlY3RlZDogMlxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLl9jbGVhbigpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignX2RhdGFDaGFuZ2VkJywgdGhpcy5fcmVzdG9yZS5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdfcmVzZXREYXRhJywgdGhpcy5fcmVzdG9yZS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiBzb21ldGhpbmcgY2hhbmdlcyBpbiB0aGUgZGF0YSBkdXJpbmcgZWRpdGluZywgc3dpdGNoIGJhY2sgdG8gdGhlIGluaXRpYWwgZGF0YW1hbmlwdWxhdGlvbiBzdGF0ZSBhbmQgY2xvc2UgYWxsIGVkaXQgbW9kZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKE1hbmlwdWxhdGlvblN5c3RlbSwgW3tcbiAgICAgIGtleTogJ19yZXN0b3JlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzdG9yZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5Nb2RlICE9PSBmYWxzZSkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5pdGlhbGx5QWN0aXZlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHRoZSBPcHRpb25zXG4gICAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMsIGFsbE9wdGlvbnMsIGdsb2JhbE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGFsbE9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChhbGxPcHRpb25zLmxvY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubG9jYWxlID0gYWxsT3B0aW9ucy5sb2NhbGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5sb2NhbGUgPSBnbG9iYWxPcHRpb25zLmxvY2FsZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFsbE9wdGlvbnMubG9jYWxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubG9jYWxlcyA9IGFsbE9wdGlvbnMubG9jYWxlcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxvY2FsZXMgPSBnbG9iYWxPcHRpb25zLmxvY2FsZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IG9wdGlvbnM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHV0aWwuZGVlcEV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmluaXRpYWxseUFjdGl2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5lZGl0TW9kZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3NldHVwKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBlZGl0LW1vZGUuIERyYXdzIHRoZSBET00gcmVxdWlyZWQgYW5kIGNsZWFucyB1cCBhZnRlciBpdHNlbGYuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndG9nZ2xlRWRpdE1vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZUVkaXRNb2RlKCkge1xuICAgICAgICBpZiAodGhpcy5lZGl0TW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZW5hYmxlRWRpdE1vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZUVkaXRNb2RlKCkge1xuICAgICAgICB0aGlzLmVkaXRNb2RlID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9jbGVhbigpO1xuICAgICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgdGhpcy5jbG9zZURpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICB0aGlzLmVkaXRNb2RlRGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXNhYmxlRWRpdE1vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVFZGl0TW9kZSgpIHtcbiAgICAgICAgdGhpcy5lZGl0TW9kZSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2NsZWFuKCk7XG4gICAgICAgIGlmICh0aGlzLmd1aUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIHRoaXMuY2xvc2VEaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICB0aGlzLmVkaXRNb2RlRGl2LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgIHRoaXMuX2NyZWF0ZUVkaXRCdXR0b24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgdGhlIG1haW4gdG9vbGJhci4gUmVtb3ZlcyBmdW5jdGlvbnMgYm91bmQgdG8gdGhlIHNlbGVjdCBldmVudC4gQmluZHMgYWxsIHRoZSBidXR0b25zIG9mIHRoZSB0b29sYmFyLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3Nob3dNYW5pcHVsYXRvclRvb2xiYXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNob3dNYW5pcHVsYXRvclRvb2xiYXIoKSB7XG4gICAgICAgIC8vIHJlc3RvcmUgdGhlIHN0YXRlIG9mIGFueSBib3VuZCBmdW5jdGlvbnMgb3IgZXZlbnRzLCByZW1vdmUgY29udHJvbCBub2RlcywgcmVzdG9yZSBwaHlzaWNzXG4gICAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgICAgLy8gcmVzZXQgZ2xvYmFsIHZhcmlhYmxlc1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTSA9IHt9O1xuXG4gICAgICAgIC8vIGlmIHRoZSBndWkgaXMgZW5hYmxlZCwgZHJhdyBhbGwgZWxlbWVudHMuXG4gICAgICAgIGlmICh0aGlzLmd1aUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAvLyBhIF9yZXN0b3JlIHdpbGwgaGlkZSB0aGVzZSBtZW51c1xuICAgICAgICAgIHRoaXMuZWRpdE1vZGUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgIHRoaXMuY2xvc2VEaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICAgICAgICB2YXIgc2VsZWN0ZWROb2RlQ291bnQgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dldFNlbGVjdGVkTm9kZUNvdW50KCk7XG4gICAgICAgICAgdmFyIHNlbGVjdGVkRWRnZUNvdW50ID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZXRTZWxlY3RlZEVkZ2VDb3VudCgpO1xuICAgICAgICAgIHZhciBzZWxlY3RlZFRvdGFsQ291bnQgPSBzZWxlY3RlZE5vZGVDb3VudCArIHNlbGVjdGVkRWRnZUNvdW50O1xuICAgICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTtcbiAgICAgICAgICB2YXIgbmVlZFNlcGVyYXRvciA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hZGROb2RlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlQWRkTm9kZUJ1dHRvbihsb2NhbGUpO1xuICAgICAgICAgICAgbmVlZFNlcGVyYXRvciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWRkRWRnZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChuZWVkU2VwZXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcigxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5lZWRTZXBlcmF0b3IgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlQWRkRWRnZUJ1dHRvbihsb2NhbGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWxlY3RlZE5vZGVDb3VudCA9PT0gMSAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLmVkaXROb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAobmVlZFNlcGVyYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZWVkU2VwZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUVkaXROb2RlQnV0dG9uKGxvY2FsZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZEVkZ2VDb3VudCA9PT0gMSAmJiBzZWxlY3RlZE5vZGVDb3VudCA9PT0gMCAmJiB0aGlzLm9wdGlvbnMuZWRpdEVkZ2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAobmVlZFNlcGVyYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoMyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZWVkU2VwZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUVkaXRFZGdlQnV0dG9uKGxvY2FsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcmVtb3ZlIGJ1dHRvbnNcbiAgICAgICAgICBpZiAoc2VsZWN0ZWRUb3RhbENvdW50ICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWROb2RlQ291bnQgPiAwICYmIHRoaXMub3B0aW9ucy5kZWxldGVOb2RlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBpZiAobmVlZFNlcGVyYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcig0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVEZWxldGVCdXR0b24obG9jYWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWROb2RlQ291bnQgPT09IDAgJiYgdGhpcy5vcHRpb25zLmRlbGV0ZUVkZ2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGlmIChuZWVkU2VwZXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKDQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZURlbGV0ZUJ1dHRvbihsb2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGJpbmQgdGhlIGNsb3NlIGJ1dHRvblxuICAgICAgICAgIHRoaXMuX2JpbmRIYW1tZXJUb0Rpdih0aGlzLmNsb3NlRGl2LCB0aGlzLnRvZ2dsZUVkaXRNb2RlLmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgLy8gcmVmcmVzaCB0aGlzIGJhciBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHNlbGVjdGVkXG4gICAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZEV2ZW50KCdzZWxlY3QnLCB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWRyYXcgdG8gc2hvdyBhbnkgcG9zc2libGUgY2hhbmdlc1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVkcmF3Jyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlIHRoZSB0b29sYmFyIGZvciBhZGRpbmcgTm9kZXNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnYWRkTm9kZU1vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE5vZGVNb2RlKCkge1xuICAgICAgICAvLyB3aGVuIHVzaW5nIHRoZSBndWksIGVuYWJsZSBlZGl0IG1vZGUgaWYgaXQgd2FzbnQgYWxyZWFkeS5cbiAgICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgIT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXN0b3JlIHRoZSBzdGF0ZSBvZiBhbnkgYm91bmQgZnVuY3Rpb25zIG9yIGV2ZW50cywgcmVtb3ZlIGNvbnRyb2wgbm9kZXMsIHJlc3RvcmUgcGh5c2ljc1xuICAgICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICAgIHRoaXMuaW5Nb2RlID0gJ2FkZE5vZGUnO1xuICAgICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdO1xuICAgICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NID0ge307XG4gICAgICAgICAgdGhpcy5fY3JlYXRlQmFja0J1dHRvbihsb2NhbGUpO1xuICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcigpO1xuICAgICAgICAgIHRoaXMuX2NyZWF0ZURlc2NyaXB0aW9uKGxvY2FsZVsnYWRkRGVzY3JpcHRpb24nXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXVsnYWRkRGVzY3JpcHRpb24nXSk7XG5cbiAgICAgICAgICAvLyBiaW5kIHRoZSBjbG9zZSBidXR0b25cbiAgICAgICAgICB0aGlzLl9iaW5kSGFtbWVyVG9EaXYodGhpcy5jbG9zZURpdiwgdGhpcy50b2dnbGVFZGl0TW9kZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRFdmVudCgnY2xpY2snLCB0aGlzLl9wZXJmb3JtQWRkTm9kZS5iaW5kKHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBjYWxsIHRoZSBib3VuZCBmdW5jdGlvbiB0byBoYW5kbGUgdGhlIGVkaXRpbmcgb2YgdGhlIG5vZGUuIFRoZSBub2RlIGhhcyB0byBiZSBzZWxlY3RlZC5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZWRpdE5vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXROb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAvLyB3aGVuIHVzaW5nIHRoZSBndWksIGVuYWJsZSBlZGl0IG1vZGUgaWYgaXQgd2FzbnQgYWxyZWFkeS5cbiAgICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgIT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXN0b3JlIHRoZSBzdGF0ZSBvZiBhbnkgYm91bmQgZnVuY3Rpb25zIG9yIGV2ZW50cywgcmVtb3ZlIGNvbnRyb2wgbm9kZXMsIHJlc3RvcmUgcGh5c2ljc1xuICAgICAgICB0aGlzLl9jbGVhbigpO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2V0U2VsZWN0ZWROb2RlKCk7XG4gICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmluTW9kZSA9ICdlZGl0Tm9kZSc7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuZWRpdE5vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmlzQ2x1c3RlciAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB2YXIgZGF0YSA9IHV0aWwuZGVlcEV4dGVuZCh7fSwgbm9kZS5vcHRpb25zLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGRhdGEueCA9IG5vZGUueDtcbiAgICAgICAgICAgICAgZGF0YS55ID0gbm9kZS55O1xuXG4gICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWRpdE5vZGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVkaXROb2RlKGRhdGEsIGZ1bmN0aW9uIChmaW5hbGl6ZWREYXRhKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmluYWxpemVkRGF0YSAhPT0gbnVsbCAmJiBmaW5hbGl6ZWREYXRhICE9PSB1bmRlZmluZWQgJiYgX3RoaXMyLmluTW9kZSA9PT0gJ2VkaXROb2RlJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHRoZSBtb2RlIGhhcyBjaGFuZ2VzIChkdWUgdG8gZGF0YXNldCBjaGFuZ2UpIGRpc3JlZ2FyZCB0aGUgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMyLmJvZHkuZGF0YS5ub2Rlcy5nZXREYXRhU2V0KCkudXBkYXRlKGZpbmFsaXplZERhdGEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX3RoaXMyLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBmdW5jdGlvbiBmb3IgZWRpdCBkb2VzIG5vdCBzdXBwb3J0IHR3byBhcmd1bWVudHMgKGRhdGEsIGNhbGxiYWNrKScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVsnZWRpdENsdXN0ZXJFcnJvciddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydlZGl0Q2x1c3RlckVycm9yJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGZ1bmN0aW9uIGhhcyBiZWVuIGNvbmZpZ3VyZWQgdG8gaGFuZGxlIHRoZSBlZGl0aW5nIG9mIG5vZGVzLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGNyZWF0ZSB0aGUgdG9vbGJhciB0byBjb25uZWN0IG5vZGVzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2FkZEVkZ2VNb2RlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFZGdlTW9kZSgpIHtcbiAgICAgICAgLy8gd2hlbiB1c2luZyB0aGUgZ3VpLCBlbmFibGUgZWRpdCBtb2RlIGlmIGl0IHdhc250IGFscmVhZHkuXG4gICAgICAgIGlmICh0aGlzLmVkaXRNb2RlICE9PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcbiAgICAgICAgdGhpcy5fY2xlYW4oKTtcblxuICAgICAgICB0aGlzLmluTW9kZSA9ICdhZGRFZGdlJztcbiAgICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTtcbiAgICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTSA9IHt9O1xuICAgICAgICAgIHRoaXMuX2NyZWF0ZUJhY2tCdXR0b24obG9jYWxlKTtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoKTtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVEZXNjcmlwdGlvbihsb2NhbGVbJ2VkZ2VEZXNjcmlwdGlvbiddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydlZGdlRGVzY3JpcHRpb24nXSk7XG5cbiAgICAgICAgICAvLyBiaW5kIHRoZSBjbG9zZSBidXR0b25cbiAgICAgICAgICB0aGlzLl9iaW5kSGFtbWVyVG9EaXYodGhpcy5jbG9zZURpdiwgdGhpcy50b2dnbGVFZGl0TW9kZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRlbXBvcmFyaWx5IG92ZXJsb2FkIGZ1bmN0aW9uc1xuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoJ29uVG91Y2gnLCB0aGlzLl9oYW5kbGVDb25uZWN0LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoJ29uRHJhZ0VuZCcsIHRoaXMuX2ZpbmlzaENvbm5lY3QuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSSgnb25EcmFnJywgdGhpcy5fZHJhZ0NvbnRyb2xOb2RlLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoJ29uUmVsZWFzZScsIHRoaXMuX2ZpbmlzaENvbm5lY3QuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKCdvbkRyYWdTdGFydCcsIGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKCdvbkhvbGQnLCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogY3JlYXRlIHRoZSB0b29sYmFyIHRvIGVkaXQgZWRnZXNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZWRpdEVkZ2VNb2RlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBlZGl0RWRnZU1vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIGd1aSwgZW5hYmxlIGVkaXQgbW9kZSBpZiBpdCB3YXNuJ3QgYWxyZWFkeS5cbiAgICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgIT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXN0b3JlIHRoZSBzdGF0ZSBvZiBhbnkgYm91bmQgZnVuY3Rpb25zIG9yIGV2ZW50cywgcmVtb3ZlIGNvbnRyb2wgbm9kZXMsIHJlc3RvcmUgcGh5c2ljc1xuICAgICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICAgIHRoaXMuaW5Nb2RlID0gJ2VkaXRFZGdlJztcbiAgICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTtcbiAgICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTSA9IHt9O1xuICAgICAgICAgIHRoaXMuX2NyZWF0ZUJhY2tCdXR0b24obG9jYWxlKTtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoKTtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVEZXNjcmlwdGlvbihsb2NhbGVbJ2VkaXRFZGdlRGVzY3JpcHRpb24nXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXVsnZWRpdEVkZ2VEZXNjcmlwdGlvbiddKTtcblxuICAgICAgICAgIC8vIGJpbmQgdGhlIGNsb3NlIGJ1dHRvblxuICAgICAgICAgIHRoaXMuX2JpbmRIYW1tZXJUb0Rpdih0aGlzLmNsb3NlRGl2LCB0aGlzLnRvZ2dsZUVkaXRNb2RlLmJpbmQodGhpcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZEVkZ2VzKClbMF07XG4gICAgICAgIGlmICh0aGlzLmVkZ2VCZWluZ0VkaXRlZElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVkZ2UgPSBfdGhpczMuYm9keS5lZGdlc1tfdGhpczMuZWRnZUJlaW5nRWRpdGVkSWRdO1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgY29udHJvbCBub2Rlc1xuICAgICAgICAgICAgdmFyIGNvbnRyb2xOb2RlRnJvbSA9IF90aGlzMy5fZ2V0TmV3VGFyZ2V0Tm9kZShlZGdlLmZyb20ueCwgZWRnZS5mcm9tLnkpO1xuICAgICAgICAgICAgdmFyIGNvbnRyb2xOb2RlVG8gPSBfdGhpczMuX2dldE5ld1RhcmdldE5vZGUoZWRnZS50by54LCBlZGdlLnRvLnkpO1xuXG4gICAgICAgICAgICBfdGhpczMudGVtcG9yYXJ5SWRzLm5vZGVzLnB1c2goY29udHJvbE5vZGVGcm9tLmlkKTtcbiAgICAgICAgICAgIF90aGlzMy50ZW1wb3JhcnlJZHMubm9kZXMucHVzaChjb250cm9sTm9kZVRvLmlkKTtcblxuICAgICAgICAgICAgX3RoaXMzLmJvZHkubm9kZXNbY29udHJvbE5vZGVGcm9tLmlkXSA9IGNvbnRyb2xOb2RlRnJvbTtcbiAgICAgICAgICAgIF90aGlzMy5ib2R5Lm5vZGVJbmRpY2VzLnB1c2goY29udHJvbE5vZGVGcm9tLmlkKTtcbiAgICAgICAgICAgIF90aGlzMy5ib2R5Lm5vZGVzW2NvbnRyb2xOb2RlVG8uaWRdID0gY29udHJvbE5vZGVUbztcbiAgICAgICAgICAgIF90aGlzMy5ib2R5Lm5vZGVJbmRpY2VzLnB1c2goY29udHJvbE5vZGVUby5pZCk7XG5cbiAgICAgICAgICAgIC8vIHRlbXBvcmFyaWx5IG92ZXJsb2FkIFVJIGZ1bmN0aW9ucywgY2xlYW5lZCB1cCBhdXRvbWF0aWNhbGx5IGJlY2F1c2Ugb2YgX3RlbXBvcmFyeUJpbmRVSVxuICAgICAgICAgICAgX3RoaXMzLl90ZW1wb3JhcnlCaW5kVUkoJ29uVG91Y2gnLCBfdGhpczMuX2NvbnRyb2xOb2RlVG91Y2guYmluZChfdGhpczMpKTsgLy8gdXNlZCB0byBnZXQgdGhlIHBvc2l0aW9uXG4gICAgICAgICAgICBfdGhpczMuX3RlbXBvcmFyeUJpbmRVSSgnb25UYXAnLCBmdW5jdGlvbiAoKSB7fSk7IC8vIGRpc2FibGVkXG4gICAgICAgICAgICBfdGhpczMuX3RlbXBvcmFyeUJpbmRVSSgnb25Ib2xkJywgZnVuY3Rpb24gKCkge30pOyAvLyBkaXNhYmxlZFxuICAgICAgICAgICAgX3RoaXMzLl90ZW1wb3JhcnlCaW5kVUkoJ29uRHJhZ1N0YXJ0JywgX3RoaXMzLl9jb250cm9sTm9kZURyYWdTdGFydC5iaW5kKF90aGlzMykpOyAvLyB1c2VkIHRvIHNlbGVjdCBjb250cm9sIG5vZGVcbiAgICAgICAgICAgIF90aGlzMy5fdGVtcG9yYXJ5QmluZFVJKCdvbkRyYWcnLCBfdGhpczMuX2NvbnRyb2xOb2RlRHJhZy5iaW5kKF90aGlzMykpOyAvLyB1c2VkIHRvIGRyYWcgY29udHJvbCBub2RlXG4gICAgICAgICAgICBfdGhpczMuX3RlbXBvcmFyeUJpbmRVSSgnb25EcmFnRW5kJywgX3RoaXMzLl9jb250cm9sTm9kZURyYWdFbmQuYmluZChfdGhpczMpKTsgLy8gdXNlZCB0byBjb25uZWN0IG9yIHJldmVydCBjb250cm9sIG5vZGVzXG4gICAgICAgICAgICBfdGhpczMuX3RlbXBvcmFyeUJpbmRVSSgnb25Nb3VzZU1vdmUnLCBmdW5jdGlvbiAoKSB7fSk7IC8vIGRpc2FibGVkXG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBmdW5jdGlvbiB0byBwb3NpdGlvbiBjb250cm9sIG5vZGVzIGNvcnJlY3RseSBvbiBtb3ZlbWVudFxuICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSBjbGVhbmVkIHVwIGJlY2F1c2Ugd2UgdXNlIHRoZSB0ZW1wb3JhcnkgYmluZFxuICAgICAgICAgICAgX3RoaXMzLl90ZW1wb3JhcnlCaW5kRXZlbnQoJ2JlZm9yZURyYXdpbmcnLCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSBlZGdlLmVkZ2VUeXBlLmZpbmRCb3JkZXJQb3NpdGlvbnMoY3R4KTtcbiAgICAgICAgICAgICAgaWYgKGNvbnRyb2xOb2RlRnJvbS5zZWxlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sTm9kZUZyb20ueCA9IHBvc2l0aW9ucy5mcm9tLng7XG4gICAgICAgICAgICAgICAgY29udHJvbE5vZGVGcm9tLnkgPSBwb3NpdGlvbnMuZnJvbS55O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb250cm9sTm9kZVRvLnNlbGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xOb2RlVG8ueCA9IHBvc2l0aW9ucy50by54O1xuICAgICAgICAgICAgICAgIGNvbnRyb2xOb2RlVG8ueSA9IHBvc2l0aW9ucy50by55O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgX3RoaXMzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVkcmF3Jyk7XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGRlbGV0ZSBldmVyeXRoaW5nIGluIHRoZSBzZWxlY3Rpb25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGVsZXRlU2VsZWN0ZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZVNlbGVjdGVkKCkge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICAvLyB3aGVuIHVzaW5nIHRoZSBndWksIGVuYWJsZSBlZGl0IG1vZGUgaWYgaXQgd2FzbnQgYWxyZWFkeS5cbiAgICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgIT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXN0b3JlIHRoZSBzdGF0ZSBvZiBhbnkgYm91bmQgZnVuY3Rpb25zIG9yIGV2ZW50cywgcmVtb3ZlIGNvbnRyb2wgbm9kZXMsIHJlc3RvcmUgcGh5c2ljc1xuICAgICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICAgIHRoaXMuaW5Nb2RlID0gJ2RlbGV0ZSc7XG4gICAgICAgIHZhciBzZWxlY3RlZE5vZGVzID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkTm9kZXMoKTtcbiAgICAgICAgdmFyIHNlbGVjdGVkRWRnZXMgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWRFZGdlcygpO1xuICAgICAgICB2YXIgZGVsZXRlRnVuY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChzZWxlY3RlZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbc2VsZWN0ZWROb2Rlc1tpXV0uaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIGFsZXJ0KHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdWydkZWxldGVDbHVzdGVyRXJyb3InXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXVsnZGVsZXRlQ2x1c3RlckVycm9yJ10pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuZGVsZXRlTm9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZGVsZXRlRnVuY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGVsZXRlTm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRFZGdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuZGVsZXRlRWRnZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZGVsZXRlRnVuY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGVsZXRlRWRnZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRlbGV0ZUZ1bmN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSB7IG5vZGVzOiBzZWxlY3RlZE5vZGVzLCBlZGdlczogc2VsZWN0ZWRFZGdlcyB9O1xuICAgICAgICAgIGlmIChkZWxldGVGdW5jdGlvbi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIGRlbGV0ZUZ1bmN0aW9uKGRhdGEsIGZ1bmN0aW9uIChmaW5hbGl6ZWREYXRhKSB7XG4gICAgICAgICAgICAgIGlmIChmaW5hbGl6ZWREYXRhICE9PSBudWxsICYmIGZpbmFsaXplZERhdGEgIT09IHVuZGVmaW5lZCAmJiBfdGhpczQuaW5Nb2RlID09PSAnZGVsZXRlJykge1xuICAgICAgICAgICAgICAgIC8vIGlmIGZvciB3aGF0ZXZlciByZWFzb24gdGhlIG1vZGUgaGFzIGNoYW5nZXMgKGR1ZSB0byBkYXRhc2V0IGNoYW5nZSkgZGlzcmVnYXJkIHRoZSBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIF90aGlzNC5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLnJlbW92ZShmaW5hbGl6ZWREYXRhLmVkZ2VzKTtcbiAgICAgICAgICAgICAgICBfdGhpczQuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKS5yZW1vdmUoZmluYWxpemVkRGF0YS5ub2Rlcyk7XG4gICAgICAgICAgICAgICAgX3RoaXM0LmJvZHkuZW1pdHRlci5lbWl0KCdzdGFydFNpbXVsYXRpb24nKTtcbiAgICAgICAgICAgICAgICBfdGhpczQuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzNC5ib2R5LmVtaXR0ZXIuZW1pdCgnc3RhcnRTaW11bGF0aW9uJyk7XG4gICAgICAgICAgICAgICAgX3RoaXM0LnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGZ1bmN0aW9uIGZvciBkZWxldGUgZG9lcyBub3Qgc3VwcG9ydCB0d28gYXJndW1lbnRzIChkYXRhLCBjYWxsYmFjayknKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLnJlbW92ZShzZWxlY3RlZEVkZ2VzKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZGF0YS5ub2Rlcy5nZXREYXRhU2V0KCkucmVtb3ZlKHNlbGVjdGVkTm9kZXMpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3N0YXJ0U2ltdWxhdGlvbicpO1xuICAgICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBQUklWQVRFICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8vXG5cbiAgICAgIC8qKlxuICAgICAgICogZHJhdyBvciByZW1vdmUgdGhlIERPTVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3NldHVwJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIEVuYWJsZSB0aGUgR1VJXG4gICAgICAgICAgdGhpcy5ndWlFbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICAgIHRoaXMuX2NyZWF0ZVdyYXBwZXJzKCk7XG4gICAgICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVFZGl0QnV0dG9uKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVNYW5pcHVsYXRpb25ET00oKTtcblxuICAgICAgICAgIC8vIGRpc2FibGUgdGhlIGd1aVxuICAgICAgICAgIHRoaXMuZ3VpRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogY3JlYXRlIHRoZSBkaXYgb3ZlcmxheXMgdGhhdCBjb250YWluIHRoZSBET01cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jcmVhdGVXcmFwcGVycycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZVdyYXBwZXJzKCkge1xuICAgICAgICAvLyBsb2FkIHRoZSBtYW5pcHVsYXRvciBIVE1MIGVsZW1lbnRzLiBBbGwgc3R5bGluZyBkb25lIGluIGNzcy5cbiAgICAgICAgaWYgKHRoaXMubWFuaXB1bGF0aW9uRGl2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmNsYXNzTmFtZSA9ICd2aXMtbWFuaXB1bGF0aW9uJztcbiAgICAgICAgICBpZiAodGhpcy5lZGl0TW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMubWFuaXB1bGF0aW9uRGl2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnRhaW5lciBmb3IgdGhlIGVkaXQgYnV0dG9uLlxuICAgICAgICBpZiAodGhpcy5lZGl0TW9kZURpdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5lZGl0TW9kZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHRoaXMuZWRpdE1vZGVEaXYuY2xhc3NOYW1lID0gJ3Zpcy1lZGl0LW1vZGUnO1xuICAgICAgICAgIGlmICh0aGlzLmVkaXRNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRNb2RlRGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdE1vZGVEaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuZWRpdE1vZGVEaXYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29udGFpbmVyIGZvciB0aGUgY2xvc2UgZGl2IGJ1dHRvblxuICAgICAgICBpZiAodGhpcy5jbG9zZURpdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHRoaXMuY2xvc2VEaXYuY2xhc3NOYW1lID0gJ3Zpcy1jbG9zZSc7XG4gICAgICAgICAgdGhpcy5jbG9zZURpdi5zdHlsZS5kaXNwbGF5ID0gdGhpcy5tYW5pcHVsYXRpb25EaXYuc3R5bGUuZGlzcGxheTtcbiAgICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmNsb3NlRGl2KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGdlbmVyYXRlIGEgbmV3IHRhcmdldCBub2RlLiBVc2VkIGZvciBjcmVhdGluZyBuZXcgZWRnZXMgYW5kIGVkaXRpbmcgZWRnZXNcbiAgICAgICAqIEBwYXJhbSB4XG4gICAgICAgKiBAcGFyYW0geVxuICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0TmV3VGFyZ2V0Tm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldE5ld1RhcmdldE5vZGUoeCwgeSkge1xuICAgICAgICB2YXIgY29udHJvbE5vZGVTdHlsZSA9IHV0aWwuZGVlcEV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLmNvbnRyb2xOb2RlU3R5bGUpO1xuXG4gICAgICAgIGNvbnRyb2xOb2RlU3R5bGUuaWQgPSAndGFyZ2V0Tm9kZScgKyB1dGlsLnJhbmRvbVVVSUQoKTtcbiAgICAgICAgY29udHJvbE5vZGVTdHlsZS5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgY29udHJvbE5vZGVTdHlsZS5waHlzaWNzID0gZmFsc2U7XG4gICAgICAgIGNvbnRyb2xOb2RlU3R5bGUueCA9IHg7XG4gICAgICAgIGNvbnRyb2xOb2RlU3R5bGUueSA9IHk7XG5cbiAgICAgICAgLy8gd2UgaGF2ZSB0byBkZWZpbmUgdGhlIGJvdW5kaW5nIGJveCBpbiBvcmRlciBmb3IgdGhlIG5vZGVzIHRvIGJlIGRyYXduIGltbWVkaWF0ZWx5XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVOb2RlKGNvbnRyb2xOb2RlU3R5bGUpO1xuICAgICAgICBub2RlLnNoYXBlLmJvdW5kaW5nQm94ID0geyBsZWZ0OiB4LCByaWdodDogeCwgdG9wOiB5LCBib3R0b206IHkgfTtcblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGUgdGhlIGVkaXQgYnV0dG9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jcmVhdGVFZGl0QnV0dG9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlRWRpdEJ1dHRvbigpIHtcbiAgICAgICAgLy8gcmVzdG9yZSBldmVyeXRoaW5nIHRvIGl0J3Mgb3JpZ2luYWwgc3RhdGUgKGlmIGFwcGxpY2FibGUpXG4gICAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgICAgLy8gcmVzZXQgdGhlIG1hbmlwdWxhdGlvbkRPTVxuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTSA9IHt9O1xuXG4gICAgICAgIC8vIGVtcHR5IHRoZSBlZGl0TW9kZURpdlxuICAgICAgICB1dGlsLnJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLmVkaXRNb2RlRGl2KTtcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGNvbnRlbnRzIGZvciB0aGUgZWRpdE1vZGUgYnV0dG9uXG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTtcbiAgICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbignZWRpdE1vZGUnLCAndmlzLWJ1dHRvbiB2aXMtZWRpdCB2aXMtZWRpdC1tb2RlJywgbG9jYWxlWydlZGl0J10gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbJ2VuJ11bJ2VkaXQnXSk7XG4gICAgICAgIHRoaXMuZWRpdE1vZGVEaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcblxuICAgICAgICAvLyBiaW5kIGEgaGFtbWVyIGxpc3RlbmVyIHRvIHRoZSBidXR0b24sIGNhbGxpbmcgdGhlIGZ1bmN0aW9uIHRvZ2dsZUVkaXRNb2RlLlxuICAgICAgICB0aGlzLl9iaW5kSGFtbWVyVG9EaXYoYnV0dG9uLCB0aGlzLnRvZ2dsZUVkaXRNb2RlLmJpbmQodGhpcykpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHRoaXMgZnVuY3Rpb24gY2xlYW5zIHVwIGFmdGVyIGV2ZXJ5dGhpbmcgdGhpcyBtb2R1bGUgZG9lcy4gVGVtcG9yYXJ5IGVsZW1lbnRzLCBmdW5jdGlvbnMgYW5kIGV2ZW50cyBhcmUgcmVtb3ZlZCwgcGh5c2ljcyByZXN0b3JlZCwgaGFtbWVycyByZW1vdmVkLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NsZWFuJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xlYW4oKSB7XG4gICAgICAgIC8vIG5vdCBpbiBtb2RlXG4gICAgICAgIHRoaXMuaW5Nb2RlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gX2NsZWFuIHRoZSBkaXZzXG4gICAgICAgIGlmICh0aGlzLmd1aUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB1dGlsLnJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLmVkaXRNb2RlRGl2KTtcbiAgICAgICAgICB1dGlsLnJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLm1hbmlwdWxhdGlvbkRpdik7XG5cbiAgICAgICAgICAvLyByZW1vdmVzIGFsbCB0aGUgYmluZGluZ3MgYW5kIG92ZXJsb2Fkc1xuICAgICAgICAgIHRoaXMuX2NsZWFuTWFuaXB1bGF0b3JIYW1tZXJzKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgdGVtcG9yYXJ5IG5vZGVzIGFuZCBlZGdlc1xuICAgICAgICB0aGlzLl9jbGVhbnVwVGVtcG9yYXJ5Tm9kZXNBbmRFZGdlcygpO1xuXG4gICAgICAgIC8vIHJlc3RvcmUgb3ZlcmxvYWRlZCBVSSBmdW5jdGlvbnNcbiAgICAgICAgdGhpcy5fdW5iaW5kVGVtcG9yYXJ5VUlzKCk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIHRoZSB0ZW1wb3JhcnlFdmVudEZ1bmN0aW9uc1xuICAgICAgICB0aGlzLl91bmJpbmRUZW1wb3JhcnlFdmVudHMoKTtcblxuICAgICAgICAvLyByZXN0b3JlIHRoZSBwaHlzaWNzIGlmIHJlcXVpcmVkXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3Jlc3RvcmVQaHlzaWNzJyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRWFjaCBkb20gZWxlbWVudCBoYXMgaXQncyBvd24gaGFtbWVyLiBUaGV5IGFyZSBzdG9yZWQgaW4gdGhpcy5tYW5pcHVsYXRpb25IYW1tZXJzLiBUaGlzIGNsZWFucyB0aGVtIHVwLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NsZWFuTWFuaXB1bGF0b3JIYW1tZXJzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xlYW5NYW5pcHVsYXRvckhhbW1lcnMoKSB7XG4gICAgICAgIC8vIF9jbGVhbiBoYW1tZXIgYmluZGluZ3NcbiAgICAgICAgaWYgKHRoaXMubWFuaXB1bGF0aW9uSGFtbWVycy5sZW5ndGggIT0gMCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYW5pcHVsYXRpb25IYW1tZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkhhbW1lcnNbaV0uZGVzdHJveSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkhhbW1lcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBhbGwgRE9NIGVsZW1lbnRzIGNyZWF0ZWQgYnkgdGhpcyBtb2R1bGUuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcmVtb3ZlTWFuaXB1bGF0aW9uRE9NJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlTWFuaXB1bGF0aW9uRE9NKCkge1xuICAgICAgICAvLyByZW1vdmVzIGFsbCB0aGUgYmluZGluZ3MgYW5kIG92ZXJsb2Fkc1xuICAgICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICAgIC8vIGVtcHR5IHRoZSBtYW5pcHVsYXRpb24gZGl2c1xuICAgICAgICB1dGlsLnJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLm1hbmlwdWxhdGlvbkRpdik7XG4gICAgICAgIHV0aWwucmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMuZWRpdE1vZGVEaXYpO1xuICAgICAgICB1dGlsLnJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLmNsb3NlRGl2KTtcblxuICAgICAgICAvLyByZW1vdmUgdGhlIG1hbmlwdWxhdGlvbiBkaXZzXG4gICAgICAgIGlmICh0aGlzLm1hbmlwdWxhdGlvbkRpdikge1xuICAgICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLnJlbW92ZUNoaWxkKHRoaXMubWFuaXB1bGF0aW9uRGl2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lZGl0TW9kZURpdikge1xuICAgICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLnJlbW92ZUNoaWxkKHRoaXMuZWRpdE1vZGVEaXYpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNsb3NlRGl2KSB7XG4gICAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUucmVtb3ZlQ2hpbGQodGhpcy5jbG9zZURpdik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdGhlIHJlZmVyZW5jZXMgdG8gdW5kZWZpbmVkXG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmVkaXRNb2RlRGl2ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNsb3NlRGl2ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGNyZWF0ZSBhIHNlcGVyYXRvciBsaW5lLiB0aGUgaW5kZXggaXMgdG8gZGlmZmVyZW50aWF0ZSBpbiB0aGUgbWFuaXB1bGF0aW9uIGRvbVxuICAgICAgICogQHBhcmFtIGluZGV4XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY3JlYXRlU2VwZXJhdG9yJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlU2VwZXJhdG9yKCkge1xuICAgICAgICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDE7XG5cbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01bJ3NlcGVyYXRvckxpbmVEaXYnICsgaW5kZXhdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NWydzZXBlcmF0b3JMaW5lRGl2JyArIGluZGV4XS5jbGFzc05hbWUgPSAndmlzLXNlcGFyYXRvci1saW5lJztcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQodGhpcy5tYW5pcHVsYXRpb25ET01bJ3NlcGVyYXRvckxpbmVEaXYnICsgaW5kZXhdKTtcbiAgICAgIH1cblxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgICBET00gZnVuY3Rpb25zIGZvciBidXR0b25zICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jcmVhdGVBZGROb2RlQnV0dG9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQWRkTm9kZUJ1dHRvbihsb2NhbGUpIHtcbiAgICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbignYWRkTm9kZScsICd2aXMtYnV0dG9uIHZpcy1hZGQnLCBsb2NhbGVbJ2FkZE5vZGUnXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXVsnYWRkTm9kZSddKTtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgICAgdGhpcy5fYmluZEhhbW1lclRvRGl2KGJ1dHRvbiwgdGhpcy5hZGROb2RlTW9kZS5iaW5kKHRoaXMpKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY3JlYXRlQWRkRWRnZUJ1dHRvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUFkZEVkZ2VCdXR0b24obG9jYWxlKSB7XG4gICAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oJ2FkZEVkZ2UnLCAndmlzLWJ1dHRvbiB2aXMtY29ubmVjdCcsIGxvY2FsZVsnYWRkRWRnZSddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydhZGRFZGdlJ10pO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgICAgICB0aGlzLl9iaW5kSGFtbWVyVG9EaXYoYnV0dG9uLCB0aGlzLmFkZEVkZ2VNb2RlLmJpbmQodGhpcykpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jcmVhdGVFZGl0Tm9kZUJ1dHRvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUVkaXROb2RlQnV0dG9uKGxvY2FsZSkge1xuICAgICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKCdlZGl0Tm9kZScsICd2aXMtYnV0dG9uIHZpcy1lZGl0JywgbG9jYWxlWydlZGl0Tm9kZSddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydlZGl0Tm9kZSddKTtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgICAgdGhpcy5fYmluZEhhbW1lclRvRGl2KGJ1dHRvbiwgdGhpcy5lZGl0Tm9kZS5iaW5kKHRoaXMpKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY3JlYXRlRWRpdEVkZ2VCdXR0b24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVFZGl0RWRnZUJ1dHRvbihsb2NhbGUpIHtcbiAgICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbignZWRpdEVkZ2UnLCAndmlzLWJ1dHRvbiB2aXMtZWRpdCcsIGxvY2FsZVsnZWRpdEVkZ2UnXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXVsnZWRpdEVkZ2UnXSk7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgICAgIHRoaXMuX2JpbmRIYW1tZXJUb0RpdihidXR0b24sIHRoaXMuZWRpdEVkZ2VNb2RlLmJpbmQodGhpcykpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jcmVhdGVEZWxldGVCdXR0b24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVEZWxldGVCdXR0b24obG9jYWxlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgICAgdmFyIGRlbGV0ZUJ0bkNsYXNzID0gJ3Zpcy1idXR0b24gdmlzLWRlbGV0ZS1ydGwnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkZWxldGVCdG5DbGFzcyA9ICd2aXMtYnV0dG9uIHZpcy1kZWxldGUnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oJ2RlbGV0ZScsIGRlbGV0ZUJ0bkNsYXNzLCBsb2NhbGVbJ2RlbCddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydkZWwnXSk7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgICAgIHRoaXMuX2JpbmRIYW1tZXJUb0RpdihidXR0b24sIHRoaXMuZGVsZXRlU2VsZWN0ZWQuYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2NyZWF0ZUJhY2tCdXR0b24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVCYWNrQnV0dG9uKGxvY2FsZSkge1xuICAgICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKCdiYWNrJywgJ3Zpcy1idXR0b24gdmlzLWJhY2snLCBsb2NhbGVbJ2JhY2snXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXVsnYmFjayddKTtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgICAgdGhpcy5fYmluZEhhbW1lclRvRGl2KGJ1dHRvbiwgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyLmJpbmQodGhpcykpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jcmVhdGVCdXR0b24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVCdXR0b24oaWQsIGNsYXNzTmFtZSwgbGFiZWwpIHtcbiAgICAgICAgdmFyIGxhYmVsQ2xhc3NOYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAndmlzLWxhYmVsJztcblxuXG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgJ0RpdiddID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgJ0RpdiddLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyAnTGFiZWwnXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArICdMYWJlbCddLmNsYXNzTmFtZSA9IGxhYmVsQ2xhc3NOYW1lO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArICdMYWJlbCddLmlubmVySFRNTCA9IGxhYmVsO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArICdEaXYnXS5hcHBlbmRDaGlsZCh0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArICdMYWJlbCddKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgJ0RpdiddO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jcmVhdGVEZXNjcmlwdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZURlc2NyaXB0aW9uKGxhYmVsKSB7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKHRoaXMuX2NyZWF0ZUJ1dHRvbignZGVzY3JpcHRpb24nLCAndmlzLWJ1dHRvbiB2aXMtbm9uZScsIGxhYmVsKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVuZCBvZiBET00gZnVuY3Rpb25zIGZvciBidXR0b25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAgIC8qKlxuICAgICAgICogdGhpcyBiaW5kcyBhbiBldmVudCB1bnRpbCBjbGVhbnVwIGJ5IHRoZSBjbGVhbiBmdW5jdGlvbnMuXG4gICAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgICAqIEBwYXJhbSBuZXdGdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3RlbXBvcmFyeUJpbmRFdmVudCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3RlbXBvcmFyeUJpbmRFdmVudChldmVudCwgbmV3RnVuY3Rpb24pIHtcbiAgICAgICAgdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9ucy5wdXNoKHsgZXZlbnQ6IGV2ZW50LCBib3VuZEZ1bmN0aW9uOiBuZXdGdW5jdGlvbiB9KTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oZXZlbnQsIG5ld0Z1bmN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB0aGlzIG92ZXJyaWRlcyBhbiBVSSBmdW5jdGlvbiB1bnRpbCBjbGVhbnVwIGJ5IHRoZSBjbGVhbiBmdW5jdGlvblxuICAgICAgICogQHBhcmFtIFVJZnVuY3Rpb25OYW1lXG4gICAgICAgKiBAcGFyYW0gbmV3RnVuY3Rpb25cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ190ZW1wb3JhcnlCaW5kVUknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90ZW1wb3JhcnlCaW5kVUkoVUlmdW5jdGlvbk5hbWUsIG5ld0Z1bmN0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnNbVUlmdW5jdGlvbk5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zW1VJZnVuY3Rpb25OYW1lXSA9IHRoaXMuYm9keS5ldmVudExpc3RlbmVyc1tVSWZ1bmN0aW9uTmFtZV07XG4gICAgICAgICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzW1VJZnVuY3Rpb25OYW1lXSA9IG5ld0Z1bmN0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBVSSBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdC4gVHlwbz8gWW91IHRyaWVkOiAnICsgVUlmdW5jdGlvbk5hbWUgKyAnIHBvc3NpYmxlIGFyZTogJyArIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHRoaXMuYm9keS5ldmVudExpc3RlbmVycykpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlc3RvcmUgdGhlIG92ZXJyaWRkZW4gVUkgZnVuY3Rpb25zIHRvIHRoZWlyIG9yaWdpbmFsIHN0YXRlLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ191bmJpbmRUZW1wb3JhcnlVSXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bmJpbmRUZW1wb3JhcnlVSXMoKSB7XG4gICAgICAgIGZvciAodmFyIGZ1bmN0aW9uTmFtZSBpbiB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zKSB7XG4gICAgICAgICAgaWYgKHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnMuaGFzT3duUHJvcGVydHkoZnVuY3Rpb25OYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzW2Z1bmN0aW9uTmFtZV0gPSB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zW2Z1bmN0aW9uTmFtZV07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9uc1tmdW5jdGlvbk5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVW5iaW5kIHRoZSBldmVudHMgY3JlYXRlZCBieSBfdGVtcG9yYXJ5QmluZEV2ZW50XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdW5iaW5kVGVtcG9yYXJ5RXZlbnRzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5iaW5kVGVtcG9yYXJ5RXZlbnRzKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZXZlbnROYW1lID0gdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9uc1tpXS5ldmVudDtcbiAgICAgICAgICB2YXIgYm91bmRGdW5jdGlvbiA9IHRoaXMudGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnNbaV0uYm91bmRGdW5jdGlvbjtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vZmYoZXZlbnROYW1lLCBib3VuZEZ1bmN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zID0gW107XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQmluZCBhbiBoYW1tZXIgaW5zdGFuY2UgdG8gYSBET00gZWxlbWVudC5cbiAgICAgICAqIEBwYXJhbSBkb21FbGVtZW50XG4gICAgICAgKiBAcGFyYW0gZnVuY3RcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2JpbmRIYW1tZXJUb0RpdicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRIYW1tZXJUb0Rpdihkb21FbGVtZW50LCBib3VuZEZ1bmN0aW9uKSB7XG4gICAgICAgIHZhciBoYW1tZXIgPSBuZXcgSGFtbWVyKGRvbUVsZW1lbnQsIHt9KTtcbiAgICAgICAgaGFtbWVyVXRpbC5vblRvdWNoKGhhbW1lciwgYm91bmRGdW5jdGlvbik7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uSGFtbWVycy5wdXNoKGhhbW1lcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTmVhdGx5IGNsZWFuIHVwIHRlbXBvcmFyeSBlZGdlcyBhbmQgbm9kZXNcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jbGVhbnVwVGVtcG9yYXJ5Tm9kZXNBbmRFZGdlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NsZWFudXBUZW1wb3JhcnlOb2Rlc0FuZEVkZ2VzKCkge1xuICAgICAgICAvLyBfY2xlYW4gdGVtcG9yYXJ5IGVkZ2VzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZWRnZXNbdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbaV1dLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5ib2R5LmVkZ2VzW3RoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzW2ldXTtcbiAgICAgICAgICB2YXIgaW5kZXhUZW1wRWRnZSA9IHRoaXMuYm9keS5lZGdlSW5kaWNlcy5pbmRleE9mKHRoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzW2ldKTtcbiAgICAgICAgICBpZiAoaW5kZXhUZW1wRWRnZSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keS5lZGdlSW5kaWNlcy5zcGxpY2UoaW5kZXhUZW1wRWRnZSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gX2NsZWFuIHRlbXBvcmFyeSBub2Rlc1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy50ZW1wb3JhcnlJZHMubm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuYm9keS5ub2Rlc1t0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1tfaV1dO1xuICAgICAgICAgIHZhciBpbmRleFRlbXBOb2RlID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmluZGV4T2YodGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbX2ldKTtcbiAgICAgICAgICBpZiAoaW5kZXhUZW1wTm9kZSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5zcGxpY2UoaW5kZXhUZW1wTm9kZSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50ZW1wb3JhcnlJZHMgPSB7IG5vZGVzOiBbXSwgZWRnZXM6IFtdIH07XG4gICAgICB9XG5cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFRElUIEVER0UgRlVOQ1RJT05TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuICAgICAgLyoqXG4gICAgICAgKiB0aGUgdG91Y2ggaXMgdXNlZCB0byBnZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBpbml0aWFsIGNsaWNrXG4gICAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jb250cm9sTm9kZVRvdWNoJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY29udHJvbE5vZGVUb3VjaChldmVudCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2ggPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2gudHJhbnNsYXRpb24gPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24pOyAvLyBjb3B5IHRoZSBvYmplY3RcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB0aGUgZHJhZyBzdGFydCBpcyB1c2VkIHRvIG1hcmsgb25lIG9mIHRoZSBjb250cm9sIG5vZGVzIGFzIHNlbGVjdGVkLlxuICAgICAgICogQHBhcmFtIGV2ZW50XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY29udHJvbE5vZGVEcmFnU3RhcnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jb250cm9sTm9kZURyYWdTdGFydChldmVudCkge1xuICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMubGFzdFRvdWNoO1xuICAgICAgICB2YXIgcG9pbnRlck9iaiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fcG9pbnRlclRvUG9zaXRpb25PYmplY3QocG9pbnRlcik7XG4gICAgICAgIHZhciBmcm9tID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMudGVtcG9yYXJ5SWRzLm5vZGVzWzBdXTtcbiAgICAgICAgdmFyIHRvID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMudGVtcG9yYXJ5SWRzLm5vZGVzWzFdXTtcbiAgICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZF07XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICB2YXIgZnJvbVNlbGVjdCA9IGZyb20uaXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaik7XG4gICAgICAgIHZhciB0b1NlbGVjdCA9IHRvLmlzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopO1xuXG4gICAgICAgIGlmIChmcm9tU2VsZWN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlID0gZnJvbTtcbiAgICAgICAgICBlZGdlLmVkZ2VUeXBlLmZyb20gPSBmcm9tO1xuICAgICAgICB9IGVsc2UgaWYgKHRvU2VsZWN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlID0gdG87XG4gICAgICAgICAgZWRnZS5lZGdlVHlwZS50byA9IHRvO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2UgdXNlIHRoZSBzZWxlY3Rpb24gdG8gZmluZCB0aGUgbm9kZSB0aGF0IGlzIGJlaW5nIGRyYWdnZWQuIFdlIGV4cGxpY2l0bHkgc2VsZWN0IGl0IGhlcmUuXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RPYmplY3QodGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZWRyYXcnKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBkcmFnZ2luZyB0aGUgY29udHJvbCBub2RlcyBvciB0aGUgY2FudmFzXG4gICAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jb250cm9sTm9kZURyYWcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jb250cm9sTm9kZURyYWcoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnZGlzYWJsZVBoeXNpY3MnKTtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHBvaW50ZXIpO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUueCA9IHBvcy54O1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZS55ID0gcG9zLnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGRyYWcgd2FzIG5vdCBzdGFydGVkIHByb3Blcmx5IGJlY2F1c2UgdGhlIGNsaWNrIHN0YXJ0ZWQgb3V0c2lkZSB0aGUgbmV0d29yayBkaXYsIHN0YXJ0IGl0IG5vdy5cbiAgICAgICAgICB2YXIgZGlmZlggPSBwb2ludGVyLnggLSB0aGlzLmxhc3RUb3VjaC54O1xuICAgICAgICAgIHZhciBkaWZmWSA9IHBvaW50ZXIueSAtIHRoaXMubGFzdFRvdWNoLnk7XG4gICAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7IHg6IHRoaXMubGFzdFRvdWNoLnRyYW5zbGF0aW9uLnggKyBkaWZmWCwgeTogdGhpcy5sYXN0VG91Y2gudHJhbnNsYXRpb24ueSArIGRpZmZZIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlZHJhdycpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGNvbm5lY3Rpbmcgb3IgcmVzdG9yaW5nIHRoZSBjb250cm9sIG5vZGVzLlxuICAgICAgICogQHBhcmFtIGV2ZW50XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY29udHJvbE5vZGVEcmFnRW5kJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY29udHJvbE5vZGVEcmFnRW5kKGV2ZW50KSB7XG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgIHZhciBwb2ludGVyT2JqID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChwb2ludGVyKTtcbiAgICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZF07XG4gICAgICAgIC8vIGlmIHRoZSBub2RlIHRoYXQgd2FzIGRyYWdnZWQgaXMgbm90IGEgY29udHJvbCBub2RlLCByZXR1cm5cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2UgdXNlIHRoZSBzZWxlY3Rpb24gdG8gZmluZCB0aGUgbm9kZSB0aGF0IGlzIGJlaW5nIGRyYWdnZWQuIFdlIGV4cGxpY2l0bHkgREVzZWxlY3QgdGhlIGNvbnRyb2wgbm9kZSBoZXJlLlxuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgICAgdmFyIG92ZXJsYXBwaW5nTm9kZUlkcyA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2V0QWxsTm9kZXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaik7XG4gICAgICAgIHZhciBub2RlID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKHZhciBpID0gb3ZlcmxhcHBpbmdOb2RlSWRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKG92ZXJsYXBwaW5nTm9kZUlkc1tpXSAhPT0gdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlLmlkKSB7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW292ZXJsYXBwaW5nTm9kZUlkc1tpXV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGVyZm9ybSB0aGUgY29ubmVjdGlvblxuICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG5vZGUuaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVsnY3JlYXRlRWRnZUVycm9yJ10gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbJ2VuJ11bJ2NyZWF0ZUVkZ2VFcnJvciddKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZyb20gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMF1dO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZS5pZCA9PT0gZnJvbS5pZCkge1xuICAgICAgICAgICAgICB0aGlzLl9wZXJmb3JtRWRpdEVkZ2Uobm9kZS5pZCwgZWRnZS50by5pZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9wZXJmb3JtRWRpdEVkZ2UoZWRnZS5mcm9tLmlkLCBub2RlLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRnZS51cGRhdGVFZGdlVHlwZSgpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3Jlc3RvcmVQaHlzaWNzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlZHJhdycpO1xuICAgICAgfVxuXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRU5EIE9GIEVESVQgRURHRSBGVU5DVElPTlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG5cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gQUREIEVER0UgRlVOQ1RJT05TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cbiAgICAgIC8qKlxuICAgICAgICogdGhlIGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBzZWxlY3Rpb24gZXZlbnQuIEl0IGNoZWNrcyBpZiB5b3Ugd2FudCB0byBjb25uZWN0IGEgY2x1c3RlciBhbmQgY2hhbmdlcyB0aGUgZGVzY3JpcHRpb25cbiAgICAgICAqIHRvIHdhbGsgdGhlIHVzZXIgdGhyb3VnaCB0aGUgcHJvY2Vzcy5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfaGFuZGxlQ29ubmVjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUNvbm5lY3QoZXZlbnQpIHtcbiAgICAgICAgLy8gY2hlY2sgdG8gYXZvaWQgZG91YmxlIGZpcmVpbmcgb2YgdGhpcyBmdW5jdGlvbi5cbiAgICAgICAgaWYgKG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdGhpcy50b3VjaFRpbWUgPiAxMDApIHtcbiAgICAgICAgICB0aGlzLmxhc3RUb3VjaCA9IHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgICAgIHRoaXMubGFzdFRvdWNoLnRyYW5zbGF0aW9uID0gdXRpbC5leHRlbmQoe30sIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uKTsgLy8gY29weSB0aGUgb2JqZWN0XG5cbiAgICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMubGFzdFRvdWNoO1xuICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdChwb2ludGVyKTtcblxuICAgICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmlzQ2x1c3RlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVsnY3JlYXRlRWRnZUVycm9yJ10gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbJ2VuJ11bJ2NyZWF0ZUVkZ2VFcnJvciddKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIG5vZGUgdGhlIHRlbXBvcmFyeSBsaW5lIGNhbiBsb29rIGF0XG4gICAgICAgICAgICAgIHZhciB0YXJnZXROb2RlID0gdGhpcy5fZ2V0TmV3VGFyZ2V0Tm9kZShub2RlLngsIG5vZGUueSk7XG4gICAgICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1t0YXJnZXROb2RlLmlkXSA9IHRhcmdldE5vZGU7XG4gICAgICAgICAgICAgIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5wdXNoKHRhcmdldE5vZGUuaWQpO1xuXG4gICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHRlbXBvcmFyeSBlZGdlXG4gICAgICAgICAgICAgIHZhciBjb25uZWN0aW9uRWRnZSA9IHRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlRWRnZSh7XG4gICAgICAgICAgICAgICAgaWQ6ICdjb25uZWN0aW9uRWRnZScgKyB1dGlsLnJhbmRvbVVVSUQoKSxcbiAgICAgICAgICAgICAgICBmcm9tOiBub2RlLmlkLFxuICAgICAgICAgICAgICAgIHRvOiB0YXJnZXROb2RlLmlkLFxuICAgICAgICAgICAgICAgIHBoeXNpY3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNtb290aDoge1xuICAgICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb250aW51b3VzJyxcbiAgICAgICAgICAgICAgICAgIHJvdW5kbmVzczogMC41XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5ib2R5LmVkZ2VzW2Nvbm5lY3Rpb25FZGdlLmlkXSA9IGNvbm5lY3Rpb25FZGdlO1xuICAgICAgICAgICAgICB0aGlzLmJvZHkuZWRnZUluZGljZXMucHVzaChjb25uZWN0aW9uRWRnZS5pZCk7XG5cbiAgICAgICAgICAgICAgdGhpcy50ZW1wb3JhcnlJZHMubm9kZXMucHVzaCh0YXJnZXROb2RlLmlkKTtcbiAgICAgICAgICAgICAgdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXMucHVzaChjb25uZWN0aW9uRWRnZS5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudG91Y2hUaW1lID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZHJhZ0NvbnRyb2xOb2RlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhZ0NvbnRyb2xOb2RlKGV2ZW50KSB7XG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgIGlmICh0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1swXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHRhcmdldE5vZGUgPSB0aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMF1dOyAvLyB0aGVyZSBpcyBvbmx5IG9uZSB0ZW1wIG5vZGUgaW4gdGhlIGFkZCBlZGdlIG1vZGUuXG4gICAgICAgICAgdGFyZ2V0Tm9kZS54ID0gdGhpcy5jYW52YXMuX1hjb252ZXJ0RE9NdG9DYW52YXMocG9pbnRlci54KTtcbiAgICAgICAgICB0YXJnZXROb2RlLnkgPSB0aGlzLmNhbnZhcy5fWWNvbnZlcnRET010b0NhbnZhcyhwb2ludGVyLnkpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZWRyYXcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZGlmZlggPSBwb2ludGVyLnggLSB0aGlzLmxhc3RUb3VjaC54O1xuICAgICAgICAgIHZhciBkaWZmWSA9IHBvaW50ZXIueSAtIHRoaXMubGFzdFRvdWNoLnk7XG4gICAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7IHg6IHRoaXMubGFzdFRvdWNoLnRyYW5zbGF0aW9uLnggKyBkaWZmWCwgeTogdGhpcy5sYXN0VG91Y2gudHJhbnNsYXRpb24ueSArIGRpZmZZIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb25uZWN0IHRoZSBuZXcgZWRnZSB0byB0aGUgdGFyZ2V0IGlmIG9uZSBleGlzdHMsIG90aGVyd2lzZSByZW1vdmUgdGVtcCBsaW5lXG4gICAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19maW5pc2hDb25uZWN0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluaXNoQ29ubmVjdChldmVudCkge1xuICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgICB2YXIgcG9pbnRlck9iaiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fcG9pbnRlclRvUG9zaXRpb25PYmplY3QocG9pbnRlcik7XG5cbiAgICAgICAgLy8gcmVtZW1iZXIgdGhlIGVkZ2UgaWRcbiAgICAgICAgdmFyIGNvbm5lY3RGcm9tSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1swXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29ubmVjdEZyb21JZCA9IHRoaXMuYm9keS5lZGdlc1t0aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1swXV0uZnJvbUlkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBvdmVybGFwcGluZyBub2RlIGJ1dCBOT1QgdGhlIHRlbXBvcmFyeSBub2RlO1xuICAgICAgICB2YXIgb3ZlcmxhcHBpbmdOb2RlSWRzID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZXRBbGxOb2Rlc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcbiAgICAgICAgdmFyIG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAodmFyIGkgPSBvdmVybGFwcGluZ05vZGVJZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAvLyBpZiB0aGUgbm9kZSBpZCBpcyBOT1QgYSB0ZW1wb3Jhcnkgbm9kZSwgYWNjZXB0IHRoZSBub2RlLlxuICAgICAgICAgIGlmICh0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlcy5pbmRleE9mKG92ZXJsYXBwaW5nTm9kZUlkc1tpXSkgPT09IC0xKSB7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW292ZXJsYXBwaW5nTm9kZUlkc1tpXV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhbiB0ZW1wb3Jhcnkgbm9kZXMgYW5kIGVkZ2VzLlxuICAgICAgICB0aGlzLl9jbGVhbnVwVGVtcG9yYXJ5Tm9kZXNBbmRFZGdlcygpO1xuXG4gICAgICAgIC8vIHBlcmZvcm0gdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChub2RlLmlzQ2x1c3RlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgYWxlcnQodGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV1bJ2NyZWF0ZUVkZ2VFcnJvciddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydjcmVhdGVFZGdlRXJyb3InXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbY29ubmVjdEZyb21JZF0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmJvZHkubm9kZXNbbm9kZS5pZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLl9wZXJmb3JtQWRkRWRnZShjb25uZWN0RnJvbUlkLCBub2RlLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlZHJhdycpO1xuICAgICAgfVxuXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRU5EIE9GIEFERCBFREdFIEZVTkNUSU9OUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUGVyZm9ybWluZyBhbGwgdGhlIGFjdHVhbCBkYXRhIG1hbmlwdWxhdGlvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgYSBub2RlIG9uIHRoZSBzcGVjaWZpZWQgbG9jYXRpb25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3BlcmZvcm1BZGROb2RlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcGVyZm9ybUFkZE5vZGUoY2xpY2tEYXRhKSB7XG4gICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHtcbiAgICAgICAgICBpZDogdXRpbC5yYW5kb21VVUlEKCksXG4gICAgICAgICAgeDogY2xpY2tEYXRhLnBvaW50ZXIuY2FudmFzLngsXG4gICAgICAgICAgeTogY2xpY2tEYXRhLnBvaW50ZXIuY2FudmFzLnksXG4gICAgICAgICAgbGFiZWw6ICduZXcnXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuYWRkTm9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWRkTm9kZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hZGROb2RlKGRlZmF1bHREYXRhLCBmdW5jdGlvbiAoZmluYWxpemVkRGF0YSkge1xuICAgICAgICAgICAgICBpZiAoZmluYWxpemVkRGF0YSAhPT0gbnVsbCAmJiBmaW5hbGl6ZWREYXRhICE9PSB1bmRlZmluZWQgJiYgX3RoaXM1LmluTW9kZSA9PT0gJ2FkZE5vZGUnKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgZm9yIHdoYXRldmVyIHJlYXNvbiB0aGUgbW9kZSBoYXMgY2hhbmdlcyAoZHVlIHRvIGRhdGFzZXQgY2hhbmdlKSBkaXNyZWdhcmQgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgX3RoaXM1LmJvZHkuZGF0YS5ub2Rlcy5nZXREYXRhU2V0KCkuYWRkKGZpbmFsaXplZERhdGEpO1xuICAgICAgICAgICAgICAgIF90aGlzNS5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBmdW5jdGlvbiBmb3IgYWRkIGRvZXMgbm90IHN1cHBvcnQgdHdvIGFyZ3VtZW50cyAoZGF0YSxjYWxsYmFjayknKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZGF0YS5ub2Rlcy5nZXREYXRhU2V0KCkuYWRkKGRlZmF1bHREYXRhKTtcbiAgICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGNvbm5lY3QgdHdvIG5vZGVzIHdpdGggYSBuZXcgZWRnZS5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcGVyZm9ybUFkZEVkZ2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wZXJmb3JtQWRkRWRnZShzb3VyY2VOb2RlSWQsIHRhcmdldE5vZGVJZCkge1xuICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgICB2YXIgZGVmYXVsdERhdGEgPSB7IGZyb206IHNvdXJjZU5vZGVJZCwgdG86IHRhcmdldE5vZGVJZCB9O1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5hZGRFZGdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hZGRFZGdlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmFkZEVkZ2UoZGVmYXVsdERhdGEsIGZ1bmN0aW9uIChmaW5hbGl6ZWREYXRhKSB7XG4gICAgICAgICAgICAgIGlmIChmaW5hbGl6ZWREYXRhICE9PSBudWxsICYmIGZpbmFsaXplZERhdGEgIT09IHVuZGVmaW5lZCAmJiBfdGhpczYuaW5Nb2RlID09PSAnYWRkRWRnZScpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHRoZSBtb2RlIGhhcyBjaGFuZ2VzIChkdWUgdG8gZGF0YXNldCBjaGFuZ2UpIGRpc3JlZ2FyZCB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBfdGhpczYuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS5hZGQoZmluYWxpemVkRGF0YSk7XG4gICAgICAgICAgICAgICAgX3RoaXM2LnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgICAgICAgICAgICBfdGhpczYuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZnVuY3Rpb24gZm9yIGNvbm5lY3QgZG9lcyBub3Qgc3VwcG9ydCB0d28gYXJndW1lbnRzIChkYXRhLGNhbGxiYWNrKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkuYWRkKGRlZmF1bHREYXRhKTtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGNvbm5lY3QgdHdvIG5vZGVzIHdpdGggYSBuZXcgZWRnZS5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcGVyZm9ybUVkaXRFZGdlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcGVyZm9ybUVkaXRFZGdlKHNvdXJjZU5vZGVJZCwgdGFyZ2V0Tm9kZUlkKSB7XG4gICAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHsgaWQ6IHRoaXMuZWRnZUJlaW5nRWRpdGVkSWQsIGZyb206IHNvdXJjZU5vZGVJZCwgdG86IHRhcmdldE5vZGVJZCB9O1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5lZGl0RWRnZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWRpdEVkZ2UubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWRpdEVkZ2UoZGVmYXVsdERhdGEsIGZ1bmN0aW9uIChmaW5hbGl6ZWREYXRhKSB7XG4gICAgICAgICAgICAgIGlmIChmaW5hbGl6ZWREYXRhID09PSBudWxsIHx8IGZpbmFsaXplZERhdGEgPT09IHVuZGVmaW5lZCB8fCBfdGhpczcuaW5Nb2RlICE9PSAnZWRpdEVkZ2UnKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgZm9yIHdoYXRldmVyIHJlYXNvbiB0aGUgbW9kZSBoYXMgY2hhbmdlcyAoZHVlIHRvIGRhdGFzZXQgY2hhbmdlKSBkaXNyZWdhcmQgdGhlIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgX3RoaXM3LmJvZHkuZWRnZXNbZGVmYXVsdERhdGEuaWRdLnVwZGF0ZUVkZ2VUeXBlKCk7XG4gICAgICAgICAgICAgICAgX3RoaXM3LmJvZHkuZW1pdHRlci5lbWl0KCdfcmVkcmF3Jyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXM3LmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkudXBkYXRlKGZpbmFsaXplZERhdGEpO1xuICAgICAgICAgICAgICAgIF90aGlzNy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7XG4gICAgICAgICAgICAgICAgX3RoaXM3LnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGZ1bmN0aW9uIGZvciBlZGl0IGRvZXMgbm90IHN1cHBvcnQgdHdvIGFyZ3VtZW50cyAoZGF0YSwgY2FsbGJhY2spJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS51cGRhdGUoZGVmYXVsdERhdGEpO1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuICAgICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIE1hbmlwdWxhdGlvblN5c3RlbTtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IE1hbmlwdWxhdGlvblN5c3RlbTtcblxuLyoqKi8gfSxcbi8qIDExNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICAvKipcbiAgICogVGhpcyBvYmplY3QgY29udGFpbnMgYWxsIHBvc3NpYmxlIG9wdGlvbnMuIEl0IHdpbGwgY2hlY2sgaWYgdGhlIHR5cGVzIGFyZSBjb3JyZWN0LCBpZiByZXF1aXJlZCBpZiB0aGUgb3B0aW9uIGlzIG9uZVxuICAgKiBvZiB0aGUgYWxsb3dlZCB2YWx1ZXMuXG4gICAqXG4gICAqIF9fYW55X18gbWVhbnMgdGhhdCB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgZG9lcyBub3QgbWF0dGVyLlxuICAgKiBfX3R5cGVfXyBpcyBhIHJlcXVpcmVkIGZpZWxkIGZvciBhbGwgb2JqZWN0cyBhbmQgY29udGFpbnMgdGhlIGFsbG93ZWQgdHlwZXMgb2YgYWxsIG9iamVjdHNcbiAgICovXG4gIHZhciBzdHJpbmcgPSAnc3RyaW5nJztcbiAgdmFyIGJvb2xlYW4gPSAnYm9vbGVhbic7XG4gIHZhciBudW1iZXIgPSAnbnVtYmVyJztcbiAgdmFyIGFycmF5ID0gJ2FycmF5JztcbiAgdmFyIG9iamVjdCA9ICdvYmplY3QnOyAvLyBzaG91bGQgb25seSBiZSBpbiBhIF9fdHlwZV9fIHByb3BlcnR5XG4gIHZhciBkb20gPSAnZG9tJztcbiAgdmFyIGFueSA9ICdhbnknO1xuXG4gIHZhciBhbGxPcHRpb25zID0ge1xuICAgIGNvbmZpZ3VyZToge1xuICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBmaWx0ZXI6IHsgYm9vbGVhbjogYm9vbGVhbiwgc3RyaW5nOiBzdHJpbmcsIGFycmF5OiBhcnJheSwgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgY29udGFpbmVyOiB7IGRvbTogZG9tIH0sXG4gICAgICBzaG93QnV0dG9uOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sZWFuLCBzdHJpbmc6IHN0cmluZywgYXJyYXk6IGFycmF5LCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH1cbiAgICB9LFxuICAgIGVkZ2VzOiB7XG4gICAgICBhcnJvd3M6IHtcbiAgICAgICAgdG86IHsgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sIHNjYWxlRmFjdG9yOiB7IG51bWJlcjogbnVtYmVyIH0sIHR5cGU6IHsgc3RyaW5nOiBbJ2Fycm93JywgJ2NpcmNsZSddIH0sIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sZWFuIH0gfSxcbiAgICAgICAgbWlkZGxlOiB7IGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbGVhbiB9LCBzY2FsZUZhY3RvcjogeyBudW1iZXI6IG51bWJlciB9LCB0eXBlOiB7IHN0cmluZzogWydhcnJvdycsICdjaXJjbGUnXSB9LCBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbGVhbiB9IH0sXG4gICAgICAgIGZyb206IHsgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sIHNjYWxlRmFjdG9yOiB7IG51bWJlcjogbnVtYmVyIH0sIHR5cGU6IHsgc3RyaW5nOiBbJ2Fycm93JywgJ2NpcmNsZSddIH0sIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sZWFuIH0gfSxcbiAgICAgICAgX190eXBlX186IHsgc3RyaW5nOiBbJ2Zyb20nLCAndG8nLCAnbWlkZGxlJ10sIG9iamVjdDogb2JqZWN0IH1cbiAgICAgIH0sXG4gICAgICBhcnJvd1N0cmlrZXRocm91Z2g6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgY29sb3I6IHtcbiAgICAgICAgY29sb3I6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgaGlnaGxpZ2h0OiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIGhvdmVyOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIGluaGVyaXQ6IHsgc3RyaW5nOiBbJ2Zyb20nLCAndG8nLCAnYm90aCddLCBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgIG9wYWNpdHk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIHN0cmluZzogc3RyaW5nIH1cbiAgICAgIH0sXG4gICAgICBkYXNoZXM6IHsgYm9vbGVhbjogYm9vbGVhbiwgYXJyYXk6IGFycmF5IH0sXG4gICAgICBmb250OiB7XG4gICAgICAgIGNvbG9yOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIHNpemU6IHsgbnVtYmVyOiBudW1iZXIgfSwgLy8gcHhcbiAgICAgICAgZmFjZTogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBiYWNrZ3JvdW5kOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIHN0cm9rZVdpZHRoOiB7IG51bWJlcjogbnVtYmVyIH0sIC8vIHB4XG4gICAgICAgIHN0cm9rZUNvbG9yOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIGFsaWduOiB7IHN0cmluZzogWydob3Jpem9udGFsJywgJ3RvcCcsICdtaWRkbGUnLCAnYm90dG9tJ10gfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIHN0cmluZzogc3RyaW5nIH1cbiAgICAgIH0sXG4gICAgICBoaWRkZW46IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgaG92ZXJXaWR0aDogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nLCBudW1iZXI6IG51bWJlciB9LFxuICAgICAgbGFiZWw6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgbGFiZWxIaWdobGlnaHRCb2xkOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIGxlbmd0aDogeyBudW1iZXI6IG51bWJlciwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICBwaHlzaWNzOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIHNjYWxpbmc6IHtcbiAgICAgICAgbWluOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIG1heDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgICAgIG1pbjogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICAgIG1heDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICAgIG1heFZpc2libGU6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgICBkcmF3VGhyZXNob2xkOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2xlYW4gfVxuICAgICAgICB9LFxuICAgICAgICBjdXN0b21TY2FsaW5nRnVuY3Rpb246IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgICB9LFxuICAgICAgc2VsZWN0aW9uV2lkdGg6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJywgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIHNlbGZSZWZlcmVuY2VTaXplOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBzaGFkb3c6IHtcbiAgICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgIGNvbG9yOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIHNpemU6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgeDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICB5OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sZWFuIH1cbiAgICAgIH0sXG4gICAgICBzbW9vdGg6IHtcbiAgICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgIHR5cGU6IHsgc3RyaW5nOiBbJ2R5bmFtaWMnLCAnY29udGludW91cycsICdkaXNjcmV0ZScsICdkaWFnb25hbENyb3NzJywgJ3N0cmFpZ2h0Q3Jvc3MnLCAnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCcsICdjdXJ2ZWRDVycsICdjdXJ2ZWRDQ1cnLCAnY3ViaWNCZXppZXInXSB9LFxuICAgICAgICByb3VuZG5lc3M6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgZm9yY2VEaXJlY3Rpb246IHsgc3RyaW5nOiBbJ2hvcml6b250YWwnLCAndmVydGljYWwnLCAnbm9uZSddLCBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sZWFuIH1cbiAgICAgIH0sXG4gICAgICB0aXRsZTogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICB3aWR0aDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgdmFsdWU6IHsgbnVtYmVyOiBudW1iZXIsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgZ3JvdXBzOiB7XG4gICAgICB1c2VEZWZhdWx0R3JvdXBzOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIF9fYW55X186ICdnZXQgZnJvbSBub2Rlcywgd2lsbCBiZSBvdmVyd3JpdHRlbiBiZWxvdycsXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcbiAgICBpbnRlcmFjdGlvbjoge1xuICAgICAgZHJhZ05vZGVzOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIGRyYWdWaWV3OiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIGhpZGVFZGdlc09uRHJhZzogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBoaWRlTm9kZXNPbkRyYWc6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgaG92ZXI6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAga2V5Ym9hcmQ6IHtcbiAgICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgIHNwZWVkOiB7IHg6IHsgbnVtYmVyOiBudW1iZXIgfSwgeTogeyBudW1iZXI6IG51bWJlciB9LCB6b29tOiB7IG51bWJlcjogbnVtYmVyIH0sIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH0gfSxcbiAgICAgICAgYmluZFRvV2luZG93OiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2xlYW4gfVxuICAgICAgfSxcbiAgICAgIG11bHRpc2VsZWN0OiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIG5hdmlnYXRpb25CdXR0b25zOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIHNlbGVjdGFibGU6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgc2VsZWN0Q29ubmVjdGVkRWRnZXM6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgaG92ZXJDb25uZWN0ZWRFZGdlczogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICB0b29sdGlwRGVsYXk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIHpvb21WaWV3OiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICB9LFxuICAgIGxheW91dDoge1xuICAgICAgcmFuZG9tU2VlZDogeyAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcsIG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBpbXByb3ZlZExheW91dDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBoaWVyYXJjaGljYWw6IHtcbiAgICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgIGxldmVsU2VwYXJhdGlvbjogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBub2RlU3BhY2luZzogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICB0cmVlU3BhY2luZzogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBibG9ja1NoaWZ0aW5nOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgZWRnZU1pbmltaXphdGlvbjogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgIHBhcmVudENlbnRyYWxpemF0aW9uOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgZGlyZWN0aW9uOiB7IHN0cmluZzogWydVRCcsICdEVScsICdMUicsICdSTCddIH0sIC8vIFVELCBEVSwgTFIsIFJMXG4gICAgICAgIHNvcnRNZXRob2Q6IHsgc3RyaW5nOiBbJ2h1YnNpemUnLCAnZGlyZWN0ZWQnXSB9LCAvLyBodWJzaXplLCBkaXJlY3RlZFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbGVhbiB9XG4gICAgICB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgbWFuaXB1bGF0aW9uOiB7XG4gICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIGluaXRpYWxseUFjdGl2ZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBhZGROb2RlOiB7IGJvb2xlYW46IGJvb2xlYW4sICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICAgIGFkZEVkZ2U6IHsgYm9vbGVhbjogYm9vbGVhbiwgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgZWRpdE5vZGU6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgZWRpdEVkZ2U6IHsgYm9vbGVhbjogYm9vbGVhbiwgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgZGVsZXRlTm9kZTogeyBib29sZWFuOiBib29sZWFuLCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgICBkZWxldGVFZGdlOiB7IGJvb2xlYW46IGJvb2xlYW4sICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICAgIGNvbnRyb2xOb2RlU3R5bGU6ICdnZXQgZnJvbSBub2Rlcywgd2lsbCBiZSBvdmVyd3JpdHRlbiBiZWxvdycsXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbGVhbiB9XG4gICAgfSxcbiAgICBub2Rlczoge1xuICAgICAgYm9yZGVyV2lkdGg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIGJvcmRlcldpZHRoU2VsZWN0ZWQ6IHsgbnVtYmVyOiBudW1iZXIsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgYnJva2VuSW1hZ2U6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgY29sb3I6IHtcbiAgICAgICAgYm9yZGVyOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIGJhY2tncm91bmQ6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgYm9yZGVyOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgICAgYmFja2dyb3VuZDogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBzdHJpbmc6IHN0cmluZyB9XG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgYm9yZGVyOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgICAgYmFja2dyb3VuZDogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBzdHJpbmc6IHN0cmluZyB9XG4gICAgICAgIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBzdHJpbmc6IHN0cmluZyB9XG4gICAgICB9LFxuICAgICAgZml4ZWQ6IHtcbiAgICAgICAgeDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgIHk6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbGVhbiB9XG4gICAgICB9LFxuICAgICAgZm9udDoge1xuICAgICAgICBhbGlnbjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBjb2xvcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBzaXplOiB7IG51bWJlcjogbnVtYmVyIH0sIC8vIHB4XG4gICAgICAgIGZhY2U6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgYmFja2dyb3VuZDogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBzdHJva2VXaWR0aDogeyBudW1iZXI6IG51bWJlciB9LCAvLyBweFxuICAgICAgICBzdHJva2VDb2xvcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgc3RyaW5nOiBzdHJpbmcgfVxuICAgICAgfSxcbiAgICAgIGdyb3VwOiB7IHN0cmluZzogc3RyaW5nLCBudW1iZXI6IG51bWJlciwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICBoaWRkZW46IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgaWNvbjoge1xuICAgICAgICBmYWNlOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIGNvZGU6IHsgc3RyaW5nOiBzdHJpbmcgfSwgLy8nXFx1ZjAwNycsXG4gICAgICAgIHNpemU6IHsgbnVtYmVyOiBudW1iZXIgfSwgLy81MCxcbiAgICAgICAgY29sb3I6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgICAgfSxcbiAgICAgIGlkOiB7IHN0cmluZzogc3RyaW5nLCBudW1iZXI6IG51bWJlciB9LFxuICAgICAgaW1hZ2U6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LCAvLyAtLT4gVVJMXG4gICAgICBsYWJlbDogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICBsYWJlbEhpZ2hsaWdodEJvbGQ6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgbGV2ZWw6IHsgbnVtYmVyOiBudW1iZXIsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgbWFzczogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgcGh5c2ljczogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBzY2FsaW5nOiB7XG4gICAgICAgIG1pbjogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBtYXg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgICBtaW46IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgICBtYXg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgICBtYXhWaXNpYmxlOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgICAgZHJhd1RocmVzaG9sZDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sZWFuIH1cbiAgICAgICAgfSxcbiAgICAgICAgY3VzdG9tU2NhbGluZ0Z1bmN0aW9uOiB7ICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgICAgfSxcbiAgICAgIHNoYWRvdzoge1xuICAgICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgY29sb3I6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgc2l6ZTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICB4OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIHk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2xlYW4gfVxuICAgICAgfSxcbiAgICAgIHNoYXBlOiB7IHN0cmluZzogWydlbGxpcHNlJywgJ2NpcmNsZScsICdkYXRhYmFzZScsICdib3gnLCAndGV4dCcsICdpbWFnZScsICdjaXJjdWxhckltYWdlJywgJ2RpYW1vbmQnLCAnZG90JywgJ3N0YXInLCAndHJpYW5nbGUnLCAndHJpYW5nbGVEb3duJywgJ3NxdWFyZScsICdpY29uJ10gfSxcbiAgICAgIHNoYXBlUHJvcGVydGllczoge1xuICAgICAgICBib3JkZXJEYXNoZXM6IHsgYm9vbGVhbjogYm9vbGVhbiwgYXJyYXk6IGFycmF5IH0sXG4gICAgICAgIGJvcmRlclJhZGl1czogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBpbnRlcnBvbGF0aW9uOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgdXNlSW1hZ2VTaXplOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgdXNlQm9yZGVyV2l0aEltYWdlOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgICAgfSxcbiAgICAgIHNpemU6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIHRpdGxlOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgIHZhbHVlOiB7IG51bWJlcjogbnVtYmVyLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgIHg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIHk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICB9LFxuICAgIHBoeXNpY3M6IHtcbiAgICAgIGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgYmFybmVzSHV0OiB7XG4gICAgICAgIGdyYXZpdGF0aW9uYWxDb25zdGFudDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBjZW50cmFsR3Jhdml0eTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBzcHJpbmdMZW5ndGg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgc3ByaW5nQ29uc3RhbnQ6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgZGFtcGluZzogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBhdm9pZE92ZXJsYXA6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgICAgfSxcbiAgICAgIGZvcmNlQXRsYXMyQmFzZWQ6IHtcbiAgICAgICAgZ3Jhdml0YXRpb25hbENvbnN0YW50OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIGNlbnRyYWxHcmF2aXR5OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIHNwcmluZ0xlbmd0aDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBzcHJpbmdDb25zdGFudDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBkYW1waW5nOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIGF2b2lkT3ZlcmxhcDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgICB9LFxuICAgICAgcmVwdWxzaW9uOiB7XG4gICAgICAgIGNlbnRyYWxHcmF2aXR5OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIHNwcmluZ0xlbmd0aDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBzcHJpbmdDb25zdGFudDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBub2RlRGlzdGFuY2U6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgZGFtcGluZzogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgICB9LFxuICAgICAgaGllcmFyY2hpY2FsUmVwdWxzaW9uOiB7XG4gICAgICAgIGNlbnRyYWxHcmF2aXR5OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIHNwcmluZ0xlbmd0aDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBzcHJpbmdDb25zdGFudDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBub2RlRGlzdGFuY2U6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgZGFtcGluZzogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgICB9LFxuICAgICAgbWF4VmVsb2NpdHk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIG1pblZlbG9jaXR5OiB7IG51bWJlcjogbnVtYmVyIH0sIC8vIHB4L3NcbiAgICAgIHNvbHZlcjogeyBzdHJpbmc6IFsnYmFybmVzSHV0JywgJ3JlcHVsc2lvbicsICdoaWVyYXJjaGljYWxSZXB1bHNpb24nLCAnZm9yY2VBdGxhczJCYXNlZCddIH0sXG4gICAgICBzdGFiaWxpemF0aW9uOiB7XG4gICAgICAgIGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgICBpdGVyYXRpb25zOiB7IG51bWJlcjogbnVtYmVyIH0sIC8vIG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbiB0byBzdGFiaWxpemVcbiAgICAgICAgdXBkYXRlSW50ZXJ2YWw6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgb25seUR5bmFtaWNFZGdlczogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgIGZpdDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sZWFuIH1cbiAgICAgIH0sXG4gICAgICB0aW1lc3RlcDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgYWRhcHRpdmVUaW1lc3RlcDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbGVhbiB9XG4gICAgfSxcblxuICAgIC8vZ2xvYmFscyA6XG4gICAgYXV0b1Jlc2l6ZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgY2xpY2tUb1VzZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgbG9jYWxlOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgbG9jYWxlczoge1xuICAgICAgX19hbnlfXzogeyBhbnk6IGFueSB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgaGVpZ2h0OiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgd2lkdGg6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gIH07XG5cbiAgYWxsT3B0aW9ucy5ncm91cHMuX19hbnlfXyA9IGFsbE9wdGlvbnMubm9kZXM7XG4gIGFsbE9wdGlvbnMubWFuaXB1bGF0aW9uLmNvbnRyb2xOb2RlU3R5bGUgPSBhbGxPcHRpb25zLm5vZGVzO1xuXG4gIHZhciBjb25maWd1cmVPcHRpb25zID0ge1xuICAgIG5vZGVzOiB7XG4gICAgICBib3JkZXJXaWR0aDogWzEsIDAsIDEwLCAxXSxcbiAgICAgIGJvcmRlcldpZHRoU2VsZWN0ZWQ6IFsyLCAwLCAxMCwgMV0sXG4gICAgICBjb2xvcjoge1xuICAgICAgICBib3JkZXI6IFsnY29sb3InLCAnIzJCN0NFOSddLFxuICAgICAgICBiYWNrZ3JvdW5kOiBbJ2NvbG9yJywgJyM5N0MyRkMnXSxcbiAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgYm9yZGVyOiBbJ2NvbG9yJywgJyMyQjdDRTknXSxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBbJ2NvbG9yJywgJyNEMkU1RkYnXVxuICAgICAgICB9LFxuICAgICAgICBob3Zlcjoge1xuICAgICAgICAgIGJvcmRlcjogWydjb2xvcicsICcjMkI3Q0U5J10sXG4gICAgICAgICAgYmFja2dyb3VuZDogWydjb2xvcicsICcjRDJFNUZGJ11cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGZpeGVkOiB7XG4gICAgICAgIHg6IGZhbHNlLFxuICAgICAgICB5OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGZvbnQ6IHtcbiAgICAgICAgY29sb3I6IFsnY29sb3InLCAnIzM0MzQzNCddLFxuICAgICAgICBzaXplOiBbMTQsIDAsIDEwMCwgMV0sIC8vIHB4XG4gICAgICAgIGZhY2U6IFsnYXJpYWwnLCAndmVyZGFuYScsICd0YWhvbWEnXSxcbiAgICAgICAgYmFja2dyb3VuZDogWydjb2xvcicsICdub25lJ10sXG4gICAgICAgIHN0cm9rZVdpZHRoOiBbMCwgMCwgNTAsIDFdLCAvLyBweFxuICAgICAgICBzdHJva2VDb2xvcjogWydjb2xvcicsICcjZmZmZmZmJ11cbiAgICAgIH0sXG4gICAgICAvL2dyb3VwOiAnc3RyaW5nJyxcbiAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICBsYWJlbEhpZ2hsaWdodEJvbGQ6IHRydWUsXG4gICAgICAvL2ljb246IHtcbiAgICAgIC8vICBmYWNlOiAnc3RyaW5nJywgIC8vJ0ZvbnRBd2Vzb21lJyxcbiAgICAgIC8vICBjb2RlOiAnc3RyaW5nJywgIC8vJ1xcdWYwMDcnLFxuICAgICAgLy8gIHNpemU6IFs1MCwgMCwgMjAwLCAxXSwgIC8vNTAsXG4gICAgICAvLyAgY29sb3I6IFsnY29sb3InLCcjMkI3Q0U5J10gICAvLycjYWEwMGZmJ1xuICAgICAgLy99LFxuICAgICAgLy9pbWFnZTogJ3N0cmluZycsIC8vIC0tPiBVUkxcbiAgICAgIHBoeXNpY3M6IHRydWUsXG4gICAgICBzY2FsaW5nOiB7XG4gICAgICAgIG1pbjogWzEwLCAwLCAyMDAsIDFdLFxuICAgICAgICBtYXg6IFszMCwgMCwgMjAwLCAxXSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBtaW46IFsxNCwgMCwgMjAwLCAxXSxcbiAgICAgICAgICBtYXg6IFszMCwgMCwgMjAwLCAxXSxcbiAgICAgICAgICBtYXhWaXNpYmxlOiBbMzAsIDAsIDIwMCwgMV0sXG4gICAgICAgICAgZHJhd1RocmVzaG9sZDogWzUsIDAsIDIwLCAxXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2hhZG93OiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBjb2xvcjogJ3JnYmEoMCwwLDAsMC41KScsXG4gICAgICAgIHNpemU6IFsxMCwgMCwgMjAsIDFdLFxuICAgICAgICB4OiBbNSwgLTMwLCAzMCwgMV0sXG4gICAgICAgIHk6IFs1LCAtMzAsIDMwLCAxXVxuICAgICAgfSxcbiAgICAgIHNoYXBlOiBbJ2VsbGlwc2UnLCAnYm94JywgJ2NpcmNsZScsICdkYXRhYmFzZScsICdkaWFtb25kJywgJ2RvdCcsICdzcXVhcmUnLCAnc3RhcicsICd0ZXh0JywgJ3RyaWFuZ2xlJywgJ3RyaWFuZ2xlRG93biddLFxuICAgICAgc2hhcGVQcm9wZXJ0aWVzOiB7XG4gICAgICAgIGJvcmRlckRhc2hlczogZmFsc2UsXG4gICAgICAgIGJvcmRlclJhZGl1czogWzYsIDAsIDIwLCAxXSxcbiAgICAgICAgaW50ZXJwb2xhdGlvbjogdHJ1ZSxcbiAgICAgICAgdXNlSW1hZ2VTaXplOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHNpemU6IFsyNSwgMCwgMjAwLCAxXVxuICAgIH0sXG4gICAgZWRnZXM6IHtcbiAgICAgIGFycm93czoge1xuICAgICAgICB0bzogeyBlbmFibGVkOiBmYWxzZSwgc2NhbGVGYWN0b3I6IFsxLCAwLCAzLCAwLjA1XSwgdHlwZTogJ2Fycm93JyB9LFxuICAgICAgICBtaWRkbGU6IHsgZW5hYmxlZDogZmFsc2UsIHNjYWxlRmFjdG9yOiBbMSwgMCwgMywgMC4wNV0sIHR5cGU6ICdhcnJvdycgfSxcbiAgICAgICAgZnJvbTogeyBlbmFibGVkOiBmYWxzZSwgc2NhbGVGYWN0b3I6IFsxLCAwLCAzLCAwLjA1XSwgdHlwZTogJ2Fycm93JyB9XG4gICAgICB9LFxuICAgICAgYXJyb3dTdHJpa2V0aHJvdWdoOiB0cnVlLFxuICAgICAgY29sb3I6IHtcbiAgICAgICAgY29sb3I6IFsnY29sb3InLCAnIzg0ODQ4NCddLFxuICAgICAgICBoaWdobGlnaHQ6IFsnY29sb3InLCAnIzg0ODQ4NCddLFxuICAgICAgICBob3ZlcjogWydjb2xvcicsICcjODQ4NDg0J10sXG4gICAgICAgIGluaGVyaXQ6IFsnZnJvbScsICd0bycsICdib3RoJywgdHJ1ZSwgZmFsc2VdLFxuICAgICAgICBvcGFjaXR5OiBbMSwgMCwgMSwgMC4wNV1cbiAgICAgIH0sXG4gICAgICBkYXNoZXM6IGZhbHNlLFxuICAgICAgZm9udDoge1xuICAgICAgICBjb2xvcjogWydjb2xvcicsICcjMzQzNDM0J10sXG4gICAgICAgIHNpemU6IFsxNCwgMCwgMTAwLCAxXSwgLy8gcHhcbiAgICAgICAgZmFjZTogWydhcmlhbCcsICd2ZXJkYW5hJywgJ3RhaG9tYSddLFxuICAgICAgICBiYWNrZ3JvdW5kOiBbJ2NvbG9yJywgJ25vbmUnXSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IFsyLCAwLCA1MCwgMV0sIC8vIHB4XG4gICAgICAgIHN0cm9rZUNvbG9yOiBbJ2NvbG9yJywgJyNmZmZmZmYnXSxcbiAgICAgICAgYWxpZ246IFsnaG9yaXpvbnRhbCcsICd0b3AnLCAnbWlkZGxlJywgJ2JvdHRvbSddXG4gICAgICB9LFxuICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgIGhvdmVyV2lkdGg6IFsxLjUsIDAsIDUsIDAuMV0sXG4gICAgICBsYWJlbEhpZ2hsaWdodEJvbGQ6IHRydWUsXG4gICAgICBwaHlzaWNzOiB0cnVlLFxuICAgICAgc2NhbGluZzoge1xuICAgICAgICBtaW46IFsxLCAwLCAxMDAsIDFdLFxuICAgICAgICBtYXg6IFsxNSwgMCwgMTAwLCAxXSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgIG1pbjogWzE0LCAwLCAyMDAsIDFdLFxuICAgICAgICAgIG1heDogWzMwLCAwLCAyMDAsIDFdLFxuICAgICAgICAgIG1heFZpc2libGU6IFszMCwgMCwgMjAwLCAxXSxcbiAgICAgICAgICBkcmF3VGhyZXNob2xkOiBbNSwgMCwgMjAsIDFdXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZWxlY3Rpb25XaWR0aDogWzEuNSwgMCwgNSwgMC4xXSxcbiAgICAgIHNlbGZSZWZlcmVuY2VTaXplOiBbMjAsIDAsIDIwMCwgMV0sXG4gICAgICBzaGFkb3c6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGNvbG9yOiAncmdiYSgwLDAsMCwwLjUpJyxcbiAgICAgICAgc2l6ZTogWzEwLCAwLCAyMCwgMV0sXG4gICAgICAgIHg6IFs1LCAtMzAsIDMwLCAxXSxcbiAgICAgICAgeTogWzUsIC0zMCwgMzAsIDFdXG4gICAgICB9LFxuICAgICAgc21vb3RoOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIHR5cGU6IFsnZHluYW1pYycsICdjb250aW51b3VzJywgJ2Rpc2NyZXRlJywgJ2RpYWdvbmFsQ3Jvc3MnLCAnc3RyYWlnaHRDcm9zcycsICdob3Jpem9udGFsJywgJ3ZlcnRpY2FsJywgJ2N1cnZlZENXJywgJ2N1cnZlZENDVycsICdjdWJpY0JlemllciddLFxuICAgICAgICBmb3JjZURpcmVjdGlvbjogWydob3Jpem9udGFsJywgJ3ZlcnRpY2FsJywgJ25vbmUnXSxcbiAgICAgICAgcm91bmRuZXNzOiBbMC41LCAwLCAxLCAwLjA1XVxuICAgICAgfSxcbiAgICAgIHdpZHRoOiBbMSwgMCwgMzAsIDFdXG4gICAgfSxcbiAgICBsYXlvdXQ6IHtcbiAgICAgIC8vcmFuZG9tU2VlZDogWzAsIDAsIDUwMCwgMV0sXG4gICAgICAvL2ltcHJvdmVkTGF5b3V0OiB0cnVlLFxuICAgICAgaGllcmFyY2hpY2FsOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBsZXZlbFNlcGFyYXRpb246IFsxNTAsIDIwLCA1MDAsIDVdLFxuICAgICAgICBub2RlU3BhY2luZzogWzEwMCwgMjAsIDUwMCwgNV0sXG4gICAgICAgIHRyZWVTcGFjaW5nOiBbMjAwLCAyMCwgNTAwLCA1XSxcbiAgICAgICAgYmxvY2tTaGlmdGluZzogdHJ1ZSxcbiAgICAgICAgZWRnZU1pbmltaXphdGlvbjogdHJ1ZSxcbiAgICAgICAgcGFyZW50Q2VudHJhbGl6YXRpb246IHRydWUsXG4gICAgICAgIGRpcmVjdGlvbjogWydVRCcsICdEVScsICdMUicsICdSTCddLCAvLyBVRCwgRFUsIExSLCBSTFxuICAgICAgICBzb3J0TWV0aG9kOiBbJ2h1YnNpemUnLCAnZGlyZWN0ZWQnXSAvLyBodWJzaXplLCBkaXJlY3RlZFxuICAgICAgfVxuICAgIH0sXG4gICAgaW50ZXJhY3Rpb246IHtcbiAgICAgIGRyYWdOb2RlczogdHJ1ZSxcbiAgICAgIGRyYWdWaWV3OiB0cnVlLFxuICAgICAgaGlkZUVkZ2VzT25EcmFnOiBmYWxzZSxcbiAgICAgIGhpZGVOb2Rlc09uRHJhZzogZmFsc2UsXG4gICAgICBob3ZlcjogZmFsc2UsXG4gICAgICBrZXlib2FyZDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgc3BlZWQ6IHsgeDogWzEwLCAwLCA0MCwgMV0sIHk6IFsxMCwgMCwgNDAsIDFdLCB6b29tOiBbMC4wMiwgMCwgMC4xLCAwLjAwNV0gfSxcbiAgICAgICAgYmluZFRvV2luZG93OiB0cnVlXG4gICAgICB9LFxuICAgICAgbXVsdGlzZWxlY3Q6IGZhbHNlLFxuICAgICAgbmF2aWdhdGlvbkJ1dHRvbnM6IGZhbHNlLFxuICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICAgIHNlbGVjdENvbm5lY3RlZEVkZ2VzOiB0cnVlLFxuICAgICAgaG92ZXJDb25uZWN0ZWRFZGdlczogdHJ1ZSxcbiAgICAgIHRvb2x0aXBEZWxheTogWzMwMCwgMCwgMTAwMCwgMjVdLFxuICAgICAgem9vbVZpZXc6IHRydWVcbiAgICB9LFxuICAgIG1hbmlwdWxhdGlvbjoge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBpbml0aWFsbHlBY3RpdmU6IGZhbHNlXG4gICAgfSxcbiAgICBwaHlzaWNzOiB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgYmFybmVzSHV0OiB7XG4gICAgICAgIC8vdGhldGE6IFswLjUsIDAuMSwgMSwgMC4wNV0sXG4gICAgICAgIGdyYXZpdGF0aW9uYWxDb25zdGFudDogWy0yMDAwLCAtMzAwMDAsIDAsIDUwXSxcbiAgICAgICAgY2VudHJhbEdyYXZpdHk6IFswLjMsIDAsIDEwLCAwLjA1XSxcbiAgICAgICAgc3ByaW5nTGVuZ3RoOiBbOTUsIDAsIDUwMCwgNV0sXG4gICAgICAgIHNwcmluZ0NvbnN0YW50OiBbMC4wNCwgMCwgMS4yLCAwLjAwNV0sXG4gICAgICAgIGRhbXBpbmc6IFswLjA5LCAwLCAxLCAwLjAxXSxcbiAgICAgICAgYXZvaWRPdmVybGFwOiBbMCwgMCwgMSwgMC4wMV1cbiAgICAgIH0sXG4gICAgICBmb3JjZUF0bGFzMkJhc2VkOiB7XG4gICAgICAgIC8vdGhldGE6IFswLjUsIDAuMSwgMSwgMC4wNV0sXG4gICAgICAgIGdyYXZpdGF0aW9uYWxDb25zdGFudDogWy01MCwgLTUwMCwgMCwgMV0sXG4gICAgICAgIGNlbnRyYWxHcmF2aXR5OiBbMC4wMSwgMCwgMSwgMC4wMDVdLFxuICAgICAgICBzcHJpbmdMZW5ndGg6IFs5NSwgMCwgNTAwLCA1XSxcbiAgICAgICAgc3ByaW5nQ29uc3RhbnQ6IFswLjA4LCAwLCAxLjIsIDAuMDA1XSxcbiAgICAgICAgZGFtcGluZzogWzAuNCwgMCwgMSwgMC4wMV0sXG4gICAgICAgIGF2b2lkT3ZlcmxhcDogWzAsIDAsIDEsIDAuMDFdXG4gICAgICB9LFxuICAgICAgcmVwdWxzaW9uOiB7XG4gICAgICAgIGNlbnRyYWxHcmF2aXR5OiBbMC4yLCAwLCAxMCwgMC4wNV0sXG4gICAgICAgIHNwcmluZ0xlbmd0aDogWzIwMCwgMCwgNTAwLCA1XSxcbiAgICAgICAgc3ByaW5nQ29uc3RhbnQ6IFswLjA1LCAwLCAxLjIsIDAuMDA1XSxcbiAgICAgICAgbm9kZURpc3RhbmNlOiBbMTAwLCAwLCA1MDAsIDVdLFxuICAgICAgICBkYW1waW5nOiBbMC4wOSwgMCwgMSwgMC4wMV1cbiAgICAgIH0sXG4gICAgICBoaWVyYXJjaGljYWxSZXB1bHNpb246IHtcbiAgICAgICAgY2VudHJhbEdyYXZpdHk6IFswLjIsIDAsIDEwLCAwLjA1XSxcbiAgICAgICAgc3ByaW5nTGVuZ3RoOiBbMTAwLCAwLCA1MDAsIDVdLFxuICAgICAgICBzcHJpbmdDb25zdGFudDogWzAuMDEsIDAsIDEuMiwgMC4wMDVdLFxuICAgICAgICBub2RlRGlzdGFuY2U6IFsxMjAsIDAsIDUwMCwgNV0sXG4gICAgICAgIGRhbXBpbmc6IFswLjA5LCAwLCAxLCAwLjAxXVxuICAgICAgfSxcbiAgICAgIG1heFZlbG9jaXR5OiBbNTAsIDAsIDE1MCwgMV0sXG4gICAgICBtaW5WZWxvY2l0eTogWzAuMSwgMC4wMSwgMC41LCAwLjAxXSxcbiAgICAgIHNvbHZlcjogWydiYXJuZXNIdXQnLCAnZm9yY2VBdGxhczJCYXNlZCcsICdyZXB1bHNpb24nLCAnaGllcmFyY2hpY2FsUmVwdWxzaW9uJ10sXG4gICAgICB0aW1lc3RlcDogWzAuNSwgMC4wMSwgMSwgMC4wMV1cbiAgICB9XG4gIH07XG5cbiAgZXhwb3J0cy5hbGxPcHRpb25zID0gYWxsT3B0aW9ucztcbiAgZXhwb3J0cy5jb25maWd1cmVPcHRpb25zID0gY29uZmlndXJlT3B0aW9ucztcblxuLyoqKi8gfSxcbi8qIDExNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7IC8vIGRpc3RhbmNlIGZpbmRpbmcgYWxnb3JpdGhtXG5cblxuICB2YXIgX0Zsb3lkV2Fyc2hhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExOCk7XG5cbiAgdmFyIF9GbG95ZFdhcnNoYWxsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Zsb3lkV2Fyc2hhbGwpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICAvKipcbiAgICogS2FtYWRhS2F3YWkgcG9zaXRpb25zIHRoZSBub2RlcyBpbml0aWFsbHkgYmFzZWQgb25cbiAgICpcbiAgICogXCJBTiBBTEdPUklUSE0gRk9SIERSQVdJTkcgR0VORVJBTCBVTkRJUkVDVEVEIEdSQVBIU1wiXG4gICAqIC0tIFRvbWloaXNhIEtBTUFEQSBhbmQgU2F0b3J1IEtBV0FJIGluIDE5ODlcbiAgICpcbiAgICogUG9zc2libGUgb3B0aW1pemF0aW9ucyBpbiB0aGUgZGlzdGFuY2UgY2FsY3VsYXRpb24gY2FuIGJlIGltcGxlbWVudGVkLlxuICAgKi9cbiAgdmFyIEthbWFkYUthd2FpID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEthbWFkYUthd2FpKGJvZHksIGVkZ2VMZW5ndGgsIGVkZ2VTdHJlbmd0aCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEthbWFkYUthd2FpKTtcblxuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMuc3ByaW5nTGVuZ3RoID0gZWRnZUxlbmd0aDtcbiAgICAgIHRoaXMuc3ByaW5nQ29uc3RhbnQgPSBlZGdlU3RyZW5ndGg7XG4gICAgICB0aGlzLmRpc3RhbmNlU29sdmVyID0gbmV3IF9GbG95ZFdhcnNoYWxsMi5kZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm90IHN1cmUgaWYgbmVlZGVkIGJ1dCBjYW4gYmUgdXNlZCB0byB1cGRhdGUgdGhlIHNwcmluZyBsZW5ndGggYW5kIHNwcmluZyBjb25zdGFudFxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhLYW1hZGFLYXdhaSwgW3tcbiAgICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuc3ByaW5nTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnNwcmluZ0xlbmd0aCA9IG9wdGlvbnMuc3ByaW5nTGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy5zcHJpbmdDb25zdGFudCkge1xuICAgICAgICAgICAgdGhpcy5zcHJpbmdDb25zdGFudCA9IG9wdGlvbnMuc3ByaW5nQ29uc3RhbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUG9zaXRpb24gdGhlIHN5c3RlbVxuICAgICAgICogQHBhcmFtIG5vZGVzQXJyYXlcbiAgICAgICAqIEBwYXJhbSBlZGdlc0FycmF5XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzb2x2ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNvbHZlKG5vZGVzQXJyYXksIGVkZ2VzQXJyYXkpIHtcbiAgICAgICAgdmFyIGlnbm9yZUNsdXN0ZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgICAvLyBnZXQgZGlzdGFuY2UgbWF0cml4XG4gICAgICAgIHZhciBEX21hdHJpeCA9IHRoaXMuZGlzdGFuY2VTb2x2ZXIuZ2V0RGlzdGFuY2VzKHRoaXMuYm9keSwgbm9kZXNBcnJheSwgZWRnZXNBcnJheSk7IC8vIGRpc3RhbmNlIG1hdHJpeFxuXG4gICAgICAgIC8vIGdldCB0aGUgTCBNYXRyaXhcbiAgICAgICAgdGhpcy5fY3JlYXRlTF9tYXRyaXgoRF9tYXRyaXgpO1xuXG4gICAgICAgIC8vIGdldCB0aGUgSyBNYXRyaXhcbiAgICAgICAgdGhpcy5fY3JlYXRlS19tYXRyaXgoRF9tYXRyaXgpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBwb3NpdGlvbnNcbiAgICAgICAgdmFyIHRocmVzaG9sZCA9IDAuMDE7XG4gICAgICAgIHZhciBpbm5lclRocmVzaG9sZCA9IDE7XG4gICAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSBNYXRoLm1heCgxMDAwLCBNYXRoLm1pbigxMCAqIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGgsIDYwMDApKTtcbiAgICAgICAgdmFyIG1heElubmVySXRlcmF0aW9ucyA9IDU7XG5cbiAgICAgICAgdmFyIG1heEVuZXJneSA9IDFlOTtcbiAgICAgICAgdmFyIGhpZ2hFX25vZGVJZCA9IDAsXG4gICAgICAgICAgICBkRV9keCA9IDAsXG4gICAgICAgICAgICBkRV9keSA9IDAsXG4gICAgICAgICAgICBkZWx0YV9tID0gMCxcbiAgICAgICAgICAgIHN1Ykl0ZXJhdGlvbnMgPSAwO1xuXG4gICAgICAgIHdoaWxlIChtYXhFbmVyZ3kgPiB0aHJlc2hvbGQgJiYgaXRlcmF0aW9ucyA8IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICBpdGVyYXRpb25zICs9IDE7XG5cbiAgICAgICAgICB2YXIgX2dldEhpZ2hlc3RFbmVyZ3lOb2RlMiA9IHRoaXMuX2dldEhpZ2hlc3RFbmVyZ3lOb2RlKGlnbm9yZUNsdXN0ZXJzKTtcblxuICAgICAgICAgIHZhciBfZ2V0SGlnaGVzdEVuZXJneU5vZGUzID0gX3NsaWNlZFRvQXJyYXkoX2dldEhpZ2hlc3RFbmVyZ3lOb2RlMiwgNCk7XG5cbiAgICAgICAgICBoaWdoRV9ub2RlSWQgPSBfZ2V0SGlnaGVzdEVuZXJneU5vZGUzWzBdO1xuICAgICAgICAgIG1heEVuZXJneSA9IF9nZXRIaWdoZXN0RW5lcmd5Tm9kZTNbMV07XG4gICAgICAgICAgZEVfZHggPSBfZ2V0SGlnaGVzdEVuZXJneU5vZGUzWzJdO1xuICAgICAgICAgIGRFX2R5ID0gX2dldEhpZ2hlc3RFbmVyZ3lOb2RlM1szXTtcblxuICAgICAgICAgIGRlbHRhX20gPSBtYXhFbmVyZ3k7XG4gICAgICAgICAgc3ViSXRlcmF0aW9ucyA9IDA7XG4gICAgICAgICAgd2hpbGUgKGRlbHRhX20gPiBpbm5lclRocmVzaG9sZCAmJiBzdWJJdGVyYXRpb25zIDwgbWF4SW5uZXJJdGVyYXRpb25zKSB7XG4gICAgICAgICAgICBzdWJJdGVyYXRpb25zICs9IDE7XG4gICAgICAgICAgICB0aGlzLl9tb3ZlTm9kZShoaWdoRV9ub2RlSWQsIGRFX2R4LCBkRV9keSk7XG5cbiAgICAgICAgICAgIHZhciBfZ2V0RW5lcmd5MiA9IHRoaXMuX2dldEVuZXJneShoaWdoRV9ub2RlSWQpO1xuXG4gICAgICAgICAgICB2YXIgX2dldEVuZXJneTMgPSBfc2xpY2VkVG9BcnJheShfZ2V0RW5lcmd5MiwgMyk7XG5cbiAgICAgICAgICAgIGRlbHRhX20gPSBfZ2V0RW5lcmd5M1swXTtcbiAgICAgICAgICAgIGRFX2R4ID0gX2dldEVuZXJneTNbMV07XG4gICAgICAgICAgICBkRV9keSA9IF9nZXRFbmVyZ3kzWzJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGdldCB0aGUgbm9kZSB3aXRoIHRoZSBoaWdoZXN0IGVuZXJneVxuICAgICAgICogQHJldHVybnMgeypbXX1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZ2V0SGlnaGVzdEVuZXJneU5vZGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SGlnaGVzdEVuZXJneU5vZGUoaWdub3JlQ2x1c3RlcnMpIHtcbiAgICAgICAgdmFyIG5vZGVzQXJyYXkgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgdmFyIG1heEVuZXJneSA9IDA7XG4gICAgICAgIHZhciBtYXhFbmVyZ3lOb2RlSWQgPSBub2Rlc0FycmF5WzBdO1xuICAgICAgICB2YXIgZEVfZHhfbWF4ID0gMCxcbiAgICAgICAgICAgIGRFX2R5X21heCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgbm9kZUlkeCA9IDA7IG5vZGVJZHggPCBub2Rlc0FycmF5Lmxlbmd0aDsgbm9kZUlkeCsrKSB7XG4gICAgICAgICAgdmFyIG0gPSBub2Rlc0FycmF5W25vZGVJZHhdO1xuICAgICAgICAgIC8vIGJ5IG5vdCBldmFsdWF0aW5nIG5vZGVzIHdpdGggcHJlZGVmaW5lZCBwb3NpdGlvbnMgd2Ugc2hvdWxkIG9ubHkgbW92ZSBub2RlcyB0aGF0IGhhdmUgbm8gcG9zaXRpb25zLlxuICAgICAgICAgIGlmIChub2Rlc1ttXS5wcmVkZWZpbmVkUG9zaXRpb24gPT09IGZhbHNlIHx8IG5vZGVzW21dLmlzQ2x1c3RlciA9PT0gdHJ1ZSAmJiBpZ25vcmVDbHVzdGVycyA9PT0gdHJ1ZSB8fCBub2Rlc1ttXS5vcHRpb25zLmZpeGVkLnggPT09IHRydWUgfHwgbm9kZXNbbV0ub3B0aW9ucy5maXhlZC55ID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgX2dldEVuZXJneTQgPSB0aGlzLl9nZXRFbmVyZ3kobSksXG4gICAgICAgICAgICAgICAgX2dldEVuZXJneTUgPSBfc2xpY2VkVG9BcnJheShfZ2V0RW5lcmd5NCwgMyksXG4gICAgICAgICAgICAgICAgZGVsdGFfbSA9IF9nZXRFbmVyZ3k1WzBdLFxuICAgICAgICAgICAgICAgIGRFX2R4ID0gX2dldEVuZXJneTVbMV0sXG4gICAgICAgICAgICAgICAgZEVfZHkgPSBfZ2V0RW5lcmd5NVsyXTtcblxuICAgICAgICAgICAgaWYgKG1heEVuZXJneSA8IGRlbHRhX20pIHtcbiAgICAgICAgICAgICAgbWF4RW5lcmd5ID0gZGVsdGFfbTtcbiAgICAgICAgICAgICAgbWF4RW5lcmd5Tm9kZUlkID0gbTtcbiAgICAgICAgICAgICAgZEVfZHhfbWF4ID0gZEVfZHg7XG4gICAgICAgICAgICAgIGRFX2R5X21heCA9IGRFX2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbbWF4RW5lcmd5Tm9kZUlkLCBtYXhFbmVyZ3ksIGRFX2R4X21heCwgZEVfZHlfbWF4XTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBjYWxjdWxhdGUgdGhlIGVuZXJneSBvZiBhIHNpbmdsZSBub2RlXG4gICAgICAgKiBAcGFyYW0gbVxuICAgICAgICogQHJldHVybnMgeypbXX1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZ2V0RW5lcmd5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEVuZXJneShtKSB7XG4gICAgICAgIHZhciBub2Rlc0FycmF5ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG5cbiAgICAgICAgdmFyIHhfbSA9IG5vZGVzW21dLng7XG4gICAgICAgIHZhciB5X20gPSBub2Rlc1ttXS55O1xuICAgICAgICB2YXIgZEVfZHggPSAwO1xuICAgICAgICB2YXIgZEVfZHkgPSAwO1xuICAgICAgICBmb3IgKHZhciBpSWR4ID0gMDsgaUlkeCA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpSWR4KyspIHtcbiAgICAgICAgICB2YXIgaSA9IG5vZGVzQXJyYXlbaUlkeF07XG4gICAgICAgICAgaWYgKGkgIT09IG0pIHtcbiAgICAgICAgICAgIHZhciB4X2kgPSBub2Rlc1tpXS54O1xuICAgICAgICAgICAgdmFyIHlfaSA9IG5vZGVzW2ldLnk7XG4gICAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSAxLjAgLyBNYXRoLnNxcnQoTWF0aC5wb3coeF9tIC0geF9pLCAyKSArIE1hdGgucG93KHlfbSAtIHlfaSwgMikpO1xuICAgICAgICAgICAgZEVfZHggKz0gdGhpcy5LX21hdHJpeFttXVtpXSAqICh4X20gLSB4X2kgLSB0aGlzLkxfbWF0cml4W21dW2ldICogKHhfbSAtIHhfaSkgKiBkZW5vbWluYXRvcik7XG4gICAgICAgICAgICBkRV9keSArPSB0aGlzLktfbWF0cml4W21dW2ldICogKHlfbSAtIHlfaSAtIHRoaXMuTF9tYXRyaXhbbV1baV0gKiAoeV9tIC0geV9pKSAqIGRlbm9taW5hdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVsdGFfbSA9IE1hdGguc3FydChNYXRoLnBvdyhkRV9keCwgMikgKyBNYXRoLnBvdyhkRV9keSwgMikpO1xuICAgICAgICByZXR1cm4gW2RlbHRhX20sIGRFX2R4LCBkRV9keV07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogbW92ZSB0aGUgbm9kZSBiYXNlZCBvbiBpdCdzIGVuZXJneVxuICAgICAgICogdGhlIGR4IGFuZCBkeSBhcmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBsaW5lYXIgc3lzdGVtIHByb3Bvc2VkIGJ5IEthbWFkYSBhbmQgS2F3YWlcbiAgICAgICAqIEBwYXJhbSBtXG4gICAgICAgKiBAcGFyYW0gZEVfZHhcbiAgICAgICAqIEBwYXJhbSBkRV9keVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9tb3ZlTm9kZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlTm9kZShtLCBkRV9keCwgZEVfZHkpIHtcbiAgICAgICAgdmFyIG5vZGVzQXJyYXkgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgdmFyIGQyRV9keDIgPSAwO1xuICAgICAgICB2YXIgZDJFX2R4ZHkgPSAwO1xuICAgICAgICB2YXIgZDJFX2R5MiA9IDA7XG5cbiAgICAgICAgdmFyIHhfbSA9IG5vZGVzW21dLng7XG4gICAgICAgIHZhciB5X20gPSBub2Rlc1ttXS55O1xuICAgICAgICBmb3IgKHZhciBpSWR4ID0gMDsgaUlkeCA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpSWR4KyspIHtcbiAgICAgICAgICB2YXIgaSA9IG5vZGVzQXJyYXlbaUlkeF07XG4gICAgICAgICAgaWYgKGkgIT09IG0pIHtcbiAgICAgICAgICAgIHZhciB4X2kgPSBub2Rlc1tpXS54O1xuICAgICAgICAgICAgdmFyIHlfaSA9IG5vZGVzW2ldLnk7XG4gICAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSAxLjAgLyBNYXRoLnBvdyhNYXRoLnBvdyh4X20gLSB4X2ksIDIpICsgTWF0aC5wb3coeV9tIC0geV9pLCAyKSwgMS41KTtcbiAgICAgICAgICAgIGQyRV9keDIgKz0gdGhpcy5LX21hdHJpeFttXVtpXSAqICgxIC0gdGhpcy5MX21hdHJpeFttXVtpXSAqIE1hdGgucG93KHlfbSAtIHlfaSwgMikgKiBkZW5vbWluYXRvcik7XG4gICAgICAgICAgICBkMkVfZHhkeSArPSB0aGlzLktfbWF0cml4W21dW2ldICogKHRoaXMuTF9tYXRyaXhbbV1baV0gKiAoeF9tIC0geF9pKSAqICh5X20gLSB5X2kpICogZGVub21pbmF0b3IpO1xuICAgICAgICAgICAgZDJFX2R5MiArPSB0aGlzLktfbWF0cml4W21dW2ldICogKDEgLSB0aGlzLkxfbWF0cml4W21dW2ldICogTWF0aC5wb3coeF9tIC0geF9pLCAyKSAqIGRlbm9taW5hdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFrZSB0aGUgdmFyaWFibGUgbmFtZXMgZWFzaWVyIHRvIG1ha2UgdGhlIHNvbHZpbmcgb2YgdGhlIGxpbmVhciBzeXN0ZW0gZWFzaWVyIHRvIHJlYWRcbiAgICAgICAgdmFyIEEgPSBkMkVfZHgyLFxuICAgICAgICAgICAgQiA9IGQyRV9keGR5LFxuICAgICAgICAgICAgQyA9IGRFX2R4LFxuICAgICAgICAgICAgRCA9IGQyRV9keTIsXG4gICAgICAgICAgICBFID0gZEVfZHk7XG5cbiAgICAgICAgLy8gc29sdmUgdGhlIGxpbmVhciBzeXN0ZW0gZm9yIGR4IGFuZCBkeVxuICAgICAgICB2YXIgZHkgPSAoQyAvIEEgKyBFIC8gQikgLyAoQiAvIEEgLSBEIC8gQik7XG4gICAgICAgIHZhciBkeCA9IC0oQiAqIGR5ICsgQykgLyBBO1xuXG4gICAgICAgIC8vIG1vdmUgdGhlIG5vZGVcbiAgICAgICAgbm9kZXNbbV0ueCArPSBkeDtcbiAgICAgICAgbm9kZXNbbV0ueSArPSBkeTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGUgdGhlIEwgbWF0cml4OiBlZGdlIGxlbmd0aCB0aW1lcyBzaG9ydGVzdCBwYXRoXG4gICAgICAgKiBAcGFyYW0gRF9tYXRyaXhcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfY3JlYXRlTF9tYXRyaXhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlTF9tYXRyaXgoRF9tYXRyaXgpIHtcbiAgICAgICAgdmFyIG5vZGVzQXJyYXkgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICAgIHZhciBlZGdlTGVuZ3RoID0gdGhpcy5zcHJpbmdMZW5ndGg7XG5cbiAgICAgICAgdGhpcy5MX21hdHJpeCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLkxfbWF0cml4W25vZGVzQXJyYXlbaV1dID0ge307XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2Rlc0FycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB0aGlzLkxfbWF0cml4W25vZGVzQXJyYXlbaV1dW25vZGVzQXJyYXlbal1dID0gZWRnZUxlbmd0aCAqIERfbWF0cml4W25vZGVzQXJyYXlbaV1dW25vZGVzQXJyYXlbal1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSB0aGUgSyBtYXRyaXg6IHNwcmluZyBjb25zdGFudHMgdGltZXMgc2hvcnRlc3QgcGF0aFxuICAgICAgICogQHBhcmFtIERfbWF0cml4XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2NyZWF0ZUtfbWF0cml4XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUtfbWF0cml4KERfbWF0cml4KSB7XG4gICAgICAgIHZhciBub2Rlc0FycmF5ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgICB2YXIgZWRnZVN0cmVuZ3RoID0gdGhpcy5zcHJpbmdDb25zdGFudDtcblxuICAgICAgICB0aGlzLktfbWF0cml4ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuS19tYXRyaXhbbm9kZXNBcnJheVtpXV0gPSB7fTtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHRoaXMuS19tYXRyaXhbbm9kZXNBcnJheVtpXV1bbm9kZXNBcnJheVtqXV0gPSBlZGdlU3RyZW5ndGggKiBNYXRoLnBvdyhEX21hdHJpeFtub2Rlc0FycmF5W2ldXVtub2Rlc0FycmF5W2pdXSwgLTIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBLYW1hZGFLYXdhaTtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IEthbWFkYUthd2FpO1xuXG4vKioqLyB9LFxuLyogMTE4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICBcInVzZSBzdHJpY3RcIjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZWQgYnkgQWxleCBvbiAxMC1BdWctMTUuXG4gICAqL1xuXG4gIHZhciBGbG95ZFdhcnNoYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZsb3lkV2Fyc2hhbGwoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmxveWRXYXJzaGFsbCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEZsb3lkV2Fyc2hhbGwsIFt7XG4gICAgICBrZXk6IFwiZ2V0RGlzdGFuY2VzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGlzdGFuY2VzKGJvZHksIG5vZGVzQXJyYXksIGVkZ2VzQXJyYXkpIHtcbiAgICAgICAgdmFyIERfbWF0cml4ID0ge307XG4gICAgICAgIHZhciBlZGdlcyA9IGJvZHkuZWRnZXM7XG5cbiAgICAgICAgLy8gcHJlcGFyZSBtYXRyaXggd2l0aCBsYXJnZSBudW1iZXJzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIERfbWF0cml4W25vZGVzQXJyYXlbaV1dID0ge307XG4gICAgICAgICAgRF9tYXRyaXhbbm9kZXNBcnJheVtpXV0gPSB7fTtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIERfbWF0cml4W25vZGVzQXJyYXlbaV1dW25vZGVzQXJyYXlbal1dID0gaSA9PSBqID8gMCA6IDFlOTtcbiAgICAgICAgICAgIERfbWF0cml4W25vZGVzQXJyYXlbaV1dW25vZGVzQXJyYXlbal1dID0gaSA9PSBqID8gMCA6IDFlOTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwdXQgdGhlIHdlaWdodHMgZm9yIHRoZSBlZGdlcyBpbi4gVGhpcyBhc3N1bWVzIHVuaWRpcmVjdGlvbmFsaXR5LlxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWRnZXNBcnJheS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VkZ2VzQXJyYXlbX2ldXTtcbiAgICAgICAgICAvLyBlZGdlIGhhcyB0byBiZSBjb25uZWN0ZWQgaWYgaXQgY291bnRzIHRvIHRoZSBkaXN0YW5jZXMuIElmIGl0IGlzIGNvbm5lY3RlZCB0byBpbm5lciBjbHVzdGVycyBpdCB3aWxsIGNyYXNoIHNvIHdlIGFsc28gY2hlY2sgaWYgaXQgaXMgaW4gdGhlIERfbWF0cml4XG4gICAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkID09PSB0cnVlICYmIERfbWF0cml4W2VkZ2UuZnJvbUlkXSAhPT0gdW5kZWZpbmVkICYmIERfbWF0cml4W2VkZ2UudG9JZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgRF9tYXRyaXhbZWRnZS5mcm9tSWRdW2VkZ2UudG9JZF0gPSAxO1xuICAgICAgICAgICAgRF9tYXRyaXhbZWRnZS50b0lkXVtlZGdlLmZyb21JZF0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub2RlQ291bnQgPSBub2Rlc0FycmF5Lmxlbmd0aDtcblxuICAgICAgICAvLyBBZGFwdGVkIEZsb3lkV2Fyc2hhbGwgYmFzZWQgb24gdW5pZGlyZWN0aW9uYWxpdHkgdG8gZ3JlYXRseSByZWR1Y2UgY29tcGxleGl0eS5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBub2RlQ291bnQ7IGsrKykge1xuICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVDb3VudCAtIDE7IF9pMisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaiA9IF9pMiArIDE7IF9qIDwgbm9kZUNvdW50OyBfaisrKSB7XG4gICAgICAgICAgICAgIERfbWF0cml4W25vZGVzQXJyYXlbX2kyXV1bbm9kZXNBcnJheVtfal1dID0gTWF0aC5taW4oRF9tYXRyaXhbbm9kZXNBcnJheVtfaTJdXVtub2Rlc0FycmF5W19qXV0sIERfbWF0cml4W25vZGVzQXJyYXlbX2kyXV1bbm9kZXNBcnJheVtrXV0gKyBEX21hdHJpeFtub2Rlc0FycmF5W2tdXVtub2Rlc0FycmF5W19qXV0pO1xuICAgICAgICAgICAgICBEX21hdHJpeFtub2Rlc0FycmF5W19qXV1bbm9kZXNBcnJheVtfaTJdXSA9IERfbWF0cml4W25vZGVzQXJyYXlbX2kyXV1bbm9kZXNBcnJheVtfal1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBEX21hdHJpeDtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRmxveWRXYXJzaGFsbDtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IEZsb3lkV2Fyc2hhbGw7XG5cbi8qKiovIH0sXG4vKiAxMTkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogQ2FudmFzIHNoYXBlcyB1c2VkIGJ5IE5ldHdvcmtcbiAgICovXG4gIGlmICh0eXBlb2YgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEICE9PSAndW5kZWZpbmVkJykge1xuXG4gICAgLyoqXG4gICAgICogRHJhdyBhIGNpcmNsZSBzaGFwZVxuICAgICAqL1xuICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuY2lyY2xlID0gZnVuY3Rpb24gKHgsIHksIHIpIHtcbiAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLmFyYyh4LCB5LCByLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRHJhdyBhIHNxdWFyZSBzaGFwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IGhvcml6b250YWwgY2VudGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgdmVydGljYWwgY2VudGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHIgICBzaXplLCB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBzcXVhcmVcbiAgICAgKi9cbiAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLnNxdWFyZSA9IGZ1bmN0aW9uICh4LCB5LCByKSB7XG4gICAgICB0aGlzLmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5yZWN0KHggLSByLCB5IC0gciwgciAqIDIsIHIgKiAyKTtcbiAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERyYXcgYSB0cmlhbmdsZSBzaGFwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IGhvcml6b250YWwgY2VudGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgdmVydGljYWwgY2VudGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHIgICByYWRpdXMsIGhhbGYgdGhlIGxlbmd0aCBvZiB0aGUgc2lkZXMgb2YgdGhlIHRyaWFuZ2xlXG4gICAgICovXG4gICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS50cmlhbmdsZSA9IGZ1bmN0aW9uICh4LCB5LCByKSB7XG4gICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VxdWlsYXRlcmFsX3RyaWFuZ2xlXG4gICAgICB0aGlzLmJlZ2luUGF0aCgpO1xuXG4gICAgICAvLyB0aGUgY2hhbmdlIGluIHJhZGl1cyBhbmQgdGhlIG9mZnNldCBpcyBoZXJlIHRvIGNlbnRlciB0aGUgc2hhcGVcbiAgICAgIHIgKj0gMS4xNTtcbiAgICAgIHkgKz0gMC4yNzUgKiByO1xuXG4gICAgICB2YXIgcyA9IHIgKiAyO1xuICAgICAgdmFyIHMyID0gcyAvIDI7XG4gICAgICB2YXIgaXIgPSBNYXRoLnNxcnQoMykgLyA2ICogczsgLy8gcmFkaXVzIG9mIGlubmVyIGNpcmNsZVxuICAgICAgdmFyIGggPSBNYXRoLnNxcnQocyAqIHMgLSBzMiAqIHMyKTsgLy8gaGVpZ2h0XG5cblxuICAgICAgdGhpcy5tb3ZlVG8oeCwgeSAtIChoIC0gaXIpKTtcbiAgICAgIHRoaXMubGluZVRvKHggKyBzMiwgeSArIGlyKTtcbiAgICAgIHRoaXMubGluZVRvKHggLSBzMiwgeSArIGlyKTtcbiAgICAgIHRoaXMubGluZVRvKHgsIHkgLSAoaCAtIGlyKSk7XG4gICAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgdHJpYW5nbGUgc2hhcGUgaW4gZG93bndhcmQgb3JpZW50YXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBob3Jpem9udGFsIGNlbnRlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHZlcnRpY2FsIGNlbnRlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByIHJhZGl1c1xuICAgICAqL1xuICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUudHJpYW5nbGVEb3duID0gZnVuY3Rpb24gKHgsIHksIHIpIHtcbiAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXF1aWxhdGVyYWxfdHJpYW5nbGVcbiAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XG5cbiAgICAgIC8vIHRoZSBjaGFuZ2UgaW4gcmFkaXVzIGFuZCB0aGUgb2Zmc2V0IGlzIGhlcmUgdG8gY2VudGVyIHRoZSBzaGFwZVxuICAgICAgciAqPSAxLjE1O1xuICAgICAgeSAtPSAwLjI3NSAqIHI7XG5cbiAgICAgIHZhciBzID0gciAqIDI7XG4gICAgICB2YXIgczIgPSBzIC8gMjtcbiAgICAgIHZhciBpciA9IE1hdGguc3FydCgzKSAvIDYgKiBzOyAvLyByYWRpdXMgb2YgaW5uZXIgY2lyY2xlXG4gICAgICB2YXIgaCA9IE1hdGguc3FydChzICogcyAtIHMyICogczIpOyAvLyBoZWlnaHRcblxuICAgICAgdGhpcy5tb3ZlVG8oeCwgeSArIChoIC0gaXIpKTtcbiAgICAgIHRoaXMubGluZVRvKHggKyBzMiwgeSAtIGlyKTtcbiAgICAgIHRoaXMubGluZVRvKHggLSBzMiwgeSAtIGlyKTtcbiAgICAgIHRoaXMubGluZVRvKHgsIHkgKyAoaCAtIGlyKSk7XG4gICAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgc3RhciBzaGFwZSwgYSBzdGFyIHdpdGggNSBwb2ludHNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBob3Jpem9udGFsIGNlbnRlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHZlcnRpY2FsIGNlbnRlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByICAgcmFkaXVzLCBoYWxmIHRoZSBsZW5ndGggb2YgdGhlIHNpZGVzIG9mIHRoZSB0cmlhbmdsZVxuICAgICAqL1xuICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuc3RhciA9IGZ1bmN0aW9uICh4LCB5LCByKSB7XG4gICAgICAvLyBodHRwOi8vd3d3Lmh0bWw1Y2FudmFzdHV0b3JpYWxzLmNvbS9sYWJzL2h0bWw1LWNhbnZhcy1zdGFyLXNwaW5uZXIvXG4gICAgICB0aGlzLmJlZ2luUGF0aCgpO1xuXG4gICAgICAvLyB0aGUgY2hhbmdlIGluIHJhZGl1cyBhbmQgdGhlIG9mZnNldCBpcyBoZXJlIHRvIGNlbnRlciB0aGUgc2hhcGVcbiAgICAgIHIgKj0gMC44MjtcbiAgICAgIHkgKz0gMC4xICogcjtcblxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCAxMDsgbisrKSB7XG4gICAgICAgIHZhciByYWRpdXMgPSBuICUgMiA9PT0gMCA/IHIgKiAxLjMgOiByICogMC41O1xuICAgICAgICB0aGlzLmxpbmVUbyh4ICsgcmFkaXVzICogTWF0aC5zaW4obiAqIDIgKiBNYXRoLlBJIC8gMTApLCB5IC0gcmFkaXVzICogTWF0aC5jb3MobiAqIDIgKiBNYXRoLlBJIC8gMTApKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRHJhdyBhIERpYW1vbmQgc2hhcGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBob3Jpem9udGFsIGNlbnRlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHZlcnRpY2FsIGNlbnRlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByICAgcmFkaXVzLCBoYWxmIHRoZSBsZW5ndGggb2YgdGhlIHNpZGVzIG9mIHRoZSB0cmlhbmdsZVxuICAgICAqL1xuICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZGlhbW9uZCA9IGZ1bmN0aW9uICh4LCB5LCByKSB7XG4gICAgICAvLyBodHRwOi8vd3d3Lmh0bWw1Y2FudmFzdHV0b3JpYWxzLmNvbS9sYWJzL2h0bWw1LWNhbnZhcy1zdGFyLXNwaW5uZXIvXG4gICAgICB0aGlzLmJlZ2luUGF0aCgpO1xuXG4gICAgICB0aGlzLmxpbmVUbyh4LCB5ICsgcik7XG4gICAgICB0aGlzLmxpbmVUbyh4ICsgciwgeSk7XG4gICAgICB0aGlzLmxpbmVUbyh4LCB5IC0gcik7XG4gICAgICB0aGlzLmxpbmVUbyh4IC0gciwgeSk7XG5cbiAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTI1NTUxMi9ob3ctdG8tZHJhdy1hLXJvdW5kZWQtcmVjdGFuZ2xlLW9uLWh0bWwtY2FudmFzXG4gICAgICovXG4gICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5yb3VuZFJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgdywgaCwgcikge1xuICAgICAgdmFyIHIyZCA9IE1hdGguUEkgLyAxODA7XG4gICAgICBpZiAodyAtIDIgKiByIDwgMCkge1xuICAgICAgICByID0gdyAvIDI7XG4gICAgICB9IC8vZW5zdXJlIHRoYXQgdGhlIHJhZGl1cyBpc24ndCB0b28gbGFyZ2UgZm9yIHhcbiAgICAgIGlmIChoIC0gMiAqIHIgPCAwKSB7XG4gICAgICAgIHIgPSBoIC8gMjtcbiAgICAgIH0gLy9lbnN1cmUgdGhhdCB0aGUgcmFkaXVzIGlzbid0IHRvbyBsYXJnZSBmb3IgeVxuICAgICAgdGhpcy5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMubW92ZVRvKHggKyByLCB5KTtcbiAgICAgIHRoaXMubGluZVRvKHggKyB3IC0gciwgeSk7XG4gICAgICB0aGlzLmFyYyh4ICsgdyAtIHIsIHkgKyByLCByLCByMmQgKiAyNzAsIHIyZCAqIDM2MCwgZmFsc2UpO1xuICAgICAgdGhpcy5saW5lVG8oeCArIHcsIHkgKyBoIC0gcik7XG4gICAgICB0aGlzLmFyYyh4ICsgdyAtIHIsIHkgKyBoIC0gciwgciwgMCwgcjJkICogOTAsIGZhbHNlKTtcbiAgICAgIHRoaXMubGluZVRvKHggKyByLCB5ICsgaCk7XG4gICAgICB0aGlzLmFyYyh4ICsgciwgeSArIGggLSByLCByLCByMmQgKiA5MCwgcjJkICogMTgwLCBmYWxzZSk7XG4gICAgICB0aGlzLmxpbmVUbyh4LCB5ICsgcik7XG4gICAgICB0aGlzLmFyYyh4ICsgciwgeSArIHIsIHIsIHIyZCAqIDE4MCwgcjJkICogMjcwLCBmYWxzZSk7XG4gICAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIxNzI3OTgvaG93LXRvLWRyYXctYW4tb3ZhbC1pbi1odG1sNS1jYW52YXNcbiAgICAgKi9cbiAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmVsbGlwc2UgPSBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuICAgICAgdmFyIGthcHBhID0gLjU1MjI4NDgsXG4gICAgICAgICAgb3ggPSB3IC8gMiAqIGthcHBhLFxuICAgICAgICAgIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IGhvcml6b250YWxcbiAgICAgIG95ID0gaCAvIDIgKiBrYXBwYSxcbiAgICAgICAgICAvLyBjb250cm9sIHBvaW50IG9mZnNldCB2ZXJ0aWNhbFxuICAgICAgeGUgPSB4ICsgdyxcbiAgICAgICAgICAvLyB4LWVuZFxuICAgICAgeWUgPSB5ICsgaCxcbiAgICAgICAgICAvLyB5LWVuZFxuICAgICAgeG0gPSB4ICsgdyAvIDIsXG4gICAgICAgICAgLy8geC1taWRkbGVcbiAgICAgIHltID0geSArIGggLyAyOyAvLyB5LW1pZGRsZVxuXG4gICAgICB0aGlzLmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5tb3ZlVG8oeCwgeW0pO1xuICAgICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHgsIHltIC0gb3ksIHhtIC0gb3gsIHksIHhtLCB5KTtcbiAgICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4bSArIG94LCB5LCB4ZSwgeW0gLSBveSwgeGUsIHltKTtcbiAgICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4ZSwgeW0gKyBveSwgeG0gKyBveCwgeWUsIHhtLCB5ZSk7XG4gICAgICB0aGlzLmJlemllckN1cnZlVG8oeG0gLSBveCwgeWUsIHgsIHltICsgb3ksIHgsIHltKTtcbiAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjE3Mjc5OC9ob3ctdG8tZHJhdy1hbi1vdmFsLWluLWh0bWw1LWNhbnZhc1xuICAgICAqL1xuICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZGF0YWJhc2UgPSBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuICAgICAgdmFyIGYgPSAxIC8gMztcbiAgICAgIHZhciB3RWxsaXBzZSA9IHc7XG4gICAgICB2YXIgaEVsbGlwc2UgPSBoICogZjtcblxuICAgICAgdmFyIGthcHBhID0gLjU1MjI4NDgsXG4gICAgICAgICAgb3ggPSB3RWxsaXBzZSAvIDIgKiBrYXBwYSxcbiAgICAgICAgICAvLyBjb250cm9sIHBvaW50IG9mZnNldCBob3Jpem9udGFsXG4gICAgICBveSA9IGhFbGxpcHNlIC8gMiAqIGthcHBhLFxuICAgICAgICAgIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IHZlcnRpY2FsXG4gICAgICB4ZSA9IHggKyB3RWxsaXBzZSxcbiAgICAgICAgICAvLyB4LWVuZFxuICAgICAgeWUgPSB5ICsgaEVsbGlwc2UsXG4gICAgICAgICAgLy8geS1lbmRcbiAgICAgIHhtID0geCArIHdFbGxpcHNlIC8gMixcbiAgICAgICAgICAvLyB4LW1pZGRsZVxuICAgICAgeW0gPSB5ICsgaEVsbGlwc2UgLyAyLFxuICAgICAgICAgIC8vIHktbWlkZGxlXG4gICAgICB5bWIgPSB5ICsgKGggLSBoRWxsaXBzZSAvIDIpLFxuICAgICAgICAgIC8vIHktbWlkbGxlLCBib3R0b20gZWxsaXBzZVxuICAgICAgeWViID0geSArIGg7IC8vIHktZW5kLCBib3R0b20gZWxsaXBzZVxuXG4gICAgICB0aGlzLmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5tb3ZlVG8oeGUsIHltKTtcblxuICAgICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHhlLCB5bSArIG95LCB4bSArIG94LCB5ZSwgeG0sIHllKTtcbiAgICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4bSAtIG94LCB5ZSwgeCwgeW0gKyBveSwgeCwgeW0pO1xuXG4gICAgICB0aGlzLmJlemllckN1cnZlVG8oeCwgeW0gLSBveSwgeG0gLSBveCwgeSwgeG0sIHkpO1xuICAgICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHhtICsgb3gsIHksIHhlLCB5bSAtIG95LCB4ZSwgeW0pO1xuXG4gICAgICB0aGlzLmxpbmVUbyh4ZSwgeW1iKTtcblxuICAgICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHhlLCB5bWIgKyBveSwgeG0gKyBveCwgeWViLCB4bSwgeWViKTtcbiAgICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4bSAtIG94LCB5ZWIsIHgsIHltYiArIG95LCB4LCB5bWIpO1xuXG4gICAgICB0aGlzLmxpbmVUbyh4LCB5bSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERyYXcgYW4gYXJyb3cgYXQgdGhlIGVuZCBvZiBhIGxpbmUgd2l0aCB0aGUgZ2l2ZW4gYW5nbGUuXG4gICAgICovXG4gICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5hcnJvd0VuZHBvaW50ID0gZnVuY3Rpb24gKHgsIHksIGFuZ2xlLCBsZW5ndGgpIHtcbiAgICAgIC8vIHRhaWxcbiAgICAgIHZhciB4dCA9IHggLSBsZW5ndGggKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICB2YXIgeXQgPSB5IC0gbGVuZ3RoICogTWF0aC5zaW4oYW5nbGUpO1xuXG4gICAgICAvLyBpbm5lciB0YWlsXG4gICAgICB2YXIgeGkgPSB4IC0gbGVuZ3RoICogMC45ICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgdmFyIHlpID0geSAtIGxlbmd0aCAqIDAuOSAqIE1hdGguc2luKGFuZ2xlKTtcblxuICAgICAgLy8gbGVmdFxuICAgICAgdmFyIHhsID0geHQgKyBsZW5ndGggLyAzICogTWF0aC5jb3MoYW5nbGUgKyAwLjUgKiBNYXRoLlBJKTtcbiAgICAgIHZhciB5bCA9IHl0ICsgbGVuZ3RoIC8gMyAqIE1hdGguc2luKGFuZ2xlICsgMC41ICogTWF0aC5QSSk7XG5cbiAgICAgIC8vIHJpZ2h0XG4gICAgICB2YXIgeHIgPSB4dCArIGxlbmd0aCAvIDMgKiBNYXRoLmNvcyhhbmdsZSAtIDAuNSAqIE1hdGguUEkpO1xuICAgICAgdmFyIHlyID0geXQgKyBsZW5ndGggLyAzICogTWF0aC5zaW4oYW5nbGUgLSAwLjUgKiBNYXRoLlBJKTtcblxuICAgICAgdGhpcy5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMubW92ZVRvKHgsIHkpO1xuICAgICAgdGhpcy5saW5lVG8oeGwsIHlsKTtcbiAgICAgIHRoaXMubGluZVRvKHhpLCB5aSk7XG4gICAgICB0aGlzLmxpbmVUbyh4ciwgeXIpO1xuICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRHJhdyBhbiBjaXJjbGUgYW4gdGhlIGVuZCBvZiBhbiBsaW5lIHdpdGggdGhlIGdpdmVuIGFuZ2xlLlxuICAgICAqL1xuICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuY2lyY2xlRW5kcG9pbnQgPSBmdW5jdGlvbiAoeCwgeSwgYW5nbGUsIGxlbmd0aCkge1xuICAgICAgdmFyIHJhZGl1cyA9IGxlbmd0aCAqIDAuNDtcbiAgICAgIHZhciB4YyA9IHggLSByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICB2YXIgeWMgPSB5IC0gcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgdGhpcy5jaXJjbGUoeGMsIHljLCByYWRpdXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBkYXNoZWRMaW5lIGZ1bmN0aW9uYWxpdHkgZm9yIGRyYXdpbmdcbiAgICAgKiBPcmlnaW5hbCBjb2RlIGNhbWUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ1NzY3MjQvZG90dGVkLXN0cm9rZS1pbi1jYW52YXNcbiAgICAgKiBAYXV0aG9yIERhdmlkIEpvcmRhblxuICAgICAqIEBkYXRlIDIwMTItMDgtMDhcbiAgICAgKi9cbiAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmRhc2hlZExpbmUgPSBmdW5jdGlvbiAoeCwgeSwgeDIsIHkyLCBwYXR0ZXJuKSB7XG4gICAgICB0aGlzLmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5tb3ZlVG8oeCwgeSk7XG5cbiAgICAgIHZhciBwYXR0ZXJuTGVuZ3RoID0gcGF0dGVybi5sZW5ndGg7XG4gICAgICB2YXIgZHggPSB4MiAtIHg7XG4gICAgICB2YXIgZHkgPSB5MiAtIHk7XG4gICAgICB2YXIgc2xvcGUgPSBkeSAvIGR4O1xuICAgICAgdmFyIGRpc3RSZW1haW5pbmcgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgdmFyIHBhdHRlcm5JbmRleCA9IDA7XG4gICAgICB2YXIgZHJhdyA9IHRydWU7XG4gICAgICB2YXIgeFN0ZXAgPSAwO1xuICAgICAgdmFyIGRhc2hMZW5ndGggPSBwYXR0ZXJuWzBdO1xuXG4gICAgICB3aGlsZSAoZGlzdFJlbWFpbmluZyA+PSAwLjEpIHtcbiAgICAgICAgZGFzaExlbmd0aCA9IHBhdHRlcm5bcGF0dGVybkluZGV4KysgJSBwYXR0ZXJuTGVuZ3RoXTtcbiAgICAgICAgaWYgKGRhc2hMZW5ndGggPiBkaXN0UmVtYWluaW5nKSB7XG4gICAgICAgICAgZGFzaExlbmd0aCA9IGRpc3RSZW1haW5pbmc7XG4gICAgICAgIH1cblxuICAgICAgICB4U3RlcCA9IE1hdGguc3FydChkYXNoTGVuZ3RoICogZGFzaExlbmd0aCAvICgxICsgc2xvcGUgKiBzbG9wZSkpO1xuICAgICAgICB4U3RlcCA9IGR4IDwgMCA/IC14U3RlcCA6IHhTdGVwO1xuICAgICAgICB4ICs9IHhTdGVwO1xuICAgICAgICB5ICs9IHNsb3BlICogeFN0ZXA7XG5cbiAgICAgICAgaWYgKGRyYXcgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm1vdmVUbyh4LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3RSZW1haW5pbmcgLT0gZGFzaExlbmd0aDtcbiAgICAgICAgZHJhdyA9ICFkcmF3O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuLyoqKi8gfSxcbi8qIDEyMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHRleHQgc291cmNlIGNvbnRhaW5pbmcgZGF0YSBpbiBET1QgbGFuZ3VhZ2UgaW50byBhIEpTT04gb2JqZWN0LlxuICAgKiBUaGUgb2JqZWN0IGNvbnRhaW5zIHR3byBsaXN0czogb25lIHdpdGggbm9kZXMgYW5kIG9uZSB3aXRoIGVkZ2VzLlxuICAgKlxuICAgKiBET1QgbGFuZ3VhZ2UgcmVmZXJlbmNlOiBodHRwOi8vd3d3LmdyYXBodml6Lm9yZy9kb2MvaW5mby9sYW5nLmh0bWxcbiAgICpcbiAgICogRE9UIGxhbmd1YWdlIGF0dHJpYnV0ZXM6IGh0dHA6Ly9ncmFwaHZpei5vcmcvY29udGVudC9hdHRyc1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSAgICAgVGV4dCBjb250YWluaW5nIGEgZ3JhcGggaW4gRE9ULW5vdGF0aW9uXG4gICAqIEByZXR1cm4ge09iamVjdH0gZ3JhcGggICBBbiBvYmplY3QgY29udGFpbmluZyB0d28gcGFyYW1ldGVyczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3RbXX0gbm9kZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3RbXX0gZWRnZXNcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlRE9UKGRhdGEpIHtcbiAgICBkb3QgPSBkYXRhO1xuICAgIHJldHVybiBwYXJzZUdyYXBoKCk7XG4gIH1cblxuICAvLyBtYXBwaW5nIG9mIGF0dHJpYnV0ZXMgZnJvbSBET1QgKHRoZSBrZXlzKSB0byB2aXMuanMgKHRoZSB2YWx1ZXMpXG4gIHZhciBOT0RFX0FUVFJfTUFQUElORyA9IHtcbiAgICAnZm9udHNpemUnOiAnZm9udC5zaXplJyxcbiAgICAnZm9udGNvbG9yJzogJ2ZvbnQuY29sb3InLFxuICAgICdsYWJlbGZvbnRjb2xvcic6ICdmb250LmNvbG9yJyxcbiAgICAnZm9udG5hbWUnOiAnZm9udC5mYWNlJyxcbiAgICAnY29sb3InOiBbJ2NvbG9yLmJvcmRlcicsICdjb2xvci5iYWNrZ3JvdW5kJ10sXG4gICAgJ2ZpbGxjb2xvcic6ICdjb2xvci5iYWNrZ3JvdW5kJyxcbiAgICAndG9vbHRpcCc6ICd0aXRsZScsXG4gICAgJ2xhYmVsdG9vbHRpcCc6ICd0aXRsZSdcbiAgfTtcbiAgdmFyIEVER0VfQVRUUl9NQVBQSU5HID0gT2JqZWN0LmNyZWF0ZShOT0RFX0FUVFJfTUFQUElORyk7XG4gIEVER0VfQVRUUl9NQVBQSU5HLmNvbG9yID0gJ2NvbG9yLmNvbG9yJztcblxuICAvLyB0b2tlbiB0eXBlcyBlbnVtZXJhdGlvblxuICB2YXIgVE9LRU5UWVBFID0ge1xuICAgIE5VTEw6IDAsXG4gICAgREVMSU1JVEVSOiAxLFxuICAgIElERU5USUZJRVI6IDIsXG4gICAgVU5LTk9XTjogM1xuICB9O1xuXG4gIC8vIG1hcCB3aXRoIGFsbCBkZWxpbWl0ZXJzXG4gIHZhciBERUxJTUlURVJTID0ge1xuICAgICd7JzogdHJ1ZSxcbiAgICAnfSc6IHRydWUsXG4gICAgJ1snOiB0cnVlLFxuICAgICddJzogdHJ1ZSxcbiAgICAnOyc6IHRydWUsXG4gICAgJz0nOiB0cnVlLFxuICAgICcsJzogdHJ1ZSxcblxuICAgICctPic6IHRydWUsXG4gICAgJy0tJzogdHJ1ZVxuICB9O1xuXG4gIHZhciBkb3QgPSAnJzsgLy8gY3VycmVudCBkb3QgZmlsZVxuICB2YXIgaW5kZXggPSAwOyAvLyBjdXJyZW50IGluZGV4IGluIGRvdCBmaWxlXG4gIHZhciBjID0gJyc7IC8vIGN1cnJlbnQgdG9rZW4gY2hhcmFjdGVyIGluIGV4cHJcbiAgdmFyIHRva2VuID0gJyc7IC8vIGN1cnJlbnQgdG9rZW5cbiAgdmFyIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5OVUxMOyAvLyB0eXBlIG9mIHRoZSB0b2tlblxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpcnN0IGNoYXJhY3RlciBmcm9tIHRoZSBkb3QgZmlsZS5cbiAgICogVGhlIGNoYXJhY3RlciBpcyBzdG9yZWQgaW50byB0aGUgY2hhciBjLiBJZiB0aGUgZW5kIG9mIHRoZSBkb3QgZmlsZSBpc1xuICAgKiByZWFjaGVkLCB0aGUgZnVuY3Rpb24gcHV0cyBhbiBlbXB0eSBzdHJpbmcgaW4gYy5cbiAgICovXG4gIGZ1bmN0aW9uIGZpcnN0KCkge1xuICAgIGluZGV4ID0gMDtcbiAgICBjID0gZG90LmNoYXJBdCgwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5leHQgY2hhcmFjdGVyIGZyb20gdGhlIGRvdCBmaWxlLlxuICAgKiBUaGUgY2hhcmFjdGVyIGlzIHN0b3JlZCBpbnRvIHRoZSBjaGFyIGMuIElmIHRoZSBlbmQgb2YgdGhlIGRvdCBmaWxlIGlzXG4gICAqIHJlYWNoZWQsIHRoZSBmdW5jdGlvbiBwdXRzIGFuIGVtcHR5IHN0cmluZyBpbiBjLlxuICAgKi9cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBpbmRleCsrO1xuICAgIGMgPSBkb3QuY2hhckF0KGluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmV2aWV3IHRoZSBuZXh0IGNoYXJhY3RlciBmcm9tIHRoZSBkb3QgZmlsZS5cbiAgICogQHJldHVybiB7U3RyaW5nfSBjTmV4dFxuICAgKi9cbiAgZnVuY3Rpb24gbmV4dFByZXZpZXcoKSB7XG4gICAgcmV0dXJuIGRvdC5jaGFyQXQoaW5kZXggKyAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgZ2l2ZW4gY2hhcmFjdGVyIGlzIGFscGhhYmV0aWMgb3IgbnVtZXJpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gY1xuICAgKiBAcmV0dXJuIHtCb29sZWFufSBpc0FscGhhTnVtZXJpY1xuICAgKi9cbiAgdmFyIHJlZ2V4QWxwaGFOdW1lcmljID0gL1thLXpBLVpfMC05LjojXS87XG4gIGZ1bmN0aW9uIGlzQWxwaGFOdW1lcmljKGMpIHtcbiAgICByZXR1cm4gcmVnZXhBbHBoYU51bWVyaWMudGVzdChjKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSBhbGwgb3B0aW9ucyBvZiBvYmplY3QgYiBpbnRvIG9iamVjdCBiXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gICAqIEByZXR1cm4ge09iamVjdH0gYVxuICAgKi9cbiAgZnVuY3Rpb24gbWVyZ2UoYSwgYikge1xuICAgIGlmICghYSkge1xuICAgICAgYSA9IHt9O1xuICAgIH1cblxuICAgIGlmIChiKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGIpIHtcbiAgICAgICAgaWYgKGIuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICBhW25hbWVdID0gYltuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSB2YWx1ZSBpbiBhbiBvYmplY3QsIHdoZXJlIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgbmFtZSBjYW4gYmUgYVxuICAgKiBwYXRoIHdpdGggbmVzdGVkIHBhcmFtZXRlcnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHthOiAyfTtcbiAgICogICAgIHNldFZhbHVlKG9iaiwgJ2IuYycsIDMpOyAgICAgLy8gb2JqID0ge2E6IDIsIGI6IHtjOiAzfX1cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCAgQSBwYXJhbWV0ZXIgbmFtZSBvciBkb3Qtc2VwYXJhdGVkIHBhcmFtZXRlciBwYXRoLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICBsaWtlIFwiY29sb3IuaGlnaGxpZ2h0LmJvcmRlclwiLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICBmdW5jdGlvbiBzZXRWYWx1ZShvYmosIHBhdGgsIHZhbHVlKSB7XG4gICAgdmFyIGtleXMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgdmFyIG8gPSBvYmo7XG4gICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICB2YXIga2V5ID0ga2V5cy5zaGlmdCgpO1xuICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIHRoaXMgaXNuJ3QgdGhlIGVuZCBwb2ludFxuICAgICAgICBpZiAoIW9ba2V5XSkge1xuICAgICAgICAgIG9ba2V5XSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIG8gPSBvW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBlbmQgcG9pbnRcbiAgICAgICAgb1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5vZGUgdG8gYSBncmFwaCBvYmplY3QuIElmIHRoZXJlIGlzIGFscmVhZHkgYSBub2RlIHdpdGhcbiAgICogdGhlIHNhbWUgaWQsIHRoZWlyIGF0dHJpYnV0ZXMgd2lsbCBiZSBtZXJnZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBncmFwaFxuICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gYWRkTm9kZShncmFwaCwgbm9kZSkge1xuICAgIHZhciBpLCBsZW47XG4gICAgdmFyIGN1cnJlbnQgPSBudWxsO1xuXG4gICAgLy8gZmluZCByb290IGdyYXBoIChpbiBjYXNlIG9mIHN1YmdyYXBoKVxuICAgIHZhciBncmFwaHMgPSBbZ3JhcGhdOyAvLyBsaXN0IHdpdGggYWxsIGdyYXBocyBmcm9tIGN1cnJlbnQgZ3JhcGggdG8gcm9vdCBncmFwaFxuICAgIHZhciByb290ID0gZ3JhcGg7XG4gICAgd2hpbGUgKHJvb3QucGFyZW50KSB7XG4gICAgICBncmFwaHMucHVzaChyb290LnBhcmVudCk7XG4gICAgICByb290ID0gcm9vdC5wYXJlbnQ7XG4gICAgfVxuXG4gICAgLy8gZmluZCBleGlzdGluZyBub2RlIChhdCByb290IGxldmVsKSBieSBpdHMgaWRcbiAgICBpZiAocm9vdC5ub2Rlcykge1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gcm9vdC5ub2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAobm9kZS5pZCA9PT0gcm9vdC5ub2Rlc1tpXS5pZCkge1xuICAgICAgICAgIGN1cnJlbnQgPSByb290Lm5vZGVzW2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAvLyB0aGlzIGlzIGEgbmV3IG5vZGVcbiAgICAgIGN1cnJlbnQgPSB7XG4gICAgICAgIGlkOiBub2RlLmlkXG4gICAgICB9O1xuICAgICAgaWYgKGdyYXBoLm5vZGUpIHtcbiAgICAgICAgLy8gY2xvbmUgZGVmYXVsdCBhdHRyaWJ1dGVzXG4gICAgICAgIGN1cnJlbnQuYXR0ciA9IG1lcmdlKGN1cnJlbnQuYXR0ciwgZ3JhcGgubm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkIG5vZGUgdG8gdGhpcyAoc3ViKWdyYXBoIGFuZCBhbGwgaXRzIHBhcmVudCBncmFwaHNcbiAgICBmb3IgKGkgPSBncmFwaHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBnID0gZ3JhcGhzW2ldO1xuXG4gICAgICBpZiAoIWcubm9kZXMpIHtcbiAgICAgICAgZy5ub2RlcyA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKGcubm9kZXMuaW5kZXhPZihjdXJyZW50KSA9PT0gLTEpIHtcbiAgICAgICAgZy5ub2Rlcy5wdXNoKGN1cnJlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1lcmdlIGF0dHJpYnV0ZXNcbiAgICBpZiAobm9kZS5hdHRyKSB7XG4gICAgICBjdXJyZW50LmF0dHIgPSBtZXJnZShjdXJyZW50LmF0dHIsIG5vZGUuYXR0cik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBlZGdlIHRvIGEgZ3JhcGggb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBncmFwaFxuICAgKiBAcGFyYW0ge09iamVjdH0gZWRnZVxuICAgKi9cbiAgZnVuY3Rpb24gYWRkRWRnZShncmFwaCwgZWRnZSkge1xuICAgIGlmICghZ3JhcGguZWRnZXMpIHtcbiAgICAgIGdyYXBoLmVkZ2VzID0gW107XG4gICAgfVxuICAgIGdyYXBoLmVkZ2VzLnB1c2goZWRnZSk7XG4gICAgaWYgKGdyYXBoLmVkZ2UpIHtcbiAgICAgIHZhciBhdHRyID0gbWVyZ2Uoe30sIGdyYXBoLmVkZ2UpOyAvLyBjbG9uZSBkZWZhdWx0IGF0dHJpYnV0ZXNcbiAgICAgIGVkZ2UuYXR0ciA9IG1lcmdlKGF0dHIsIGVkZ2UuYXR0cik7IC8vIG1lcmdlIGF0dHJpYnV0ZXNcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGVkZ2UgdG8gYSBncmFwaCBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGdyYXBoXG4gICAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyIHwgT2JqZWN0fSBmcm9tXG4gICAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyIHwgT2JqZWN0fSB0b1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge09iamVjdCB8IG51bGx9IGF0dHJcbiAgICogQHJldHVybiB7T2JqZWN0fSBlZGdlXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVFZGdlKGdyYXBoLCBmcm9tLCB0bywgdHlwZSwgYXR0cikge1xuICAgIHZhciBlZGdlID0ge1xuICAgICAgZnJvbTogZnJvbSxcbiAgICAgIHRvOiB0byxcbiAgICAgIHR5cGU6IHR5cGVcbiAgICB9O1xuXG4gICAgaWYgKGdyYXBoLmVkZ2UpIHtcbiAgICAgIGVkZ2UuYXR0ciA9IG1lcmdlKHt9LCBncmFwaC5lZGdlKTsgLy8gY2xvbmUgZGVmYXVsdCBhdHRyaWJ1dGVzXG4gICAgfVxuICAgIGVkZ2UuYXR0ciA9IG1lcmdlKGVkZ2UuYXR0ciB8fCB7fSwgYXR0cik7IC8vIG1lcmdlIGF0dHJpYnV0ZXNcblxuICAgIHJldHVybiBlZGdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBuZXh0IHRva2VuIGluIHRoZSBjdXJyZW50IGRvdCBmaWxlLlxuICAgKiBUaGUgdG9rZW4gYW5kIHRva2VuIHR5cGUgYXJlIGF2YWlsYWJsZSBhcyB0b2tlbiBhbmQgdG9rZW5UeXBlXG4gICAqL1xuICBmdW5jdGlvbiBnZXRUb2tlbigpIHtcbiAgICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuTlVMTDtcbiAgICB0b2tlbiA9ICcnO1xuXG4gICAgLy8gc2tpcCBvdmVyIHdoaXRlc3BhY2VzXG4gICAgd2hpbGUgKGMgPT09ICcgJyB8fCBjID09PSAnXFx0JyB8fCBjID09PSAnXFxuJyB8fCBjID09PSAnXFxyJykge1xuICAgICAgLy8gc3BhY2UsIHRhYiwgZW50ZXJcbiAgICAgIG5leHQoKTtcbiAgICB9XG5cbiAgICBkbyB7XG4gICAgICB2YXIgaXNDb21tZW50ID0gZmFsc2U7XG5cbiAgICAgIC8vIHNraXAgY29tbWVudFxuICAgICAgaWYgKGMgPT09ICcjJykge1xuICAgICAgICAvLyBmaW5kIHRoZSBwcmV2aW91cyBub24tc3BhY2UgY2hhcmFjdGVyXG4gICAgICAgIHZhciBpID0gaW5kZXggLSAxO1xuICAgICAgICB3aGlsZSAoZG90LmNoYXJBdChpKSA9PT0gJyAnIHx8IGRvdC5jaGFyQXQoaSkgPT09ICdcXHQnKSB7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb3QuY2hhckF0KGkpID09PSAnXFxuJyB8fCBkb3QuY2hhckF0KGkpID09PSAnJykge1xuICAgICAgICAgIC8vIHRoZSAjIGlzIGF0IHRoZSBzdGFydCBvZiBhIGxpbmUsIHRoaXMgaXMgaW5kZWVkIGEgbGluZSBjb21tZW50XG4gICAgICAgICAgd2hpbGUgKGMgIT0gJycgJiYgYyAhPSAnXFxuJykge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc0NvbW1lbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gJy8nICYmIG5leHRQcmV2aWV3KCkgPT09ICcvJykge1xuICAgICAgICAvLyBza2lwIGxpbmUgY29tbWVudFxuICAgICAgICB3aGlsZSAoYyAhPSAnJyAmJiBjICE9ICdcXG4nKSB7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlzQ29tbWVudCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gJy8nICYmIG5leHRQcmV2aWV3KCkgPT09ICcqJykge1xuICAgICAgICAvLyBza2lwIGJsb2NrIGNvbW1lbnRcbiAgICAgICAgd2hpbGUgKGMgIT0gJycpIHtcbiAgICAgICAgICBpZiAoYyA9PT0gJyonICYmIG5leHRQcmV2aWV3KCkgPT09ICcvJykge1xuICAgICAgICAgICAgLy8gZW5kIG9mIGJsb2NrIGNvbW1lbnQgZm91bmQuIHNraXAgdGhlc2UgbGFzdCB0d28gY2hhcmFjdGVyc1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXNDb21tZW50ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gc2tpcCBvdmVyIHdoaXRlc3BhY2VzXG4gICAgICB3aGlsZSAoYyA9PT0gJyAnIHx8IGMgPT09ICdcXHQnIHx8IGMgPT09ICdcXG4nIHx8IGMgPT09ICdcXHInKSB7XG4gICAgICAgIC8vIHNwYWNlLCB0YWIsIGVudGVyXG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChpc0NvbW1lbnQpO1xuXG4gICAgLy8gY2hlY2sgZm9yIGVuZCBvZiBkb3QgZmlsZVxuICAgIGlmIChjID09PSAnJykge1xuICAgICAgLy8gdG9rZW4gaXMgc3RpbGwgZW1wdHlcbiAgICAgIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5ERUxJTUlURVI7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIGRlbGltaXRlcnMgY29uc2lzdGluZyBvZiAyIGNoYXJhY3RlcnNcbiAgICB2YXIgYzIgPSBjICsgbmV4dFByZXZpZXcoKTtcbiAgICBpZiAoREVMSU1JVEVSU1tjMl0pIHtcbiAgICAgIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5ERUxJTUlURVI7XG4gICAgICB0b2tlbiA9IGMyO1xuICAgICAgbmV4dCgpO1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciBkZWxpbWl0ZXJzIGNvbnNpc3Rpbmcgb2YgMSBjaGFyYWN0ZXJcbiAgICBpZiAoREVMSU1JVEVSU1tjXSkge1xuICAgICAgdG9rZW5UeXBlID0gVE9LRU5UWVBFLkRFTElNSVRFUjtcbiAgICAgIHRva2VuID0gYztcbiAgICAgIG5leHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgYW4gaWRlbnRpZmllciAobnVtYmVyIG9yIHN0cmluZylcbiAgICAvLyBUT0RPOiBtb3JlIHByZWNpc2UgcGFyc2luZyBvZiBudW1iZXJzL3N0cmluZ3MgKGFuZCB0aGUgcG9ydCBzZXBhcmF0b3IgJzonKVxuICAgIGlmIChpc0FscGhhTnVtZXJpYyhjKSB8fCBjID09PSAnLScpIHtcbiAgICAgIHRva2VuICs9IGM7XG4gICAgICBuZXh0KCk7XG5cbiAgICAgIHdoaWxlIChpc0FscGhhTnVtZXJpYyhjKSkge1xuICAgICAgICB0b2tlbiArPSBjO1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4gPT09ICdmYWxzZScpIHtcbiAgICAgICAgdG9rZW4gPSBmYWxzZTsgLy8gY29udmVydCB0byBib29sZWFuXG4gICAgICB9IGVsc2UgaWYgKHRva2VuID09PSAndHJ1ZScpIHtcbiAgICAgICAgdG9rZW4gPSB0cnVlOyAvLyBjb252ZXJ0IHRvIGJvb2xlYW5cbiAgICAgIH0gZWxzZSBpZiAoIWlzTmFOKE51bWJlcih0b2tlbikpKSB7XG4gICAgICAgIHRva2VuID0gTnVtYmVyKHRva2VuKTsgLy8gY29udmVydCB0byBudW1iZXJcbiAgICAgIH1cbiAgICAgIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5JREVOVElGSUVSO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciBhIHN0cmluZyBlbmNsb3NlZCBieSBkb3VibGUgcXVvdGVzXG4gICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgIG5leHQoKTtcbiAgICAgIHdoaWxlIChjICE9ICcnICYmIChjICE9ICdcIicgfHwgYyA9PT0gJ1wiJyAmJiBuZXh0UHJldmlldygpID09PSAnXCInKSkge1xuICAgICAgICB0b2tlbiArPSBjO1xuICAgICAgICBpZiAoYyA9PT0gJ1wiJykge1xuICAgICAgICAgIC8vIHNraXAgdGhlIGVzY2FwZSBjaGFyYWN0ZXJcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuICAgICAgaWYgKGMgIT0gJ1wiJykge1xuICAgICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignRW5kIG9mIHN0cmluZyBcIiBleHBlY3RlZCcpO1xuICAgICAgfVxuICAgICAgbmV4dCgpO1xuICAgICAgdG9rZW5UeXBlID0gVE9LRU5UWVBFLklERU5USUZJRVI7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc29tZXRoaW5nIHVua25vd24gaXMgZm91bmQsIHdyb25nIGNoYXJhY3RlcnMsIGEgc3ludGF4IGVycm9yXG4gICAgdG9rZW5UeXBlID0gVE9LRU5UWVBFLlVOS05PV047XG4gICAgd2hpbGUgKGMgIT0gJycpIHtcbiAgICAgIHRva2VuICs9IGM7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignU3ludGF4IGVycm9yIGluIHBhcnQgXCInICsgY2hvcCh0b2tlbiwgMzApICsgJ1wiJyk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSBncmFwaC5cbiAgICogQHJldHVybnMge09iamVjdH0gZ3JhcGhcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlR3JhcGgoKSB7XG4gICAgdmFyIGdyYXBoID0ge307XG5cbiAgICBmaXJzdCgpO1xuICAgIGdldFRva2VuKCk7XG5cbiAgICAvLyBvcHRpb25hbCBzdHJpY3Qga2V5d29yZFxuICAgIGlmICh0b2tlbiA9PT0gJ3N0cmljdCcpIHtcbiAgICAgIGdyYXBoLnN0cmljdCA9IHRydWU7XG4gICAgICBnZXRUb2tlbigpO1xuICAgIH1cblxuICAgIC8vIGdyYXBoIG9yIGRpZ3JhcGgga2V5d29yZFxuICAgIGlmICh0b2tlbiA9PT0gJ2dyYXBoJyB8fCB0b2tlbiA9PT0gJ2RpZ3JhcGgnKSB7XG4gICAgICBncmFwaC50eXBlID0gdG9rZW47XG4gICAgICBnZXRUb2tlbigpO1xuICAgIH1cblxuICAgIC8vIG9wdGlvbmFsIGdyYXBoIGlkXG4gICAgaWYgKHRva2VuVHlwZSA9PT0gVE9LRU5UWVBFLklERU5USUZJRVIpIHtcbiAgICAgIGdyYXBoLmlkID0gdG9rZW47XG4gICAgICBnZXRUb2tlbigpO1xuICAgIH1cblxuICAgIC8vIG9wZW4gYW5nbGUgYnJhY2tldFxuICAgIGlmICh0b2tlbiAhPSAneycpIHtcbiAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdBbmdsZSBicmFja2V0IHsgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgZ2V0VG9rZW4oKTtcblxuICAgIC8vIHN0YXRlbWVudHNcbiAgICBwYXJzZVN0YXRlbWVudHMoZ3JhcGgpO1xuXG4gICAgLy8gY2xvc2UgYW5nbGUgYnJhY2tldFxuICAgIGlmICh0b2tlbiAhPSAnfScpIHtcbiAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdBbmdsZSBicmFja2V0IH0gZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgZ2V0VG9rZW4oKTtcblxuICAgIC8vIGVuZCBvZiBmaWxlXG4gICAgaWYgKHRva2VuICE9PSAnJykge1xuICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0VuZCBvZiBmaWxlIGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIGdldFRva2VuKCk7XG5cbiAgICAvLyByZW1vdmUgdGVtcG9yYXJ5IGRlZmF1bHQgb3B0aW9uc1xuICAgIGRlbGV0ZSBncmFwaC5ub2RlO1xuICAgIGRlbGV0ZSBncmFwaC5lZGdlO1xuICAgIGRlbGV0ZSBncmFwaC5ncmFwaDtcblxuICAgIHJldHVybiBncmFwaDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIGxpc3Qgd2l0aCBzdGF0ZW1lbnRzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50cyhncmFwaCkge1xuICAgIHdoaWxlICh0b2tlbiAhPT0gJycgJiYgdG9rZW4gIT0gJ30nKSB7XG4gICAgICBwYXJzZVN0YXRlbWVudChncmFwaCk7XG4gICAgICBpZiAodG9rZW4gPT09ICc7Jykge1xuICAgICAgICBnZXRUb2tlbigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHNpbmdsZSBzdGF0ZW1lbnQuIENhbiBiZSBhIGFuIGF0dHJpYnV0ZSBzdGF0ZW1lbnQsIG5vZGVcbiAgICogc3RhdGVtZW50LCBhIHNlcmllcyBvZiBub2RlIHN0YXRlbWVudHMgYW5kIGVkZ2Ugc3RhdGVtZW50cywgb3IgYVxuICAgKiBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBncmFwaFxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VTdGF0ZW1lbnQoZ3JhcGgpIHtcbiAgICAvLyBwYXJzZSBzdWJncmFwaFxuICAgIHZhciBzdWJncmFwaCA9IHBhcnNlU3ViZ3JhcGgoZ3JhcGgpO1xuICAgIGlmIChzdWJncmFwaCkge1xuICAgICAgLy8gZWRnZSBzdGF0ZW1lbnRzXG4gICAgICBwYXJzZUVkZ2UoZ3JhcGgsIHN1YmdyYXBoKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHBhcnNlIGFuIGF0dHJpYnV0ZSBzdGF0ZW1lbnRcbiAgICB2YXIgYXR0ciA9IHBhcnNlQXR0cmlidXRlU3RhdGVtZW50KGdyYXBoKTtcbiAgICBpZiAoYXR0cikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHBhcnNlIG5vZGVcbiAgICBpZiAodG9rZW5UeXBlICE9IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignSWRlbnRpZmllciBleHBlY3RlZCcpO1xuICAgIH1cbiAgICB2YXIgaWQgPSB0b2tlbjsgLy8gaWQgY2FuIGJlIGEgc3RyaW5nIG9yIGEgbnVtYmVyXG4gICAgZ2V0VG9rZW4oKTtcblxuICAgIGlmICh0b2tlbiA9PT0gJz0nKSB7XG4gICAgICAvLyBpZCBzdGF0ZW1lbnRcbiAgICAgIGdldFRva2VuKCk7XG4gICAgICBpZiAodG9rZW5UeXBlICE9IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdJZGVudGlmaWVyIGV4cGVjdGVkJyk7XG4gICAgICB9XG4gICAgICBncmFwaFtpZF0gPSB0b2tlbjtcbiAgICAgIGdldFRva2VuKCk7XG4gICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgY29tbWEgc2VwYXJhdGVkIGxpc3Qgd2l0aCBcImFfbGlzdDogSUQ9SUQgWycsJ10gW2FfbGlzdF0gXCJcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VOb2RlU3RhdGVtZW50KGdyYXBoLCBpZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgc3ViZ3JhcGhcbiAgICogQHBhcmFtIHtPYmplY3R9IGdyYXBoICAgIHBhcmVudCBncmFwaCBvYmplY3RcbiAgICogQHJldHVybiB7T2JqZWN0IHwgbnVsbH0gc3ViZ3JhcGhcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlU3ViZ3JhcGgoZ3JhcGgpIHtcbiAgICB2YXIgc3ViZ3JhcGggPSBudWxsO1xuXG4gICAgLy8gb3B0aW9uYWwgc3ViZ3JhcGgga2V5d29yZFxuICAgIGlmICh0b2tlbiA9PT0gJ3N1YmdyYXBoJykge1xuICAgICAgc3ViZ3JhcGggPSB7fTtcbiAgICAgIHN1YmdyYXBoLnR5cGUgPSAnc3ViZ3JhcGgnO1xuICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgLy8gb3B0aW9uYWwgZ3JhcGggaWRcbiAgICAgIGlmICh0b2tlblR5cGUgPT09IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgICAgIHN1YmdyYXBoLmlkID0gdG9rZW47XG4gICAgICAgIGdldFRva2VuKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gb3BlbiBhbmdsZSBicmFja2V0XG4gICAgaWYgKHRva2VuID09PSAneycpIHtcbiAgICAgIGdldFRva2VuKCk7XG5cbiAgICAgIGlmICghc3ViZ3JhcGgpIHtcbiAgICAgICAgc3ViZ3JhcGggPSB7fTtcbiAgICAgIH1cbiAgICAgIHN1YmdyYXBoLnBhcmVudCA9IGdyYXBoO1xuICAgICAgc3ViZ3JhcGgubm9kZSA9IGdyYXBoLm5vZGU7XG4gICAgICBzdWJncmFwaC5lZGdlID0gZ3JhcGguZWRnZTtcbiAgICAgIHN1YmdyYXBoLmdyYXBoID0gZ3JhcGguZ3JhcGg7XG5cbiAgICAgIC8vIHN0YXRlbWVudHNcbiAgICAgIHBhcnNlU3RhdGVtZW50cyhzdWJncmFwaCk7XG5cbiAgICAgIC8vIGNsb3NlIGFuZ2xlIGJyYWNrZXRcbiAgICAgIGlmICh0b2tlbiAhPSAnfScpIHtcbiAgICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0FuZ2xlIGJyYWNrZXQgfSBleHBlY3RlZCcpO1xuICAgICAgfVxuICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgLy8gcmVtb3ZlIHRlbXBvcmFyeSBkZWZhdWx0IG9wdGlvbnNcbiAgICAgIGRlbGV0ZSBzdWJncmFwaC5ub2RlO1xuICAgICAgZGVsZXRlIHN1YmdyYXBoLmVkZ2U7XG4gICAgICBkZWxldGUgc3ViZ3JhcGguZ3JhcGg7XG4gICAgICBkZWxldGUgc3ViZ3JhcGgucGFyZW50O1xuXG4gICAgICAvLyByZWdpc3RlciBhdCB0aGUgcGFyZW50IGdyYXBoXG4gICAgICBpZiAoIWdyYXBoLnN1YmdyYXBocykge1xuICAgICAgICBncmFwaC5zdWJncmFwaHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGdyYXBoLnN1YmdyYXBocy5wdXNoKHN1YmdyYXBoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3ViZ3JhcGg7XG4gIH1cblxuICAvKipcbiAgICogcGFyc2UgYW4gYXR0cmlidXRlIHN0YXRlbWVudCBsaWtlIFwibm9kZSBbc2hhcGU9Y2lyY2xlIGZvbnRTaXplPTE2XVwiLlxuICAgKiBBdmFpbGFibGUga2V5d29yZHMgYXJlICdub2RlJywgJ2VkZ2UnLCAnZ3JhcGgnLlxuICAgKiBUaGUgcHJldmlvdXMgbGlzdCB3aXRoIGRlZmF1bHQgYXR0cmlidXRlcyB3aWxsIGJlIHJlcGxhY2VkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBncmFwaFxuICAgKiBAcmV0dXJucyB7U3RyaW5nIHwgbnVsbH0ga2V5d29yZCBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBwYXJzZWQgYXR0cmlidXRlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChub2RlLCBlZGdlLCBncmFwaCksIG9yIG51bGwgaWYgbm90aGluZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBwYXJzZWQuXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZVN0YXRlbWVudChncmFwaCkge1xuICAgIC8vIGF0dHJpYnV0ZSBzdGF0ZW1lbnRzXG4gICAgaWYgKHRva2VuID09PSAnbm9kZScpIHtcbiAgICAgIGdldFRva2VuKCk7XG5cbiAgICAgIC8vIG5vZGUgYXR0cmlidXRlc1xuICAgICAgZ3JhcGgubm9kZSA9IHBhcnNlQXR0cmlidXRlTGlzdCgpO1xuICAgICAgcmV0dXJuICdub2RlJztcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnZWRnZScpIHtcbiAgICAgIGdldFRva2VuKCk7XG5cbiAgICAgIC8vIGVkZ2UgYXR0cmlidXRlc1xuICAgICAgZ3JhcGguZWRnZSA9IHBhcnNlQXR0cmlidXRlTGlzdCgpO1xuICAgICAgcmV0dXJuICdlZGdlJztcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnZ3JhcGgnKSB7XG4gICAgICBnZXRUb2tlbigpO1xuXG4gICAgICAvLyBncmFwaCBhdHRyaWJ1dGVzXG4gICAgICBncmFwaC5ncmFwaCA9IHBhcnNlQXR0cmlidXRlTGlzdCgpO1xuICAgICAgcmV0dXJuICdncmFwaCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogcGFyc2UgYSBub2RlIHN0YXRlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhcbiAgICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IGlkXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZU5vZGVTdGF0ZW1lbnQoZ3JhcGgsIGlkKSB7XG4gICAgLy8gbm9kZSBzdGF0ZW1lbnRcbiAgICB2YXIgbm9kZSA9IHtcbiAgICAgIGlkOiBpZFxuICAgIH07XG4gICAgdmFyIGF0dHIgPSBwYXJzZUF0dHJpYnV0ZUxpc3QoKTtcbiAgICBpZiAoYXR0cikge1xuICAgICAgbm9kZS5hdHRyID0gYXR0cjtcbiAgICB9XG4gICAgYWRkTm9kZShncmFwaCwgbm9kZSk7XG5cbiAgICAvLyBlZGdlIHN0YXRlbWVudHNcbiAgICBwYXJzZUVkZ2UoZ3JhcGgsIGlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhbiBlZGdlIG9yIGEgc2VyaWVzIG9mIGVkZ2VzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBncmFwaFxuICAgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gZnJvbSAgICAgICAgSWQgb2YgdGhlIGZyb20gbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VFZGdlKGdyYXBoLCBmcm9tKSB7XG4gICAgd2hpbGUgKHRva2VuID09PSAnLT4nIHx8IHRva2VuID09PSAnLS0nKSB7XG4gICAgICB2YXIgdG87XG4gICAgICB2YXIgdHlwZSA9IHRva2VuO1xuICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgdmFyIHN1YmdyYXBoID0gcGFyc2VTdWJncmFwaChncmFwaCk7XG4gICAgICBpZiAoc3ViZ3JhcGgpIHtcbiAgICAgICAgdG8gPSBzdWJncmFwaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0b2tlblR5cGUgIT0gVE9LRU5UWVBFLklERU5USUZJRVIpIHtcbiAgICAgICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignSWRlbnRpZmllciBvciBzdWJncmFwaCBleHBlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRvID0gdG9rZW47XG4gICAgICAgIGFkZE5vZGUoZ3JhcGgsIHtcbiAgICAgICAgICBpZDogdG9cbiAgICAgICAgfSk7XG4gICAgICAgIGdldFRva2VuKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHBhcnNlIGVkZ2UgYXR0cmlidXRlc1xuICAgICAgdmFyIGF0dHIgPSBwYXJzZUF0dHJpYnV0ZUxpc3QoKTtcblxuICAgICAgLy8gY3JlYXRlIGVkZ2VcbiAgICAgIHZhciBlZGdlID0gY3JlYXRlRWRnZShncmFwaCwgZnJvbSwgdG8sIHR5cGUsIGF0dHIpO1xuICAgICAgYWRkRWRnZShncmFwaCwgZWRnZSk7XG5cbiAgICAgIGZyb20gPSB0bztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSBzZXQgd2l0aCBhdHRyaWJ1dGVzLFxuICAgKiBmb3IgZXhhbXBsZSBbbGFiZWw9XCIxLjAwMFwiLCBzaGFwZT1zb2xpZF1cbiAgICogQHJldHVybiB7T2JqZWN0IHwgbnVsbH0gYXR0clxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVMaXN0KCkge1xuICAgIHZhciBhdHRyID0gbnVsbDtcblxuICAgIHdoaWxlICh0b2tlbiA9PT0gJ1snKSB7XG4gICAgICBnZXRUb2tlbigpO1xuICAgICAgYXR0ciA9IHt9O1xuICAgICAgd2hpbGUgKHRva2VuICE9PSAnJyAmJiB0b2tlbiAhPSAnXScpIHtcbiAgICAgICAgaWYgKHRva2VuVHlwZSAhPSBUT0tFTlRZUEUuSURFTlRJRklFUikge1xuICAgICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdBdHRyaWJ1dGUgbmFtZSBleHBlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gdG9rZW47XG5cbiAgICAgICAgZ2V0VG9rZW4oKTtcbiAgICAgICAgaWYgKHRva2VuICE9ICc9Jykge1xuICAgICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdFcXVhbCBzaWduID0gZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRUb2tlbigpO1xuXG4gICAgICAgIGlmICh0b2tlblR5cGUgIT0gVE9LRU5UWVBFLklERU5USUZJRVIpIHtcbiAgICAgICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignQXR0cmlidXRlIHZhbHVlIGV4cGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gdG9rZW47XG4gICAgICAgIHNldFZhbHVlKGF0dHIsIG5hbWUsIHZhbHVlKTsgLy8gbmFtZSBjYW4gYmUgYSBwYXRoXG5cbiAgICAgICAgZ2V0VG9rZW4oKTtcbiAgICAgICAgaWYgKHRva2VuID09ICcsJykge1xuICAgICAgICAgIGdldFRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuICE9ICddJykge1xuICAgICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignQnJhY2tldCBdIGV4cGVjdGVkJyk7XG4gICAgICB9XG4gICAgICBnZXRUb2tlbigpO1xuICAgIH1cblxuICAgIHJldHVybiBhdHRyO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHN5bnRheCBlcnJvciB3aXRoIGV4dHJhIGluZm9ybWF0aW9uIG9uIGN1cnJlbnQgdG9rZW4gYW5kIGluZGV4LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAcmV0dXJucyB7U3ludGF4RXJyb3J9IGVyclxuICAgKi9cbiAgZnVuY3Rpb24gbmV3U3ludGF4RXJyb3IobWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSArICcsIGdvdCBcIicgKyBjaG9wKHRva2VuLCAzMCkgKyAnXCIgKGNoYXIgJyArIGluZGV4ICsgJyknKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaG9wIG9mZiB0ZXh0IGFmdGVyIGEgbWF4aW11bSBsZW5ndGhcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1heExlbmd0aFxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24gY2hvcCh0ZXh0LCBtYXhMZW5ndGgpIHtcbiAgICByZXR1cm4gdGV4dC5sZW5ndGggPD0gbWF4TGVuZ3RoID8gdGV4dCA6IHRleHQuc3Vic3RyKDAsIDI3KSArICcuLi4nO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBmdW5jdGlvbiBmbiBmb3IgZWFjaCBwYWlyIG9mIGVsZW1lbnRzIGluIHR3byBhcnJheXNcbiAgICogQHBhcmFtIHtBcnJheSB8ICp9IGFycmF5MVxuICAgKiBAcGFyYW0ge0FycmF5IHwgKn0gYXJyYXkyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG4gICAqL1xuICBmdW5jdGlvbiBmb3JFYWNoMihhcnJheTEsIGFycmF5MiwgZm4pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheTEpKSB7XG4gICAgICBhcnJheTEuZm9yRWFjaChmdW5jdGlvbiAoZWxlbTEpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXkyKSkge1xuICAgICAgICAgIGFycmF5Mi5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtMikge1xuICAgICAgICAgICAgZm4oZWxlbTEsIGVsZW0yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbihlbGVtMSwgYXJyYXkyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5MikpIHtcbiAgICAgICAgYXJyYXkyLmZvckVhY2goZnVuY3Rpb24gKGVsZW0yKSB7XG4gICAgICAgICAgZm4oYXJyYXkxLCBlbGVtMik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4oYXJyYXkxLCBhcnJheTIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBuZXN0ZWQgcHJvcGVydHkgb24gYW4gb2JqZWN0XG4gICAqIFdoZW4gbmVzdGVkIG9iamVjdHMgYXJlIG1pc3NpbmcsIHRoZXkgd2lsbCBiZSBjcmVhdGVkLlxuICAgKiBGb3IgZXhhbXBsZSBzZXRQcm9wKHt9LCAnZm9udC5jb2xvcicsICdyZWQnKSB3aWxsIHJldHVybiB7Zm9udDoge2NvbG9yOiAncmVkJ319XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggICBBIGRvdCBzZXBhcmF0ZWQgc3RyaW5nIGxpa2UgJ2ZvbnQuY29sb3InXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgICAgICAgVmFsdWUgZm9yIHRoZSBwcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIG9yaWdpbmFsIG9iamVjdCwgYWxsb3dzIGZvciBjaGFpbmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIHNldFByb3Aob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICAgIHZhciBuYW1lcyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICB2YXIgcHJvcCA9IG5hbWVzLnBvcCgpO1xuXG4gICAgLy8gdHJhdmVyc2Ugb3ZlciB0aGUgbmVzdGVkIG9iamVjdHNcbiAgICB2YXIgb2JqID0gb2JqZWN0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICBpZiAoIShuYW1lIGluIG9iaikpIHtcbiAgICAgICAgb2JqW25hbWVdID0ge307XG4gICAgICB9XG4gICAgICBvYmogPSBvYmpbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gc2V0IHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICAgIG9ialtwcm9wXSA9IHZhbHVlO1xuXG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGFuIG9iamVjdCB3aXRoIERPVCBhdHRyaWJ1dGVzIHRvIHRoZWlyIHZpcy5qcyBlcXVpdmFsZW50cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHIgICAgIE9iamVjdCB3aXRoIERPVCBhdHRyaWJ1dGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXBwaW5nXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHZpcy5qcyBhdHRyaWJ1dGVzXG4gICAqL1xuICBmdW5jdGlvbiBjb252ZXJ0QXR0cihhdHRyLCBtYXBwaW5nKSB7XG4gICAgdmFyIGNvbnZlcnRlZCA9IHt9O1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBhdHRyKSB7XG4gICAgICBpZiAoYXR0ci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICB2YXIgdmlzUHJvcCA9IG1hcHBpbmdbcHJvcF07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZpc1Byb3ApKSB7XG4gICAgICAgICAgdmlzUHJvcC5mb3JFYWNoKGZ1bmN0aW9uICh2aXNQcm9wSSkge1xuICAgICAgICAgICAgc2V0UHJvcChjb252ZXJ0ZWQsIHZpc1Byb3BJLCBhdHRyW3Byb3BdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmlzUHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBzZXRQcm9wKGNvbnZlcnRlZCwgdmlzUHJvcCwgYXR0cltwcm9wXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0UHJvcChjb252ZXJ0ZWQsIHByb3AsIGF0dHJbcHJvcF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnZlcnRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgc3RyaW5nIGNvbnRhaW5pbmcgYSBncmFwaCBpbiBET1QgbGFuZ3VhZ2UgaW50byBhIG1hcCBjb250YWluaW5nXG4gICAqIHdpdGggbm9kZXMgYW5kIGVkZ2VzIGluIHRoZSBmb3JtYXQgb2YgZ3JhcGguXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhICAgICAgICAgVGV4dCBjb250YWluaW5nIGEgZ3JhcGggaW4gRE9ULW5vdGF0aW9uXG4gICAqIEByZXR1cm4ge09iamVjdH0gZ3JhcGhEYXRhXG4gICAqL1xuICBmdW5jdGlvbiBET1RUb0dyYXBoKGRhdGEpIHtcbiAgICAvLyBwYXJzZSB0aGUgRE9UIGZpbGVcbiAgICB2YXIgZG90RGF0YSA9IHBhcnNlRE9UKGRhdGEpO1xuICAgIHZhciBncmFwaERhdGEgPSB7XG4gICAgICBub2RlczogW10sXG4gICAgICBlZGdlczogW10sXG4gICAgICBvcHRpb25zOiB7fVxuICAgIH07XG5cbiAgICAvLyBjb3B5IHRoZSBub2Rlc1xuICAgIGlmIChkb3REYXRhLm5vZGVzKSB7XG4gICAgICBkb3REYXRhLm5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGRvdE5vZGUpIHtcbiAgICAgICAgdmFyIGdyYXBoTm9kZSA9IHtcbiAgICAgICAgICBpZDogZG90Tm9kZS5pZCxcbiAgICAgICAgICBsYWJlbDogU3RyaW5nKGRvdE5vZGUubGFiZWwgfHwgZG90Tm9kZS5pZClcbiAgICAgICAgfTtcbiAgICAgICAgbWVyZ2UoZ3JhcGhOb2RlLCBjb252ZXJ0QXR0cihkb3ROb2RlLmF0dHIsIE5PREVfQVRUUl9NQVBQSU5HKSk7XG4gICAgICAgIGlmIChncmFwaE5vZGUuaW1hZ2UpIHtcbiAgICAgICAgICBncmFwaE5vZGUuc2hhcGUgPSAnaW1hZ2UnO1xuICAgICAgICB9XG4gICAgICAgIGdyYXBoRGF0YS5ub2Rlcy5wdXNoKGdyYXBoTm9kZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBjb3B5IHRoZSBlZGdlc1xuICAgIGlmIChkb3REYXRhLmVkZ2VzKSB7XG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnQgYW4gZWRnZSBpbiBET1QgZm9ybWF0IHRvIGFuIGVkZ2Ugd2l0aCBWaXNHcmFwaCBmb3JtYXRcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkb3RFZGdlXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBncmFwaEVkZ2VcbiAgICAgICAqL1xuICAgICAgdmFyIGNvbnZlcnRFZGdlID0gZnVuY3Rpb24gY29udmVydEVkZ2UoZG90RWRnZSkge1xuICAgICAgICB2YXIgZ3JhcGhFZGdlID0ge1xuICAgICAgICAgIGZyb206IGRvdEVkZ2UuZnJvbSxcbiAgICAgICAgICB0bzogZG90RWRnZS50b1xuICAgICAgICB9O1xuICAgICAgICBtZXJnZShncmFwaEVkZ2UsIGNvbnZlcnRBdHRyKGRvdEVkZ2UuYXR0ciwgRURHRV9BVFRSX01BUFBJTkcpKTtcbiAgICAgICAgZ3JhcGhFZGdlLmFycm93cyA9IGRvdEVkZ2UudHlwZSA9PT0gJy0+JyA/ICd0bycgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgcmV0dXJuIGdyYXBoRWRnZTtcbiAgICAgIH07XG5cbiAgICAgIGRvdERhdGEuZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZG90RWRnZSkge1xuICAgICAgICB2YXIgZnJvbSwgdG87XG4gICAgICAgIGlmIChkb3RFZGdlLmZyb20gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICBmcm9tID0gZG90RWRnZS5mcm9tLm5vZGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyb20gPSB7XG4gICAgICAgICAgICBpZDogZG90RWRnZS5mcm9tXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgb2Ygc29saWQvZG90dGVkL2Rhc2hlZCBlZGdlcyAoYXR0ciA9ICdzdHlsZScpXG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgZm9yIGF0dHJpYnV0ZXMgJ2RpcicgYW5kICdhcnJvd2hlYWQnIChlZGdlIGFycm93cylcblxuICAgICAgICBpZiAoZG90RWRnZS50byBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgIHRvID0gZG90RWRnZS50by5ub2RlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0byA9IHtcbiAgICAgICAgICAgIGlkOiBkb3RFZGdlLnRvXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb3RFZGdlLmZyb20gaW5zdGFuY2VvZiBPYmplY3QgJiYgZG90RWRnZS5mcm9tLmVkZ2VzKSB7XG4gICAgICAgICAgZG90RWRnZS5mcm9tLmVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKHN1YkVkZ2UpIHtcbiAgICAgICAgICAgIHZhciBncmFwaEVkZ2UgPSBjb252ZXJ0RWRnZShzdWJFZGdlKTtcbiAgICAgICAgICAgIGdyYXBoRGF0YS5lZGdlcy5wdXNoKGdyYXBoRWRnZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JFYWNoMihmcm9tLCB0bywgZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICAgICAgdmFyIHN1YkVkZ2UgPSBjcmVhdGVFZGdlKGdyYXBoRGF0YSwgZnJvbS5pZCwgdG8uaWQsIGRvdEVkZ2UudHlwZSwgZG90RWRnZS5hdHRyKTtcbiAgICAgICAgICB2YXIgZ3JhcGhFZGdlID0gY29udmVydEVkZ2Uoc3ViRWRnZSk7XG4gICAgICAgICAgZ3JhcGhEYXRhLmVkZ2VzLnB1c2goZ3JhcGhFZGdlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGRvdEVkZ2UudG8gaW5zdGFuY2VvZiBPYmplY3QgJiYgZG90RWRnZS50by5lZGdlcykge1xuICAgICAgICAgIGRvdEVkZ2UudG8uZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoc3ViRWRnZSkge1xuICAgICAgICAgICAgdmFyIGdyYXBoRWRnZSA9IGNvbnZlcnRFZGdlKHN1YkVkZ2UpO1xuICAgICAgICAgICAgZ3JhcGhEYXRhLmVkZ2VzLnB1c2goZ3JhcGhFZGdlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gY29weSB0aGUgb3B0aW9uc1xuICAgIGlmIChkb3REYXRhLmF0dHIpIHtcbiAgICAgIGdyYXBoRGF0YS5vcHRpb25zID0gZG90RGF0YS5hdHRyO1xuICAgIH1cblxuICAgIHJldHVybiBncmFwaERhdGE7XG4gIH1cblxuICAvLyBleHBvcnRzXG4gIGV4cG9ydHMucGFyc2VET1QgPSBwYXJzZURPVDtcbiAgZXhwb3J0cy5ET1RUb0dyYXBoID0gRE9UVG9HcmFwaDtcblxuLyoqKi8gfSxcbi8qIDEyMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIHBhcnNlR2VwaGkoZ2VwaGlKU09OLCBvcHRpb25zT2JqKSB7XG4gICAgdmFyIGVkZ2VzID0gW107XG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBlZGdlczoge1xuICAgICAgICBpbmhlcml0Q29sb3I6IGZhbHNlXG4gICAgICB9LFxuICAgICAgbm9kZXM6IHtcbiAgICAgICAgZml4ZWQ6IGZhbHNlLFxuICAgICAgICBwYXJzZUNvbG9yOiBmYWxzZVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAob3B0aW9uc09iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAob3B0aW9uc09iai5maXhlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMubm9kZXMuZml4ZWQgPSBvcHRpb25zT2JqLmZpeGVkO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnNPYmoucGFyc2VDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMubm9kZXMucGFyc2VDb2xvciA9IG9wdGlvbnNPYmoucGFyc2VDb2xvcjtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zT2JqLmluaGVyaXRDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuZWRnZXMuaW5oZXJpdENvbG9yID0gb3B0aW9uc09iai5pbmhlcml0Q29sb3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGdFZGdlcyA9IGdlcGhpSlNPTi5lZGdlcztcbiAgICB2YXIgZ05vZGVzID0gZ2VwaGlKU09OLm5vZGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ0VkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWRnZSA9IHt9O1xuICAgICAgdmFyIGdFZGdlID0gZ0VkZ2VzW2ldO1xuICAgICAgZWRnZVsnaWQnXSA9IGdFZGdlLmlkO1xuICAgICAgZWRnZVsnZnJvbSddID0gZ0VkZ2Uuc291cmNlO1xuICAgICAgZWRnZVsndG8nXSA9IGdFZGdlLnRhcmdldDtcbiAgICAgIGVkZ2VbJ2F0dHJpYnV0ZXMnXSA9IGdFZGdlLmF0dHJpYnV0ZXM7XG4gICAgICBlZGdlWydsYWJlbCddID0gZ0VkZ2UubGFiZWw7XG4gICAgICBlZGdlWyd0aXRsZSddID0gZ0VkZ2UuYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkID8gZ0VkZ2UuYXR0cmlidXRlcy50aXRsZSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChnRWRnZVsndHlwZSddID09PSAnRGlyZWN0ZWQnKSB7XG4gICAgICAgIGVkZ2VbJ2Fycm93cyddID0gJ3RvJztcbiAgICAgIH1cbiAgICAgIC8vICAgIGVkZ2VbJ3ZhbHVlJ10gPSBnRWRnZS5hdHRyaWJ1dGVzICE9PSB1bmRlZmluZWQgPyBnRWRnZS5hdHRyaWJ1dGVzLldlaWdodCA6IHVuZGVmaW5lZDtcbiAgICAgIC8vICAgIGVkZ2VbJ3dpZHRoJ10gPSBlZGdlWyd2YWx1ZSddICE9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBlZGdlZ0VkZ2Uuc2l6ZTtcbiAgICAgIGlmIChnRWRnZS5jb2xvciAmJiBvcHRpb25zLmluaGVyaXRDb2xvciA9PT0gZmFsc2UpIHtcbiAgICAgICAgZWRnZVsnY29sb3InXSA9IGdFZGdlLmNvbG9yO1xuICAgICAgfVxuICAgICAgZWRnZXMucHVzaChlZGdlKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSB7fTtcbiAgICAgIHZhciBnTm9kZSA9IGdOb2Rlc1tpXTtcbiAgICAgIG5vZGVbJ2lkJ10gPSBnTm9kZS5pZDtcbiAgICAgIG5vZGVbJ2F0dHJpYnV0ZXMnXSA9IGdOb2RlLmF0dHJpYnV0ZXM7XG4gICAgICBub2RlWyd0aXRsZSddID0gZ05vZGUudGl0bGU7XG4gICAgICBub2RlWyd4J10gPSBnTm9kZS54O1xuICAgICAgbm9kZVsneSddID0gZ05vZGUueTtcbiAgICAgIG5vZGVbJ2xhYmVsJ10gPSBnTm9kZS5sYWJlbDtcbiAgICAgIG5vZGVbJ3RpdGxlJ10gPSBnTm9kZS5hdHRyaWJ1dGVzICE9PSB1bmRlZmluZWQgPyBnTm9kZS5hdHRyaWJ1dGVzLnRpdGxlIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG9wdGlvbnMubm9kZXMucGFyc2VDb2xvciA9PT0gdHJ1ZSkge1xuICAgICAgICBub2RlWydjb2xvciddID0gZ05vZGUuY29sb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlWydjb2xvciddID0gZ05vZGUuY29sb3IgIT09IHVuZGVmaW5lZCA/IHsgYmFja2dyb3VuZDogZ05vZGUuY29sb3IsIGJvcmRlcjogZ05vZGUuY29sb3IsIGhpZ2hsaWdodDogeyBiYWNrZ3JvdW5kOiBnTm9kZS5jb2xvciwgYm9yZGVyOiBnTm9kZS5jb2xvciB9LCBob3ZlcjogeyBiYWNrZ3JvdW5kOiBnTm9kZS5jb2xvciwgYm9yZGVyOiBnTm9kZS5jb2xvciB9IH0gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBub2RlWydzaXplJ10gPSBnTm9kZS5zaXplO1xuICAgICAgbm9kZVsnZml4ZWQnXSA9IG9wdGlvbnMubm9kZXMuZml4ZWQgJiYgZ05vZGUueCAhPT0gdW5kZWZpbmVkICYmIGdOb2RlLnkgIT09IHVuZGVmaW5lZDtcbiAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbm9kZXM6IG5vZGVzLCBlZGdlczogZWRnZXMgfTtcbiAgfVxuXG4gIGV4cG9ydHMucGFyc2VHZXBoaSA9IHBhcnNlR2VwaGk7XG5cbi8qKiovIH0sXG4vKiAxMjIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBFbmdsaXNoXG4gIGV4cG9ydHNbJ2VuJ10gPSB7XG4gICAgZWRpdDogJ0VkaXQnLFxuICAgIGRlbDogJ0RlbGV0ZSBzZWxlY3RlZCcsXG4gICAgYmFjazogJ0JhY2snLFxuICAgIGFkZE5vZGU6ICdBZGQgTm9kZScsXG4gICAgYWRkRWRnZTogJ0FkZCBFZGdlJyxcbiAgICBlZGl0Tm9kZTogJ0VkaXQgTm9kZScsXG4gICAgZWRpdEVkZ2U6ICdFZGl0IEVkZ2UnLFxuICAgIGFkZERlc2NyaXB0aW9uOiAnQ2xpY2sgaW4gYW4gZW1wdHkgc3BhY2UgdG8gcGxhY2UgYSBuZXcgbm9kZS4nLFxuICAgIGVkZ2VEZXNjcmlwdGlvbjogJ0NsaWNrIG9uIGEgbm9kZSBhbmQgZHJhZyB0aGUgZWRnZSB0byBhbm90aGVyIG5vZGUgdG8gY29ubmVjdCB0aGVtLicsXG4gICAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogJ0NsaWNrIG9uIHRoZSBjb250cm9sIHBvaW50cyBhbmQgZHJhZyB0aGVtIHRvIGEgbm9kZSB0byBjb25uZWN0IHRvIGl0LicsXG4gICAgY3JlYXRlRWRnZUVycm9yOiAnQ2Fubm90IGxpbmsgZWRnZXMgdG8gYSBjbHVzdGVyLicsXG4gICAgZGVsZXRlQ2x1c3RlckVycm9yOiAnQ2x1c3RlcnMgY2Fubm90IGJlIGRlbGV0ZWQuJyxcbiAgICBlZGl0Q2x1c3RlckVycm9yOiAnQ2x1c3RlcnMgY2Fubm90IGJlIGVkaXRlZC4nXG4gIH07XG4gIGV4cG9ydHNbJ2VuX0VOJ10gPSBleHBvcnRzWydlbiddO1xuICBleHBvcnRzWydlbl9VUyddID0gZXhwb3J0c1snZW4nXTtcblxuICAvLyBHZXJtYW5cbiAgZXhwb3J0c1snZGUnXSA9IHtcbiAgICBlZGl0OiAnRWRpdGllcmVuJyxcbiAgICBkZWw6ICdMXFx4RjZzY2hlIEF1c3dhaGwnLFxuICAgIGJhY2s6ICdadXJcXHhGQ2NrJyxcbiAgICBhZGROb2RlOiAnS25vdGVuIGhpbnp1ZlxceEZDZ2VuJyxcbiAgICBhZGRFZGdlOiAnS2FudGUgaGluenVmXFx4RkNnZW4nLFxuICAgIGVkaXROb2RlOiAnS25vdGVuIGVkaXRpZXJlbicsXG4gICAgZWRpdEVkZ2U6ICdLYW50ZSBlZGl0aWVyZW4nLFxuICAgIGFkZERlc2NyaXB0aW9uOiAnS2xpY2tlIGF1ZiBlaW5lIGZyZWllIFN0ZWxsZSwgdW0gZWluZW4gbmV1ZW4gS25vdGVuIHp1IHBsYXppZXJlbi4nLFxuICAgIGVkZ2VEZXNjcmlwdGlvbjogJ0tsaWNrZSBhdWYgZWluZW4gS25vdGVuIHVuZCB6aWVoZSBkaWUgS2FudGUgenUgZWluZW0gYW5kZXJlbiBLbm90ZW4sIHVtIGRpZXNlIHp1IHZlcmJpbmRlbi4nLFxuICAgIGVkaXRFZGdlRGVzY3JpcHRpb246ICdLbGlja2UgYXVmIGRpZSBWZXJiaW5kdW5nc3B1bmt0ZSB1bmQgemllaGUgZGllc2UgYXVmIGVpbmVuIEtub3RlbiwgdW0gc2llIHp1IHZlcmJpbmRlbi4nLFxuICAgIGNyZWF0ZUVkZ2VFcnJvcjogJ0VzIGlzdCBuaWNodCBtXFx4RjZnbGljaCwgS2FudGVuIG1pdCBDbHVzdGVybiB6dSB2ZXJiaW5kZW4uJyxcbiAgICBkZWxldGVDbHVzdGVyRXJyb3I6ICdDbHVzdGVyIGtcXHhGNm5uZW4gbmljaHQgZ2VsXFx4RjZzY2h0IHdlcmRlbi4nLFxuICAgIGVkaXRDbHVzdGVyRXJyb3I6ICdDbHVzdGVyIGtcXHhGNm5uZW4gbmljaHQgZWRpdGllcnQgd2VyZGVuLidcbiAgfTtcbiAgZXhwb3J0c1snZGVfREUnXSA9IGV4cG9ydHNbJ2RlJ107XG5cbiAgLy8gU3BhbmlzaFxuICBleHBvcnRzWydlcyddID0ge1xuICAgIGVkaXQ6ICdFZGl0YXInLFxuICAgIGRlbDogJ0VsaW1pbmFyIHNlbGVjY2lcXHhGM24nLFxuICAgIGJhY2s6ICdcXHhDMXRyYXMnLFxuICAgIGFkZE5vZGU6ICdBXFx4RjFhZGlyIG5vZG8nLFxuICAgIGFkZEVkZ2U6ICdBXFx4RjFhZGlyIGFyaXN0YScsXG4gICAgZWRpdE5vZGU6ICdFZGl0YXIgbm9kbycsXG4gICAgZWRpdEVkZ2U6ICdFZGl0YXIgYXJpc3RhJyxcbiAgICBhZGREZXNjcmlwdGlvbjogJ0hhZ2EgY2xpYyBlbiB1biBsdWdhciB2YWNcXHhFRG8gcGFyYSBjb2xvY2FyIHVuIG51ZXZvIG5vZG8uJyxcbiAgICBlZGdlRGVzY3JpcHRpb246ICdIYWdhIGNsaWMgZW4gdW4gbm9kbyB5IGFycmFzdHJlIGxhIGFyaXN0YSBoYWNpYSBvdHJvIG5vZG8gcGFyYSBjb25lY3Rhcmxvcy4nLFxuICAgIGVkaXRFZGdlRGVzY3JpcHRpb246ICdIYWdhIGNsaWMgZW4gdW4gcHVudG8gZGUgY29udHJvbCB5IGFycmFzdHJlbG8gYSB1biBub2RvIHBhcmEgY29uZWN0YXJsby4nLFxuICAgIGNyZWF0ZUVkZ2VFcnJvcjogJ05vIHNlIHB1ZWRlIGNvbmVjdGFyIHVuYSBhcmlzdGEgYSB1biBncnVwby4nLFxuICAgIGRlbGV0ZUNsdXN0ZXJFcnJvcjogJ05vIGVzIHBvc2libGUgZWxpbWluYXIgZ3J1cG9zLicsXG4gICAgZWRpdENsdXN0ZXJFcnJvcjogJ05vIGVzIHBvc2libGUgZWRpdGFyIGdydXBvcy4nXG4gIH07XG4gIGV4cG9ydHNbJ2VzX0VTJ10gPSBleHBvcnRzWydlcyddO1xuXG4gIC8vSXRhbGlhbm9cbiAgZXhwb3J0c1snaXQnXSA9IHtcbiAgICBlZGl0OiAnTW9kaWZpY2EnLFxuICAgIGRlbDogJ0NhbmNlbGxhIGxhIHNlbGV6aW9uZScsXG4gICAgYmFjazogJ0luZGlldHJvJyxcbiAgICBhZGROb2RlOiAnQWdnaXVuZ2kgdW4gbm9kbycsXG4gICAgYWRkRWRnZTogJ0FnZ2l1bmdpIHVuIHZlcnRpY2UnLFxuICAgIGVkaXROb2RlOiAnTW9kaWZpY2EgaWwgbm9kbycsXG4gICAgZWRpdEVkZ2U6ICdNb2RpZmljYSBpbCB2ZXJ0aWNlJyxcbiAgICBhZGREZXNjcmlwdGlvbjogJ0NsaWNjYSBwZXIgYWdnaXVuZ2VyZSB1biBudW92byBub2RvJyxcbiAgICBlZGdlRGVzY3JpcHRpb246ICdDbGljY2Egc3UgdW4gbm9kbyBlIHRyYXNjaW5hbG8gYWQgdW4gYWx0cm8gbm9kbyBwZXIgY29ubmV0dGVybGkuJyxcbiAgICBlZGl0RWRnZURlc2NyaXB0aW9uOiAnQ2xpY2NhIHN1aSBQdW50aSBkaSBjb250cm9sbG8gZSB0cmFzY2luYWxpIGFkIHVuIG5vZG8gcGVyIGNvbm5ldHRlcmxpLicsXG4gICAgY3JlYXRlRWRnZUVycm9yOiAnTm9uIHNpIHBvc3Nvbm8gY29sbGVnYXJlIHZlcnRpY2kgYWQgdW4gY2x1c3RlcicsXG4gICAgZGVsZXRlQ2x1c3RlckVycm9yOiAnSSBjbHVzdGVyIG5vbiBwb3Nzb25vIGVzc2VyZSBjYW5jZWxsYXRpJyxcbiAgICBlZGl0Q2x1c3RlckVycm9yOiAnSSBjbHVzdGVycyBub24gcG9zc29ubyBlc3NlcmUgbW9kaWZpY2F0aS4nXG4gIH07XG4gIGV4cG9ydHNbJ2l0X0lUJ10gPSBleHBvcnRzWydpdCddO1xuXG4gIC8vIER1dGNoXG4gIGV4cG9ydHNbJ25sJ10gPSB7XG4gICAgZWRpdDogJ1dpanppZ2VuJyxcbiAgICBkZWw6ICdTZWxlY3RpZSB2ZXJ3aWpkZXJlbicsXG4gICAgYmFjazogJ1RlcnVnJyxcbiAgICBhZGROb2RlOiAnTm9kZSB0b2V2b2VnZW4nLFxuICAgIGFkZEVkZ2U6ICdMaW5rIHRvZXZvZWdlbicsXG4gICAgZWRpdE5vZGU6ICdOb2RlIHdpanppZ2VuJyxcbiAgICBlZGl0RWRnZTogJ0xpbmsgd2lqemlnZW4nLFxuICAgIGFkZERlc2NyaXB0aW9uOiAnS2xpayBvcCBlZW4gbGVlZyBnZWJpZWQgb20gZWVuIG5pZXV3ZSBub2RlIHRlIG1ha2VuLicsXG4gICAgZWRnZURlc2NyaXB0aW9uOiAnS2xpayBvcCBlZW4gbm9kZSBlbiBzbGVlcCBkZSBsaW5rIG5hYXIgZWVuIGFuZGVyZSBub2RlIG9tIHplIHRlIHZlcmJpbmRlbi4nLFxuICAgIGVkaXRFZGdlRGVzY3JpcHRpb246ICdLbGlrIG9wIGRlIHZlcmJpbmRpbmdzcHVudGVuIGVuIHNsZWVwIHplIG5hYXIgZWVuIG5vZGUgb20gZGFhcm1lZSB0ZSB2ZXJiaW5kZW4uJyxcbiAgICBjcmVhdGVFZGdlRXJyb3I6ICdLYW4gZ2VlbiBsaW5rIG1ha2VuIG5hYXIgZWVuIGNsdXN0ZXIuJyxcbiAgICBkZWxldGVDbHVzdGVyRXJyb3I6ICdDbHVzdGVycyBrdW5uZW4gbmlldCB3b3JkZW4gdmVyd2lqZGVyZC4nLFxuICAgIGVkaXRDbHVzdGVyRXJyb3I6ICdDbHVzdGVycyBrdW5uZW4gbmlldCB3b3JkZW4gYWFuZ2VwYXN0LidcbiAgfTtcbiAgZXhwb3J0c1snbmxfTkwnXSA9IGV4cG9ydHNbJ25sJ107XG4gIGV4cG9ydHNbJ25sX0JFJ10gPSBleHBvcnRzWydubCddO1xuXG4gIC8vIFBvcnR1Z3Vlc2UgQnJhemlsXG4gIGV4cG9ydHNbJ3B0LWJyJ10gPSB7XG4gICAgZWRpdDogJ0VkaXRhcicsXG4gICAgZGVsOiAnUmVtb3ZlciBzZWxlY2lvbmFkbycsXG4gICAgYmFjazogJ1ZvbHRhcicsXG4gICAgYWRkTm9kZTogJ0FkaWNpb25hciBuw7MnLFxuICAgIGFkZEVkZ2U6ICdBZGljaW9uYXIgYXJlc3RhJyxcbiAgICBlZGl0Tm9kZTogJ0VkaXRhciBuw7MnLFxuICAgIGVkaXRFZGdlOiAnRWRpdGFyIGFyZXN0YScsXG4gICAgYWRkRGVzY3JpcHRpb246ICdDbGlxdWUgZW0gdW0gZXNwYcOnbyBlbSBicmFuY28gcGFyYSBhZGljaW9uYXIgdW0gbm92byBuw7MnLFxuICAgIGVkZ2VEZXNjcmlwdGlvbjogJ0NsaXF1ZSBlbSB1bSBuw7MgZSBhcnJhc3RlIGEgYXJlc3RhIGF0w6kgb3V0cm8gbsOzIHBhcmEgY29uZWN0w6EtbG9zJyxcbiAgICBlZGl0RWRnZURlc2NyaXB0aW9uOiAnQ2xpcXVlIG5vcyBwb250b3MgZGUgY29udHJvbGUgZSBvcyBhcnJhc3RlIHBhcmEgdW0gbsOzIHBhcmEgY29uZWN0w6EtbG9zJyxcbiAgICBjcmVhdGVFZGdlRXJyb3I6ICdOw6NvIGZvaSBwb3Nzw612ZWwgbGlua2FyIGFyZXN0YXMgYSB1bSBjbHVzdGVyLicsXG4gICAgZGVsZXRlQ2x1c3RlckVycm9yOiAnQ2x1c3RlcnMgbsOjbyBwdWRlcmFtIHNlciByZW1vdmlkb3MuJyxcbiAgICBlZGl0Q2x1c3RlckVycm9yOiAnQ2x1c3RlcnMgbsOjbyBwdWRlcmFtIHNlciBlZGl0YWRvcy4nXG4gIH07XG4gIGV4cG9ydHNbJ3B0LUJSJ10gPSBleHBvcnRzWydwdC1iciddO1xuICBleHBvcnRzWydwdF9CUiddID0gZXhwb3J0c1sncHQtYnInXTtcbiAgZXhwb3J0c1sncHRfYnInXSA9IGV4cG9ydHNbJ3B0LWJyJ107XG5cbiAgLy8gUnVzc2lhblxuICBleHBvcnRzWydydSddID0ge1xuICAgIGVkaXQ6ICfQoNC10LTQsNC60YLQuNGA0L7QstCw0YLRjCcsXG4gICAgZGVsOiAn0KPQtNCw0LvQuNGC0Ywg0LLRi9Cx0YDQsNC90L3QvtC1JyxcbiAgICBiYWNrOiAn0J3QsNC30LDQtCcsXG4gICAgYWRkTm9kZTogJ9CU0L7QsdCw0LLQuNGC0Ywg0YPQt9C10LsnLFxuICAgIGFkZEVkZ2U6ICfQlNC+0LHQsNCy0LjRgtGMINGA0LXQsdGA0L4nLFxuICAgIGVkaXROb2RlOiAn0KDQtdC00LDQutGC0LjRgNC+0LLQsNGC0Ywg0YPQt9C10LsnLFxuICAgIGVkaXRFZGdlOiAn0KDQtdC00LDQutGC0LjRgNC+0LLQsNGC0Ywg0YDQtdCx0YDQvicsXG4gICAgYWRkRGVzY3JpcHRpb246ICfQmtC70LjQutC90LjRgtC1INCyINGB0LLQvtCx0L7QtNC90L7QtSDQvNC10YHRgtC+LCDRh9GC0L7QsdGLINC00L7QsdCw0LLQuNGC0Ywg0L3QvtCy0YvQuSDRg9C30LXQuy4nLFxuICAgIGVkZ2VEZXNjcmlwdGlvbjogJ9Ca0LvQuNC60L3QuNGC0LUg0L3QsCDRg9C30LXQuyDQuCDQv9GA0L7RgtGP0L3QuNGC0LUg0YDQtdCx0YDQviDQuiDQtNGA0YPQs9C+0LzRgyDRg9C30LvRgywg0YfRgtC+0LHRiyDRgdC+0LXQtNC40L3QuNGC0Ywg0LjRhS4nLFxuICAgIGVkaXRFZGdlRGVzY3JpcHRpb246ICfQmtC70LjQutC90LjRgtC1INC90LAg0LrQvtC90YLRgNC+0LvRjNC90YvQtSDRgtC+0YfQutC4INC4INC/0LXRgNC10YLQsNGJ0LjRgtC1INC40YUg0LIg0YPQt9C10LssINGH0YLQvtCx0Ysg0L/QvtC00LrQu9GO0YfQuNGC0YzRgdGPINC6INC90LXQvNGDLicsXG4gICAgY3JlYXRlRWRnZUVycm9yOiAn0J3QtdCy0L7Qt9C80L7QttC90L4g0YHQvtC10LTQuNC90LjRgtGMINGA0LXQsdGA0LAg0LIg0LrQu9Cw0YHRgtC10YAuJyxcbiAgICBkZWxldGVDbHVzdGVyRXJyb3I6ICfQmtC70LDRgdGC0LXRgNGLINC90LUg0LzQvtCz0YPRgiDQsdGL0YLRjCDRg9C00LDQu9C10L3RiycsXG4gICAgZWRpdENsdXN0ZXJFcnJvcjogJ9Ca0LvQsNGB0YLQtdGA0Ysg0L3QtdC00L7RgdGC0YPQv9C90Ysg0LTQu9GPINGA0LXQtNCw0LrRgtC40YDQvtCy0LDQvdC40Y8uJ1xuICB9O1xuICBleHBvcnRzWydydV9SVSddID0gZXhwb3J0c1sncnUnXTtcblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuOyJdfQ==
